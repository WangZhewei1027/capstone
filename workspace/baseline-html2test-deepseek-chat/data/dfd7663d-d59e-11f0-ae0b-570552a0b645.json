{
  "id": "dfd7663d-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:56.065Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "# Dijkstra's Algorithm Visualization\n\nI've created an interactive visualization tool that demonstrates Dijkstra's algorithm step by step. This implementation allows you to see how the algorithm finds the shortest path between nodes in a graph.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        \n        body {\n            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n            color: #e6e6e6;\n            min-height: 100vh;\n            padding: 20px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        \n        .container {\n            width: 100%;\n            max-width: 1200px;\n            display: flex;\n            flex-direction: column;\n            gap: 25px;\n        }\n        \n        header {\n            text-align: center;\n            padding: 20px 0;\n            background: rgba(0, 0, 0, 0.3);\n            border-radius: 15px;\n            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);\n            margin-bottom: 10px;\n        }\n        \n        h1 {\n            color: #4cc9f0;\n            font-size: 2.5rem;\n            text-shadow: 0 0 10px rgba(76, 201, 240, 0.7);\n            margin-bottom: 10px;\n        }\n        \n        .description {\n            max-width: 800px;\n            margin: 0 auto;\n            line-height: 1.6;\n            font-size: 1.1rem;\n        }\n        \n        .visualization-container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 25px;\n        }\n        \n        .controls {\n            flex: 1;\n            min-width: 300px;\n            background: rgba(30, 30, 46, 0.8);\n            border-radius: 15px;\n            padding: 20px;\n            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);\n        }\n        \n        .control-group {\n            margin-bottom: 20px;\n        }\n        \n        h2 {\n            color: #f72585;\n            font-size: 1.5rem;\n            margin-bottom: 15px;\n            border-bottom: 2px solid #f72585;\n            padding-bottom: 5px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 8px;\n            font-weight: 500;\n        }\n        \n        input, select, button {\n            width: 100%;\n            padding: 12px;\n            margin-bottom: 15px;\n            border: none;\n            border-radius: 8px;\n            background: rgba(255, 255, 255, 0.1);\n            color: white;\n            font-size: 1rem;\n        }\n        \n        button {\n            background: linear-gradient(135deg, #f72585 0%, #4361ee 100%);\n            color: white;\n            font-weight: bold;\n            cursor: pointer;\n            transition: transform 0.2s, box-shadow 0.2s;\n        }\n        \n        button:hover {\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(247, 37, 133, 0.4);\n        }\n        \n        button:active {\n            transform: translateY(0);\n        }\n        \n        .canvas-container {\n            flex: 2;\n            min-width: 600px;\n            background: rgba(30, 30, 46, 0.8);\n            border-radius: 15px;\n            padding: 20px;\n            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }\n        \n        canvas {\n            background: #1a1a2e;\n            border-radius: 10px;\n            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);\n        }\n        \n        .information {\n            background: rgba(30, 30, 46, 0.8);\n            border-radius: 15px;\n            padding: 20px;\n            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);\n        }\n        \n        .step-info {\n            margin-top: 15px;\n            padding: 15px;\n            background: rgba(0, 0, 0, 0.3);\n            border-radius: 10px;\n            font-family: monospace;\n            min-height: 100px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .nodes {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            margin-top: 10px;\n        }\n        \n        .node-example {\n            display: flex;\n            align-items: center;\n            margin-right: 15px;\n        }\n        \n        .color-box {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n            margin-right: 6px;\n        }\n        \n        .unknown { background-color: #4a4a6a; }\n        .visited { background-color: #4361ee; }\n        .current { background-color: #f72585; }\n        .final-path { background-color: #4cc9f0; }\n        \n        .instructions {\n            padding: 15px;\n            background: rgba(0, 0, 0, 0.3);\n            border-radius: 10px;\n            margin-top: 15px;\n            line-height: 1.5;\n        }\n        \n        @media (max-width: 900px) {\n            .visualization-container {\n                flex-direction: column;\n            }\n            \n            .canvas-container, .controls {\n                min-width: 100%;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Dijkstra's Algorithm</h1>\n            <p class=\"description\">\n                Dijkstra's algorithm is a popular algorithm for finding the shortest paths between nodes in a graph. \n                This visualization demonstrates how the algorithm works step by step.\n            </p>\n        </header>\n        \n        <div class=\"visualization-container\">\n            <div class=\"controls\">\n                <div class=\"control-group\">\n                    <h2>Graph Configuration</h2>\n                    <label for=\"graphType\">Graph Type:</label>\n                    <select id=\"graphType\">\n                        <option value=\"predefined\">Predefined Graph</option>\n                        <option value=\"random\">Random Graph</option>\n                    </select>\n                    \n                    <label for=\"startNode\">Start Node:</label>\n                    <input type=\"number\" id=\"startNode\" min=\"0\" max=\"6\" value=\"0\">\n                    \n                    <label for=\"endNode\">End Node:</label>\n                    <input type=\"number\" id=\"endNode\" min=\"0\" max=\"6\" value=\"6\">\n                    \n                    <button id=\"resetBtn\">Reset Graph</button>\n                </div>\n                \n                <div class=\"control-group\">\n                    <h2>Algorithm Controls</h2>\n                    <button id=\"stepBtn\">Next Step</button>\n                    <button id=\"runBtn\">Run Algorithm</button>\n                    <button id=\"pauseBtn\">Pause</button>\n                </div>\n                \n                <div class=\"control-group\">\n                    <h2>Node Legend</h2>\n                    <div class=\"nodes\">\n                        <div class=\"node-example\">\n                            <div class=\"color-box unknown\"></div>\n                            <span>Unvisited</span>\n                        </div>\n                        <div class=\"node-example\">\n                            <div class=\"color-box visited\"></div>\n                            <span>Visited</span>\n                        </div>\n                        <div class=\"node-example\">\n                            <div class=\"color-box current\"></div>\n                            <span>Current</span>\n                        </div>\n                        <div class=\"node-example\">\n                            <div class=\"color-box final-path\"></div>\n                            <span>Shortest Path</span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"canvas-container\">\n                <canvas id=\"graphCanvas\" width=\"600\" height=\"500\"></canvas>\n            </div>\n        </div>\n        \n        <div class=\"information\">\n            <h2>Algorithm Steps</h2>\n            <div class=\"step-info\" id=\"stepInfo\">\n                <p>Click \"Next Step\" to start the visualization.</p>\n            </div>\n            \n            <div class=\"instructions\">\n                <h3>How Dijkstra's Algorithm Works:</h3>\n                <ol>\n                    <li>Initialize all node distances as infinity, except the start node (distance 0)</li>\n                    <li>Select the unvisited node with the smallest known distance</li>\n                    <li>For the current node, examine its unvisited neighbors</li>\n                    <li>Calculate their tentative distances through the current node</li>\n                    <li>If the calculated distance is less than the known distance, update it</li>\n                    <li>Mark the current node as visited</li>\n                    <li>Repeat until the destination node is visited or all nodes are visited</li>\n                    <li>Backtrack from the end node to find the shortest path</li>\n                </ol>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Canvas setup\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        const stepInfo = document.getElementById('stepInfo');\n        \n        // Graph configuration\n        let graph = {\n            nodes: [],\n            edges: [],\n            startNode: 0,\n            endNode: 6\n        };\n        \n        // Algorithm state\n        let algorithmState = {\n            distances: [],\n            previous: [],\n            visited: [],\n            currentStep: 0,\n            isRunning: false,\n            isCompleted: false,\n            currentNode: null,\n            finalPath: []\n        };\n        \n        // Initialize the graph\n        function initializeGraph() {\n            // Create nodes arranged in a circle\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const radius = 180;\n            const nodeCount = 7;\n            \n            graph.nodes = [];\n            for (let i = 0; i < nodeCount; i++) {\n                const angle = (i / nodeCount) * 2 * Math.PI - Math.PI / 2;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                graph.nodes.push({ id: i, x: x, y: y });\n            }\n            \n            // Create edges with weights\n            graph.edges = [\n                { from: 0, to: 1, weight: 2 },\n                { from: 0, to: 2, weight: 6 },\n                { from: 1, to: 3, weight: 5 },\n                { from: 2, to: 3, weight: 8 },\n                { from: 3, to: 4, weight: 10 },\n                { from: 3, to: 5, weight: 15 },\n                { from: 4, to: 6, weight: 2 },\n                { from: 5, to: 6, weight: 6 },\n                { from: 4, to: 5, weight: 6 },\n                { from: 1, to: 2, weight: 3 }\n            ];\n            \n            resetAlgorithm();\n        }\n        \n        // Reset the algorithm to initial state\n        function resetAlgorithm() {\n            const startNode = parseInt(document.getElementById('startNode').value) || 0;\n            const endNode = parseInt(document.getElementById('endNode').value) || 6;\n            \n            graph.startNode = Math.max(0, Math.min(startNode, graph.nodes.length - 1));\n            graph.endNode = Math.max(0, Math.min(endNode, graph.nodes.length - 1));\n            \n            algorithmState = {\n                distances: new Array(graph.nodes.length).fill(Infinity),\n                previous: new Array(graph.nodes.length).fill(null),\n                visited: new Array(graph.nodes.length).fill(false),\n                currentStep: 0,\n                isRunning: false,\n                isCompleted: false,\n                currentNode: null,\n                finalPath: []\n            };\n            \n            algorithmState.distances[graph.startNode] = 0;\n            updateStepInfo(\"Algorithm reset. Ready to start.\");\n            drawGraph();\n        }\n        \n        // Draw the graph on the canvas\n        function drawGraph() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            ctx.strokeStyle = '#4a4a6a';\n            ctx.lineWidth = 2;\n            ctx.font = '14px Arial';\n            ctx.fillStyle = '#e6e6e6';\n            \n            graph.edges.forEach(edge => {\n                const fromNode = graph.nodes[edge.from];\n                const toNode = graph.nodes[edge.to];\n                \n                // Draw line\n                ctx.beginPath();\n                ctx.moveTo(fromNode.x, fromNode.y);\n                ctx.lineTo(toNode.x, toNode.y);\n                ctx.stroke();\n                \n                // Draw weight\n                const midX = (fromNode.x + toNode.x) / 2;\n                const midY = (fromNode.y + toNode.y) / 2;\n                \n                ctx.fillStyle = '#1a1a2e';\n                ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                ctx.fillStyle = '#e6e6e6';\n                ctx.fillText(edge.weight, midX - 8, midY + 5);\n            });\n            \n            // Draw nodes\n            graph.nodes.forEach((node, index) => {\n                let nodeColor = '#4a4a6a'; // Default (unvisited)\n                \n                if (algorithmState.isCompleted && algorithmState.finalPath.includes(index)) {\n                    nodeColor = '#4cc9f0'; // Final path\n                } else if (index === algorithmState.currentNode) {\n                    nodeColor = '#f72585'; // Current node\n                } else if (algorithmState.visited[index]) {\n                    nodeColor = '#4361ee'; // Visited node\n                } else if (index === graph.startNode) {\n                    nodeColor = '#4cc9f0'; // Start node\n                } else if (index === graph.endNode) {\n                    nodeColor = '#4cc9f0'; // End node\n                }\n                \n                // Draw node\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);\n                ctx.fillStyle = nodeColor;\n                ctx.fill();\n                ctx.strokeStyle = '#e6e6e6';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw node ID\n                ctx.fillStyle = '#e6e6e6';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(node.id, node.x, node.y);\n                \n                // Draw distance if known\n                if (algorithmState.distances[index] !== Infinity) {\n                    ctx.fillStyle = '#e6e6e6';\n                    ctx.font = '12px Arial';\n                    ctx.fillText(algorithmState.distances[index], node.x, node.y - 30);\n                }\n            });\n        }\n        \n        // Update the step information display\n        function updateStepInfo(message) {\n            stepInfo.innerHTML = `<p>Step ${algorithmState.currentStep}: ${message}</p>`;\n        }\n        \n        // Perform one step of the algorithm\n        function algorithmStep() {\n            if (algorithmState.isCompleted) {\n                updateStepInfo(\"Algorithm completed. Shortest path found.\");\n                return;\n            }\n            \n            algorithmState.currentStep++;\n            \n            // Find the unvisited node with the smallest distance\n            let minDistance = Infinity;\n            let minIndex = -1;\n            \n            for (let i = 0; i < graph.nodes.length; i++) {\n                if (!algorithmState.visited[i] && algorithmState.distances[i] < minDistance) {\n                    minDistance = algorithmState.distances[i];\n                    minIndex = i;\n                }\n            }\n            \n            // If no node found or destination reached\n            if (minIndex === -1) {\n                algorithmState.isCompleted = true;\n                updateStepInfo(\"No path exists from start to end node.\");\n                drawGraph();\n                return;\n            }\n            \n            algorithmState.currentNode = minIndex;\n            algorithmState.visited[minIndex] = true;\n            \n            updateStepInfo(`Visiting node ${minIndex} with distance ${algorithmState.distances[minIndex]}`);\n            \n            // If we reached the destination\n            if (minIndex === graph.endNode) {\n                algorithmState.isCompleted = true;\n                \n                // Reconstruct the path\n                let path = [];\n                let current = graph.endNode;\n                \n                while (current !== null) {\n                    path.unshift(current);\n                    current = algorithmState.previous[current];\n                }\n                \n                algorithmState.finalPath = path;\n                \n                updateStepInfo(`Shortest path found: ${path.join(' → ')} with total distance ${algorithmState.distances[graph.endNode]}`);\n                drawGraph();\n                return;\n            }\n            \n            // Update distances to neighbors\n            graph.edges.forEach(edge => {\n                if (edge.from === minIndex && !algorithmState.visited[edge.to]) {\n                    const newDistance = algorithmState.distances[minIndex] + edge.weight;\n                    \n                    if (newDistance < algorithmState.distances[edge.to]) {\n                        algorithmState.distances[edge.to] = newDistance;\n                        algorithmState.previous[edge.to] = minIndex;\n                        updateStepInfo(updateStepInfo.innerHTML + `<br>Updated node ${edge.to} distance to ${newDistance}`);\n                    }\n                }\n                \n                // For undirected graph, check both directions\n                if (edge.to === minIndex && !algorithmState.visited[edge.from]) {\n                    const newDistance = algorithmState.distances[minIndex] + edge.weight;\n"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}