{
  "id": "6e0a0757-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:15.942Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background-color: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            margin: 20px 0;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 5px;\n        }\n        .control-group {\n            margin: 10px 0;\n        }\n        label {\n            margin-right: 10px;\n        }\n        input, button {\n            padding: 5px 10px;\n            margin: 5px;\n        }\n        canvas {\n            border: 1px solid #ccc;\n            background-color: white;\n            display: block;\n            margin: 0 auto;\n        }\n        .info {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #e9ecef;\n            border-radius: 5px;\n        }\n        .cluster-color {\n            display: inline-block;\n            width: 20px;\n            height: 20px;\n            margin-right: 5px;\n            border: 1px solid #ccc;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>K-Means Clustering Visualization</h1>\n        \n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <label for=\"kValue\">Number of Clusters (K):</label>\n                <input type=\"number\" id=\"kValue\" min=\"1\" max=\"10\" value=\"3\">\n                <button id=\"resetBtn\">Reset Points</button>\n                <button id=\"clusterBtn\">Run K-Means</button>\n                <button id=\"stepBtn\">Step Through</button>\n            </div>\n            <div class=\"control-group\">\n                <label for=\"pointCount\">Number of Points:</label>\n                <input type=\"number\" id=\"pointCount\" min=\"10\" max=\"500\" value=\"100\">\n            </div>\n        </div>\n\n        <canvas id=\"clusterCanvas\" width=\"800\" height=\"500\"></canvas>\n\n        <div class=\"info\">\n            <h3>How K-Means Works:</h3>\n            <ol>\n                <li>Randomly initialize K cluster centroids</li>\n                <li>Assign each point to the nearest centroid</li>\n                <li>Recalculate centroid positions based on assigned points</li>\n                <li>Repeat steps 2-3 until convergence</li>\n            </ol>\n            <p><strong>Current Iteration:</strong> <span id=\"iteration\">0</span></p>\n            <p><strong>Cluster Summary:</strong> <span id=\"clusterSummary\"></span></p>\n        </div>\n    </div>\n\n    <script>\n        class KMeans {\n            constructor(k, points) {\n                this.k = k;\n                this.points = points;\n                this.centroids = [];\n                this.clusters = [];\n                this.iterations = 0;\n                this.colors = this.generateColors(k);\n            }\n\n            generateColors(k) {\n                const colors = [];\n                for (let i = 0; i < k; i++) {\n                    const hue = (i * 360 / k) % 360;\n                    colors.push(`hsl(${hue}, 70%, 50%)`);\n                }\n                return colors;\n            }\n\n            initializeCentroids() {\n                this.centroids = [];\n                // Randomly select K points as initial centroids\n                const shuffled = [...this.points].sort(() => 0.5 - Math.random());\n                this.centroids = shuffled.slice(0, this.k).map(p => ({ x: p.x, y: p.y }));\n            }\n\n            calculateDistance(a, b) {\n                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n            }\n\n            assignPointsToClusters() {\n                this.clusters = Array(this.k).fill().map(() => []);\n                \n                this.points.forEach(point => {\n                    let minDistance = Infinity;\n                    let closestCentroid = 0;\n                    \n                    this.centroids.forEach((centroid, index) => {\n                        const distance = this.calculateDistance(point, centroid);\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            closestCentroid = index;\n                        }\n                    });\n                    \n                    point.cluster = closestCentroid;\n                    this.clusters[closestCentroid].push(point);\n                });\n            }\n\n            updateCentroids() {\n                let moved = false;\n                \n                this.centroids.forEach((centroid, index) => {\n                    if (this.clusters[index].length === 0) return;\n                    \n                    const newX = this.clusters[index].reduce((sum, p) => sum + p.x, 0) / this.clusters[index].length;\n                    const newY = this.clusters[index].reduce((sum, p) => sum + p.y, 0) / this.clusters[index].length;\n                    \n                    if (Math.abs(centroid.x - newX) > 0.1 || Math.abs(centroid.y - newY) > 0.1) {\n                        moved = true;\n                    }\n                    \n                    centroid.x = newX;\n                    centroid.y = newY;\n                });\n                \n                return moved;\n            }\n\n            runStep() {\n                if (this.iterations === 0) {\n                    this.initializeCentroids();\n                }\n                \n                this.assignPointsToClusters();\n                const moved = this.updateCentroids();\n                this.iterations++;\n                \n                return moved;\n            }\n\n            run(maxIterations = 100) {\n                this.initializeCentroids();\n                this.iterations = 0;\n                \n                for (let i = 0; i < maxIterations; i++) {\n                    this.assignPointsToClusters();\n                    const moved = this.updateCentroids();\n                    this.iterations++;\n                    \n                    if (!moved) break;\n                }\n            }\n        }\n\n        class KMeansVisualizer {\n            constructor(canvasId) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.points = [];\n                this.kmeans = null;\n                this.animationId = null;\n                \n                this.setupEventListeners();\n                this.generateRandomPoints(100);\n            }\n\n            setupEventListeners() {\n                document.getElementById('resetBtn').addEventListener('click', () => {\n                    const pointCount = parseInt(document.getElementById('pointCount').value);\n                    this.generateRandomPoints(pointCount);\n                    this.draw();\n                });\n\n                document.getElementById('clusterBtn').addEventListener('click', () => {\n                    this.runClustering();\n                });\n\n                document.getElementById('stepBtn').addEventListener('click', () => {\n                    this.stepClustering();\n                });\n\n                this.canvas.addEventListener('click', (e) => {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    this.addPoint(x, y);\n                    this.draw();\n                });\n            }\n\n            generateRandomPoints(count) {\n                this.points = [];\n                for (let i = 0; i < count; i++) {\n                    this.points.push({\n                        x: Math.random() * (this.canvas.width - 40) + 20,\n                        y: Math.random() * (this.canvas.height - 40) + 20,\n                        cluster: -1\n                    });\n                }\n                this.kmeans = null;\n                this.updateIterationCount(0);\n            }\n\n            addPoint(x, y) {\n                this.points.push({ x, y, cluster: -1 });\n            }\n\n            runClustering() {\n                const k = parseInt(document.getElementById('kValue').value);\n                this.kmeans = new KMeans(k, this.points);\n                this.kmeans.run();\n                this.draw();\n                this.updateIterationCount(this.kmeans.iterations);\n                this.updateClusterSummary();\n            }\n\n            stepClustering() {\n                const k = parseInt(document.getElementById('kValue').value);\n                \n                if (!this.kmeans || this.kmeans.k !== k) {\n                    this.kmeans = new KMeans(k, this.points);\n                }\n                \n                const moved = this.kmeans.runStep();\n                this.draw();\n                this.updateIterationCount(this.kmeans.iterations);\n                this.updateClusterSummary();\n                \n                if (!moved) {\n                    alert('Clustering converged!');\n                }\n            }\n\n            draw() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw points\n                this.points.forEach(point => {\n                    this.ctx.beginPath();\n                    this.ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);\n                    \n                    if (this.kmeans && point.cluster !== -1) {\n                        this.ctx.fillStyle = this.kmeans.colors[point.cluster];\n                    } else {\n                        this.ctx.fillStyle = '#666';\n                    }\n                    \n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#333';\n                    this.ctx.lineWidth = 1;\n                    this.ctx.stroke();\n                });\n                \n                // Draw centroids if clustering has been run\n                if (this.kmeans) {\n                    this.kmeans.centroids.forEach((centroid, index) => {\n                        this.ctx.beginPath();\n                        this.ctx.arc(centroid.x, centroid.y, 8, 0, 2 * Math.PI);\n                        this.ctx.fillStyle = this.kmeans.colors[index];\n                        this.ctx.fill();\n                        this.ctx.strokeStyle = '#000';\n                        this.ctx.lineWidth = 2;\n                        this.ctx.stroke();\n                        \n                        // Draw cross inside centroid\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(centroid.x - 5, centroid.y);\n                        this.ctx.lineTo(centroid.x + 5, centroid.y);\n                        this.ctx.moveTo(centroid.x, centroid.y - 5);\n                        this.ctx.lineTo(centroid.x, centroid.y + 5);\n                        this.ctx.strokeStyle = '#fff';\n                        this.ctx.lineWidth = 2;\n                        this.ctx.stroke();\n                    });\n                }\n            }\n\n            updateIterationCount(iterations) {\n                document.getElementById('iteration').textContent = iterations;\n            }\n\n            updateClusterSummary() {\n                if (!this.kmeans) return;\n                \n                const summary = this.kmeans.clusters.map((cluster, index) => {\n                    return `<span class=\"cluster-color\" style=\"background-color: ${this.kmeans.colors[index]}\"></span>Cluster ${index + 1}: ${cluster.length} points`;\n                }).join(' | ');\n                \n                document.getElementById('clusterSummary').innerHTML = summary;\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        window.addEventListener('load', () => {\n            const visualizer = new KMeansVisualizer('clusterCanvas');\n            visualizer.draw();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}