{
  "id": "dfd78d40-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:17.014Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Algorithm</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n        }\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);\n            min-height: 100vh;\n            padding: 20px;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 10px;\n            box-shadow: 0 5px 15px rgba(0,0,0,0.1);\n            overflow: hidden;\n        }\n        .header {\n            background: #4a6fa5;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }\n        .content {\n            padding: 20px;\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n        }\n        .visualization {\n            flex: 1;\n            min-width: 300px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            padding: 15px;\n            background: #f9f9f9;\n        }\n        .controls {\n            flex: 1;\n            min-width: 300px;\n            padding: 15px;\n        }\n        h1 {\n            margin-bottom: 10px;\n        }\n        h2 {\n            margin-bottom: 15px;\n            color: #4a6fa5;\n            border-bottom: 2px solid #eee;\n            padding-bottom: 5px;\n        }\n        p {\n            margin-bottom: 15px;\n        }\n        textarea {\n            width: 100%;\n            height: 120px;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            resize: vertical;\n            font-family: monospace;\n            margin-bottom: 15px;\n        }\n        button {\n            background: #4a6fa5;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background 0.3s;\n            margin-right: 10px;\n            margin-bottom: 10px;\n        }\n        button:hover {\n            background: #3a5a80;\n        }\n        button:disabled {\n            background: #aaa;\n            cursor: not-allowed;\n        }\n        .graph-display {\n            height: 300px;\n            border: 1px solid #ddd;\n            margin-bottom: 15px;\n            background: white;\n            overflow: auto;\n            padding: 15px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }\n        .result-display {\n            min-height: 200px;\n            border: 1px solid #ddd;\n            padding: 15px;\n            background: white;\n            border-radius: 4px;\n        }\n        .step-display {\n            margin-top: 10px;\n            font-size: 0.9em;\n            color: #666;\n        }\n        .vertex {\n            display: inline-block;\n            width: 40px;\n            height: 40px;\n            line-height: 40px;\n            text-align: center;\n            border-radius: 50%;\n            background: #4a6fa5;\n            color: white;\n            margin: 5px;\n            font-weight: bold;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n        .vertex.visited {\n            background: #5cb85c;\n        }\n        .vertex.current {\n            background: #f0ad4e;\n            transform: scale(1.1);\n        }\n        .edge {\n            stroke: #4a6fa5;\n            stroke-width: 2;\n            fill: none;\n        }\n        .arrow {\n            stroke: #4a6fa5;\n            stroke-width: 2;\n            fill: #4a6fa5;\n        }\n        .topological-order {\n            margin-bottom: 10px;\n            font-weight: bold;\n        }\n        .step-controls {\n            display: flex;\n            justify-content: space-between;\n            margin-top: 15px;\n        }\n        svg {\n            width: 100%;\n            height: 100%;\n        }\n        .node {\n            fill: #4a6fa5;\n            stroke: #fff;\n            stroke-width: 2;\n        }\n        .node-label {\n            fill: white;\n            font-weight: bold;\n            text-anchor: middle;\n            dominant-baseline: central;\n        }\n        .visited-node {\n            fill: #5cb85c;\n        }\n        .current-node {\n            fill: #f0ad4e;\n        }\n        input {\n            width: 100%;\n            padding: 8px;\n            margin-bottom: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .example-graphs {\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n            gap: 10px;\n            margin-bottom: 15px;\n        }\n        .example-btn {\n            background: #f8f9fa;\n            border: 1px solid #ddd;\n            color: #333;\n            padding: 8px;\n            text-align: left;\n        }\n        .example-btn:hover {\n            background: #e9ecef;\n        }\n        .predefined-graphs {\n            margin-bottom: 15px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Topological Sort Algorithm</h1>\n            <p>Visualize and understand topological sorting on directed acyclic graphs (DAG)</p>\n        </div>\n        \n        <div class=\"content\">\n            <div class=\"visualization\">\n                <h2>Graph Visualization</h2>\n                <div class=\"graph-display\" id=\"graphDisplay\">\n                    <svg id=\"graphCanvas\" width=\"400\" height=\"280\"></svg>\n                </div>\n                \n                <h2>Topological Order</h2>\n                <div class=\"result-display\" id=\"resultDisplay\">\n                    <p>Run the algorithm to see the topological order</p>\n                </div>\n                \n                <div class=\"step-display\" id=\"stepDisplay\">\n                    <p>No steps yet. Run the algorithm to see the steps.</p>\n                </div>\n            </div>\n            \n            <div class=\"controls\">\n                <h2>Algorithm Controls</h2>\n                \n                <div class=\"predefined-graphs\">\n                    <p>Try a predefined graph:</p>\n                    <div class=\"example-graphs\">\n                        <button class=\"example-btn\" onclick=\"loadExampleGraph('simple')\">Simple Linear DAG:</button>\n                        <button class=\"example-btn\" onclick=\"loadExampleGraph('complex')\">Complex DAG:</button>\n                        <button class=\"example-btn\" onclick=\"loadExampleGraph('tree')\">Tree-like DAG:</button>\n                        <button class=\"example-btn\" onclick=\"loadExampleGraph('course')\">Course Dependencies:</button>\n                    </div>\n                </div>\n                \n                <p>Enter graph edges below as \"A->B\" (one per line)</p>\n                <textarea id=\"graphInput\" placeholder=\"A->B\nB->C\nA->D\nD->C\"></textarea>\n                \n                <button onclick=\"validateAndParseGraph()\">Parse Graph</button>\n                <button id=\"runAlgorithmBtn\" onclick=\"runAlgorithm()\" disabled>Run Algorithm</button>\n                <button id=\"stepBtn\" onclick=\"stepAlgorithm()\" disabled>Step Forward</button>\n                <button onclick=\"resetAlgorithm()\">Reset</button>\n                \n                <h2>About Topological Sort</h2>\n                <p>Topological sort is an algorithm for ordering the nodes of a directed acyclic graph (DAG) such that for every directed edge u → v, u comes before v in the ordering.</p>\n                <p>Applications include:</p>\n                <ul>\n                    <li>Course prerequisites scheduling</li>\n                    <li>Build system dependency resolution</li>\n                    <li>Event scheduling</li>\n                    <li>Task scheduling with dependencies</li>\n                </ul>\n                \n                <p>The algorithm works by repeatedly selecting nodes with no incoming edges (in-degree of 0), adding them to the order, and removing their outgoing edges.</p>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        let graph = {\n            nodes: [],\n            edges: []\n        };\n        \n        // Algorithm state\n        let algorithmState = {\n            inDegree: {},\n            queue: [],\n            order: [],\n            step: 0,\n            running: false,\n            currentVertex: null\n        };\n        \n        // Predefined graphs\n        const exampleGraphs = {\n            simple: {\n                edges: [\"A->B\", \"B->C\", \"C->D\"],\n                description: \"Simple linear path A→B→C→D\"\n            },\n            complex: {\n                edges: [\"A->B\", \"A->C\", \"B->D\", \"C->D\", \"D->E\", \"D->F\"],\n                description: \"Complex DAG with multiple paths\"\n            },\n            tree: {\n                edges: [\"A->B\", \"A->C\", \"B->D\", \"B->E\", \"C->F\", \"C->G\"],\n                description: \"Tree-like structure\"\n            },\n            course: {\n                edges: [\"Math101->Math201\", \"Math101->CS101\", \"CS101->CS201\", \"CS101->CS202\", \"CS201->CS301\", \"CS202->CS301\"],\n                description: \"Course prerequisites\"\n            }\n        };\n        \n        // Initialize the visualization\n        function init() {\n            // Set up default graph\n            loadExampleGraph('simple');\n            validateAndParseGraph();\n            renderGraph();\n        }\n        \n        // Load an example graph\n        function loadExampleGraph(type) {\n            const example = exampleGraphs[type];\n            if (example) {\n                document.getElementById('graphInput').value = example.edges.join('\\n');\n                validateAndParseGraph();\n                document.getElementById('stepDisplay').innerHTML = `<p>Loaded: ${example.description}</p>`;\n            }\n        }\n        \n        // Parse the graph input\n        function validateAndParseGraph() {\n            const input = document.getElementById('graphInput').value;\n            const lines = input.split('\\n').filter(line => line.trim() !== '');\n            \n            graph.nodes = [];\n            graph.edges = [];\n            \n            // Collect all unique nodes\n            const nodeSet = new Set();\n            \n            for (const line of lines) {\n                const parts = line.split('->');\n                if (parts.length !== 2) {\n                    alert(`Invalid edge format: ${line}. Use format \"A->B\"`);\n                    return;\n                }\n                \n                const from = parts[0].trim();\n                const to = parts[1].trim();\n                \n                if (from === '' || to === '') {\n                    alert(`Invalid edge format: ${line}. Nodes cannot be empty`);\n                    return;\n                }\n                \n                nodeSet.add(from);\n                nodeSet.add(to);\n                \n                graph.edges.push({ from, to });\n            }\n            \n            graph.nodes = Array.from(nodeSet).sort();\n            \n            // Reset algorithm state\n            initializeAlgorithm();\n            \n            // Enable algorithm buttons\n            document.getElementById('runAlgorithmBtn').disabled = false;\n            document.getElementById('stepBtn').disabled = false;\n            \n            // Render the graph\n            renderGraph();\n            \n            document.getElementById('stepDisplay').innerHTML = `<p>Graph parsed successfully. ${graph.nodes.length} nodes, ${graph.edges.length} edges.</p>`;\n        }\n        \n        // Initialize the algorithm state\n        function initializeAlgorithm() {\n            algorithmState = {\n                inDegree: {},\n                queue: [],\n                order: [],\n                step: 0,\n                running: false,\n                currentVertex: null\n            };\n            \n            // Calculate initial in-degrees\n            for (const node of graph.nodes) {\n                algorithmState.inDegree[node] = 0;\n            }\n            \n            for (const edge of graph.edges) {\n                algorithmState.inDegree[edge.to]++;\n            }\n            \n            // Initialize queue with nodes having in-degree 0\n            for (const node of graph.nodes) {\n                if (algorithmState.inDegree[node] === 0) {\n                    algorithmState.queue.push(node);\n                }\n            }\n            \n            updateResultDisplay();\n        }\n        \n        // Run the algorithm to completion\n        function runAlgorithm() {\n            if (!algorithmState.running) {\n                algorithmState.running = true;\n                \n                while (algorithmState.queue.length > 0) {\n                    stepAlgorithm();\n                }\n                \n                algorithmState.running = false;\n                \n                // Check if we have a valid topological sort\n                if (algorithmState.order.length === graph.nodes.length) {\n                    document.getElementById('stepDisplay').innerHTML += `<p><strong>Algorithm completed successfully!</strong></p>`;\n                } else {\n                    document.getElementById('stepDisplay').innerHTML += `<p><strong>Graph has cycles! Cannot perform topological sort.</strong></p>`;\n                }\n            }\n        }\n        \n        // Perform one step of the algorithm\n        function stepAlgorithm() {\n            if (algorithmState.queue.length === 0) {\n                algorithmState.running = false;\n                return;\n            }\n            \n            algorithmState.step++;\n            const current = algorithmState.queue.shift();\n            algorithmState.order.push(current);\n            algorithmState.currentVertex = current;\n            \n            // Update in-degrees of neighbors\n            for (const edge of graph.edges) {\n                if (edge.from === current) {\n                    algorithmState.inDegree[edge.to]--;\n                    \n                    // If in-degree becomes 0, add to queue\n                    if (algorithmState.inDegree[edge.to] === 0) {\n                        algorithmState.queue.push(edge.to);\n                    }\n                }\n            }\n            \n            updateResultDisplay();\n            renderGraph();\n            \n            let stepText = `<p><strong>Step ${algorithmState.step}:</strong> Processing node ${current}</p>`;\n            stepText += `<p>Queue: [${algorithmState.queue.join(', ')}]</p>`;\n            stepText += `<p>In-degrees: ${JSON.stringify(algorithmState.inDegree)}</p>`;\n            \n            document.getElementById('stepDisplay').innerHTML = stepText;\n        }\n        \n        // Reset the algorithm\n        function resetAlgorithm() {\n            initializeAlgorithm();\n            renderGraph();\n            document.getElementById('stepDisplay').innerHTML = `<p>Algorithm reset. Ready to run.</p>`;\n        }\n        \n        // Update the result display\n        function updateResultDisplay() {\n            const resultDiv = document.getElementById('resultDisplay');\n            \n            if (algorithmState.order.length === 0) {\n                resultDiv.innerHTML = `<p>Run the algorithm to see the topological order</p>`;\n                return;\n            }\n            \n            let html = `<p class=\"topological-order\">Topological Order: ${algorithmState.order.join(' → ')}</p>`;\n            \n            if (algorithmState.order.length === graph.nodes.length) {\n                html += `<p><strong>Valid topological sort found!</strong></p>`;\n            } else if (algorithmState.queue.length === 0 && algorithmState.order.length < graph.nodes.length) {\n                html += `<p><strong>Graph contains cycles! Cannot complete topological sort.</strong></p>`;\n            } else {\n                html += `<p>Algorithm in progress...</p>`;\n            }\n            \n            resultDiv.innerHTML = html;\n        }\n        \n        // Render the graph visualization\n        function renderGraph() {\n            const svg = document.getElementById('graphCanvas');\n            svg.innerHTML = ''; // Clear previous content\n            \n            // Set up dimensions\n            const width = svg.getAttribute('width');\n            const height = svg.getAttribute('height');\n            \n            // Calculate node positions in a circle\n            const centerX = width / 2;\n            const centerY = height / 2;\n            const radius = Math.min(width, height) * 0.4;\n            \n            const nodePositions = {};\n            const angleStep = (2 * Math.PI) / graph.nodes.length;\n            \n            graph.nodes.forEach((node, index) => {\n                const angle = index * angleStep;\n                nodePositions[node] = {\n                    x: centerX + radius * Math.cos(angle),\n                    y: centerY + radius * Math.sin(angle)\n                };\n            });\n            \n            // Draw edges\n            graph.edges.forEach(edge => {\n                const fromPos = nodePositions[edge.from];\n                const toPos = nodePositions[edge.to];\n                \n                // Draw arrow line\n                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                line.setAttribute('x1', fromPos.x);\n                line.setAttribute('y1', fromPos.y);\n                line.setAttribute('x2', toPos.x);\n                line.setAttribute('y2', toPos.y);\n                line.setAttribute('class', 'edge');\n                svg.appendChild(line);\n                \n                // Draw arrowhead\n                const arrowSize = 10;\n                const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);\n                const arrowX = toPos.x - 20 * Math.cos(angle);\n                const arrowY = toPos.y - 20 * Math.sin(angle);\n                \n                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n                const points = [\n                    `${arrowX},${arrowY}`,\n                    `${arrowX - arrowSize * Math.cos(angle - Math.PI/6)},${arrowY - arrowSize * Math.sin(angle - Math.PI/6)}`,\n                    `${arrowX - arrowSize * Math.cos(angle + Math.PI/6)},${arrowY - arrowSize * Math.sin(angle + Math.PI/6)}`\n                ].join(' ');\n                arrow.setAttribute('points', points);\n                arrow.setAttribute('class', 'arrow');\n                svg.appendChild(arrow);\n            });\n            \n            // Draw nodes\n            graph.nodes.forEach(node => {\n                const pos = nodePositions[node];\n                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                circle.setAttribute('cx', pos.x);\n                circle.setAttribute('cy', pos.y);\n                circle.setAttribute('"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}