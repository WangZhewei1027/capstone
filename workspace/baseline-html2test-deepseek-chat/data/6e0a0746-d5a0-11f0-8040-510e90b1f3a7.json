{
  "id": "6e0a0746-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:18:59.448Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Breadth-First Search Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 900px;\n            margin: 0 auto;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            margin: 20px 0;\n            text-align: center;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 5px;\n            border: none;\n            border-radius: 4px;\n            background-color: #4CAF50;\n            color: white;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        .graph-container {\n            display: flex;\n            justify-content: space-between;\n            margin-top: 20px;\n        }\n        .graph {\n            flex: 1;\n            min-height: 400px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            position: relative;\n        }\n        .info-panel {\n            flex: 0 0 300px;\n            margin-left: 20px;\n            padding: 15px;\n            background-color: #f9f9f9;\n            border-radius: 4px;\n            border: 1px solid #ddd;\n        }\n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #2196F3;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            transition: all 0.3s ease;\n        }\n        .node.visited {\n            background-color: #FF9800;\n        }\n        .node.current {\n            background-color: #F44336;\n            transform: scale(1.2);\n        }\n        .node.target {\n            background-color: #4CAF50;\n        }\n        .edge {\n            position: absolute;\n            height: 3px;\n            background-color: #666;\n            transform-origin: 0 0;\n        }\n        .queue-visualization {\n            margin-top: 20px;\n            padding: 10px;\n            background-color: #f0f0f0;\n            border-radius: 4px;\n        }\n        .queue-item {\n            display: inline-block;\n            padding: 8px 12px;\n            margin: 2px;\n            background-color: #2196F3;\n            color: white;\n            border-radius: 4px;\n        }\n        .queue-item.current {\n            background-color: #F44336;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Breadth-First Search (BFS) Visualization</h1>\n        \n        <div class=\"controls\">\n            <button id=\"startBtn\">Start BFS</button>\n            <button id=\"resetBtn\">Reset</button>\n            <button id=\"stepBtn\">Step Forward</button>\n            <select id=\"speedSelect\">\n                <option value=\"500\">Slow</option>\n                <option value=\"300\" selected>Medium</option>\n                <option value=\"100\">Fast</option>\n            </select>\n        </div>\n\n        <div class=\"graph-container\">\n            <div class=\"graph\" id=\"graphCanvas\"></div>\n            <div class=\"info-panel\">\n                <h3>BFS Algorithm Info</h3>\n                <p><strong>Current Step:</strong> <span id=\"currentStep\">Ready</span></p>\n                <p><strong>Visited Nodes:</strong> <span id=\"visitedNodes\">None</span></p>\n                <p><strong>Queue Contents:</strong></p>\n                <div class=\"queue-visualization\" id=\"queueDisplay\"></div>\n                <h3>BFS Algorithm Steps:</h3>\n                <ol>\n                    <li>Start from the root node</li>\n                    <li>Visit all neighbors at current depth</li>\n                    <li>Move to next depth level</li>\n                    <li>Use a queue to track nodes to visit</li>\n                </ol>\n                <p><strong>Time Complexity:</strong> O(V + E)</p>\n                <p><strong>Space Complexity:</strong> O(V)</p>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.adjacencyList = {};\n            }\n\n            addNode(nodeId, x, y) {\n                this.nodes.push({ id: nodeId, x, y });\n                this.adjacencyList[nodeId] = [];\n            }\n\n            addEdge(node1, node2) {\n                this.edges.push({ from: node1, to: node2 });\n                this.adjacencyList[node1].push(node2);\n                this.adjacencyList[node2].push(node1);\n            }\n\n            bfs(startNode) {\n                const visited = new Set();\n                const queue = [startNode];\n                const steps = [];\n                \n                visited.add(startNode);\n                steps.push({\n                    current: startNode,\n                    visited: new Set(visited),\n                    queue: [...queue],\n                    description: `Starting BFS from node ${startNode}`\n                });\n\n                while (queue.length > 0) {\n                    const currentNode = queue.shift();\n                    \n                    steps.push({\n                        current: currentNode,\n                        visited: new Set(visited),\n                        queue: [...queue],\n                        description: `Processing node ${currentNode}`\n                    });\n\n                    for (const neighbor of this.adjacencyList[currentNode]) {\n                        if (!visited.has(neighbor)) {\n                            visited.add(neighbor);\n                            queue.push(neighbor);\n                            \n                            steps.push({\n                                current: currentNode,\n                                visited: new Set(visited),\n                                queue: [...queue],\n                                description: `Discovered neighbor ${neighbor}, added to queue`\n                            });\n                        }\n                    }\n                }\n\n                steps.push({\n                    current: null,\n                    visited: new Set(visited),\n                    queue: [],\n                    description: 'BFS completed!'\n                });\n\n                return steps;\n            }\n        }\n\n        class BFSVisualizer {\n            constructor() {\n                this.graph = new Graph();\n                this.steps = [];\n                this.currentStep = 0;\n                this.isRunning = false;\n                this.animationSpeed = 300;\n                this.initializeGraph();\n                this.renderGraph();\n                this.setupEventListeners();\n            }\n\n            initializeGraph() {\n                // Create a sample graph\n                const nodes = [\n                    { id: 'A', x: 100, y: 150 },\n                    { id: 'B', x: 250, y: 100 },\n                    { id: 'C', x: 250, y: 200 },\n                    { id: 'D', x: 400, y: 50 },\n                    { id: 'E', x: 400, y: 150 },\n                    { id: 'F', x: 400, y: 250 },\n                    { id: 'G', x: 550, y: 150 }\n                ];\n\n                nodes.forEach(node => this.graph.addNode(node.id, node.x, node.y));\n                \n                this.graph.addEdge('A', 'B');\n                this.graph.addEdge('A', 'C');\n                this.graph.addEdge('B', 'D');\n                this.graph.addEdge('B', 'E');\n                this.graph.addEdge('C', 'E');\n                this.graph.addEdge('C', 'F');\n                this.graph.addEdge('E', 'G');\n                this.graph.addEdge('F', 'G');\n\n                this.steps = this.graph.bfs('A');\n            }\n\n            renderGraph() {\n                const canvas = document.getElementById('graphCanvas');\n                canvas.innerHTML = '';\n\n                // Render edges\n                this.graph.edges.forEach(edge => {\n                    const fromNode = this.graph.nodes.find(n => n.id === edge.from);\n                    const toNode = this.graph.nodes.find(n => n.id === edge.to);\n                    \n                    const edgeElement = document.createElement('div');\n                    edgeElement.className = 'edge';\n                    \n                    const dx = toNode.x - fromNode.x;\n                    const dy = toNode.y - fromNode.y;\n                    const length = Math.sqrt(dx * dx + dy * dy);\n                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                    \n                    edgeElement.style.width = length + 'px';\n                    edgeElement.style.left = fromNode.x + 'px';\n                    edgeElement.style.top = (fromNode.y - 1.5) + 'px';\n                    edgeElement.style.transform = `rotate(${angle}deg)`;\n                    \n                    canvas.appendChild(edgeElement);\n                });\n\n                // Render nodes\n                this.graph.nodes.forEach(node => {\n                    const nodeElement = document.createElement('div');\n                    nodeElement.className = 'node';\n                    nodeElement.id = `node-${node.id}`;\n                    nodeElement.textContent = node.id;\n                    nodeElement.style.left = (node.x - 20) + 'px';\n                    nodeElement.style.top = (node.y - 20) + 'px';\n                    \n                    canvas.appendChild(nodeElement);\n                });\n\n                this.updateVisualization();\n            }\n\n            updateVisualization() {\n                // Reset all nodes\n                this.graph.nodes.forEach(node => {\n                    const nodeElement = document.getElementById(`node-${node.id}`);\n                    nodeElement.className = 'node';\n                });\n\n                if (this.currentStep >= this.steps.length) return;\n\n                const step = this.steps[this.currentStep];\n                \n                // Update visited nodes\n                step.visited.forEach(nodeId => {\n                    const nodeElement = document.getElementById(`node-${nodeId}`);\n                    if (nodeElement) nodeElement.classList.add('visited');\n                });\n\n                // Update current node\n                if (step.current) {\n                    const currentNodeElement = document.getElementById(`node-${step.current}`);\n                    if (currentNodeElement) currentNodeElement.classList.add('current');\n                }\n\n                // Update info panel\n                document.getElementById('currentStep').textContent = step.description;\n                document.getElementById('visitedNodes').textContent = Array.from(step.visited).join(', ');\n                \n                // Update queue visualization\n                const queueDisplay = document.getElementById('queueDisplay');\n                queueDisplay.innerHTML = '';\n                step.queue.forEach((nodeId, index) => {\n                    const queueItem = document.createElement('div');\n                    queueItem.className = 'queue-item';\n                    if (index === 0) queueItem.classList.add('current');\n                    queueItem.textContent = nodeId;\n                    queueDisplay.appendChild(queueItem);\n                });\n            }\n\n            nextStep() {\n                if (this.currentStep < this.steps.length - 1) {\n                    this.currentStep++;\n                    this.updateVisualization();\n                    return true;\n                }\n                return false;\n            }\n\n            previousStep() {\n                if (this.currentStep > 0) {\n                    this.currentStep--;\n                    this.updateVisualization();\n                    return true;\n                }\n                return false;\n            }\n\n            startAnimation() {\n                if (this.isRunning) return;\n                \n                this.isRunning = true;\n                document.getElementById('startBtn').disabled = true;\n                document.getElementById('stepBtn').disabled = true;\n                \n                const animate = () => {\n                    if (!this.nextStep() || !this.isRunning) {\n                        this.isRunning = false;\n                        document.getElementById('startBtn').disabled = false;\n                        document.getElementById('stepBtn').disabled = false;\n                        return;\n                    }\n                    setTimeout(animate, this.animationSpeed);\n                };\n                \n                animate();\n            }\n\n            stopAnimation() {\n                this.isRunning = false;\n                document.getElementById('startBtn').disabled = false;\n                document.getElementById('stepBtn').disabled = false;\n            }\n\n            reset() {\n                this.stopAnimation();\n                this.currentStep = 0;\n                this.updateVisualization();\n            }\n\n            setupEventListeners() {\n                document.getElementById('startBtn').addEventListener('click', () => {\n                    this.startAnimation();\n                });\n\n                document.getElementById('resetBtn').addEventListener('click', () => {\n                    this.reset();\n                });\n\n                document.getElementById('stepBtn').addEventListener('click', () => {\n                    this.nextStep();\n                });\n\n                document.getElementById('speedSelect').addEventListener('change', (e) => {\n                    this.animationSpeed = parseInt(e.target.value);\n                });\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new BFSVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}