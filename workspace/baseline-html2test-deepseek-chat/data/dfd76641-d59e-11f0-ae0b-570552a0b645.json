{
  "id": "dfd76641-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:11.048Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .controls {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        .visualization {\n            display: flex;\n            gap: 20px;\n        }\n        .graph-container {\n            flex: 2;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            min-height: 500px;\n        }\n        .info-panel {\n            flex: 1;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n        }\n        button {\n            padding: 10px 15px;\n            margin: 5px;\n            border: none;\n            border-radius: 4px;\n            background-color: #4CAF50;\n            color: white;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        .step-info {\n            background-color: #f8f9fa;\n            padding: 10px;\n            border-radius: 4px;\n            margin-top: 10px;\n            font-family: monospace;\n            white-space: pre-wrap;\n        }\n        .node {\n            position: absolute;\n            width: 30px;\n            height: 30px;\n            background-color: #4CAF50;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n            cursor: pointer;\n        }\n        .edge {\n            position: absolute;\n            background-color: #333;\n            transform-origin: 0 0;\n        }\n        .weight {\n            position: absolute;\n            background: white;\n            padding: 2px 5px;\n            border-radius: 3px;\n            font-size: 12px;\n        }\n        .mst-edge {\n            background-color: #ff5722;\n            stroke-width: 3;\n        }\n        .current-edge {\n            background-color: #2196F3;\n            animation: pulse 1s infinite;\n        }\n        @keyframes pulse {\n            0% { opacity: 1; }\n            50% { opacity: 0.5; }\n            100% { opacity: 1; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Prim's Algorithm Visualization</h1>\n        \n        <div class=\"controls\">\n            <button id=\"randomGraph\">Generate Random Graph</button>\n            <button id=\"startPrim\">Start Prim's Algorithm</button>\n            <button id=\"nextStep\">Next Step</button>\n            <button id=\"reset\">Reset</button>\n            <label>\n                Number of Nodes: \n                <input type=\"number\" id=\"nodeCount\" value=\"6\" min=\"3\" max=\"10\">\n            </label>\n        </div>\n\n        <div class=\"visualization\">\n            <div class=\"graph-container\">\n                <canvas id=\"graphCanvas\" width=\"600\" height=\"500\"></canvas>\n            </div>\n            \n            <div class=\"info-panel\">\n                <h3>Algorithm Steps</h3>\n                <div id=\"stepInfo\" class=\"step-info\">Click \"Start Prim's Algorithm\" to begin</div>\n                <h3>Minimum Spanning Tree</h3>\n                <div id=\"mstInfo\" class=\"step-info\">Total weight: 0</div>\n                <h3>About Prim's Algorithm</h3>\n                <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph.</p>\n                <p><strong>Time Complexity:</strong> O(E log V) using binary heap</p>\n                <p><strong>Steps:</strong></p>\n                <ol>\n                    <li>Start with an arbitrary node</li>\n                    <li>Add the minimum weight edge connecting the tree to a new node</li>\n                    <li>Repeat until all nodes are included</li>\n                </ol>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.adjacencyList = {};\n            }\n\n            addNode(id, x, y) {\n                this.nodes.push({ id, x, y });\n                this.adjacencyList[id] = [];\n            }\n\n            addEdge(from, to, weight) {\n                this.edges.push({ from, to, weight });\n                this.adjacencyList[from].push({ node: to, weight });\n                this.adjacencyList[to].push({ node: from, weight });\n            }\n\n            generateRandomGraph(nodeCount) {\n                this.nodes = [];\n                this.edges = [];\n                this.adjacencyList = {};\n\n                // Create nodes in a circular layout\n                const centerX = 300;\n                const centerY = 250;\n                const radius = 150;\n\n                for (let i = 0; i < nodeCount; i++) {\n                    const angle = (2 * Math.PI * i) / nodeCount;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.addNode(i, x, y);\n                }\n\n                // Create edges (approximately 2*nodeCount edges)\n                const edgeCount = Math.min(nodeCount * 2, (nodeCount * (nodeCount - 1)) / 2);\n                const createdEdges = new Set();\n\n                while (this.edges.length < edgeCount) {\n                    const from = Math.floor(Math.random() * nodeCount);\n                    let to = Math.floor(Math.random() * nodeCount);\n                    \n                    if (from !== to) {\n                        const edgeKey = `${Math.min(from, to)}-${Math.max(from, to)}`;\n                        if (!createdEdges.has(edgeKey)) {\n                            const weight = Math.floor(Math.random() * 20) + 1;\n                            this.addEdge(from, to, weight);\n                            createdEdges.add(edgeKey);\n                        }\n                    }\n                }\n            }\n        }\n\n        class PrimVisualizer {\n            constructor() {\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.graph = new Graph();\n                this.mstEdges = [];\n                this.visited = new Set();\n                this.priorityQueue = [];\n                this.currentStep = 0;\n                this.isRunning = false;\n                \n                this.initializeEventListeners();\n                this.generateRandomGraph();\n            }\n\n            initializeEventListeners() {\n                document.getElementById('randomGraph').addEventListener('click', () => {\n                    this.generateRandomGraph();\n                });\n\n                document.getElementById('startPrim').addEventListener('click', () => {\n                    this.startPrim();\n                });\n\n                document.getElementById('nextStep').addEventListener('click', () => {\n                    this.nextStep();\n                });\n\n                document.getElementById('reset').addEventListener('click', () => {\n                    this.reset();\n                });\n\n                document.getElementById('nodeCount').addEventListener('change', (e) => {\n                    this.generateRandomGraph();\n                });\n            }\n\n            generateRandomGraph() {\n                const nodeCount = parseInt(document.getElementById('nodeCount').value);\n                this.graph.generateRandomGraph(nodeCount);\n                this.reset();\n                this.drawGraph();\n            }\n\n            reset() {\n                this.mstEdges = [];\n                this.visited.clear();\n                this.priorityQueue = [];\n                this.currentStep = 0;\n                this.isRunning = false;\n                this.updateStepInfo(\"Algorithm reset. Click 'Start Prim's Algorithm' to begin.\");\n                this.drawGraph();\n            }\n\n            startPrim() {\n                if (this.graph.nodes.length === 0) return;\n                \n                this.reset();\n                this.isRunning = true;\n                \n                // Start with first node\n                const startNode = this.graph.nodes[0].id;\n                this.visited.add(startNode);\n                \n                // Add all edges from start node to priority queue\n                this.graph.adjacencyList[startNode].forEach(edge => {\n                    this.priorityQueue.push({\n                        from: startNode,\n                        to: edge.node,\n                        weight: edge.weight\n                    });\n                });\n\n                // Sort priority queue by weight\n                this.priorityQueue.sort((a, b) => a.weight - b.weight);\n                \n                this.updateStepInfo(`Started Prim's algorithm from node ${startNode}`);\n                this.drawGraph();\n            }\n\n            nextStep() {\n                if (!this.isRunning || this.priorityQueue.length === 0) {\n                    if (this.visited.size === this.graph.nodes.length) {\n                        this.updateStepInfo(\"Algorithm completed! All nodes are in the MST.\");\n                        this.isRunning = false;\n                    }\n                    return;\n                }\n\n                this.currentStep++;\n                \n                // Get the minimum weight edge\n                const minEdge = this.priorityQueue.shift();\n                \n                // If the destination node is already visited, skip this edge\n                if (this.visited.has(minEdge.to)) {\n                    this.updateStepInfo(`Skipped edge ${minEdge.from}-${minEdge.to} (weight: ${minEdge.weight}) - node ${minEdge.to} already visited`);\n                    this.drawGraph(minEdge);\n                    setTimeout(() => this.nextStep(), 1000);\n                    return;\n                }\n\n                // Add edge to MST\n                this.mstEdges.push(minEdge);\n                this.visited.add(minEdge.to);\n                \n                // Add new edges from the newly added node\n                this.graph.adjacencyList[minEdge.to].forEach(edge => {\n                    if (!this.visited.has(edge.node)) {\n                        this.priorityQueue.push({\n                            from: minEdge.to,\n                            to: edge.node,\n                            weight: edge.weight\n                        });\n                    }\n                });\n\n                // Re-sort priority queue\n                this.priorityQueue.sort((a, b) => a.weight - b.weight);\n\n                this.updateStepInfo(`Added edge ${minEdge.from}-${minEdge.to} (weight: ${minEdge.weight}) to MST\\nVisited nodes: ${Array.from(this.visited).join(', ')}`);\n                this.updateMSTInfo();\n                this.drawGraph(minEdge);\n\n                // Check if algorithm is complete\n                if (this.visited.size === this.graph.nodes.length) {\n                    setTimeout(() => {\n                        this.updateStepInfo(\"Algorithm completed! All nodes are in the MST.\");\n                        this.isRunning = false;\n                    }, 1000);\n                }\n            }\n\n            updateStepInfo(message) {\n                document.getElementById('stepInfo').textContent = message;\n            }\n\n            updateMSTInfo() {\n                const totalWeight = this.mstEdges.reduce((sum, edge) => sum + edge.weight, 0);\n                const edgesInfo = this.mstEdges.map(edge => \n                    `${edge.from}-${edge.to} (${edge.weight})`\n                ).join(', ');\n                document.getElementById('mstInfo').textContent = \n                    `Total weight: ${totalWeight}\\nEdges: ${edgesInfo}`;\n            }\n\n            drawGraph(currentEdge = null) {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.graph.edges.forEach(edge => {\n                    const fromNode = this.graph.nodes[edge.from];\n                    const toNode = this.graph.nodes[edge.to];\n                    \n                    this.ctx.beginPath();\n                    this.ctx.moveTo(fromNode.x, fromNode.y);\n                    this.ctx.lineTo(toNode.x, toNode.y);\n                    \n                    // Check if this edge is in MST\n                    const isInMST = this.mstEdges.some(e => \n                        (e.from === edge.from && e.to === edge.to) || \n                        (e.from === edge.to && e.to === edge.from)\n                    );\n                    \n                    // Check if this is the current edge being considered\n                    const isCurrent = currentEdge && \n                        ((currentEdge.from === edge.from && currentEdge.to === edge.to) ||\n                         (currentEdge.from === edge.to && currentEdge.to === edge.from));\n\n                    if (isInMST) {\n                        this.ctx.strokeStyle = '#ff5722';\n                        this.ctx.lineWidth = 3;\n                    } else if (isCurrent) {\n                        this.ctx.strokeStyle = '#2196F3';\n                        this.ctx.lineWidth = 3;\n                    } else {\n                        this.ctx.strokeStyle = '#333';\n                        this.ctx.lineWidth = 1;\n                    }\n                    \n                    this.ctx.stroke();\n\n                    // Draw weight\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.fillRect(midX - 10, midY - 8, 20, 16);\n                    this.ctx.fillStyle = 'black';\n                    this.ctx.font = '12px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.fillText(edge.weight.toString(), midX, midY + 4);\n                });\n\n                // Draw nodes\n                this.graph.nodes.forEach(node => {\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);\n                    this.ctx.fillStyle = this.visited.has(node.id) ? '#4CAF50' : '#2196F3';\n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#333';\n                    this.ctx.lineWidth = 2;\n                    this.ctx.stroke();\n\n                    // Draw node ID\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 14px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.fillText(node.id.toString(), node.x, node.y + 5);\n                });\n\n                // Draw priority queue visualization\n                this.drawPriorityQueue();\n            }\n\n            drawPriorityQueue() {\n                if (!this.isRunning) return;\n\n                this.ctx.fillStyle = 'rgba(240, 240, 240, 0.9)';\n                this.ctx.fillRect(10, 10, 200, 100);\n                \n                this.ctx.fillStyle = 'black';\n                this.ctx.font = '12px Arial';\n                this.ctx.textAlign = 'left';\n                this.ctx.fillText('Priority Queue:', 15, 25);\n                \n                // Show top 5 edges in queue\n                this.priorityQueue.slice(0, 5).forEach((edge, index) => {\n                    this.ctx.fillText(\n                        `${edge.from}-${edge.to} (${edge.weight})`,\n                        15, 45 + index * 15\n                    );\n                });\n                \n                if (this.priorityQueue.length > 5) {\n                    this.ctx.fillText('...', 15, 45 + 5 * 15);\n                }\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new PrimVisualizer();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}