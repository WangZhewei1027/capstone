{
  "id": "6e099211-d5a0-11f0-8040-510e90b1f3a7",
  "timestamp": "2025-12-10T08:19:27.645Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Search Tree Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        input, button {\n            padding: 8px 12px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        button {\n            background: #007bff;\n            color: white;\n            cursor: pointer;\n        }\n        button:hover {\n            background: #0056b3;\n        }\n        .tree-container {\n            display: flex;\n            justify-content: center;\n            min-height: 400px;\n            margin-top: 20px;\n        }\n        .node {\n            width: 40px;\n            height: 40px;\n            border: 2px solid #333;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            margin: 10px 20px;\n            background: white;\n            position: relative;\n        }\n        .node-value {\n            font-weight: bold;\n        }\n        .level {\n            display: flex;\n            justify-content: center;\n            position: relative;\n        }\n        .line {\n            position: absolute;\n            background: #333;\n            height: 2px;\n            transform-origin: 0 0;\n        }\n        .operations {\n            margin-top: 20px;\n            padding: 15px;\n            background: #f8f9fa;\n            border-radius: 4px;\n        }\n        .log {\n            margin-top: 20px;\n            padding: 15px;\n            background: #f8f9fa;\n            border-radius: 4px;\n            max-height: 200px;\n            overflow-y: auto;\n            font-family: monospace;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Binary Search Tree Visualization</h1>\n        \n        <div class=\"controls\">\n            <input type=\"number\" id=\"valueInput\" placeholder=\"Enter a number\" min=\"-999\" max=\"999\">\n            <button onclick=\"insertValue()\">Insert</button>\n            <button onclick=\"removeValue()\">Remove</button>\n            <button onclick=\"searchValue()\">Search</button>\n            <button onclick=\"clearTree()\">Clear Tree</button>\n            <button onclick=\"generateRandomTree()\">Generate Random Tree</button>\n        </div>\n\n        <div class=\"tree-container\" id=\"treeContainer\">\n            <!-- Tree will be rendered here -->\n        </div>\n\n        <div class=\"operations\">\n            <h3>Tree Operations</h3>\n            <div class=\"controls\">\n                <button onclick=\"traverseInOrder()\">In-Order Traversal</button>\n                <button onclick=\"traversePreOrder()\">Pre-Order Traversal</button>\n                <button onclick=\"traversePostOrder()\">Post-Order Traversal</button>\n                <button onclick=\"findMin()\">Find Minimum</button>\n                <button onclick=\"findMax()\">Find Maximum</button>\n            </div>\n        </div>\n\n        <div class=\"log\" id=\"log\">\n            <h3>Operation Log</h3>\n            <div id=\"logContent\"></div>\n        </div>\n    </div>\n\n    <script>\n        class Node {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BinarySearchTree {\n            constructor() {\n                this.root = null;\n            }\n\n            insert(value) {\n                const newNode = new Node(value);\n                \n                if (this.root === null) {\n                    this.root = newNode;\n                    return true;\n                }\n\n                let current = this.root;\n                while (true) {\n                    if (value === current.value) {\n                        logMessage(`Value ${value} already exists in the tree`);\n                        return false;\n                    }\n\n                    if (value < current.value) {\n                        if (current.left === null) {\n                            current.left = newNode;\n                            return true;\n                        }\n                        current = current.left;\n                    } else {\n                        if (current.right === null) {\n                            current.right = newNode;\n                            return true;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n\n            remove(value) {\n                this.root = this._removeNode(this.root, value);\n            }\n\n            _removeNode(node, value) {\n                if (node === null) {\n                    logMessage(`Value ${value} not found in the tree`);\n                    return null;\n                }\n\n                if (value < node.value) {\n                    node.left = this._removeNode(node.left, value);\n                    return node;\n                } else if (value > node.value) {\n                    node.right = this._removeNode(node.right, value);\n                    return node;\n                } else {\n                    // Node to be deleted found\n                    if (node.left === null && node.right === null) {\n                        return null;\n                    }\n                    \n                    if (node.left === null) {\n                        return node.right;\n                    } else if (node.right === null) {\n                        return node.left;\n                    }\n\n                    // Node with two children\n                    const minNode = this._findMinNode(node.right);\n                    node.value = minNode.value;\n                    node.right = this._removeNode(node.right, minNode.value);\n                    return node;\n                }\n            }\n\n            _findMinNode(node) {\n                while (node && node.left !== null) {\n                    node = node.left;\n                }\n                return node;\n            }\n\n            search(value) {\n                let current = this.root;\n                let steps = 0;\n                \n                while (current !== null) {\n                    steps++;\n                    if (value === current.value) {\n                        logMessage(`Value ${value} found in ${steps} steps`);\n                        return current;\n                    } else if (value < current.value) {\n                        current = current.left;\n                    } else {\n                        current = current.right;\n                    }\n                }\n                \n                logMessage(`Value ${value} not found in the tree`);\n                return null;\n            }\n\n            inOrder(node = this.root, result = []) {\n                if (node !== null) {\n                    this.inOrder(node.left, result);\n                    result.push(node.value);\n                    this.inOrder(node.right, result);\n                }\n                return result;\n            }\n\n            preOrder(node = this.root, result = []) {\n                if (node !== null) {\n                    result.push(node.value);\n                    this.preOrder(node.left, result);\n                    this.preOrder(node.right, result);\n                }\n                return result;\n            }\n\n            postOrder(node = this.root, result = []) {\n                if (node !== null) {\n                    this.postOrder(node.left, result);\n                    this.postOrder(node.right, result);\n                    result.push(node.value);\n                }\n                return result;\n            }\n\n            findMin() {\n                if (this.root === null) return null;\n                let current = this.root;\n                while (current.left !== null) {\n                    current = current.left;\n                }\n                return current.value;\n            }\n\n            findMax() {\n                if (this.root === null) return null;\n                let current = this.root;\n                while (current.right !== null) {\n                    current = current.right;\n                }\n                return current.value;\n            }\n\n            getHeight(node = this.root) {\n                if (node === null) return 0;\n                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));\n            }\n        }\n\n        const bst = new BinarySearchTree();\n\n        function logMessage(message) {\n            const logContent = document.getElementById('logContent');\n            const timestamp = new Date().toLocaleTimeString();\n            logContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;\n            logContent.scrollTop = logContent.scrollHeight;\n        }\n\n        function insertValue() {\n            const valueInput = document.getElementById('valueInput');\n            const value = parseInt(valueInput.value);\n            \n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n\n            if (bst.insert(value)) {\n                logMessage(`Inserted value: ${value}`);\n                renderTree();\n            }\n            valueInput.value = '';\n            valueInput.focus();\n        }\n\n        function removeValue() {\n            const valueInput = document.getElementById('valueInput');\n            const value = parseInt(valueInput.value);\n            \n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n\n            bst.remove(value);\n            logMessage(`Attempted to remove value: ${value}`);\n            renderTree();\n            valueInput.value = '';\n            valueInput.focus();\n        }\n\n        function searchValue() {\n            const valueInput = document.getElementById('valueInput');\n            const value = parseInt(valueInput.value);\n            \n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n\n            bst.search(value);\n            valueInput.value = '';\n            valueInput.focus();\n        }\n\n        function clearTree() {\n            bst.root = null;\n            logMessage('Tree cleared');\n            renderTree();\n        }\n\n        function generateRandomTree() {\n            bst.root = null;\n            const count = 7 + Math.floor(Math.random() * 8); // 7-14 nodes\n            const values = new Set();\n            \n            while (values.size < count) {\n                values.add(Math.floor(Math.random() * 100) - 50); // -50 to 49\n            }\n            \n            values.forEach(value => bst.insert(value));\n            logMessage(`Generated random tree with ${count} nodes`);\n            renderTree();\n        }\n\n        function traverseInOrder() {\n            const result = bst.inOrder();\n            logMessage(`In-Order Traversal: ${result.join(' → ')}`);\n        }\n\n        function traversePreOrder() {\n            const result = bst.preOrder();\n            logMessage(`Pre-Order Traversal: ${result.join(' → ')}`);\n        }\n\n        function traversePostOrder() {\n            const result = bst.postOrder();\n            logMessage(`Post-Order Traversal: ${result.join(' → ')}`);\n        }\n\n        function findMin() {\n            const min = bst.findMin();\n            if (min !== null) {\n                logMessage(`Minimum value: ${min}`);\n            } else {\n                logMessage('Tree is empty');\n            }\n        }\n\n        function findMax() {\n            const max = bst.findMax();\n            if (max !== null) {\n                logMessage(`Maximum value: ${max}`);\n            } else {\n                logMessage('Tree is empty');\n            }\n        }\n\n        function renderTree() {\n            const container = document.getElementById('treeContainer');\n            container.innerHTML = '';\n            \n            if (bst.root === null) {\n                container.innerHTML = '<p>Tree is empty</p>';\n                return;\n            }\n\n            const levels = getTreeLevels(bst.root);\n            const maxLevel = levels.length - 1;\n            \n            levels.forEach((level, levelIndex) => {\n                const levelDiv = document.createElement('div');\n                levelDiv.className = 'level';\n                levelDiv.style.marginBottom = '50px';\n                \n                level.forEach(nodeObj => {\n                    if (nodeObj.node) {\n                        const nodeDiv = document.createElement('div');\n                        nodeDiv.className = 'node';\n                        nodeDiv.innerHTML = `<span class=\"node-value\">${nodeObj.node.value}</span>`;\n                        nodeDiv.style.position = 'relative';\n                        \n                        // Add connecting lines\n                        if (levelIndex > 0) {\n                            const parentPos = findParentPosition(levels, levelIndex, nodeObj.index);\n                            if (parentPos !== null) {\n                                const line = createLine(nodeObj.position, parentPos, levelIndex);\n                                container.appendChild(line);\n                            }\n                        }\n                        \n                        levelDiv.appendChild(nodeDiv);\n                    } else {\n                        // Empty node for spacing\n                        const spacer = document.createElement('div');\n                        spacer.className = 'node';\n                        spacer.style.visibility = 'hidden';\n                        levelDiv.appendChild(spacer);\n                    }\n                });\n                \n                container.appendChild(levelDiv);\n            });\n        }\n\n        function getTreeLevels(node) {\n            const levels = [];\n            const queue = [{ node, level: 0, index: 0 }];\n            \n            while (queue.length > 0) {\n                const { node, level, index } = queue.shift();\n                \n                if (!levels[level]) levels[level] = [];\n                levels[level][index] = { node, index, position: index };\n                \n                if (node) {\n                    const leftIndex = index * 2;\n                    const rightIndex = index * 2 + 1;\n                    \n                    queue.push({ node: node.left, level: level + 1, index: leftIndex });\n                    queue.push({ node: node.right, level: level + 1, index: rightIndex });\n                }\n            }\n            \n            return levels;\n        }\n\n        function findParentPosition(levels, currentLevel, currentIndex) {\n            if (currentLevel === 0) return null;\n            \n            const parentIndex = Math.floor(currentIndex / 2);\n            const parentLevel = levels[currentLevel - 1];\n            \n            if (parentLevel && parentLevel[parentIndex] && parentLevel[parentIndex].node) {\n                return parentLevel[parentIndex].position;\n            }\n            \n            return null;\n        }\n\n        function createLine(childPos, parentPos, level) {\n            const line = document.createElement('div');\n            line.className = 'line';\n            \n            const levelHeight = 80;\n            const nodeSpacing = 80;\n            \n            const startX = parentPos * nodeSpacing + 20;\n            const startY = (level - 1) * levelHeight + 40;\n            const endX = childPos * nodeSpacing + 20;\n            const endY = level * levelHeight + 20;\n            \n            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));\n            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;\n            \n            line.style.width = length + 'px';\n            line.style.left = startX + 'px';\n            line.style.top = startY + 'px';\n            line.style.transform = `rotate(${angle}deg)`;\n            \n            return line;\n        }\n\n        // Initialize with some values\n        bst.insert(50);\n        bst.insert(30);\n        bst.insert(70);\n        bst.insert(20);\n        bst.insert(40);\n        bst.insert(60);\n        bst.insert(80);\n        renderTree();\n        logMessage('Demo tree created with values: 50, 30, 70, 20, 40, 60, 80');\n\n        // Add keyboard support\n        document.getElementById('valueInput').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                insertValue();\n            }\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}