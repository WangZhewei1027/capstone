{
  "id": "dfd73f23-d59e-11f0-ae0b-570552a0b645",
  "timestamp": "2025-12-10T08:08:25.817Z",
  "type": "html-to-test",
  "htmlModel": "deepseek-chat",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Graph Visualization - Directed vs Undirected</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin: 20px 0;\n        }\n        button {\n            padding: 10px 20px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        .graph-container {\n            display: flex;\n            justify-content: space-around;\n            flex-wrap: wrap;\n            gap: 20px;\n        }\n        .graph {\n            background-color: white;\n            border: 2px solid #ddd;\n            border-radius: 8px;\n            padding: 15px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        canvas {\n            border: 1px solid #ccc;\n        }\n        .info {\n            margin: 20px 0;\n            padding: 15px;\n            background-color: #e7f3ff;\n            border-left: 4px solid #2196F3;\n            border-radius: 4px;\n        }\n        .node-info {\n            margin-top: 10px;\n            font-size: 14px;\n            color: #666;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Graph Visualization: Directed vs Undirected Graphs</h1>\n        \n        <div class=\"info\">\n            <h3>About Graphs:</h3>\n            <p><strong>Undirected Graph:</strong> Edges have no direction - connections are bidirectional.</p>\n            <p><strong>Directed Graph (Digraph):</strong> Edges have direction - connections go from source to target.</p>\n        </div>\n\n        <div class=\"controls\">\n            <button onclick=\"addRandomNode()\">Add Random Node</button>\n            <button onclick=\"addRandomEdge()\">Add Random Edge</button>\n            <button onclick=\"clearGraphs()\">Clear Graphs</button>\n            <button onclick=\"generateRandomGraph()\">Generate Random Graph</button>\n        </div>\n\n        <div class=\"graph-container\">\n            <div class=\"graph\">\n                <h3>Undirected Graph</h3>\n                <canvas id=\"undirectedCanvas\" width=\"500\" height=\"400\"></canvas>\n                <div class=\"node-info\" id=\"undirectedInfo\">Click on nodes to see connections</div>\n            </div>\n            \n            <div class=\"graph\">\n                <h3>Directed Graph</h3>\n                <canvas id=\"directedCanvas\" width=\"500\" height=\"400\"></canvas>\n                <div class=\"node-info\" id=\"directedInfo\">Click on nodes to see connections</div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor(type) {\n                this.type = type; // 'directed' or 'undirected'\n                this.nodes = [];\n                this.edges = [];\n                this.selectedNode = null;\n            }\n\n            addNode(x, y, label) {\n                const node = {\n                    id: this.nodes.length,\n                    x: x,\n                    y: y,\n                    label: label || `Node ${this.nodes.length}`,\n                    radius: 20\n                };\n                this.nodes.push(node);\n                return node;\n            }\n\n            addEdge(sourceId, targetId) {\n                // Check if edge already exists\n                const existingEdge = this.edges.find(edge => \n                    edge.source === sourceId && edge.target === targetId\n                );\n                \n                if (existingEdge) return;\n\n                const edge = { source: sourceId, target: targetId };\n                this.edges.push(edge);\n\n                // For undirected graphs, add reverse edge if it doesn't exist\n                if (this.type === 'undirected') {\n                    const reverseEdge = this.edges.find(e => \n                        e.source === targetId && e.target === sourceId\n                    );\n                    if (!reverseEdge) {\n                        this.edges.push({ source: targetId, target: sourceId });\n                    }\n                }\n            }\n\n            getNodeAt(x, y) {\n                return this.nodes.find(node => {\n                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);\n                    return distance <= node.radius;\n                });\n            }\n\n            getConnections(nodeId) {\n                const outgoing = this.edges.filter(edge => edge.source === nodeId)\n                    .map(edge => this.nodes[edge.target].label);\n                \n                const incoming = this.edges.filter(edge => edge.target === nodeId && edge.source !== nodeId)\n                    .map(edge => this.nodes[edge.source].label);\n\n                return { outgoing, incoming };\n            }\n        }\n\n        // Initialize graphs\n        const undirectedGraph = new Graph('undirected');\n        const directedGraph = new Graph('directed');\n        \n        // Canvas elements\n        const undirectedCanvas = document.getElementById('undirectedCanvas');\n        const directedCanvas = document.getElementById('directedCanvas');\n        const undirectedCtx = undirectedCanvas.getContext('2d');\n        const directedCtx = directedCanvas.getContext('2d');\n\n        // Info displays\n        const undirectedInfo = document.getElementById('undirectedInfo');\n        const directedInfo = document.getElementById('directedInfo');\n\n        // Initial sample graph\n        function initializeSampleGraph() {\n            // Add nodes to both graphs\n            for (let i = 0; i < 5; i++) {\n                const x = 100 + Math.random() * 300;\n                const y = 100 + Math.random() * 200;\n                undirectedGraph.addNode(x, y, String.fromCharCode(65 + i));\n                directedGraph.addNode(x, y, String.fromCharCode(65 + i));\n            }\n\n            // Add some sample edges\n            undirectedGraph.addEdge(0, 1);\n            undirectedGraph.addEdge(1, 2);\n            undirectedGraph.addEdge(2, 3);\n            undirectedGraph.addEdge(3, 4);\n            undirectedGraph.addEdge(4, 0);\n            undirectedGraph.addEdge(1, 3);\n\n            directedGraph.addEdge(0, 1);\n            directedGraph.addEdge(1, 2);\n            directedGraph.addEdge(2, 3);\n            directedGraph.addEdge(3, 4);\n            directedGraph.addEdge(4, 0);\n            directedGraph.addEdge(1, 3);\n            directedGraph.addEdge(3, 1); // Reverse edge to show direction\n\n            drawGraphs();\n        }\n\n        function drawGraph(ctx, graph) {\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            \n            // Draw edges\n            ctx.strokeStyle = '#666';\n            ctx.lineWidth = 2;\n            \n            graph.edges.forEach(edge => {\n                const source = graph.nodes[edge.source];\n                const target = graph.nodes[edge.target];\n                \n                ctx.beginPath();\n                ctx.moveTo(source.x, source.y);\n                \n                if (graph.type === 'directed') {\n                    // Draw arrow for directed edges\n                    const angle = Math.atan2(target.y - source.y, target.x - source.x);\n                    const headLength = 15;\n                    const distance = Math.sqrt((target.x - source.x) ** 2 + (target.y - source.y) ** 2);\n                    const adjustedDistance = Math.max(0, distance - source.radius - 5);\n                    \n                    const endX = source.x + Math.cos(angle) * adjustedDistance;\n                    const endY = source.y + Math.sin(angle) * adjustedDistance;\n                    \n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                    \n                    // Draw arrowhead\n                    ctx.beginPath();\n                    ctx.moveTo(endX, endY);\n                    ctx.lineTo(\n                        endX - headLength * Math.cos(angle - Math.PI / 6),\n                        endY - headLength * Math.sin(angle - Math.PI / 6)\n                    );\n                    ctx.lineTo(\n                        endX - headLength * Math.cos(angle + Math.PI / 6),\n                        endY - headLength * Math.sin(angle + Math.PI / 6)\n                    );\n                    ctx.closePath();\n                    ctx.fillStyle = '#666';\n                    ctx.fill();\n                } else {\n                    // Straight line for undirected edges\n                    const angle = Math.atan2(target.y - source.y, target.x - source.x);\n                    const distance = Math.sqrt((target.x - source.x) ** 2 + (target.y - source.y) ** 2);\n                    const adjustedDistance = Math.max(0, distance - source.radius - target.radius);\n                    \n                    const endX = source.x + Math.cos(angle) * (source.radius + adjustedDistance / 2);\n                    const endY = source.y + Math.sin(angle) * (source.radius + adjustedDistance / 2);\n                    \n                    const controlX = (source.x + target.x) / 2;\n                    const controlY = (source.y + target.y) / 2 - 30;\n                    \n                    ctx.quadraticCurveTo(controlX, controlY, endX, endY);\n                    ctx.stroke();\n                }\n            });\n\n            // Draw nodes\n            graph.nodes.forEach((node, index) => {\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);\n                ctx.fillStyle = graph.selectedNode === index ? '#ff6b6b' : '#4ecdc4';\n                ctx.fill();\n                ctx.strokeStyle = '#333';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n\n                // Draw label\n                ctx.fillStyle = '#333';\n                ctx.font = '14px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(node.label, node.x, node.y);\n            });\n        }\n\n        function drawGraphs() {\n            drawGraph(undirectedCtx, undirectedGraph);\n            drawGraph(directedCtx, directedGraph);\n        }\n\n        function handleCanvasClick(event, graph, infoElement) {\n            const rect = event.target.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n\n            const clickedNode = graph.getNodeAt(x, y);\n            \n            if (clickedNode) {\n                graph.selectedNode = graph.selectedNode === clickedNode.id ? null : clickedNode.id;\n                const connections = graph.getConnections(clickedNode.id);\n                \n                if (graph.selectedNode !== null) {\n                    infoElement.textContent = \n                        `Selected: ${clickedNode.label} | ` +\n                        `Outgoing: ${connections.outgoing.join(', ') || 'none'} | ` +\n                        `Incoming: ${connections.incoming.join(', ') || 'none'}`;\n                } else {\n                    infoElement.textContent = 'Click on nodes to see connections';\n                }\n            } else {\n                // Add new node if clicked on empty space\n                const label = String.fromCharCode(65 + graph.nodes.length);\n                graph.addNode(x, y, label);\n                graph.selectedNode = null;\n                infoElement.textContent = 'Click on nodes to see connections';\n            }\n\n            drawGraphs();\n        }\n\n        // Event listeners\n        undirectedCanvas.addEventListener('click', (event) => {\n            handleCanvasClick(event, undirectedGraph, undirectedInfo);\n        });\n\n        directedCanvas.addEventListener('click', (event) => {\n            handleCanvasClick(event, directedGraph, directedInfo);\n        });\n\n        // Control functions\n        function addRandomNode() {\n            const x1 = 50 + Math.random() * 400;\n            const y1 = 50 + Math.random() * 300;\n            const x2 = 50 + Math.random() * 400;\n            const y2 = 50 + Math.random() * 300;\n            \n            const label = String.fromCharCode(65 + undirectedGraph.nodes.length);\n            undirectedGraph.addNode(x1, y1, label);\n            directedGraph.addNode(x2, y2, label);\n            \n            drawGraphs();\n        }\n\n        function addRandomEdge() {\n            if (undirectedGraph.nodes.length < 2) return;\n            \n            const node1 = Math.floor(Math.random() * undirectedGraph.nodes.length);\n            let node2 = Math.floor(Math.random() * undirectedGraph.nodes.length);\n            \n            // Ensure different nodes\n            while (node2 === node1 && undirectedGraph.nodes.length > 1) {\n                node2 = Math.floor(Math.random() * undirectedGraph.nodes.length);\n            }\n            \n            undirectedGraph.addEdge(node1, node2);\n            directedGraph.addEdge(node1, node2);\n            \n            drawGraphs();\n        }\n\n        function clearGraphs() {\n            undirectedGraph.nodes = [];\n            undirectedGraph.edges = [];\n            directedGraph.nodes = [];\n            directedGraph.edges = [];\n            undirectedGraph.selectedNode = null;\n            directedGraph.selectedNode = null;\n            undirectedInfo.textContent = 'Click on nodes to see connections';\n            directedInfo.textContent = 'Click on nodes to see connections';\n            drawGraphs();\n        }\n\n        function generateRandomGraph() {\n            clearGraphs();\n            \n            // Add 6-10 random nodes\n            const nodeCount = 6 + Math.floor(Math.random() * 5);\n            for (let i = 0; i < nodeCount; i++) {\n                const x1 = 50 + Math.random() * 400;\n                const y1 = 50 + Math.random() * 300;\n                const x2 = 50 + Math.random() * 400;\n                const y2 = 50 + Math.random() * 300;\n                \n                const label = String.fromCharCode(65 + i);\n                undirectedGraph.addNode(x1, y1, label);\n                directedGraph.addNode(x2, y2, label);\n            }\n            \n            // Add random edges (more for demonstration)\n            const edgeCount = Math.floor(nodeCount * 1.5);\n            for (let i = 0; i < edgeCount; i++) {\n                const node1 = Math.floor(Math.random() * nodeCount);\n                let node2 = Math.floor(Math.random() * nodeCount);\n                \n                while (node2 === node1 && nodeCount > 1) {\n                    node2 = Math.floor(Math.random() * nodeCount);\n                }\n                \n                undirectedGraph.addEdge(node1, node2);\n                directedGraph.addEdge(node1, node2);\n                \n                // Add some reverse edges for directed graph to show directionality\n                if (Math.random() > 0.7) {\n                    directedGraph.addEdge(node2, node1);\n                }\n            }\n            \n            drawGraphs();\n        }\n\n        // Initialize\n        initializeSampleGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}