<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Prim's Algorithm Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#f6f8fb;
      --panel:#ffffff;
      --muted:#6b7280;
      --accent:#0ea5a4;
      --danger:#ef4444;
      --success:#10b981;
      --edge:#94a3b8;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{background:linear-gradient(180deg,#eef2ff 0%,var(--bg) 60%);padding:18px;box-sizing:border-box;color:#0f172a;}
    h1{margin:0 0 8px;font-size:20px;}
    .wrap{display:flex;gap:16px;align-items:flex-start;}
    .left{
      width:760px;
      min-width:300px;
      background:var(--panel);
      border-radius:10px;
      box-shadow:0 6px 18px rgba(15,23,42,0.08);
      padding:12px;
    }
    .right{
      width:360px;
      background:var(--panel);
      border-radius:10px;
      box-shadow:0 6px 18px rgba(15,23,42,0.08);
      padding:12px;
      display:flex;flex-direction:column;gap:10px;
      max-height:88vh;overflow:auto;
    }
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;}
    button, select, input[type="range"]{border:1px solid #e6eef8;padding:8px;border-radius:8px;background:#fff;cursor:pointer;}
    button:hover{filter:brightness(.98);}
    .canvas-wrap{position:relative;border-radius:8px;border:1px solid rgba(15,23,42,0.06);background:linear-gradient(180deg,#fff,#fafcff);height:640px;overflow:hidden;}
    canvas{display:block;background:transparent;}
    .hint{font-size:13px;color:var(--muted);margin-top:6px;}
    .small{font-size:13px;color:var(--muted);}
    .btn-primary{background:linear-gradient(90deg,var(--accent),#06b6d4);color:white;border:none;}
    .btn-danger{background:var(--danger);color:#fff;border:none;}
    .panel{padding:10px;border-radius:8px;border:1px solid rgba(15,23,42,0.04);background:linear-gradient(180deg,#fff,#fcfeff);}
    .info-row{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .table{font-family:monospace;background:#f8fafc;padding:8px;border-radius:6px;max-height:220px;overflow:auto;border:1px dashed rgba(15,23,42,0.03);}
    .node-list{display:flex;flex-direction:column;gap:6px;}
    .status{padding:8px;border-radius:6px;background:#f1f5f9;font-size:13px;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .legend .item{display:flex;gap:6px;align-items:center;font-size:13px}
    .legend .swatch{width:18px;height:12px;border-radius:4px;border:1px solid rgba(0,0,0,0.06)}
    .edge-weight{font-family:monospace;font-size:12px;padding:2px 6px;background:rgba(255,255,255,0.8);border-radius:6px;border:1px solid rgba(15,23,42,0.04)}
    .footer{font-size:13px;color:var(--muted);margin-top:8px;}
    .control-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label{font-size:13px;color:var(--muted);}
    input[type=number]{width:64px;padding:6px;border-radius:6px;border:1px solid #e6eef8}
    .log{font-size:13px;background:#0f172a;color:white;padding:8px;border-radius:6px;white-space:pre-wrap}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <h1>Interactive Prim's Algorithm (Minimum Spanning Tree)</h1>
  <div class="wrap">
    <div class="left">
      <div class="controls">
        <button id="addNodeBtn">Add Node (click canvas)</button>
        <button id="addEdgeBtn">Add Edge (click two nodes)</button>
        <button id="deleteBtn">Delete Mode</button>
        <button id="randomBtn">Random Graph</button>
        <button id="clearBtn">Clear Graph</button>
        <select id="startSelect" title="Choose start node"><option value="">Start Node</option></select>
        <button id="runBtn" class="btn-primary">Init Prim</button>
        <button id="stepBtn">Next Step</button>
        <button id="autoBtn">Auto Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset Steps</button>
      </div>
      <div class="canvas-wrap panel" id="canvasWrap">
        <canvas id="graphCanvas" width="740" height="620"></canvas>
      </div>
      <div class="hint">
        - Add nodes by clicking the canvas. Add edges by clicking "Add Edge" then selecting two nodes. Weights are prompted (or random if left blank).<br>
        - Choose a start node from the dropdown (or click a node to select). Click "Init Prim" to initialize. Use "Next Step" to step through Prim's algorithm, or "Auto Play".
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="info-row">
          <div><strong>Algorithm Status</strong></div>
          <div id="mstWeight" class="muted">MST weight: 0</div>
        </div>
        <div style="height:8px"></div>
        <div class="legend">
          <div class="item"><div class="swatch" style="background:#94a3b8"></div>Unselected edge</div>
          <div class="item"><div class="swatch" style="background:orange"></div>Candidate edge (updated key)</div>
          <div class="item"><div class="swatch" style="background:#10b981"></div>MST edge</div>
          <div class="item"><div class="swatch" style="background:#f97316"></div>Currently selected node</div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Nodes & Keys</strong>
          <div class="small muted">key = best connecting edge weight</div>
        </div>
        <div class="table" id="nodeTable">No nodes yet.</div>
      </div>

      <div class="panel">
        <strong>Log / Steps</strong>
        <div id="log" class="log" style="background:#0b1220">No algorithm run yet.</div>
      </div>

      <div class="panel">
        <strong>Controls & Shortcuts</strong>
        <div class="small muted" style="margin-top:8px">
          - Click a node while in normal mode to set start node.<br>
          - In "Add Edge" mode: click two nodes to create an edge (enter weight).<br>
          - Delete Mode: click nodes or edges to remove them.<br>
          - Random Graph creates nodes and edges with random weights; you can control n and density.
        </div>
        <div style="margin-top:8px" class="control-row">
          <label>n</label><input id="randN" type="number" value="7" min="2" />
          <label>density (0-1)</label><input id="randD" type="range" min="0" max="1" step="0.05" value="0.45" style="width:120px" />
          <label id="randDVal" class="muted">0.45</label>
        </div>
      </div>

      <div class="footer muted">Implementation: step-by-step Prim's algorithm. Data structures shown: key[], parent[], inMST[]. Edges colored as they become part of the MST or when they update a node's key.</div>
    </div>
  </div>

<script>
/*
  Prim's Algorithm Interactive Demo
  - Click "Add Node" then click canvas to add circles (nodes)
  - Click "Add Edge" then click two nodes to add an undirected weighted edge (enter weight when prompted)
  - Choose a start node (dropdown or click a node). Click "Init Prim" to initialize.
  - Use "Next Step" to advance the algorithm: it picks the vertex with smallest key not in MST, adds its connecting edge,
    then updates neighbor keys and parents. "Auto Play" advances automatically.
  - Visual: nodes, edges, weights. Colors indicate candidate edges, MST edges, current node, etc.
*/

(function(){
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');

  const addNodeBtn = document.getElementById('addNodeBtn');
  const addEdgeBtn = document.getElementById('addEdgeBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const runBtn = document.getElementById('runBtn');
  const stepBtn = document.getElementById('stepBtn');
  const autoBtn = document.getElementById('autoBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const startSelect = document.getElementById('startSelect');
  const nodeTable = document.getElementById('nodeTable');
  const logEl = document.getElementById('log');
  const mstWeightEl = document.getElementById('mstWeight');
  const randN = document.getElementById('randN');
  const randD = document.getElementById('randD');
  const randDVal = document.getElementById('randDVal');

  randD.addEventListener('input', ()=> randDVal.textContent = randD.value);

  let mode = 'none'; // 'addNode', 'addEdge', 'delete'
  let nodes = []; // {id,x,y}
  let edges = []; // {id,a,b,weight,inMST,highlighted,candidate}
  let nodeIdCounter = 0;
  let edgeIdCounter = 0;

  // Prim-related state
  let primState = {
    initialized:false,
    inMST: [], // boolean per node
    key: [], // per node
    parent: [], // per node
    current:null, // currently selected vertex this step
    stepCount:0,
    finished:false,
  };
  let autoTimer = null;
  const AUTO_DELAY = 900;

  // Interaction state
  let pendingEdgeFrom = null;

  // Canvas interactions
  function canvasPos(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left);
    const y = (evt.clientY - rect.top);
    return {x,y};
  }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function findNodeAt(x,y){
    for(let i=nodes.length-1;i>=0;i--){
      const n = nodes[i];
      if(dist(n,{x,y}) <= 16) return n;
    }
    return null;
  }

  function findEdgeAt(x,y){
    // pick an edge if point is near the segment
    for(let e of edges){
      const a = nodes.find(n=>n.id===e.a);
      const b = nodes.find(n=>n.id===e.b);
      if(!a||!b) continue;
      const d = pointToSegmentDistance({x,y}, a, b);
      if(d < 8) return e;
    }
    return null;
  }

  function pointToSegmentDistance(p,a,b){
    const vx = b.x - a.x;
    const vy = b.y - a.y;
    const wx = p.x - a.x;
    const wy = p.y - a.y;
    const c = (vx*wx + vy*wy) / (vx*vx + vy*vy || 1);
    const t = Math.max(0, Math.min(1, c));
    const px = a.x + t*vx;
    const py = a.y + t*vy;
    return Math.hypot(p.x-px, p.y-py);
  }

  canvas.addEventListener('click', (evt)=>{
    const p = canvasPos(evt);
    if(mode === 'addNode'){
      addNode(p.x,p.y);
      mode = 'none';
      updateModeButtons();
      return;
    }
    if(mode === 'addEdge'){
      const node = findNodeAt(p.x,p.y);
      if(!node){
        // clicked empty area -> cancel
        pendingEdgeFrom = null;
        return;
      }
      if(!pendingEdgeFrom){
        pendingEdgeFrom = node;
        log("Selected node " + node.id + " as source for new edge. Click target node.");
      } else {
        if(pendingEdgeFrom.id === node.id){
          log("Cannot connect node to itself. Select a different node.");
          pendingEdgeFrom = null;
          return;
        }
        const weightStr = prompt("Enter weight for the edge (positive number). Leave empty for random 1-20:");
        let w = parseFloat(weightStr);
        if(!weightStr || isNaN(w) || w <= 0) w = Math.floor(Math.random()*20)+1;
        addEdge(pendingEdgeFrom.id, node.id, w);
        pendingEdgeFrom = null;
        mode = 'none';
        updateModeButtons();
      }
      return;
    }
    if(mode === 'delete'){
      const node = findNodeAt(p.x,p.y);
      if(node){
        removeNode(node.id);
        return;
      }
      const edge = findEdgeAt(p.x,p.y);
      if(edge){
        removeEdge(edge.id);
        return;
      }
    }
    // normal mode: clicking a node chooses it as start node
    const node = findNodeAt(p.x,p.y);
    if(node){
      setStartNode(node.id);
    }
  });

  // Buttons
  addNodeBtn.addEventListener('click', ()=> { mode = 'addNode'; updateModeButtons(); log("Click on canvas to add a node."); });
  addEdgeBtn.addEventListener('click', ()=> { mode = 'addEdge'; pendingEdgeFrom = null; updateModeButtons(); log("Click two nodes to add an edge."); });
  deleteBtn.addEventListener('click', ()=> { mode = (mode==='delete') ? 'none' : 'delete'; updateModeButtons(); log(mode==='delete' ? "Delete mode: click node or edge to remove." : "Delete mode disabled."); });
  clearBtn.addEventListener('click', ()=> { if(confirm("Clear entire graph?")) clearGraph(); });
  randomBtn.addEventListener('click', ()=> createRandomGraph());
  runBtn.addEventListener('click', ()=> initPrim());
  stepBtn.addEventListener('click', ()=> primStep());
  autoBtn.addEventListener('click', ()=> startAuto());
  pauseBtn.addEventListener('click', ()=> stopAuto());
  resetBtn.addEventListener('click', ()=> resetPrim());

  function updateModeButtons(){
    addNodeBtn.style.border = mode==='addNode' ? '2px solid rgba(2,132,199,0.2)' : '';
    addEdgeBtn.style.border = mode==='addEdge' ? '2px solid rgba(2,132,199,0.2)' : '';
    deleteBtn.style.border = mode==='delete' ? '2px solid rgba(239,68,68,0.15)' : '';
  }

  function addNode(x,y){
    const id = nodeIdCounter++;
    nodes.push({id,x,y});
    primResetState();
    rebuildStartSelect();
    log("Added node " + id);
    draw();
  }

  function addEdge(a,b,w){
    // ensure undirected single edge and no duplicates
    if(a===b) return;
    if(edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a))){
      log("Edge already exists between " + a + " and " + b);
      return;
    }
    const id = edgeIdCounter++;
    edges.push({id,a,b,weight:Number(w), inMST:false, candidate:false});
    primResetState();
    log(`Added edge ${a} — ${b} (w=${w})`);
    draw();
  }

  function removeNode(id){
    nodes = nodes.filter(n=>n.id!==id);
    edges = edges.filter(e=>e.a!==id && e.b!==id);
    primResetState();
    rebuildStartSelect();
    log("Removed node " + id);
    draw();
  }

  function removeEdge(id){
    edges = edges.filter(e=>e.id!==id);
    primResetState();
    log("Removed edge " + id);
    draw();
  }

  function clearGraph(){
    nodes = [];
    edges = [];
    nodeIdCounter = 0;
    edgeIdCounter = 0;
    primResetState();
    rebuildStartSelect();
    log("Cleared graph");
    draw();
  }

  function createRandomGraph(){
    const n = parseInt(randN.value) || 6;
    const d = parseFloat(randD.value) || 0.45;
    clearGraph();
    // place nodes approx evenly
    for(let i=0;i<n;i++){
      const angle = (i/n) * Math.PI*2;
      const cx = 380 + Math.cos(angle) * 200 * (0.6 + Math.random()*0.8);
      const cy = 310 + Math.sin(angle) * 200 * (0.6 + Math.random()*0.8);
      addNode(cx + (Math.random()-0.5)*30, cy + (Math.random()-0.5)*30);
    }
    // add edges by probability, ensure connectivity by connecting neighbors
    for(let i=0;i<nodes.length;i++){
      for(let j=i+1;j<nodes.length;j++){
        if(Math.random() < d){
          let w = Math.floor(Math.random()*20)+1;
          addEdge(nodes[i].id, nodes[j].id, w);
        }
      }
    }
    // ensure connectivity: connect sequentially if graph ended up disconnected
    const comps = getComponents();
    if(comps.length>1){
      for(let k=0;k<comps.length-1;k++){
        const a = comps[k][0];
        const b = comps[k+1][0];
        addEdge(a,b, Math.floor(Math.random()*20)+1);
      }
    }
    primResetState();
    rebuildStartSelect();
    log("Random graph created: n="+n+" density="+d);
    draw();
  }

  function getComponents(){
    const adj = buildAdjacency();
    const visited = new Set();
    const comps = [];
    for(let n of nodes){
      if(visited.has(n.id)) continue;
      const stack = [n.id];
      const comp = [];
      visited.add(n.id);
      while(stack.length){
        const u = stack.pop();
        comp.push(u);
        for(let v of adj[u] || []){
          if(!visited.has(v)){
            visited.add(v); stack.push(v);
          }
        }
      }
      comps.push(comp);
    }
    return comps;
  }

  function rebuildStartSelect(){
    while(startSelect.options.length>1) startSelect.remove(1);
    for(let n of nodes){
      const o = document.createElement('option');
      o.value = n.id;
      o.textContent = n.id;
      startSelect.appendChild(o);
    }
    startSelect.value = '';
  }

  startSelect.addEventListener('change', ()=>{
    const v = startSelect.value;
    if(v==='') return;
    setStartNode(Number(v));
  });

  function setStartNode(id){
    // highlight start node in UI
    startSelect.value = id;
    primResetState();
    log("Start node set to " + id);
    draw();
  }

  // Prim algorithm core
  function initPrim(){
    if(nodes.length === 0) { alert("No nodes in graph."); return; }
    let start = startSelect.value;
    if(!start){
      // pick first node by default
      start = nodes[0].id;
      startSelect.value = start;
    } else start = Number(start);
    // initialize arrays
    const nCount = nodes.length;
    primState.inMST = {};
    primState.key = {};
    primState.parent = {};
    for(const nd of nodes){
      primState.inMST[nd.id] = false;
      primState.key[nd.id] = Infinity;
      primState.parent[nd.id] = null;
    }
    primState.key[start] = 0;
    primState.current = null;
    primState.stepCount = 0;
    primState.finished = false;
    primState.initialized = true;
    // reset edge flags
    for(let e of edges){ e.inMST=false; e.candidate=false; }
    log("Prim initialized. Start from node " + start + ". Keys set. Ready to step.");
    updateNodeTable();
    draw();
  }

  function primStep(){
    if(!primState.initialized){
      alert("Initialize Prim first (click 'Init Prim').");
      return;
    }
    if(primState.finished){
      log("Prim already finished.");
      return;
    }
    // pick u with smallest key not in MST
    let u = null;
    let best = Infinity;
    for(const nd of nodes){
      if(!primState.inMST[nd.id] && primState.key[nd.id] < best){
        best = primState.key[nd.id]; u = nd.id;
      }
    }
    if(u === null){
      // There is at least one vertex not inMST but unreachable (key == Infinity)
      // Try to pick any remaining node to mark as separate component (graph disconnected)
      const remaining = nodes.filter(n=>!primState.inMST[n.id]);
      if(remaining.length === 0){
        primState.finished = true;
        log("Prim finished. MST complete.");
        updateNodeTable();
        draw();
        return;
      } else {
        // pick first unreachable node and mark it as component root (its key stays Infinity -> treat as 0 for selection)
        u = remaining[0].id;
        // If it's unreachable, we'll mark as added but won't add edge
      }
    }

    primState.current = u;
    primState.stepCount++;
    // If parent exists, add that edge to MST
    if(primState.parent[u] !== null){
      const p = primState.parent[u];
      const e = edges.find(e => (e.a===u && e.b===p) || (e.b===u && e.a===p));
      if(e) e.inMST = true;
      log(`Step ${primState.stepCount}: Select node ${u} (key=${primState.key[u]}) and add edge ${p}—${u} to MST.`);
    } else {
      if(primState.key[u]===Infinity){
        log(`Step ${primState.stepCount}: Select unreachable node ${u} (no connecting edge) — new component.`);
      } else {
        log(`Step ${primState.stepCount}: Select start node ${u}.`);
      }
    }
    primState.inMST[u] = true;

    // Update neighbors
    const adj = buildAdjacencyDetailed();
    if(adj[u]){
      for(const nb of adj[u]){
        if(primState.inMST[nb.v]) continue;
        if(nb.weight < primState.key[nb.v]){
          primState.key[nb.v] = nb.weight;
          primState.parent[nb.v] = u;
          // mark edge as candidate (visual)
          const e = edges.find(e => (e.a===u && e.b===nb.v) || (e.b===u && e.a===nb.v));
          if(e) { e.candidate = true; }
          log(`  Update: node ${nb.v} key <- ${nb.weight} (parent=${u})`);
        } else {
          // not improving
          // optionally highlight the considered edge briefly (we'll just note)
        }
      }
    }
    // After updating, clear candidate flag for non-best edges
    for(const e of edges){
      if(e.candidate){
        // keep candidate only if it's currently the parent-edge of some node
        const keeps = nodes.some(n => primState.parent[n.id] !== null && ( (e.a===n.id && e.b===primState.parent[n.id]) || (e.b===n.id && e.a===primState.parent[n.id]) ));
        if(!keeps) e.candidate = false;
      }
    }

    // Check finish
    const allIn = nodes.every(n => primState.inMST[n.id]);
    if(allIn){
      primState.finished = true;
      log("Prim finished: all nodes in MST. Total weight = " + totalMSTWeight());
    }
    updateNodeTable();
    draw();
  }

  function buildAdjacency(){
    const adj = {};
    for(const n of nodes) adj[n.id] = [];
    for(const e of edges){
      adj[e.a].push(e.b);
      adj[e.b].push(e.a);
    }
    return adj;
  }

  function buildAdjacencyDetailed(){
    const adj = {};
    for(const n of nodes) adj[n.id] = [];
    for(const e of edges){
      adj[e.a].push({v:e.b, weight:e.weight});
      adj[e.b].push({v:e.a, weight:e.weight});
    }
    return adj;
  }

  function totalMSTWeight(){
    let sum = 0;
    for(const e of edges) if(e.inMST) sum += e.weight;
    return sum;
  }

  function primResetState(){
    // Called when graph changes: clear prim state but maintain initialization flag false
    primState.initialized = false;
    primState.inMST = [];
    primState.key = [];
    primState.parent = [];
    primState.current = null;
    primState.stepCount = 0;
    primState.finished = false;
    for(let e of edges){ e.inMST=false; e.candidate=false; }
    stopAuto();
    updateNodeTable();
    draw();
  }

  function resetPrim(){
    if(!primState.initialized){ log("Prim not initialized."); return; }
    const prevStart = startSelect.value ? Number(startSelect.value) : (nodes.length?nodes[0].id:null);
    initPrim();
    if(prevStart !== null) startSelect.value = prevStart;
    log("Prim reset to initial state.");
    draw();
  }

  function startAuto(){
    if(!primState.initialized){
      alert("Initialize Prim first.");
      return;
    }
    if(autoTimer) return;
    autoTimer = setInterval(()=>{
      if(primState.finished) stopAuto();
      else primStep();
    }, AUTO_DELAY);
    log("Auto-play started.");
  }
  function stopAuto(){
    if(autoTimer){ clearInterval(autoTimer); autoTimer = null; log("Auto-play paused."); }
  }

  function log(msg){
    const time = new Date().toLocaleTimeString();
    logEl.textContent = time + "   " + msg + "\n" + logEl.textContent;
    // keep log to reasonable size
    if(logEl.textContent.length > 8000) logEl.textContent = logEl.textContent.slice(0,8000);
  }

  // drawing
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawEdges();
    drawNodes();
    mstWeightEl.textContent = "MST weight: " + totalMSTWeight();
  }

  function drawEdges(){
    // draw edges with different colors depending on state
    for(const e of edges){
      const a = nodes.find(n=>n.id===e.a);
      const b = nodes.find(n=>n.id===e.b);
      if(!a || !b) continue;
      ctx.lineWidth = e.inMST ? 4 : 2;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      if(e.inMST){
        ctx.strokeStyle = '#10b981'; // green
      } else if(e.candidate){
        ctx.strokeStyle = 'orange';
      } else {
        ctx.strokeStyle = '#94a3b8';
      }
      ctx.stroke();
      // weight label in middle
      const mx = (a.x + b.x)/2;
      const my = (a.y + b.y)/2;
      const pad = 6;
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 1;
      roundRect(ctx, mx - 18, my - 12, 36, 20, 6, true, true);
      ctx.fillStyle = '#0b1220';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(e.weight), mx, my);
      ctx.beginPath();
    }
  }

  function drawNodes(){
    for(const n of nodes){
      const r = 16;
      // node background
      ctx.beginPath();
      ctx.arc(n.x, n.y, r, 0, Math.PI*2);
      // color depending on prim state
      let fill = '#ffffff';
      let stroke = '#0b1220';
      let lineWidth = 1;
      if(primState.initialized && primState.inMST && primState.inMST[n.id]){
        fill = '#ecfdf5'; // light green
        stroke = '#10b981';
        lineWidth = 2;
      }
      if(primState.current === n.id){
        fill = '#fff7ed'; // current amber
        stroke = '#f97316';
        lineWidth = 2;
      }
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lineWidth;
      ctx.fill();
      ctx.stroke();

      // node label (id)
      ctx.fillStyle = '#0b1220';
      ctx.font = '13px Inter, system-ui, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(n.id), n.x, n.y);

      // small key indicator near node
      if(primState.initialized && primState.key && primState.key[n.id] !== undefined){
        const key = primState.key[n.id];
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        roundRect(ctx, n.x-26, n.y+18, 52, 18, 6, true, true);
        ctx.fillStyle = '#0b1220';
        ctx.font = '12px monospace';
        ctx.fillText((key===Infinity? '∞' : key), n.x, n.y+27);
      }
    }
  }

  // utilities
  function roundRect(ctx, x, y, w, h, r, fill = true, stroke = false) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function updateNodeTable(){
    if(nodes.length === 0){ nodeTable.innerHTML = "No nodes yet."; return; }
    let html = '<div class="node-list">';
    for(const n of nodes){
      const id = n.id;
      const key = (primState.key && primState.key[id] !== undefined) ? (primState.key[id]===Infinity ? '∞' : primState.key[id]) : '-';
      const parent = (primState.parent && primState.parent[id] !== undefined && primState.parent[id] !== null) ? primState.parent[id] : '-';
      const inM = (primState.inMST && primState.inMST[id]) ? '✓' : '';
      const cur = primState.current === id ? '<span style="color:#f97316">current</span>' : '';
      html += `<div style="display:flex;justify-content:space-between;gap:8px;padding:6px 4px;border-bottom:1px dashed rgba(0,0,0,0.03)">
        <div style="min-width:36px"><strong>${id}</strong> ${cur}</div>
        <div style="color:#475569">key: <span style="font-family:monospace">${key}</span></div>
        <div style="color:#475569">parent: <span style="font-family:monospace">${parent}</span></div>
        <div style="color:#475569">inMST: ${inM}</div>
      </div>`;
    }
    html += '</div>';
    nodeTable.innerHTML = html;
    mstWeightEl.textContent = "MST weight: " + totalMSTWeight();
  }

  // initial draw
  draw();
  updateModeButtons();
  rebuildStartSelect();
  updateNodeTable();

  // convenience helpers for demo: seed some example graph (optional)
  // create a small example when page loads
  (function seedExample(){
    // create 6 nodes
    clearGraph();
    const coords = [
      {x:120,y:120},{x:620,y:110},{x:380,y:80},{x:220,y:420},{x:520,y:440},{x:100,y:280}
    ];
    for(let c of coords) addNode(c.x,c.y);
    addEdge(0,1,7); addEdge(0,2,9); addEdge(0,5,14);
    addEdge(1,2,10); addEdge(1,3,15); addEdge(2,3,11);
    addEdge(2,5,2); addEdge(3,4,6); addEdge(4,5,9);
    primResetState();
    rebuildStartSelect();
    log("Sample graph created (click start node and 'Init Prim').");
  })();

})();
</script>
</body>
</html>