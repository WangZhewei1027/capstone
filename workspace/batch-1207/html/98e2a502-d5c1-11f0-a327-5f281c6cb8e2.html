<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Recursion Playground — Interactive Demos</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 0; padding: 0; color: #111; background: #f6f8fb; }
    header { background: #0b6efd; color: white; padding: 18px 20px; box-shadow: 0 2px 6px rgba(11,110,253,0.15); }
    header h1 { margin: 0; font-size: 20px; }
    header p { margin: 6px 0 0; font-size: 13px; opacity: 0.95; }
    main { display: grid; grid-template-columns: 1fr 420px; gap: 18px; padding: 18px; max-width: 1200px; margin: 18px auto; }
    section.card { background: white; border-radius: 10px; padding: 14px; box-shadow: 0 2px 8px rgba(22,27,50,0.06); }
    .card h2 { margin: 2px 0 10px; font-size: 16px; }
    .small { font-size: 13px; color: #475569; margin-bottom: 8px; }
    label { display:block; font-size:13px; margin-top:8px; }
    input[type="number"], select { width:100%; padding:8px 10px; margin-top:6px; border-radius:6px; border:1px solid #d6dbe9; box-sizing:border-box; }
    button { background:#0b6efd; color:white; padding:8px 12px; border:none; border-radius:8px; cursor:pointer; margin-top:10px; }
    button.secondary { background:#e6eefc; color:#0b6efd; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .output { background:#0f1724; color:#e6eefc; padding:10px; border-radius:8px; font-family: monospace; white-space: pre-wrap; max-height:300px; overflow:auto; }
    .canvas-wrap { background:#fff; border-radius:10px; padding:10px; display:flex; gap:10px; align-items:flex-start; }
    canvas { background:#fff; border-radius:6px; box-shadow: inset 0 0 0 1px #eef2ff; }
    .legend { font-size:12px; color:#475569; }
    .stat { font-size:13px; padding:6px 8px; background:#f1f5f9; border-radius:8px; display:inline-block; margin-right:8px; }
    .callstack { max-height:320px; overflow:auto; background:#fff; border-radius:8px; padding:10px; border:1px solid #e6eefc; }
    .frame { padding:8px; margin-bottom:8px; border-radius:8px; background:linear-gradient(180deg,#fbfdff,#f5f9ff); box-shadow: 0 1px 0 rgba(11,110,253,0.05); font-family: monospace; }
    .frame.active { outline: 2px solid #c7e0ff; background: linear-gradient(180deg,#eaf6ff,#e6f2ff); }
    footer { text-align:center; color:#94a3b8; font-size:12px; margin:18px 0 40px; }
    a.inline { color:#0b6efd; text-decoration:none; }
    @media (max-width:980px) {
      main { grid-template-columns: 1fr; padding:12px; }
      .canvas-wrap { flex-direction:column; align-items:center; }
      canvas { max-width:100%; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Recursion Playground</h1>
    <p>Interactive demonstrations that show how recursion works: call stacks, recursion trees, performance, and a visual fractal.</p>
  </header>

  <main>
    <div>
      <!-- Factorial / Call Stack Demo -->
      <section class="card" id="factorialCard">
        <h2>Factorial — Recursion & Call Stack</h2>
        <div class="small">Compute n! using recursion. See the call stack and the recursion tree of calls.</div>

        <label>n (integer ≥ 0)</label>
        <input type="number" id="factN" value="6" min="0" step="1">

        <div class="row" style="margin-top:8px;">
          <button id="runFact">Run Recursive Factorial</button>
          <button id="runFactIter" class="secondary">Show Iterative</button>
          <label style="margin:0 0 0 8px;"><input type="checkbox" id="animateStack" checked> animate stack</label>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px; align-items:flex-start;">
          <div style="flex:1;">
            <div class="small">Call stack (top = current active call)</div>
            <div id="factStack" class="callstack" aria-live="polite"></div>
          </div>
          <div style="width:260px;">
            <div class="small">Result & logs</div>
            <div id="factOutput" class="output">Press "Run Recursive Factorial".</div>
          </div>
        </div>
      </section>

      <!-- Fibonacci Demo -->
      <section class="card" id="fibCard" style="margin-top:14px;">
        <h2>Fibonacci — naive recursion vs memoization</h2>
        <div class="small">Compare the explosion of calls in naive recursion with a memoized version that reuses results.</div>

        <label>n (recommended ≤ 35 for naive)</label>
        <input type="number" id="fibN" value="28" min="0" step="1">

        <div class="row">
          <button id="runFib">Run Naive Recursion</button>
          <button id="runFibMemo" class="secondary">Run Memoized</button>
          <button id="showFibTree" class="secondary">Show Recursion Tree (n ≤ 8)</button>
        </div>

        <div style="margin-top:10px;">
          <span class="stat" id="fibTime">—</span>
          <span class="stat" id="fibCalls">—</span>
          <span class="legend">Time and call counts</span>
        </div>

        <div style="display:flex; gap:12px; margin-top:10px;">
          <div style="flex:1;">
            <div class="small">Logs</div>
            <div id="fibOutput" class="output">Press a button to run.</div>
          </div>
          <div style="width:300px;">
            <div class="small">Recursion tree (small n)</div>
            <div id="fibTree" class="callstack" style="max-height:240px;"></div>
          </div>
        </div>
      </section>

      <!-- Binary Search Demo -->
      <section class="card" id="bsCard" style="margin-top:14px;">
        <h2>Binary Search — Divide & Conquer (recursive)</h2>
        <div class="small">A sorted array and a recursive binary search that highlights mid values and subranges.</div>

        <label>Array size</label>
        <input type="number" id="bsSize" value="15" min="3" step="1">

        <label>Target (value in array)</label>
        <input type="number" id="bsTarget" value="0" step="1">

        <div class="row">
          <button id="genArray">Generate Sorted Array</button>
          <button id="runBS">Run Recursive Binary Search</button>
        </div>

        <div style="display:flex; gap:12px; margin-top:10px; align-items:flex-start;">
          <div style="flex:1;">
            <div class="small">Array (click a value to choose it)</div>
            <div id="bsArray" class="callstack" style="display:flex; flex-wrap:wrap; gap:6px; padding:8px;"></div>
          </div>
          <div style="width:300px;">
            <div class="small">Trace</div>
            <div id="bsTrace" class="callstack" style="max-height:250px;"></div>
          </div>
        </div>
      </section>
    </div>

    <aside>
      <!-- Fractal / Visual Recursion -->
      <section class="card">
        <h2>Fractal Tree — Visual Recursion</h2>
        <div class="small">A simple recursive branch drawing. Increase depth to see more recursive calls.</div>

        <div class="canvas-wrap" style="flex-direction:column;">
          <canvas id="treeCanvas" width="380" height="380"></canvas>
          <div style="width:100%; display:flex; gap:8px; align-items:center; margin-top:8px;">
            <label style="flex:1;">
              Depth: <input id="treeDepth" type="range" min="0" max="12" value="8" style="width:100%;">
            </label>
            <button id="drawTree">Redraw</button>
          </div>
          <div style="margin-top:8px;" class="legend">Tip: larger depth shows more recursion depth — browser stack usage increases with depth.</div>
        </div>
      </section>

      <!-- Generic Call Stack Visualizer -->
      <section class="card" style="margin-top:14px;">
        <h2>Call Stack Visualization</h2>
        <div class="small">Shows how recursive calls push and pop frames. Use the example function shown below (sumRange).</div>

        <div class="small" style="margin-top:6px;">
          sumRange(a, b): recursively computes sum of integers from a to b (inclusive). It's a tail-recursive friendly pattern (not optimized in JS).
        </div>
        <label>a</label><input type="number" id="srA" value="1">
        <label>b</label><input type="number" id="srB" value="6">
        <div class="row">
          <button id="runSumRange">Run sumRange</button>
          <button id="stepSumRange" class="secondary">Step-through</button>
        </div>

        <div style="margin-top:10px;">
          <div class="small">Call stack</div>
          <div id="srStack" class="callstack"></div>
          <div class="small" style="margin-top:8px;">Output</div>
          <div id="srOutput" class="output">—</div>
        </div>
      </section>
    </aside>
  </main>

  <footer>
    Built to teach recursion — factorial, fibonacci, binary search, and a fractal tree. Try changing inputs!
  </footer>

  <script>
    // Utility
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function el(id){ return document.getElementById(id); }
    function clearChildren(node){ node.innerHTML = ''; }

    // ---------- Factorial Demo ----------
    const factStackEl = el('factStack'), factOutputEl = el('factOutput');
    el('runFact').addEventListener('click', async ()=>{
      const n = Math.max(0, Math.floor(Number(el('factN').value) || 0));
      clearChildren(factStackEl);
      factOutputEl.textContent = 'Running recursive factorial...';
      const animate = el('animateStack').checked;

      let steps = [];
      // We'll implement recursion that records push/pop events
      function factorialRec(k){
        steps.push({type:'push', n:k});
        if (k <= 1){
          steps.push({type:'result', n:k, res:1});
          steps.push({type:'pop', n:k, res:1});
          return 1;
        }
        const r = factorialRec(k-1) * k;
        steps.push({type:'result', n:k, res:r});
        steps.push({type:'pop', n:k, res:r});
        return r;
      }

      const result = factorialRec(n);

      // Animate or display instantly
      if (animate){
        const frames = [];
        const stack = [];
        factStackEl.innerHTML = '';
        for (const ev of steps){
          if (ev.type === 'push'){
            stack.unshift(ev);
            renderStack(stack, factStackEl);
            await sleep(220);
          } else if (ev.type === 'result'){
            // annotate top frame with result
            if (stack.length && stack[0].n === ev.n) stack[0].res = ev.res;
            renderStack(stack, factStackEl);
            await sleep(180);
          } else if (ev.type === 'pop'){
            renderStack(stack, factStackEl, ev);
            await sleep(220);
            if (stack.length && stack[0].n === ev.n) stack.shift();
            renderStack(stack, factStackEl);
            await sleep(120);
          }
        }
        factOutputEl.textContent = `Result: ${n}! = ${result}`;
      } else {
        // instant
        renderStackSummary(steps, factStackEl);
        factOutputEl.textContent = `Result: ${n}! = ${result}`;
      }
    });

    el('runFactIter').addEventListener('click', ()=>{
      const n = Math.max(0, Math.floor(Number(el('factN').value) || 0));
      let acc = 1;
      let log = [];
      for (let i=1;i<=n;i++){ acc*=i; log.push(`${i}! = ${acc}`); }
      el('factOutput').textContent = `Iterative result: ${n}! = ${acc}\nTrace:\n` + log.join('\n');
      clearChildren(factStackEl);
      // show final frame
      const d = document.createElement('div'); d.className='frame active'; d.textContent = `iterative frame\nn=${n}\nresult=${acc}`; factStackEl.appendChild(d);
    });

    function renderStack(stack, container, highlightEv){
      container.innerHTML = '';
      stack.forEach((frame, idx)=>{
        const f = document.createElement('div');
        f.className = 'frame' + (idx === 0 ? ' active' : '');
        let txt = `fact(${frame.n})`;
        if (frame.res !== undefined) txt += ` → ${frame.res}`;
        f.textContent = txt;
        container.appendChild(f);
      });
      if (highlightEv && highlightEv.type==='pop'){
        const note = document.createElement('div'); note.style.fontSize='12px'; note.style.color='#475569';
        note.style.marginTop='6px'; note.textContent = `Popped fact(${highlightEv.n}) = ${highlightEv.res}`;
        container.appendChild(note);
      }
    }

    function renderStackSummary(steps, container){
      container.innerHTML='';
      // reconstruct final stack (empty after run) but show each unique pushed frame in call order
      const pushed = steps.filter(s => s.type==='push').map(s=>s.n);
      pushed.slice().reverse().forEach(n=>{
        const f = document.createElement('div'); f.className='frame'; f.textContent = `fact(${n})`;
        container.appendChild(f);
      });
      const lastRes = steps.filter(s=>s.type==='result').slice(-1)[0];
      if (lastRes) {
        const r = document.createElement('div'); r.style.marginTop='8px'; r.style.fontSize='13px';
        r.textContent = `Final: fact(${pushed[0]}) = ${lastRes.res}`;
        container.appendChild(r);
      }
    }

    // ---------- Fibonacci Demo ----------
    const fibOutputEl = el('fibOutput'), fibTreeEl = el('fibTree'), fibTimeEl = el('fibTime'), fibCallsEl = el('fibCalls');
    el('runFib').addEventListener('click', ()=>{
      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));
      fibOutputEl.textContent = 'Running naive recursive Fibonacci...';
      fibTreeEl.innerHTML='';
      // count calls
      let calls=0;
      const t0 = performance.now();
      function fib(k){
        calls++;
        if (k<=1) return k;
        return fib(k-1)+fib(k-2);
      }
      const res = fib(n);
      const t1 = performance.now();
      fibOutputEl.textContent = `fib(${n}) = ${res}`;
      fibTimeEl.textContent = `Time: ${(t1-t0).toFixed(2)} ms`;
      fibCallsEl.textContent = `Calls: ${calls.toLocaleString()}`;
    });

    el('runFibMemo').addEventListener('click', ()=>{
      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));
      fibOutputEl.textContent = 'Running memoized Fibonacci...';
      fibTreeEl.innerHTML='';
      const t0 = performance.now();
      let calls=0;
      const memo = new Map();
      function fib(k){
        calls++;
        if (k<=1) return k;
        if (memo.has(k)) return memo.get(k);
        const val = fib(k-1)+fib(k-2);
        memo.set(k, val);
        return val;
      }
      const res = fib(n);
      const t1 = performance.now();
      fibOutputEl.textContent = `fib(${n}) = ${res}\nMemo entries: ${memo.size}`;
      fibTimeEl.textContent = `Time: ${(t1-t0).toFixed(2)} ms`;
      fibCallsEl.textContent = `Effective calls: ${calls.toLocaleString()}`;
    });

    el('showFibTree').addEventListener('click', ()=>{
      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));
      fibTreeEl.innerHTML='';
      if (n>8){ fibTreeEl.textContent='Too big to draw tree (choose n ≤ 8)'; return; }
      // Build a simple textual tree
      function buildLines(k, prefix=''){
        if (k<=1) return [`${prefix}${k}`];
        const left = buildLines(k-1, prefix + '  ');
        const right = buildLines(k-2, prefix + '  ');
        return [`${prefix}${k}`].concat(left).concat(right);
      }
      const lines = buildLines(n);
      fibTreeEl.textContent = lines.join('\n');
      fibOutputEl.textContent = 'Recursion tree printed at right.';
      fibTimeEl.textContent = '—';
      fibCallsEl.textContent = `Nodes: ${lines.length}`;
    });

    // ---------- Binary Search Demo ----------
    const bsArrayEl = el('bsArray'), bsTraceEl = el('bsTrace');
    let currentArray = [];
    function genArray(size){
      const arr = [];
      let start = Math.floor(Math.random()*10);
      for (let i=0;i<size;i++){ arr.push(start + i*2 + Math.floor(Math.random()*2)); }
      arr.sort((a,b)=>a-b);
      return Array.from(new Set(arr)).slice(0,size); // ensure unique-ish
    }
    el('genArray').addEventListener('click', ()=>{
      const size = Math.max(3, Math.floor(Number(el('bsSize').value) || 10));
      currentArray = genArray(size);
      renderArray();
    });
    function renderArray(){
      bsArrayEl.innerHTML='';
      currentArray.forEach(v=>{
        const b = document.createElement('button');
        b.textContent = v; b.style.padding='6px 8px'; b.style.borderRadius='8px'; b.style.border='1px solid #eef2ff';
        b.style.background='white'; b.style.cursor='pointer';
        b.onclick = ()=>{ el('bsTarget').value = v; };
        bsArrayEl.appendChild(b);
      });
    }
    el('runBS').addEventListener('click', ()=>{
      if (!currentArray.length) currentArray = genArray(Math.max(3,Number(el('bsSize').value)||10));
      const target = Number(el('bsTarget').value);
      bsTraceEl.innerHTML = '';
      // recursive binary search with trace
      function bs(lo, hi, depth=0){
        const frame = document.createElement('div'); frame.className='frame'; frame.textContent = `[depth ${depth}] lo=${lo}, hi=${hi}`;
        bsTraceEl.appendChild(frame);
        if (lo>hi){ const nf = document.createElement('div'); nf.style.marginTop='6px'; nf.textContent = 'Not found.'; bsTraceEl.appendChild(nf); return -1; }
        const mid = Math.floor((lo+hi)/2);
        const midVal = currentArray[mid];
        const mark = document.createElement('div'); mark.style.fontSize='13px'; mark.textContent = `mid=${mid} → ${midVal}`;
        frame.appendChild(mark);
        if (midVal === target){
          const found = document.createElement('div'); found.style.marginTop='6px'; found.style.color='#0b6efd'; found.textContent = `Found at index ${mid}`;
          bsTraceEl.appendChild(found);
          return mid;
        } else if (target < midVal){
          return bs(lo, mid-1, depth+1);
        } else {
          return bs(mid+1, hi, depth+1);
        }
      }
      const idx = bs(0, currentArray.length-1);
      if (idx >= 0) {
        // highlight selection on array
        Array.from(bsArrayEl.children).forEach((btn, i)=>{
          btn.style.background = (i===idx) ? '#e6f0ff' : 'white';
          btn.style.border = (i===idx) ? '1px solid #0b6efd' : '1px solid #eef2ff';
        });
      }
    });

    // initialize array
    currentArray = genArray(15); renderArray();

    // ---------- Fractal Tree ----------
    const treeCanvas = el('treeCanvas'), treeDepth = el('treeDepth');
    const ctx = treeCanvas.getContext('2d');
    function drawTree(){
      const w = treeCanvas.width, h = treeCanvas.height;
      ctx.clearRect(0,0,w,h);
      ctx.translate(w/2, h-20);
      const depth = Number(treeDepth.value);
      ctx.lineCap = 'round';
      function branch(len, angle, depthLeft){
        ctx.save();
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0, -len);
        ctx.strokeStyle = `hsl(${120 - depthLeft*10}, 60%, ${40 + depthLeft*3}%)`;
        ctx.lineWidth = Math.max(1, depthLeft*0.8 + 1);
        ctx.stroke();
        ctx.translate(0, -len);
        if (depthLeft>0){
          branch(len*0.75, Math.PI/8, depthLeft-1);
          branch(len*0.68, -Math.PI/6, depthLeft-1);
        }
        ctx.restore();
      }
      ctx.save();
      branch(60, 0, depth);
      ctx.restore();
      // reset transform
      ctx.setTransform(1,0,0,1,0,0);
    }
    el('drawTree').addEventListener('click', drawTree);
    drawTree();

    // ---------- sumRange (call stack visualizer) ----------
    const srStack = el('srStack'), srOutput = el('srOutput');
    el('runSumRange').addEventListener('click', async ()=>{
      srStack.innerHTML=''; srOutput.textContent='Running sumRange...';
      const a = Number(el('srA').value), b = Number(el('srB').value);
      let steps = [];
      function sumRange(a,b){
        steps.push({type:'push', a:a, b:b});
        if (a>b){
          steps.push({type:'pop', a:a, b:b, res:0});
          return 0;
        }
        if (a===b){
          steps.push({type:'result', a:a, b:b, res:a});
          steps.push({type:'pop', a:a, b:b, res:a});
          return a;
        }
        const res = a + sumRange(a+1, b);
        steps.push({type:'result', a:a, b:b, res:res});
        steps.push({type:'pop', a:a, b:b, res:res});
        return res;
      }
      const res = sumRange(a,b);
      // animate quickly
      const stack = [];
      for (const ev of steps){
        if (ev.type==='push'){ stack.unshift(ev); renderSRStack(stack); await sleep(160); }
        else if (ev.type==='result'){ if (stack.length) stack[0].res = ev.res; renderSRStack(stack); await sleep(120); }
        else if (ev.type==='pop'){ renderSRStack(stack, ev); await sleep(140); if (stack.length) stack.shift(); renderSRStack(stack); await sleep(80); }
      }
      srOutput.textContent = `sumRange(${a}, ${b}) = ${res}`;
    });

    let stepMode = null;
    el('stepSumRange').addEventListener('click', ()=>{
      // prepare generator for stepping
      const a = Number(el('srA').value), b = Number(el('srB').value);
      srStack.innerHTML=''; srOutput.textContent='Step mode — press Step-through again to advance.';
      const steps = [];
      function sumRange(a,b){
        steps.push({type:'push', a:a, b:b});
        if (a>b){
          steps.push({type:'pop', a:a, b:b, res:0});
          return 0;
        }
        if (a===b){
          steps.push({type:'result', a:a, b:b, res:a});
          steps.push({type:'pop', a:a, b:b, res:a});
          return a;
        }
        const res = a + sumRange(a+1, b);
        steps.push({type:'result', a:a, b:b, res:res});
        steps.push({type:'pop', a:a, b:b, res:res});
        return res;
      }
      sumRange(a,b);
      // store steps in stepMode
      stepMode = {steps, idx:0, stack:[]};
      // replace button behavior to step
      el('stepSumRange').textContent='Step';
      el('stepSumRange').onclick = async ()=>{
        if (!stepMode) return;
        const ev = stepMode.steps[stepMode.idx++];
        if (!ev) {
          srOutput.textContent = 'Done.';
          el('stepSumRange').textContent='Step-through';
          // reinstate listener
          el('stepSumRange').onclick = ()=>{ /* old handler */ stepMode=null; el('stepSumRange').textContent='Step-through'; };
          return;
        }
        if (ev.type==='push'){ stepMode.stack.unshift(ev); renderSRStack(stepMode.stack); }
        else if (ev.type==='result'){ if (stepMode.stack.length) stepMode.stack[0].res = ev.res; renderSRStack(stepMode.stack); }
        else if (ev.type==='pop'){ renderSRStack(stepMode.stack, ev); if (stepMode.stack.length) stepMode.stack.shift(); }
      };
    });

    function renderSRStack(stack, highlight){
      srStack.innerHTML='';
      stack.forEach((f, i)=>{
        const d = document.createElement('div'); d.className='frame' + (i===0 ? ' active' : '');
        d.textContent = `sumRange(${f.a}, ${f.b})` + (f.res!==undefined ? ` → ${f.res}` : '');
        srStack.appendChild(d);
      });
      if (highlight){
        const note = document.createElement('div'); note.style.fontSize='13px'; note.style.color='#475569';
        note.style.marginTop='6px';
        note.textContent = `Popped ${highlight.a},${highlight.b} → ${highlight.res}`;
        srStack.appendChild(note);
      }
    }

    // Accessibility & keyboard: allow pressing Enter on inputs to run primary action
    document.querySelectorAll('input[type="number"]').forEach(inp=>{
      inp.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          const id = inp.id;
          if (id.startsWith('fact')) el('runFact').click();
          else if (id.startsWith('fib')) el('runFib').click();
          else if (id.startsWith('bs')) el('runBS').click();
          else if (id.startsWith('sr')) el('runSumRange').click();
        }
      });
    });

    // Minor: on load, set bsTarget to first value
    el('bsTarget').value = currentArray[0] || 0;

    // Quick explanation printed to console for curious users
    console.log("Recursion Playground loaded. Try factorial, fibonacci, binary search, and draw the fractal tree.");
  </script>
</body>
</html>