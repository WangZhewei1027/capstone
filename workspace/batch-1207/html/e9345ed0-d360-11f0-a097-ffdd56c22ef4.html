<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Kruskal's Algorithm Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #f7f9fb;
      --panel: #ffffff;
      --accent: #2b7cff;
      --muted: #6b7280;
      --good: #16a34a;
      --bad: #ef4444;
      --yellow: #f59e0b;
    }
    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#0f172a; }
    .container { display:flex; gap:16px; padding:16px; box-sizing:border-box; height:100%; }
    .left, .right { background:var(--panel); border-radius:12px; padding:12px; box-shadow: 0 1px 3px rgba(2,6,23,0.06); }
    .left { flex:1; display:flex; flex-direction:column; gap:12px; min-width:680px; }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .controls label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
    .control-group { display:flex; flex-direction:column; min-width:120px; }
    input[type="number"], input[type="range"], select { padding:8px 10px; border-radius:8px; border:1px solid #e6eef8; background:white; outline:none; font-size:13px; }
    button { padding:8px 12px; border-radius:8px; border:0; background:var(--accent); color:white; cursor:pointer; font-weight:600; }
    button.secondary { background:#eef2ff; color:var(--accent); border:1px solid rgba(43,124,255,0.12); }
    button.warn { background:var(--bad); }
    .svg-wrap { background:linear-gradient(180deg,#ffffff, #fbfdff); border-radius:8px; padding:8px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
    svg { width:100%; height:600px; border-radius:8px; display:block; }
    .right { width:360px; display:flex; flex-direction:column; gap:12px; }
    .panel { padding:8px; border-radius:8px; background:linear-gradient(180deg,#ffffff, #fbfdff); box-shadow: 0 1px 2px rgba(2,6,23,0.04); }
    h2 { margin:6px 0 8px 0; font-size:18px; }
    small { color:var(--muted); }
    .edge-list { max-height:300px; overflow:auto; border-top:1px dashed #eef2ff; margin-top:8px; padding-top:8px; }
    .edge-item { display:flex; justify-content:space-between; gap:8px; padding:6px 8px; border-radius:8px; align-items:center; }
    .edge-item:hover { background:#fbfbff; }
    .edge-weight { font-weight:700; background:#eef6ff; color:var(--accent); padding:4px 8px; border-radius:999px; font-size:13px; }
    .edge-state { font-size:12px; color:var(--muted); }
    .status { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .chip { background:#f1f5f9; padding:6px 10px; border-radius:999px; font-weight:600; color:#0f172a; }
    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .legend .dot { display:inline-block; width:12px; height:12px; border-radius:3px; margin-right:6px; vertical-align:middle; }
    .uf-box { display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:8px; border-radius:8px; background:#fbfdff; border:1px solid #eef2ff; }
    .uf-item { padding:6px 10px; border-radius:8px; background:#fff; border:1px solid #eef2ff; font-weight:600; }
    footer { margin-top:8px; font-size:12px; color:var(--muted); }
    .controls-row { display:flex; gap:8px; align-items:center; }
    .small { font-size:13px; color:var(--muted); }
    .slider-label { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .btn-icon { background:#eef6ff; color:var(--accent); border:0; padding:8px; border-radius:8px; cursor:pointer; }
    .edge-highlighted { filter: drop-shadow(0 6px 10px rgba(43,124,255,0.06)); }
    .input-inline { display:flex; gap:8px; align-items:center; }
    .note { font-size:13px; color:var(--muted); }
    /* small responsive */
    @media (max-width:1100px) {
      .container { flex-direction:column; }
      .left { min-width:auto; }
      .right { width:100%;}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="left">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h2>Kruskal's Algorithm Visualizer</h2>
          <small>Build a Minimum Spanning Tree by processing edges in increasing weight and using union-find to avoid cycles.</small>
        </div>
        <div class="legend">
          <div style="display:flex; flex-direction:column; gap:6px; align-items:flex-end;">
            <div><span class="dot" style="background:var(--good);"></span><small> Added to MST</small></div>
            <div><span class="dot" style="background:var(--bad);"></span><small> Rejected (would cycle)</small></div>
            <div><span class="dot" style="background:var(--yellow);"></span><small> Currently considered</small></div>
          </div>
        </div>
      </div>

      <div class="panel controls">
        <div class="control-group">
          <label>Nodes</label>
          <div class="input-inline">
            <input id="nodesCount" type="number" min="2" max="20" value="8" style="width:92px;" />
            <button id="genBtn" class="secondary">Generate</button>
          </div>
          <small class="note">Click Generate to create a random graph with given node count.</small>
        </div>

        <div class="control-group">
          <label>Edge Probability</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="edgeProb" type="range" min="0" max="100" value="45" />
            <div class="chip" id="probLabel">45%</div>
          </div>
          <small class="note">Controls how dense the random graph is.</small>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          <button id="resetBtn" class="secondary">Reset Colors</button>
          <button id="clearBtn" class="secondary">Clear All</button>
        </div>

        <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
          <button id="stepBtn">Step</button>
          <button id="playBtn">Play</button>
          <button id="fastBtn" class="secondary">Fast</button>
          <button id="pauseBtn" class="secondary">Pause</button>
        </div>

        <div style="display:flex; gap:12px; align-items:center; margin-top:6px;">
          <div class="control-group" style="min-width:160px;">
            <label>Speed (ms per step)</label>
            <input id="speed" type="range" min="50" max="2000" value="800" />
            <div class="small" id="speedLabel">800 ms</div>
          </div>

          <div style="min-width:140px;">
            <label>Graph Type</label>
            <select id="graphType">
              <option value="random">Random</option>
              <option value="complete">Complete</option>
            </select>
          </div>
        </div>

        <div style="display:flex; gap:12px; margin-top:6px; align-items:center;">
          <div class="status">
            <div class="chip">Step: <span id="curStep">0</span>/<span id="totalEdges">0</span></div>
            <div class="chip">MST Weight: <span id="mstWeight">0</span></div>
          </div>
        </div>

      </div>

      <div class="panel svg-wrap" id="canvasPanel">
        <svg id="svgCanvas" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
      </div>

      <div style="display:flex; gap:8px;">
        <div style="flex:1;" class="panel">
          <small><strong>Instructions</strong></small>
          <div class="note" style="margin-top:6px;">
            - Generate a graph, then use Step to process one edge at a time. Play auto-steps through the remaining edges.<br>
            - Kruskal sorts edges by weight and uses a union-find structure to prevent cycles: if two endpoints are in different sets, the edge is added to the MST.<br>
            - The right panel shows the sorted edge list and the union-find parent/rank information.
          </div>
        </div>
        <div style="width:320px;" class="panel">
          <small><strong>Controls Tip</strong></small>
          <div class="note" style="margin-top:6px;">
            - Toggle Graph Type to Complete for a complete graph (dense).<br>
            - Use Edge Probability (or Complete) to control density.<br>
            - Reset Colors will clear highlights but keep the current state; Clear All generates an empty canvas.
          </div>
        </div>
      </div>

    </div>

    <div class="right">
      <div class="panel">
        <h2>Sorted Edge List</h2>
        <small>Edges are sorted by weight (ascending). The currently considered edge is highlighted.</small>
        <div class="edge-list" id="edgeList"></div>
      </div>

      <div class="panel">
        <h2>Union-Find State</h2>
        <small>Displays parent and rank arrays plus sets colored by root.</small>
        <div style="margin-top:8px;">
          <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
            <div class="uf-box" id="ufParents"></div>
          </div>
          <div style="margin-top:8px;" id="ufRanks"></div>
        </div>
      </div>

      <div class="panel">
        <h2>Summary</h2>
        <div style="display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap;">
          <div class="chip">Edges considered: <span id="consideredCount">0</span></div>
          <div class="chip">Edges in MST: <span id="mstCount">0</span></div>
          <div class="chip">Nodes: <span id="nodesCountDisplay">0</span></div>
        </div>
        <footer>
          Kruskal's algorithm builds the minimum spanning tree by always picking the smallest edge that doesn't create a cycle. Union-Find (disjoint set) quickly answers whether two vertices belong to the same component.
        </footer>
      </div>

    </div>
  </div>

  <script>
    // Kruskal Visualizer - single-file
    (() => {
      const svg = document.getElementById('svgCanvas');
      const genBtn = document.getElementById('genBtn');
      const nodesCountIn = document.getElementById('nodesCount');
      const edgeProbIn = document.getElementById('edgeProb');
      const probLabel = document.getElementById('probLabel');
      const graphType = document.getElementById('graphType');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const fastBtn = document.getElementById('fastBtn');
      const resetBtn = document.getElementById('resetBtn');
      const clearBtn = document.getElementById('clearBtn');
      const edgeListEl = document.getElementById('edgeList');
      const curStepEl = document.getElementById('curStep');
      const totalEdgesEl = document.getElementById('totalEdges');
      const mstWeightEl = document.getElementById('mstWeight');
      const speedIn = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');
      const consideredCountEl = document.getElementById('consideredCount');
      const mstCountEl = document.getElementById('mstCount');
      const nodesCountDisplay = document.getElementById('nodesCountDisplay');
      const ufParentsEl = document.getElementById('ufParents');
      const ufRanksEl = document.getElementById('ufRanks');

      let width = 1000, height = 700;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

      let nodes = []; // {id, x, y, elem}
      let edges = []; // {id, a, b, w, lineElem, labelElem}
      let sortedEdges = []; // references to edges sorted
      let uf = null; // union-find
      let curIndex = 0;
      let mstWeight = 0;
      let consideredCount = 0;
      let mstEdges = [];
      let timer = null;
      let playing = false;

      function randInt(a, b) { return Math.floor(Math.random()*(b-a+1))+a; }
      function clearSVG() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      // Create a random layout of nodes on the canvas
      function generateNodes(n) {
        nodes = [];
        const padding = 60;
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n/cols);
        let i = 0;
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            if (i>=n) break;
            const jitterX = randInt(-40,40);
            const jitterY = randInt(-40,40);
            const x = padding + (width-2*padding)*(c/(cols-1||1)) + jitterX;
            const y = padding + (height-2*padding)*(r/(rows-1||1)) + jitterY;
            nodes.push({ id:i, x, y });
            i++;
          }
        }
      }

      // Build edges depending on graph type
      function buildEdges(prob, type) {
        edges = [];
        let id = 0;
        const n = nodes.length;
        for (let i=0;i<n;i++){
          for (let j=i+1;j<n;j++){
            let include = false;
            if (type === 'complete') include = true;
            else include = Math.random()*100 < prob;
            if (include) {
              const w = randInt(1, 99);
              edges.push({ id: id++, a: i, b: j, w });
            }
          }
        }
      }

      // Draw nodes and edges to SVG
      function drawGraph() {
        clearSVG();
        // Draw edges first (so nodes are on top)
        edges.forEach(e => {
          const na = nodes[e.a], nb = nodes[e.b];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', na.x);
          line.setAttribute('y1', na.y);
          line.setAttribute('x2', nb.x);
          line.setAttribute('y2', nb.y);
          line.setAttribute('stroke', '#cbd5e1');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('stroke-linecap', 'round');
          line.setAttribute('data-edge-id', e.id);
          svg.appendChild(line);
          e.lineElem = line;

          // weight label near midpoint
          const mx = (na.x + nb.x)/2;
          const my = (na.y + nb.y)/2;
          const labelBg = document.createElementNS('http://www.w3.org/2000/svg','rect');
          labelBg.setAttribute('x', mx-16);
          labelBg.setAttribute('y', my-14);
          labelBg.setAttribute('rx', 6);
          labelBg.setAttribute('ry', 6);
          labelBg.setAttribute('width', 32);
          labelBg.setAttribute('height', 20);
          labelBg.setAttribute('fill', '#ffffff');
          labelBg.setAttribute('stroke', '#eef2ff');
          labelBg.setAttribute('stroke-width', '1');
          labelBg.setAttribute('pointer-events', 'none');
          svg.appendChild(labelBg);

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', mx);
          label.setAttribute('y', my);
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('dominant-baseline', 'middle');
          label.setAttribute('font-size', '12');
          label.setAttribute('fill', '#0f172a');
          label.setAttribute('font-weight', '700');
          label.textContent = e.w;
          svg.appendChild(label);
          e.labelElem = label;
          e.labelBg = labelBg;
        });

        // Draw nodes on top
        nodes.forEach(n => {
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          g.setAttribute('data-node-id', n.id);

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', 18);
          circle.setAttribute('fill', '#fff');
          circle.setAttribute('stroke', '#c7d2fe');
          circle.setAttribute('stroke-width', '2');
          g.appendChild(circle);

          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x', 0);
          text.setAttribute('y', 0);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('font-size', '12');
          text.setAttribute('font-weight', '700');
          text.textContent = n.id;
          g.appendChild(text);

          svg.appendChild(g);
          n.elem = g;
        });
      }

      // Initialize union-find
      function UF(n) {
        this.parent = new Array(n);
        this.rank = new Array(n);
        for (let i=0;i<n;i++){ this.parent[i] = i; this.rank[i] = 0; }
      }
      UF.prototype.find = function(x){
        if (this.parent[x] !== x) {
          this.parent[x] = this.find(this.parent[x]); // path compression
        }
        return this.parent[x];
      }
      UF.prototype.union = function(a,b){
        let ra = this.find(a), rb = this.find(b);
        if (ra === rb) return false;
        if (this.rank[ra] < this.rank[rb]) {
          this.parent[ra] = rb;
        } else if (this.rank[ra] > this.rank[rb]) {
          this.parent[rb] = ra;
        } else {
          this.parent[rb] = ra;
          this.rank[ra] += 1;
        }
        return true;
      }

      // Prepare Kruskal state
      function prepareKruskal() {
        sortedEdges = edges.slice().sort((a,b)=> a.w - b.w || a.a - b.a || a.b - b.b);
        curIndex = 0;
        uf = new UF(nodes.length);
        mstWeight = 0;
        consideredCount = 0;
        mstEdges = [];
        updateUI();
        renderEdgeList();
        colorAllDefaults();
        highlightCounts();
      }

      function colorAllDefaults() {
        edges.forEach(e => {
          e.lineElem.setAttribute('stroke', '#cbd5e1');
          e.lineElem.setAttribute('stroke-width', '2');
          e.lineElem.setAttribute('stroke-dasharray', '');
          e.labelElem.setAttribute('fill', '#0f172a');
          e.labelBg.setAttribute('fill', '#ffffff');
        });
        nodes.forEach(n => {
          const g = n.elem;
          const circle = g.querySelector('circle');
          circle.setAttribute('fill', '#fff');
          circle.setAttribute('stroke', '#c7d2fe');
        });
      }

      // Step through one edge
      function step() {
        if (!sortedEdges || curIndex >= sortedEdges.length) {
          stopPlaying();
          return;
        }
        const e = sortedEdges[curIndex];

        // highlight considered
        highlightConsidered(e);

        // Wait briefly (visual) then decide (in play we rely on interval)
        // Do the check and union
        const a = e.a, b = e.b;
        const ra = uf.find(a), rb = uf.find(b);
        consideredCount++;
        if (ra !== rb) {
          // add to MST
          uf.union(a,b);
          mstEdges.push(e);
          mstWeight += e.w;
          colorEdgeAdded(e);
        } else {
          colorEdgeRejected(e);
        }
        curIndex++;
        updateUI();
        renderEdgeList();
        highlightCounts();
        recolorNodesBySet();
        if (curIndex >= sortedEdges.length) {
          stopPlaying();
        }
      }

      // Visual helpers
      function highlightConsidered(edge) {
        // make previously considered remain same; current get yellow
        edges.forEach(e => {
          if (e === edge) {
            e.lineElem.setAttribute('stroke', getCSSVar('--yellow') );
            e.lineElem.setAttribute('stroke-width', '4');
            e.lineElem.classList.add('edge-highlighted');
            e.lineElem.setAttribute('stroke-dasharray', '');
            e.labelBg.setAttribute('fill', '#fff7ed');
          } else {
            e.lineElem.classList.remove('edge-highlighted');
          }
        });
        // highlight list item
        const items = edgeListEl.querySelectorAll('.edge-item');
        items.forEach(it => {
          it.style.background = '';
        });
      }

      function colorEdgeAdded(e) {
        e.lineElem.setAttribute('stroke', getCSSVar('--good'));
        e.lineElem.setAttribute('stroke-width', '5');
        e.lineElem.setAttribute('stroke-dasharray', '');
        e.labelBg.setAttribute('fill', '#ecfdf5');
      }
      function colorEdgeRejected(e) {
        e.lineElem.setAttribute('stroke', getCSSVar('--bad'));
        e.lineElem.setAttribute('stroke-width', '3');
        e.lineElem.setAttribute('stroke-dasharray', '6 6');
        e.labelBg.setAttribute('fill', '#fff1f2');
      }

      function recolorNodesBySet() {
        const roots = {};
        let colorIdx = 0;
        const palette = [
          '#f97316','#06b6d4','#7c3aed','#ef4444','#10b981','#f59e0b','#3b82f6','#ef6f6c','#9333ea','#0ea5a4'
        ];
        nodes.forEach(n => {
          const r = uf.find(n.id);
          if (!(r in roots)) roots[r] = palette[colorIdx++ % palette.length];
        });
        nodes.forEach(n => {
          const g = n.elem;
          const circle = g.querySelector('circle');
          const color = roots[ uf.find(n.id) ] || '#fff';
          circle.setAttribute('fill', color);
          circle.setAttribute('stroke', '#ffffff');
        });

        // update UF display
        renderUF();
      }

      function renderEdgeList() {
        edgeListEl.innerHTML = '';
        totalEdgesEl.textContent = sortedEdges.length;
        sortedEdges.forEach((e, idx) => {
          const el = document.createElement('div');
          el.className = 'edge-item';
          el.style.display = 'flex';
          el.style.justifyContent = 'space-between';
          el.style.alignItems = 'center';
          el.style.padding = '6px';
          const left = document.createElement('div');
          left.innerHTML = `<strong>${e.a} â†” ${e.b}</strong> <span class="small" style="margin-left:6px;">(${idx+1})</span>`;
          const right = document.createElement('div');
          const wspan = document.createElement('span');
          wspan.className = 'edge-weight';
          wspan.textContent = e.w;
          right.appendChild(wspan);

          const state = document.createElement('div');
          state.className = 'edge-state';
          if (mstEdges.indexOf(e) !== -1) state.textContent = 'in MST';
          else if (idx < curIndex) state.textContent = 'rejected';
          else if (idx === curIndex) state.textContent = 'considering';
          else state.textContent = '';
          right.appendChild(state);

          el.appendChild(left);
          el.appendChild(right);

          // click to center/highlight
          el.addEventListener('click', () => {
            // scroll svg to show the edge (we just flash it)
            flashEdge(e);
          });

          edgeListEl.appendChild(el);
        });
      }

      function flashEdge(e) {
        const orig = e.lineElem.getAttribute('stroke');
        e.lineElem.setAttribute('stroke', getCSSVar('--accent'));
        e.lineElem.setAttribute('stroke-width', '6');
        setTimeout(()=> {
          // restore based on state
          if (mstEdges.indexOf(e) !== -1) colorEdgeAdded(e);
          else if (sortedEdges.indexOf(e) < curIndex) colorEdgeRejected(e);
          else {
            e.lineElem.setAttribute('stroke', '#cbd5e1');
            e.lineElem.setAttribute('stroke-width', '2');
            e.labelBg.setAttribute('fill', '#ffffff');
          }
        }, 700);
      }

      function updateUI() {
        curStepEl.textContent = curIndex;
        mstWeightEl.textContent = mstWeight;
        consideredCountEl.textContent = consideredCount;
        mstCountEl.textContent = mstEdges.length;
        nodesCountDisplay.textContent = nodes.length;
      }

      function renderUF() {
        ufParentsEl.innerHTML = '';
        ufRanksEl.innerHTML = '';
        // parents
        for (let i=0;i<nodes.length;i++){
          const box = document.createElement('div');
          box.className = 'uf-item';
          box.style.background = '#fff';
          box.style.border = '1px solid #eef2ff';
          box.textContent = `p[${i}] = ${uf.parent[i]}`;
          ufParentsEl.appendChild(box);
        }
        // ranks
        const rankTitle = document.createElement('div');
        rankTitle.style.fontSize = '13px';
        rankTitle.style.color = '#475569';
        rankTitle.style.marginTop = '6px';
        rankTitle.textContent = 'Ranks:';
        ufRanksEl.appendChild(rankTitle);
        for (let i=0;i<nodes.length;i++){
          const r = document.createElement('div');
          r.className = 'uf-item';
          r.style.background = '#fff';
          r.style.border = '1px solid #eef2ff';
          r.textContent = `r[${i}] = ${uf.rank[i]}`;
          ufRanksEl.appendChild(r);
        }
      }

      function highlightCounts() {
        // highlight the current considered in list
        const items = edgeListEl.querySelectorAll('.edge-item');
        items.forEach((it, idx)=>{
          it.style.background = (idx === curIndex) ? '#fff7ed' : '';
        });
      }

      function getCSSVar(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name) || '#000';
      }

      // Controls wiring
      genBtn.addEventListener('click', ()=> {
        const n = Math.max(2, Math.min(20, parseInt(nodesCountIn.value) || 8));
        const prob = parseInt(edgeProbIn.value);
        generateNodes(n);
        buildEdges(prob, graphType.value);
        drawGraph();
        prepareKruskal();
      });

      edgeProbIn.addEventListener('input', ()=>{
        probLabel.textContent = edgeProbIn.value + '%';
      });

      stepBtn.addEventListener('click', ()=> {
        stopPlaying();
        step();
      });

      playBtn.addEventListener('click', ()=> {
        if (playing) return;
        playing = true;
        const ms = parseInt(speedIn.value);
        timer = setInterval(()=> {
          if (curIndex >= sortedEdges.length) { stopPlaying(); return; }
          step();
        }, ms);
      });
      pauseBtn.addEventListener('click', ()=> stopPlaying());
      fastBtn.addEventListener('click', ()=> {
        stopPlaying();
        timer = setInterval(()=> {
          if (!sortedEdges || curIndex >= sortedEdges.length) { stopPlaying(); return; }
          step();
        }, 80);
        playing = true;
      });

      function stopPlaying() {
        if (timer) { clearInterval(timer); timer = null; }
        playing = false;
      }

      speedIn.addEventListener('input', ()=> {
        speedLabel.textContent = speedIn.value + ' ms';
        if (playing) {
          stopPlaying();
          // restart with new speed
          timer = setInterval(()=> {
            if (curIndex >= sortedEdges.length) { stopPlaying(); return; }
            step();
          }, parseInt(speedIn.value));
          playing = true;
        }
      });

      resetBtn.addEventListener('click', ()=> {
        colorAllDefaults();
        prepareKruskal(); // resets unions
        // But keep progress? We'll just reset everything to initial state
      });

      clearBtn.addEventListener('click', ()=> {
        stopPlaying();
        nodes = [];
        edges = [];
        sortedEdges = [];
        curIndex = 0;
        consideredCount = 0;
        mstWeight = 0;
        mstEdges = [];
        clearSVG();
        updateUI();
        edgeListEl.innerHTML = '';
        ufParentsEl.innerHTML = '';
        ufRanksEl.innerHTML = '';
        totalEdgesEl.textContent = 0;
      });

      // init with default sample
      function initDemo() {
        const n = parseInt(nodesCountIn.value) || 8;
        const prob = parseInt(edgeProbIn.value);
        generateNodes(n);
        buildEdges(prob, graphType.value);
        drawGraph();
        prepareKruskal();
        updateUI();
      }

      initDemo();

      // allow clicking an edge in the svg to flash it
      svg.addEventListener('click', (ev) => {
        if (!ev.target) return;
        if (ev.target.tagName === 'line') {
          const id = parseInt(ev.target.getAttribute('data-edge-id'));
          const e = edges.find(x => x.id === id);
          if (e) flashEdge(e);
        }
      });

      // small keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ') { e.preventDefault(); stopPlaying(); step(); }
        if (e.key === 'p') { playBtn.click(); }
        if (e.key === 's') { stepBtn.click(); }
        if (e.key === 'r') { resetBtn.click(); }
      });

    })();
  </script>
</body>
</html>