<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Floyd–Warshall Algorithm Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#0f1720;--card:#0b1220;--accent:#4f46e5;--muted:#94a3b8;--good:#16a34a;--bad:#ef4444;}
  body{font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; margin:0; background:linear-gradient(180deg,#071126 0%, #071827 60%); color:#e6eef7;}
  .wrap{max-width:1200px;margin:20px auto;padding:18px;}
  header{display:flex;align-items:center;gap:16px;margin-bottom:14px}
  header h1{font-size:20px;margin:0}
  .panel{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type=number], input[type=text], select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 8px;border-radius:6px}
  button{background:var(--accent);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .small{font-size:13px;padding:6px 8px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:12px}
  .matrix-area{display:flex;gap:12px;align-items:flex-start}
  .matrix{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;overflow:auto;max-height:420px}
  table{border-collapse:collapse;font-family:monospace;font-size:13px}
  td, th{border:1px solid rgba(255,255,255,0.03);padding:6px 8px;text-align:center;min-width:48px}
  th{background:rgba(255,255,255,0.02);color:var(--muted);font-weight:600}
  .inf{color:var(--muted)}
  .updated{background:linear-gradient(90deg, rgba(79,70,229,0.18), rgba(16,185,129,0.06)); box-shadow:0 0 12px rgba(79,70,229,0.06) inset}
  .current{background:rgba(79,70,229,0.14)}
  .kcol{background:rgba(79,70,229,0.06)}
  .log{font-family:ui-monospace,Monaco,monospace;background:#021226;padding:8px;border-radius:8px;color:#cfefff;max-height:220px;overflow:auto;font-size:13px}
  .row{display:flex;gap:12px;align-items:center;margin-top:10px}
  label{font-size:13px;color:var(--muted)}
  .playbar{display:flex;gap:8px;align-items:center}
  input[type=range]{accent-color:var(--accent)}
  .path-result{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted)}
  .bad{color:var(--bad);font-weight:700}
  .good{color:var(--good);font-weight:700}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .example-btn{background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:6px;border-radius:6px;color:var(--muted);cursor:pointer}
  @media (max-width:900px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Floyd–Warshall Algorithm — Interactive Demo</h1>
      <div style="color:var(--muted);font-size:13px">All-pairs shortest paths with step-by-step visualization, path reconstruction and negative-cycle detection.</div>
    </div>
  </header>

  <div class="panel">
    <div class="controls">
      <label>Vertices:
        <input id="nInput" type="number" min="1" max="12" value="5" style="width:72px;margin-left:8px"/>
      </label>

      <label style="display:flex;align-items:center">Directed:
        <input id="directed" type="checkbox" checked style="margin-left:8px"/>
      </label>

      <label>Random graph:
        <select id="density" style="margin-left:8px">
          <option value="0.3">sparse ~30%</option>
          <option value="0.5" selected>moderate ~50%</option>
          <option value="0.8">dense ~80%</option>
        </select>
      </label>

      <label>Weight range:
        <input id="wmin" type="number" value="-5" style="width:64px;margin-left:8px"/>
        to
        <input id="wmax" type="number" value="12" style="width:64px;margin-left:8px"/>
      </label>

      <button id="randBtn" class="small">Generate Random</button>
      <button id="presetBtn" class="small ghost">Load Example</button>
      <button id="applyBtn" class="small">Apply Matrix</button>
    </div>

    <div class="grid">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Adjacency matrix (use INF or leave blank for no edge)</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="addNode" class="example-btn" title="Increase vertices">+V</button>
            <button id="remNode" class="example-btn" title="Decrease vertices">-V</button>
          </div>
        </div>
        <div class="matrix" id="adjMatrixArea" style="margin-top:8px"></div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Controls & Playback</strong>
          <div style="color:var(--muted);font-size:13px">Step mode visualizes each i,j for current k</div>
        </div>

        <div class="row" style="margin-top:8px">
          <button id="initBtn">Initialize</button>
          <button id="stepBack" class="ghost small" disabled>Step ◀</button>
          <button id="stepFwd" class="ghost small" disabled>Step ▶</button>
          <button id="playBtn" class="ghost small" disabled>Play</button>
          <button id="runFull" class="small">Run to End</button>
          <button id="resetBtn" class="ghost small">Reset</button>
        </div>

        <div class="row">
          <label>Speed:
            <input id="speed" type="range" min="100" max="2000" value="600" style="width:220px;margin-left:8px"/>
          </label>
          <div style="color:var(--muted);font-size:13px"> <span id="kLabel">k = -</span> • Current (i,j): <span id="ijLabel">-</span></div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <label>Source:
            <select id="srcSel"></select>
          </label>
          <label>Target:
            <select id="tgtSel"></select>
          </label>
          <button id="showPath" class="small" title="Reconstruct shortest path">Show Path</button>
        </div>

        <div style="margin-top:10px">
          <div class="path-result" id="pathRes">Path: —</div>
        </div>
      </div>

      <div class="panel" style="grid-column:1/3">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <strong>Distance and "Next" matrices</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="exportBtn" class="ghost small" title="Export current matrices as JSON">Export JSON</button>
            <button id="loadBtn" class="ghost small" title="Load JSON (paste)">Load JSON</button>
          </div>
        </div>

        <div style="display:flex;gap:12px;margin-top:8px">
          <div class="matrix" style="flex:1">
            <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Distance matrix</div>
            <div id="distArea"></div>
          </div>
          <div class="matrix" style="flex:0.7">
            <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Next matrix (for path reconstruction)</div>
            <div id="nextArea"></div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Execution log</div>
          <div class="log" id="logArea" aria-live="polite"></div>
        </div>
      </div>
    </div>

    <footer style="margin-top:12px">Notes: • Initialize reads the adjacency table and prepares Floyd–Warshall. • Step shows each pair (i,j) considered for a given intermediate k. • Negative cycles: if any dist[i][i] &lt; 0 after the algorithm, a reachable negative cycle exists.</footer>
  </div>
</div>

<script>
/*
  Floyd–Warshall Interactive Demo
  - Distance matrix & "next" (successor) matrix representation.
  - Step-by-step visualization captures each inner (i,j) check for each k.
  - Allows path reconstruction using the "next" matrix after run completes (unless negative cycle).
*/

const MAX_N = 12;

let N = 5;
let directed = true;
let adjInputs = []; // references to input elements
let dist = []; // current distance matrix
let nextm = []; // successor matrix for path reconstruction
let history = []; // states for stepping (snapshots)
let stepIndex = -1;
let playing = false;
let playTimer = null;
let currentMeta = {}; // meta info for highlighted cells

// DOM refs
const adjMatrixArea = document.getElementById('adjMatrixArea');
const distArea = document.getElementById('distArea');
const nextArea = document.getElementById('nextArea');
const logArea = document.getElementById('logArea');
const nInput = document.getElementById('nInput');
const directedChk = document.getElementById('directed');
const densitySel = document.getElementById('density');
const wminInput = document.getElementById('wmin');
const wmaxInput = document.getElementById('wmax');
const randBtn = document.getElementById('randBtn');
const presetBtn = document.getElementById('presetBtn');
const applyBtn = document.getElementById('applyBtn');
const initBtn = document.getElementById('initBtn');
const stepFwdBtn = document.getElementById('stepFwd');
const stepBackBtn = document.getElementById('stepBack');
const playBtn = document.getElementById('playBtn');
const runFullBtn = document.getElementById('runFull');
const resetBtn = document.getElementById('resetBtn');
const kLabel = document.getElementById('kLabel');
const ijLabel = document.getElementById('ijLabel');
const speedSlider = document.getElementById('speed');
const srcSel = document.getElementById('srcSel');
const tgtSel = document.getElementById('tgtSel');
const showPathBtn = document.getElementById('showPath');
const pathRes = document.getElementById('pathRes');
const addNodeBtn = document.getElementById('addNode');
const remNodeBtn = document.getElementById('remNode');
const exportBtn = document.getElementById('exportBtn');
const loadBtn = document.getElementById('loadBtn');

// Initialize UI
function createAdjMatrix(n){
  N = n;
  adjInputs = [];
  adjMatrixArea.innerHTML = '';
  const table = document.createElement('table');
  const header = document.createElement('tr');
  header.appendChild(document.createElement('th'));
  for(let j=0;j<N;j++){
    const th = document.createElement('th'); th.textContent = 'v'+j; header.appendChild(th);
  }
  table.appendChild(header);
  for(let i=0;i<N;i++){
    const tr = document.createElement('tr');
    const th = document.createElement('th'); th.textContent = 'v'+i; tr.appendChild(th);
    const rowInputs = [];
    for(let j=0;j<N;j++){
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.type = 'text'; inp.value = (i===j ? '0' : '');
      inp.style.width = '64px';
      inp.dataset.i = i; inp.dataset.j = j;
      td.appendChild(inp); tr.appendChild(td);
      rowInputs.push(inp);
    }
    adjInputs.push(rowInputs);
    table.appendChild(tr);
  }
  adjMatrixArea.appendChild(table);
  updateSelectors();
}

function updateSelectors(){
  srcSel.innerHTML = ''; tgtSel.innerHTML = '';
  for(let i=0;i<N;i++){
    const o1=document.createElement('option');o1.value=i;o1.textContent='v'+i;srcSel.appendChild(o1);
    const o2=document.createElement('option');o2.value=i;o2.textContent='v'+i;tgtSel.appendChild(o2);
  }
}

// parse adjacency inputs to produce distance and next matrices
function readAdjacency(){
  directed = directedChk.checked;
  dist = new Array(N);
  nextm = new Array(N);
  for(let i=0;i<N;i++){
    dist[i] = new Array(N).fill(Infinity);
    nextm[i] = new Array(N).fill(null);
  }
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      const raw = adjInputs[i][j].value.trim();
      if(raw === '' || /^inf(inity)?$/i.test(raw)) continue;
      const num = Number(raw);
      if(!isFinite(num)) continue;
      dist[i][j] = num;
      if(i===j && num===0){
        nextm[i][j] = i;
      } else {
        nextm[i][j] = j;
      }
      if(!directed){
        // mirror if undirected
        dist[j][i] = num;
        nextm[j][i] = i;
      }
    }
  }
  // ensure zero on diagonal
  for(let i=0;i<N;i++){
    if(dist[i][i] === Infinity) { dist[i][i]=0; nextm[i][i]=i; }
  }
}

// render matrix helper
function renderMatrix(mat, container, highlight){
  // mat is either number matrix or next matrix
  const table = document.createElement('table');
  const trh = document.createElement('tr'); trh.appendChild(document.createElement('th'));
  for(let j=0;j<N;j++){ const th=document.createElement('th'); th.textContent='v'+j; trh.appendChild(th); }
  table.appendChild(trh);
  for(let i=0;i<N;i++){
    const tr = document.createElement('tr');
    const th = document.createElement('th'); th.textContent='v'+i; tr.appendChild(th);
    for(let j=0;j<N;j++){
      const td = document.createElement('td');
      if(typeof(mat[i][j]) === 'number'){
        const v = mat[i][j];
        td.textContent = (v === Infinity ? '∞' : (Math.abs(v) === Infinity ? '∞' : v));
        if(v === Infinity) td.classList.add('inf');
      } else {
        td.textContent = (mat[i][j] === null ? '-' : 'v'+mat[i][j]);
        if(mat[i][j] === null) td.classList.add('inf');
      }
      if(highlight){
        if(highlight.k === i || highlight.k === j){
          td.classList.add('kcol');
        }
        if(highlight.current && highlight.current.i===i && highlight.current.j===j){
          td.classList.add('current');
        }
        if(highlight.updated && highlight.updated.i===i && highlight.updated.j===j){
          td.classList.add('updated');
        }
      }
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
  container.innerHTML = '';
  container.appendChild(table);
}

// initialize algorithm: capture history for step navigation
function initializeFW(){
  readAdjacency();
  // reset history
  history = [];
  stepIndex = -1;
  currentMeta = {k:-1, i:-1, j:-1};
  // push initial state (k = -1) - before any k processed
  pushState(dist, nextm, {k:-1, current:null, updated:null, note:'Initial matrices'});
  log('Initialized matrices. Ready to step.');
  renderAll();
  enableControls(true);
}

function deepCopyMat(m){
  return m.map(row => row.slice());
}

function pushState(dMat, nMat, meta){
  history.push({
    dist: deepCopyMat(dMat),
    next: deepCopyMat(nMat),
    meta: Object.assign({}, meta)
  });
  stepIndex = history.length - 1;
  renderFromHistoryIndex(stepIndex);
}

function renderAll(){
  const h = history[stepIndex];
  renderMatrix(h.dist, distArea, h.meta);
  renderMatrix(h.next, nextArea, h.meta);
  kLabel.textContent = 'k = ' + (h.meta.k>=0 ? 'v'+h.meta.k : '-');
  ijLabel.textContent = (h.meta.current ? `(${h.meta.current.i},${h.meta.current.j})` : '-');
  // log area kept as appended messages; matrices reflect state
}

// perform full Floyd–Warshall but record each inner step in history
function runAndRecord(){
  // working copies
  let D = deepCopyMat(history[stepIndex].dist);
  let NX = deepCopyMat(history[stepIndex].next);

  // triple loop: for k=0..N-1; for i=0..N-1; for j=0..N-1
  for(let k=0;k<N;k++){
    // snapshot before processing this k (optional)
    pushState(D, NX, {k:k, current:null, updated:null, note:`Start k=${k}`});
    for(let i=0;i<N;i++){
      for(let j=0;j<N;j++){
        // record the current comparison
        const meta = {k:k, current:{i:i,j:j}, updated:null, note:`Checking if v${i}->v${j} > v${i}->v${k} + v${k}->v${j}`};
        pushState(D, NX, meta);
        const dik = D[i][k];
        const dkj = D[k][j];
        const dij = D[i][j];
        if(dik === Infinity || dkj === Infinity) continue;
        const nd = dik + dkj;
        if(nd < dij){
          D[i][j] = nd;
          NX[i][j] = NX[i][k]; // successor update
          // snapshot after update
          const updMeta = {k:k, current:{i:i,j:j}, updated:{i:i,j:j}, note:`Updated v${i}->v${j} via v${k}: ${dij} → ${nd}`};
          pushState(D, NX, updMeta);
        }
      }
    }
    // after finishing k, push snapshot
    pushState(D, NX, {k:k, current:null, updated:null, note:`Finished k=${k}`});
  }
  // final snapshot
  pushState(D, NX, {k:-2, current:null, updated:null, note:'Completed'});
  log('Algorithm completed. Use "Show Path" to reconstruct a path (unless negative cycle).');
}

// step navigation
function renderFromHistoryIndex(idx){
  if(idx < 0) { return; }
  const h = history[idx];
  // render
  renderMatrix(h.dist, distArea, h.meta);
  renderMatrix(h.next, nextArea, h.meta);
  kLabel.textContent = 'k = ' + (h.meta.k>=0 ? 'v'+h.meta.k : (h.meta.k===-1 ? '-' : 'final'));
  ijLabel.textContent = (h.meta.current ? `(${h.meta.current.i},${h.meta.current.j})` : '-');
  // highlight in log
  if(h.meta.note) {
    // brief log addition but keep appending for trace
    log(`[state ${idx}] ${h.meta.note}`);
  }
  // update enabled buttons
  stepBackBtn.disabled = (idx <= 0);
  stepFwdBtn.disabled = (idx >= history.length-1);
  playBtn.disabled = false;
}

// basic logging
function log(msg){
  const ts = new Date().toLocaleTimeString();
  const line = document.createElement('div');
  line.textContent = `[${ts}] ${msg}`;
  logArea.appendChild(line);
  logArea.scrollTop = logArea.scrollHeight;
}

// UI event handlers
randBtn.addEventListener('click', ()=>{
  const n = Number(nInput.value) || 5;
  const density = Number(densitySel.value);
  const wmin = Number(wminInput.value) || -5;
  const wmax = Number(wmaxInput.value) || 12;
  createAdjMatrix(n);
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
      if(i===j){ adjInputs[i][j].value = '0'; continue; }
      if(Math.random() < density){
        const w = Math.floor(Math.random()*(wmax-wmin+1))+wmin;
        adjInputs[i][j].value = w;
        if(!directedChk.checked) adjInputs[j][i].value = w;
      } else {
        adjInputs[i][j].value = '';
      }
    }
  }
});
presetBtn.addEventListener('click', ()=>{
  // small example including a negative edge but no negative cycle
  createAdjMatrix(4);
  const preset = [
    ['0','3','INF','7'],
    ['8','0','2','INF'],
    ['5','INF','0','1'],
    ['2','INF','INF','0']
  ];
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) adjInputs[i][j].value = preset[i][j];
});
addNodeBtn.addEventListener('click', ()=>{
  let n = Number(nInput.value)||5;
  if(n < MAX_N) n++;
  nInput.value = n;
  createAdjMatrix(n);
});
remNodeBtn.addEventListener('click', ()=>{
  let n = Number(nInput.value)||5;
  if(n > 1) n--;
  nInput.value = n;
  createAdjMatrix(n);
});
applyBtn.addEventListener('click', ()=>{
  createAdjMatrix(Number(nInput.value) || 5);
});
initBtn.addEventListener('click', ()=>{
  try {
    initializeFW();
  } catch(e){
    alert('Error initializing: '+e);
  }
});
stepFwdBtn.addEventListener('click', ()=>{
  if(stepIndex < history.length-1){
    stepIndex++;
    renderFromHistoryIndex(stepIndex);
  }
});
stepBackBtn.addEventListener('click', ()=>{
  if(stepIndex > 0){
    stepIndex--;
    renderFromHistoryIndex(stepIndex);
  }
});
playBtn.addEventListener('click', ()=>{
  if(playing){ stopPlay(); return; }
  playing = true;
  playBtn.textContent = 'Pause';
  stepFwdBtn.disabled = true; stepBackBtn.disabled = true; runFullBtn.disabled = true;
  playStep();
});
function playStep(){
  if(!playing){ return; }
  if(stepIndex >= history.length-1){ stopPlay(); return; }
  const delay = Number(speedSlider.value);
  playTimer = setTimeout(()=>{
    stepIndex++;
    renderFromHistoryIndex(stepIndex);
    if(stepIndex >= history.length-1) { stopPlay(); }
    else playStep();
  }, delay);
}
function stopPlay(){
  playing = false;
  if(playTimer) clearTimeout(playTimer);
  playBtn.textContent = 'Play';
  stepFwdBtn.disabled = false; stepBackBtn.disabled = false; runFullBtn.disabled = false;
}

runFullBtn.addEventListener('click', ()=>{
  if(history.length === 0){ log('Initialize first.'); return; }
  // if only initial snapshot present, run and record all steps
  if(stepIndex === history.length-1){
    // already ran?
  }
  // run algorithm from initial state
  // Reset history to start from initial state (index 0) to avoid duplicate initial snapshots
  const initState = history[0];
  history = [initState];
  stepIndex = 0;
  runAndRecord();
  // go to last state
  stepIndex = history.length - 1;
  renderFromHistoryIndex(stepIndex);
});

resetBtn.addEventListener('click', ()=>{
  createAdjMatrix(Number(nInput.value) || 5);
  logArea.innerHTML = '';
  distArea.innerHTML = '';
  nextArea.innerHTML = '';
  history = []; stepIndex = -1;
  kLabel.textContent = 'k = -';
  ijLabel.textContent = '-';
  pathRes.textContent = 'Path: —';
  enableControls(false);
});

showPathBtn.addEventListener('click', ()=>{
  if(history.length===0){ log('Initialize and run algorithm first.'); return; }
  // Use final matrices (last state)
  const final = history[history.length-1];
  const D = final.dist;
  const NX = final.next;
  // detect negative cycle reachable between src and tgt?
  for(let v=0;v<N;v++){
    if(D[v][v] < 0){
      pathRes.innerHTML = `<span class="bad">Negative cycle detected (dist[v][v] < 0). Shortest paths undefined for some pairs.</span>`;
      log('Negative cycle detected; path reconstruction may be invalid.');
      return;
    }
  }
  const s = Number(srcSel.value);
  const t = Number(tgtSel.value);
  if(D[s][t] === Infinity){
    pathRes.textContent = `Path: no path from v${s} to v${t} (∞)`;
    return;
  }
  const path = reconstructPath(s,t,NX);
  if(!path){
    pathRes.textContent = `Path: none`;
  } else {
    pathRes.innerHTML = `Path: ${path.map(v=>'v'+v).join(' → ')} • length = ${D[s][t]}`;
  }
});

function reconstructPath(u,v,NX){
  if(NX[u][v] === null) return null;
  const path = [u];
  let cur = u;
  while(cur !== v){
    cur = NX[cur][v];
    if(cur === null || path.length > N+5) return null;
    path.push(cur);
  }
  return path;
}

exportBtn.addEventListener('click', ()=>{
  if(history.length===0){ alert('No matrices available. Initialize first.'); return; }
  const final = history[history.length-1];
  const payload = {N:N, directed: directedChk.checked, dist:final.dist, next:final.next};
  const txt = JSON.stringify(payload, null, 2);
  prompt('Copy JSON below (Ctrl/Cmd+C):', txt);
});
loadBtn.addEventListener('click', ()=>{
  const txt = prompt('Paste JSON exported by this demo:');
  if(!txt) return;
  try{
    const obj = JSON.parse(txt);
    if(!obj || typeof obj.N !== 'number') throw new Error('Invalid JSON');
    createAdjMatrix(obj.N);
    // attempt to fill adjacency from dist (best-effort)
    for(let i=0;i<obj.N;i++){
      for(let j=0;j<obj.N;j++){
        const val = obj.dist?.[i]?.[j];
        if(val === undefined || val === null || !isFinite(val)) adjInputs[i][j].value = '';
        else adjInputs[i][j].value = String(val);
      }
    }
    log('Loaded JSON into adjacency matrix (best-effort). Press Initialize to start.');
  }catch(e){
    alert('Could not load JSON: '+e);
  }
});

// enable/disable controls based on state
function enableControls(enabled){
  initBtn.disabled = !enabled;
  stepFwdBtn.disabled = true;
  stepBackBtn.disabled = true;
  playBtn.disabled = true;
  runFullBtn.disabled = !enabled;
  resetBtn.disabled = false;
}

// initial page setup
createAdjMatrix(N);
updateSelectors();
enableControls(true);

// When initializing, after we create initial history entry, enable stepping buttons
// Modify initializeFW to enable step buttons after creation. We'll attach enabling there:
initBtn.addEventListener('click', ()=>{
  if(history.length>0 && stepIndex>=0){
    // Already initialized; do nothing (handled above)
  } else {
    initializeFW();
  }
});

// After initializeFW, ensure we have one snapshot and enable step buttons
const origInit = initializeFW;
initializeFW = function(){
  // call original logic from closure by referencing origInit? we already captured above; to avoid complexity, reimplement
  readAdjacency();
  history = [];
  stepIndex = -1;
  currentMeta = {k:-1,i:-1,j:-1};
  // push initial
  pushState(dist, nextm, {k:-1, current:null, updated:null, note:'Initial matrices'});
  log('Initialized matrices. Ready to step.');
  renderAll();
  // enable controls
  stepFwdBtn.disabled = false;
  stepBackBtn.disabled = true;
  playBtn.disabled = false;
  runFullBtn.disabled = false;
  resetBtn.disabled = false;
};

// Reassign event to use this new initializeFW (rebind)
initBtn.onclick = initializeFW;

// Important: When "Run to End" executed, some controls are changed. We'll ensure step navigation works after run.
// After runAndRecord, stepIndex is set to last; enable step back/forward accordingly:
runFullBtn.addEventListener('click', ()=>{
  if(history.length===0){ log('Initialize first.'); return; }
  // Reset history to initial state
  const initstate = history[0];
  history = [initstate];
  stepIndex = 0;
  runAndRecord();
  // Go to last valid state
  stepIndex = history.length - 1;
  renderFromHistoryIndex(stepIndex);
  stepFwdBtn.disabled = true;
  stepBackBtn.disabled = false;
});

// To enable step as we play, ensure play button toggling handled earlier.

// Small improvement: allow editing adjacency values to accept "INF" or empty -> treated as Infinity
// Already handled in readAdjacency.

// Ensure initial log and UI readiness
log('Ready. Set up a graph, click "Initialize", then Step/Play/Run.');

// Provide some helpful hints in console for advanced users
console.info('Floyd–Warshall demo loaded.');

/* End of script */
</script>
</body>
</html>