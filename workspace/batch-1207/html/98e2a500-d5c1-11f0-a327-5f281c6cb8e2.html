<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Longest Common Subsequence (LCS) Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --muted:#94a3b8;
    --accent:#60a5fa;
    --success:#34d399;
    --danger:#fb7185;
    --cell:#071029;
    --cell-border:#12263a;
    --highlight:#2563eb;
    --path:#f59e0b;
    --font: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box;font-family:var(--font)}
  body{
    margin:0;
    min-height:100vh;
    background:linear-gradient(180deg,#071029,#07162a 60%);
    color:#e6eef8;
    padding:24px;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    gap:16px;
  }
  .container{
    width:100%;
    max-width:1200px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    padding:18px;
    border-radius:12px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  h1{margin:0 0 6px 0;font-size:20px}
  p.lead{margin:0 0 16px 0;color:var(--muted);font-size:13px}
  .top{
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  .panel{
    background:var(--card);
    padding:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.03);
    flex:1;
  }
  label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted)}
  textarea{
    width:100%;
    min-height:64px;
    resize:vertical;
    padding:8px;
    background:var(--cell);
    border:1px solid var(--cell-border);
    color:#e6eef8;
    border-radius:8px;
    font-family:monospace;
    font-size:14px;
  }
  .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  button{
    background:linear-gradient(180deg,var(--highlight), #1e40af);
    color:white;
    padding:8px 12px;
    border-radius:8px;
    border:0;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
  }
  button.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--muted);
  }
  .info{
    margin-top:12px;
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  .badge{
    background:rgba(255,255,255,0.03);
    padding:8px 10px;
    border-radius:8px;
    font-size:13px;
    color:var(--muted);
  }
  .grid-wrap{
    overflow:auto;
    margin-top:12px;
    border-radius:8px;
    padding:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.02);
  }
  table.grid{
    border-collapse:collapse;
    font-family:monospace;
    background:transparent;
  }
  table.grid td, table.grid th{
    width:40px;
    height:40px;
    text-align:center;
    border:1px solid var(--cell-border);
    padding:0;
    margin:0;
    color:#cfe9ff;
    background:var(--cell);
    font-size:13px;
  }
  table.grid th{
    background:transparent;
    color:var(--muted);
    font-weight:700;
  }
  td.char{
    background:transparent;
    color:var(--muted);
    font-weight:700;
    font-size:14px;
  }
  td.cell-value{
    position:relative;
  }
  td.cell-value .small{
    position:absolute;
    bottom:2px;
    right:3px;
    font-size:10px;
    color:rgba(255,255,255,0.35);
  }
  td.compare{
    box-shadow:inset 0 0 0 2px rgba(96,165,250,0.12);
    background:linear-gradient(180deg, rgba(96,165,250,0.03), rgba(96,165,250,0.01));
  }
  td.diag-match{
    background:linear-gradient(180deg, rgba(52,211,153,0.06), rgba(52,211,153,0.01));
    box-shadow:inset 0 0 0 2px rgba(52,211,153,0.06);
  }
  td.path{
    background:linear-gradient(180deg, rgba(245,158,11,0.08), rgba(245,158,11,0.02));
    box-shadow:inset 0 0 0 2px rgba(245,158,11,0.06);
    color:#ffd8a8;
  }
  .results{
    margin-top:12px;
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  .result-block{
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    padding:10px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.02);
  }
  code.k{background:rgba(255,255,255,0.02);padding:4px 6px;border-radius:6px;font-weight:700;}
  .smallmuted{color:var(--muted);font-size:13px;margin-top:6px}
  .footer{
    margin-top:12px;
    color:var(--muted);
    font-size:13px;
  }
  .row{display:flex;gap:8px;align-items:center}
  input[type=number]{width:70px;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:var(--cell);color:#e6eef8}
  .hint{font-size:12px;color:var(--muted)}
  .warning{color:var(--danger);font-weight:700}
  .success{color:var(--success);font-weight:700}
  .smallbtn{padding:4px 8px;font-size:12px;border-radius:6px}
  .footer a{color:var(--accent);text-decoration:none}
  @media(max-width:900px){
    .top{flex-direction:column}
  }
</style>
</head>
<body>
<div class="container" role="main">
  <h1>Longest Common Subsequence (LCS) Visualizer</h1>
  <p class="lead">Type two strings below to compute the LCS. Visualize the dynamic programming table, animate the DP fill and the backtracking path, and optionally list all distinct LCS sequences (bounded).</p>

  <div class="top">
    <div class="panel" style="flex:0.55">
      <label for="aStr">String A</label>
      <textarea id="aStr" placeholder="Enter first string (e.g., ABCBDAB)">ABCBDAB</textarea>
      <label for="bStr" style="margin-top:8px">String B</label>
      <textarea id="bStr" placeholder="Enter second string (e.g., BDCABA)">BDCABA</textarea>

      <div class="controls">
        <button id="computeBtn">Compute LCS</button>
        <button class="secondary" id="animateBtn">Animate DP Fill</button>
        <button class="secondary" id="traceBtn">Animate Backtrace</button>
        <button class="secondary" id="allBtn">Show All LCS</button>
        <button class="secondary" id="clearBtn">Clear Highlights</button>
        <button class="secondary" id="randomBtn">Random Strings</button>
        <button class="secondary" id="copyBtn">Copy One LCS</button>
      </div>

      <div class="info">
        <div class="badge">Length: <span id="lcsLen">-</span></div>
        <div class="badge">One LCS: <span id="oneLcs" class="k">-</span></div>
        <div class="badge">All sequences (limit): <span id="allCount">-</span></div>
      </div>

      <div class="smallmuted">
        Controls: "Animate DP Fill" draws the dp table row-by-row. "Animate Backtrace" highlights a single backtrace path that yields one LCS. "Show All LCS" attempts to enumerate distinct LCS up to a limit (may be exponential).
      </div>
    </div>

    <div class="panel" style="flex:0.45">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <label>Settings</label>
          <div class="hint">Max length for animation: <span id="maxLenText">40</span> chars</div>
        </div>
        <div style="text-align:right">
          <div class="row">
            <label style="margin-right:6px">All-limit</label>
            <input id="allLimit" type="number" min="1" step="1" value="200" />
          </div>
          <div class="row" style="margin-top:8px">
            <label style="margin-right:6px">Delay (ms)</label>
            <input id="delay" type="number" min="10" step="10" value="40" />
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="hint">DP Table (rows = chars of A; cols = chars of B). Extra top row/left column are zeros for base cases.</div>
        <div class="grid-wrap" id="gridWrap" style="max-height:420px">
          <!-- Table inserted here -->
          <div style="color:var(--muted);padding:18px">Press "Compute LCS" to build the DP table.</div>
        </div>
      </div>

    </div>
  </div>

  <div class="results">
    <div class="result-block">
      <strong>Explanation</strong>
      <div class="smallmuted" style="margin-top:8px">
        The standard dynamic programming formulation builds a (m+1)x(n+1) table dp, where dp[i][j] is the length of the LCS of A[0..i-1] and B[0..j-1]. Recurrence:
        <div style="margin-top:6px">
          - If A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 (match)<br/>
          - Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (skip one char)
        </div>
        Backtracking from dp[m][n] following matches and equal choices recovers one or all LCS.
      </div>
    </div>

    <div class="result-block" id="allBlock">
      <strong>All LCS (distinct)</strong>
      <div class="smallmuted" style="margin-top:8px" id="allList">No data yet. Click "Show All LCS" after computing.</div>
    </div>
  </div>

  <div class="footer">
    Tip: Keep strings under about 40 characters for animation. Listing all LCS can explode combinatorially — we stop collecting deeper results once the configured limit is reached. Source: classic DP algorithm.
  </div>
</div>

<script>
/*
  LCS Visualizer
  - Builds DP table
  - Animates table filling
  - Animates backtrace for one LCS
  - Enumerates all distinct LCS up to a user-provided limit
*/

(function(){
  // Elements
  const aEl = document.getElementById('aStr');
  const bEl = document.getElementById('bStr');
  const computeBtn = document.getElementById('computeBtn');
  const animateBtn = document.getElementById('animateBtn');
  const traceBtn = document.getElementById('traceBtn');
  const allBtn = document.getElementById('allBtn');
  const clearBtn = document.getElementById('clearBtn');
  const gridWrap = document.getElementById('gridWrap');
  const lcsLenEl = document.getElementById('lcsLen');
  const oneLcsEl = document.getElementById('oneLcs');
  const allListEl = document.getElementById('allList');
  const allCountEl = document.getElementById('allCount');
  const delayEl = document.getElementById('delay');
  const allLimitEl = document.getElementById('allLimit');
  const randomBtn = document.getElementById('randomBtn');
  const copyBtn = document.getElementById('copyBtn');
  const maxLenText = document.getElementById('maxLenText');
  const clearHighlightsBtn = clearBtn;

  const DEFAULT_MAX_LEN = 40;
  maxLenText.textContent = DEFAULT_MAX_LEN;

  let dp = []; // dp matrix
  let tableEl = null; // DOM table
  let A = '', B = '';
  let animating = false;
  let animationTimeouts = [];

  // Utility to stop animation timeouts
  function clearAnimationTimeouts(){
    for(const t of animationTimeouts) clearTimeout(t);
    animationTimeouts = [];
    animating = false;
  }

  // Build dp matrix (values only)
  function buildDp(a, b){
    const m = a.length, n = b.length;
    const D = Array.from({length: m+1}, ()=> new Array(n+1).fill(0));
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        if (a[i-1] === b[j-1]) D[i][j] = D[i-1][j-1] + 1;
        else D[i][j] = Math.max(D[i-1][j], D[i][j-1]);
      }
    }
    return D;
  }

  // Render initial table (with zeros) and row/col headers
  function renderTable(a, b, D=null){
    // Create table element
    const m = a.length, n = b.length;
    const tbl = document.createElement('table');
    tbl.className = 'grid';
    const tbody = document.createElement('tbody');

    // top header row: empty cell + B characters
    const topRow = document.createElement('tr');
    topRow.appendChild(document.createElement('th')); // top-left empty
    topRow.appendChild(document.createElement('th')); // second empty for zero row label
    for(let j=0;j<n;j++){
      const th = document.createElement('th');
      th.textContent = b[j];
      topRow.appendChild(th);
    }
    tbody.appendChild(topRow);

    // Zero row (dp[0][*])
    const zeroRow = document.createElement('tr');
    // left-most header for zero row
    const th0 = document.createElement('th');
    th0.className = 'char';
    th0.textContent = '0';
    zeroRow.appendChild(th0);
    // cell for dp[0][0]
    const cell00 = document.createElement('td');
    cell00.className = 'cell-value';
    cell00.dataset.i = 0; cell00.dataset.j = 0;
    cell00.textContent = '0';
    zeroRow.appendChild(cell00);
    // rest zeros with header B chars above already set
    for(let j=1;j<=n;j++){
      const td = document.createElement('td');
      td.className = 'cell-value';
      td.dataset.i = 0; td.dataset.j = j;
      td.textContent = D? String(D[0][j]) : '0';
      zeroRow.appendChild(td);
    }
    tbody.appendChild(zeroRow);

    // remaining rows for i=1..m
    for(let i=1;i<=m;i++){
      const tr = document.createElement('tr');
      // left header: A[i-1]
      const th = document.createElement('th');
      th.className = 'char';
      th.textContent = a[i-1];
      tr.appendChild(th);
      // dp cell for dp[i][0]
      const td0 = document.createElement('td');
      td0.className = 'cell-value';
      td0.dataset.i = i; td0.dataset.j = 0;
      td0.textContent = D? String(D[i][0]) : '0';
      tr.appendChild(td0);

      // dp cells
      for(let j=1;j<=n;j++){
        const td = document.createElement('td');
        td.className = 'cell-value';
        td.dataset.i = i; td.dataset.j = j;
        td.textContent = D? String(D[i][j]) : '0';
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }

    tbl.appendChild(tbody);
    gridWrap.innerHTML = '';
    gridWrap.appendChild(tbl);
    tableEl = tbl;
    return tbl;
  }

  // Update a cell value in the DOM
  function setCellValue(i,j,val){
    if(!tableEl) return;
    const cell = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
    if(cell) cell.textContent = String(val);
  }

  // Mark compare cell (i,j) during animation
  function markCompare(i,j,match=false){
    if(!tableEl) return;
    const td = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
    if(!td) return;
    td.classList.add(match? 'diag-match' : 'compare');
  }
  function unmarkCompare(i,j){
    if(!tableEl) return;
    const td = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
    if(!td) return;
    td.classList.remove('compare','diag-match');
  }
  function markPath(i,j){
    if(!tableEl) return;
    const td = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
    if(!td) return;
    td.classList.add('path');
  }
  function unmarkAll(){
    if(!tableEl) return;
    const tds = tableEl.querySelectorAll('td');
    tds.forEach(td => td.classList.remove('compare','diag-match','path'));
  }

  // Compute dp and update UI values (non-animated)
  function computeAndRender(){
    clearAnimationTimeouts();
    unmarkAll();
    A = aEl.value;
    B = bEl.value;
    const m = A.length, n = B.length;
    dp = buildDp(A,B);
    renderTable(A,B,dp);
    const L = dp[m][n];
    lcsLenEl.textContent = String(L);
    const one = backtraceOne(dp,A,B);
    oneLcsEl.textContent = one || '-';
    allListEl.textContent = 'Not computed.';
    allCountEl.textContent = '-';
  }

  // Backtrace to find one LCS (non-animated). Returns string.
  function backtraceOne(D,a,b){
    let i = a.length, j = b.length;
    const res = [];
    while(i>0 && j>0){
      if (a[i-1] === b[j-1]){
        res.push(a[i-1]);
        i--; j--;
      } else {
        if (D[i-1][j] > D[i][j-1]) i--;
        else j--;
      }
    }
    return res.reverse().join('');
  }

  // Animate DP fill: fill table cell-by-cell with delay
  function animateFill(){
    clearAnimationTimeouts();
    unmarkAll();
    A = aEl.value; B = bEl.value;
    const m = A.length, n = B.length;
    const delay = Math.max(10, Number(delayEl.value) || 40);
    if (m>DEFAULT_MAX_LEN || n>DEFAULT_MAX_LEN){
      alert('Strings too long for animation. Keep both under ' + DEFAULT_MAX_LEN + ' characters.');
      return;
    }
    // render empty table
    renderTable(A,B,null);
    dp = Array.from({length:m+1}, ()=> new Array(n+1).fill(0));
    let step = 0;
    animating = true;
    for(let i=1;i<=m;i++){
      for(let j=1;j<=n;j++){
        const t = setTimeout(((ii,jj)=>{
          return ()=>{
            if (!animating) return;
            // highlight compare
            const match = (A[ii-1] === B[jj-1]);
            markCompare(ii,jj,match);
            // display compare chars small in corner for hint
            // compute dp value
            if (match) dp[ii][jj] = dp[ii-1][jj-1] + 1;
            else dp[ii][jj] = Math.max(dp[ii-1][jj], dp[ii][jj-1]);
            // update displayed value after short delay so highlight visible
            setTimeout(()=>{
              setCellValue(ii,jj, dp[ii][jj]);
              unmarkCompare(ii,jj);
            }, Math.max(0, delay/2));
          };
        })(i,j), delay * (++step));
        animationTimeouts.push(t);
      }
    }
    // After done, display result
    const finalT = setTimeout(()=>{
      animating = false;
      const L = dp[m][n];
      lcsLenEl.textContent = String(L);
      const one = backtraceOne(dp,A,B);
      oneLcsEl.textContent = one || '-';
      allListEl.textContent = 'Not computed.';
      allCountEl.textContent = '-';
    }, delay * (++step));
    animationTimeouts.push(finalT);
  }

  // Animate backtrace path (single LCS)
  function animateBacktrace(){
    if(!dp || dp.length===0){ alert('Compute the DP table first (Compute or Animate DP Fill).'); return; }
    clearAnimationTimeouts();
    unmarkAll();
    animating = true;
    const m = A.length, n = B.length;
    const delay = Math.max(10, Number(delayEl.value) || 40);
    // perform backtrace to get the choices: we'll follow a path that when choices equal picks left-first (or pick up-first?)
    // We'll pick a path that prefers diagonal matches when possible, then up vs left: prefer up if dp[i-1][j] >= dp[i][j-1]
    const path = []; // array of [i,j] in order visited (from end to start)
    let i = m, j = n;
    while (i>0 && j>0){
      path.push([i,j]);
      if (A[i-1] === B[j-1]){
        i--; j--;
      } else {
        if (dp[i-1][j] >= dp[i][j-1]) i--;
        else j--;
      }
    }
    // include remaining cells along top/left border
    while(i>0){ path.push([i,0]); i--; }
    while(j>0){ path.push([0,j]); j--; }
    // animate marking path (reverse to show from start to end)
    path.reverse();
    let step = 0;
    for(const [ii,jj] of path){
      const t = setTimeout(((ri,rj)=>{
        return ()=>{
          markPath(ri,rj);
        };
      })(ii,jj), delay * (++step));
      animationTimeouts.push(t);
    }
    const finalT = setTimeout(()=>{
      animating = false;
    }, delay * (++step));
    animationTimeouts.push(finalT);
  }

  // Enumerate ALL distinct LCS sequences using recursion + memoization.
  // We limit the number of sequences collected to `limit`.
  function allLcs(D, a, b, limit=200){
    const m = a.length, n = b.length;
    const memo = new Map(); // key = i+','+j -> Set of strings
    function key(i,j){ return i+','+j; }

    function helper(i,j){
      const k = key(i,j);
      if (memo.has(k)) return memo.get(k);
      const res = new Set();
      if (i===0 || j===0){
        res.add('');
        memo.set(k,res);
        return res;
      }
      if (a[i-1] === b[j-1]){
        const prev = helper(i-1,j-1);
        for(const s of prev){
          const ns = s + a[i-1]; // append match (we build forward)
          if (res.size < limit) res.add(ns);
          else break;
        }
      } else {
        if (D[i-1][j] >= D[i][j-1]){
          const up = helper(i-1,j);
          for(const s of up){
            if (res.size < limit) res.add(s);
            else break;
          }
        }
        if (D[i][j-1] >= D[i-1][j]){
          const left = helper(i,j-1);
          for(const s of left){
            if (res.size < limit) res.add(s);
            else break;
          }
        }
      }
      // Note: we are building sequences in forward order (prefix), but because we append matches as we go down,
      // we might need to ensure final strings are full LCS; they will be of length D[m][n].
      memo.set(k,res);
      return res;
    }

    const out = helper(m,n);
    // The sequences produced build characters in order of increasing i/j — current helper appended char at end,
    // but since we started from (m,n) downwards, strings are built in forward order; however we might have empty strings padded.
    // Filter only strings of length D[m][n] and reverse each if necessary? Let's confirm:
    // We appended a[i-1] when matched in recursion: helper(i-1,j-1) returns prefixes for first i-1/j-1, then we append a[i-1],
    // so final strings are in correct left-to-right order.
    const expectedLen = D[m][n];
    const filtered = [];
    for(const s of out){
      if (s.length === expectedLen) filtered.push(s);
    }
    // Deduplicate and sort
    const uniq = Array.from(new Set(filtered)).sort();
    return uniq.slice(0, limit);
  }

  // Button handlers
  computeBtn.addEventListener('click', ()=>{
    clearAnimationTimeouts();
    computeAndRender();
  });

  animateBtn.addEventListener('click', ()=>{
    clearAnimationTimeouts();
    animateFill();
  });

  traceBtn.addEventListener('click', ()=>{
    animateBacktrace();
  });

  clearHighlightsBtn.addEventListener('click', ()=>{
    clearAnimationTimeouts();
    unmarkAll();
  });

  allBtn.addEventListener('click', ()=>{
    clearAnimationTimeouts();
    A = aEl.value; B = bEl.value;
    const m = A.length, n = B.length;
    if (m===0 || n===0){ alert('Empty string(s)'); return; }
    // Ensure dp exists and corresponds; if not compute
    if (!dp || dp.length !== (m+1) || dp[0].length !== (n+1)) dp = buildDp(A,B);
    const limit = Math.max(1, Number(allLimitEl.value) || 200);
    // If the number of potential sequences may be huge, warn
    const expectLen = dp[m][n];
    if (expectLen===0){
      allListEl.textContent = 'No common subsequence.';
      allCountEl.textContent = '0';
      return;
    }
    // Attempt to collect
    allListEl.textContent = 'Collecting... (may take a while for large cases)';
    setTimeout(()=>{
      try{
        const list = allLcs(dp, A, B, limit);
        allCountEl.textContent = String(list.length);
        if (list.length===0){
          allListEl.textContent = 'No LCS of expected length found.';
        } else {
          // display them (comma separated), but protect from too many characters by limiting output length
          const maxChars = 5000;
          let out = list.join(', ');
          if (out.length > maxChars) out = out.slice(0,maxChars) + ' ... (truncated)';
          allListEl.innerHTML = '<div style="font-family:monospace;margin-top:6px;white-space:pre-wrap;">' + escapeHtml(out) + '</div>';
        }
      } catch(e){
        allListEl.textContent = 'Error computing all sequences: ' + e.message;
      }
    }, 20);
  });

  copyBtn.addEventListener('click', async ()=>{
    const one = oneLcsEl.textContent || '';
    if (!one || one==='-'){ alert('No LCS to copy'); return; }
    try{
      await navigator.clipboard.writeText(one);
      copyBtn.textContent = 'Copied!';
      setTimeout(()=> copyBtn.textContent = 'Copy One LCS', 1400);
    } catch(e){
      alert('Clipboard copy failed: ' + e.message);
    }
  });

  randomBtn.addEventListener('click', ()=>{
    const alph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lenA = Math.floor(Math.random()*8) + 6;
    const lenB = Math.floor(Math.random()*8) + 6;
    let s1='', s2='';
    for(let i=0;i<lenA;i++) s1 += alph[Math.floor(Math.random()*alph.length)];
    for(let i=0;i<lenB;i++) s2 += alph[Math.floor(Math.random()*alph.length)];
    aEl.value = s1;
    bEl.value = s2;
  });

  // Helper: escape for HTML
  function escapeHtml(s){
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Initialize with given sample
  computeAndRender();

  // Ensure animation stops if user navigates or runs new actions
  window.addEventListener('beforeunload', clearAnimationTimeouts);
})();
</script>
</body>
</html>