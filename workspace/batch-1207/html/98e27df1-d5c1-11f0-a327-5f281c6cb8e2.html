<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Topological Sort — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#0f1724;--panel:#071027;--muted:#9aa6bf;--accent:#60a5fa;--good:#10b981;--bad:#f87171}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{display:flex;gap:12px;padding:12px;background:linear-gradient(180deg,#071428 0%,#02111b 100%);color:#e6eef8;}
    .container{display:flex;flex:1;gap:12px;align-items:stretch}
    .panel{width:360px;background:linear-gradient(180deg,var(--panel),#031627);border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,0.7);overflow:auto}
    h1{font-size:18px;margin:6px 0 12px}
    label{font-size:12px;color:var(--muted);display:block;margin-top:8px}
    button, select, input[type=number], input[type=range] {background:#04324a;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:8px;margin-top:6px}
    button{cursor:pointer}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .small{font-size:12px;padding:6px 8px}
    .toggle{display:inline-flex;align-items:center;gap:8px}
    #svgWrap{flex:1;border-radius:12px;background:linear-gradient(180deg,#062033,#041622);position:relative;overflow:hidden;display:flex;flex-direction:column}
    #canvas{flex:1;width:100%;height:100%}
    .info{font-size:13px;color:var(--muted);margin-top:8px}
    .list{background:#021a28;padding:8px;border-radius:8px;margin-top:8px;max-height:160px;overflow:auto;font-family:monospace;font-size:13px}
    .statusline{display:flex;gap:6px;flex-wrap:wrap;align-items:center;margin-top:8px}
    .chip{background:#062b3f;padding:6px 8px;border-radius:999px;font-size:13px}
    .nodeLabel{pointer-events:none;font-weight:600}
    #controls-top{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:13px}
    .stepper{display:flex;gap:6px}
    .algo-code{background:#021220;padding:8px;border-radius:8px;margin-top:8px;font-family:monospace;font-size:13px;white-space:pre-wrap;color:#cfe8ff}
    .highlight{background:rgba(96,165,250,0.12);border-left:3px solid var(--accent);padding-left:6px}
    .footer{font-size:12px;color:var(--muted);margin-top:12px}
    .danger{color:var(--bad)}
    .good{color:var(--good)}
    svg{width:100%;height:100%}
    /* node styles handled inline */
    .labelSmall{font-size:11px;fill:#bfe0ff}
    .inDegree{font-family:monospace;font-size:12px;fill:#ffd580}
    .edgePath{stroke:#6fb8ff;stroke-width:2;fill:none;opacity:0.75}
    .edgeHover{stroke:#aee3ff;stroke-width:3;opacity:1}
    .markerArrow{fill:#6fb8ff}
    .nodeCircle{stroke:#16384a;stroke-width:2;cursor:pointer}
    .nodeText{font-size:14px;fill:#e6f7ff;text-anchor:middle;dominant-baseline:middle;font-weight:700;pointer-events:none}
    .removed{opacity:0.25}
    .selected{stroke:#ffd166;stroke-width:3}
    .cycleEdge{stroke:#ff7b7b;stroke-width:3}
    .queueBox{background:#012; border-radius:6px; padding:8px; display:flex; gap:6px; align-items:center}
    .queueItem{background:#072f3d;padding:6px 8px;border-radius:6px;font-weight:700}
    .orderItem{background:linear-gradient(90deg,#063a2e,#093a4d);padding:6px 8px;border-radius:6px}
    .smallMuted{font-size:12px;color:var(--muted)}
    .controls-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  </style>
</head>
<body>
  <div class="container">
    <div class="panel">
      <h1>Topological Sort — Interactive Demo</h1>
      <div id="controls-top">
        <button id="btnAddNode" class="small">Add Node</button>
        <button id="btnAddEdge" class="small">Add Edge</button>
        <button id="btnDelete" class="small">Delete Mode</button>
        <button id="btnClear" class="small">Clear Graph</button>
      </div>

      <label>Random DAG</label>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="randN" type="number" value="6" min="1" style="width:72px"/>
        <input id="randP" type="number" value="30" min="0" max="100" style="width:72px"/> <span class="muted">edge % (i->j, i&lt;j)</span>
        <button id="btnRand" class="small">Generate</button>
      </div>

      <label>Kahn's Algorithm (step-by-step)</label>
      <div class="stepper">
        <button id="kahnReset" class="small">Reset</button>
        <button id="kahnStep" class="small">Step</button>
        <button id="kahnPlay" class="small">Play</button>
        <button id="kahnRun" class="small">Run to End</button>
        <label class="smallMuted">Speed</label><input id="playSpeed" type="range" min="100" max="2000" value="800" />
      </div>

      <div class="controls-row">
        <button id="btnKahnFull" class="small">Full Kahn (instant)</button>
        <button id="btnDFS" class="small">DFS Topo</button>
        <button id="btnCompare" class="small">Compare</button>
      </div>

      <div class="statusline">
        <div class="chip">Nodes: <span id="nodeCount">0</span></div>
        <div class="chip">Edges: <span id="edgeCount">0</span></div>
        <div class="chip">Status: <span id="algoStatus">idle</span></div>
      </div>

      <div class="info">
        Click "Add Node" then click canvas to place nodes. Use "Add Edge" then click source then target to make directed edge. Drag nodes to reposition. "Random DAG" creates an acyclic graph. Use Kahn stepper to watch topology emerge.
      </div>

      <label>Current Queue (Kahn)</label>
      <div id="queueView" class="list" style="min-height:40px"></div>

      <label>Topological Order (so far)</label>
      <div id="orderView" class="list" style="min-height:40px"></div>

      <label>Adjacency / In-degrees</label>
      <div id="adjView" class="list"></div>

      <label>Algorithm (Kahn)</label>
      <div id="algoCode" class="algo-code">
kahn(G):
  L = empty list
  S = set of all nodes with no incoming edges
  while S is non-empty:
    remove a node n from S
    add n to L
    for each node m with an edge e from n to m:
      remove edge e from the graph
      if m has no other incoming edges:
        insert m into S
  if graph has edges:
    graph has at least one cycle (no topo ordering)
  else:
    return L
      </div>

      <div class="footer">Demonstration by interactive SVG. Try creating a cycle to see detection.</div>
    </div>

    <div id="svgWrap">
      <svg id="canvas" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" class="markerArrow"/>
          </marker>
        </defs>
        <!-- edges and nodes drawn dynamically -->
      </svg>
    </div>
  </div>

  <script>
    // Interactive Topological Sort demo
    (function(){
      // DOM
      const svg = document.getElementById('canvas');
      const btnAddNode = document.getElementById('btnAddNode');
      const btnAddEdge = document.getElementById('btnAddEdge');
      const btnDelete = document.getElementById('btnDelete');
      const btnClear = document.getElementById('btnClear');
      const btnRand = document.getElementById('btnRand');
      const randN = document.getElementById('randN');
      const randP = document.getElementById('randP');

      const nodeCountEl = document.getElementById('nodeCount');
      const edgeCountEl = document.getElementById('edgeCount');
      const algoStatus = document.getElementById('algoStatus');

      const queueView = document.getElementById('queueView');
      const orderView = document.getElementById('orderView');
      const adjView = document.getElementById('adjView');

      const kahnReset = document.getElementById('kahnReset');
      const kahnStep = document.getElementById('kahnStep');
      const kahnPlay = document.getElementById('kahnPlay');
      const kahnRun = document.getElementById('kahnRun');
      const playSpeed = document.getElementById('playSpeed');

      const btnKahnFull = document.getElementById('btnKahnFull');
      const btnDFS = document.getElementById('btnDFS');
      const btnCompare = document.getElementById('btnCompare');

      // state
      let nodes = []; // {id,label,x,y}
      let edges = []; // {id,from,to}
      let nextNodeId = 1;
      let nextEdgeId = 1;

      let mode = null; // 'addNode', 'addEdge', 'delete'
      let pendingEdgeFrom = null;

      // dragging
      let drag = {node:null,offsetX:0,offsetY:0};

      // Kahn algorithm state
      let kahnState = null; // {inDeg:Map,idToOut:Map,queue:Array,order:Array,removed:Set}
      let playInterval = null;

      // helpers
      function $(id){return document.getElementById(id);}
      function setMode(m){
        mode = m;
        btnAddNode.style.background = (m==='addNode' ? '#074056' : '#04324a');
        btnAddEdge.style.background = (m==='addEdge' ? '#074056' : '#04324a');
        btnDelete.style.background = (m==='delete' ? '#701b1b' : '#04324a');
        pendingEdgeFrom = null;
        render();
      }

      function clearGraph(){
        nodes=[];edges=[];nextNodeId=1;nextEdgeId=1;resetKahn();
        render();
      }

      // create random acyclic graph by only allowing edges i->j for i<j
      function randomDAG(n,percent){
        nodes=[];edges=[];nextNodeId=1;nextEdgeId=1;
        const w = svg.viewBox.baseVal.width || svg.clientWidth;
        const h = svg.viewBox.baseVal.height || svg.clientHeight;
        for(let i=0;i<n;i++){
          nodes.push({id:nextNodeId,label:String.fromCharCode(65+i%26),x:120+(w-240)*(i/(n+1)),y:80+ (h-160)*(0.35 + 0.5*Math.sin(i*1.2)),});
          nextNodeId++;
        }
        for(let i=0;i<n;i++){
          for(let j=i+1;j<n;j++){
            if(Math.random()*100 < percent){
              edges.push({id:nextEdgeId++,from:nodes[i].id,to:nodes[j].id});
            }
          }
        }
        resetKahn();
        render();
      }

      // compute adjacency and in-degree
      function computeAdjAndInDeg(){
        let adj = new Map(); // id -> [to,...]
        let inDeg = new Map();
        for(const node of nodes){
          adj.set(node.id,[]);
          inDeg.set(node.id,0);
        }
        for(const e of edges){
          if(!adj.has(e.from) || !adj.has(e.to)) continue;
          adj.get(e.from).push(e.to);
          inDeg.set(e.to, inDeg.get(e.to)+1);
        }
        return {adj,inDeg};
      }

      function updateInfo(){
        nodeCountEl.textContent = nodes.length;
        edgeCountEl.textContent = edges.length;
        // adjacency view
        const {adj,inDeg} = computeAdjAndInDeg();
        let lines = [];
        for(const n of nodes){
          lines.push(n.label + ' ('+n.id+') | in=' + (inDeg.get(n.id)||0) + ' -> [' + (adj.get(n.id)||[]).map(id=>labelOf(id)).join(',') + ']');
        }
        adjView.textContent = lines.join('\n');
      }

      function labelOf(id){
        const n = nodes.find(x=>x.id===id);
        return n ? n.label : ('#'+id);
      }

      // rendering
      function render(){
        // clear svg
        while(svg.lastChild) svg.removeChild(svg.lastChild);
        // re-add defs
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = '<marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L10,5 L0,10 z" class="markerArrow"/></marker>';
        svg.appendChild(defs);

        // prepare maps
        const nodeById = new Map(nodes.map(n=>[n.id,n]));
        // draw edges behind nodes
        const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        svg.appendChild(edgeGroup);

        // highlight cycle edges if present (kahnState may have cycleEdges)
        const cycleEdges = kahnState && kahnState.cycleEdges ? new Set(kahnState.cycleEdges) : new Set();

        for(const e of edges){
          const from = nodeById.get(e.from);
          const to = nodeById.get(e.to);
          if(!from || !to) continue;
          // compute line from edge of circle to edge of circle
          const r = 24;
          const dx = to.x - from.x, dy = to.y - from.y;
          const dist = Math.hypot(dx,dy) || 1;
          const ux = dx/dist, uy = dy/dist;
          const startX = from.x + ux*r;
          const startY = from.y + uy*r;
          const endX = to.x - ux*r;
          const endY = to.y - uy*r;

          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('d',`M ${startX} ${startY} L ${endX} ${endY}`);
          path.setAttribute('class','edgePath');
          path.setAttribute('marker-end','url(#arrow)');
          if(cycleEdges.has(e.id)){
            path.classList.add('cycleEdge');
            path.setAttribute('stroke','#ffb3b3');
          }
          edgeGroup.appendChild(path);

          // attach event for delete
          (function(e){
            path.addEventListener('dblclick',ev=>{
              // double-click to remove edge
              edges = edges.filter(x=>x.id!==e.id);
              resetKahn();
              render();
            });
          })(e);
        }

        // nodes last (on top)
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        svg.appendChild(nodeGroup);

        // show pending selection highlight
        for(const n of nodes){
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','nodeGroup');
          g.setAttribute('data-id',n.id);

          // circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('cx',n.x);
          circle.setAttribute('cy',n.y);
          circle.setAttribute('r',24);
          circle.setAttribute('fill','#063a4f');
          circle.setAttribute('class','nodeCircle');
          circle.style.stroke = (pendingEdgeFrom===n.id ? '#ffd166' : '#16384a');
          if(kahnState && kahnState.removed && kahnState.removed.has(n.id)) circle.classList.add('removed');
          if(drag.node && drag.node.id===n.id) circle.classList.add('selected');
          circle.addEventListener('mousedown',ev=>onNodeMouseDown(ev,n));
          circle.addEventListener('mouseup',ev=>onNodeMouseUp(ev,n));
          circle.addEventListener('click',ev=>onNodeClick(ev,n));
          g.appendChild(circle);

          // label
          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x',n.x);
          text.setAttribute('y',n.y);
          text.setAttribute('class','nodeText');
          text.textContent = n.label;
          g.appendChild(text);

          // small id under label
          const idText = document.createElementNS('http://www.w3.org/2000/svg','text');
          idText.setAttribute('x', n.x);
          idText.setAttribute('y', n.y + 18);
          idText.setAttribute('class','labelSmall');
          idText.setAttribute('text-anchor','middle');
          idText.setAttribute('fill','#bfe0ff');
          idText.textContent = '#'+n.id;
          g.appendChild(idText);

          // in-degree badge
          const {inDeg} = computeAdjAndInDeg();
          const deg = inDeg.get(n.id) || 0;
          const degText = document.createElementNS('http://www.w3.org/2000/svg','text');
          degText.setAttribute('x', n.x + 30);
          degText.setAttribute('y', n.y - 20);
          degText.setAttribute('class','inDegree');
          degText.textContent = 'in:'+deg;
          g.appendChild(degText);

          // attach to group
          nodeGroup.appendChild(g);
        }

        updateInfo();
        updateKahnViews();
      }

      // mouse handling
      function onCanvasClick(ev){
        const pt = svg.createSVGPoint();
        pt.x = ev.clientX; pt.y = ev.clientY;
        const ctm = svg.getScreenCTM();
        const loc = pt.matrixTransform(ctm.inverse());
        if(mode==='addNode'){
          // place node
          const label = nextNodeId <= 26 ? String.fromCharCode(64 + nextNodeId) : 'N'+nextNodeId;
          nodes.push({id:nextNodeId,label:label,x:loc.x,y:loc.y});
          nextNodeId++;
          resetKahn();
          render();
        } else {
          // nothing
        }
      }

      function onNodeMouseDown(ev,node){
        ev.stopPropagation();
        if(mode==='delete'){
          // remove node and its edges
          nodes = nodes.filter(n=>n.id!==node.id);
          edges = edges.filter(e=>e.from!==node.id && e.to!==node.id);
          resetKahn();
          render();
          return;
        }
        if(mode==='addEdge'){
          if(!pendingEdgeFrom){
            pendingEdgeFrom = node.id;
            render();
            return;
          } else {
            // create edge from pendingEdgeFrom to node.id
            if(pendingEdgeFrom === node.id){
              // self-loop
            } else {
              // if duplicate, skip
              const exists = edges.some(e=>e.from===pendingEdgeFrom && e.to===node.id);
              if(!exists) edges.push({id:nextEdgeId++,from:pendingEdgeFrom,to:node.id});
            }
            pendingEdgeFrom = null;
            resetKahn();
            render();
            return;
          }
        }
        if(mode==='addNode' || mode===null){
          // start drag
          drag.node = node;
          const pt = svg.createSVGPoint();
          pt.x = ev.clientX; pt.y = ev.clientY;
          const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
          drag.offsetX = node.x - loc.x;
          drag.offsetY = node.y - loc.y;
          document.addEventListener('mousemove',onDocMouseMove);
          document.addEventListener('mouseup',onDocMouseUp);
        }
      }
      function onNodeMouseUp(ev,node){
        // placeholder in case needed
      }
      function onNodeClick(ev,node){
        ev.stopPropagation();
        // allow selecting a node when not dragging to add edges
        if(mode==='addEdge' && pendingEdgeFrom && pendingEdgeFrom!==node.id){
          const exists = edges.some(e=>e.from===pendingEdgeFrom && e.to===node.id);
          if(!exists) edges.push({id:nextEdgeId++,from:pendingEdgeFrom,to:node.id});
          pendingEdgeFrom = null;
          resetKahn();
          render();
          return;
        }
      }
      function onDocMouseMove(ev){
        if(!drag.node) return;
        const pt = svg.createSVGPoint();
        pt.x = ev.clientX; pt.y = ev.clientY;
        const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
        drag.node.x = loc.x + drag.offsetX;
        drag.node.y = loc.y + drag.offsetY;
        render();
      }
      function onDocMouseUp(ev){
        if(drag.node){
          drag.node = null;
          document.removeEventListener('mousemove',onDocMouseMove);
          document.removeEventListener('mouseup',onDocMouseUp);
          render();
        }
      }

      // Kahn algorithm functions
      function initKahn(){
        const {adj,inDeg} = computeAdjAndInDeg();
        const inDegCopy = new Map(inDeg);
        const outMap = new Map();
        for(const [k,v] of adj.entries()) outMap.set(k, v.slice());
        const queue = [];
        for(const n of nodes){
          if((inDegCopy.get(n.id)||0)===0) queue.push(n.id);
        }
        kahnState = {inDeg:inDegCopy,idToOut:outMap,queue:queue,order:[],removed:new Set(),cycleEdges:null};
        algoStatus.textContent = 'kahn initialized';
        render();
      }
      function resetKahn(){
        if(playInterval){ clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play'; }
        kahnState = null;
        algoStatus.textContent = 'idle';
        updateKahnViews();
      }

      function kahnStepOnce(){
        if(!kahnState) initKahn();
        const state = kahnState;
        if(state.queue.length===0){
          // finished or cycle
          if(state.order.length === nodes.length){
            algoStatus.textContent = 'done — topological order complete';
          } else {
            // cycle exists: mark remaining edges as cycle edges for visualization
            algoStatus.textContent = 'cycle detected — no topo ordering';
            const remainingEdges = edges.filter(e=> !state.removed.has(e.from) || !state.removed.has(e.to));
            state.cycleEdges = remainingEdges.map(e=>e.id);
          }
          render();
          return;
        }
        // pop a node from queue
        const n = state.queue.shift();
        state.order.push(n);
        state.removed.add(n);
        // remove outgoing edges
        const outs = state.idToOut.get(n) || [];
        for(const to of outs){
          // find edge objects and mark removed (we won't physically delete edges; we track in particular inDeg)
          const current = state.inDeg.get(to) || 0;
          state.inDeg.set(to, current-1);
          if(state.inDeg.get(to)===0){
            state.queue.push(to);
          }
        }
        algoStatus.textContent = `removed ${labelOf(n)}`;
        render();
      }

      function updateKahnViews(){
        // queue view
        while(queueView.firstChild) queueView.removeChild(queueView.lastChild);
        while(orderView.firstChild) orderView.removeChild(orderView.lastChild);
        if(!kahnState){
          queueView.textContent = '(not initialized)';
          orderView.textContent = '(none)';
          return;
        }
        const q = document.createElement('div');
        q.style.display='flex'; q.style.gap='6px'; q.style.flexWrap='wrap';
        for(const id of kahnState.queue){
          const d = document.createElement('div');
          d.className='queueItem';
          d.textContent = labelOf(id);
          q.appendChild(d);
        }
        queueView.appendChild(q);

        const ord = document.createElement('div');
        ord.style.display='flex'; ord.style.gap='6px'; ord.style.flexWrap='wrap';
        for(const id of kahnState.order){
          const d = document.createElement('div');
          d.className='orderItem';
          d.textContent = labelOf(id);
          ord.appendChild(d);
        }
        orderView.appendChild(ord);
      }

      // run to end with delays or instant
      function kahnPlayToggle(){
        if(playInterval){
          clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play';
          return;
        }
        if(!kahnState) initKahn();
        kahnPlay.textContent='Pause';
        const speed = parseInt(playSpeed.value);
        playInterval = setInterval(()=>{
          if(!kahnState) { clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play'; return;}
          const prevOrderLen = kahnState.order.length;
          kahnStepOnce();
          if(kahnState.queue.length===0 || kahnState.order.length===nodes.length || kahnState.order.length===prevOrderLen){
            clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play';
          }
        },speed);
      }

      function kahnRunToEnd(){
        if(!kahnState) initKahn();
        // run instantly
        while(kahnState.queue.length>0){
          kahnStepOnce();
        }
        // final check
        if(kahnState.order.length !== nodes.length){
          algoStatus.textContent = 'cycle detected';
          kahnState.cycleEdges = edges.map(e=>e.id);
        } else {
          algoStatus.textContent = 'done';
        }
        render();
      }

      // full instant Kahn
      function kahnFullInstant(){
        resetKahn();
        initKahn();
        const state = kahnState;
        while(state.queue.length>0){
          const n = state.queue.shift();
          state.order.push(n);
          state.removed.add(n);
          const outs = state.idToOut.get(n) || [];
          for(const to of outs){
            state.inDeg.set(to, state.inDeg.get(to)-1);
            if(state.inDeg.get(to)===0) state.queue.push(to);
          }
        }
        if(state.order.length !== nodes.length){
          algoStatus.textContent = 'cycle detected';
          state.cycleEdges = edges.map(e=>e.id);
        } else {
          algoStatus.textContent = 'complete';
        }
        render();
      }

      // DFS topological sort with cycle detection, returns {order,cycle:boolean}
      function dfsTopo(){
        const {adj} = computeAdjAndInDeg();
        const visited = new Map(); // 0=un,1=visiting,2=done
        const order = [];
        let cycle = null;
        function visit(u,stack){
          if(cycle) return;
          visited.set(u,1);
          stack.push(u);
          const outs = adj.get(u) || [];
          for(const v of outs){
            if(visited.get(v)===1){
              // back edge -> cycle
              cycle = stack.slice(stack.indexOf(v)).concat(v);
              return;
            } else if(!visited.get(v)){
              visit(v,stack);
              if(cycle) return;
            }
          }
          stack.pop();
          visited.set(u,2);
          order.push(u);
        }
        for(const n of nodes){
          if(!visited.get(n.id)) visit(n.id,[]);
        }
        return {order: order.reverse(), cycle};
      }

      // UI wiring
      svg.addEventListener('click',onCanvasClick);
      btnAddNode.addEventListener('click',()=> setMode(mode==='addNode'?null:'addNode'));
      btnAddEdge.addEventListener('click',()=> setMode(mode==='addEdge'?null:'addEdge'));
      btnDelete.addEventListener('click',()=> setMode(mode==='delete'?null:'delete'));
      btnClear.addEventListener('click',()=> { if(confirm('Clear graph?')) clearGraph(); });

      btnRand.addEventListener('click',()=>{
        const n = Math.max(1,parseInt(randN.value)||6);
        const p = Math.max(0,Math.min(100,parseInt(randP.value)||30));
        randomDAG(n,p);
      });

      kahnReset.addEventListener('click',()=> resetKahn());
      kahnStep.addEventListener('click',()=> kahnStepOnce());
      kahnPlay.addEventListener('click',()=> kahnPlayToggle());
      kahnRun.addEventListener('click',()=> kahnRunToEnd());
      btnKahnFull.addEventListener('click',()=> kahnFullInstant());
      btnDFS.addEventListener('click',()=>{
        const res = dfsTopo();
        if(res.cycle){
          alert('Cycle detected (nodes): ' + res.cycle.map(id=>labelOf(id)).join(' -> '));
          // highlight cycle edges
          // mark edges participating in cycle (heuristic: edges between these nodes)
          const setc = new Set(res.cycle);
          resetKahn();
          kahnState = {inDeg:new Map(), idToOut:new Map(), queue:[], order:[], removed:new Set(), cycleEdges:[]};
          for(const e of edges){
            if(setc.has(e.from) && setc.has(e.to)) kahnState.cycleEdges.push(e.id);
          }
          algoStatus.textContent = 'DFS: cycle';
          render();
        } else {
          alert('Topological order (DFS): ' + res.order.map(id=>labelOf(id)).join(', '));
          // show result visually
          resetKahn();
          kahnState = {inDeg:new Map(), idToOut:new Map(), queue:[], order:res.order.slice(), removed:new Set(), cycleEdges:null};
          for(const id of res.order) kahnState.removed.add(id);
          algoStatus.textContent = 'DFS: order computed';
          render();
        }
      });

      btnCompare.addEventListener('click',()=>{
        // run both algorithms and compare
        resetKahn();
        kahnFullInstant();
        const kahnOrder = kahnState && kahnState.order ? kahnState.order.slice() : [];
        const dfsRes = dfsTopo();
        if(dfsRes.cycle){
          alert('DFS found a cycle, Kahn also reports: ' + (kahnState && kahnState.order.length !== nodes.length ? 'cycle' : 'inconsistent'));
        } else {
          const dfOrder = dfsRes.order;
          const s1 = kahnOrder.map(labelOf).join(', ');
          const s2 = dfOrder.map(labelOf).join(', ');
          alert('Kahn: ' + s1 + '\nDFS:  ' + s2 + '\n(Orders may differ but are valid topological sorts)');
        }
      });

      // double click on empty canvas to generate sample
      svg.addEventListener('dblclick',ev=>{
        // create a small example with a known DAG
        nodes = [
          {id:1,label:'A',x:200,y:160},
          {id:2,label:'B',x:420,y:90},
          {id:3,label:'C',x:420,y:240},
          {id:4,label:'D',x:640,y:160},
          {id:5,label:'E',x:860,y:160},
        ];
        edges = [
          {id:1,from:1,to:2},
          {id:2,from:1,to:3},
          {id:3,from:2,to:4},
          {id:4,from:3,to:4},
          {id:5,from:4,to:5},
        ];
        nextEdgeId = 6; nextNodeId = 6;
        resetKahn();
        render();
      });

      // keyboard: Esc cancels mode
      document.addEventListener('keydown',ev=>{
        if(ev.key==='Escape'){ setMode(null); pendingEdgeFrom=null; render(); }
      });

      // init with a small graph
      randomDAG(6,30);

      // Expose a tiny help in status
      algoStatus.textContent = 'idle — ready';
    })();
  </script>
</body>
</html>