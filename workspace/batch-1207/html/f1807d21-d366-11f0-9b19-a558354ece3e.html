<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007cba;
            color: white;
            cursor: pointer;
            border: none;
        }
        button:hover {
            background: #005a87;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .tree-container {
            display: flex;
            justify-content: center;
            min-height: 400px;
            border: 1px solid #eee;
            padding: 20px;
            overflow: auto;
        }
        .node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin: 20px;
            position: relative;
        }
        .red {
            background: #dc3545;
        }
        .black {
            background: #212529;
        }
        .line {
            position: absolute;
            background: #333;
            transform-origin: top left;
        }
        .operations {
            margin-top: 20px;
        }
        .log {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
        }
        .node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Red-Black Tree Visualization</h1>
        
        <div class="controls">
            <input type="number" id="nodeValue" placeholder="Enter value" min="0">
            <button onclick="insertNode()">Insert</button>
            <button onclick="deleteNode()" id="deleteBtn" disabled>Delete</button>
            <button onclick="searchNode()">Search</button>
            <button onclick="clearTree()">Clear Tree</button>
            <button onclick="generateRandomTree()">Generate Random Tree</button>
            <span>Operations: <span id="opCount">0</span></span>
        </div>

        <div class="tree-container" id="treeContainer">
            <!-- Tree will be rendered here -->
        </div>

        <div class="operations">
            <h3>Operations Log</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        class RBNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.parent = null;
                this.color = 'red'; // New nodes are always red
                this.isNull = false; // For leaf nodes
            }
        }

        class RedBlackTree {
            constructor() {
                this.NIL = new RBNode(null);
                this.NIL.color = 'black';
                this.NIL.isNull = true;
                this.root = this.NIL;
                this.operationCount = 0;
            }

            log(message) {
                const log = document.getElementById('log');
                log.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}<br>`;
                log.scrollTop = log.scrollHeight;
                document.getElementById('opCount').textContent = ++this.operationCount;
            }

            leftRotate(x) {
                this.log(`Left rotate at node ${x.value}`);
                const y = x.right;
                x.right = y.left;
                
                if (!y.left.isNull) {
                    y.left.parent = x;
                }
                
                y.parent = x.parent;
                
                if (x.parent.isNull) {
                    this.root = y;
                } else if (x === x.parent.left) {
                    x.parent.left = y;
                } else {
                    x.parent.right = y;
                }
                
                y.left = x;
                x.parent = y;
            }

            rightRotate(y) {
                this.log(`Right rotate at node ${y.value}`);
                const x = y.left;
                y.left = x.right;
                
                if (!x.right.isNull) {
                    x.right.parent = y;
                }
                
                x.parent = y.parent;
                
                if (y.parent.isNull) {
                    this.root = x;
                } else if (y === y.parent.right) {
                    y.parent.right = x;
                } else {
                    y.parent.left = x;
                }
                
                x.right = y;
                y.parent = x;
            }

            insertFixup(z) {
                while (z.parent.color === 'red') {
                    if (z.parent === z.parent.parent.left) {
                        const y = z.parent.parent.right;
                        
                        if (y.color === 'red') {
                            z.parent.color = 'black';
                            y.color = 'black';
                            z.parent.parent.color = 'red';
                            z = z.parent.parent;
                            this.log(`Case 1: Recoloring nodes around ${z.value}`);
                        } else {
                            if (z === z.parent.right) {
                                z = z.parent;
                                this.leftRotate(z);
                            }
                            z.parent.color = 'black';
                            z.parent.parent.color = 'red';
                            this.rightRotate(z.parent.parent);
                            this.log(`Case 2/3: Restructuring around ${z.value}`);
                        }
                    } else {
                        const y = z.parent.parent.left;
                        
                        if (y.color === 'red') {
                            z.parent.color = 'black';
                            y.color = 'black';
                            z.parent.parent.color = 'red';
                            z = z.parent.parent;
                            this.log(`Case 1 (mirror): Recoloring nodes around ${z.value}`);
                        } else {
                            if (z === z.parent.left) {
                                z = z.parent;
                                this.rightRotate(z);
                            }
                            z.parent.color = 'black';
                            z.parent.parent.color = 'red';
                            this.leftRotate(z.parent.parent);
                            this.log(`Case 2/3 (mirror): Restructuring around ${z.value}`);
                        }
                    }
                }
                this.root.color = 'black';
            }

            insert(value) {
                this.log(`Inserting value: ${value}`);
                const z = new RBNode(value);
                z.left = this.NIL;
                z.right = this.NIL;
                
                let y = this.NIL;
                let x = this.root;
                
                while (!x.isNull) {
                    y = x;
                    if (z.value < x.value) {
                        x = x.left;
                    } else {
                        x = x.right;
                    }
                }
                
                z.parent = y;
                
                if (y.isNull) {
                    this.root = z;
                } else if (z.value < y.value) {
                    y.left = z;
                } else {
                    y.right = z;
                }
                
                this.insertFixup(z);
                this.renderTree();
            }

            search(value) {
                this.log(`Searching for value: ${value}`);
                let current = this.root;
                let found = false;
                
                while (!current.isNull) {
                    if (value === current.value) {
                        found = true;
                        break;
                    } else if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                
                if (found) {
                    this.log(`✓ Value ${value} found in the tree`);
                    this.highlightNode(value, true);
                } else {
                    this.log(`✗ Value ${value} not found in the tree`);
                }
                
                return found;
            }

            highlightNode(value, isFound) {
                const nodes = document.querySelectorAll('.node');
                nodes.forEach(node => {
                    if (parseInt(node.textContent) === value) {
                        node.style.boxShadow = isFound ? '0 0 10px green' : '0 0 10px orange';
                        setTimeout(() => node.style.boxShadow = '', 2000);
                    }
                });
            }

            renderTree() {
                const container = document.getElementById('treeContainer');
                container.innerHTML = '';
                
                if (this.root.isNull) {
                    container.innerHTML = '<p>Tree is empty</p>';
                    return;
                }
                
                const levels = this.getTreeLevels();
                this.drawTree(levels, container);
            }

            getTreeLevels() {
                const levels = [];
                const queue = [{node: this.root, level: 0, pos: 0}];
                
                while (queue.length > 0) {
                    const {node, level, pos} = queue.shift();
                    
                    if (!levels[level]) levels[level] = [];
                    levels[level][pos] = node;
                    
                    if (!node.left.isNull) {
                        queue.push({node: node.left, level: level + 1, pos: pos * 2});
                    }
                    if (!node.right.isNull) {
                        queue.push({node: node.right, level: level + 1, pos: pos * 2 + 1});
                    }
                }
                
                return levels;
            }

            drawTree(levels, container) {
                const maxLevel = levels.length - 1;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.width = '100%';
                svg.style.height = '400px';
                svg.style.position = 'absolute';
                
                const nodeContainer = document.createElement('div');
                nodeContainer.style.position = 'relative';
                nodeContainer.style.minHeight = '400px';
                
                levels.forEach((levelNodes, level) => {
                    const levelDiv = document.createElement('div');
                    levelDiv.style.display = 'flex';
                    levelDiv.style.justifyContent = 'center';
                    levelDiv.style.marginBottom = '40px';
                    
                    const levelWidth = Math.pow(2, level);
                    levelNodes.forEach((node, index) => {
                        if (node) {
                            const nodeDiv = document.createElement('div');
                            nodeDiv.className = `node ${node.color}`;
                            nodeDiv.textContent = node.value;
                            nodeDiv.style.margin = `0 ${80 / levelWidth}px`;
                            nodeDiv.dataset.value = node.value;
                            
                            levelDiv.appendChild(nodeDiv);
                            
                            // Draw lines to children
                            if (!node.left.isNull) {
                                this.drawLine(svg, nodeDiv, level + 1, index * 2, levelWidth * 2);
                            }
                            if (!node.right.isNull) {
                                this.drawLine(svg, nodeDiv, level + 1, index * 2 + 1, levelWidth * 2);
                            }
                        }
                    });
                    
                    nodeContainer.appendChild(levelDiv);
                });
                
                container.appendChild(svg);
                container.appendChild(nodeContainer);
            }

            drawLine(svg, parentNode, childLevel, childIndex, totalWidth) {
                const parentRect = parentNode.getBoundingClientRect();
                const containerRect = document.getElementById('treeContainer').getBoundingClientRect();
                
                const x1 = parentRect.left + parentRect.width / 2 - containerRect.left;
                const y1 = parentRect.top + parentRect.height - containerRect.top;
                
                const childLevelDiv = document.querySelectorAll('#treeContainer > div > div')[childLevel];
                if (!childLevelDiv) return;
                
                const childNodes = childLevelDiv.children;
                const childNode = childNodes[childIndex];
                if (!childNode) return;
                
                const childRect = childNode.getBoundingClientRect();
                const x2 = childRect.left + childRect.width / 2 - containerRect.left;
                const y2 = childRect.top - containerRect.top;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '2');
                
                svg.appendChild(line);
            }
        }

        const tree = new RedBlackTree();

        function insertNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            tree.insert(value);
            document.getElementById('nodeValue').value = '';
            updateDeleteButton();
        }

        function deleteNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            // Delete functionality would be implemented here
            tree.log(`Delete operation for value ${value} (not implemented in this demo)`);
            document.getElementById('nodeValue').value = '';
            updateDeleteButton();
        }

        function searchNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            tree.search(value);
            document.getElementById('nodeValue').value = '';
        }

        function clearTree() {
            tree.root = tree.NIL;
            tree.operationCount = 0;
            document.getElementById('opCount').textContent = '0';
            document.getElementById('log').innerHTML = '';
            tree.renderTree();
            updateDeleteButton();
            tree.log('Tree cleared');
        }

        function generateRandomTree() {
            clearTree();
            const count = Math.floor(Math.random() * 10) + 5;
            for (let i = 0; i < count; i++) {
                const value = Math.floor(Math.random() * 100);
                tree.insert(value);
            }
            updateDeleteButton();
        }

        function updateDeleteButton() {
            const deleteBtn = document.getElementById('deleteBtn');
            deleteBtn.disabled = tree.root.isNull;
        }

        // Initialize
        updateDeleteButton();
        tree.renderTree();
    </script>
</body>
</html>