<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Huffman Coding Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#38bdf8;
      --muted:#94a3b8;
      --card:#071226;
      --success:#10b981;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue","Noto Sans",Arial;}
    body{
      margin:0;
      background:linear-gradient(180deg,var(--bg),#02111a 60%);
      color:#e6eef8;
      padding:18px;
    }
    header{display:flex;align-items:center;gap:12px;margin-bottom:14px;}
    h1{font-size:20px;margin:0;color:var(--accent);}
    .desc{color:var(--muted);font-size:13px;margin-top:2px;}
    .container{display:grid;grid-template-columns:380px 1fr;gap:18px;}
    .panel{
      background:linear-gradient(180deg,var(--panel),#041226);border-radius:10px;padding:14px;
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
    }
    label{font-size:13px;color:var(--muted);}
    textarea{width:100%;min-height:120px;background:transparent;border:1px solid rgba(255,255,255,0.06);padding:10px;border-radius:8px;color:inherit;resize:vertical;}
    .row{display:flex;gap:8px;margin-top:8px;}
    button{background:linear-gradient(90deg,var(--accent),#6ee7b7);color:#02111a;border:0;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);}
    .small{padding:6px 8px;font-size:13px;border-radius:7px;}
    .muted{color:var(--muted);font-size:13px;margin-top:8px;}
    .freqs{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .chip{background:var(--glass);padding:6px 8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.03);}
    .controls{display:flex;gap:8px;margin-top:10px;align-items:center;}
    .steps{display:flex;gap:8px;align-items:center;margin-top:10px;}
    .codeTable{margin-top:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);}
    table{width:100%;border-collapse:collapse;}
    th,td{padding:6px;font-size:13px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.02);color:var(--muted);}
    th{color:var(--accent);font-weight:700;}
    .svgWrap{background:linear-gradient(180deg,#02182744,transparent);border-radius:8px;padding:8px;overflow:auto;}
    .pqList{display:flex;flex-direction:column;gap:6px;margin-top:8px;}
    .pqItem{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);}
    .pqLabel{font-weight:700;color:var(--accent);min-width:60px;}
    .freq{color:var(--muted);}
    .status{margin-top:10px;color:var(--muted);font-size:13px;}
    .bigBits{background:#001825;padding:8px;border-radius:8px;margin-top:10px;font-family:monospace;color:#9ae6ff;word-break:break-all;}
    .ratio{margin-top:6px;color:var(--muted);}
    .legend{display:flex;gap:8px;align-items:center;margin-top:8px;}
    .legendItem{display:flex;gap:6px;align-items:center;color:var(--muted);font-size:13px;}
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot0{background:#60a5fa;}
    .dot1{background:#f472b6;}
    footer{margin-top:12px;color:var(--muted);font-size:12px;}
    .help{font-size:13px;margin-top:8px;color:var(--muted);}
    .resultRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px;}
    input[type="text"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);}
    .highlight{outline:2px solid rgba(56,189,248,0.15);box-shadow:0 4px 20px rgba(8,145,178,0.06);}
    .stepControls{display:flex;gap:8px;align-items:center;margin-top:8px;}
    .svgNode{cursor:pointer;transition:transform .12s ease;}
    .svgNode:hover{transform:translateY(-4px);}
    .edgeLabel{font-size:12px;fill:var(--muted);}
  </style>
</head>
<body>
  <header>
    <div style="width:46px;height:46px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:800;color:#02111a;">HC</div>
    <div>
      <h1>Huffman Coding Visualizer</h1>
      <div class="desc">Interactively build a Huffman tree, view codes, encode/decode text and step through the algorithm.</div>
    </div>
  </header>

  <div class="container">
    <div class="panel">
      <label>Input text to encode</label>
      <textarea id="inputText" placeholder="Type or paste some text...">this is an example for huffman encoding</textarea>
      <div class="row">
        <button id="buildBtn">Build Huffman Tree</button>
        <button class="secondary small" id="randomBtn">Random demo</button>
        <button class="secondary small" id="clearBtn">Clear</button>
      </div>
      <div class="help">Try short English sentences or characters. Huffman coding assigns short bit sequences to frequent symbols.</div>

      <div class="muted">Character frequencies</div>
      <div id="freqChips" class="freqs"></div>

      <div class="muted">Priority queue & building steps</div>
      <div id="pqSteps" class="pqList" style="max-height:200px;overflow:auto;"></div>

      <div class="stepControls">
        <button id="prevStep" class="secondary small">◀ Prev</button>
        <button id="nextStep" class="secondary small">Next ▶</button>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
          <button id="autoPlay" class="small secondary">▶ Play</button>
          <span class="badge" id="stepIndicator">Step 0 / 0</span>
        </div>
      </div>

      <div class="muted">Codes (symbol -> bitstring)</div>
      <div id="codes" class="codeTable"></div>

      <div class="muted">Encode / Decode</div>
      <div class="row" style="margin-top:8px;">
        <button id="encodeBtn" class="small">Encode</button>
        <button id="decodeBtn" class="small secondary">Decode</button>
        <input id="bitsInput" type="text" placeholder="Bits for decoding (optional)" style="flex:1;" />
      </div>

      <div id="encodedOut" class="bigBits" style="display:none;"></div>
      <div id="decodedOut" class="bigBits" style="display:none;background:#05221a;color:#bfffe8;"></div>

      <div class="ratio" id="ratio"></div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <div style="font-weight:700;color:var(--accent);">Huffman Tree</div>
          <div class="muted">Visualizes tree nodes (freq + symbol). Click nodes to highlight codes.</div>
        </div>
        <div class="legend">
          <div class="legendItem"><div class="dot dot0"></div> Left edge = 0</div>
          <div class="legendItem"><div class="dot dot1"></div> Right edge = 1</div>
        </div>
      </div>

      <div class="svgWrap" style="margin-top:12px;">
        <svg id="treeSvg" width="100%" height="520"></svg>
      </div>

      <div class="status" id="status">Build a tree to start the visualization.</div>
      <footer>Tip: For single unique characters the code is "0" by convention to allow at least one bit per symbol in this demo.</footer>
    </div>
  </div>

  <script>
    // Huffman Coding Visualizer - Single file
    (function(){
      // Utilities
      function uid() { return Math.random().toString(36).slice(2,9); }
      function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

      // DOM references
      const inputText = document.getElementById('inputText');
      const buildBtn = document.getElementById('buildBtn');
      const randomBtn = document.getElementById('randomBtn');
      const clearBtn = document.getElementById('clearBtn');
      const freqChips = document.getElementById('freqChips');
      const pqStepsDiv = document.getElementById('pqSteps');
      const codesDiv = document.getElementById('codes');
      const treeSvg = document.getElementById('treeSvg');
      const encodeBtn = document.getElementById('encodeBtn');
      const decodeBtn = document.getElementById('decodeBtn');
      const bitsInput = document.getElementById('bitsInput');
      const encodedOut = document.getElementById('encodedOut');
      const decodedOut = document.getElementById('decodedOut');
      const ratioDiv = document.getElementById('ratio');
      const status = document.getElementById('status');
      const prevStep = document.getElementById('prevStep');
      const nextStep = document.getElementById('nextStep');
      const autoPlayBtn = document.getElementById('autoPlay');
      const stepIndicator = document.getElementById('stepIndicator');

      // State
      let frequencies = {};
      let root = null;
      let codes = {};
      let encodeBits = "";
      let steps = []; // building steps
      let stepIndex = -1;
      let autoplayTimer = null;

      // Build frequencies from text
      function computeFrequencies(text){
        const map = {};
        for(const c of text){
          map[c] = (map[c]||0)+1;
        }
        return map;
      }

      // Node structure {id, freq, chars (array), char (single symbol or null), left, right}
      function buildHuffmanTree(freqMap){
        // Priority queue as array sorted by (freq, order)
        const nodes = [];
        let orderCounter = 0;
        function pushNode(node){
          node._order = orderCounter++;
          nodes.push(node);
          nodes.sort((a,b)=> a.freq - b.freq || a._order - b._order);
        }
        // Create leaf nodes
        for(const [ch,f] of Object.entries(freqMap)){
          pushNode({id:uid(), freq:f, chars:[ch], char:ch, left:null, right:null});
        }
        // Edge case: empty
        if(nodes.length===0){
          return {steps:[], root:null};
        }
        // Edge case: single unique char - still create tree node (root) with that leaf as child? We'll create root with one child
        const localSteps = [];
        localSteps.push({pq: nodes.map(n=>({id:n.id, chars:n.chars.slice(), freq:n.freq}))});
        if(nodes.length===1){
          // Create a pseudo parent to ensure a code exists; conventionally assign '0' to the symbol
          const only = nodes.shift();
          const parent = {id:uid(), freq:only.freq, chars:only.chars.slice(), char:null, left:only, right:null};
          localSteps.push({merged: [only.id], created: parent.id, pq: [ {id:parent.id, chars:parent.chars.slice(), freq:parent.freq} ]});
          return {steps:localSteps, root:parent};
        }
        while(nodes.length>1){
          const a = nodes.shift();
          const b = nodes.shift();
          const mergedChars = a.chars.concat(b.chars);
          const parent = {id:uid(), freq: a.freq + b.freq, chars: mergedChars, char:null, left:a, right:b};
          pushNode(parent);
          // record step
          localSteps.push({
            merged: [a.id, b.id],
            created: parent.id,
            pq: nodes.map(n=>({id:n.id, chars:n.chars.slice(), freq:n.freq}))
          });
        }
        return {steps:localSteps, root: nodes[0] || null};
      }

      // Generate codes by traversing tree
      function generateCodes(root){
        const map = {};
        if(!root) return map;
        // If root has only one child or is leaf: give '0' to single symbol
        function dfs(node, prefix){
          if(!node) return;
          if(node.char !== null && node.left===null && node.right===null){
            map[node.char] = prefix.length ? prefix : "0";
            return;
          }
          if(node.left) dfs(node.left, prefix + "0");
          if(node.right) dfs(node.right, prefix + "1");
          // Handle case where right child null but left exists: codes assigned already
        }
        dfs(root, "");
        return map;
      }

      // Encode text with codes
      function encodeText(text, codes){
        let bits="";
        for(const ch of text){
          bits += (codes[ch] ?? "");
        }
        return bits;
      }

      // Decode bits using tree
      function decodeBits(bits, root){
        if(!root) return "";
        let out = "";
        let node = root;
        // If tree is single-leaf parent with only left child and right null, interpret '0' bits as the symbol
        for(let i=0;i<bits.length;i++){
          const b = bits[i];
          if(b==='0'){
            if(node.left) node = node.left;
            else node = node.left || node.right || node; // fallback
          } else {
            if(node.right) node = node.right;
            else node = node.left || node.right || node;
          }
          if(node.char !== null && node.left===null && node.right===null){
            out += node.char;
            node = root;
          }
        }
        return out;
      }

      // UI update functions
      function renderFreqChips(freqMap){
        freqChips.innerHTML="";
        const items = Object.entries(freqMap).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]? -1:1));
        for(const [ch,f] of items){
          const chip = document.createElement('div');
          chip.className = 'chip';
          const label = ch === ' ' ? '␣ (space)' : ch;
          chip.textContent = `${label} : ${f}`;
          freqChips.appendChild(chip);
        }
        if(items.length===0){
          freqChips.innerHTML = '<div class="muted">No characters</div>';
        }
      }

      function renderPQSteps(steps, idx){
        pqStepsDiv.innerHTML = "";
        steps.forEach((s,i)=>{
          const item = document.createElement('div');
          item.className = 'pqItem';
          if(i===idx) item.classList.add('highlight');
          const label = document.createElement('div');
          label.className = 'pqLabel';
          label.textContent = `Step ${i}`;
          const info = document.createElement('div');
          info.style.flex='1';
          if(s.pq){
            const list = s.pq.map(p=> `${p.chars.join('')}(${p.freq})`).join('  |  ');
            info.innerHTML = `<div style="color:var(--muted)">${list}</div>`;
          } else {
            info.innerHTML = `<div style="color:var(--muted)">No PQ</div>`;
          }
          const meta = document.createElement('div');
          meta.className = 'freq';
          meta.textContent = s.merged ? `merged ${s.merged.join(',')} → ${s.created}` : '';
          item.appendChild(label);
          item.appendChild(info);
          item.appendChild(meta);
          pqStepsDiv.appendChild(item);
        });
        if(steps.length===0){
          pqStepsDiv.innerHTML = '<div class="muted">No building steps yet</div>';
        }
      }

      function renderCodesTable(codesMap){
        codesDiv.innerHTML = "";
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr><th>Symbol</th><th>Code</th><th>Bits</th></tr>`;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        const rows = Object.entries(codesMap).sort((a,b)=> a[0].localeCompare(b[0]));
        for(const [ch,code] of rows){
          const tr = document.createElement('tr');
          const s = ch === ' ' ? '␣ (space)' : (ch === '\n' ? '\\n' : ch);
          tr.innerHTML = `<td style="color:var(--accent);font-weight:700">${s}</td><td style="font-family:monospace">${code}</td><td class="freq">${code.length} bits</td>`;
          tbody.appendChild(tr);
        }
        if(rows.length===0){
          const tr = document.createElement('tr'); tr.innerHTML = `<td class="muted">No codes</td><td></td><td></td>`; tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        codesDiv.appendChild(table);
      }

      // Tree layout & drawing
      function layoutTree(node){
        // Compute number of leaves to determine horizontal span
        function countLeaves(n){
          if(!n) return 0;
          if(n.left===null && n.right===null) return 1;
          return (n.left?countLeaves(n.left):0) + (n.right?countLeaves(n.right):0);
        }
        const leafCount = countLeaves(node) || 1;
        // assign positions
        const xGap = 80;
        const yGap = 70;
        let curX = 20;
        function assign(n, depth){
          if(!n) return;
          if(n.left===null && n.right===null){
            n._x = curX;
            n._y = depth*yGap + 40;
            curX += xGap;
          } else {
            // assign left subtree first
            if(n.left) assign(n.left, depth+1);
            if(n.right) assign(n.right, depth+1);
            // position at middle of children
            const leftX = n.left? n.left._x : (n.right? n.right._x : curX);
            const rightX = n.right? n.right._x : (n.left? n.left._x : curX);
            n._x = (leftX + rightX)/2;
            n._y = depth*yGap + 40;
          }
        }
        assign(node, 0);
      }

      function drawTree(rootNode, highlightPathChars=[]){
        treeSvg.innerHTML = '';
        if(!rootNode){
          const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
          txt.setAttribute("x","20"); txt.setAttribute("y","40");
          txt.setAttribute("fill","#7dd3fc");
          txt.setAttribute("font-size","16");
          txt.textContent = "No tree to draw";
          treeSvg.appendChild(txt);
          return;
        }
        layoutTree(rootNode);
        // Resize svg height/width to fit nodes
        let maxX=0, maxY=0;
        (function traverse(n){
          if(!n) return;
          maxX = Math.max(maxX, n._x);
          maxY = Math.max(maxY, n._y);
          traverse(n.left); traverse(n.right);
        })(rootNode);
        treeSvg.setAttribute('viewBox',`0 0 ${Math.max(500, maxX+80)} ${Math.max(520,maxY+120)}`);

        // Draw edges first
        function drawEdges(n){
          if(!n) return;
          if(n.left){
            drawLine(n._x, n._y, n.left._x, n.left._y, '0');
            drawEdges(n.left);
          }
          if(n.right){
            drawLine(n._x, n._y, n.right._x, n.right._y, '1');
            drawEdges(n.right);
          }
        }
        function drawLine(x1,y1,x2,y2,label){
          const line = document.createElementNS("http://www.w3.org/2000/svg","line");
          line.setAttribute("x1",x1); line.setAttribute("y1",y1+12);
          line.setAttribute("x2",x2); line.setAttribute("y2",y2-12);
          line.setAttribute("stroke", label==='0' ? "#60a5fa" : "#f472b6");
          line.setAttribute("stroke-width","2");
          treeSvg.appendChild(line);
          // label
          const lx = (x1+x2)/2;
          const ly = (y1+y2)/2;
          const lab = document.createElementNS("http://www.w3.org/2000/svg","text");
          lab.setAttribute("x", lx);
          lab.setAttribute("y", ly);
          lab.setAttribute("text-anchor","middle");
          lab.setAttribute("class","edgeLabel");
          lab.textContent = label;
          treeSvg.appendChild(lab);
        }

        drawEdges(rootNode);

        // Draw nodes
        function drawNode(n){
          const g = document.createElementNS("http://www.w3.org/2000/svg","g");
          g.setAttribute("transform", `translate(${n._x},${n._y})`);
          g.classList.add('svgNode');
          // background circle
          const circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
          circle.setAttribute("r",22);
          circle.setAttribute("cx",0);
          circle.setAttribute("cy",0);
          // highlight if part of hovered path
          const inPath = n.chars && n.chars.some(c=> highlightPathChars.includes(c));
          circle.setAttribute("fill", inPath ? "rgba(56,189,248,0.12)" : "rgba(255,255,255,0.02)");
          circle.setAttribute("stroke", inPath ? "#38bdf8" : "rgba(255,255,255,0.06)");
          circle.setAttribute("stroke-width","2");
          g.appendChild(circle);

          // label text
          const topText = document.createElementNS("http://www.w3.org/2000/svg","text");
          topText.setAttribute("x",0);
          topText.setAttribute("y",-6);
          topText.setAttribute("text-anchor","middle");
          topText.setAttribute("font-size","12");
          topText.setAttribute("fill", "#e6eef8");
          if(n.char !== null && n.left===null && n.right===null){
            const symbol = n.char === ' ' ? '␣' : (n.char === '\n' ? '\\n' : n.char);
            topText.textContent = symbol;
          } else {
            topText.textContent = '';
          }
          g.appendChild(topText);

          const freqText = document.createElementNS("http://www.w3.org/2000/svg","text");
          freqText.setAttribute("x",0);
          freqText.setAttribute("y",14);
          freqText.setAttribute("text-anchor","middle");
          freqText.setAttribute("font-size","12");
          freqText.setAttribute("fill","#9fbfd9");
          freqText.textContent = n.freq;
          g.appendChild(freqText);

          // attach hover/click
          g.addEventListener('mouseenter', ()=> {
            // show codes for chars in this node
            const targetChars = n.chars ? n.chars.slice() : [];
            drawTree(rootNode, targetChars);
            showStatus(`Node includes symbols: ${targetChars.map(c=> c===' ' ? '␣(space)' : c).join(', ')}`);
          });
          g.addEventListener('mouseleave', ()=> {
            drawTree(rootNode, []);
            showStatus(`Huffman tree built. Click nodes to highlight codes.`);
          });
          g.addEventListener('click', ()=> {
            // Show codes filtered to this node
            const targetChars = n.chars ? n.chars.slice() : [];
            const filtered = {};
            for(const ch of targetChars){
              if(codes[ch]) filtered[ch]=codes[ch];
            }
            renderCodesTable(filtered);
            showStatus(`Codes for node: ${targetChars.map(c=> c===' ' ? '␣(space)' : c).join(', ')}`);
          });

          treeSvg.appendChild(g);

          if(n.left) drawNode(n.left);
          if(n.right) drawNode(n.right);
        }

        drawNode(rootNode);
      }

      function showStatus(text){
        status.textContent = text;
      }

      // Steps navigation
      function updateStepIndicator(){
        stepIndicator.textContent = `Step ${Math.max(0,stepIndex)} / ${Math.max(0,steps.length-1)}`;
      }

      function gotoStep(i){
        if(steps.length===0){ stepIndex = -1; updateStepIndicator(); renderPQSteps(steps, -1); return; }
        stepIndex = clamp(i,0,steps.length-1);
        updateStepIndicator();
        renderPQSteps(steps, stepIndex);
        // Show PQ snapshot for step
        const s = steps[stepIndex];
        if(s.pq && s.pq.length){
          // build a pseudo forest for PQ rendering: show each node as small representation in left panel (we already render pq list)
          // For the main tree, always show final root
        }
      }

      function next(){
        gotoStep(stepIndex+1);
      }
      function prev(){
        gotoStep(stepIndex-1);
      }
      function toggleAutoplay(){
        if(autoplayTimer){
          clearInterval(autoplayTimer); autoplayTimer=null; autoPlayBtn.textContent="▶ Play";
        } else {
          autoPlayBtn.textContent="⏸ Pause";
          autoplayTimer = setInterval(()=>{
            if(stepIndex >= steps.length-1){
              clearInterval(autoplayTimer); autoplayTimer=null; autoPlayBtn.textContent="▶ Play";
            } else next();
          }, 700);
        }
      }

      // Main build function
      function build(){
        const txt = inputText.value;
        frequencies = computeFrequencies(txt);
        renderFreqChips(frequencies);
        const built = buildHuffmanTree(frequencies);
        steps = built.steps || [];
        root = built.root;
        codes = generateCodes(root);
        renderCodesTable(codes);
        drawTree(root);
        // reset navigation
        stepIndex = 0;
        updateStepIndicator();
        renderPQSteps(steps, 0);
        showStatus("Tree built. Hover nodes to highlight symbols. Click nodes to filter codes.");
        // reset outputs
        encodedOut.style.display='none';
        decodedOut.style.display='none';
        ratioDiv.textContent = '';
      }

      // Encode event
      function doEncode(){
        const text = inputText.value;
        if(!root){ showStatus("Build the tree first."); return; }
        encodeBits = encodeText(text, codes);
        encodedOut.style.display='block';
        encodedOut.textContent = encodeBits || "(empty)";
        // compute original size in bits assuming ASCII/UTF-8 8 bits per char
        const originalBits = text.length * 8;
        const compressedBits = encodeBits.length;
        const ratio = compressedBits ? (Math.round((compressedBits/originalBits)*1000)/10) : 0;
        ratioDiv.textContent = `Original: ${originalBits} bits (${text.length} chars @8b) · Compressed: ${compressedBits} bits · Ratio: ${ratio}%`;
        showStatus('Encoded text. You can copy the bitstring or decode it.');
      }

      // Decode event
      function doDecode(){
        const bits = bitsInput.value.trim() || encodeBits;
        if(!root){ showStatus("Build the tree first."); return; }
        if(!bits){
          decodedOut.style.display='block';
          decodedOut.textContent = "(no bits)";
          return;
        }
        const decoded = decodeBits(bits, root);
        decodedOut.style.display='block';
        decodedOut.textContent = decoded;
        showStatus('Decoded bitstring using current Huffman tree.');
      }

      // random demo
      function randomDemo(){
        const samples = [
          "this is just a random demo of huffman coding",
          "aaabbbbccddeeeeeeee",
          "the quick brown fox jumps over the lazy dog",
          "to be or not to be that is the question",
          "huffman coding compresses data by using variable length codes"
        ];
        inputText.value = samples[Math.floor(Math.random()*samples.length)];
        build();
      }

      // Clear
      function clearAll(){
        inputText.value = '';
        freqChips.innerHTML='';
        pqStepsDiv.innerHTML='';
        codesDiv.innerHTML='';
        treeSvg.innerHTML='';
        encodedOut.style.display='none';
        decodedOut.style.display='none';
        ratioDiv.textContent='';
        status.textContent = 'Cleared. Enter text to build a Huffman tree.';
        frequencies = {}; root = null; steps=[]; stepIndex=-1; codes={}; encodeBits="";
      }

      // Wire events
      buildBtn.addEventListener('click', build);
      randomBtn.addEventListener('click', randomDemo);
      clearBtn.addEventListener('click', clearAll);
      encodeBtn.addEventListener('click', doEncode);
      decodeBtn.addEventListener('click', doDecode);
      nextStep.addEventListener('click', ()=>{ next(); });
      prevStep.addEventListener('click', ()=>{ prev(); });
      autoPlayBtn.addEventListener('click', toggleAutoplay);

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'ArrowRight') next();
        if(e.key === 'ArrowLeft') prev();
        if(e.key === ' ') { e.preventDefault(); toggleAutoplay(); }
      });

      // Initialize demo
      build();

      // For accessibility: show clickable instructions
      treeSvg.addEventListener('click', ()=> {
        showStatus('You can hover nodes to highlight and click to filter codes.');
      });

    })();
  </script>
</body>
</html>