<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Min/Max Heap Visualization</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #heapContainer { display: flex; justify-content: center; margin-top: 20px; }
        .node { border: 1px solid #333; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        #controls { text-align: center; margin: 20px; }
    </style>
</head>
<body>

<h1>Min/Max Heap Visualization</h1>
<div id="controls">
    <input type="number" id="valueInput" placeholder="Enter a number" />
    <button onclick="insertMinHeap()">Insert to Min Heap</button>
    <button onclick="insertMaxHeap()">Insert to Max Heap</button>
    <button onclick="removeMinHeap()">Remove from Min Heap</button>
    <button onclick="removeMaxHeap()">Remove from Max Heap</button>
</div>

<div id="heapContainer"></div>

<script>
    let minHeap = [];
    let maxHeap = [];

    function displayHeaps() {
        const container = document.getElementById('heapContainer');
        container.innerHTML = ''; // Clear previous heaps
        
        const minHeapDiv = document.createElement('div');
        minHeapDiv.innerHTML = '<strong>Min Heap:</strong> ' + minHeap.map(node => `<span class="node">${node}</span>`).join('');
        
        const maxHeapDiv = document.createElement('div');
        maxHeapDiv.innerHTML = '<strong>Max Heap:</strong> ' + maxHeap.map(node => `<span class="node">${node}</span>`).join('');
        
        container.appendChild(minHeapDiv);
        container.appendChild(maxHeapDiv);
    }

    function insertMinHeap() {
        const value = parseInt(document.getElementById('valueInput').value);
        if (!isNaN(value)) {
            minHeap.push(value);
            bubbleUpMin(minHeap);
            displayHeaps();
            document.getElementById('valueInput').value = ''; // Clear input field
        }
    }

    function insertMaxHeap() {
        const value = parseInt(document.getElementById('valueInput').value);
        if (!isNaN(value)) {
            maxHeap.push(value);
            bubbleUpMax(maxHeap);
            displayHeaps();
            document.getElementById('valueInput').value = ''; // Clear input field
        }
    }

    function removeMinHeap() {
        if (minHeap.length > 0) {
            minHeap[0] = minHeap.pop(); // Replace root with the last element
            bubbleDownMin(minHeap);
            displayHeaps();
        }
    }

    function removeMaxHeap() {
        if (maxHeap.length > 0) {
            maxHeap[0] = maxHeap.pop(); // Replace root with the last element
            bubbleDownMax(maxHeap);
            displayHeaps();
        }
    }

    function bubbleUpMin(heap) {
        let index = heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (heap[index] >= heap[parentIndex]) break;
            [heap[index], heap[parentIndex]] = [heap[parentIndex], heap[index]];
            index = parentIndex;
        }
    }

    function bubbleDownMin(heap) {
        let index = 0;
        const length = heap.length;
        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let smallest = index;

            if (leftChildIndex < length && heap[leftChildIndex] < heap[smallest]) {
                smallest = leftChildIndex;
            }
            if (rightChildIndex < length && heap[rightChildIndex] < heap[smallest]) {
                smallest = rightChildIndex;
            }
            if (smallest === index) break;

            [heap[index], heap[smallest]] = [heap[smallest], heap[index]];
            index = smallest;
        }
    }

    function bubbleUpMax(heap) {
        let index = heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (heap[index] <= heap[parentIndex]) break;
            [heap[index], heap[parentIndex]] = [heap[parentIndex], heap[index]];
            index = parentIndex;
        }
    }

    function bubbleDownMax(heap) {
        let index = 0;
        const length = heap.length;
        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let largest = index;

            if (leftChildIndex < length && heap[leftChildIndex] > heap[largest]) {
                largest = leftChildIndex;
            }
            if (rightChildIndex < length && heap[rightChildIndex] > heap[largest]) {
                largest = rightChildIndex;
            }
            if (largest === index) break;
            
            [heap[index], heap[largest]] = [heap[largest], heap[index]];
            index = largest;
        }
    }
</script>
</body>
</html>