<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Huffman Coding Visualizer</title>
<style>
  :root{--bg:#0f1724;--panel:#111827;--accent:#3b82f6;--muted:#94a3b8;--card:#0b1220;--good:#16a34a;--bad:#ef4444}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,#051025 0%, #071428 50%, #021324 100%);color:#e6eef8;display:flex;flex-direction:column;gap:12px;padding:16px;}
  header{display:flex;align-items:center;gap:12px}
  header h1{margin:0;font-size:20px}
  .container{display:grid;grid-template-columns:370px 1fr;gap:16px;align-items:start}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
  .controls{display:flex;flex-direction:column;gap:10px}
  textarea,input,select,button{font-family:inherit;font-size:13px}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  textarea{width:100%;min-height:84px;background:#071223;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:#e6eef8;resize:vertical}
  input[type="text"],select{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#071223;color:#e6eef8}
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  button{background:var(--accent);border:none;color:white;padding:10px;border-radius:8px;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .small{padding:8px;font-size:13px;border-radius:6px}
  .kbd{background:#081226;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace}
  .meta{display:flex;gap:8px;flex-wrap:wrap}
  .stat{background:#061226;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:120px}
  .tree-area{height:640px;position:relative;overflow:auto;background:linear-gradient(180deg,#071a2b,rgba(7,24,43,0.6));border-radius:10px;padding:12px}
  svg{width:100%;height:100%}
  .codes{max-height:300px;overflow:auto;margin-top:8px;border-radius:6px;padding:8px;background:#061226;border:1px solid rgba(255,255,255,0.02)}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:6px 8px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03)}
  th{font-size:12px;color:var(--muted)}
  .node{stroke:#0b1220;stroke-width:1.5}
  .leaf{fill:#0ea5a4}
  .internal{fill:#3b82f6}
  .highlight{stroke:#f59e0b;stroke-width:3}
  .pq{background:#061226;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);margin-top:8px}
  .controls-row{display:flex;gap:8px;align-items:center}
  .toggle{display:inline-flex;align-items:center;gap:8px}
  .smallmuted{color:var(--muted);font-size:13px}
  a{color:var(--accent)}
  footer{color:var(--muted);font-size:13px}
  .bitbox{background:#071426;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);font-family:monospace;white-space:nowrap;overflow:auto}
  @media(max-width:900px){.container{grid-template-columns:1fr;}}
</style>
</head>
<body>
<header>
  <h1>Huffman Coding Visualizer</h1>
  <div class="smallmuted">Interactive demonstration of building a Huffman tree, generating codes, encoding and decoding.</div>
</header>

<div class="container">
  <div class="panel controls">
    <label for="inputText">Input text (or enter symbol:frequency lines below)</label>
    <textarea id="inputText" placeholder="Type text to analyze, e.g.: hello world"></textarea>

    <label for="freqInput">Optional custom frequencies (one per line, e.g. A:5 or space:10). If filled, this overrides the text above.</label>
    <textarea id="freqInput" placeholder="Example:
a:5
b:2
 :10"></textarea>

    <div class="row">
      <button id="buildBtn">Build Huffman Tree</button>
      <button id="randomBtn" class="ghost">Sample text</button>
    </div>

    <div class="controls-row">
      <div style="flex:1">
        <label>Step through tree construction</label>
        <div class="row">
          <button id="stepBack" class="ghost small">◀ Step Back</button>
          <button id="stepForward" class="ghost small">Step ▶</button>
          <button id="playBtn" class="small">Play ▶</button>
        </div>
      </div>
      <div style="width:120px">
        <label>Speed (ms)</label>
        <input type="range" id="speed" min="200" max="2000" step="100" value="800"/>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div class="smallmuted">Priority queue shows nodes available each step.</div>
      <button id="resetBtn" class="ghost small">Reset</button>
    </div>

    <div style="margin-top:8px">
      <label>Encoding / Decoding</label>
      <div class="row">
        <input id="encodeInput" type="text" placeholder="Text to encode (uses current mapping)"/>
        <button id="encodeBtn" class="small">Encode</button>
      </div>
      <div style="margin-top:8px" class="row">
        <input id="bitInput" type="text" placeholder="Bits to decode (e.g. 010011)"/>
        <button id="decodeBtn" class="small">Decode</button>
      </div>
    </div>

    <div style="margin-top:8px" class="meta">
      <div class="stat"><div class="smallmuted">Original length</div><div id="origLen">—</div></div>
      <div class="stat"><div class="smallmuted">Encoded bits</div><div id="encLen">—</div></div>
      <div class="stat"><div class="smallmuted">Compression</div><div id="ratio">—</div></div>
    </div>

    <div style="margin-top:8px">
      <label>Codes</label>
      <div id="codes" class="codes">No codes yet</div>
    </div>

    <div style="margin-top:8px">
      <label>Priority Queue (current step)</label>
      <div id="pq" class="pq">—</div>
    </div>

    <div style="margin-top:8px">
      <label>Encoded bits (top 400 shown)</label>
      <div id="bitbox" class="bitbox">—</div>
    </div>

    <div style="margin-top:8px">
      <label>Decode result</label>
      <div id="decodeResult" class="bitbox">—</div>
    </div>
  </div>

  <div class="panel">
    <label>Tree visualization</label>
    <div class="tree-area" id="treeArea">
      <svg id="svgRoot" viewBox="0 0 1200 640" preserveAspectRatio="xMinYMin meet"></svg>
    </div>
  </div>
</div>

<footer style="margin-top:8px">
  Explanation: Huffman coding builds an optimal prefix code by repeatedly merging the two least-frequent symbols into a combined node. Left edges are shown as "0" and right edges as "1". Use the step controls to watch the merges.
</footer>

<script>
/* Huffman Coding Visualizer
   - Build freq table from input text or explicit frequencies
   - Construct Huffman tree; record merge steps
   - Visualize tree, nodes, codes; allow step-through animation
   - Encode/decode functionality
*/

(function(){
  // Utilities
  const $ = id => document.getElementById(id)
  const svg = $('svgRoot')
  const treeArea = $('treeArea')

  // State
  let nodes = []             // all nodes created (leaves and internals)
  let steps = []             // snapshots of {queue: [{id,weight,labels}], merge: {left,right,newId}} per merge
  let stepIndex = 0
  let playTimer = null

  // DOM elements
  const inputText = $('inputText')
  const freqInput = $('freqInput')
  const buildBtn = $('buildBtn')
  const randomBtn = $('randomBtn')
  const stepForward = $('stepForward')
  const stepBack = $('stepBack')
  const playBtn = $('playBtn')
  const resetBtn = $('resetBtn')
  const speed = $('speed')
  const codesDiv = $('codes')
  const pqDiv = $('pq')
  const origLenDiv = $('origLen')
  const encLenDiv = $('encLen')
  const ratioDiv = $('ratio')
  const encodeInput = $('encodeInput')
  const encodeBtn = $('encodeBtn')
  const bitInput = $('bitInput')
  const decodeBtn = $('decodeBtn')
  const bitbox = $('bitbox')
  const decodeResult = $('decodeResult')

  // Sample texts
  const samples = [
    "this is an example for huffman encoding",
    "hello hello hello huffman coding test",
    "the quick brown fox jumps over the lazy dog",
    "aaaaabbbbcccdde"
  ]
  randomBtn.addEventListener('click', ()=>{
    inputText.value = samples[Math.floor(Math.random()*samples.length)]
  })

  buildBtn.addEventListener('click', buildFromInput)
  stepForward.addEventListener('click', ()=>{ stepIndex = Math.min(stepIndex+1, steps.length); renderStep() })
  stepBack.addEventListener('click', ()=>{ stepIndex = Math.max(stepIndex-1, 0); renderStep() })
  playBtn.addEventListener('click', togglePlay)
  resetBtn.addEventListener('click', resetAll)
  encodeBtn.addEventListener('click', doEncode)
  decodeBtn.addEventListener('click', doDecode)

  // buildFromInput: read input text / freq input and build steps
  function buildFromInput(){
    resetAll()
    const freqSpec = parseFreqInput(freqInput.value.trim())
    let freq
    if (Object.keys(freqSpec).length > 0) {
      freq = freqSpec
    } else {
      const txt = inputText.value
      if (!txt) { alert('Enter text or custom frequencies first.'); return }
      freq = buildFreqFromText(txt)
    }
    // Create leaf nodes
    nodes = []
    let idCounter = 0
    const leaves = []
    for (const sym of Object.keys(freq).sort()) {
      const node = { id: 'n'+(idCounter++), sym, weight: freq[sym], left:null, right:null, isLeaf:true }
      nodes.push(node)
      leaves.push(node)
    }
    // Edge case: single symbol -> assign code "0"
    if (leaves.length === 1) {
      const root = { id:'n'+(idCounter++), sym:null, weight:leaves[0].weight, left:leaves[0], right:null, isLeaf:false }
      nodes.push(root)
      steps = [{ queue: leaves.map(n=>snapshotNode(n)), merge: null }]
      steps.push({ queue: [snapshotNode(root)], merge: { left: leaves[0].id, right: null, newId: root.id } })
      stepIndex = steps.length
      buildCodes(root)
      renderStep()
      return
    }

    // Priority queue: array of nodes, sorted by weight then by symbol ordering for determinism
    function pqCompare(a,b){
      if (a.weight !== b.weight) return a.weight - b.weight
      // tie-breaker: leaf vs internal, then symbol alphabetical, then id
      const at = a.isLeaf ? 0 : 1
      const bt = b.isLeaf ? 0 : 1
      if (at !== bt) return at - bt
      const sa = a.isLeaf ? String(a.sym) : combinedLabel(a)
      const sb = b.isLeaf ? String(b.sym) : combinedLabel(b)
      if (sa !== sb) return sa < sb ? -1 : 1
      return a.id < b.id ? -1 : 1
    }
    function combinedLabel(n){
      if (!n) return ''
      if (n.isLeaf) return String(n.sym)
      const left = n.left ? combinedLabel(n.left) : ''
      const right = n.right ? combinedLabel(n.right) : ''
      return '('+left+'|'+right+')'
    }

    // Initialize PQ
    let pq = leaves.slice().sort(pqCompare)
    steps = []
    steps.push({ queue: pq.map(n=>snapshotNode(n)), merge: null })

    // Iteratively merge two smallest
    while (pq.length > 1) {
      const a = pq.shift()
      const b = pq.shift()
      const merged = { id:'n'+(idCounter++), sym:null, weight: a.weight + b.weight, left:a, right:b, isLeaf:false }
      nodes.push(merged)
      // Insert back into pq keeping sort
      pq.push(merged)
      pq.sort(pqCompare)
      steps.push({ queue: pq.map(n=>snapshotNode(n)), merge: { left: a.id, right: b.id, newId: merged.id } })
    }

    // Final root is pq[0]
    stepIndex = 0
    buildCodes(pq[0])
    renderStep()
  }

  function snapshotNode(n){
    return { id: n.id, weight: n.weight, label: n.isLeaf ? String(n.sym) : combinedLabel(n) }
    function combinedLabel(n2){
      if (n2.isLeaf) return String(n2.sym)
      const l = n2.left ? combinedLabel(n2.left) : ''
      const r = n2.right ? combinedLabel(n2.right) : ''
      return '('+l+'|'+r+')'
    }
  }

  function buildFreqFromText(text){
    const freq = {}
    for (let ch of text) {
      freq[ch] = (freq[ch] || 0) + 1
    }
    return freq
  }

  function parseFreqInput(txt){
    const out = {}
    if (!txt) return out
    const lines = txt.split('\n')
    for (let line of lines) {
      line = line.trim()
      if (!line) continue
      const m = line.match(/^(.+?)\s*[:=]\s*(\d+)\s*$/)
      if (m) {
        let sym = m[1]
        // allow special names like "space" or "newline"
        if (sym.toLowerCase() === 'space') sym = ' '
        else if (sym.toLowerCase() === 'newline') sym = '\n'
        else if (sym.toLowerCase() === 'tab') sym = '\t'
        out[sym] = parseInt(m[2],10)
      } else {
        // fallback: single char then number separated by whitespace
        const p = line.split(/\s+/)
        if (p.length >= 2 && p[p.length-1].match(/^\d+$/)) {
          const num = parseInt(p[p.length-1],10)
          const sym = line.slice(0, line.lastIndexOf(p[p.length-1])).trim()
          let s = sym
          if (s.toLowerCase() === 'space') s = ' '
          out[s] = num
        }
      }
    }
    return out
  }

  // Build codes for a final root node
  let currentCodes = {}
  function buildCodes(root){
    currentCodes = {}
    if (!root) return
    // Edge single leaf: assign code '0'
    if (root.isLeaf) {
      currentCodes[root.sym] = '0'
      return
    }
    const dfs = (node, prefix)=>{
      if (!node) return
      if (node.isLeaf) {
        currentCodes[node.sym] = prefix || '0'
        return
      }
      dfs(node.left, prefix + '0')
      dfs(node.right, prefix + '1')
    }
    dfs(root, '')
  }

  // Render functions
  function renderStep(){
    clearSvg()
    if (steps.length === 0) {
      codesDiv.innerText = 'No codes yet'
      pqDiv.innerText = '—'
      origLenDiv.innerText = '—'
      encLenDiv.innerText = '—'
      ratioDiv.innerText = '—'
      bitbox.innerText = '—'
      decodeResult.innerText = '—'
      return
    }
    // Clamp stepIndex
    stepIndex = Math.max(0, Math.min(stepIndex, steps.length))
    // Show PQ for current step
    const snap = (stepIndex === 0) ? steps[0] : steps[Math.max(0, stepIndex-1)]
    pqDiv.innerHTML = pqHtml(snap.queue, (stepIndex > 0 ? steps[stepIndex-1].merge : null))
    // Determine which nodes should be visible at this step
    const visibleIds = new Set()
    // At step 0: show initial leaves only
    if (stepIndex === 0) {
      for (const q of steps[0].queue) visibleIds.add(q.id)
    } else {
      // Include leaves that are referenced by any remaining PQ node or by merges already performed
      // Strategy: reconstruct by applying merges from step 1..stepIndex-1 adding merged nodes
      // start with leaves from first queue
      for (const q of steps[0].queue) visibleIds.add(q.id)
      for (let si = 1; si <= stepIndex; si++) {
        const merge = steps[si].merge
        if (!merge) continue
        visibleIds.add(merge.newId)
        if (merge.left) visibleIds.add(merge.left)
        if (merge.right) visibleIds.add(merge.right)
      }
    }

    // Build a map of id -> node object from nodes list
    const nodeMap = {}
    for (const n of nodes) nodeMap[n.id] = n

    // Build a minimal set of nodes to display: include any visible node and recursively include children if visible
    const displayNodes = []
    for (const id of visibleIds) {
      if (nodeMap[id]) displayNodes.push(nodeMap[id])
    }

    // Determine root for layout: if we've completed all merges, root is last merged; else choose the highest merged/new node at current step or fallback
    let root = null
    if (stepIndex >= steps.length) {
      root = nodes.find(n => n.id === steps[steps.length-1].merge.newId) || nodeMap[steps[0].queue[0].id]
    } else {
      // find the latest merge performed (<= stepIndex)
      let lastMerge = null
      for (let si = 1; si <= stepIndex; si++) {
        const m = steps[si].merge
        if (m) lastMerge = m
      }
      if (lastMerge) root = nodeMap[lastMerge.newId]
      else {
        // no merges yet: pick an arbitrary leaf (leftmost)
        root = nodeMap[steps[0].queue[0].id]
      }
    }
    if (!root) root = displayNodes[0]

    // Layout positions: compute subtree widths and assign x,y
    const positions = {}
    const levelHeight = 80
    function computeWidths(node){
      if (!node) return 0
      // If node not in displayNodes set, treat as width 0
      if (!visibleIds.has(node.id)) return 0
      if (node.isLeaf) {
        return 1
      } else {
        const lw = computeWidths(node.left)
        const rw = computeWidths(node.right)
        const w = Math.max(1, lw + rw)
        return w
      }
    }
    const totalWidthUnits = computeWidths(root) || 1
    let cursor = 0
    function assign(node, depth){
      if (!node) return
      if (!visibleIds.has(node.id)) return
      if (node.isLeaf) {
        const x = ((cursor + 0.5) / totalWidthUnits) * 1000 + 60
        positions[node.id] = {x, y: 20 + depth*levelHeight}
        cursor++
      } else {
        // place children first
        assign(node.left, depth+1)
        assign(node.right, depth+1)
        // position here as midpoint of children available positions
        const leftPos = node.left && positions[node.left.id]
        const rightPos = node.right && positions[node.right.id]
        let x
        if (leftPos && rightPos) x = (leftPos.x + rightPos.x)/2
        else if (leftPos) x = leftPos.x
        else if (rightPos) x = rightPos.x
        else {
          // no children visible: assign at next cursor
          x = ((cursor + 0.5) / totalWidthUnits) * 1000 + 60
          cursor++
        }
        positions[node.id] = {x, y: 20 + depth*levelHeight}
      }
    }
    assign(root, 0)

    // Draw edges and nodes for visible nodes
    // We'll draw edges first (so nodes overlay them)
    const svgNS = "http://www.w3.org/2000/svg"

    // edges
    for (const id of Object.keys(positions)) {
      const node = nodeMap[id]
      if (!node || node.isLeaf) continue
      const p = positions[id]
      if (node.left && positions[node.left.id]) {
        const c = positions[node.left.id]
        const line = document.createElementNS(svgNS, 'path')
        const d = `M ${p.x} ${p.y+18} C ${p.x} ${p.y+40} ${c.x} ${c.y-10} ${c.x} ${c.y-8}`
        line.setAttribute('d', d)
        line.setAttribute('stroke', '#2b6ea3')
        line.setAttribute('fill', 'none')
        line.setAttribute('opacity', '0.9')
        svg.appendChild(line)
        // label 0 near left branch
        const tx = document.createElementNS(svgNS, 'text')
        tx.setAttribute('x', (p.x*0.66 + c.x*0.34))
        tx.setAttribute('y', (p.y*0.66 + c.y*0.34)-6)
        tx.setAttribute('fill', '#bfe0ff')
        tx.setAttribute('font-size', '11')
        tx.setAttribute('text-anchor','middle')
        tx.textContent = '0'
        svg.appendChild(tx)
      }
      if (node.right && positions[node.right.id]) {
        const c = positions[node.right.id]
        const p2 = positions[id]
        const line = document.createElementNS(svgNS, 'path')
        const d = `M ${p2.x} ${p2.y+18} C ${p2.x} ${p2.y+40} ${c.x} ${c.y-10} ${c.x} ${c.y-8}`
        line.setAttribute('d', d)
        line.setAttribute('stroke', '#60a5fa')
        line.setAttribute('fill', 'none')
        line.setAttribute('opacity', '0.9')
        svg.appendChild(line)
        // label 1 near right branch
        const tx = document.createElementNS(svgNS, 'text')
        tx.setAttribute('x', (p2.x*0.66 + c.x*0.34))
        tx.setAttribute('y', (p2.y*0.66 + c.y*0.34)-6)
        tx.setAttribute('fill', '#bfe0ff')
        tx.setAttribute('font-size', '11')
        tx.setAttribute('text-anchor','middle')
        tx.textContent = '1'
        svg.appendChild(tx)
      }
    }

    // nodes
    for (const id of Object.keys(positions)) {
      const n = nodeMap[id]
      const pos = positions[id]
      const g = document.createElementNS(svgNS, 'g')
      g.setAttribute('transform', `translate(${pos.x},${pos.y})`)
      // circle
      const circ = document.createElementNS(svgNS, 'circle')
      circ.setAttribute('r', 18)
      circ.setAttribute('class', 'node')
      circ.setAttribute('stroke', '#062033')
      circ.setAttribute('stroke-width', '2')
      circ.setAttribute('fill', n.isLeaf ? '#06b6a4' : '#3b82f6')
      // highlight merged node at current step (if any)
      const curMerge = (stepIndex>0 && stepIndex<=steps.length-1) ? steps[stepIndex].merge : null
      if (curMerge && curMerge.newId === id) {
        circ.setAttribute('stroke', '#f59e0b')
        circ.setAttribute('stroke-width', '3')
      }
      g.appendChild(circ)
      // text: weight
      const txt1 = document.createElementNS(svgNS, 'text')
      txt1.setAttribute('y', -2)
      txt1.setAttribute('fill', '#031827')
      txt1.setAttribute('font-weight', '700')
      txt1.setAttribute('font-size', '12')
      txt1.setAttribute('text-anchor','middle')
      txt1.textContent = n.weight
      g.appendChild(txt1)
      // symbol for leaf
      if (n.isLeaf) {
        const txt2 = document.createElementNS(svgNS, 'text')
        txt2.setAttribute('y', 18)
        txt2.setAttribute('fill', '#bfe0ff')
        txt2.setAttribute('font-size', '12')
        txt2.setAttribute('text-anchor','middle')
        txt2.textContent = printable(n.sym)
        g.appendChild(txt2)
      }
      svg.appendChild(g)
    }

    // Update codes display: if fully built, show final codes; else show codes for partial tree (if possible)
    const finalRoot = nodes.find(n => steps.length>0 && n.id === steps[steps.length-1].merge.newId)
    if (finalRoot) {
      buildCodes(finalRoot)
      // original text metrics
      const freq = {}
      if (freqInput.value.trim()) {
        Object.assign(freq, parseFreqInput(freqInput.value.trim()))
      } else {
        const txt = inputText.value || ''
        const f = buildFreqFromText(txt)
        Object.assign(freq, f)
      }
      let origBits = 0
      let totalChars = 0
      for (const s of Object.keys(freq)) {
        totalChars += freq[s]
        const code = currentCodes[s] || ''
        origBits += freq[s] * code.length
      }
      // For original size assuming 8 bits per character
      const origSizeBits = (inputText.value || '').length * 8
      origLenDiv.innerText = (inputText.value || '').length + ' chars (' + origSizeBits + ' bits at 8b/c)'
      encLenDiv.innerText = origBits + ' bits'
      ratioDiv.innerText = origBits ? ( (origBits / origSizeBits * 100).toFixed(1) + '% of original') : '—'
      // codes table
      codesDiv.innerHTML = buildCodesHtml(currentCodes, freq)
      // show encoded bits for the entire input text
      const txt = inputText.value || ''
      const encoded = encodeTextWithCodes(txt, currentCodes)
      bitbox.innerText = encoded ? encoded.slice(0,400) + (encoded.length>400 ? '…' : '') : '(empty)'
    } else {
      codesDiv.innerText = 'Tree not complete yet; advance steps to final merge to see final codes.'
      origLenDiv.innerText = '—'
      encLenDiv.innerText = '—'
      ratioDiv.innerText = '—'
      bitbox.innerText = '—'
    }

    // adjust svg viewBox to content (rough)
    const allX = Object.values(positions).map(p=>p.x)
    const allY = Object.values(positions).map(p=>p.y)
    if (allX.length>0) {
      const minX = Math.min(...allX)-80
      const maxX = Math.max(...allX)+80
      const minY = 0
      const maxY = Math.max(...allY)+120
      const width = Math.max(900, maxX-minX)
      const height = Math.max(300, maxY-minY)
      svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`)
    }
  }

  function pqHtml(queue, merge){
    if (!queue || queue.length===0) return '—'
    const rows = queue.map(q=> `<div style="display:flex;justify-content:space-between;padding:4px 6px;border-radius:6px;margin-bottom:4px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)"><div style="font-family:monospace">${escapeHtml(q.label)}</div><div style="color:#bfe0ff">${q.weight}</div></div>`).join('')
    let top = '<div style="font-size:13px;color:var(--muted);margin-bottom:6px">[' + queue.map(q=>q.id).join(', ') + ']</div>'
    if (merge) {
      top += `<div style="font-size:13px;color:#f59e0b;margin-bottom:6px">Last merge: ${merge.left}${merge.right ? ' + ' + merge.right : ''} → ${merge.newId}</div>`
    }
    return top + rows
  }

  function buildCodesHtml(codes, freq){
    const entries = Object.keys(codes).sort((a,b)=> ( (freq && freq[b] ? freq[b] :0) - (freq && freq[a] ? freq[a] :0) ) || (a<b?-1:1))
    let html = '<table><thead><tr><th>Symbol</th><th>Frequency</th><th>Code</th><th>Bits</th></tr></thead><tbody>'
    for (const s of entries) {
      const code = codes[s]
      const f = freq && freq[s] ? freq[s] : '-'
      html += `<tr><td class="kbd">${escapeHtml(printable(s))}</td><td>${f}</td><td><span class="kbd">${escapeHtml(code)}</span></td><td>${code.length}</td></tr>`
    }
    html += '</tbody></table>'
    return html
  }

  function escapeHtml(s){
    if (s === null || s === undefined) return ''
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
  }

  function printable(s){
    if (s === ' ') return '␣ (space)'
    if (s === '\n') return '␤ (newline)'
    if (s === '\t') return '\\t (tab)'
    if (s === '') return '(empty)'
    return String(s)
  }

  function clearSvg(){
    while (svg.firstChild) svg.removeChild(svg.firstChild)
  }

  // Encoding & decoding helpers
  function encodeTextWithCodes(txt, codes){
    if (!txt || !codes) return ''
    let out = ''
    for (let ch of txt) {
      const c = codes[ch]
      if (!c) return null
      out += c
    }
    return out
  }

  function doEncode(){
    if (!currentCodes || Object.keys(currentCodes).length===0) {
      alert('No code mapping available. Build the tree first and reach the final merge.')
      return
    }
    const text = encodeInput.value
    if (!text) { alert('Enter text to encode'); return }
    const enc = encodeTextWithCodes(text, currentCodes)
    if (enc === null) {
      alert('Input contains symbols not present in the codes.')
      return
    }
    bitbox.innerText = enc.slice(0,400) + (enc.length>400 ? '…' : '')
    encLenDiv.innerText = enc.length + ' bits (encoded input)'
  }

  function doDecode(){
    if (!nodes || nodes.length===0) { alert('Build a tree first.'); return }
    // Need final root (complete tree)
    const finalMerge = steps.length ? steps[steps.length-1].merge : null
    if (!finalMerge) { alert('Tree not complete; advance to final merge to decode.'); return }
    const root = nodes.find(n => n.id === finalMerge.newId)
    if (!root) { alert('No final tree available.'); return }
    const bits = bitInput.value.trim()
    if (!bits) { alert('Enter bits to decode'); return }
    // validate bits
    if (!/^[01]+$/.test(bits)) { alert('Bits must be 0/1 only'); return }
    let out = ''
    let node = root
    for (let i=0;i<bits.length;i++){
      const b = bits[i]
      if (b === '0') node = node.left
      else node = node.right
      if (!node) { decodeResult.innerText = 'Decoding failed at bit index ' + i + ' (no child)'; return }
      if (node.isLeaf) {
        out += node.sym
        node = root
      }
    }
    decodeResult.innerText = out || '(empty)'
  }

  // Play control
  function togglePlay(){
    if (playTimer) {
      clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play ▶'
    } else {
      playBtn.textContent = 'Pause ❚❚'
      playTimer = setInterval(()=>{
        if (stepIndex < steps.length) {
          stepIndex++
          renderStep()
        } else {
          clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play ▶'
        }
      }, parseInt(speed.value,10))
    }
  }

  function resetAll(){
    nodes = []
    steps = []
    stepIndex = 0
    currentCodes = {}
    clearSvg()
    renderStep()
  }

  // Initialize with a default sample
  inputText.value = samples[0]
  buildFromInput()

  // Accessibility: keyboard shortcuts
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'ArrowRight') { stepIndex = Math.min(stepIndex+1, steps.length); renderStep() }
    if (e.key === 'ArrowLeft') { stepIndex = Math.max(stepIndex-1, 0); renderStep() }
    if (e.key === ' ') { e.preventDefault(); togglePlay() }
  })
})();
</script>
</body>
</html>