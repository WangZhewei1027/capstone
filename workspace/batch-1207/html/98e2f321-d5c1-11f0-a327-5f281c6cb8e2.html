<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>K-Means Clustering Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 0; background: #f6f7fb; color: #111; }
    header { padding: 18px 22px; background: linear-gradient(90deg,#2f3e8f,#5b79d8); color: white; }
    header h1 { margin: 0; font-size: 20px; }
    main { display: flex; gap: 12px; padding: 14px; }
    #controls { width: 360px; background: white; border-radius: 8px; padding: 12px; box-shadow: 0 6px 18px rgba(20,30,80,0.08); }
    .section { margin-bottom: 12px; }
    label { display:block; font-size: 13px; margin-bottom:6px; color:#333;}
    input[type=range] { width: 100%; }
    input[type=number], select, button { font-size: 13px; padding: 6px 8px; border-radius: 6px; border: 1px solid #ccd6ee; }
    button { background: #2f3e8f; color: white; cursor: pointer; }
    button.secondary { background: white; color: #2f3e8f; border: 1px solid #cdd7fb; }
    button.small { padding: 6px 10px; font-size: 13px; }
    .row { display:flex; gap:8px; align-items:center; }
    .compact { display:flex; gap:8px; }
    #canvasWrap { flex: 1; display:flex; flex-direction: column; gap:8px; align-items:stretch; }
    #canvas { background: linear-gradient(180deg, #ffffff, #f3f7ff); border-radius: 8px; box-shadow: 0 6px 18px rgba(20,30,80,0.06); cursor: crosshair; }
    .stats { display:flex; gap:10px; align-items:center; font-size: 13px; color:#333; }
    .muted { color:#6b7280; font-size: 13px; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); display:inline-block; vertical-align: middle; }
    footer { padding: 10px 18px; font-size: 13px; color:#444; text-align:center; }
    .hint { font-size:12px; color:#666; margin-top:6px; }
    .control-row { display:flex; gap:8px; align-items:center; margin-top:6px; }
    #pointsCount{width:80px;}
    .small-muted { font-size: 12px; color: #666; }
    .center-info { font-size: 12px; color:#333; margin-top:6px; max-height:120px; overflow:auto; }
  </style>
</head>
<body>
  <header>
    <h1>K-Means Clustering — Interactive Visualization</h1>
  </header>

  <main>
    <div id="controls">
      <div class="section">
        <label>Dataset</label>
        <div class="row">
          <select id="dataType">
            <option value="random">Uniform random</option>
            <option value="blobs" selected>Gaussian blobs</option>
            <option value="ring">Ring + noise</option>
          </select>
          <input id="pointsCount" type="number" min="5" max="2000" value="200" title="Number of points">
          <button id="generate" class="small">Generate</button>
        </div>
        <div class="hint">Click on canvas to add a point. Drag points to move them.</div>
      </div>

      <div class="section">
        <label>Algorithm</label>
        <div class="row">
          <label style="margin:0;">k: <strong id="kDisplay">4</strong></label>
          <input id="kRange" type="range" min="1" max="12" value="4">
        </div>
        <div style="margin-top:8px;">
          <select id="initMethod">
            <option value="random">Random initialization</option>
            <option value="kmeans++" selected>K-Means++</option>
          </select>
          <select id="distanceMetric" style="margin-left:8px; display:none;">
            <option>Euclidean</option>
          </select>
        </div>
      </div>

      <div class="section">
        <label>Control</label>
        <div class="compact" style="margin-bottom:8px;">
          <button id="play" class="small">Run</button>
          <button id="step" class="small secondary">Step</button>
          <button id="reset" class="small secondary">Reset</button>
          <button id="clear" class="small secondary">Clear Points</button>
        </div>
        <div class="control-row">
          <label style="margin:0;">Speed</label>
          <input id="speed" type="range" min="50" max="2000" value="400">
          <label id="speedLbl" class="small-muted">400 ms / it</label>
        </div>
        <div class="control-row">
          <label style="margin:0;">Max Iter</label>
          <input id="maxIter" type="number" min="1" max="1000" value="100" style="width:80px;">
        </div>
      </div>

      <div class="section">
        <label>Info</label>
        <div class="stats">
          <div class="muted">Iteration:</div><div id="iter">0</div>
          <div class="muted">SSE (inertia):</div><div id="sse">0.00</div>
          <div class="muted">Converged:</div><div id="converged">—</div>
        </div>
        <div class="hint">SSE = sum of squared distances of points to their cluster center (lower is better).</div>
      </div>

      <div class="section">
        <label>Cluster Centers</label>
        <div id="centers" class="center-info muted">No centers yet.</div>
      </div>

      <div class="section">
        <div class="muted">Tips:</div>
        <ul style="margin:6px 0 0 18px; padding:0; color:#444; font-size:13px;">
          <li>Use K-Means++ for smarter initialization.</li>
          <li>Empty clusters may occur — they get reinitialized automatically.</li>
          <li>Try different k and datasets to see behavior.</li>
        </ul>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="canvas" width="900" height="620"></canvas>
      <div class="legend" id="legend"></div>
    </div>
  </main>

  <footer>Interactive K-Means demo • Click points to add • Drag to move • Press Run to animate</footer>

<script>
/*
  K-Means Interactive Demo
  - Single-file HTML + JavaScript
  - Supports random and k-means++ initializations
  - Step-by-step iteration, Play/Pause, step, reset
  - Add and drag points on canvas
  - Shows SSE, iteration count, and centers
*/

(() => {
  // Basic utilities
  function rand(min=0,max=1){ return Math.random()*(max-min)+min; }
  function randint(a,b){ return Math.floor(rand(a,b+1)); }
  function distance2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  // Canvas and UI elements
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const kRange = document.getElementById('kRange');
  const kDisplay = document.getElementById('kDisplay');
  const generateBtn = document.getElementById('generate');
  const dataType = document.getElementById('dataType');
  const pointsCountInput = document.getElementById('pointsCount');
  const playBtn = document.getElementById('play');
  const stepBtn = document.getElementById('step');
  const resetBtn = document.getElementById('reset');
  const clearBtn = document.getElementById('clear');
  const speedSlider = document.getElementById('speed');
  const speedLbl = document.getElementById('speedLbl');
  const maxIterInput = document.getElementById('maxIter');
  const iterLabel = document.getElementById('iter');
  const sseLabel = document.getElementById('sse');
  const convergedLabel = document.getElementById('converged');
  const centersDiv = document.getElementById('centers');
  const initMethod = document.getElementById('initMethod');
  const legendDiv = document.getElementById('legend');

  let width = canvas.width, height = canvas.height;

  // Data structures
  let points = []; // {x,y, cluster}
  let centers = []; // {x,y, oldX, oldY}
  let k = parseInt(kRange.value);
  let running = false;
  let iter = 0;
  let maxIter = parseInt(maxIterInput.value);
  let playTimer = null;
  let converged = false;
  let colors = [];

  // Parameters
  function updateParamsFromUI(){
    k = parseInt(kRange.value);
    kDisplay.textContent = k;
    maxIter = parseInt(maxIterInput.value) || 100;
    speedLbl.textContent = speedSlider.value + " ms / it";
  }
  updateParamsFromUI();

  // Color generation for clusters (HSL)
  function colorForIndex(i){
    const hue = Math.floor((i*360/k) % 360);
    return `hsl(${hue} 80% 50%)`;
  }
  function updateColors(){
    colors = [];
    for(let i=0;i<Math.max(k,1);i++) colors.push(colorForIndex(i));
    renderLegend();
  }
  function renderLegend(){
    legendDiv.innerHTML = '';
    for(let i=0;i<Math.min(colors.length,12);i++){
      const el = document.createElement('div');
      el.style.display = 'flex';
      el.style.alignItems = 'center';
      el.style.gap = '6px';
      el.innerHTML = `<span class="swatch" style="background:${colors[i]};"></span><span style="font-size:13px;color:#333">Cluster ${i+1}</span>`;
      legendDiv.appendChild(el);
    }
  }

  // Dataset generation
  function generateDataset(){
    const n = clamp(parseInt(pointsCountInput.value) || 200, 1, 2000);
    const type = dataType.value;
    points = [];
    if(type === 'random'){
      for(let i=0;i<n;i++){
        points.push({x: rand(30, width-30), y: rand(30, height-30), cluster: -1});
      }
    } else if(type === 'blobs'){
      // choose 3-6 blob centers
      const blobs = randint(3,6);
      const centersBlob = [];
      for(let b=0;b<blobs;b++){
        centersBlob.push({x: rand(80,width-80), y: rand(80,height-80), spread: rand(20,70)});
      }
      for(let i=0;i<n;i++){
        const b = centersBlob[randint(0, blobs-1)];
        const angle = rand(0,Math.PI*2);
        const r = Math.abs(randn()) * b.spread;
        points.push({x: clamp(b.x + Math.cos(angle)*r, 5, width-5), y: clamp(b.y + Math.sin(angle)*r, 5, height-5), cluster: -1});
      }
    } else if(type === 'ring'){
      // One ring cluster + random noise
      const ringCenter = {x: width/2 + rand(-60,60), y: height/2 + rand(-40,40)};
      const radius = Math.min(width,height)/4;
      for(let i=0;i<n;i++){
        if(Math.random() < 0.75){
          const ang = rand(0,Math.PI*2);
          const r = radius + randn()*18;
          points.push({x: clamp(ringCenter.x + Math.cos(ang)*r, 5, width-5), y: clamp(ringCenter.y + Math.sin(ang)*r, 5, height-5), cluster: -1});
        } else {
          points.push({x: rand(10,width-10), y: rand(10,height-10), cluster: -1});
        }
      }
    }
    iter = 0;
    converged = false;
    centers = [];
    updateColors();
    computeSSELabel();
    draw();
  }

  // Normal(ish) random for blobs
  function randn(){
    // Box-Muller
    let u=0,v=0;
    while(u===0) u=Math.random();
    while(v===0) v=Math.random();
    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  }

  // Initialize centers (random or kmeans++)
  function initCenters(){
    centers = [];
    updateColors();
    if(k <= 0) return;
    if(initMethod.value === 'random'){
      // pick k random points from canvas space (not necessarily existing points)
      for(let i=0;i<k;i++){
        centers.push({x: rand(20,width-20), y: rand(20,height-20), oldX: null, oldY: null});
      }
    } else {
      // k-means++ initialization: choose centers from points probabilistically
      if(points.length === 0){
        for(let i=0;i<k;i++) centers.push({x: rand(20,width-20), y: rand(20,height-20), oldX:null, oldY:null});
      } else {
        // copy points array for distances
        // 1. choose first center uniformly from points
        const first = points[randint(0, points.length-1)];
        centers.push({x:first.x, y:first.y, oldX:null, oldY:null});
        // choose remaining
        while(centers.length < k){
          // compute d^2 to nearest chosen center for each point
          const d2 = points.map(p => {
            let minD = Infinity;
            for(const c of centers){
              const dd = distance2(p, c);
              if(dd < minD) minD = dd;
            }
            return minD;
          });
          // sum
          const sum = d2.reduce((a,b)=>a+b,0);
          if(sum === 0){
            // all points coincide — pick random
            const p = points[randint(0,points.length-1)];
            centers.push({x:p.x, y:p.y, oldX:null, oldY:null});
            continue;
          }
          // pick random with probability proportional to d2
          let r = Math.random()*sum;
          let idx = 0;
          while(r > 0 && idx < d2.length){
            r -= d2[idx];
            idx++;
          }
          idx = clamp(idx-1, 0, points.length-1);
          const chosen = points[idx];
          centers.push({x: chosen.x, y: chosen.y, oldX:null, oldY:null});
        }
      }
    }
    // if k > points, may still have centers created at random positions
    draw();
  }

  // Assignment step: assign each point to nearest center
  function assignPoints(){
    if(centers.length === 0) return false;
    let changed = false;
    for(const p of points){
      let best = -1, bestD = Infinity;
      for(let i=0;i<centers.length;i++){
        const d = distance2(p, centers[i]);
        if(d < bestD){ bestD = d; best = i; }
      }
      if(p.cluster !== best){
        changed = true;
        p.cluster = best;
      }
    }
    return changed;
  }

  // Update step: move centers to mean of assigned points
  function updateCenters(){
    const sums = new Array(centers.length).fill(0).map(()=>({x:0,y:0,count:0}));
    for(const p of points){
      if(p.cluster>=0 && p.cluster < centers.length){
        sums[p.cluster].x += p.x;
        sums[p.cluster].y += p.y;
        sums[p.cluster].count += 1;
      }
    }
    let anyMoved = false;
    for(let i=0;i<centers.length;i++){
      const c = centers[i];
      c.oldX = c.x; c.oldY = c.y;
      const s = sums[i];
      if(s.count === 0){
        // Empty cluster: reinitialize to random point or random location
        if(points.length > 0){
          const pick = points[randint(0, points.length-1)];
          c.x = pick.x + randn()*6;
          c.y = pick.y + randn()*6;
        } else {
          c.x = rand(20, width-20);
          c.y = rand(20, height-20);
        }
      } else {
        c.x = s.x / s.count;
        c.y = s.y / s.count;
      }
      if(distance2(c, {x:c.oldX,y:c.oldY}) > 1e-6) anyMoved = true;
    }
    return anyMoved;
  }

  // Compute SSE
  function computeSSE(){
    let sse = 0;
    for(const p of points){
      if(p.cluster >= 0 && p.cluster < centers.length){
        sse += distance2(p, centers[p.cluster]);
      } else {
        // not assigned -> ignore
      }
    }
    return sse;
  }

  function computeSSELabel(){
    const sse = computeSSE();
    sseLabel.textContent = sse.toFixed(2);
  }

  // A single iteration: assign + update
  function iterateOnce(){
    if(centers.length === 0) initCenters();
    iter++;
    iterLabel.textContent = iter;
    const changedAssign = assignPoints();
    const moved = updateCenters();
    computeSSELabel();
    draw();
    // converged if no assignment changed and centers did not move
    converged = !changedAssign && !moved;
    convergedLabel.textContent = converged ? 'Yes' : 'No';
    if(converged || iter >= maxIter) {
      stop();
    }
    updateCenterDisplay();
  }

  // Control functions
  function play(){
    if(running) return;
    running = true;
    playBtn.textContent = 'Pause';
    // ensure centers initialized
    if(centers.length === 0) initCenters();
    if(iter === 0){
      // do one step so UI shows progress quickly
      // but don't auto-stop before starting
    }
    const stepFunc = () => {
      if(!running) return;
      if(iter >= maxIter || converged) { stop(); return; }
      iterateOnce();
    };
    // immediate first step
    stepFunc();
    playTimer = setInterval(stepFunc, parseInt(speedSlider.value));
  }

  function stop(){
    running = false;
    playBtn.textContent = 'Run';
    if(playTimer){ clearInterval(playTimer); playTimer = null; }
  }

  function reset(){
    stop();
    iter = 0;
    iterLabel.textContent = 0;
    converged = false;
    convergedLabel.textContent = '—';
    // clear cluster assignments but keep points
    for(const p of points) p.cluster = -1;
    centers = [];
    updateColors();
    computeSSELabel();
    updateCenterDisplay();
    draw();
  }

  // UI event wiring
  kRange.addEventListener('input', () => {
    updateParamsFromUI();
    updateColors();
    updateCenterDisplay();
    draw();
  });
  pointsCountInput.addEventListener('change', ()=>{ /* nothing */ });
  generateBtn.addEventListener('click', ()=>{
    reset();
    generateDataset();
  });
  initMethod.addEventListener('change', ()=>{ reset(); });
  playBtn.addEventListener('click', ()=>{ if(running) stop(); else play(); });
  stepBtn.addEventListener('click', ()=>{
    stop();
    if(centers.length === 0) initCenters();
    iterateOnce();
  });
  resetBtn.addEventListener('click', reset);
  clearBtn.addEventListener('click', ()=>{
    stop();
    points = [];
    centers = [];
    iter = 0;
    iterLabel.textContent = 0;
    computeSSELabel();
    updateCenterDisplay();
    draw();
  });
  speedSlider.addEventListener('input', ()=>{ speedLbl.textContent = speedSlider.value + " ms / it"; if(playTimer){ clearInterval(playTimer); playTimer = setInterval(() => { if(running) iterateOnce(); }, parseInt(speedSlider.value)); }});
  maxIterInput.addEventListener('change', ()=>{ maxIter = parseInt(maxIterInput.value) || 100; });

  // Mouse interactions for adding and dragging points
  let draggingPoint = null;
  let dragOffset = {x:0,y:0};

  function findPointAt(x,y, radius=8){
    for(let i=points.length-1;i>=0;i--){ // topmost
      const p = points[i];
      const dx = p.x - x, dy = p.y - y;
      if(dx*dx + dy*dy <= radius*radius) return p;
    }
    return null;
  }

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const p = findPointAt(x,y);
    if(p){
      draggingPoint = p;
      dragOffset.x = p.x - x;
      dragOffset.y = p.y - y;
      canvas.style.cursor = 'grabbing';
      stop();
    } else {
      // add new point
      const newP = {x: clamp(x, 2, width-2), y: clamp(y, 2, height-2), cluster: -1};
      points.push(newP);
      computeSSELabel();
      draw();
    }
  });

  window.addEventListener('mousemove', (e) => {
    if(!draggingPoint) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    draggingPoint.x = clamp(x + dragOffset.x, 2, width-2);
    draggingPoint.y = clamp(y + dragOffset.y, 2, height-2);
    // optionally reassign on the fly for a live feel
    draw();
  });

  window.addEventListener('mouseup', (e) => {
    if(draggingPoint){
      draggingPoint = null;
      canvas.style.cursor = 'crosshair';
      computeSSELabel();
      draw();
    }
  });

  // Display centers info
  function updateCenterDisplay(){
    if(centers.length === 0){
      centersDiv.textContent = 'No centers yet.';
      return;
    }
    let html = '';
    for(let i=0;i<centers.length;i++){
      const c = centers[i];
      const pts = points.filter(p => p.cluster === i);
      html += `<div style="display:flex;gap:6px;align-items:center;margin-bottom:6px;">
        <span class="swatch" style="background:${colors[i]}; width:12px;height:12px;"></span>
        <div style="font-size:13px;color:#222;">
          <strong>Cluster ${i+1}</strong> — (${c.x.toFixed(1)}, ${c.y.toFixed(1)}) — ${pts.length} pts
        </div>
      </div>`;
    }
    centersDiv.innerHTML = html;
  }

  // Rendering
  function draw(){
    ctx.clearRect(0,0,width,height);

    // background grid
    ctx.save();
    ctx.fillStyle = '#f7f9ff';
    ctx.fillRect(0,0,width,height);
    ctx.restore();

    // draw Voronoi-like colored point fills (optional) - we'll draw semi-transparent fills per cluster for better visuals
    if(centers.length > 0){
      // paint approximate cluster regions by drawing many translucent circles around centers (cheap approximation)
      for(let i=0;i<centers.length;i++){
        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(colors[i], 0.04);
        ctx.arc(centers[i].x, centers[i].y, 120, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // draw points
    for(const p of points){
      const col = (p.cluster >= 0 && p.cluster < colors.length) ? colors[p.cluster] : '#999';
      ctx.beginPath();
      ctx.fillStyle = col;
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 1;
      ctx.moveTo(p.x, p.y);
      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }

    // draw centers (with motion trail)
    for(let i=0;i<centers.length;i++){
      const c = centers[i];
      // draw line from old pos -> new pos to show movement
      if(c.oldX !== null && (Math.abs(c.oldX-c.x) > 0.01 || Math.abs(c.oldY-c.y) > 0.01)){
        ctx.beginPath();
        ctx.strokeStyle = hexToRGBA(colors[i], 0.6);
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        ctx.moveTo(c.oldX, c.oldY);
        ctx.lineTo(c.x, c.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      // center marker
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = colors[i];
      ctx.lineWidth = 2.5;
      ctx.arc(c.x, c.y, 9, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // label
      ctx.fillStyle = '#222';
      ctx.font = '12px system-ui, Arial';
      ctx.fillText((i+1).toString(), c.x-4, c.y+4);
    }
  }

  // tiny helper to convert HSL/CSS color into rgba with alpha
  function hexToRGBA(cssColor, alpha){
    // assume hsl(...) or rgb(...) or hex; just return css with alpha if hsl present
    if(cssColor.startsWith('hsl')){
      // convert to rgba by inserting alpha
      return cssColor.replace('hsl','hsla').replace(')', `, ${alpha})`);
    } else {
      // fallback: return as-is with globalAlpha through fillStyle wrapper
      // We'll use canvas globalAlpha as workaround (but we need a color); return color string
      // For simplicity, convert hex (#rrggbb) to rgba if provided
      const m = cssColor.match(/^#?([0-9a-f]{6})$/i);
      if(m){
        const v = m[1];
        const r = parseInt(v.substring(0,2),16);
        const g = parseInt(v.substring(2,4),16);
        const b = parseInt(v.substring(4,6),16);
        return `rgba(${r},${g},${b},${alpha})`;
      }
      return cssColor;
    }
  }

  // Setup initial dataset
  generateDataset();

  // Expose some keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){
      e.preventDefault();
      if(running) stop(); else play();
    } else if(e.key === 'r' || e.key === 'R'){
      reset();
    } else if(e.key === 'g' || e.key === 'G'){
      generateBtn.click();
    }
  });

  // Initialize center UI values
  updateColors();
  updateCenterDisplay();
  draw();

  // Start with kmeans++ initialization for convenience
  initCenters();

  // Resize handling to support device pixel ratio (crisp canvas)
  function adjustCanvasForDPR(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    width = Math.floor(rect.width);
    height = Math.floor(rect.height);
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  // ensure consistent size by matching initial attributes
  (function initCanvasSize(){
    // already set by attributes; place a small refresh
    const rect = canvas.getBoundingClientRect();
    width = canvas.width; height = canvas.height;
    draw();
  })();

  // Window resize - keep canvas pixel size fixed as defined
  window.addEventListener('resize', () => {
    // ignore for simplicity; the canvas has fixed dimensions
  });

})();
</script>
</body>
</html>