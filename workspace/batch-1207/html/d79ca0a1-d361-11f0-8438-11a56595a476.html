<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Selection Sort Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f0f0;
    color: #333;
  }
  h1 {
    text-align: center;
  }
  #arrayContainer {
    display: flex;
    justify-content: center;
    align-items: flex-end;
    height: 200px;
    margin: 20px auto;
    max-width: 600px;
    gap: 4px;
  }
  .bar {
    background-color: steelblue;
    width: 30px;
    transition: background-color 0.3s, height 0.3s;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    color: white;
    font-weight: bold;
    border-radius: 3px 3px 0 0;
  }
  .bar.selected {
    background-color: #e67e22;
  }
  .bar.min {
    background-color: #27ae60;
  }
  .bar.swapping {
    background-color: #c0392b;
  }
  #controls {
    text-align: center;
    margin-bottom: 20px;
  }
  button, input[type="number"] {
    font-size: 16px;
    padding: 6px 12px;
    margin: 0 5px;
  }
  #info {
    max-width: 600px;
    margin: 0 auto;
    font-size: 1.1em;
    background: white;
    padding: 15px;
    border-radius: 6px;
    box-shadow: 0 0 8px #ccc;
    line-height: 1.4;
  }
</style>
</head>
<body>
<h1>Selection Sort Visualization</h1>
<div id="controls">
  <label for="arraySize">Array Size: </label>
  <input type="number" id="arraySize" min="5" max="30" value="10" />
  <button id="generateBtn">Generate Array</button>
  <button id="startBtn">Start Sorting</button>
</div>
<div id="arrayContainer"></div>
<div id="info">
  <p><strong>Selection Sort</strong> is an in-place comparison sorting algorithm. It divides the input list into two parts: a sorted sublist of items which is built up from left to right at the front (left) of the list and a sublist of the remaining unsorted items. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest element in the unsorted sublist, swapping it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
  <p>This visualization shows the process step-by-step.</p>
</div>

<script>
  const arrayContainer = document.getElementById('arrayContainer');
  const generateBtn = document.getElementById('generateBtn');
  const startBtn = document.getElementById('startBtn');
  const arraySizeInput = document.getElementById('arraySize');

  let array = [];
  let actions = []; // holds the steps of sorting for visualization
  let sorting = false;

  function generateArray(size) {
    array = [];
    for (let i = 0; i < size; i++) {
      array.push(Math.floor(Math.random() * 90) + 10); // values between 10 and 99
    }
    renderArray(array);
    actions = [];
    sorting = false;
    startBtn.disabled = false;
  }

  function renderArray(arr, highlightIndices = {}, swapIndices = []) {
    // highlightIndices: {selected: idx, min: idx}
    // swapIndices: [idx1, idx2]
    arrayContainer.innerHTML = '';
    const maxVal = Math.max(...arr);
    arr.forEach((val, idx) => {
      const bar = document.createElement('div');
      bar.classList.add('bar');
      bar.style.height = (val / maxVal) * 180 + 20 + 'px';
      bar.textContent = val;
      if (highlightIndices.selected === idx) {
        bar.classList.add('selected');
      }
      if (highlightIndices.min === idx) {
        bar.classList.add('min');
      }
      if (swapIndices.includes(idx)) {
        bar.classList.add('swapping');
      }
      arrayContainer.appendChild(bar);
    });
  }

  function selectionSort(arr) {
    const steps = [];
    let a = arr.slice();
    let n = a.length;
    for (let i = 0; i < n - 1; i++) {
      let minIdx = i;
      // Highlight the current "starting" index
      steps.push({ arr: a.slice(), selected: i, min: minIdx, swap: [] });
      for (let j = i + 1; j < n; j++) {
        // Highlight the element being compared
        steps.push({ arr: a.slice(), selected: j, min: minIdx, swap: [] });
        if (a[j] < a[minIdx]) {
          minIdx = j;
          // Highlight the new min
          steps.push({ arr: a.slice(), selected: j, min: minIdx, swap: [] });
        }
      }
      if (minIdx !== i) {
        // Indicate swap
        let newArr = a.slice();
        [newArr[i], newArr[minIdx]] = [newArr[minIdx], newArr[i]];
        steps.push({ arr: a.slice(), selected: i, min: minIdx, swap: [i, minIdx] });
        a = newArr;
        steps.push({ arr: a.slice(), selected: i+1, min: null, swap: [] });
      } else {
        // No swap needed just move on
        steps.push({ arr: a.slice(), selected: i+1, min: null, swap: [] });
      }
    }
    // Final sorted state
    steps.push({ arr: a.slice(), selected: null, min: null, swap: [] });
    return steps;
  }

  async function animateSorting(steps) {
    sorting = true;
    startBtn.disabled = true;
    generateBtn.disabled = true;
    arraySizeInput.disabled = true;
    for (const step of steps) {
      renderArray(step.arr, { selected: step.selected, min: step.min }, step.swap);
      await new Promise((r) => setTimeout(r, 600));
    }
    sorting = false;
    startBtn.disabled = false;
    generateBtn.disabled = false;
    arraySizeInput.disabled = false;
  }

  generateBtn.addEventListener('click', () => {
    if (sorting) return;
    const size = parseInt(arraySizeInput.value);
    if (isNaN(size) || size < 5 || size > 30) {
      alert('Please enter a size between 5 and 30');
      return;
    }
    generateArray(size);
  });

  startBtn.addEventListener('click', () => {
    if (sorting) return;
    if (array.length === 0) {
      alert('Generate an array first.');
      return;
    }
    actions = selectionSort(array);
    animateSorting(actions);
  });

  window.onload = () => {
    generateArray(parseInt(arraySizeInput.value));
  };
</script>
</body>
</html>