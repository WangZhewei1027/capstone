<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Union-Find (Disjoint Set) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#22c1c3;
      --muted:#94a3b8;
      --card:#071327;
      --white:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      background:linear-gradient(180deg,#071428 0%, #041022 60%);
      color:var(--white);
      display:flex;
      gap:12px;
      padding:12px;
      box-sizing:border-box;
      align-items:flex-start;
      justify-content:center;
    }
    .container{
      width:1200px;
      max-width:calc(100vw - 24px);
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:12px;
      align-items:start;
    }
    .canvas-card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(8,16,28,0.1));
      border-radius:10px;
      padding:12px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    canvas{background:transparent;display:block;border-radius:8px;touch-action:none;}
    .controls{
      display:flex;flex-direction:column;gap:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(8,12,20,0.06));
      padding:12px;border-radius:10px;
    }
    .row{display:flex;gap:8px;align-items:center;}
    label{font-size:13px;color:var(--muted);min-width:110px;}
    input[type=number], select, button{
      background:#0b1725;border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:6px 8px;border-radius:6px;font-size:13px;
    }
    button{cursor:pointer}
    .small{font-size:12px;color:var(--muted)}
    .info{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);
      font-size:13px;color:var(--muted);
      overflow:auto;max-height:320px;
    }
    .arrays{
      display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;
    }
    .array{
      background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);
      min-width:160px;
    }
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .dot{width:18px;height:12px;border-radius:4px;}
    .btn-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .oplog{background:#02121b;padding:8px;border-radius:6px;color:var(--muted);font-size:13px;max-height:160px;overflow:auto;}
    .hint{font-size:12px;color:var(--muted)}
    .selected{outline:2px solid rgba(34,193,195,0.25);box-shadow:0 6px 18px rgba(34,193,195,0.06)}
    .footer-note{font-size:12px;color:var(--muted);margin-top:6px;}
    .big{
      font-size:15px;color:var(--white);font-weight:600;
    }
    .toggle{display:flex;gap:6px;align-items:center}
    input[type=checkbox]{width:16px;height:16px}
    .controls hr{border:0;border-top:1px solid rgba(255,255,255,0.04);margin:6px 0}
    .link{color:var(--accent);text-decoration:none}
    .button-primary{background:linear-gradient(90deg,#22c1c3,#4ecdc4);color:#022; border:none}
    .button-danger{background:linear-gradient(90deg,#ff6b6b,#ff8a8a);color:#060;border:none}
    .muted-box{background:rgba(255,255,255,0.01);padding:6px;border-radius:6px}
  </style>
</head>
<body>
<div class="container">
  <div class="canvas-card">
    <div style="display:flex;gap:12px;align-items:center;margin-bottom:6px">
      <div style="flex:1">
        <div class="big">Union-Find (Disjoint Set) Visualizer</div>
        <div class="hint">Click two nodes to perform union. Click a node to highlight its find path. Use options to toggle union-by-rank/size and animated path compression.</div>
      </div>
      <div style="text-align:right">
        <div class="small">Sets: <span id="compCount">-</span></div>
        <div class="small">Nodes: <span id="nodeCount">-</span></div>
      </div>
    </div>
    <canvas id="canvas" width="820" height="620"></canvas>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div class="hint">Tip: use "Random unions" to create merges quickly. Check "Animate compression" to see path compression.</div>
      <div><button id="helpBtn">Show Pseudocode</button></div>
    </div>
    <div id="pseudocode" class="muted-box" style="margin-top:8px;display:none">
      <pre style="margin:0;font-size:13px;color:var(--muted)">
Classic DSU (Union-Find):

make_set(n):
  for i in 0..n-1:
    parent[i] = i
    rank[i] = 0

find(x):
  if parent[x] != x:
    parent[x] = find(parent[x])   // path compression
  return parent[x]

union(a,b):
  ra = find(a); rb = find(b)
  if ra == rb: return
  if rank[ra] < rank[rb]: swap(ra,rb)
  parent[rb] = ra
  if rank[ra] == rank[rb]: rank[ra]++
      </pre>
    </div>
  </div>

  <div class="controls">
    <div class="row">
      <label>Nodes (n)</label>
      <input id="nInput" type="number" min="2" max="40" value="10" />
      <button id="resetBtn" class="button-primary">New</button>
      <button id="clearBtn">Reset</button>
    </div>

    <div class="row">
      <label>Mode</label>
      <select id="modeSelect">
        <option value="union">Union (click two nodes)</option>
        <option value="find">Find (click node)</option>
      </select>
      <label style="min-width:70px">Auto</label>
      <input id="autoCheck" type="checkbox" title="Auto-run unions" />
    </div>

    <div class="row">
      <label>Union rule</label>
      <select id="unionRule">
        <option value="rank">Union-by-rank</option>
        <option value="size">Union-by-size</option>
        <option value="none">No heuristic</option>
      </select>
      <label style="min-width:70px">Animate compression</label>
      <input id="compressAnim" type="checkbox" checked />
    </div>

    <div class="row">
      <label>Random unions</label>
      <input id="randCount" type="number" min="1" max="100" value="5" style="width:80px" />
      <button id="randBtn">Random unions</button>
    </div>

    <div style="display:flex;gap:8px">
      <button id="undoBtn">Undo last union</button>
      <button id="historyClear">Clear log</button>
    </div>

    <hr />

    <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div class="small">Parent / Rank / Size arrays</div>
      <div class="small">Click a node visual => highlight its path</div>
    </div>

    <div class="arrays">
      <div class="array">
        <div style="font-weight:600">Parent</div>
        <div id="parentArray" class="small"></div>
      </div>
      <div class="array">
        <div style="font-weight:600">Rank</div>
        <div id="rankArray" class="small"></div>
      </div>
      <div class="array">
        <div style="font-weight:600">Size</div>
        <div id="sizeArray" class="small"></div>
      </div>
    </div>

    <div style="margin-top:8px">
      <div style="font-weight:600;margin-bottom:6px">Operation Log</div>
      <div class="oplog" id="oplog"></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="stepUnions">Step unions (auto-generated)</button>
      <button id="stopAuto" class="button-danger">Stop</button>
    </div>

    <div class="footer-note">
      Built to teach how union-by-rank/size and path compression affect trees. Colors show connected components.
    </div>
  </div>
</div>

<script>
(() => {
  // Helpers
  function $(id){return document.getElementById(id);}
  function sleep(ms){return new Promise(res=>setTimeout(res,ms));}

  // Color palette
  const COLORS = [
    '#ef476f','#ffd166','#06d6a0','#118ab2','#ff6b6b','#9b5de5','#00b4d8','#8ecae6',
    '#f94144','#f8961e','#43aa8b','#577590','#7209b7','#f72585','#4cc9f0','#a8dadc'
  ];

  // Canvas & drawing
  const canvas = $('canvas');
  const ctx = canvas.getContext('2d');
  let width = canvas.width, height = canvas.height;
  function resizeCanvas(w,h){width=w;height=h;canvas.width=w;canvas.height=h;draw();}
  window.addEventListener('resize', ()=> {
    // No auto resize; keep static for predictability
  });

  // DSU Implementation with history for undo
  class DSU {
    constructor(n){
      this.n = n;
      this.parent = new Array(n);
      this.rank = new Array(n);
      this.size = new Array(n);
      this.init();
      this.history = []; // stack of operations for undo
    }
    init(){
      for(let i=0;i<this.n;i++){ this.parent[i]=i; this.rank[i]=0; this.size[i]=1; }
      this.history = [];
    }
    find(x){
      // non-animated find (recursive)
      if(this.parent[x] === x) return x;
      this.parent[x] = this.find(this.parent[x]);
      return this.parent[x];
    }
    // find path (non-compress) return path up to root
    pathToRoot(x){
      const p = [];
      let cur = x;
      while(true){
        p.push(cur);
        if(this.parent[cur] === cur) break;
        cur = this.parent[cur];
      }
      return p;
    }
    union(a,b,rule='rank'){
      const ra = this.find(a);
      const rb = this.find(b);
      if(ra === rb){
        this.history.push({type:'noop', a,b});
        return {merged:false, ra, rb};
      }
      // save snapshot for undo
      const snapshot = {type:'union', parent: this.parent.slice(), rank:this.rank.slice(), size:this.size.slice(), a,b};
      this.history.push(snapshot);

      if(rule === 'size'){
        if(this.size[ra] < this.size[rb]) [ra,rb] = [rb,ra];
        this.parent[rb] = ra;
        this.size[ra] += this.size[rb];
      } else if(rule === 'rank'){
        if(this.rank[ra] < this.rank[rb]) [ra,rb] = [rb,ra];
        this.parent[rb] = ra;
        if(this.rank[ra] === this.rank[rb]) this.rank[ra]++;
        this.size[ra] = this.size[ra] + this.size[rb];
      } else {
        // no heuristic: attach rb to ra
        this.parent[rb] = ra;
        this.size[ra] += this.size[rb];
      }
      return {merged:true, ra, rb};
    }
    undo(){
      if(this.history.length === 0) return false;
      const last = this.history.pop();
      if(last.type === 'union'){
        this.parent = last.parent;
        this.rank = last.rank;
        this.size = last.size;
        return true;
      } else {
        // noop
        return true;
      }
    }
    components(){
      const comps = new Map();
      for(let i=0;i<this.n;i++){
        const r = this.find(i);
        if(!comps.has(r)) comps.set(r, []);
        comps.get(r).push(i);
      }
      return comps;
    }
  }

  // Visualization state
  let n = parseInt($('nInput').value,10) || 10;
  let dsu = new DSU(n);
  let positions = []; // {x,y}
  let selected = []; // selected nodes for union
  let animating = false;
  let autoRunning = false;
  let stepRunning = false;

  function generatePositions(n){
    positions = [];
    const cx = width/2, cy = height/2;
    const r = Math.min(width, height) * 0.36;
    for(let i=0;i<n;i++){
      const ang = (i / n) * Math.PI * 2 - Math.PI/2;
      const radius = r * (0.7 + 0.3 * Math.sin(i*1.3)); // small variance
      const x = cx + radius * Math.cos(ang);
      const y = cy + radius * Math.sin(ang);
      positions.push({x,y});
    }
  }

  function componentColorMap(){
    const comps = dsu.components();
    const map = new Map();
    let idx = 0;
    for(const root of comps.keys()){
      map.set(root, COLORS[idx % COLORS.length]);
      idx++;
    }
    return map;
  }

  function draw(){
    ctx.clearRect(0,0,width,height);
    // background subtle circle
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.01)';
    ctx.beginPath();
    ctx.ellipse(width/2, height/2, width*0.46, height*0.46, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    const cmap = componentColorMap();

    // Draw parent arrows first (lines from node -> parent)
    ctx.lineWidth = 2;
    for(let i=0;i<n;i++){
      const p = positions[i];
      const par = dsu.parent[i];
      if(par === i) continue;
      const q = positions[par];

      const color = cmap.get(dsu.find(i)) || '#888';
      // Draw curved arrow
      const midx = (p.x + q.x)/2;
      const midy = (p.y + q.y)/2;
      const dx = q.x - p.x, dy = q.y - p.y;
      const len = Math.hypot(dx,dy);
      const ux = dx / len, uy = dy / len;
      // offset for curvature
      const curve = Math.min(60, Math.max(12, len * 0.18));
      const nx = -uy, ny = ux; // normal
      const cx1 = midx + nx * curve;
      const cy1 = midy + ny * curve;

      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.moveTo(p.x, p.y);
      // quadratic curve to parent
      ctx.quadraticCurveTo(cx1, cy1, q.x, q.y);
      ctx.stroke();
      // arrowhead at parent
      const arrowLen = 10;
      const t = 0.98;
      // compute point near end and derivative
      const ex = (1-t) * ((1-t) * p.x + t * cx1) + t * ((1-t) * cx1 + t * q.x);
      const ey = (1-t) * ((1-t) * p.y + t * cy1) + t * ((1-t) * cy1 + t * q.y);
      // derivative approximation
      const dxdyx = q.x - p.x + 0; // rough
      const dxdyy = q.y - p.y + 0;
      // But better: tangent of quadratic at t
      const tx = 2*(1-t)*(cx1 - p.x) + 2*t*(q.x - cx1);
      const ty = 2*(1-t)*(cy1 - p.y) + 2*t*(q.y - cy1);
      const ang = Math.atan2(ty, tx);
      ctx.save();
      ctx.translate(ex, ey);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(-arrowLen, arrowLen/3);
      ctx.lineTo(-arrowLen, -arrowLen/3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // Draw nodes
    for(let i=0;i<n;i++){
      const p = positions[i];
      const root = dsu.find(i);
      const color = cmap.get(root) || '#888';
      const isRoot = (dsu.parent[i] === i);
      const size = isRoot ? 22 : 18;
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.14;
      ctx.ellipse(p.x, p.y, size+8, size+8, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.beginPath();
      ctx.fillStyle = '#06202b';
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.ellipse(p.x, p.y, size, size, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // highlight if selected
      if(selected.includes(i)){
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(34,193,195,0.9)';
        ctx.lineWidth = 3;
        ctx.ellipse(p.x, p.y, size+6, size+6, 0, 0, Math.PI*2);
        ctx.stroke();
      }

      // text
      ctx.fillStyle = '#cfe9f2';
      ctx.font = 'bold 12px Inter, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(i.toString(), p.x, p.y);
      // small parent index
      ctx.font = '11px Inter, Arial';
      ctx.fillStyle = '#9fb6c4';
      ctx.fillText('p:'+dsu.parent[i], p.x, p.y+16);
    }
  }

  // UI updates
  function updateArrays(){
    $('parentArray').textContent = dsu.parent.map((v,i)=>`${i}:${v}`).join('  ');
    $('rankArray').textContent = dsu.rank.map((v,i)=>`${i}:${v}`).join('  ');
    $('sizeArray').textContent = dsu.size.map((v,i)=>`${i}:${v}`).join('  ');
    $('compCount').textContent = dsu.components().size;
    $('nodeCount').textContent = dsu.n;
  }

  function logOp(msg){
    const el = $('oplog');
    const p = document.createElement('div');
    p.textContent = msg;
    el.prepend(p);
  }

  // Interaction handlers
  function canvasPos(evt){
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    return {x,y};
  }

  function findNodeAt(x,y){
    for(let i=0;i<n;i++){
      const p = positions[i];
      const dx = x - p.x, dy = y - p.y;
      const dist = Math.hypot(dx,dy);
      const size = (dsu.parent[i]===i) ? 22 : 18;
      if(dist <= size+10) return i;
    }
    return -1;
  }

  canvas.addEventListener('pointerdown', async (evt) => {
    if(animating) return;
    const pos = canvasPos(evt);
    const node = findNodeAt(pos.x,pos.y);
    if(node === -1) return;

    const mode = $('modeSelect').value;
    if(mode === 'union'){
      if(!selected.includes(node)){
        selected.push(node);
        if(selected.length > 2) selected.shift();
      } else {
        // deselect if clicked again
        selected = selected.filter(x => x!==node);
      }
      draw();
      if(selected.length === 2){
        // perform union
        const a = selected[0], b = selected[1];
        const rule = $('unionRule').value;
        animating = true;
        await animateUnion(a,b,rule);
        animating = false;
        selected = [];
        updateArrays();
      }
    } else {
      // find mode: highlight path, then optionally animate compression
      const xnode = node;
      const path = dsu.pathToRoot(xnode);
      await highlightPath(path);
      const compressAnim = $('compressAnim').checked;
      if(compressAnim){
        animating = true;
        await animateCompression(path);
        animating = false;
        updateArrays();
      }
    }
  });

  async function animateUnion(a,b,rule){
    logOp(`Union request: ${a} ⨯ ${b} (rule=${rule})`);
    // show temporary highlighting and animate path to roots
    const pa = dsu.pathToRoot(a);
    const pb = dsu.pathToRoot(b);
    await highlightPath(pa, 'a');
    await highlightPath(pb, 'b');
    // wait a bit
    await sleep(300);
    // perform union in DSU
    const res = dsu.union(a,b,rule);
    if(!res.merged){
      logOp(`Already connected (root ${res.ra}).`);
      await sleep(300);
      draw();
      return;
    }
    logOp(`Merged root ${res.rb} -> ${res.ra}`);
    // animate attachment: move small pulse along arrow
    await animateAttach(res.rb, res.ra);
    draw();
  }

  async function animateAttach(child, parent){
    // draw a moving dot along quadratic curve from child -> parent
    const p = positions[child], q = positions[parent];
    const midx = (p.x + q.x)/2;
    const midy = (p.y + q.y)/2;
    const dx = q.x - p.x, dy = q.y - p.y;
    const len = Math.hypot(dx,dy);
    const ux = dx / len, uy = dy / len;
    const curve = Math.min(60, Math.max(12, len * 0.18));
    const nx = -uy, ny = ux;
    const cx1 = midx + nx * curve;
    const cy1 = midy + ny * curve;
    const steps = 30;
    for(let t=0;t<=steps;t++){
      const tt = t/steps;
      // point on quadratic Bézier
      const x = (1-tt)*(1-tt)*p.x + 2*(1-tt)*tt*cx1 + tt*tt*q.x;
      const y = (1-tt)*(1-tt)*p.y + 2*(1-tt)*tt*cy1 + tt*tt*q.y;
      draw();
      // draw moving circle
      ctx.beginPath();
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.95;
      ctx.ellipse(x,y,6,6,0,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1.0;
      await sleep(10);
    }
    await sleep(120);
  }

  async function highlightPath(path, tag){
    // animate highlighting nodes in path
    for(let i=0;i<path.length;i++){
      const node = path[i];
      selected = [node];
      draw();
      // overlay highlight circle
      const p = positions[node];
      ctx.beginPath();
      ctx.strokeStyle = (tag==='a') ? '#ffd166' : (tag==='b' ? '#06d6a0' : '#4ecdc4');
      ctx.lineWidth = 3;
      ctx.ellipse(p.x, p.y, 28, 28, 0, 0, Math.PI*2);
      ctx.stroke();
      await sleep(160);
    }
    selected = [];
    draw();
  }

  async function animateCompression(path){
    // Path is from node up to root: we will compress by setting each parent to root step-by-step
    if(path.length <= 1) return;
    const root = path[path.length-1];
    logOp(`Path compression towards root ${root}`);
    for(let i=0;i<path.length-1;i++){
      const node = path[i];
      // animate re-parenting to root
      await animateAttach(node, root);
      dsu.parent[node] = root;
      dsu.size[root] += dsu.size[node];
      draw();
      await sleep(120);
    }
  }

  // Buttons & controls
  $('resetBtn').addEventListener('click', () => {
    if(animating) return;
    const val = parseInt($('nInput').value,10);
    if(isNaN(val) || val < 2 || val > 40) { alert('n must be 2..40'); return; }
    n = val;
    dsu = new DSU(n);
    generatePositions(n);
    updateArrays();
    $('oplog').textContent = '';
    draw();
  });

  $('clearBtn').addEventListener('click', () => {
    if(animating) return;
    dsu = new DSU(n);
    selected = [];
    $('oplog').textContent = '';
    updateArrays();
    draw();
  });

  $('randBtn').addEventListener('click', async () => {
    if(animating) return;
    const count = parseInt($('randCount').value,10) || 5;
    if(count <= 0) return;
    animating = true;
    for(let i=0;i<count;i++){
      const a = Math.floor(Math.random()*n);
      const b = Math.floor(Math.random()*n);
      await animateUnion(a,b,$('unionRule').value);
      updateArrays();
      await sleep(200);
    }
    animating = false;
  });

  $('undoBtn').addEventListener('click', () => {
    if(animating) return;
    const ok = dsu.undo();
    if(ok){
      logOp('Undo last union');
      updateArrays();
      draw();
    } else {
      logOp('Nothing to undo');
    }
  });

  $('historyClear').addEventListener('click', ()=> $('oplog').textContent='');

  $('helpBtn').addEventListener('click', ()=>{
    const el = $('pseudocode');
    el.style.display = (el.style.display === 'none') ? 'block' : 'none';
  });

  // Step unions auto-run generator
  $('stepUnions').addEventListener('click', async () => {
    if(stepRunning) return;
    stepRunning = true;
    logOp('Starting step-run: will attempt N-1 unions to connect graph.');
    const needed = n - dsu.components().size;
    // We'll try random pairs until components unify or until limit
    let attempts = 0, maxAttempts = n*8;
    while(stepRunning && dsu.components().size > 1 && attempts < maxAttempts){
      const a = Math.floor(Math.random()*n);
      const b = Math.floor(Math.random()*n);
      if(dsu.find(a) === dsu.find(b)){ attempts++; continue; }
      animating = true;
      await animateUnion(a,b,$('unionRule').value);
      animating = false;
      updateArrays();
      attempts++;
      await sleep(200);
    }
    logOp('Step-run ended.');
    stepRunning = false;
  });

  $('stopAuto').addEventListener('click', ()=>{
    stepRunning = false;
    autoRunning = false;
    animating = false;
  });

  // Initial setup
  function init(){
    width = canvas.width;
    height = canvas.height;
    n = parseInt($('nInput').value,10) || 10;
    dsu = new DSU(n);
    generatePositions(n);
    updateArrays();
    draw();
  }

  init();

  // small animation loop to redraw occasionally for crispness
  setInterval(()=>{ draw(); }, 600);

  // Also update arrays periodically (to reflect any quicker changes)
  setInterval(()=>{ updateArrays(); }, 400);

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'u'){ $('modeSelect').value='union'; }
    if(e.key === 'f'){ $('modeSelect').value='find'; }
  });

  // Expose for debugging (console)
  window._dsu_visual = {dsu, draw, positions};

})();
</script>
</body>
</html>