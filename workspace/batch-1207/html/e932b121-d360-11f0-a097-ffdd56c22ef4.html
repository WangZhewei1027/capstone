<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Binary Tree (BST) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#f7fbff;
      --panel:#ffffff;
      --accent:#2b6cb0;
      --accent-2:#225e9c;
      --muted:#6b7280;
      --green:#16a34a;
      --danger:#ef4444;
      --node:#eaf2ff;
      --node-border:#2b6cb0;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#e6f0ff);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a}
    .app{
      max-width:1100px;margin:24px auto;padding:18px;background:var(--panel);box-shadow:0 6px 30px rgba(15,23,42,0.08);border-radius:12px;
      display:grid;grid-template-columns:360px 1fr;gap:18px;
    }
    header{grid-column:1/-1;display:flex;align-items:center;gap:12px}
    h1{font-size:20px;margin:0}
    p.subtitle{margin:0;color:var(--muted);font-size:13px}
    .controls{
      padding:12px;border-radius:8px;background:linear-gradient(180deg,#ffffff,#f8fbff);box-shadow:inset 0 1px rgba(255,255,255,0.6);
    }
    label{display:block;font-size:13px;margin:8px 0 6px;color:var(--muted)}
    input[type="number"],input[type="text"],select{
      width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;
    }
    .row{display:flex;gap:8px}
    button{appearance:none;border:0;background:var(--accent);color:white;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
    button.secondary{background:linear-gradient(180deg,#e6eefc,#dbefff);color:var(--accent-2);border:1px solid rgba(43,108,176,0.08)}
    button.warn{background:var(--danger);}
    button.ghost{background:transparent;color:var(--accent-2);border:1px solid #dbe9ff}
    .small{padding:6px 8px;font-size:13px;border-radius:6px}
    .info{margin-top:10px;padding:10px;border-radius:8px;background:#fbfdff;border:1px solid #eef6ff;font-size:13px;color:#0f172a}
    .canvas-wrap{background:linear-gradient(180deg,#fcfeff,#eef8ff);border-radius:10px;padding:12px;min-height:560px;overflow:auto}
    svg{width:100%;height:680px;display:block}
    .node{cursor:pointer;transition:transform .12s ease}
    .node:hover{transform:scale(1.04)}
    .circle{fill:var(--node);stroke:var(--node-border);stroke-width:2}
    .circle.highlight{fill:gold;stroke:#c47a00}
    .circle.search{fill:#fef3c7;stroke:#f59e0b}
    .circle.visit{fill:#bbf7d0;stroke:#16a34a}
    text{font-weight:700;fill:#0f172a;font-size:12px;text-anchor:middle;dominant-baseline:middle}
    line.edge{stroke:#9fb7d9;stroke-width:2}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend .item{display:flex;align-items:center;gap:6px;font-size:13px}
    .swatch{width:14px;height:14px;border-radius:4px;border:1px solid rgba(0,0,0,0.06)}
    .swatch.visit{background:#bbf7d0;border-color:#16a34a}
    .swatch.search{background:#fef3c7;border-color:#f59e0b}
    .swatch.highlight{background:gold;border-color:#c47a00}
    .stats{margin-top:12px;display:flex;gap:12px;flex-wrap:wrap}
    .stat{background:linear-gradient(180deg,#ffffff,#f7fbff);padding:8px;border-radius:8px;border:1px solid #eff6ff;min-width:120px}
    footer{grid-column:1/-1;margin-top:8px;color:var(--muted);font-size:13px}
    a.link{color:var(--accent-2);text-decoration:none;font-weight:600}
    .traversal-list{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .chip{background:#f1f5f9;padding:6px 8px;border-radius:999px;border:1px solid #e2e8f0;font-weight:600;color:#0f172a}
    .controls .hint{font-size:12px;color:var(--muted);margin-top:6px}
    .badge{background:#eef2ff;color:var(--accent-2);padding:4px 8px;border-radius:999px;font-weight:700;border:1px solid #dbe9ff}
    @media (max-width:920px){
      .app{grid-template-columns:1fr;max-width:720px;padding:12px}
      .canvas-wrap{order:2}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Binary Tree Visualizer">
    <header>
      <div>
        <h1>Binary Tree (BST) Visualizer</h1>
        <p class="subtitle">Interactive demonstration of a Binary Search Tree: insert, delete, search, traversals, and animations.</p>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <span class="badge">BST</span>
        <span style="color:var(--muted);font-size:13px">Nodes are placed by BST rules (value &lt; left, value &gt;= right)</span>
      </div>
    </header>

    <aside class="controls" aria-label="Controls">
      <label for="valueInput">Insert a value (integer)</label>
      <div class="row" style="margin-bottom:8px">
        <input id="valueInput" type="number" placeholder="e.g. 42" />
        <button id="insertBtn" class="small">Insert</button>
        <button id="deleteBtn" class="small ghost">Delete</button>
      </div>
      <div class="row">
        <input id="searchInput" type="number" placeholder="Search value" />
        <button id="searchBtn" class="small secondary">Search</button>
      </div>

      <label style="margin-top:10px">Build / randomize</label>
      <div class="row" style="margin-bottom:8px">
        <input id="bulkInput" type="text" placeholder="Comma-separated e.g. 8,3,10,1,6" />
        <button id="buildBtn" class="small">Build</button>
      </div>
      <div class="row" style="margin-bottom:8px">
        <select id="presetSelect">
          <option value="random">Random 10</option>
          <option value="sorted">Sorted 10</option>
          <option value="balanced">Balanced 15</option>
        </select>
        <button id="presetBtn" class="small">Generate</button>
        <button id="clearBtn" class="small warn">Clear</button>
      </div>

      <label style="margin-top:10px">Traversals & animation</label>
      <div class="row" style="margin-bottom:8px">
        <button id="preBtn" class="small secondary">Preorder</button>
        <button id="inBtn" class="small secondary">Inorder</button>
        <button id="postBtn" class="small secondary">Postorder</button>
        <button id="levelBtn" class="small secondary">Level</button>
      </div>
      <div class="row" style="margin-bottom:6px">
        <label style="display:flex;align-items:center;gap:6px"><input id="animateToggle" type="checkbox" checked/> Animate</label>
        <label style="display:flex;align-items:center;gap:6px"><input id="repeatToggle" type="checkbox"/> Repeat</label>
      </div>
      <div class="hint">Click a node in the visualization to delete it quickly. Duplicate values allowed and go to the right by convention.</div>

      <div class="info" aria-live="polite">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Tree stats</strong>
          <span id="rootValue" style="color:var(--muted)"></span>
        </div>
        <div class="stats">
          <div class="stat"><div style="font-size:12px;color:var(--muted)">Nodes</div><div id="nodeCount" style="font-size:18px;font-weight:800">0</div></div>
          <div class="stat"><div style="font-size:12px;color:var(--muted)">Height</div><div id="heightVal" style="font-size:18px;font-weight:800">0</div></div>
          <div class="stat"><div style="font-size:12px;color:var(--muted)">Last operation</div><div id="lastOp" style="font-size:14px;font-weight:700;color:var(--muted)">—</div></div>
        </div>

        <div style="margin-top:10px">
          <strong>Traversal result</strong>
          <div id="traversalOutput" class="traversal-list" aria-live="polite"></div>
        </div>

        <div class="legend">
          <div class="item"><div class="swatch visit"></div> Visited</div>
          <div class="item"><div class="swatch search"></div> Search result</div>
          <div class="item"><div class="swatch highlight"></div> Currently highlighted</div>
        </div>
      </div>
      <div style="margin-top:8px;font-size:12px;color:var(--muted)">Tip: Use "Build" with comma-separated list to create specific trees. "Balanced" preset builds a balanced BST from sorted unique values for demo.</div>
    </aside>

    <main class="canvas-wrap" id="canvasWrap" aria-label="Tree visualization">
      <svg id="svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMin meet" role="img" aria-label="Binary tree diagram"></svg>
    </main>

    <footer>
      This demo implements a Binary Search Tree (BST) with standard operations and visual traversal. Source: interactive demo — no external libraries.
    </footer>
  </div>

<script>
/*
  Binary Search Tree Visualizer
  - Supports insert, delete, search
  - Traversals: preorder, inorder, postorder, level-order with optional animation
  - Click nodes to delete
  - Visual layout computed via inorder x positions and depth-based y positions
*/

(() => {
  // Utilities
  const $ = sel => document.querySelector(sel);
  const svg = $('#svg');
  const svgNS = "http://www.w3.org/2000/svg";

  // Tree Node definition
  class Node {
    constructor(val) {
      this.val = val;
      this.left = null;
      this.right = null;
      this.id = Node._nextId++;
      // layout
      this.x = 0;
      this.y = 0;
      this.depth = 0;
    }
  }
  Node._nextId = 1;

  // BST operations
  class BST {
    constructor() {
      this.root = null;
    }
    insert(val){
      const n = new Node(val);
      if(!this.root){ this.root = n; return n; }
      let cur = this.root;
      while(true){
        if(val < cur.val){
          if(cur.left){ cur = cur.left; continue; }
          cur.left = n; return n;
        } else {
          if(cur.right){ cur = cur.right; continue; }
          cur.right = n; return n;
        }
      }
    }
    search(val){
      let cur = this.root;
      const path = [];
      while(cur){
        path.push(cur);
        if(val === cur.val) return {found: cur, path};
        cur = (val < cur.val) ? cur.left : cur.right;
      }
      return {found: null, path};
    }
    // delete by value: delete first matching node (standard BST delete)
    delete(val){
      const deleteRec = (node, val) => {
        if(!node) return [null, null];
        if(val < node.val){
          const [newLeft, deleted] = deleteRec(node.left, val);
          node.left = newLeft; return [node, deleted];
        } else if(val > node.val){
          const [newRight, deleted] = deleteRec(node.right, val);
          node.right = newRight; return [node, deleted];
        } else {
          // found this node to delete
          // case 0 or 1 child
          if(!node.left) return [node.right, node];
          if(!node.right) return [node.left, node];
          // two children: replace with inorder successor (min of right subtree)
          let succ = node.right;
          while(succ.left) succ = succ.left;
          const succVal = succ.val;
          // delete successor
          const [newRight, _] = deleteRec(node.right, succVal);
          node.val = succVal;
          node.right = newRight;
          return [node, node];
        }
      };
      const [newRoot, deleted] = deleteRec(this.root, val);
      this.root = newRoot;
      return deleted || null;
    }

    // delete by node id: helpful for clicking
    deleteByNodeId(id){
      // find value at id and delete one occurrence with that value and same id path
      // We'll perform deletion by value but ensure that when multiple equal values exist
      // we can remove the exact node: implement a recursive deletion by id
      const deleteRec = (node, id) => {
        if(!node) return [null, null];
        if(node.id === id){
          // same deletion cases as above
          if(!node.left) return [node.right, node];
          if(!node.right) return [node.left, node];
          // two children: find successor
          let succ = node.right;
          while(succ.left) succ = succ.left;
          const succId = succ.id;
          const succVal = succ.val;
          const [newRight, _] = deleteRec(node.right, succId);
          node.val = succVal;
          node.right = newRight;
          return [node, node];
        } else {
          const [newLeft, deletedLeft] = deleteRec(node.left, id);
          if(deletedLeft) { node.left = newLeft; return [node, deletedLeft]; }
          const [newRight, deletedRight] = deleteRec(node.right, id);
          node.right = newRight; return [node, deletedRight];
        }
      };
      const [newRoot, deleted] = deleteRec(this.root, id);
      this.root = newRoot;
      return deleted || null;
    }

    countNodes(){
      const c = (n) => n ? 1 + c(n.left) + c(n.right) : 0;
      return c(this.root);
    }
    height(){
      const h = (n) => n ? 1 + Math.max(h(n.left), h(n.right)) : 0;
      return h(this.root);
    }

    // traversals
    inorder(){ const out=[]; const f=(n)=>{ if(!n) return; f(n.left); out.push(n); f(n.right); }; f(this.root); return out; }
    preorder(){ const out=[]; const f=(n)=>{ if(!n) return; out.push(n); f(n.left); f(n.right); }; f(this.root); return out; }
    postorder(){ const out=[]; const f=(n)=>{ if(!n) return; f(n.left); f(n.right); out.push(n); }; f(this.root); return out; }
    levelorder(){ const out=[]; if(!this.root) return out; const q=[this.root]; while(q.length){ const n=q.shift(); out.push(n); if(n.left) q.push(n.left); if(n.right) q.push(n.right); } return out; }
  }

  // Visualization and state
  const tree = new BST();

  // DOM references
  const valueInput = $('#valueInput');
  const insertBtn = $('#insertBtn');
  const deleteBtn = $('#deleteBtn');
  const searchInput = $('#searchInput');
  const searchBtn = $('#searchBtn');
  const buildBtn = $('#buildBtn');
  const bulkInput = $('#bulkInput');
  const presetBtn = $('#presetBtn');
  const presetSelect = $('#presetSelect');
  const clearBtn = $('#clearBtn');
  const preBtn = $('#preBtn');
  const inBtn = $('#inBtn');
  const postBtn = $('#postBtn');
  const levelBtn = $('#levelBtn');
  const animateToggle = $('#animateToggle');
  const repeatToggle = $('#repeatToggle');
  const nodeCountEl = $('#nodeCount');
  const heightEl = $('#heightVal');
  const lastOpEl = $('#lastOp');
  const traversalOutput = $('#traversalOutput');
  const rootValueEl = $('#rootValue');

  // Drawing helpers
  const nodeRadius = 22;
  const levelHeight = 90;
  let maxX = 1100;
  let animTimer = null;
  let currentHighlights = new Set();

  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  // Layout: compute x and y positions.
  // We'll assign x by inorder position index * spacing.
  function computeLayout(){
    let idx = 0;
    const spacing = 70;
    const assign = (node, depth) => {
      if(!node) return;
      node.depth = depth;
      assign(node.left, depth+1);
      node.x = 60 + idx * spacing;
      node.y = 40 + depth * levelHeight;
      idx++;
      assign(node.right, depth+1);
    };
    assign(tree.root, 0);
    maxX = Math.max(1100, Math.max(120, idx * spacing + 100));
    // adjust svg viewbox width
    svg.setAttribute('viewBox', `0 0 ${maxX} 700`);
  }

  // Draw edges and nodes
  function draw(){
    clearSVG();
    computeLayout();
    if(!tree.root) return;

    // draw edges recursively
    const edges = [];
    const nodes = [];
    (function collect(n){
      if(!n) return;
      if(n.left) edges.push({from:n,to:n.left});
      if(n.right) edges.push({from:n,to:n.right});
      nodes.push(n);
      collect(n.left); collect(n.right);
    })(tree.root);

    // draw edges first
    edges.forEach(e=>{
      const line = document.createElementNS(svgNS,'line');
      line.setAttribute('x1', e.from.x);
      line.setAttribute('y1', e.from.y + nodeRadius - 6);
      line.setAttribute('x2', e.to.x);
      line.setAttribute('y2', e.to.y - nodeRadius + 6);
      line.setAttribute('class','edge');
      svg.appendChild(line);
    });

    // draw nodes: group for interaction
    nodes.forEach(n=>{
      const g = document.createElementNS(svgNS,'g');
      g.setAttribute('class','node');
      g.setAttribute('data-id', n.id);
      g.setAttribute('transform', `translate(${n.x}, ${n.y})`);
      g.setAttribute('role','button');
      g.setAttribute('tabindex','0');
      // circle
      const c = document.createElementNS(svgNS,'circle');
      c.setAttribute('r', nodeRadius);
      c.setAttribute('class','circle');
      c.setAttribute('fill', 'var(--node)');
      // text
      const t = document.createElementNS(svgNS,'text');
      t.textContent = String(n.val);
      // attach
      g.appendChild(c);
      g.appendChild(t);
      // events
      g.addEventListener('click', (ev)=> {
        ev.stopPropagation();
        const id = Number(g.getAttribute('data-id'));
        const deleted = tree.deleteByNodeId(id);
        if(deleted){
          setLastOp(`Deleted node ${deleted.val}`);
          render();
        }
      });
      g.addEventListener('keydown', (ev)=> {
        if(ev.key === 'Enter' || ev.key === ' ') { g.click(); ev.preventDefault(); }
      });
      svg.appendChild(g);
    });
  }

  // Utility to update stats
  function updateStats(){
    nodeCountEl.textContent = tree.countNodes();
    heightEl.textContent = tree.height();
    rootValueEl.textContent = tree.root ? `root: ${tree.root.val}` : '';
  }

  function setLastOp(s){
    lastOpEl.textContent = s;
  }

  // Clear highlight classes
  function clearHighlights(){
    currentHighlights.clear();
    // remove classes on circles
    svg.querySelectorAll('circle').forEach(c=> {
      c.classList.remove('visit','search','highlight');
      c.style.fill = '';
      c.style.stroke = '';
    });
  }

  // Map node -> SVG element for that node
  function svgElementForNode(node){
    if(!node) return null;
    const g = svg.querySelector(`g.node[data-id="${node.id}"]`);
    return g;
  }

  // Mark node style
  function markNode(node, cls='visit'){
    const g = svgElementForNode(node);
    if(!g) return;
    const c = g.querySelector('circle');
    c.classList.add(cls);
    if(cls === 'visit'){
      c.style.fill = '#bbf7d0';
      c.style.stroke = '#16a34a';
    } else if(cls === 'search'){
      c.style.fill = '#fef3c7';
      c.style.stroke = '#f59e0b';
    } else if(cls === 'highlight'){
      c.style.fill = 'gold';
      c.style.stroke = '#c47a00';
    }
    currentHighlights.add(node.id);
  }

  // Traversal animation manager
  async function animateNodes(nodes, options = {delay:500, markClass:'visit', repeat:false}){
    if(!nodes || nodes.length === 0){
      traversalOutput.innerHTML = '';
      return;
    }
    const delay = options.delay || 500;
    const markClass = options.markClass || 'visit';
    const outValues = [];
    let idx = 0;
    let stopped = false;

    // if not animate, mark all at once
    if(!animateToggle.checked){
      clearHighlights();
      nodes.forEach(n => markNode(n, options.resultClass || 'visit'));
      outValues.push(...nodes.map(n=>n.val));
      updateTraversalOutput(outValues);
      await new Promise(r => setTimeout(r, 100));
      return;
    }

    // animated step
    const step = async () => {
      if(idx >= nodes.length){
        updateTraversalOutput(outValues);
        return;
      }
      const n = nodes[idx++];
      clearHighlights();
      markNode(n, markClass);
      outValues.push(n.val);
      updateTraversalOutput(outValues);
      await new Promise(r => setTimeout(r, delay));
      if(stopped) return;
      if(idx < nodes.length) return step();
      if(repeatToggle.checked && !stopped){
        // small pause then repeat
        await new Promise(r => setTimeout(r, 600));
        idx = 0;
        outValues.length = 0;
        return step();
      }
    };

    await step();
  }

  function updateTraversalOutput(arr){
    traversalOutput.innerHTML = '';
    arr.forEach(v=>{
      const span = document.createElement('div');
      span.className = 'chip';
      span.textContent = v;
      traversalOutput.appendChild(span);
    });
  }

  // Render function: draws and updates stats
  function render(){
    clearHighlights();
    draw();
    updateStats();
  }

  // Wiring up buttons
  insertBtn.addEventListener('click', ()=>{
    const v = Number(valueInput.value);
    if(Number.isNaN(v)){ alert('Please enter a number to insert.'); return; }
    const n = tree.insert(v);
    setLastOp(`Inserted ${v}`);
    valueInput.value = '';
    render();
    // highlight inserted node briefly
    setTimeout(()=>{ clearHighlights(); markNode(n,'highlight'); }, 40);
  });

  deleteBtn.addEventListener('click', ()=>{
    const v = Number(valueInput.value);
    if(Number.isNaN(v)){ alert('Please enter a number to delete.'); return; }
    const deleted = tree.delete(v);
    if(deleted){
      setLastOp(`Deleted ${v}`);
      render();
    } else {
      setLastOp(`Value ${v} not found`);
    }
  });

  searchBtn.addEventListener('click', async ()=>{
    const v = Number(searchInput.value);
    if(Number.isNaN(v)){ alert('Please enter a number to search.'); return; }
    // perform search and animate along path
    const res = tree.search(v);
    clearHighlights();
    const delay = 500;
    for(let i=0;i<res.path.length;i++){
      const node = res.path[i];
      clearHighlights();
      markNode(node,'visit');
      updateTraversalOutput(res.path.slice(0,i+1).map(n=>n.val));
      await new Promise(r=>setTimeout(r, delay));
    }
    if(res.found){
      // mark found differently
      clearHighlights();
      markNode(res.found,'search');
      setLastOp(`Found ${v}`);
    } else {
      setLastOp(`${v} not found`);
    }
  });

  // Bulk build
  buildBtn.addEventListener('click', ()=>{
    const text = bulkInput.value.trim();
    if(!text) { alert('Enter comma separated numbers'); return; }
    const parts = text.split(',').map(s=>s.trim()).filter(s=>s!=='');
    const nums = parts.map(s => Number(s)).filter(n => !Number.isNaN(n));
    if(nums.length === 0){ alert('No valid numbers found'); return; }
    // clear existing tree
    tree.root = null;
    Node._nextId = 1;
    nums.forEach(n => tree.insert(n));
    setLastOp(`Built from list (${nums.length} values)`);
    render();
  });

  presetBtn.addEventListener('click', ()=>{
    const sel = presetSelect.value;
    tree.root = null;
    Node._nextId = 1;
    if(sel === 'random'){
      const arr = Array.from({length:10}, ()=>Math.floor(Math.random()*90)+1);
      arr.forEach(v=>tree.insert(v));
      setLastOp('Generated random tree');
    } else if(sel === 'sorted'){
      const arr = Array.from({length:10}, (_,i)=>i+1);
      arr.forEach(v=>tree.insert(v));
      setLastOp('Generated sorted tree (degenerate)');
    } else if(sel === 'balanced'){
      // create balanced BST from 15 unique sorted numbers
      const arr = Array.from({length:15}, (_,i)=>i+1);
      const insertMiddle = (a) => {
        if(a.length===0) return;
        const mid = Math.floor(a.length/2);
        tree.insert(a[mid]);
        insertMiddle(a.slice(0,mid));
        insertMiddle(a.slice(mid+1));
      };
      insertMiddle(arr);
      setLastOp('Generated balanced tree');
    }
    render();
  });

  clearBtn.addEventListener('click', ()=>{
    tree.root = null;
    Node._nextId = 1;
    clearHighlights();
    traversalOutput.innerHTML = '';
    setLastOp('Cleared tree');
    render();
  });

  // Traversal buttons
  inBtn.addEventListener('click', async ()=>{
    clearHighlights();
    const nodes = tree.inorder();
    setLastOp('Inorder traversal');
    await animateNodes(nodes, {delay:500, markClass:'visit'});
  });
  preBtn.addEventListener('click', async ()=>{
    clearHighlights();
    const nodes = tree.preorder();
    setLastOp('Preorder traversal');
    await animateNodes(nodes, {delay:500, markClass:'visit'});
  });
  postBtn.addEventListener('click', async ()=>{
    clearHighlights();
    const nodes = tree.postorder();
    setLastOp('Postorder traversal');
    await animateNodes(nodes, {delay:500, markClass:'visit'});
  });
  levelBtn.addEventListener('click', async ()=>{
    clearHighlights();
    const nodes = tree.levelorder();
    setLastOp('Level-order traversal');
    await animateNodes(nodes, {delay:500, markClass:'visit'});
  });

  // Click background clears highlights
  $('#canvasWrap').addEventListener('click', ()=>{
    clearHighlights();
    traversalOutput.innerHTML = '';
  });

  // initial demo tree
  (function seedDemo(){
    const demo = [50,30,70,20,40,60,80,10,25,35,45];
    demo.forEach(v => tree.insert(v));
    setLastOp('Initial demo tree');
    render();
  })();

  // Resize handling (keep svg height big enough)
  window.addEventListener('resize', ()=> render());
})();
</script>
</body>
</html>