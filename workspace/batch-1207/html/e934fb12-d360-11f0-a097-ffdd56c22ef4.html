<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>K-Means Clustering — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --muted:#666;
      --accent:#2b7cff;
      --danger:#e05d5d;
      --ok:#3bb273;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#eef2ff 0%, var(--bg) 40%); display:flex; align-items:stretch; padding:20px; box-sizing:border-box;}
    .container{max-width:1200px;margin:auto; width:100%; display:flex; gap:18px;}
    .left{flex:1; background:var(--panel); border-radius:12px; padding:14px; box-shadow:0 6px 18px rgba(20,30,60,0.06);}
    .right{width:320px; background:var(--panel); border-radius:12px; padding:14px; box-shadow:0 6px 18px rgba(20,30,60,0.06); display:flex; flex-direction:column; gap:12px;}
    h1{font-size:18px;margin:0 0 6px 0;}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    canvas{width:100%; height:600px; border-radius:8px; background:linear-gradient(180deg,#ffffff 0%, #fafbff 100%); display:block; box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);}
    .row{display:flex; gap:8px; align-items:center;}
    .controls{display:flex; flex-direction:column; gap:10px;}
    label{font-size:13px;color:#333;}
    input[type="range"]{width:100%;}
    .small{font-size:12px;color:var(--muted);}
    button{background:var(--accent); color:white; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600;}
    button.secondary{background:#f3f6ff; color:#234; font-weight:600; border:1px solid rgba(20,40,100,0.06);}
    button.warn{background:var(--danger);}
    .inline{display:flex; gap:8px; align-items:center;}
    select{padding:8px;border-radius:8px;border:1px solid #e6e9f2;background:white;}
    .stat{background:#f8fafc;border-radius:8px;padding:8px;font-size:13px;color:#222;}
    .muted{color:var(--muted);font-size:13px;}
    .colors-legend{display:flex;flex-wrap:wrap;gap:6px;}
    .legend-item{display:flex;gap:6px;align-items:center;padding:6px;border-radius:6px;background:#fbfcff;border:1px solid #f0f4ff;font-size:12px;}
    .swatch{width:14px;height:14px;border-radius:3px;}
    footer{font-size:12px;color:var(--muted);margin-top:8px;}
    .btn-row{display:flex; gap:8px; flex-wrap:wrap;}
    .linklike{background:none;border:0;color:var(--accent);cursor:pointer;padding:0;font-weight:600;}
    .toggle{display:inline-flex;align-items:center;gap:8px;}
    .note{font-size:12px;color:var(--muted);}
    .center{display:flex;align-items:center;justify-content:center;}
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="K-Means clustering demo">
    <div class="left">
      <h1>K-Means Clustering — Visual Interactive Demo</h1>
      <p class="lead">Generate 2D points, pick K, and watch the algorithm group points into clusters. Try different initialization methods and step through iterations.</p>

      <canvas id="plot" width="900" height="600" title="Click to add points when Add Points mode is on"></canvas>

      <div style="display:flex;justify-content:space-between;gap:12px;margin-top:10px;">
        <div class="muted">Click a point and drag to move it. Toggle "Add Points" to add new points by clicking on the plot.</div>
        <div class="muted">Legend: large squares are centroids; small are data points.</div>
      </div>
    </div>

    <div class="right">
      <div class="controls">
        <div class="row">
          <label for="nPoints">Points</label>
          <div style="flex:1;margin-left:8px;">
            <input id="nPoints" type="range" min="10" max="1000" value="150" />
            <div class="small">Count: <span id="nPointsVal">150</span></div>
          </div>
        </div>

        <div class="row">
          <label for="k">K (clusters)</label>
          <div style="flex:1;margin-left:8px;">
            <input id="k" type="range" min="1" max="12" value="4" />
            <div class="small">K: <span id="kVal">4</span></div>
          </div>
        </div>

        <div class="row">
          <label for="init">Initialization</label>
          <select id="init" style="flex:1;margin-left:8px;">
            <option value="random">Random</option>
            <option value="kmeans++" selected>K-Means++</option>
          </select>
        </div>

        <div class="row">
          <label for="speed">Speed (ms)</label>
          <input id="speed" type="range" min="50" max="1200" value="250" />
          <div class="small">Animation delay: <span id="speedVal">250</span> ms</div>
        </div>

        <div class="btn-row">
          <button id="initBtn" class="secondary">Initialize</button>
          <button id="stepBtn">Step</button>
          <button id="runBtn">Run</button>
          <button id="stopBtn" class="secondary" disabled>Stop</button>
        </div>

        <div class="btn-row" style="margin-top:6px;">
          <button id="randomBtn" class="secondary">Randomize Data</button>
          <button id="clearBtn" class="secondary">Clear Points</button>
          <button id="resetBtn" class="warn">Reset All</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
          <label class="toggle"><input id="addToggle" type="checkbox" /> Add Points</label>
          <label class="toggle"><input id="dragToggle" type="checkbox" checked /> Drag Points</label>
        </div>
      </div>

      <div class="stat">
        <div style="display:flex;justify-content:space-between;">
          <div>Iteration: <strong id="iter">0</strong></div>
          <div>Assignments changed: <strong id="changed">—</strong></div>
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:6px;">
          <div>SSE (sum squared errors): <strong id="sse">—</strong></div>
          <div>Empty clusters: <strong id="empty">0</strong></div>
        </div>
      </div>

      <div class="stat">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>Colors</div>
          <div class="small">Up to 12 colors</div>
        </div>
        <div class="colors-legend" id="legend" style="margin-top:8px;"></div>
      </div>

      <div class="stat" style="font-size:13px;">
        <div><strong>How it works (quick):</strong></div>
        <ol style="padding-left:18px;margin:6px 0 0 0;">
          <li>Initialize K centroids (random or K-Means++).</li>
          <li>Assign each point to nearest centroid.</li>
          <li>Move centroids to the mean of assigned points.</li>
          <li>Repeat until assignments don't change or centroids stabilize.</li>
        </ol>
      </div>

      <footer>
        Tip: Try different K and initialization methods. Use "Step" to see intermediate changes.
      </footer>
    </div>
  </div>

  <script>
  // K-Means Interactive Demo
  (function(){
    // Canvas and UI elements
    const canvas = document.getElementById('plot');
    const ctx = canvas.getContext('2d');
    const nPointsInput = document.getElementById('nPoints');
    const nPointsVal = document.getElementById('nPointsVal');
    const kInput = document.getElementById('k');
    const kVal = document.getElementById('kVal');
    const initSelect = document.getElementById('init');
    const speedInput = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const initBtn = document.getElementById('initBtn');
    const stepBtn = document.getElementById('stepBtn');
    const runBtn = document.getElementById('runBtn');
    const stopBtn = document.getElementById('stopBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resetBtn = document.getElementById('resetBtn');
    const addToggle = document.getElementById('addToggle');
    const dragToggle = document.getElementById('dragToggle');
    const iterElem = document.getElementById('iter');
    const changedElem = document.getElementById('changed');
    const sseElem = document.getElementById('sse');
    const emptyElem = document.getElementById('empty');
    const legend = document.getElementById('legend');

    // State
    let points = []; // {x:0-1,y:0-1,cluster:-1}
    let centroids = []; // {x,y}
    let iteration = 0;
    let intervalId = null;
    let lastAssignments = null;
    let animationDelay = Number(speedInput.value);
    let draggingPoint = null;
    let dragOffset = {x:0,y:0};

    // Colors - up to 12 distinct; for larger K we will generate hues
    const baseColors = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b',
      '#e377c2','#7f7f7f','#bcbd22','#17becf','#393b79','#5254a3'
    ];

    function colorFor(kIndex, K){
      if (kIndex < baseColors.length) return baseColors[kIndex];
      // generate using HSL
      const hue = Math.round((kIndex*360/K) % 360);
      return `hsl(${hue} 70% 45%)`;
    }

    // Canvas coordinate helpers
    const padding = 30;
    function toCanvas(p){
      return {cx: padding + p.x*(canvas.width-2*padding), cy: padding + (1-p.y)*(canvas.height-2*padding)};
    }
    function fromCanvas(cx, cy){
      const x = (cx - padding) / (canvas.width - 2*padding);
      const y = 1 - (cy - padding) / (canvas.height - 2*padding);
      return {x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y))};
    }

    // Utilities
    function rand() { return Math.random(); }
    function randNormal() {
      // Box-Muller
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    // Generate initial clustered data for nicer looking demos
    function generateData(n){
      points = [];
      // Create between 2 and 5 random Gaussian blobs
      const blobs = Math.max(2, Math.min(6, Math.round(Math.sqrt(n)/3)));
      const centers = [];
      for(let i=0;i<blobs;i++){
        centers.push({x: Math.random()*0.8+0.1, y: Math.random()*0.8+0.1, s: 0.03 + Math.random()*0.06});
      }
      for(let i=0;i<n;i++){
        const b = centers[Math.floor(Math.random()*blobs)];
        const x = b.x + randNormal()*b.s;
        const y = b.y + randNormal()*b.s;
        points.push({x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y)), cluster: -1});
      }
      lastAssignments = null;
      iteration = 0;
      updateStats();
      draw();
    }

    // K-Means++ initialization
    function kmeansPlusPlusInit(K){
      centroids = [];
      if (points.length === 0) return;
      // pick first uniformly at random from points
      centroids.push({...points[Math.floor(Math.random()*points.length)]});
      while(centroids.length < K){
        // compute squared distances to nearest centroid for each point
        const d2 = points.map(p => {
          let md2 = Infinity;
          for(const c of centroids){
            const dx = p.x - c.x, dy = p.y - c.y;
            const dist2 = dx*dx + dy*dy;
            if (dist2 < md2) md2 = dist2;
          }
          return md2;
        });
        const sum = d2.reduce((a,b)=>a+b,0);
        if (sum === 0){
          // all points identical; pick random
          centroids.push({...points[Math.floor(Math.random()*points.length)]});
          continue;
        }
        // choose next point weighted by d2
        let r = Math.random()*sum;
        let idx = 0;
        while(r > d2[idx]){ r -= d2[idx]; idx++; if(idx>=d2.length) break; }
        centroids.push({...points[idx]});
      }
    }

    // Random initialization: pick K random positions in unit square
    function randomInit(K){
      centroids = [];
      for(let i=0;i<K;i++){
        centroids.push({x: Math.random(), y: Math.random()});
      }
    }

    // Assign points to nearest centroid; returns count changed
    function assignPoints(){
      if (centroids.length === 0) return 0;
      let changed = 0;
      for(const p of points){
        let best = -1;
        let bestD = Infinity;
        for(let i=0;i<centroids.length;i++){
          const c = centroids[i];
          const dx = p.x - c.x, dy = p.y - c.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestD){ bestD = d2; best = i; }
        }
        if (p.cluster !== best){
          p.cluster = best;
          changed++;
        }
      }
      return changed;
    }

    // Update centroids to means; returns number of empty clusters
    function updateCentroids(){
      const K = centroids.length;
      const sums = Array(K).fill(0).map(()=>({x:0,y:0,count:0}));
      for(const p of points){
        if (p.cluster >=0 && p.cluster < K){
          sums[p.cluster].x += p.x;
          sums[p.cluster].y += p.y;
          sums[p.cluster].count++;
        }
      }
      let empty = 0;
      for(let i=0;i<K;i++){
        if (sums[i].count === 0){
          // empty cluster: reinitialize to random point (strategy)
          centroids[i] = {...points[Math.floor(Math.random()*points.length)] || {x: Math.random(), y: Math.random()}};
          empty++;
        } else {
          centroids[i].x = sums[i].x / sums[i].count;
          centroids[i].y = sums[i].y / sums[i].count;
        }
      }
      return empty;
    }

    function computeSSE(){
      let sse = 0;
      for(const p of points){
        if (p.cluster >= 0 && centroids[p.cluster]){
          const dx = p.x - centroids[p.cluster].x;
          const dy = p.y - centroids[p.cluster].y;
          sse += dx*dx + dy*dy;
        }
      }
      return sse;
    }

    // One K-means iteration: assign then update
    function kmeansStep(){
      if (centroids.length === 0) return {changed:0, empty:0, sse:0};
      const changed = assignPoints();
      const empty = updateCentroids();
      const sse = computeSSE();
      iteration++;
      updateStats(changed, empty, sse);
      return {changed, empty, sse};
    }

    // Run until convergence or maxSteps
    function runUntilConverged(maxSteps=1000){
      if (centroids.length === 0) return;
      let steps = 0;
      while(steps < maxSteps){
        const {changed} = kmeansStep();
        steps++;
        if (changed === 0) break;
      }
    }

    // Draw functions
    function draw(){
      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Background grid
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Draw border/margins
      ctx.strokeStyle = 'rgba(20,30,60,0.04)';
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);

      // Draw points grouped by cluster to color them
      // Draw lines from points to centroid (optional subtle)
      for(const p of points){
        const c = toCanvas(p);
        const color = (p.cluster >= 0 && centroids[p.cluster]) ? colorFor(p.cluster, centroids.length) : '#d6d8e6';
        // optional line to centroid
        if (p.cluster >= 0 && centroids[p.cluster]){
          const cc = toCanvas(centroids[p.cluster]);
          ctx.strokeStyle = hexToRgba(color, 0.06);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(c.cx, c.cy);
          ctx.lineTo(cc.cx, cc.cy);
          ctx.stroke();
        }
        // point
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(c.cx, c.cy, 4, 0, Math.PI*2);
        ctx.fill();
        // outline
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Draw centroids on top
      for(let i=0;i<centroids.length;i++){
        const c = toCanvas(centroids[i]);
        const color = colorFor(i, centroids.length);
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(c.cx, c.cy, 10, 0, Math.PI*2);
        ctx.fill();
        // square inside
        ctx.fillStyle = color;
        roundRect(ctx, c.cx-9, c.cy-9, 18, 18, 4, true, false);
        // border
        ctx.strokeStyle = hexToRgba(color, 0.6);
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      // Axes or border labels
      ctx.fillStyle = '#444';
      ctx.font = '12px sans-serif';
      ctx.fillText('X', canvas.width - 18, canvas.height - 8);
      ctx.fillText('Y', 8, 14);
    }

    // Drawing helpers
    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function hexToRgba(hex, alpha){
      // hex like #rrggbb
      const h = hex.replace('#','');
      const bigint = parseInt(h,16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // UI update functions
    function updateStats(changed = null, empty = null, sse = null){
      iterElem.textContent = iteration;
      changedElem.textContent = (changed === null ? '—' : changed);
      sseElem.textContent = (sse === null ? '—' : sse.toFixed(4));
      emptyElem.textContent = (empty === null ? '—' : empty);
      renderLegend();
    }

    function renderLegend(){
      legend.innerHTML = '';
      const K = centroids.length;
      const counts = Array(K).fill(0);
      for(const p of points) if (p.cluster >=0 && p.cluster < K) counts[p.cluster]++;
      for(let i=0;i<K;i++){
        const item = document.createElement('div');
        item.className = 'legend-item';
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = colorFor(i, K);
        item.appendChild(sw);
        const txt = document.createElement('div');
        txt.textContent = `C${i} (${counts[i]||0})`;
        txt.style.minWidth = '56px';
        txt.style.fontSize = '12px';
        item.appendChild(txt);
        legend.appendChild(item);
      }
    }

    // Control handlers
    nPointsInput.addEventListener('input', () => {
      nPointsVal.textContent = nPointsInput.value;
    });
    kInput.addEventListener('input', () => {
      kVal.textContent = kInput.value;
    });
    speedInput.addEventListener('input', () => {
      speedVal.textContent = speedInput.value;
      animationDelay = Number(speedInput.value);
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = setInterval(stepAndDraw, animationDelay);
      }
    });

    initBtn.addEventListener('click', () => {
      initializeCentroids();
      draw();
    });

    stepBtn.addEventListener('click', () => {
      stepAndDraw();
    });

    runBtn.addEventListener('click', () => {
      if (intervalId) return;
      intervalId = setInterval(stepAndDraw, animationDelay);
      runBtn.disabled = true;
      stopBtn.disabled = false;
    });

    stopBtn.addEventListener('click', () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      runBtn.disabled = false;
      stopBtn.disabled = true;
    });

    randomBtn.addEventListener('click', () => {
      generateData(Number(nPointsInput.value));
      centroids = [];
      iteration = 0;
      updateStats();
    });

    clearBtn.addEventListener('click', () => {
      points = [];
      centroids = [];
      iteration = 0;
      updateStats();
      draw();
    });

    resetBtn.addEventListener('click', () => {
      // Reset everything to defaults
      nPointsInput.value = 150;
      kInput.value = 4;
      speedInput.value = 250;
      initSelect.value = 'kmeans++';
      nPointsVal.textContent = nPointsInput.value;
      kVal.textContent = kInput.value;
      speedVal.textContent = speedInput.value;
      generateData(Number(nPointsInput.value));
      centroids = [];
      iteration = 0;
      updateStats();
      draw();
    });

    // Initialization (centroids)
    function initializeCentroids(){
      const K = Math.max(1, Math.min(points.length || 1, Number(kInput.value)));
      if (initSelect.value === 'kmeans++'){
        kmeansPlusPlusInit(K);
      } else {
        randomInit(K);
      }
      // assign once to start
      lastAssignments = null;
      iteration = 0;
      const changed = assignPoints();
      const empty = updateCentroids();
      const sse = computeSSE();
      updateStats(changed, empty, sse);
      draw();
    }

    // Step and draw: one K-means iteration and redraw
    function stepAndDraw(){
      if (centroids.length === 0){
        initializeCentroids();
        return;
      }
      const {changed, empty, sse} = kmeansStep();
      draw();
      if (changed === 0){
        // converged: stop if running
        if (intervalId){
          clearInterval(intervalId);
          intervalId = null;
          runBtn.disabled = false;
          stopBtn.disabled = true;
        }
      }
    }

    // Mouse interaction: add points, drag points
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
      if (addToggle.checked){
        const p = fromCanvas(cx, cy);
        points.push({x:p.x,y:p.y,cluster:-1});
        draw();
        updateStats();
        return;
      }
      if (dragToggle.checked){
        // find closest point within threshold
        let best = null;
        let bestDist = 12;
        for(const p of points){
          const c = toCanvas(p);
          const dx = c.cx - cx, dy = c.cy - cy;
          const d = Math.sqrt(dx*dx+dy*dy);
          if (d < bestDist){
            bestDist = d;
            best = p;
          }
        }
        if (best){
          draggingPoint = best;
          const cp = toCanvas(best);
          dragOffset.x = cp.cx - cx;
          dragOffset.y = cp.cy - cy;
        }
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!draggingPoint) return;
      const rect = canvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
      const p = fromCanvas(cx + dragOffset.x, cy + dragOffset.y);
      draggingPoint.x = p.x;
      draggingPoint.y = p.y;
      // moving points invalidates clustering assignments
      // optionally, keep cluster but better to set to -1 so next step recomputes
      // we choose to keep cluster but update drawing
      draw();
    });

    window.addEventListener('mouseup', (e) => {
      if (draggingPoint) {
        draggingPoint = null;
      }
    });

    // Double-click to remove nearest point
    canvas.addEventListener('dblclick', (e) => {
      const rect = canvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
      let bestIdx = -1;
      let bestD = 12;
      for(let i=0;i<points.length;i++){
        const p = points[i];
        const c = toCanvas(p);
        const dx = c.cx - cx, dy = c.cy - cy;
        const d = Math.sqrt(dx*dx+dy*dy);
        if (d < bestD){ bestD = d; bestIdx = i; }
      }
      if (bestIdx >= 0) {
        points.splice(bestIdx, 1);
        draw();
        updateStats();
      }
    });

    // Responsive canvas actual pixel ratio
    function fixCanvasSize(){
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * ratio);
      canvas.height = Math.round(rect.height * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
      draw();
    }
    window.addEventListener('resize', fixCanvasSize);

    // Initial setup
    function init(){
      nPointsVal.textContent = nPointsInput.value;
      kVal.textContent = kInput.value;
      speedVal.textContent = speedInput.value;
      animationDelay = Number(speedInput.value);
      generateData(Number(nPointsInput.value));
      renderLegend();
      fixCanvasSize();
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') { e.preventDefault(); stepAndDraw(); }
      if (e.key === 'r') { generateData(Number(nPointsInput.value)); draw(); }
    });

    // Generate a palette legend initially (empty if no centroids)
    function renderInitialLegend(){
      legend.innerHTML = '';
      const K = Number(kInput.value);
      for(let i=0;i<K;i++){
        const item = document.createElement('div');
        item.className = 'legend-item';
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = colorFor(i, K);
        item.appendChild(sw);
        const txt = document.createElement('div');
        txt.textContent = `C${i}`;
        txt.style.fontSize = '12px';
        item.appendChild(txt);
        legend.appendChild(item);
      }
    }

    // Run init
    init();
    renderInitialLegend();

    // Expose some functions for console (debug)
    window._kmeansDemo = {
      points, centroids, step: stepAndDraw, init: initializeCentroids, run: () => {
        if (!intervalId) { intervalId = setInterval(stepAndDraw, animationDelay); runBtn.disabled = true; stopBtn.disabled = false; }
      }, stop: () => { if (intervalId){ clearInterval(intervalId); intervalId=null; runBtn.disabled=false; stopBtn.disabled=true; } }
    };

  })();
  </script>
</body>
</html>