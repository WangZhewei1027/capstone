<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #1a73e8;
        }
        
        .description {
            color: #5f6368;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        
        .controls {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        input {
            padding: 10px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 150px;
        }
        
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #0d62d9;
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .traversal-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .canvas-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: auto;
            max-width: 100%;
        }
        
        #treeCanvas {
            width: 100%;
            height: 400px;
            border: 1px solid #e8eaed;
        }
        
        .operations {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            min-height: 20px;
        }
        
        .success {
            background-color: #e6f4ea;
            color: #137333;
        }
        
        .error {
            background-color: #fce8e6;
            color: #c5221f;
        }
        
        .info {
            background-color: #e8f0fe;
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Binary Search Tree Visualization</h1>
            <div class="description">
                A Binary Search Tree (BST) is a tree data structure in which each node has at most two children, 
                referred to as the left child and the right child. For each node, all elements in the left subtree 
                are less than the node, and all elements in the right subtree are greater than the node.
            </div>
        </header>
        
        <div class="controls">
            <div class="input-group">
                <input type="number" id="nodeValue" placeholder="Enter a number to add">
                <button id="addBtn">Add Node</button>
                <button id="searchBtn">Search Value</button>
                <button id="resetBtn">Reset Tree</button>
            </div>
            
            <div class="traversal-buttons">
                <button id="inorderBtn">In-Order Traversal</button>
                <button id="preorderBtn">Pre-Order Traversal</button>
                <button id="postorderBtn">Post-Order Traversal</button>
                <button id="levelorderBtn">Level-Order Traversal</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="treeCanvas"></canvas>
        </div>
        
        <div class="operations">
            <button id="minBtn">Find Minimum</button>
            <button id="maxBtn">Find Maximum</button>
            <button id="depthBtn">Calculate Depth</button>
        </div>
        
        <div id="status" class="status"></div>
    </div>

    <script>
        // Binary Search Tree implementation
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0; // For visualization
                this.y = 0; // For visualization
            }
        }

        class BinarySearchTree {
            constructor() {
                this.root = null;
            }
            
            // Insert a new value into the BST
            insert(value) {
                const newNode = new TreeNode(value);
                
                if (this.root === null) {
                    this.root = newNode;
                } else {
                    this.insertNode(this.root, newNode);
                }
                
                return true;
            }
            
            insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (node.left === null) {
                        node.left = newNode;
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else {
                    if (node.right === null) {
                        node.right = newNode;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }
            
            // Search for a value in the BST
            search(value) {
                return this.searchNode(this.root, value);
            }
            
            searchNode(node, value) {
                if (node === null) {
                    return false;
                }
                
                if (value < node.value) {
                    return this.searchNode(node.left, value);
                } else if (value > node.value) {
                    return this.searchNode(node.right, value);
                } else {
                    return true;
                }
            }
            
            // Get the minimum value in the BST
            findMin() {
                return this.findMinNode(this.root);
            }
            
            findMinNode(node) {
                if (node.left === null) {
                    return node.value;
                } else {
                    return this.findMinNode(node.left);
                }
            }
            
            // Get the maximum value in the BST
            findMax() {
                return this.findMaxNode(this.root);
            }
            
            findMaxNode(node) {
                if (node.right === null) {
                    return node.value;
                } else {
                    return this.findMaxNode(node.right);
                }
            }
            
            // Get the depth of the tree
            getDepth() {
                return this.calculateDepth(this.root);
            }
            
            calculateDepth(node) {
                if (node === null) {
                    return 0;
                } else {
                    const leftDepth = this.calculateDepth(node.left);
                    const rightDepth = this.calculateDepth(node.right);
                    
                    return Math.max(leftDepth, rightDepth) + 1;
                }
            }
            
            // Tree traversals
            inOrderTraversal(callback) {
                const result = [];
                this.inOrder(this.root, result);
                return result;
            }
            
            inOrder(node, result) {
                if (node !== null) {
                    this.inOrder(node.left, result);
                    result.push(node.value);
                    this.inOrder(node.right, result);
                }
            }
            
            preOrderTraversal(callback) {
                const result = [];
                this.preOrder(this.root, result);
                return result;
            }
            
            preOrder(node, result) {
                if (node !== null) {
                    result.push(node.value);
                    this.preOrder(node.left, result);
                    this.preOrder(node.right, result);
                }
            }
            
            postOrderTraversal(callback) {
                const result = [];
                this.postOrder(this.root, result);
                return result;
            }
            
            postOrder(node, result) {
                if (node !== null) {
                    this.postOrder(node.left, result);
                    this.postOrder(node.right, result);
                    result.push(node.value);
                }
            }
            
            levelOrderTraversal() {
                const result = [];
                if (this.root === null) {
                    return result;
                }
                
                const queue = [this.root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node.value);
                    
                    if (node.left !== null) {
                        queue.push(node.left);
                    }
                    
                    if (node.right !== null) {
                        queue.push(node.right);
                    }
                }
                
                return result;
            }
            
            // Prepare tree for visualization
            prepareForVisualization() {
                if (this.root === null) {
                    return;
                }
                
                // Calculate positions for each node
                const calculatePositions = (node, level, position, minDistance) => {
                    if (node === null) {
                        return;
                    }
                    
                    // Calculate position for left child
                    calculatePositions(node.left, level + 1, position - minDistance/Math.pow(2, level), minDistance);
                    
                    // Set position for current node
                    node.x = position;
                    node.y = level * 80;
                    
                    // Calculate position for right child
                    calculatePositions(node.right, level + 1, position + minDistance/Math.pow(2, level), minDistance);
                };
                
                // Start calculation from root
                calculatePositions(this.root, 0, 450, 450);
            }
            
            // Draw the tree on canvas
            draw(canvas, ctx) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (this.root === null) {
                    return;
                }
                
                // Prepare tree for visualization
                this.prepareForVisualization();
                
                // Draw connections first (so nodes appear on top)
                this.drawConnections(this.root, ctx);
                
                // Then draw nodes
                this.drawNodes(this.root, ctx);
            }
            
            drawConnections(node, ctx) {
                if (node === null) {
                    return;
                }
                
                ctx.strokeStyle = "#5f6368";
                ctx.lineWidth = 2;
                
                if (node.left !== null) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.left.x, node.left.y);
                    ctx.stroke();
                    this.drawConnections(node.left, ctx);
                }
                
                if (node.right !== null) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.right.x, node.right.y);
                    ctx.stroke();
                    this.drawConnections(node.right, ctx);
                }
            }
            
            drawNodes(node, ctx) {
                if (node === null) {
                    return;
                }
                
                // Draw the node
                ctx.fillStyle = "#1a73e8";
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw the value
                ctx.fillStyle = "white";
                ctx.font = "14px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(node.value, node.x, node.y);
                
                // Draw children
                this.drawNodes(node.left, ctx);
                this.drawNodes(node.right, ctx);
            }
        }

        // DOM elements
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const nodeValueInput = document.getElementById('nodeValue');
        const addBtn = document.getElementById('addBtn');
        const searchBtn = document.getElementById('searchBtn');
        const resetBtn = document.getElementById('resetBtn');
        const inorderBtn = document.getElementById('inorderBtn');
        const preorderBtn = document.getElementById('preorderBtn');
        const postorderBtn = document.getElementById('postorderBtn');
        const levelorderBtn = document.getElementById('levelorderBtn');
        const minBtn = document.getElementById('minBtn');
        const maxBtn = document.getElementById('maxBtn');
        const depthBtn = document.getElementById('depthBtn');
        const statusDiv = document.getElementById('status');

        // Initialize BST
        const bst = new BinarySearchTree();

        // Adjust canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            bst.draw(canvas, ctx);
        }

        // Event listeners
        addBtn.addEventListener('click', () => {
            const value = parseInt(nodeValueInput.value);
            if (isNaN(value)) {
                showStatus("Please enter a valid number", "error");
                return;
            }
            
            if (bst.search(value)) {
                showStatus(`Value ${value} already exists in the tree`, "error");
            } else {
                bst.insert(value);
                bst.draw(canvas, ctx);
                showStatus(`Value ${value} added to the tree`, "success");
            }
            
            nodeValueInput.value = "";
            nodeValueInput.focus();
        });

        searchBtn.addEventListener('click', () => {
            const value = parseInt(nodeValueInput.value);
            if (isNaN(value)) {
                showStatus("Please enter a valid number", "error");
                return;
            }
            
            if (bst.search(value)) {
                showStatus(`Value ${value} found in the tree`, "success");
            } else {
                showStatus(`Value ${value} not found in the tree`, "error");
            }
        });

        resetBtn.addEventListener('click', () => {
            bst.root = null;
            bst.draw(canvas, ctx);
            showStatus("Tree has been reset", "info");
        });

        inorderBtn.addEventListener('click', () => {
            const result = bst.inOrderTraversal();
            showStatus(`In-Order Traversal: [${result.join(", ")}]`, "info");
        });

        preorderBtn.addEventListener('click', () => {
            const result = bst.preOrderTraversal();
            showStatus(`Pre-Order Traversal: [${result.join(", ")}]`, "info");
        });

        postorderBtn.addEventListener('click', () => {
            const result = bst.postOrderTraversal();
            showStatus(`Post-Order Traversal: [${result.join(", ")}]`, "info");
        });

        levelorderBtn.addEventListener('click', () => {
            const result = bst.levelOrderTraversal();
            showStatus(`Level-Order Traversal: [${result.join(", ")}]`, "info");
        });

        minBtn.addEventListener('click', () => {
            if (bst.root === null) {
                showStatus("Tree is empty", "error");
            } else {
                const min = bst.findMin();
                showStatus(`Minimum value: ${min}`, "info");
            }
        });

        maxBtn.addEventListener('click', () => {
            if (bst.root === null) {
                showStatus("Tree is empty", "error");
            } else {
                const max = bst.findMax();
                showStatus(`Maximum value: ${max}`, "info");
            }
        });

        depthBtn.addEventListener('click', () => {
            const depth = bst.getDepth();
            showStatus(`Tree depth: ${depth}`, "info");
        });

        // Show status message
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = "status";
            statusDiv.classList.add(type);
            
            // Clear status after 3 seconds
            setTimeout(() => {
                statusDiv.textContent = "";
                statusDiv.className = "status";
            }, 3000);
        }

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Initialize canvas size
        resizeCanvas();
    </script>
</body>
</html>