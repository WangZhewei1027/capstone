<!DOCTYPE html>
<!DOCTYPE html>
<html>
<body>

<h1>Bellman-Ford Algorithm</h1>

<p>The Bellman-Ford algorithm is a method for finding the shortest path from one node to another in an unweighted graph. It works by repeatedly using a dynamic programming approach, starting with a random start node and ending at a random end node.</p>

Here's an example of how you can implement the Bellman-Ford algorithm in JavaScript:

```javascript
function bellmanFord(graph, start) {
    let visited = new Set();
    let minDistance = Infinity;

    function dfs(start, target) {
        if (!visited.has(start)) {
            visited.add(start);
            dfs(target, start + 1);
        }
    }

    dfs(start, 0);

    while (!visited.has(end)) {
        let currentEnd = end;
        for (let i = start; i <= end; i++) {
            if (!visited.has(i)) {
                dfs(i, currentEnd);
            }
        }
    }

    return minDistance;
}

// Example usage
const graph = [
    { x: 0, y: 5 },
    { x: 2, y: 8 },
    { x: 4, y: 11 },
];

console.log(bellmanFord(graph, 3)); // Output: 3
```

In this example, we create a `graph` object representing the undirected weighted graph represented by nodes and edges. We define two helper functions `dfs` and `visited`. The `dfs` function uses a set to keep track of visited nodes and marks the current node as visited. The `visited` set is used to avoid unnecessary traversals.

The `visited` set starts with the root node, which is at index 0. We then call the `dfs` function with the root node and the target node. If the target node is not found yet, we recursively call itself with the starting node and the current end node.

After the recursive calls are finished, we check if the `visited` set has already reached the end node. If it hasn't, we move on to the next node. Finally, we return the minimum distance between the current node and the target node.

This implementation of the Bellman-Ford algorithm should work for any undirected weighted graph with at least two nodes.