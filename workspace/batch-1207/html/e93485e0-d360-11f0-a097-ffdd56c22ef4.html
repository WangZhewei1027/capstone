<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Fibonacci Sequence Explorer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:#111}
    body{margin:16px;background:#f7f9fb}
    header{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    h1{margin:0;font-size:20px}
    .card{background:white;border-radius:8px;padding:12px;box-shadow:0 1px 3px rgba(0,0,0,0.08);margin-top:12px}
    label{display:block;margin:6px 0 4px;font-size:13px;color:#333}
    input[type="number"], select, button, textarea {font: inherit}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:end}
    input[type="number"]{width:120px;padding:6px;border:1px solid #d0d7de;border-radius:6px}
    select{padding:6px;border:1px solid #d0d7de;border-radius:6px}
    button{background:#2563eb;color:white;border:0;padding:8px 12px;border-radius:6px;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    .small-btn{background:#e5e7eb;color:#111;padding:6px 8px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
    .muted{color:#555;font-size:13px}
    textarea{width:100%;height:160px;padding:10px;border-radius:6px;border:1px solid #e6eef8;background:#fcfdff;resize:vertical;font-family:monospace}
    .info{font-size:13px;color:#333;margin-top:8px}
    canvas{width:100%;height:220px;background:white;border-radius:6px;border:1px solid #e6eef8}
    .stats{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
    .stat{background:#f1f5f9;padding:8px;border-radius:6px;font-size:13px}
    .warn{color:#b45309;background:#fff7ed;padding:10px;border-radius:6px;border:1px solid #fef3c7;margin-top:8px}
    footer{margin-top:12px;font-size:12px;color:#555}
    @media(max-width:920px){ .grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>
    <h1>Fibonacci Sequence Explorer</h1>
    <div class="muted">Explore methods, see performance, visualize growth & ratios</div>
  </header>

  <section class="card">
    <div class="controls">
      <div>
        <label for="nInput">n (0 ≤ n ≤ 10000)</label>
        <input id="nInput" type="number" value="100" min="0" max="10000" step="1"/>
      </div>

      <div>
        <label for="methodSelect">Method</label>
        <select id="methodSelect">
          <option value="fast">Fast doubling (O(log n))</option>
          <option value="iter">Iterative (O(n))</option>
          <option value="memo">Memoized recursion (O(n))</option>
          <option value="rec">Naïve recursion (exponential) — small n only</option>
        </select>
      </div>

      <div>
        <label for="modeSelect">Output</label>
        <select id="modeSelect">
          <option value="nth">Show F(n) only</option>
          <option value="seq">Show full sequence up to n</option>
          <option value="animate">Animate sequence on chart</option>
        </select>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="computeBtn">Compute</button>
        <button id="stopBtn" class="small-btn" disabled>Stop</button>
      </div>
    </div>

    <div class="warn" id="warn" style="display:none"></div>

    <div class="grid" style="margin-top:12px">
      <div>
        <div class="card" style="padding:10px">
          <div style="display:flex;gap:8px;align-items:center">
            <div style="flex:1">
              <label>Result</label>
              <textarea id="resultArea" readonly placeholder="Result will appear here..."></textarea>
            </div>
            <div style="width:180px">
              <label>Actions</label>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button id="copyBtn" class="small-btn">Copy</button>
                <button id="downloadBtn" class="small-btn">Download .txt</button>
                <button id="clearBtn" class="small-btn">Clear</button>
              </div>
            </div>
          </div>

          <div class="stats" style="margin-top:12px">
            <div class="stat" id="timeStat">Time: —</div>
            <div class="stat" id="callsStat">Calls (recursions): —</div>
            <div class="stat" id="digitsStat">Digits: —</div>
            <div class="stat" id="ratioStat">Ratio F(n)/F(n-1): —</div>
          </div>

          <div class="info">
            Methods:
            <ul style="margin:6px 0 0 20px">
              <li><b>Fast doubling</b>: uses identities to compute in O(log n) time and is ideal for huge n (BigInt used).</li>
              <li><b>Iterative</b>: simple loop, O(n) time, O(1) memory.</li>
              <li><b>Memoized</b>: recursion with memo, O(n) time and memory.</li>
              <li><b>Naïve recursion</b>: exponential time — for demo only (n ≤ 40 recommended).</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <label>Log / Notes</label>
          <textarea id="logArea" readonly style="height:90px"></textarea>
        </div>
      </div>

      <div>
        <div class="card">
          <label>Growth chart (y = number of digits of F(k))</label>
          <canvas id="chart" width="600" height="220"></canvas>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label style="margin:0">Chart range:</label>
            <input id="chartStart" type="number" value="0" min="0" style="width:80px;padding:6px;border:1px solid #d0d7de;border-radius:6px"/>
            <input id="chartEnd" type="number" value="100" min="0" style="width:80px;padding:6px;border:1px solid #d0d7de;border-radius:6px"/>
            <button id="drawBtn" class="small-btn">Draw</button>
          </div>
          <div class="muted" style="margin-top:8px">Tip: when plotted by digits, exponential growth appears linear.</div>
        </div>

        <div class="card" style="margin-top:12px">
          <label>Quick examples</label>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="small-btn" data-n="0">F(0)</button>
            <button class="small-btn" data-n="1">F(1)</button>
            <button class="small-btn" data-n="2">F(2)</button>
            <button class="small-btn" data-n="10">F(10)</button>
            <button class="small-btn" data-n="50">F(50)</button>
            <button class="small-btn" data-n="500">F(500)</button>
            <button class="small-btn" data-n="1000">F(1000)</button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Notes: BigInt is used for exact integer results. For very large n the output can be extremely large (many KB/MB) — use the fast doubling method and avoid printing the entire sequence unless necessary.
    </footer>
  </section>

<script>
(() => {
  // Helpers and algorithms using BigInt
  const el = id => document.getElementById(id);
  const nInput = el('nInput');
  const methodSelect = el('methodSelect');
  const modeSelect = el('modeSelect');
  const computeBtn = el('computeBtn');
  const stopBtn = el('stopBtn');
  const resultArea = el('resultArea');
  const logArea = el('logArea');
  const copyBtn = el('copyBtn');
  const downloadBtn = el('downloadBtn');
  const clearBtn = el('clearBtn');
  const timeStat = el('timeStat');
  const callsStat = el('callsStat');
  const digitsStat = el('digitsStat');
  const ratioStat = el('ratioStat');
  const warnBox = el('warn');
  const chart = el('chart');
  const drawBtn = el('drawBtn');
  const chartStart = el('chartStart');
  const chartEnd = el('chartEnd');

  let stopRequested = false;

  function log(msg){
    logArea.value = (new Date()).toLocaleTimeString() + " — " + msg + "\n" + logArea.value;
  }

  // Fast doubling (returns [F(n), F(n+1)])
  function fibDoublingPair(n){
    if(n === 0) return [0n, 1n];
    const [a,b] = fibDoublingPair(Math.floor(n/2));
    const c = a * ( (b << 1n) - a ); // c = F(2k)
    const d = a*a + b*b;            // d = F(2k+1)
    if(n % 2 === 0) return [c, d];
    else return [d, c + d];
  }
  function fibFast(n){ return fibDoublingPair(n)[0]; }

  // Iterative
  function fibIter(n){
    if(n === 0) return 0n;
    let a = 0n, b = 1n;
    for(let i = 1; i < n; i++){
      if(stopRequested) throw new Error('stopped');
      const c = a + b;
      a = b; b = c;
    }
    return b;
  }

  // Memoized recursion
  function fibMemo(n, memo = {}){
    if(n in memo) return memo[n];
    if(n < 2) return BigInt(n);
    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
    return memo[n];
  }

  // Naive recursion (with call counting)
  let recCalls = 0;
  function fibRec(n){
    recCalls++;
    if(n < 2) return BigInt(n);
    return fibRec(n-1) + fibRec(n-2);
  }

  // Utility: number of digits of BigInt
  function digitsCount(bn){
    if(bn === 0n) return 1;
    return bn.toString().length;
  }

  // Ratio Fn / F(n-1) with k decimal digits using BigInt scaled division
  function ratioApprox(Fn, Fprev, k = 12){
    if(Fprev === 0n) return '∞';
    const scale = 10n ** BigInt(k);
    const scaled = (Fn * scale) / Fprev; // integer
    const s = scaled.toString().padStart(k+1,'0'); // ensure at least k decimal digits
    const intPart = s.slice(0, -k);
    const frac = s.slice(-k).replace(/0+$/,''); // trim trailing zeros
    return frac ? `${intPart}.${frac}` : intPart;
  }

  // Draw chart plotting digits for F(k) for k from start..end
  function drawChart(values, start=0, end=values.length-1){
    const ctx = chart.getContext('2d');
    const w = chart.width = chart.clientWidth * devicePixelRatio;
    const h = chart.height = chart.clientHeight * devicePixelRatio;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.scale(devicePixelRatio, devicePixelRatio);

    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,chart.clientWidth, chart.clientHeight);

    const pad = 30;
    const W = chart.clientWidth - pad*2;
    const H = chart.clientHeight - pad*2;

    // Subset values
    const subset = values.slice(start, end+1);
    if(subset.length === 0){
      ctx.fillStyle = '#666'; ctx.fillText('No data', pad, pad);
      ctx.restore(); return;
    }
    const xs = subset.map((v,i) => start + i);
    const ys = subset.map(v => v);

    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    // Axes
    ctx.strokeStyle = '#d6e0ef';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, pad + H);
    ctx.lineTo(pad + W, pad + H);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, pad + H);
    ctx.stroke();

    // plot points as polyline
    ctx.beginPath();
    ctx.strokeStyle = '#2563eb';
    ctx.lineWidth = 2;
    for(let i=0;i<subset.length;i++){
      const x = pad + (i/(subset.length-1 || 1)) * W;
      const y = pad + H - ((subset[i]-minY)/(maxY-minY || 1)) * H;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // grid labels
    ctx.fillStyle = '#333'; ctx.font = '12px system-ui, Arial';
    ctx.fillText(`k: ${start} → ${end}`, pad, 16);
    ctx.fillStyle = '#666';
    ctx.fillText(`${minY} digits`, pad, pad + H + 16);
    ctx.fillText(`${maxY} digits`, pad + W - 60, pad + 12);

    ctx.restore();
  }

  // Generate sequence up to n using chosen method (returns array of BigInt)
  function generateSequence(n, method, onProgress=null){
    const arr = [];
    if(method === 'rec'){
      // naive recursion: build by calling fibRec for each k (very slow). limit recommended.
      for(let k=0;k<=n;k++){
        if(stopRequested) throw new Error('stopped');
        recCalls = 0;
        const v = fibRec(k);
        arr.push(v);
        if(onProgress) onProgress(k, v);
      }
      return arr;
    }

    if(method === 'iter'){
      let a = 0n, b = 1n;
      arr.push(0n);
      if(n>=1) arr.push(1n);
      for(let k=2;k<=n;k++){
        if(stopRequested) throw new Error('stopped');
        const c = a + b;
        a = b; b = c;
        arr.push(b);
        if(onProgress) onProgress(k, b);
      }
      return arr;
    }

    if(method === 'memo'){
      const memo = {};
      for(let k=0;k<=n;k++){
        if(stopRequested) throw new Error('stopped');
        const v = fibMemo(k, memo);
        arr.push(v);
        if(onProgress) onProgress(k, v);
      }
      return arr;
    }

    // fast doubling
    for(let k=0;k<=n;k++){
      if(stopRequested) throw new Error('stopped');
      arr.push(fibFast(k));
      if(onProgress) onProgress(k, arr[k]);
    }
    return arr;
  }

  // Core compute handler
  async function compute(){
    stopRequested = false;
    stopBtn.disabled = false;
    computeBtn.disabled = true;
    warnBox.style.display = 'none';
    resultArea.value = '';
    logArea.value = '';
    timeStat.textContent = 'Time: —';
    callsStat.textContent = 'Calls (recursions): —';
    digitsStat.textContent = 'Digits: —';
    ratioStat.textContent = 'Ratio F(n)/F(n-1): —';

    let n = Math.floor(Number(nInput.value));
    if(!Number.isFinite(n) || n < 0) n = 0;
    if(n > 10000){
      warnBox.style.display = 'block';
      warnBox.textContent = 'n capped at 10000 for safety';
      n = 10000;
    }

    const method = methodSelect.value;
    const mode = modeSelect.value;

    // warn for naive recursion
    if(method === 'rec' && n > 40){
      warnBox.style.display = 'block';
      warnBox.textContent = 'Naïve recursion is exponential; limit n ≤ 40 recommended';
      if(!confirm('Compute with naïve recursion? This may take a long time. Cancel to abort.')) {
        computeBtn.disabled = false;
        stopBtn.disabled = true;
        return;
      }
    }

    // mode: animate will stream to chart
    try {
      const t0 = performance.now();
      if(mode === 'nth'){
        // compute single Fn
        let Fn;
        if(method === 'fast'){
          Fn = fibFast(n);
        } else if(method === 'iter'){
          Fn = fibIter(n);
        } else if(method === 'memo'){
          Fn = fibMemo(n, {});
        } else { // rec
          recCalls = 0;
          Fn = fibRec(n);
        }
        const t1 = performance.now();
        resultArea.value = `F(${n}) =\n` + Fn.toString();
        timeStat.textContent = `Time: ${(t1-t0).toFixed(3)} ms`;
        callsStat.textContent = (method === 'rec') ? `Calls: ${recCalls}` : 'Calls: —';
        digitsStat.textContent = `Digits: ${digitsCount(Fn)}`;
        // ratio compute F(n)/F(n-1) if n>=1
        if(n >= 1){
          let Fprev;
          if(method === 'fast') Fprev = fibFast(n-1);
          else if(method === 'iter') {
            Fprev = (n===1) ? 1n : fibIter(n-1);
          } else if(method === 'memo'){
            const memo = {}; Fprev = fibMemo(n-1,memo);
          } else { // rec
            // compute directly (it's fine for small n already)
            Fprev = fibRec(n-1);
          }
          try {
            const ratio = ratioApprox(Fn, Fprev, 18);
            ratioStat.textContent = `Ratio F(n)/F(n-1): ≈ ${ratio}`;
          } catch(e){
            ratioStat.textContent = 'Ratio: too large to compute';
          }
        } else {
          ratioStat.textContent = 'Ratio: —';
        }
        log(`Computed F(${n}) with method ${method}`);
      }
      else if(mode === 'seq'){
        // compute full sequence and display (warning if huge)
        if(n > 3000 && method !== 'fast'){
          if(!confirm('You requested the full sequence up to a large n > 3000 with a non-fast method — this may be slow and memory heavy. Continue?')) {
            computeBtn.disabled = false; stopBtn.disabled = true; return;
          }
        }
        // generate
        stopRequested = false;
        const arr = generateSequence(n, method);
        const t1 = performance.now();
        // join into string
        const lines = arr.map((b,i) => `${i}: ${b.toString()}`);
        resultArea.value = lines.join('\n');
        timeStat.textContent = `Time: ${(t1-t0).toFixed(3)} ms`;
        callsStat.textContent = (method === 'rec') ? `Calls: ${recCalls}` : 'Calls: —';
        digitsStat.textContent = `F(${n}) digits: ${digitsCount(arr[n])}`;
        if(n >= 1) ratioStat.textContent = `Ratio: ≈ ${ratioApprox(arr[n], arr[n-1], 12)}`;
        drawChart(arr.map(x => digitsCount(x)), 0, Math.min(arr.length-1, 200)); // draw first 200 by default
        log(`Generated sequence up to ${n} with method ${method}`);
      }
      else if(mode === 'animate'){
        // animate sequence points on chart progressively
        // limit n for animation
        if(n > 2000){
          if(!confirm('Animating more than 2000 points may freeze the page. Continue?')) {
            computeBtn.disabled = false; stopBtn.disabled = true; return;
          }
        }
        stopRequested = false;
        // compute sequence progressively and draw streaming chart
        const digitsArr = [];
        const valuesPreview = []; // store BigInts for stats
        const ctx = chart.getContext('2d');
        ctx.clearRect(0,0,chart.width,chart.height);
        const maxPoints = n+1;
        // We will draw incrementally: build arr and redraw small canvas each few steps for responsiveness
        const batch = 200;
        let arr = [];
        if(method === 'rec'){
          for(let k=0;k<=n;k++){
            if(stopRequested) throw new Error('stopped');
            recCalls = 0;
            const v = fibRec(k);
            arr.push(v);
            digitsArr.push(digitsCount(v));
            if(k % batch === 0) drawChart(digitsArr, 0, digitsArr.length-1);
            await new Promise(r => setTimeout(r,0)); // allow UI updates
          }
        } else if(method === 'iter'){
          // iterative streaming
          let a = 0n, b = 1n;
          arr.push(0n); digitsArr.push(1);
          if(n>=1){ arr.push(1n); digitsArr.push(1); }
          drawChart(digitsArr,0,digitsArr.length-1);
          for(let k=2;k<=n;k++){
            if(stopRequested) throw new Error('stopped');
            const c = a + b; a = b; b = c;
            arr.push(b); digitsArr.push(digitsCount(b));
            if(k % batch === 0) drawChart(digitsArr, 0, digitsArr.length-1);
            await new Promise(r => setTimeout(r,0));
          }
        } else if(method === 'memo'){
          const memo = {};
          for(let k=0;k<=n;k++){
            if(stopRequested) throw new Error('stopped');
            const v = fibMemo(k, memo);
            arr.push(v); digitsArr.push(digitsCount(v));
            if(k % batch === 0) drawChart(digitsArr, 0, digitsArr.length-1);
            await new Promise(r => setTimeout(r,0));
          }
        } else { // fast
          for(let k=0;k<=n;k++){
            if(stopRequested) throw new Error('stopped');
            const v = fibFast(k);
            arr.push(v); digitsArr.push(digitsCount(v));
            if(k % batch === 0) drawChart(digitsArr, 0, digitsArr.length-1);
            await new Promise(r => setTimeout(r,0));
          }
        }
        // final draw
        drawChart(digitsArr, 0, digitsArr.length-1);
        const t1 = performance.now();
        resultArea.value = `Animated sequence up to ${n}. Last value F(${n}) has ${digitsArr[digitsArr.length-1]} digits.\n\nYou can switch to "Show full sequence" to print them.`;
        timeStat.textContent = `Time: ${(t1-t0).toFixed(3)} ms`;
        callsStat.textContent = (method === 'rec') ? `Calls: ${recCalls}` : 'Calls: —';
        digitsStat.textContent = `F(${n}) digits: ${digitsArr[digitsArr.length-1]}`;
        if(n>=1) ratioStat.textContent = `Ratio: ≈ ${ratioApprox(arr[n], arr[n-1], 12)}`;
        log(`Animated sequence up to ${n} with method ${method}`);
      }
    } catch(e){
      if(e.message === 'stopped') {
        log('Operation stopped by user');
        resultArea.value += '\n\n[Stopped by user]';
      } else {
        console.error(e);
        resultArea.value = 'Error: ' + e.message;
        log('Error: ' + e.message);
      }
    } finally {
      computeBtn.disabled = false;
      stopBtn.disabled = true;
      stopRequested = false;
    }
  }

  computeBtn.addEventListener('click', () => compute());
  stopBtn.addEventListener('click', () => { stopRequested = true; stopBtn.disabled = true; });

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(resultArea.value);
      log('Copied result to clipboard');
    } catch (e) {
      log('Copy failed: ' + e);
    }
  });

  downloadBtn.addEventListener('click', () => {
    const blob = new Blob([resultArea.value], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'fibonacci.txt';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    log('Downloaded result as fibonacci.txt');
  });

  clearBtn.addEventListener('click', () => { resultArea.value=''; log('Cleared result') });

  // Quick example buttons
  document.querySelectorAll('[data-n]').forEach(btn => {
    btn.addEventListener('click', () => {
      nInput.value = btn.getAttribute('data-n');
      methodSelect.value = 'fast';
      modeSelect.value = 'nth';
      computeBtn.click();
    });
  });

  // Chart draw button
  drawBtn.addEventListener('click', async () => {
    const s = Math.max(0, Math.floor(Number(chartStart.value)));
    const e = Math.max(s, Math.floor(Number(chartEnd.value)));
    const maxRange = 5000;
    if(e - s > maxRange){
      if(!confirm(`Drawing more than ${maxRange} points may be slow. Continue?`)) return;
    }
    // compute digits for F(k) for k in [s,e] using fast doubling
    const arrDigits = [];
    try {
      for(let k=s;k<=e;k++){
        if(stopRequested) break;
        const f = fibFast(k);
        arrDigits.push(digitsCount(f));
        if(k % 200 === 0) await new Promise(r=>setTimeout(r,0));
      }
      drawChart(arrDigits, 0, arrDigits.length-1);
      log(`Drew chart digits for k=${s}..${e}`);
    } catch(e){
      log('Chart draw error: ' + e.message);
    }
  });

  // initial sample draw
  (function init(){
    // draw sample Fibonacci digits 0..100
    const sample = [];
    for(let k=0;k<=100;k++) sample.push(digitsCount(fibFast(k)));
    drawChart(sample,0,sample.length-1);
  })();

})();
</script>
</body>
</html>