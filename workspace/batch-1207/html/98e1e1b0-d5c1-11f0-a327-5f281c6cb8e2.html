<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Merge Sort Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#2dd4bf;
    --muted:#94a3b8;
    --bar:#60a5fa;
    --compare:#ef4444;
    --write:#10b981;
    --merge:#f59e0b;
    --sorted:#7c3aed;
  }
  html,body{
    height:100%;
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #001219 0%, #031926 100%);
    color:#e6eef6;
  }
  .wrap{
    max-width:1100px;
    margin:24px auto;
    padding:18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.7);
  }
  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  h1{ margin:0; font-size:20px; letter-spacing:0.2px;}
  .controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  .controls > * { background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.04); padding:8px; border-radius:8px; color:var(--muted); }
  button{
    cursor:pointer;
    color:#e6eef6;
    border:none;
    background:var(--panel);
    padding:8px 12px;
    border-radius:8px;
    transition:transform .06s ease, box-shadow .06s;
  }
  button:active{ transform:translateY(1px); }
  button[disabled]{ opacity:0.4; cursor:not-allowed; }
  .row {
    margin-top:18px;
    display:flex;
    gap:18px;
    align-items:flex-start;
  }
  .left{
    flex:1 1 65%;
    min-height:260px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border-radius:10px;
    padding:12px;
  }
  .right{
    flex:0 0 320px;
    min-height:260px;
    padding:12px;
  }
  #arrayCanvas{
    width:100%;
    height:360px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
    border-radius:8px;
    display:flex;
    align-items:flex-end;
    padding:6px;
    box-sizing:border-box;
    overflow:hidden;
  }
  .bar{
    margin:0 2px;
    background:linear-gradient(180deg, var(--bar), #2b6cb0);
    width:20px;
    border-radius:6px 6px 2px 2px;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    position:relative;
    transition: height 200ms ease, background 120ms ease, transform 120ms ease;
  }
  .bar > span{
    font-size:11px;
    color:rgba(255,255,255,0.92);
    transform:translateY(-6px);
    user-select:none;
  }
  .bar.small > span{ transform:translateY(-6px) scale(0.86); opacity:0.85; }
  .bar.compare{ background:linear-gradient(180deg,var(--compare), #b91c1c); transform:scale(1.03); z-index:2;}
  .bar.write{ background:linear-gradient(180deg,var(--write), #059669); transform:scale(1.03); z-index:2;}
  .bar.mergeRange{ background:linear-gradient(180deg,var(--merge), #b45309); opacity:0.95;}
  .bar.sorted{ background:linear-gradient(180deg,var(--sorted), #4c1d95); }
  .info{
    color:var(--muted);
    font-size:13px;
    line-height:1.4;
  }
  .stat{
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
  }
  input[type=range]{ accent-color:var(--accent); width:140px; }
  label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px;}
  .small-muted{ font-size:12px; color:var(--muted); margin-top:6px;}
  .footer{
    margin-top:16px;
    font-size:13px;
    color:var(--muted);
  }
  .controlsGroup{ display:flex; gap:8px; align-items:center;}
  @media (max-width:880px){
    .row{ flex-direction:column; }
    .right{ flex:1 1 auto; }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Merge Sort — Visualizer & Interactive Demo</h1>
    <div class="controls">
      <div class="controlsGroup">
        <label style="margin:0 6px 0 0; font-size:13px; color:var(--muted)">Array size</label>
        <input id="sizeRange" type="range" min="5" max="80" value="28">
        <span id="sizeLabel" style="min-width:34px; text-align:center; font-size:13px; color:var(--muted)"></span>
      </div>

      <div class="controlsGroup">
        <label style="margin:0 6px 0 0; font-size:13px; color:var(--muted)">Speed</label>
        <input id="speedRange" type="range" min="10" max="1000" value="160">
        <span id="speedLabel" style="min-width:50px; text-align:center; font-size:13px; color:var(--muted)"></span>
      </div>

      <button id="shuffleBtn" title="Generate a new random array">Shuffle</button>
      <button id="startBtn">Start</button>
      <button id="stepBtn">Step</button>
      <button id="pauseBtn" disabled>Pause</button>
    </div>
  </header>

  <div class="row">
    <div class="left">
      <div id="arrayCanvas" aria-hidden="true"></div>
      <div class="stat" id="actionStat"></div>
    </div>
    <div class="right">
      <div class="info">
        <strong>How Merge Sort works (brief):</strong>
        <p style="margin:6px 0 10px 0;">Merge sort is a divide-and-conquer algorithm. It recursively splits the array until subarrays of size 1 are reached, then repeatedly merges pairs of subarrays back together in sorted order. This demo records the key operations (comparisons and overwrites) and replays them visually.</p>

        <div>
          <label>Controls</label>
          <div class="small-muted">
            Shuffle: create a new random array.<br>
            Start: run the full animation. Step: advance one recorded operation. Pause: pause playback.
          </div>
        </div>

        <div style="margin-top:10px;">
          <label>Legend</label>
          <div class="small-muted">
            Colored bars represent current action:
            <div style="margin-top:6px;">
              <span style="display:inline-block;width:12px;height:12px;background:var(--compare);border-radius:2px;margin-right:8px;"></span> comparing
              <span style="display:inline-block;width:12px;height:12px;background:var(--write);border-radius:2px;margin:0 8px 0 18px;"></span> writing/overwrite
              <span style="display:inline-block;width:12px;height:12px;background:var(--merge);border-radius:2px;margin:0 8px 0 18px;"></span> current merge range
              <span style="display:inline-block;width:12px;height:12px;background:var(--sorted);border-radius:2px;margin:0 8px 0 18px;"></span> merged/sorted range
            </div>
          </div>
        </div>

        <div class="footer" style="margin-top:12px;">
          Implementation notes: This visualizer first records the merge sort operations (so stepping/pausing is consistent), then replays them. You may change the array size and speed anytime.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // DOM elements
  const canvas = document.getElementById('arrayCanvas');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const sizeRange = document.getElementById('sizeRange');
  const sizeLabel = document.getElementById('sizeLabel');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const actionStat = document.getElementById('actionStat');

  // State
  let array = [];
  let bars = [];
  let actions = []; // recorded actions
  let actionIndex = 0;
  let playing = false;
  let timer = null;
  let msPerAction = 160;

  // Initialize
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function generateArray(n){
    array = [];
    for(let i=0;i<n;i++) array.push(randInt(10, 500));
    renderArray();
  }

  function renderArray(){
    // Clear
    canvas.innerHTML = '';
    bars = [];
    const n = array.length;
    const canvasHeight = canvas.clientHeight - 8;
    const maxVal = Math.max(...array, 1);
    const barWidth = Math.max(6, Math.floor((canvas.clientWidth - 12) / n) - 4);
    for(let i=0;i<n;i++){
      const val = array[i];
      const bar = document.createElement('div');
      bar.className = 'bar';
      if (barWidth < 18) bar.classList.add('small');
      bar.style.width = barWidth + 'px';
      const height = Math.max(6, Math.round((val / maxVal) * (canvasHeight - 8)));
      bar.style.height = height + 'px';
      const span = document.createElement('span');
      span.textContent = val;
      bar.appendChild(span);
      canvas.appendChild(bar);
      bars.push(bar);
    }
  }

  // Action types:
  // {type:'merge', l, mid, r} - highlight range about to be merged
  // {type:'compare', i, j} - compare indices i and j
  // {type:'overwrite', index:k, value:val} - write value into index k
  // {type:'merged', l, r} - mark range as merged/sorted
  // We'll record a sequence of actions during a merge sort execution on a copy.

  function recordMergeSort(arr){
    actions = [];
    const aCopy = arr.slice();
    function mergeSortRec(a, l, r){
      if (l>=r) return;
      const mid = Math.floor((l+r)/2);
      mergeSortRec(a, l, mid);
      mergeSortRec(a, mid+1, r);
      // record start of merge
      actions.push({type:'merge', l, mid, r});
      // merge process
      let i = l, j = mid+1;
      const temp = [];
      while(i<=mid && j<=r){
        actions.push({type:'compare', i, j});
        if (a[i] <= a[j]){
          temp.push(a[i]); i++;
        } else {
          temp.push(a[j]); j++;
        }
      }
      while(i<=mid){
        // no compare, but still push to record movement
        temp.push(a[i]); i++;
      }
      while(j<=r){
        temp.push(a[j]); j++;
      }
      // write back
      for(let k=0;k<temp.length;k++){
        const idx = l + k;
        actions.push({type:'overwrite', index:idx, value:temp[k]});
        a[idx] = temp[k];
      }
      actions.push({type:'merged', l, r});
    }
    mergeSortRec(aCopy, 0, aCopy.length-1);
    return actions;
  }

  // Visualizer: play actions sequentially
  function applyAction(act){
    // reset previous highlights first
    // We'll adjust classes per action.
    // Clear compare/write classes from all bars, but keep merged class as it is.
    bars.forEach(b => {
      b.classList.remove('compare','write','mergeRange');
      // 'sorted' class persists after merged
    });

    switch(act.type){
      case 'merge':
        // highlight merge range
        for(let k=act.l;k<=act.r;k++){
          bars[k].classList.add('mergeRange');
        }
        updateStat(`Merging range [${act.l} .. ${act.r}] (mid=${act.mid})`);
        break;
      case 'compare':
        if (act.i < bars.length) bars[act.i].classList.add('compare');
        if (act.j < bars.length) bars[act.j].classList.add('compare');
        updateStat(`Compare indices ${act.i} and ${act.j}`);
        break;
      case 'overwrite':
        // update visual array value and height
        const idx = act.index;
        const val = act.value;
        array[idx] = val;
        const maxVal = Math.max(...array, 1);
        const canvasHeight = canvas.clientHeight - 8;
        const height = Math.max(6, Math.round((val / maxVal) * (canvasHeight - 8)));
        const bar = bars[idx];
        if (bar){
          bar.classList.add('write');
          bar.style.height = height + 'px';
          bar.firstChild.textContent = val;
        }
        updateStat(`Write value ${val} at index ${idx}`);
        break;
      case 'merged':
        // mark range as sorted
        for(let k=act.l;k<=act.r;k++){
          bars[k].classList.remove('mergeRange');
          bars[k].classList.remove('compare','write');
          bars[k].classList.add('sorted');
        }
        updateStat(`Range [${act.l} .. ${act.r}] merged (sorted)`);
        break;
      default:
        break;
    }
  }

  function updateStat(text){
    actionStat.textContent = `Action ${actionIndex+1}/${actions.length} — ${text}`;
  }

  function play(){
    if (actions.length === 0) return;
    playing = true;
    startBtn.disabled = true;
    shuffleBtn.disabled = true;
    stepBtn.disabled = true;
    pauseBtn.disabled = false;
    sizeRange.disabled = true;
    // schedule next action
    function step(){
      if (!playing) return;
      if (actionIndex >= actions.length){
        // finished
        playing = false;
        pauseBtn.disabled = true;
        startBtn.disabled = false;
        shuffleBtn.disabled = false;
        stepBtn.disabled = false;
        sizeRange.disabled = false;
        updateStat('Done — array sorted');
        return;
      }
      const act = actions[actionIndex];
      applyAction(act);
      actionIndex++;
      // schedule next
      timer = setTimeout(step, msPerAction);
    }
    step();
  }

  function pause(){
    playing = false;
    if (timer) clearTimeout(timer);
    startBtn.disabled = false;
    stepBtn.disabled = false;
    shuffleBtn.disabled = false;
    pauseBtn.disabled = true;
    sizeRange.disabled = false;
    updateStat('Paused');
  }

  function stepOnce(){
    if (actions.length === 0) return;
    if (actionIndex >= actions.length){
      updateStat('Already finished');
      return;
    }
    // apply one action and pause
    const act = actions[actionIndex];
    applyAction(act);
    actionIndex++;
    updateStat(`Stepped: ${actionIndex}/${actions.length}`);
  }

  // UI wiring
  sizeRange.addEventListener('input', () => {
    sizeLabel.textContent = sizeRange.value;
  });

  speedRange.addEventListener('input', () => {
    const v = Number(speedRange.value);
    // smaller value = faster; we want ms per action scale,
    // invert and map to reasonable range
    msPerAction = Math.max(6, Math.round(v));
    speedLabel.textContent = `${msPerAction} ms`;
  });

  shuffleBtn.addEventListener('click', () => {
    cancelPlaybackReset();
    generateArray(Number(sizeRange.value));
    // reset visuals
    actions = [];
    actionIndex = 0;
    updateStat('New array generated — record actions to begin.');
  });

  startBtn.addEventListener('click', () => {
    // If no actions recorded, record them now based on current array
    if (playing) return;
    actions = recordMergeSort(array);
    actionIndex = 0;
    // clear previous sorted markings
    bars.forEach(b => b.classList.remove('sorted','mergeRange','compare','write'));
    play();
  });

  pauseBtn.addEventListener('click', () => {
    pause();
  });

  stepBtn.addEventListener('click', () => {
    // if no actions recorded, record them now
    if (actions.length === 0){
      actions = recordMergeSort(array);
      actionIndex = 0;
      bars.forEach(b => b.classList.remove('sorted','mergeRange','compare','write'));
    }
    // if playing, pause first
    if (playing) pause();
    stepOnce();
  });

  function cancelPlaybackReset(){
    if (timer) { clearTimeout(timer); timer = null; }
    playing = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    stepBtn.disabled = false;
    shuffleBtn.disabled = false;
    sizeRange.disabled = false;
  }

  // initial setup
  sizeLabel.textContent = sizeRange.value;
  speedLabel.textContent = speedRange.value + ' ms';
  msPerAction = Number(speedRange.value);

  // Generate an initial array
  generateArray(Number(sizeRange.value));
  updateStat('Ready — click Start to visualize Merge Sort.');

  // Make responsive on resize: re-render bars to adjust width
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      renderArray();
    }, 120);
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' '){ // space to play/pause
      e.preventDefault();
      if (playing) pause();
      else startBtn.click();
    } else if (e.key === 'ArrowRight'){
      stepBtn.click();
    } else if (e.key === 'r' || e.key === 'R'){
      shuffleBtn.click();
    }
  });

})();
</script>
</body>
</html>