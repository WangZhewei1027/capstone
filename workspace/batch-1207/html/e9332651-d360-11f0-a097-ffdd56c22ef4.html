<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Weighted Graph Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --muted: #94a3b8;
      --danger: #fb7185;
      --canvas: #071024;
      --card: #071029;
    }
    html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,var(--bg),#061224 60%); color:#e6eef8; }
    .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
    .left {
      width:75%;
      background:linear-gradient(180deg,var(--canvas),#031024);
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      position:relative;
      box-shadow:0 6px 30px rgba(2,6,23,0.7);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .topbar { display:flex; gap:8px; align-items:center; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select, input[type="number"], .mode-toggle {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      transition:all .15s;
    }
    button:hover, .mode-toggle:hover { transform:translateY(-2px); border-color:rgba(255,255,255,0.12); color:#fff; }
    button.primary { background:linear-gradient(90deg,var(--accent),#7dd3fc); color:#07203a; border:none; }
    .mode-toggle.active { border-color:var(--accent); color:var(--accent); box-shadow:0 4px 18px rgba(96,165,250,0.08); }
    .right {
      width:25%;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .panel {
      background:linear-gradient(180deg,var(--panel),var(--card));
      padding:12px;
      border-radius:12px;
      box-shadow:0 6px 16px rgba(2,6,23,0.5);
      overflow:auto;
    }
    .canvas-wrap { flex:1; border-radius:10px; background:transparent; position:relative; }
    svg { width:100%; height:100%; display:block; border-radius:8px; cursor:crosshair; }
    .hint { font-size:12px; color:var(--muted); }
    .small { font-size:13px; color:var(--muted); }
    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .legend .chip { padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.03); color:var(--muted); font-size:13px; border:1px dashed rgba(255,255,255,0.03); }
    .adj { font-family:monospace; font-size:13px; color:#dbeafe; white-space:pre-wrap; }
    .footer { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .info-line { font-size:13px; color:var(--muted); }
    .weight-badge { background:rgba(0,0,0,0.45); padding:4px 6px; border-radius:6px; font-size:12px; color:#fff; border:1px solid rgba(255,255,255,0.04); }
    .status { font-size:13px; color:var(--muted); }
    .title { font-weight:600; color:#e6f0ff; }
    a { color:var(--accent); text-decoration:none; }
    .small-muted { font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="topbar">
        <div style="display:flex;flex-direction:column;">
          <div class="title">Interactive Weighted Graph</div>
          <div class="small-muted">Create nodes & edges, set weights, run Dijkstra or MST (Prim). Drag to move nodes.</div>
        </div>
        <div style="flex:1"></div>
        <div class="controls">
          <button id="mode-add" class="mode-toggle active" title="Add node">Add Node</button>
          <button id="mode-edge" class="mode-toggle" title="Add edge (click two nodes)">Add Edge</button>
          <button id="mode-move" class="mode-toggle" title="Move nodes">Move</button>
          <button id="mode-del" class="mode-toggle" title="Delete node/edge">Delete</button>

          <label class="small-muted" title="Default weight when adding edges">Default weight</label>
          <input id="default-weight" type="number" min="1" value="1" style="width:70px" />

          <label style="display:flex;align-items:center;gap:6px;">
            <input id="directed" type="checkbox" /> &nbsp;<span class="small-muted">Directed</span>
          </label>

          <button id="random" title="Generate random graph">Random</button>
          <button id="clear" title="Clear graph">Clear</button>
        </div>
      </div>

      <div class="canvas-wrap panel" style="padding:8px;">
        <svg id="svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet"></svg>
        <div style="position:absolute;right:18px;bottom:12px;">
          <div class="weight-badge" id="status">Mode: Add Node</div>
        </div>
      </div>

      <div class="footer" style="margin-top:8px;">
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="dijkstra" class="primary">Dijkstra (Shortest Path)</button>
          <button id="prim">Prim's MST</button>
          <button id="animate-steps">Toggle Step Animation</button>
          <div class="hint">Click source and target when running Dijkstra. For MST it picks a node.</div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;">
          <div class="small-muted">Selected:</div>
          <div id="selected-info" class="weight-badge">None</div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="title">Graph Info</div>
        <div style="margin-top:8px;">
          <div class="small-muted">Nodes: <span id="node-count">0</span> &nbsp; Edges: <span id="edge-count">0</span></div>
          <div style="margin-top:8px;">
            <div class="small-muted">Adjacency List</div>
            <div id="adj" class="adj">[]</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="title">How to Use</div>
        <ol style="color:var(--muted); font-size:13px; margin-top:8px; padding-left:18px;">
          <li>Click 'Add Node' then click anywhere on the canvas to create nodes.</li>
          <li>Choose 'Add Edge', click two nodes to connect them. You'll be prompted for a weight.</li>
          <li>Drag in 'Move' mode to reposition nodes.</li>
          <li>'Delete' mode removes a clicked node or edge.</li>
          <li>Toggle 'Directed' to make edges directed.</li>
          <li>Click 'Dijkstra' then click source and target nodes to find shortest path.</li>
          <li>Click 'Prim' to compute a minimum spanning tree (undirected edges considered).</li>
        </ol>
      </div>

      <div class="panel">
        <div class="title">Legend</div>
        <div class="legend" style="margin-top:8px;">
          <div class="chip">Blue edge = normal</div>
          <div class="chip" style="background:linear-gradient(90deg,#f97316,#fb923c);color:#071022">Orange = active / selected</div>
          <div class="chip" style="background:linear-gradient(90deg,#34d399,#10b981);color:#042018">Green = result (path / MST)</div>
          <div class="chip">Hover nodes to see id and distance during algorithms</div>
        </div>
      </div>

    </div>
  </div>

<script>
(function(){
  const svg = document.getElementById('svg');
  const MODE_ADD = 'add';
  const MODE_EDGE = 'edge';
  const MODE_MOVE = 'move';
  const MODE_DEL = 'del';
  let mode = MODE_ADD;
  let directed = false;
  let defaultWeight = 1;
  let animateSteps = true;

  let nodes = []; // {id,x,y}
  let edges = []; // {id,a,b,w,directed}
  let nodeIdCounter = 0, edgeIdCounter = 0;

  const R = 18; // node radius
  const showStatus = document.getElementById('status');
  const nodeCountEl = document.getElementById('node-count');
  const edgeCountEl = document.getElementById('edge-count');
  const adjEl = document.getElementById('adj');
  const selectedInfo = document.getElementById('selected-info');

  const modeButtons = {
    add: document.getElementById('mode-add'),
    edge: document.getElementById('mode-edge'),
    move: document.getElementById('mode-move'),
    del: document.getElementById('mode-del')
  };

  function setMode(newMode) {
    mode = newMode;
    showStatus.textContent = 'Mode: ' + (mode === MODE_ADD ? 'Add Node' : mode === MODE_EDGE ? 'Add Edge' : mode === MODE_MOVE ? 'Move' : 'Delete');
    for (let k in modeButtons) modeButtons[k].classList.toggle('active', k === newMode);
    resetSelections();
  }

  modeButtons.add.addEventListener('click', ()=> setMode(MODE_ADD));
  modeButtons.edge.addEventListener('click', ()=> setMode(MODE_EDGE));
  modeButtons.move.addEventListener('click', ()=> setMode(MODE_MOVE));
  modeButtons.del.addEventListener('click', ()=> setMode(MODE_DEL));

  document.getElementById('default-weight').addEventListener('change', (e)=>{
    defaultWeight = Math.max(0, Number(e.target.value) || 0);
  });

  document.getElementById('directed').addEventListener('change', (e)=>{
    directed = e.target.checked;
  });

  document.getElementById('clear').addEventListener('click', ()=>{
    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;
    resetSelections();
    redraw();
  });

  document.getElementById('random').addEventListener('click', ()=>{
    generateRandomGraph();
  });

  document.getElementById('dijkstra').addEventListener('click', ()=>{
    startDijkstraMode();
  });

  document.getElementById('prim').addEventListener('click', ()=>{
    runPrimMST();
  });

  document.getElementById('animate-steps').addEventListener('click', ()=>{
    animateSteps = !animateSteps;
    alert('Step animation ' + (animateSteps ? 'ON' : 'OFF'));
  });

  function generateRandomGraph(){
    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;
    const n = 8 + Math.floor(Math.random()*6);
    for (let i=0;i<n;i++){
      nodes.push({id: nodeIdCounter++, x: 120 + Math.random()*960, y: 80 + Math.random()*520});
    }
    // Add roughly 1.5*n edges
    const m = Math.floor(n * (1.4 + Math.random()*0.8));
    for (let i=0;i<m;i++){
      const a = nodes[Math.floor(Math.random()*nodes.length)];
      const b = nodes[Math.floor(Math.random()*nodes.length)];
      if (a === b) continue;
      // prevent duplicate edge (simple check for undirected)
      if (edges.some(e => (e.a===a.id && e.b===b.id) || (!directed && e.a===b.id && e.b===a.id))) continue;
      edges.push({id: edgeIdCounter++, a:a.id, b:b.id, w: 1+Math.floor(Math.random()*15), directed: Math.random() < 0.2});
    }
    redraw();
  }

  // Rendering
  function redraw(highlight = {}) {
    // highlight: {pathEdges:Set(edgeId), pathNodes:Set(nodeId), activeEdge:edgeId, activeNode:nodeId, mstEdges:Set}
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    // defs for arrowheads
    const defs = createSvg('defs', {});
    defs.innerHTML = `
      <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
        <path d="M0,0 L10,3.5 L0,7 z" fill="#60a5fa"></path>
      </marker>
      <marker id="arrowhead-orange" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
        <path d="M0,0 L10,3.5 L0,7 z" fill="#fb923c"></path>
      </marker>
      <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
        <path d="M0,0 L10,3.5 L0,7 z" fill="#34d399"></path>
      </marker>
    `;
    svg.appendChild(defs);

    // draw edges
    const edgeGroup = createSvg('g', {});
    // sort so selected/highlight edges drawn last
    const normalEdges = edges.filter(e => !highlight.pathEdges || !highlight.pathEdges.has(e.id));
    normalEdges.forEach(e => {
      const a = nodes.find(n => n.id === e.a);
      const b = nodes.find(n => n.id === e.b);
      if (!a || !b) return;
      drawEdge(edgeGroup, e, a, b, highlight);
    });
    if (highlight.pathEdges) {
      highlight.pathEdges.forEach(eid=>{
        const e = edges.find(z=>z.id===eid); if (!e) return;
        const a = nodes.find(n => n.id === e.a);
        const b = nodes.find(n => n.id === e.b);
        drawEdge(edgeGroup, e, a, b, highlight, true);
      });
    }
    svg.appendChild(edgeGroup);

    // draw nodes
    const nodeGroup = createSvg('g', {});
    nodes.forEach(n => {
      drawNode(nodeGroup, n, highlight);
    });
    svg.appendChild(nodeGroup);

    updateStats();
  }

  function drawEdge(parent, e, a, b, highlight, emphasized=false) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const ux = dx / dist;
    const uy = dy / dist;
    const startX = a.x + ux * R;
    const startY = a.y + uy * R;
    const endX = b.x - ux * R;
    const endY = b.y - uy * R;

    const isPath = highlight.pathEdges && highlight.pathEdges.has(e.id);
    const stroke = isPath ? '#34d399' : (highlight.activeEdge === e.id ? '#fb923c' : '#60a5fa');
    const strokeWidth = isPath ? 4 : (highlight.activeEdge === e.id ? 4 : 2);
    const markerId = isPath ? 'arrowhead-green' : (highlight.activeEdge === e.id ? 'arrowhead-orange' : 'arrowhead');

    const line = createSvg('line', { x1:startX, y1:startY, x2:endX, y2:endY, stroke, 'stroke-width':strokeWidth, 'stroke-linecap':'round' });
    if (e.directed || e.directed === true) {
      line.setAttribute('marker-end', `url(#${markerId})`);
    } else if (directed) {
      // if global directed toggle on and edge isn't directed, show symmetric small arrow?
      // We'll only show arrows if edge.directed true or global directed toggled when adding.
    }
    line.style.cursor = 'pointer';
    line.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      if (mode === MODE_DEL) {
        if (confirm('Delete this edge?')) {
          edges = edges.filter(x=>x.id!==e.id);
          redraw();
        }
      } else {
        // toggle highlight
        resetSelections();
        redraw({activeEdge: e.id});
        selectedInfo.textContent = `Edge ${e.id} (${e.a} → ${e.b}) w=${e.w}`;
      }
    });

    parent.appendChild(line);

    // weight label at midpoint with offset perpendicular
    const mx = (startX + endX) / 2;
    const my = (startY + endY) / 2;
    const px = -uy; const py = ux; // perpendicular
    const labelX = mx + px * 10;
    const labelY = my + py * 10;

    const rect = createSvg('rect', { x: labelX - 18, y: labelY - 12, rx:6, ry:6, width: 36, height: 20, fill: 'rgba(0,0,0,0.45)', stroke: 'rgba(255,255,255,0.03)', 'pointer-events':'none' });
    parent.appendChild(rect);
    const text = createSvg('text', { x: labelX, y: labelY + 4, 'text-anchor':'middle', 'font-size':12, fill:'#e6f0ff', 'pointer-events':'none' });
    text.textContent = e.w;
    parent.appendChild(text);
  }

  function drawNode(parent, n, highlight) {
    const isPathNode = highlight.pathNodes && highlight.pathNodes.has(n.id);
    const fill = isPathNode ? '#10b981' : (highlight.activeNode === n.id ? '#fb923c' : '#071a32');
    const stroke = isPathNode ? '#34d399' : (highlight.activeNode === n.id ? '#fb923c' : '#60a5fa');
    const strokeWidth = isPathNode ? 3 : (highlight.activeNode === n.id ? 3 : 2);

    const g = createSvg('g', { transform:`translate(${n.x},${n.y})` });
    const circle = createSvg('circle', { cx:0, cy:0, r:R, fill, stroke, 'stroke-width': strokeWidth });
    circle.style.cursor = 'pointer';
    circle.addEventListener('mousedown', (ev)=>{
      ev.stopPropagation();
      if (mode === MODE_MOVE) {
        startDrag(n, ev);
      } else if (mode === MODE_ADD) {
        // do nothing (can't add node on existing)
      } else if (mode === MODE_EDGE) {
        handleEdgeClick(n);
      } else if (mode === MODE_DEL) {
        if (confirm('Delete node ' + n.id + ' and its edges?')) {
          edges = edges.filter(e => e.a!==n.id && e.b!==n.id);
          nodes = nodes.filter(nd => nd.id!==n.id);
          redraw();
        }
      }
    });
    circle.addEventListener('click', (ev)=> {
      ev.stopPropagation();
      // update selected info if not edge mode
      if (mode !== MODE_EDGE) {
        resetSelections();
        redraw({activeNode: n.id});
        selectedInfo.textContent = `Node ${n.id}`;
      }
    });
    circle.addEventListener('mouseenter', ()=>{
      // show tooltip-ish by drawing label nearby
      redraw({activeNode: n.id});
    });
    g.appendChild(circle);
    const text = createSvg('text', { x:0, y:6, 'text-anchor':'middle', 'font-size':13, fill:'#fff', 'pointer-events':'none' });
    text.textContent = n.id;
    g.appendChild(text);
    parent.appendChild(g);
  }

  function createSvg(tag, attrs) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  // Interaction
  svg.addEventListener('click', (ev)=>{
    const pt = svgPoint(ev);
    if (mode === MODE_ADD) {
      addNode(pt.x, pt.y);
    } else if (mode !== MODE_MOVE && mode !== MODE_EDGE && mode !== MODE_DEL) {
      // nothing
    } else {
      // click on background resets selection
      resetSelections();
      redraw();
    }
  });

  function svgPoint(ev) {
    const rect = svg.getBoundingClientRect();
    // viewBox 0 0 1200 700 mapping to client rect
    const vw = rect.width, vh = rect.height;
    const x = (ev.clientX - rect.left) * (1200 / vw);
    const y = (ev.clientY - rect.top) * (700 / vh);
    return {x,y};
  }

  function addNode(x,y) {
    const n = {id: nodeIdCounter++, x, y};
    nodes.push(n);
    redraw();
  }

  let edgeFirstNode = null;
  function handleEdgeClick(n) {
    if (!edgeFirstNode) {
      edgeFirstNode = n;
      selectedInfo.textContent = `Edge from ${n.id} → ... (click target)`;
      redraw({activeNode: n.id});
    } else if (edgeFirstNode.id === n.id) {
      // clicked same node - cancel
      edgeFirstNode = null;
      selectedInfo.textContent = 'None';
      redraw();
    } else {
      // create edge between edgeFirstNode and n
      let weight = Number(document.getElementById('default-weight').value) || defaultWeight;
      const input = prompt('Weight for edge ' + edgeFirstNode.id + ' → ' + n.id + ' (number):', weight);
      if (input === null) {
        edgeFirstNode = null; redraw(); return;
      }
      weight = Number(input);
      if (!isFinite(weight)) weight = defaultWeight;
      // check duplicate
      if (edges.some(e => e.a===edgeFirstNode.id && e.b===n.id && e.directed===directed)) {
        if (!confirm('An identical edge exists. Add duplicate anyway?')) {
          edgeFirstNode = null; redraw(); return;
        }
      }
      const e = {id: edgeIdCounter++, a:edgeFirstNode.id, b:n.id, w: weight, directed: directed};
      edges.push(e);
      edgeFirstNode = null;
      selectedInfo.textContent = 'None';
      redraw();
    }
  }

  // Dragging
  let dragNode = null;
  let dragOffset = {x:0,y:0};
  function startDrag(n, ev) {
    dragNode = n;
    const pt = svgPoint(ev);
    dragOffset.x = n.x - pt.x;
    dragOffset.y = n.y - pt.y;
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', endDrag);
  }
  function onDrag(ev) {
    if (!dragNode) return;
    const pt = svgPoint(ev);
    dragNode.x = pt.x + dragOffset.x;
    dragNode.y = pt.y + dragOffset.y;
    redraw();
  }
  function endDrag(ev) {
    dragNode = null;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', endDrag);
  }

  function resetSelections() {
    edgeFirstNode = null;
    selectedInfo.textContent = 'None';
  }

  function updateStats() {
    nodeCountEl.textContent = nodes.length;
    edgeCountEl.textContent = edges.length;
    // build adjacency list
    const adj = {};
    nodes.forEach(n => adj[n.id] = []);
    edges.forEach(e => {
      adj[e.a].push({to: e.b, w: e.w, edgeId:e.id});
      if (!e.directed) adj[e.b].push({to: e.a, w: e.w, edgeId:e.id});
    });
    let txt = '';
    for (let id in adj) {
      txt += id + ': ';
      txt += adj[id].map(x => `${x.to}(w=${x.w})`).join(', ');
      txt += '\n';
    }
    adjEl.textContent = txt || '[]';
  }

  // Algorithms
  function startDijkstraMode() {
    if (nodes.length === 0) { alert('No nodes'); return; }
    alert('Dijkstra: Click source node then target node on canvas.');
    let src = null;
    let tgt = null;
    const handler = (ev)=>{
      ev.stopPropagation();
      // find clicked node from mouse position
      const pt = svgPoint(ev);
      const clicked = nodes.find(n => Math.hypot(n.x-pt.x,n.y-pt.y) <= R+4);
      if (!clicked) return;
      if (!src) {
        src = clicked.id;
        redraw({activeNode: clicked.id});
        selectedInfo.textContent = 'Dijkstra source: ' + src;
      } else if (!tgt) {
        tgt = clicked.id;
        selectedInfo.textContent = 'Dijkstra target: ' + tgt;
        svg.removeEventListener('click', handler, true);
        computeDijkstra(src, tgt);
      }
    };
    svg.addEventListener('click', handler, true);
  }

  function computeDijkstra(srcId, tgtId) {
    // Build adjacency
    const adj = {};
    nodes.forEach(n=>adj[n.id]=[]);
    edges.forEach(e=>{
      adj[e.a].push({to:e.b,w:e.w,edgeId:e.id});
      if (!e.directed) adj[e.b].push({to:e.a,w:e.w,edgeId:e.id});
    });
    const dist = {};
    const prev = {};
    const prevEdge = {};
    nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; prevEdge[n.id]=null; });
    dist[srcId] = 0;
    const visited = new Set();
    // simple PQ
    const pq = new MinPQ();
    pq.push({id:srcId, d:0});
    const steps = [];
    while (!pq.empty()) {
      const cur = pq.pop();
      if (visited.has(cur.id)) continue;
      visited.add(cur.id);
      steps.push({type:'visit', id:cur.id, dist: dist[cur.id]});
      if (cur.id === tgtId) break;
      for (const e of adj[cur.id]) {
        const nd = dist[cur.id] + e.w;
        if (nd < dist[e.to]) {
          dist[e.to] = nd;
          prev[e.to] = cur.id;
          prevEdge[e.to] = e.edgeId;
          pq.push({id:e.to, d:nd});
          steps.push({type:'relax', from:cur.id, to:e.to, newDist:nd, edgeId:e.edgeId});
        }
      }
    }

    if (dist[tgtId] === Infinity) {
      alert('No path found from ' + srcId + ' to ' + tgtId);
      redraw();
      return;
    }
    // reconstruct path
    const pathNodes = new Set();
    const pathEdges = new Set();
    let cur = tgtId;
    while (cur !== null) {
      pathNodes.add(cur);
      if (prevEdge[cur] !== null) pathEdges.add(prevEdge[cur]);
      cur = prev[cur];
    }
    // Optionally animate steps
    if (animateSteps) {
      playDijkstraSteps(steps, pathNodes, pathEdges, dist, srcId, tgtId);
    } else {
      redraw({pathNodes, pathEdges});
      selectedInfo.textContent = `Shortest ${srcId}→${tgtId} distance=${dist[tgtId]}`;
      showDistanceOverlay(dist);
    }
  }

  function playDijkstraSteps(steps, pathNodes, pathEdges, dist, srcId, tgtId) {
    let i = 0;
    const stepInterval = 400;
    const interval = setInterval(()=>{
      if (i >= steps.length) {
        // final: highlight path
        clearInterval(interval);
        redraw({pathNodes, pathEdges});
        selectedInfo.textContent = `Shortest ${srcId}→${tgtId} distance=${dist[tgtId]}`;
        showDistanceOverlay(dist);
        return;
      }
      const s = steps[i++];
      if (s.type === 'visit') {
        redraw({activeNode: s.id});
      } else if (s.type === 'relax') {
        redraw({activeEdge: s.edgeId, activeNode: s.to});
      } else {
        redraw();
      }
    }, stepInterval);
  }

  function showDistanceOverlay(dist) {
    // draw distances next to nodes temporarily
    // We'll overlay small number tags on nodes
    // For simplicity, redraw with an overlay group with distances
    const overlay = createSvg('g', { id: 'overlay' });
    nodes.forEach(n => {
      const x = n.x + 22;
      const y = n.y - 12;
      const rect = createSvg('rect', { x:x-6, y:y-12, rx:6, ry:6, width: 44, height: 20, fill: 'rgba(0,0,0,0.45)', stroke: 'rgba(255,255,255,0.03)' });
      const text = createSvg('text', { x:x+16, y:y+4, 'text-anchor':'middle', 'font-size':12, fill:'#e6f0ff' });
      const d = dist[n.id] === Infinity ? '∞' : dist[n.id];
      text.textContent = d;
      overlay.appendChild(rect);
      overlay.appendChild(text);
    });
    svg.appendChild(overlay);
    // remove after 5 sec
    setTimeout(()=>{ const el = document.getElementById('overlay'); if (el) el.remove(); }, 5000);
  }

  // Prim MST
  function runPrimMST() {
    if (nodes.length === 0) { alert('No nodes'); return; }
    // For Prim we ignore directed edges and treat graph as undirected
    const adj = {};
    nodes.forEach(n=>adj[n.id]=[]);
    edges.forEach(e=>{
      adj[e.a].push({to:e.b,w:e.w,edgeId:e.id});
      adj[e.b].push({to:e.a,w:e.w,edgeId:e.id});
    });
    const startId = nodes[0].id;
    const inTree = new Set([startId]);
    const edgeSet = new Set();
    const pq = new MinPQ();
    for (const e of adj[startId]) pq.push({edgeId: e.edgeId, from: startId, to: e.to, w: e.w});
    const steps = [];
    while (!pq.empty()) {
      const cur = pq.pop();
      if (inTree.has(cur.to)) continue;
      inTree.add(cur.to);
      edgeSet.add(cur.edgeId);
      steps.push({type:'addEdge', edgeId: cur.edgeId, from:cur.from, to:cur.to, w:cur.w});
      for (const e of adj[cur.to]) {
        if (!inTree.has(e.to)) pq.push({edgeId:e.edgeId, from:cur.to, to:e.to, w:e.w});
      }
    }
    if (inTree.size !== nodes.length) {
      alert('Graph is not connected — MST covers its component.');
    }
    // animate
    if (animateSteps) {
      playPrimSteps(steps, edgeSet);
    } else {
      redraw({pathEdges: edgeSet});
      selectedInfo.textContent = `Prim MST edges: ${Array.from(edgeSet).join(', ')}`;
    }
  }

  function playPrimSteps(steps, edgeSet) {
    let i = 0;
    const interval = setInterval(()=>{
      if (i >= steps.length) {
        clearInterval(interval);
        redraw({pathEdges: edgeSet});
        selectedInfo.textContent = 'Prim MST done';
        return;
      }
      const s = steps[i++];
      redraw({activeEdge: s.edgeId});
    }, 450);
  }

  // Utilities: MinPQ
  function MinPQ() {
    this.arr = [];
  }
  MinPQ.prototype.push = function(obj) {
    this.arr.push(obj);
  };
  MinPQ.prototype.pop = function() {
    if (this.arr.length === 0) return null;
    let idx = 0;
    for (let i=1;i<this.arr.length;i++) {
      if ((this.arr[i].d || this.arr[i].w) < (this.arr[idx].d || this.arr[idx].w)) idx = i;
    }
    return this.arr.splice(idx,1)[0];
  };
  MinPQ.prototype.empty = function() { return this.arr.length === 0; };

  // initial render
  redraw();

  // small helper: clicking edges needs to know event propagation order; we attached click handlers in drawEdge

  // Prevent text selection while dragging
  document.addEventListener('selectstart', (e)=>{ if (dragNode) e.preventDefault(); });

  // Expose for testing via console (optional)
  window._graphDemo = { nodes, edges, redraw };

})();
</script>
</body>
</html>