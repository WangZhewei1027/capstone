<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #tree {
            margin-top: 20px;
        }
        .node {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            border-radius: 5px;
            color: white;
            text-align: center;
            position: relative;
        }
        .red {
            background-color: red;
        }
        .black {
            background-color: black;
        }
        .line {
            border-left: 1px solid black;
            position: absolute;
            top: 0;
            height: 50px;
            left: 50%;
            margin-left: -1px;
        }
        #inputNumber {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

<h1>Red-Black Tree Visualization</h1>
<input type="number" id="inputNumber" placeholder="Enter a number">
<button onclick="insertNode()">Insert Node</button>

<div id="tree"></div>

<script>
    class Node {
        constructor(data) {
            this.data = data;
            this.color = "red";  // New nodes are initially red
            this.left = null;
            this.right = null;
            this.parent = null;
        }
    }

    class RedBlackTree {
        constructor() {
            this.TNULL = new Node(0);
            this.TNULL.color = "black";
            this.root = this.TNULL;
        }

        insert(data) {
            let node = new Node(data);
            node.parent = null;
            node.data = data;
            node.left = this.TNULL;
            node.right = this.TNULL;

            let y = null;
            let x = this.root;

            while (x !== this.TNULL) {
                y = x;
                if (node.data < x.data) {
                    x = x.left;
                } else {
                    x = x.right;
                }
            }

            node.parent = y;
            if (y === null) {
                this.root = node;
            } else if (node.data < y.data) {
                y.left = node;
            } else {
                y.right = node;
            }

            if (node.parent === null) {
                node.color = "black";
                return;
            }

            if (node.parent.parent === null) {
                return;
            }

            this.fixInsert(node);
        }

        fixInsert(k) {
            while (k.parent.color === "red") {
                if (k.parent === k.parent.parent.left) {
                    let u = k.parent.parent.right;
                    if (u.color === "red") {
                        k.parent.color = "black";
                        u.color = "black";
                        k.parent.parent.color = "red";
                        k = k.parent.parent;
                    } else {
                        if (k === k.parent.right) {
                            k = k.parent;
                            this.leftRotate(k);
                        }
                        k.parent.color = "black";
                        k.parent.parent.color = "red";
                        this.rightRotate(k.parent.parent);
                    }
                } else {
                    let u = k.parent.parent.left;

                    if (u.color === "red") {
                        k.parent.color = "black";
                        u.color = "black";
                        k.parent.parent.color = "red";
                        k = k.parent.parent;
                    } else {
                        if (k === k.parent.left) {
                            k = k.parent;
                            this.rightRotate(k);
                        }
                        k.parent.color = "black";
                        k.parent.parent.color = "red";
                        this.leftRotate(k.parent.parent);
                    }
                }
                if (k === this.root) break;
            }
            this.root.color = "black";
        }

        leftRotate(x) {
            let y = x.right;
            x.right = y.left;
            if (y.left !== this.TNULL) {
                y.left.parent = x;
            }
            y.parent = x.parent;
            if (x.parent === null) {
                this.root = y;
            } else if (x === x.parent.left) {
                x.parent.left = y;
            } else {
                x.parent.right = y;
            }
            y.left = x;
            x.parent = y;
        }

        rightRotate(x) {
            let y = x.left;
            x.left = y.right;
            if (y.right !== this.TNULL) {
                y.right.parent = x;
            }
            y.parent = x.parent;
            if (x.parent === null) {
                this.root = y;
            } else if (x === x.parent.right) {
                x.parent.right = y;
            } else {
                x.parent.left = y;
            }
            y.right = x;
            x.parent = y;
        }

        visualizeTree(node = this.root) {
            if (node !== this.TNULL) {
                let div = document.createElement('div');
                div.classList.add('node', node.color);
                div.innerText = node.data;
                document.getElementById('tree').appendChild(div);

                if (node.left !== this.TNULL || node.right !== this.TNULL) {
                    if (node.left !== this.TNULL) {
                        let line = document.createElement('div');
                        line.className = 'line';
                        document.getElementById('tree').appendChild(line);
                        line.style.borderColor = node.color === 'red' ? 'red' : 'black';
                    }

                    this.visualizeTree(node.left);
                    
                    if (node.right !== this.TNULL) {
                        let line = document.createElement('div');
                        line.className = 'line';
                        document.getElementById('tree').appendChild(line);
                        line.style.borderColor = node.color === 'red' ? 'red' : 'black';
                    }

                    this.visualizeTree(node.right);
                }
            }
        }
    }

    const rbt = new RedBlackTree();

    function insertNode() {
        const input = document.getElementById("inputNumber").value;
        if (input) {
            rbt.insert(parseInt(input));
            document.getElementById('tree').innerHTML = '';
            rbt.visualizeTree();
            document.getElementById("inputNumber").value = '';
        }
    }
</script>
</body>
</html>