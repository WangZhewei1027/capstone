<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Directed and Undirected Graph Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f7f9fc;
    color: #333;
  }
  h1 {
    text-align: center;
    margin-bottom: 10px;
  }
  #controls {
    margin-bottom: 10px;
    text-align: center;
  }
  label {
    margin-right: 15px;
    font-weight: bold;
  }
  canvas {
    background: white;
    display: block;
    margin: 0 auto;
    box-shadow: 0 0 8px rgba(0,0,0,0.15);
    border-radius: 6px;
  }
  #instructions {
    max-width: 600px;
    margin: 15px auto;
    font-size: 0.9em;
    color: #555;
    line-height: 1.4em;
  }
  button {
    font-weight: bold;
    padding: 6px 14px;
    cursor: pointer;
    border-radius: 4px;
    border: none;
    background-color: #0078d4;
    color: white;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #005a9e;
  }
</style>
</head>
<body>
<h1>Graph Visualization: Directed & Undirected</h1>
<div id="controls">
  <label>
    <input type="radio" name="graphType" value="undirected" checked />
    Undirected Graph
  </label>
  <label>
    <input type="radio" name="graphType" value="directed" />
    Directed Graph
  </label>
  <button id="resetBtn" title="Clear all nodes and edges">Reset Graph</button>
</div>
<canvas id="graphCanvas" width="700" height="500" title="Click to add nodes, drag between nodes to create edges"></canvas>
<div id="instructions">
  <p><strong>Instructions:</strong></p>
  <ul>
    <li>Click anywhere on the canvas to add a node.</li>
    <li>Drag from a node to another node to create an edge (arrow for directed graph, line for undirected).</li>
    <li>Switch between Directed and Undirected graph modes using the radio buttons.</li>
    <li>Reset button clears the graph.</li>
  </ul>
</div>

<script>
(() => {
  const canvas = document.getElementById("graphCanvas");
  const ctx = canvas.getContext("2d");
  const graphTypeInputs = document.querySelectorAll('input[name="graphType"]');
  const resetBtn = document.getElementById("resetBtn");

  const NODE_RADIUS = 20;
  const ARROW_SIZE = 10;

  // Graph data structure
  // { id: number, x: number, y: number }
  // edges: {from: nodeId, to: nodeId}
  let nodes = [];
  let edges = [];

  let currentGraphType = 'undirected';

  let dragNodeId = null;
  let draggingEdge = false;
  let dragPos = { x: 0, y: 0 };

  // Track node IDs incrementally
  let nextNodeId = 1;

  /** Utility Functions */
  function distance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function getNodeAtPos(pos) {
    return nodes.find(node => distance(node, pos) <= NODE_RADIUS);
  }

  // Clear canvas
  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Draw arrow between two points
  function drawArrow(fromX, fromY, toX, toY, color = "#333") {
    const headlen = ARROW_SIZE; // length of head in pixels
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(dy, dx);

    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;

    // line from fromX,fromY to toX,toY but shrink endpoints by NODE_RADIUS to avoid overlap with nodes
    // Calculate shortened line endpoints:
    const length = Math.sqrt(dx*dx + dy*dy);
    if(length === 0) return;

    // Move start point forward by NODE_RADIUS
    const startX = fromX + (dx / length) * NODE_RADIUS;
    const startY = fromY + (dy / length) * NODE_RADIUS;

    // Move end point backward by NODE_RADIUS + arrow head length
    const endX = toX - (dx / length) * (NODE_RADIUS + headlen);
    const endY = toY - (dy / length) * (NODE_RADIUS + headlen);

    // draw line
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // draw arrowhead
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  // Draw line between two points (for undirected edges)
  function drawLine(fromX, fromY, toX, toY, color = "#333") {
    const dx = toX - fromX;
    const dy = toY - fromY;
    const length = Math.sqrt(dx*dx + dy*dy);
    if(length === 0) return;
    const startX = fromX + (dx / length) * NODE_RADIUS;
    const startY = fromY + (dy / length) * NODE_RADIUS;
    const endX = toX - (dx / length) * NODE_RADIUS;
    const endY = toY - (dy / length) * NODE_RADIUS;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }

  // Draw nodes
  function drawNode(node, highlight = false) {
    ctx.beginPath();
    ctx.fillStyle = highlight ? "#0078d4" : "#ffffff";
    ctx.strokeStyle = highlight ? "#005a9e" : "#333";
    ctx.lineWidth = highlight ? 4 : 2;
    ctx.shadowColor = "rgba(0,0,0,0.1)";
    ctx.shadowBlur = 5;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.stroke();

    // Draw node label (id)
    ctx.fillStyle = highlight ? "#fff" : "#333";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(node.id, node.x, node.y);
  }

  // Draw all
  function drawGraph() {
    clearCanvas();

    // Draw edges first
    edges.forEach(edge => {
      const fromNode = nodes.find(n => n.id === edge.from);
      const toNode = nodes.find(n => n.id === edge.to);
      if (!fromNode || !toNode) return;

      if(currentGraphType === 'directed'){
        drawArrow(fromNode.x, fromNode.y, toNode.x, toNode.y);
        if(edge.from === edge.to){
          // Draw a loop for self-edge:
          drawSelfLoop(fromNode);
        }
      } else {
        if(edge.from === edge.to){
          drawSelfLoop(fromNode);
        } else {
          drawLine(fromNode.x, fromNode.y, toNode.x, toNode.y);
        }
      }
    });

    // If dragging an edge, draw temporary line
    if(draggingEdge && dragNodeId !== null){
      const fromNode = nodes.find(n => n.id === dragNodeId);
      if(fromNode){
        drawLine(fromNode.x, fromNode.y, dragPos.x, dragPos.y, '#aaa');
      }
    }

    // Draw nodes on top
    // Highlight nodes under mouse or selected during drag?
    nodes.forEach(node => drawNode(node));
  }

  // Draw a self-loop on a node - a small circle on top-right side of the node
  function drawSelfLoop(node) {
    const loopRadius = 15;
    const loopX = node.x + NODE_RADIUS;
    const loopY = node.y - NODE_RADIUS;
    ctx.beginPath();
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.arc(loopX, loopY, loopRadius, 0, Math.PI * 2);
    ctx.stroke();

    if(currentGraphType === 'directed') {
      // Draw arrowhead on loop - approx at right-top side of loop arc (around 45 degrees)
      const angle = -Math.PI / 4; // 45 degrees clockwise from +x axis
      const arrowX = loopX + loopRadius * Math.cos(angle);
      const arrowY = loopY + loopRadius * Math.sin(angle);
      const arrowAngle = angle - Math.PI / 2; // perpendicular to loop edge direction

      ctx.beginPath();
      ctx.fillStyle = "#333";
      ctx.moveTo(arrowX, arrowY);
      ctx.lineTo(arrowX - ARROW_SIZE * Math.cos(arrowAngle - Math.PI / 6),
                 arrowY - ARROW_SIZE * Math.sin(arrowAngle - Math.PI / 6));
      ctx.lineTo(arrowX - ARROW_SIZE * Math.cos(arrowAngle + Math.PI / 6),
                 arrowY - ARROW_SIZE * Math.sin(arrowAngle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
    }
  }

  // Add node at position
  function addNode(x, y) {
    // Prevent overlap within 2*NODE_RADIUS from existing node
    if(nodes.some(n => distance(n, {x,y}) < NODE_RADIUS * 2)){
      return null;
    }
    const node = {id: nextNodeId++, x, y};
    nodes.push(node);
    return node;
  }

  // Add edge if doesn't exist (allow multiedges? For simplicity, no duplicates)
  function addEdge(fromId, toId) {
    if(fromId === toId){
      // Allow self-loops
    } else if(currentGraphType === 'undirected'){
      // For undirected, edge from->to same as to->from. Check both.
      if(edges.some(e =>
        (e.from === fromId && e.to === toId) ||
        (e.from === toId && e.to === fromId)
      )) return false;
    } else {
      // Directed: check exact match
      if(edges.some(e => e.from === fromId && e.to === toId)) return false;
    }

    edges.push({from: fromId, to: toId});
    return true;
  }

  // Event handlers
  canvas.addEventListener("mousedown", e => {
    const rect = canvas.getBoundingClientRect();
    const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
    const node = getNodeAtPos(mousePos);

    if(node){
      dragNodeId = node.id;
      draggingEdge = true;
      dragPos = mousePos;
    }
  });

  canvas.addEventListener("mousemove", e => {
    if(draggingEdge && dragNodeId !== null){
      const rect = canvas.getBoundingClientRect();
      dragPos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
      drawGraph();
    }
  });

  canvas.addEventListener("mouseup", e => {
    if(draggingEdge && dragNodeId !== null){
      const rect = canvas.getBoundingClientRect();
      const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
      const targetNode = getNodeAtPos(mousePos);

      if(targetNode){
        if(addEdge(dragNodeId, targetNode.id)){
          // Edge added
        }
      }
      dragNodeId = null;
      draggingEdge = false;
      drawGraph();
    }
  });

  // Clicking on empty space adds node
  canvas.addEventListener("click", e => {
    if(draggingEdge) return; // Ignore clicks during drag
    const rect = canvas.getBoundingClientRect();
    const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
    if(!getNodeAtPos(mousePos)){
      if(addNode(mousePos.x, mousePos.y)){
        drawGraph();
      }
    }
  });

  // Change graph type
  graphTypeInputs.forEach(input => {
    input.addEventListener("change", e => {
      currentGraphType = e.target.value;
      drawGraph();
    });
  });

  // Reset graph
  resetBtn.addEventListener("click", () => {
    nodes = [];
    edges = [];
    nextNodeId = 1;
    drawGraph();
  });

  drawGraph();
})();
</script>
</body>
</html>