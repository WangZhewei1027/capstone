<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Dijkstra's Algorithm Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#f7f9fc;
    --panel:#ffffff;
    --accent:#2b78f6;
    --muted:#6b7280;
    --good:#10b981;
    --bad:#ef4444;
    --node:#ffffff;
    --node-stroke:#1f2937;
  }
  html,body{height:100%;margin:0;font-family:Inter, Roboto, Helvetica, Arial, sans-serif;background:var(--bg);color:#111827}
  .container{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
  .canvas-panel{flex:1;background:linear-gradient(180deg,#eef6ff, #ffffff);border-radius:10px;padding:10px;box-shadow:0 2px 8px rgba(15,23,42,0.06);display:flex;flex-direction:column}
  #graphCanvas{flex:1;background:transparent;border-radius:6px;cursor:crosshair}
  .controls{width:380px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 2px 10px rgba(2,6,23,0.06);overflow:auto}
  h2{margin:2px 0 8px 0;font-size:18px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .modes{display:flex;gap:6px;flex-wrap:wrap}
  button{background:var(--accent);color:#fff;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}
  .btn-ghost{background:transparent;color:var(--accent);border:1px solid rgba(43,120,246,0.15)}
  .btn-danger{background:var(--bad)}
  .small{padding:6px 8px;font-size:14px}
  label{font-size:13px;color:var(--muted)}
  input[type="number"],input[type="text"],select{padding:6px;border-radius:6px;border:1px solid #e6e9ee}
  .info-block{background:#f8fafc;padding:8px;border-radius:8px;margin-bottom:8px;border:1px dashed #e6eefb}
  .list{max-height:220px;overflow:auto;padding:6px;border-radius:6px;border:1px solid #eef2ff;background:#fcfeff}
  .row-space{display:flex;justify-content:space-between;align-items:center}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:999px;background:#fff;border:1px solid #eef2ff;font-size:13px}
  .chip .dot{width:12px;height:12px;border-radius:50%}
  .dot-unvisited{background:#f3f4f6;border:1px solid #c7cbd6}
  .dot-frontier{background:#ffb020}
  .dot-visited{background:#10b981}
  .dot-current{background:#ef4444}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:6px;text-align:left;border-bottom:1px dashed #eef2ff}
  .pq-item{display:flex;justify-content:space-between;gap:8px;padding:6px;border-radius:6px;background:#fff;border:1px solid #eef2ff;margin-bottom:6px}
  .small-muted{font-size:12px;color:var(--muted)}
  .tight{padding:4px 6px}
  .footer{font-size:12px;color:var(--muted);margin-top:8px}
  .weight-badge{background:rgba(2,6,23,0.04);padding:3px 6px;border-radius:4px;font-weight:600}
</style>
</head>
<body>
<div class="container">
  <div class="canvas-panel">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div>
        <h2>Dijkstra Visualizer</h2>
        <div class="small-muted">Create a graph, set weights, then run Dijkstra step-by-step or animate.</div>
      </div>
      <div style="text-align:right">
        <div class="small-muted">Nodes: <span id="nodeCount">0</span> • Edges: <span id="edgeCount">0</span></div>
      </div>
    </div>
    <canvas id="graphCanvas"></canvas>
    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <div class="small-muted">Mode:</div>
      <div class="modes" id="modes">
        <button class="small" id="mode-add-node">Add Node</button>
        <button class="small btn-ghost" id="mode-add-edge">Add Edge</button>
        <button class="small btn-ghost" id="mode-move">Move</button>
        <button class="small btn-ghost" id="mode-delete">Delete</button>
      </div>
      <div style="margin-left:auto;display:flex;gap:6px">
        <button class="small btn-ghost" id="btn-clear">Clear</button>
        <button class="small btn-ghost" id="btn-reset">Reset Dijkstra</button>
      </div>
    </div>
    <div class="footer">Tip: Add nodes by clicking canvas. Use "Add Edge" mode: click source then target and enter weight. Toggle "Directed" to create one-way edges.</div>
  </div>

  <div class="controls">
    <h3>Graph & Dijkstra Controls</h3>

    <div class="row">
      <label>Directed?</label>
      <input type="checkbox" id="directed" style="margin-left:8px" />
      <div style="margin-left:auto" class="small-muted">Default weight:</div>
      <input type="number" id="defaultWeight" value="1" style="width:76px;margin-left:8px"/>
    </div>

    <div class="row">
      <button id="btn-run" class="small">Run (Animate)</button>
      <button id="btn-step" class="small btn-ghost">Step</button>
      <button id="btn-pause" class="small btn-ghost">Pause</button>
      <button id="btn-speed" class="small btn-ghost">Speed: <span id="speedLabel">1x</span></button>
    </div>

    <div class="row">
      <label>Start node:</label>
      <select id="startSelect" style="flex:1"></select>
    </div>

    <div class="row">
      <label>Highlight shortest path to:</label>
      <select id="endSelect" style="flex:1"><option value="">(none)</option></select>
    </div>

    <div class="info-block">
      <div class="row-space"><strong>Algorithm state</strong><div class="small-muted">Step-by-step visualization</div></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <div style="flex:1">
          <div class="small-muted">Priority Queue (min by dist)</div>
          <div id="pqList" class="list" style="min-height:80px"></div>
        </div>
        <div style="flex:1">
          <div class="small-muted">Distances</div>
          <div class="list" id="distList"></div>
        </div>
      </div>
      <div style="margin-top:8px">
        <div class="small-muted">Legend</div>
        <div class="legend">
          <div class="chip"><span class="dot dot-unvisited"></span>unvisited</div>
          <div class="chip"><span class="dot dot-frontier"></span>in priority queue</div>
          <div class="chip"><span class="dot dot-visited"></span>visited (settled)</div>
          <div class="chip"><span class="dot dot-current"></span>current exploring</div>
        </div>
      </div>
    </div>

    <h4 style="margin-top:10px;margin-bottom:6px">Nodes & Edges</h4>
    <div style="display:flex;gap:8px;margin-bottom:6px">
      <div style="flex:1">
        <div class="small-muted">Nodes</div>
        <div class="list" id="nodeList"></div>
      </div>
      <div style="flex:1">
        <div class="small-muted">Edges</div>
        <div class="list" id="edgeList"></div>
      </div>
    </div>

    <div style="display:flex;gap:8px;margin-top:6px">
      <button id="btn-export" class="small btn-ghost">Export JSON</button>
      <button id="btn-import" class="small btn-ghost">Import JSON</button>
      <input type="file" id="fileInput" style="display:none" />
    </div>

    <div style="margin-top:8px">
      <div class="small-muted">Animation speed</div>
      <input type="range" id="speedRange" min="0.25" max="3" step="0.25" value="1" />
    </div>

    <div style="margin-top:10px" class="small-muted">
      Instructions:
      <ul style="margin:6px 0 0 18px;padding:0">
        <li>Modes: Add Node (click canvas), Add Edge (click src then dst), Move (drag nodes), Delete (click node/edge).</li>
        <li>Set a start node, then Run or Step. Watch distances and priority queue update.</li>
        <li>After finish, pick an end node to highlight the shortest path.</li>
      </ul>
    </div>
  </div>
</div>

<script>
(function(){
  // Canvas and graph state
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  let DPR = window.devicePixelRatio || 1;
  function resizeCanvas(){
    canvas.width = canvas.clientWidth * DPR;
    canvas.height = canvas.clientHeight * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
    render();
  }
  // set initial canvas size to fill panel
  function fitCanvasToParent(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(300, rect.width) * DPR;
    canvas.height = Math.max(200, rect.height) * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  // ensure canvas fills available space
  function adjustCanvasStyle(){
    const parent = canvas.parentElement;
    canvas.style.width = '100%';
    canvas.style.height = (parent.clientHeight - 10) + 'px';
  }
  adjustCanvasStyle();
  fitCanvasToParent();
  window.addEventListener('resize', ()=>{
    adjustCanvasStyle();
    fitCanvasToParent();
    render();
  });

  // Data structures
  let nodes = []; // {id,label,x,y}
  let edges = []; // {id,from,to,weight}
  let nextNodeId = 1;
  let nextEdgeId = 1;

  // Interaction
  let mode = 'add-node'; // add-node, add-edge, move, delete
  const modeButtons = {
    'add-node': document.getElementById('mode-add-node'),
    'add-edge': document.getElementById('mode-add-edge'),
    'move': document.getElementById('mode-move'),
    'delete': document.getElementById('mode-delete')
  };
  function setMode(m){
    mode = m;
    for(const k in modeButtons){
      modeButtons[k].classList.toggle('btn-ghost', k !== m);
      modeButtons[k].classList.toggle('small', true);
      modeButtons[k].classList.toggle('active', k === m);
      modeButtons[k].style.background = (k === m ? 'var(--accent)' : (k === 'add-node' ? '' : 'transparent'));
      modeButtons[k].style.color = (k === m ? '#fff' : (k === 'add-node' ? '' : 'var(--accent)'));
      if(k === 'add-node' && m !== 'add-node'){
        // restore style of add-node as ghost when not active
        modeButtons[k].classList.toggle('btn-ghost', true);
      }
    }
    // specific visuals
    for(const k in modeButtons){
      modeButtons[k].style.background = (k === m ? 'var(--accent)' : '');
      modeButtons[k].style.color = (k === m ? '#fff' : '');
      modeButtons[k].classList.toggle('btn-ghost', k !== m);
    }
  }
  setMode(mode);

  modeButtons['add-node'].addEventListener('click', ()=>setMode('add-node'));
  modeButtons['add-edge'].addEventListener('click', ()=>setMode('add-edge'));
  modeButtons['move'].addEventListener('click', ()=>setMode('move'));
  modeButtons['delete'].addEventListener('click', ()=>setMode('delete'));

  const defaultWeightInput = document.getElementById('defaultWeight');
  const directedCheckbox = document.getElementById('directed');

  // selection state for add-edge
  let edgeFromNode = null;

  // dragging
  let draggingNode = null;
  let dragOffset = {x:0,y:0};

  // helper finders
  function nodeAt(x,y){
    return nodes.find(n=>{
      const dx = n.x - x, dy = n.y - y;
      return Math.sqrt(dx*dx+dy*dy) <= 20;
    });
  }
  function edgeAt(x,y){
    // pick if click near segment midpoint within 8px
    for(const e of edges){
      const a = nodes.find(n=>n.id===e.from);
      const b = nodes.find(n=>n.id===e.to);
      if(!a||!b) continue;
      const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;
      const dx = mx - x, dy = my - y;
      if(Math.sqrt(dx*dx+dy*dy) < 12) return e;
    }
    return null;
  }

  // canvas event handling
  canvas.addEventListener('mousedown', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;

    if(mode === 'add-node'){
      addNode(x,y);
      render();
      return;
    }
    if(mode === 'add-edge'){
      const n = nodeAt(x,y);
      if(!n) return;
      if(!edgeFromNode){
        edgeFromNode = n;
      } else {
        if(edgeFromNode.id === n.id){
          edgeFromNode = null;
          render();
          return;
        }
        const w = parseFloat(prompt('Edge weight (positive number):', defaultWeightInput.value || '1'));
        if(isFinite(w) && w >= 0){
          addEdge(edgeFromNode.id, n.id, w);
        }
        edgeFromNode = null;
        render();
      }
      render();
      return;
    }
    if(mode === 'move'){
      const n = nodeAt(x,y);
      if(n){
        draggingNode = n;
        dragOffset.x = x - n.x;
        dragOffset.y = y - n.y;
      }
    }
    if(mode === 'delete'){
      const n = nodeAt(x,y);
      if(n){
        if(confirm('Delete node "'+n.label+'"? This removes connected edges.')){
          deleteNode(n.id);
          render();
        }
        return;
      }
      const e = edgeAt(x,y);
      if(e){
        if(confirm('Delete edge '+labelEdge(e)+'?')){
          deleteEdge(e.id);
          render();
        }
      }
    }
  });

  canvas.addEventListener('mousemove', (ev)=>{
    if(draggingNode && mode === 'move'){
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      draggingNode.x = x - dragOffset.x;
      draggingNode.y = y - dragOffset.y;
      render();
    }
  });

  window.addEventListener('mouseup', ()=>{
    draggingNode = null;
  });

  // Add, delete helpers
  function addNode(x,y){
    const id = nextNodeId++;
    const label = String.fromCharCode(64 + id); // A,B,C,... maybe beyond Z becomes symbols
    nodes.push({id:id, label:label, x:x, y:y});
    updateNodeEdgeCounts();
    rebuildNodeSelects();
  }
  function deleteNode(id){
    nodes = nodes.filter(n=>n.id!==id);
    edges = edges.filter(e=> e.from!==id && e.to!==id);
    updateNodeEdgeCounts();
    rebuildNodeSelects();
  }
  function addEdge(from,to,weight){
    const id = nextEdgeId++;
    edges.push({id:id,from:from,to:to,weight:weight});
    // if undirected, also add reverse? We will treat edges as directed by default; if user wants undirected, they can toggle directed OFF when creating edges.
    if(!directedCheckbox.checked){
      // also add reverse implicitly as another edge? For clarity, we create symmetric edge entry to act as undirected
      edges.push({id: nextEdgeId++, from: to, to: from, weight: weight});
    }
    updateNodeEdgeCounts();
  }
  function deleteEdge(id){
    edges = edges.filter(e=>e.id!==id);
    updateNodeEdgeCounts();
  }
  function labelEdge(e){
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    return `${a? a.label : e.from}→${b? b.label : e.to} (w=${e.weight})`;
  }

  // Rendering
  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // background grid
    drawGrid();
    // draw edges
    for(const e of edges){
      drawEdge(e);
    }
    // draw placeholder for edge-from when adding edge
    if(edgeFromNode){
      drawNode(edgeFromNode, {highlight:true, ghostTarget: lastMousePos});
    }
    // draw nodes
    for(const n of nodes){
      drawNode(n);
    }
    // draw UI overlays: selected edge-from indicator
    // no-op
    updateLists();
  }

  function drawGrid(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.0)';
    ctx.fillRect(0,0,w,h);
    // subtle grid
    ctx.strokeStyle = 'rgba(15,23,42,0.03)';
    ctx.lineWidth = 1;
    const step = 40;
    for(let x=0;x<w;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0;y<h;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawEdge(e){
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    if(!a||!b) return;
    const dx = b.x - a.x, dy = b.y - a.y;
    const len = Math.sqrt(dx*dx + dy*dy);
    if(len < 1) return;
    const ux = dx/len, uy = dy/len;
    const startX = a.x + ux*20, startY = a.y + uy*20;
    const endX = b.x - ux*20, endY = b.y - uy*20;

    ctx.save();
    // edge line
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(15,23,42,0.14)';
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // arrow for directed graphs
    if(directedCheckbox.checked){
      ctx.beginPath();
      const arwLen = 10;
      const px = endX, py = endY;
      ctx.fillStyle = 'rgba(15,23,42,0.6)';
      ctx.moveTo(px,py);
      ctx.lineTo(px - ux*arwLen - uy*6, py - uy*arwLen + ux*6);
      ctx.lineTo(px - ux*arwLen + uy*6, py - uy*arwLen - ux*6);
      ctx.closePath();
      ctx.fill();
    }

    // weight label
    ctx.fillStyle = 'rgba(2,6,23,0.8)';
    ctx.font = '12px sans-serif';
    const mx = (startX + endX)/2;
    const my = (startY + endY)/2;
    ctx.fillText(String(e.weight), mx + 8, my + 4);
    ctx.restore();
  }

  function drawNode(n, opts = {}){
    const x = n.x, y = n.y;
    // determine state from algorithm visualization
    const state = algStateForNode(n.id);
    const r = 20;
    ctx.save();
    // shadow
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = 'rgba(15,23,42,0.08)';
    ctx.lineWidth = 1;
    // fill based on state
    let fill = '#ffffff';
    let stroke = 'rgba(15,23,42,0.25)';
    if(state){
      if(state.isCurrent) fill = '#fee2e2'; // current exploring red-ish
      else if(state.visited) fill = '#ecfdf5'; // visited green-ish
      else if(state.inQueue) fill = '#fff7ed'; // frontier orange-ish
    }

    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = 'rgba(15,23,42,0.12)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // label
    ctx.fillStyle = '#0f172a';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.label, x, y - 2);

    // distance badge
    const distText = (distances && distances.hasOwnProperty(n.id) && distances[n.id] < Infinity) ? String(distances[n.id]) : '∞';
    ctx.fillStyle = 'rgba(2,6,23,0.6)';
    ctx.font = '11px sans-serif';
    ctx.fillText(distText, x, y + 14);

    ctx.restore();
  }

  // Algorithm visualization state
  let distances = {}; // nodeId -> dist
  let prev = {}; // nodeId -> previous node id in shortest path
  let visited = {}; // nodeId -> bool (settled)
  let inQueue = {}; // nodeId -> bool
  let currentNodeId = null;

  function algStateForNode(nodeId){
    if(!started) return null;
    return {
      visited: !!visited[nodeId],
      inQueue: !!inQueue[nodeId],
      isCurrent: currentNodeId === nodeId
    };
  }

  // UI list updates
  function updateNodeEdgeCounts(){
    document.getElementById('nodeCount').textContent = nodes.length;
    document.getElementById('edgeCount').textContent = edges.length;
    rebuildNodeSelects();
    updateLists();
  }

  function rebuildNodeSelects(){
    const startSel = document.getElementById('startSelect');
    const endSel = document.getElementById('endSelect');
    const oldStart = startSel.value;
    const oldEnd = endSel.value;
    startSel.innerHTML = '';
    endSel.innerHTML = '<option value="">(none)</option>';
    nodes.forEach(n=>{
      const o = document.createElement('option');
      o.value = n.id;
      o.textContent = n.label + ' ('+n.id+')';
      startSel.appendChild(o);
      const oe = o.cloneNode(true);
      endSel.appendChild(oe);
    });
    if(nodes.length) startSel.value = oldStart || nodes[0].id;
    endSel.value = oldEnd || '';
  }

  function updateLists(){
    // distances
    const distList = document.getElementById('distList');
    distList.innerHTML = '';
    if(nodes.length === 0){
      distList.textContent = '(no nodes)';
    } else {
      nodes.forEach(n=>{
        const div = document.createElement('div');
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.style.padding = '6px';
        div.style.borderBottom = '1px dashed #eef2ff';
        const left = document.createElement('div');
        left.textContent = n.label;
        left.style.fontWeight = '600';
        const right = document.createElement('div');
        right.style.color = 'rgba(2,6,23,0.6)';
        const d = (distances && distances.hasOwnProperty(n.id) && distances[n.id] < Infinity) ? distances[n.id] : '∞';
        right.textContent = d + (prev[n.id] ? (' ← '+(nodes.find(nn=>nn.id===prev[n.id])?.label || prev[n.id])) : '');
        div.appendChild(left);
        div.appendChild(right);
        distList.appendChild(div);
      });
    }

    // PQ
    const pqDiv = document.getElementById('pqList');
    pqDiv.innerHTML = '';
    if(Object.keys(inQueue || {}).filter(k=>inQueue[k]).length === 0){
      pqDiv.textContent = '(empty)';
    } else {
      // show sorted by distances
      const items = Object.keys(inQueue).filter(k=>inQueue[k]).map(k=>({id:+k,dist:distances[k]}));
      items.sort((a,b)=> (a.dist === undefined ? Infinity : a.dist) - (b.dist===undefined?Infinity:b.dist));
      items.forEach(it=>{
        const row = document.createElement('div');
        row.className = 'pq-item';
        const lbl = document.createElement('div');
        lbl.textContent = (nodes.find(n=>n.id===it.id)?.label || it.id);
        const d = document.createElement('div');
        d.textContent = it.dist;
        d.style.opacity = '0.85';
        row.appendChild(lbl); row.appendChild(d);
        pqDiv.appendChild(row);
      });
    }

    // node list
    const nodeList = document.getElementById('nodeList');
    nodeList.innerHTML = '';
    nodes.forEach(n=>{
      const d = document.createElement('div');
      d.textContent = n.label + ' ('+n.id+')';
      d.style.padding = '4px 6px';
      nodeList.appendChild(d);
    });

    // edge list
    const edgeList = document.getElementById('edgeList');
    edgeList.innerHTML = '';
    edges.forEach(e=>{
      const el = document.createElement('div');
      el.textContent = labelEdge(e);
      el.style.padding = '4px 6px';
      edgeList.appendChild(el);
    });
  }

  // Dijkstra algorithm implementation with generator for step-by-step
  function* dijkstraGenerator(startId){
    // Build adjacency list from edges
    const adj = {};
    nodes.forEach(n => adj[n.id] = []);
    edges.forEach(e => {
      if(adj[e.from]) adj[e.from].push({to: e.to, w: e.weight, edgeId:e.id});
    });
    // initialize
    distances = {};
    prev = {};
    visited = {};
    inQueue = {};
    currentNodeId = null;
    nodes.forEach(n => { distances[n.id] = Infinity; prev[n.id] = null; visited[n.id] = false; inQueue[n.id] = false; });
    distances[startId] = 0;
    // simple PQ using array; store candidate nodes
    const pq = [];
    pqPush(pq, startId, distances[startId]); inQueue[startId] = true;
    yield {type:'init', distances: {...distances}, prev: {...prev}, pq: pq.slice()};
    while(pq.length){
      // pop min
      const u = pqPop(pq);
      currentNodeId = u;
      if(visited[u]) { yield {type:'skip', u}; continue; }
      // settle u
      visited[u] = true;
      inQueue[u] = false;
      yield {type:'visit', u, distances: {...distances}, prev: {...prev}};
      // relax edges
      const neighbors = adj[u] || [];
      for(const {to:v, w, edgeId} of neighbors){
        yield {type:'exam', u, v, w};
        if(visited[v]) { yield {type:'exam-done', u,v}; continue; }
        const alt = distances[u] + w;
        if(alt < distances[v]){
          distances[v] = alt;
          prev[v] = u;
          pqPush(pq, v, alt);
          inQueue[v] = true;
          yield {type:'update', v, newDist:alt, prev: u, pq: pq.slice(), distances: {...distances}};
        } else {
          yield {type:'no-update', v, alt, distances: {...distances}};
        }
      }
    }
    currentNodeId = null;
    yield {type:'done', distances: {...distances}, prev: {...prev}};
  }

  // simple PQ helpers
  function pqPush(pq, nodeId, dist){
    pq.push({id:nodeId, dist:dist});
    // keep sorted by dist ascending
    pq.sort((a,b)=> a.dist - b.dist);
  }
  function pqPop(pq){
    if(pq.length===0) return null;
    return pq.shift().id;
  }

  // Controls: run, step, reset, pause, speed
  let generator = null;
  let autoplay = false;
  let animInterval = null;
  let animSpeed = 1; // multiplier (1x)
  let started = false;

  const btnRun = document.getElementById('btn-run');
  const btnStep = document.getElementById('btn-step');
  const btnPause = document.getElementById('btn-pause');
  const btnReset = document.getElementById('btn-reset');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');

  btnRun.addEventListener('click', ()=>{
    if(!nodes.length){
      alert('No nodes to run on.');
      return;
    }
    const startVal = document.getElementById('startSelect').value;
    if(!startVal){ alert('Select a start node.'); return; }
    if(generator == null){
      generator = dijkstraGenerator(+startVal);
    }
    autoplay = true;
    btnRun.disabled = true;
    btnPause.disabled = false;
    btnStep.disabled = true;
    stepAnimation();
  });

  btnStep.addEventListener('click', ()=>{
    if(!nodes.length){ alert('No nodes.'); return; }
    const startVal = document.getElementById('startSelect').value;
    if(!startVal){ alert('Select a start node.'); return; }
    if(generator == null){
      generator = dijkstraGenerator(+startVal);
      started = true;
    }
    const r = generator.next();
    handleGeneratorResult(r.value);
  });

  btnPause.addEventListener('click', ()=>{
    autoplay = false;
    generator = null;
    btnRun.disabled = false;
    btnStep.disabled = false;
    btnPause.disabled = true;
    started = false;
    currentNodeId = null;
    render();
  });

  btnReset.addEventListener('click', ()=>{
    generator = null;
    autoplay = false;
    started = false;
    distances = {};
    prev = {};
    visited = {};
    inQueue = {};
    currentNodeId = null;
    render();
  });

  speedRange.addEventListener('input', ()=>{
    animSpeed = parseFloat(speedRange.value);
    speedLabel.textContent = animSpeed + 'x';
  });

  function stepAnimation(){
    if(!autoplay) return;
    // schedule steps with interval inversely proportional to animSpeed
    const delay = Math.max(120, 600 / animSpeed);
    if(animInterval) clearInterval(animInterval);
    animInterval = setInterval(()=>{
      if(!autoplay) { clearInterval(animInterval); return; }
      if(!generator){
        const startVal = document.getElementById('startSelect').value;
        if(!startVal) return;
        generator = dijkstraGenerator(+startVal);
      }
      const r = generator.next();
      if(r.done || !r.value){
        autoplay = false;
        generator = null;
        clearInterval(animInterval);
        btnRun.disabled = false;
        btnStep.disabled = false;
        btnPause.disabled = true;
        started = false;
        currentNodeId = null;
        render();
        return;
      }
      handleGeneratorResult(r.value);
    }, delay);
  }

  function handleGeneratorResult(val){
    if(!val) return;
    const t = val.type;
    if(t === 'init'){
      distances = val.distances;
      prev = val.prev;
      inQueue = {};
      Object.keys(val.distances).forEach(k=> inQueue[k]=false);
      val.pq.forEach(p => inQueue[p.id] = true);
      started = true;
      currentNodeId = null;
      render();
    } else if(t === 'visit'){
      distances = val.distances;
      prev = val.prev;
      visited[val.u] = true;
      inQueue[val.u] = false;
      currentNodeId = val.u;
      render();
    } else if(t === 'exam'){
      // mark current node
      currentNodeId = val.u;
      render();
    } else if(t === 'update'){
      distances = val.distances;
      prev = val.prev;
      inQueue[val.v] = true;
      currentNodeId = val.u;
      render();
    } else if(t === 'no-update' || t === 'exam-done'){
      // just update state visuals
      distances = val.distances || distances;
      render();
    } else if(t === 'done'){
      distances = val.distances;
      prev = val.prev;
      visited = {};
      Object.keys(distances).forEach(k => visited[k] = true);
      currentNodeId = null;
      started = false;
      generator = null;
      autoplay = false;
      btnRun.disabled = false;
      btnStep.disabled = false;
      btnPause.disabled = true;
      render();
      alert('Dijkstra complete.');
    }
    updateLists();
  }

  // export/import
  document.getElementById('btn-export').addEventListener('click', ()=>{
    const data = {nodes, edges, nextNodeId, nextEdgeId, directed: directedCheckbox.checked};
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'graph-dijkstra.json';
    a.click();
    URL.revokeObjectURL(url);
  });
  document.getElementById('btn-import').addEventListener('click', ()=>{
    document.getElementById('fileInput').click();
  });
  document.getElementById('fileInput').addEventListener('change', (ev)=>{
    const file = ev.target.files[0];
    if(!file) return;
    const fr = new FileReader();
    fr.onload = function(e){
      try{
        const data = JSON.parse(e.target.result);
        nodes = data.nodes || [];
        edges = data.edges || [];
        nextNodeId = data.nextNodeId || (nodes.length + 1);
        nextEdgeId = data.nextEdgeId || (edges.length + 1);
        directedCheckbox.checked = data.directed || false;
        rebuildNodeSelects();
        updateNodeEdgeCounts();
        render();
      }catch(err){
        alert('Could not import: ' + err.message);
      }
    }
    fr.readAsText(file);
    ev.target.value = '';
  });

  // utility to compute shortest path for highlighting
  function highlightPathTo(targetId){
    if(!prev || !prev[targetId]) return [];
    const path = [];
    let cur = +targetId;
    while(cur != null){
      path.push(cur);
      cur = prev[cur];
      if(cur === null) break;
    }
    return path.reverse();
  }

  // highlight path when user selects end node
  document.getElementById('endSelect').addEventListener('change', ()=>{
    const val = document.getElementById('endSelect').value;
    if(!val) { render(); return; }
    if(!prev || !Object.keys(prev).length){
      alert('No shortest path data available. Run Dijkstra first.');
      document.getElementById('endSelect').value = '';
      return;
    }
    const path = highlightPathTo(+val);
    if(path.length <= 1){
      alert('No path to selected node.');
      return;
    }
    // draw path overlay
    render();
    // draw path edges
    ctx.save();
    ctx.strokeStyle = 'rgba(59,130,246,0.9)';
    ctx.lineWidth = 4;
    for(let i=0;i<path.length-1;i++){
      const a = nodes.find(n=>n.id===path[i]);
      const b = nodes.find(n=>n.id===path[i+1]);
      if(!a||!b) continue;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }
    // highlight nodes
    for(const id of path){
      const n = nodes.find(nn=>nn.id===id);
      if(!n) continue;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(59,130,246,0.08)';
      ctx.arc(n.x, n.y, 26, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(59,130,246,0.2)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  });

  // small utilities
  function clearAll(){
    nodes = [];
    edges = [];
    nextNodeId = 1;
    nextEdgeId = 1;
    distances = {};
    prev = {};
    visited = {};
    inQueue = {};
    generator = null;
    started = false;
    currentNodeId = null;
    edgeFromNode = null;
    updateNodeEdgeCounts();
    rebuildNodeSelects();
    render();
  }
  document.getElementById('btn-clear').addEventListener('click', ()=>{
    if(confirm('Clear entire graph?')){
      clearAll();
    }
  });

  // initial UI state
  rebuildNodeSelects();
  updateNodeEdgeCounts();
  render();

  // track last mouse pos for ghost rendering
  let lastMousePos = null;
  canvas.addEventListener('mousemove', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    lastMousePos = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};
    if(edgeFromNode) render();
  });

  // helper: when new edges are created with directed toggling OFF we added symmetric entries.
  // If the user wants strictly directed graphs, they can check "Directed" to avoid symmetry.

  // Small helper to prepopulate sample graph for users (optional)
  // Let's add a sample graph on first load for demonstration
  (function prepopulate(){
    // Only prepopulate if graph empty
    if(nodes.length === 0){
      addNode(100,100); addNode(260,80); addNode(420,130); addNode(160,230); addNode(360,240);
      addEdge(1,2,2); addEdge(2,3,3); addEdge(1,4,6); addEdge(4,5,1); addEdge(5,3,1); addEdge(2,4,2);
      // For undirected default, those edges will be duplicated unless directed is checked
      directedCheckbox.checked = true;
      updateNodeEdgeCounts();
      render();
    }
  })();

})();
</script>
</body>
</html>