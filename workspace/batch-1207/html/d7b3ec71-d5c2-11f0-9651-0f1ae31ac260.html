<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dijkstra’s Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    background: #20232a;
    color: white;
    padding: 10px 20px;
    text-align: center;
  }
  #container {
    display: flex;
    flex-grow: 1;
    background: #f0f0f0;
  }
  #graph-container {
    flex: 2;
    position: relative;
    background: white;
    border-right: 2px solid #ccc;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  svg {
    width: 100%;
    height: 100%;
  }
  #controls {
    flex: 1;
    padding: 20px;
    box-sizing: border-box;
    background: #fafafa;
  }
  h2 {
    margin-top: 0;
  }
  label {
    display: block;
    margin-top: 15px;
    margin-bottom: 5px;
    font-weight: bold;
  }
  select, button {
    width: 100%;
    padding: 8px;
    font-size: 1rem;
  }
  #log {
    margin-top: 20px;
    height: 250px;
    overflow-y: auto;
    background: #222;
    color: #eee;
    font-family: monospace;
    padding: 10px;
    border-radius: 4px;
    white-space: pre-wrap;
  }
  .node {
    cursor: pointer;
    transition: fill 0.3s, stroke 0.3s;
  }
  .node circle {
    stroke: #333;
    stroke-width: 2px;
    fill: #61dafb;
    transition: fill 0.3s;
  }
  .node text {
    pointer-events: none;
    user-select: none;
    font-weight: bold;
    fill: #222;
  }
  .edge {
    stroke: #999;
    stroke-width: 2px;
    fill: none;
    marker-end: url(#arrowhead);
    transition: stroke 0.3s;
  }
  .edge-label {
    fill: #666;
    font-size: 0.8rem;
    user-select: none;
  }
  .visited circle {
    fill: #95d6a4;
  }
  .current circle {
    fill: #f9d976;
    stroke: #f39c12;
    stroke-width: 4px;
  }
  .path-edge {
    stroke: #f39c12;
    stroke-width: 4px;
  }
  .final-node circle {
    fill: #f87171;
    stroke: #c53030;
    stroke-width: 4px;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  footer {
    text-align: center;
    padding: 8px;
    font-size: 0.8rem;
    background: #20232a;
    color: white;
  }

</style>
</head>
<body>
<header>
  <h1>Dijkstra’s Algorithm Visualization</h1>
</header>
<div id="container">
  <div id="graph-container">
    <svg id="graph" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600" aria-label="Graph visualization"></svg>
  </div>
  <div id="controls">
    <h2>Controls</h2>
    <label for="startNode">Start Node:</label>
    <select id="startNode"></select>

    <label for="endNode">End Node (optional):</label>
    <select id="endNode">
      <option value="">None (show all shortest distances)</option>
    </select>

    <button id="startBtn">Start Algorithm</button>
    <button id="stepBtn" disabled>Next Step</button>
    <button id="resetBtn" disabled>Reset</button>

    <div id="log" aria-live="polite" aria-atomic="true"></div>
  </div>
</div>
<footer>
  Created by ChatGPT &mdash; Demonstration of Dijkstra’s Algorithm
</footer>

<script>
// Hardcoded graph data (nodes and edges with weights)
const nodes = [
  {id: 'A', x: 150, y: 100},
  {id: 'B', x: 400, y: 80},
  {id: 'C', x: 650, y: 120},
  {id: 'D', x: 200, y: 300},
  {id: 'E', x: 450, y: 300},
  {id: 'F', x: 650, y: 320},
  {id: 'G', x: 350, y: 480},
  {id: 'H', x: 600, y: 500},
];

const edges = [
  {from: 'A', to: 'B', weight: 4},
  {from: 'A', to: 'D', weight: 2},
  {from: 'B', to: 'C', weight: 3},
  {from: 'B', to: 'E', weight: 2},
  {from: 'C', to: 'F', weight: 4},
  {from: 'D', to: 'E', weight: 3},
  {from: 'D', to: 'G', weight: 4},
  {from: 'E', to: 'F', weight: 1},
  {from: 'E', to: 'G', weight: 1},
  {from: 'F', to: 'H', weight: 2},
  {from: 'G', to: 'H', weight: 3},
];

// Bidirectional edges for undirected graph
// We'll add reverse edges too for convenience in adjacency list
const allEdges = [];
edges.forEach(e => {
  allEdges.push(e);
  allEdges.push({from: e.to, to: e.from, weight: e.weight});
});

// Build adjacency list
const adjacencyList = {};
nodes.forEach(n => {
  adjacencyList[n.id] = [];
});
allEdges.forEach(e => {
  adjacencyList[e.from].push({to: e.to, weight: e.weight});
});

// Globals to manage state
let distances = {};
let previous = {};
let visited = {};
let unvisitedSet = new Set();
let currentNode = null;
let finished = false;
let endNode = null;

const svg = document.getElementById('graph');
const logDiv = document.getElementById('log');

const startSelect = document.getElementById('startNode');
const endSelect = document.getElementById('endNode');
const startBtn = document.getElementById('startBtn');
const stepBtn = document.getElementById('stepBtn');
const resetBtn = document.getElementById('resetBtn');

function log(msg) {
  logDiv.textContent += msg + '\n';
  logDiv.scrollTop = logDiv.scrollHeight;
}

function clearLog() {
  logDiv.textContent = '';
}

// Populate start and end selects
function populateSelects() {
  nodes.forEach(n => {
    const optionStart = document.createElement('option');
    optionStart.value = n.id;
    optionStart.textContent = n.id;
    startSelect.appendChild(optionStart);

    const optionEnd = document.createElement('option');
    optionEnd.value = n.id;
    optionEnd.textContent = n.id;
    endSelect.appendChild(optionEnd);
  });
}

// Draw arrowhead marker for edges
function defineArrowMarker() {
  const ns = "http://www.w3.org/2000/svg";
  const marker = document.createElementNS(ns, 'marker');
  marker.setAttribute('id', 'arrowhead');
  marker.setAttribute('markerWidth', '10');
  marker.setAttribute('markerHeight', '7');
  marker.setAttribute('refX', '10');
  marker.setAttribute('refY', '3.5');
  marker.setAttribute('orient', 'auto');
  marker.setAttribute('markerUnits', 'strokeWidth');

  const path = document.createElementNS(ns, 'path');
  path.setAttribute('d', 'M0,0 L10,3.5 L0,7 Z');
  path.setAttribute('fill', '#999');
  marker.appendChild(path);

  const defs = document.createElementNS(ns, 'defs');
  defs.appendChild(marker);
  svg.appendChild(defs);
}

// Clear SVG
function clearSVG() {
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
  defineArrowMarker();
}

// Draw edges
function drawEdges(highlightEdges = new Set()) {
  const ns = "http://www.w3.org/2000/svg";
  // Draw edges below nodes
  edges.forEach(({from, to, weight}, i) => {
    const fromNode = nodes.find(n => n.id === from);
    const toNode = nodes.find(n => n.id === to);
    // Draw line with some offset from center to keep arrow visible
    const dx = toNode.x - fromNode.x;
    const dy = toNode.y - fromNode.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = 25;
    const startX = fromNode.x + (dx/dist)*offset;
    const startY = fromNode.y + (dy/dist)*offset;
    const endX = toNode.x - (dx/dist)*offset;
    const endY = toNode.y - (dy/dist)*offset;

    const line = document.createElementNS(ns, 'line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', startY);
    line.setAttribute('x2', endX);
    line.setAttribute('y2', endY);
    line.setAttribute('class', 'edge');

    // Highlight if edge is part of shortest path tree or current path
    if (highlightEdges.has(from + '->' + to) || highlightEdges.has(to + '->' + from)) {
      line.classList.add('path-edge');
      line.setAttribute('stroke', '#f39c12');
      line.setAttribute('stroke-width', 4);
      line.removeAttribute('marker-end'); // remove arrow on highlighted path edges to keep clean
    } else {
      line.setAttribute('stroke', '#999');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('marker-end', 'url(#arrowhead)');
    }

    svg.appendChild(line);

    // Edge label
    const label = document.createElementNS(ns, 'text');
    label.setAttribute('class', 'edge-label');
    label.setAttribute('x', (startX + endX) / 2);
    label.setAttribute('y', (startY + endY) / 2 - 5);
    label.textContent = weight;
    svg.appendChild(label);
  });
}

function drawNodes() {
  const ns = "http://www.w3.org/2000/svg";

  nodes.forEach(n => {
    const group = document.createElementNS(ns, 'g');
    group.setAttribute('class', 'node');
    group.setAttribute('tabindex', '0');
    group.setAttribute('aria-label', `Node ${n.id}`);
    group.dataset.id = n.id;

    const circle = document.createElementNS(ns, 'circle');
    circle.setAttribute('cx', n.x);
    circle.setAttribute('cy', n.y);
    circle.setAttribute('r', 20);

    const text = document.createElementNS(ns, 'text');
    text.setAttribute('x', n.x);
    text.setAttribute('y', n.y + 6);
    text.setAttribute('text-anchor', 'middle');
    text.textContent = n.id;

    group.appendChild(circle);
    group.appendChild(text);
    svg.appendChild(group);
  });
}

// Update nodes colors depending on state
function updateNodes() {
  const nodeGroups = svg.querySelectorAll('.node');
  nodeGroups.forEach(g => {
    const id = g.dataset.id;
    g.classList.remove('visited', 'current', 'final-node');
    if (id === currentNode) {
      g.classList.add('current');
    } else if (visited[id]) {
      g.classList.add('visited');
    }
    if (finished && endNode && id === endNode) {
      g.classList.add('final-node');
    }
    // Show distance as tooltip (title)
    const circle = g.querySelector('circle');
    const dist = distances[id];
    if (dist === Infinity) {
      circle.setAttribute('title', 'Distance: ∞');
    } else {
      circle.setAttribute('title', `Distance: ${dist}`);
    }
  });
}

// Highlight edges that form shortest path tree or path
function getHighlightEdges() {
  const edgesSet = new Set();
  for (const [node, prev] of Object.entries(previous)) {
    if (prev) {
      edgesSet.add(prev + '->' + node);
    }
  }
  if (finished && endNode) {
    // Show shortest path edges from start to end
    let pathNode = endNode;
    while (previous[pathNode]) {
      const p = previous[pathNode];
      edgesSet.add(p + '->' + pathNode);
      pathNode = p;
    }
  }
  return edgesSet;
}

// Initialize algorithm variables & state
function initialize(start) {
  distances = {};
  previous = {};
  visited = {};
  unvisitedSet = new Set();

  nodes.forEach(n => {
    distances[n.id] = Infinity;
    previous[n.id] = null;
    visited[n.id] = false;
    unvisitedSet.add(n.id);
  });

  distances[start] = 0;
  currentNode = null;
  finished = false;
  endNode = endSelect.value || null;
  clearLog();
  log(`Algorithm initialized with start node ${start}.`);
}

// Get unvisited node with smallest distance
function getNextNode() {
  let minDist = Infinity;
  let minNode = null;
  unvisitedSet.forEach(node => {
    if (distances[node] < minDist) {
      minDist = distances[node];
      minNode = node;
    }
  });
  return minNode;
}

// Perform one step of Dijkstra's Algorithm
function step() {
  if (finished) return;

  if (currentNode === null) {
    currentNode = getNextNode();
    if (currentNode === null) {
      finished = true;
      log("All nodes visited, algorithm finished.");
      return;
    }
    log(`Selected starting node ${currentNode} with distance 0.`);
  } else {
    // Mark current node visited
    visited[currentNode] = true;
    unvisitedSet.delete(currentNode);
    log(`Visiting node ${currentNode} with current distance ${distances[currentNode]}.`);

    // Update distances of neighbors
    adjacencyList[currentNode].forEach(({to, weight}) => {
      if (!visited[to]) {
        const newDist = distances[currentNode] + weight;
        if (newDist < distances[to]) {
          distances[to] = newDist;
          previous[to] = currentNode;
          log(`Updated distance of node ${to} to ${newDist} (via ${currentNode}).`);
        } else {
          log(`Node ${to} not updated; current distance ${distances[to]} <= new distance ${newDist}.`);
        }
      }
    });

    // Select next node
    currentNode = getNextNode();
    if (currentNode === null) {
      finished = true;
      log("All reachable nodes visited, algorithm finished.");
    } else {
      log(`Next node to visit: ${currentNode} with distance ${distances[currentNode]}.`);
    }
  }

  updateVisualization();
}

function updateVisualization() {
  clearSVG();
  const highlightEdges = getHighlightEdges();
  drawEdges(highlightEdges);
  drawNodes();
  updateNodes();

  // Show final shortest path if finished and endNode selected
  if (finished && endNode) {
    let path = [];
    let stepNode = endNode;
    if (distances[endNode] === Infinity) {
      log(`No path to node ${endNode} found.`);
    } else {
      while (stepNode !== null) {
        path.unshift(stepNode);
        stepNode = previous[stepNode];
      }
      log(`Shortest path to node ${endNode}: ${path.join(' -> ')} (total cost: ${distances[endNode]})`);
    }
  }
}

function startAlgorithm() {
  const startNodeId = startSelect.value;
  if (!startNodeId) {
    alert('Please select a start node.');
    return;
  }
  initialize(startNodeId);
  updateVisualization();

  startBtn.disabled = true;
  stepBtn.disabled = false;
  resetBtn.disabled = false;
}

function resetAlgorithm() {
  distances = {};
  previous = {};
  visited = {};
  unvisitedSet = new Set();
  currentNode = null;
  finished = false;
  clearLog();

  startBtn.disabled = false;
  stepBtn.disabled = true;
  resetBtn.disabled = true;

  clearSVG();
  drawEdges();
  drawNodes();
}

function onEndNodeChange() {
  // Nothing special needed here for now, just allow selection
}

// Initialization
function init() {
  populateSelects();
  clearSVG();
  drawEdges();
  drawNodes();

  startBtn.addEventListener('click', startAlgorithm);
  stepBtn.addEventListener('click', step);
  resetBtn.addEventListener('click', resetAlgorithm);
  endSelect.addEventListener('change', onEndNodeChange);

  // Initialize buttons states
  stepBtn.disabled = true;
  resetBtn.disabled = true;
}

init();

</script>
</body>
</html>