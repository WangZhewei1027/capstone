<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Linear Regression Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:#f6f8fa; color:#111; }
    .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
    .left { flex:1 1 0; display:flex; flex-direction:column; gap:8px; }
    .canvas-wrap { flex:1; background:white; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; display:flex; flex-direction:column; }
    canvas { width:100%; height:100%; background:linear-gradient(180deg,#ffffff,#fbfdff); border-radius:6px; cursor:crosshair; display:block; }
    .controls { width:360px; flex:0 0 360px; display:flex; flex-direction:column; gap:8px; }
    .panel { background:white; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    label { font-size:13px; color:#333; }
    input[type=range] { width:160px; }
    button { background:#2563eb; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    button.ghost { background:transparent; border:1px solid #cbd5e1; color:#111; }
    small.gray { color:#666; display:block; margin-top:6px; }
    .stats { font-family:monospace; white-space:pre; font-size:13px; color:#111; }
    .hint { font-size:13px; color:#444; }
    .muted { color:#666; font-size:13px; }
    .checkbox { display:flex; gap:6px; align-items:center; }
    .point-list { max-height:160px; overflow:auto; border-top:1px dashed #eee; padding-top:8px; }
    .point-row { display:flex; justify-content:space-between; gap:8px; padding:4px 0; border-bottom:1px dashed #fafafa; }
    .small-btn { background:#eef2ff; color:#1e3a8a; border:none; padding:6px 8px; border-radius:6px; cursor:pointer; }
    .center { display:flex; gap:8px; align-items:center; }
    .footer { font-size:12px; color:#666; text-align:center; margin-top:8px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="canvas-wrap panel">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <div>
            <strong>Linear Regression — Interactive</strong>
            <div class="muted" style="margin-top:4px;">Click to add a point. Drag to move. Double-click to remove a point.</div>
          </div>
          <div class="muted">Points: <span id="count">0</span></div>
        </div>
        <canvas id="chart"></canvas>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center;justify-content:space-between;">
          <div class="muted">X,Y scaled 0–100</div>
          <div class="muted">Click empty area to add point</div>
        </div>
      </div>

      <div class="panel" style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div>
          <div class="muted">Fit type</div>
          <div style="display:flex;gap:8px;margin-top:6px;">
            <button id="btn-ols" class="small-btn">Analytic (OLS)</button>
            <button id="btn-gd" class="small-btn">Gradient Descent</button>
            <button id="btn-reset" class="ghost">Clear</button>
          </div>
        </div>
        <div style="text-align:right;">
          <div class="muted">Residuals</div>
          <div style="margin-top:6px;">
            <label class="checkbox"><input type="checkbox" id="show-res" checked> Show</label>
          </div>
        </div>
      </div>

      <div class="panel" style="display:flex;flex-direction:row;gap:12px;">
        <div style="flex:1;">
          <label>Generate random points</label>
          <div style="display:flex;gap:8px;margin-top:6px;">
            <input id="randN" type="number" min="1" max="200" value="10" style="width:72px;padding:6px;border:1px solid #ddd;border-radius:6px;">
            <button id="btn-gen" class="small-btn">Generate</button>
            <button id="btn-gen-noise" class="ghost">From underlying line</button>
          </div>
          <small class="gray">You can generate random spread or points sampled from a hidden line + noise.</small>
        </div>
        <div style="width:160px;">
          <label>Noise (σ)</label>
          <input id="noise" type="range" min="0" max="30" value="8">
          <div class="muted" style="text-align:right;" id="noiseVal">8</div>
        </div>
      </div>

      <div class="panel" style="display:flex;gap:12px;align-items:center;">
        <div style="flex:1;">
          <label>Gradient Descent settings</label>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center;">
            <div>
              <div class="muted">Learning rate</div>
              <input id="lr" type="range" min="0.0005" max="1" step="0.0005" value="0.01" style="width:180px;">
              <div class="muted" id="lrVal">0.0100</div>
            </div>
            <div>
              <div class="muted">Iterations</div>
              <input id="iters" type="number" min="1" max="100000" value="200" style="width:90px;padding:6px;border:1px solid #ddd;border-radius:6px;">
            </div>
          </div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px;">
          <button id="run-gd" style="background:#10b981;color:white;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;">Run GD</button>
          <button id="stop-gd" class="ghost">Stop</button>
        </div>
      </div>

      <div class="panel" style="display:flex;gap:12px;align-items:flex-start;">
        <div style="flex:1;">
          <div style="display:flex;justify-content:space-between;">
            <label>Statistics & model</label>
            <div class="muted">Updated live</div>
          </div>
          <pre class="stats" id="stats">No data yet.</pre>
        </div>
        <div style="width:160px;">
          <label>Display</label>
          <div style="display:flex;flex-direction:column;gap:6px;margin-top:8px;">
            <label class="checkbox"><input type="checkbox" id="show-ols" checked> Show OLS line</label>
            <label class="checkbox"><input type="checkbox" id="show-gd" checked> Show GD line</label>
            <label class="checkbox"><input type="checkbox" id="show-points" checked> Show points</label>
          </div>
        </div>
      </div>

      <div class="panel" style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div class="muted">Tips: Drag points to see the line update. Use Gradient Descent to watch optimization converge.</div>
        <div class="footer">Made for learning • No libraries • OLS uses normal equations</div>
      </div>
    </div>

    <div class="controls">
      <div class="panel">
        <strong>Point list</strong>
        <div class="point-list" id="pointList"></div>
      </div>

      <div class="panel">
        <strong>Actions</strong>
        <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
          <button id="btn-add-slope" class="ghost">Add points on a line</button>
          <button id="btn-random" class="small-btn">Add one random point</button>
          <button id="btn-center" class="ghost">Center points</button>
        </div>
      </div>

      <div class="panel">
        <strong>About</strong>
        <div style="margin-top:8px;" class="muted">
          Ordinary Least Squares (OLS) analytic solution:
          slope m = cov(x,y) / var(x)
          intercept b = mean(y) - m * mean(x)
          R² = 1 - SSE / SST
        </div>
      </div>
    </div>
  </div>

<script>
/*
Interactive Linear Regression Demo
- Click to add points
- Drag to move points
- Double-click to remove
- Analytic OLS fit computed from data
- Optional Gradient Descent optimizer to fit m and b
- Residuals and R^2 displayed
*/

(() => {
  // Utility & state
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');
  let width = 800, height = 480;
  function resize() {
    // size canvas to container
    const rect = canvas.getBoundingClientRect();
    width = Math.floor(rect.width);
    height = Math.floor(rect.height);
    // set actual canvas pixel size for crispness
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  new ResizeObserver(resize).observe(canvas.parentElement);

  // Internal points: x,y in range [0,100]
  let points = [];
  const pointRadius = 6;
  let dragging = null;
  document.getElementById('count').textContent = points.length;

  // GD state
  let gdRunning = false;
  let gdParams = { m:0, b:0 };
  let gdStep = 0;

  // Hidden "true" line used when generating sample-from-line
  let trueLine = { m: 0.6, b: 30 }; // in 0-100 units

  // DOM elements
  const statsEl = document.getElementById('stats');
  const pointListEl = document.getElementById('pointList');
  const noiseEl = document.getElementById('noise');
  const noiseValEl = document.getElementById('noiseVal');
  const lrEl = document.getElementById('lr');
  const lrValEl = document.getElementById('lrVal');
  const itersEl = document.getElementById('iters');
  const showResEl = document.getElementById('show-res');
  const showOlsEl = document.getElementById('show-ols');
  const showGdEl = document.getElementById('show-gd');
  const showPointsEl = document.getElementById('show-points');

  // initial display
  noiseValEl.textContent = noiseEl.value;
  lrValEl.textContent = Number(lrEl.value).toFixed(4);

  // Mapping between data coords (0..100) and canvas pixels
  const pad = 32;
  function dataToScreen(pt) {
    const x = pad + (pt.x / 100) * (width - pad*2);
    const y = pad + ((100 - pt.y) / 100) * (height - pad*2);
    return { x, y };
  }
  function screenToData(px, py) {
    const x = Math.max(0, Math.min(100, ((px - pad) / (width - pad*2)) * 100));
    const y = Math.max(0, Math.min(100, (1 - ((py - pad) / (height - pad*2))) * 100));
    return { x, y };
  }

  // Drawing functions
  function clearCanvas() {
    ctx.clearRect(0,0,width,height);
  }
  function drawGrid() {
    ctx.save();
    ctx.strokeStyle = '#f1f5f9';
    ctx.lineWidth = 1;
    // vertical lines every 10
    for (let i=0;i<=10;i++) {
      const x = pad + i*(width-2*pad)/10;
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, height-pad);
      ctx.stroke();
    }
    for (let j=0;j<=10;j++) {
      const y = pad + j*(height-2*pad)/10;
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(width-pad, y);
      ctx.stroke();
    }
    // axes border
    ctx.strokeStyle = '#e6eef8';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(pad, pad, width-2*pad, height-2*pad);
    // labels
    ctx.fillStyle = '#556';
    ctx.font = '12px system-ui,Arial';
    ctx.textAlign = 'center';
    for (let i=0;i<=10;i++) {
      const x = pad + i*(width-2*pad)/10;
      ctx.fillText((i*10).toString(), x, height - 6);
    }
    ctx.textAlign = 'right';
    for (let j=0;j<=10;j++) {
      const y = pad + j*(height-2*pad)/10;
      ctx.fillText((100 - j*10).toString(), pad-6, y+4);
    }
    ctx.restore();
  }

  function drawPoints() {
    if (!showPointsEl.checked) return;
    for (let i=0;i<points.length;i++) {
      const p = points[i];
      const s = dataToScreen(p);
      ctx.beginPath();
      ctx.fillStyle = (p === dragging) ? '#ffb86b' : '#1f77b4';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.arc(s.x, s.y, pointRadius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      // index label
      ctx.fillStyle = '#064e3b';
      ctx.font = '11px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(String(i), s.x, s.y+4);
    }
  }

  function drawResiduals(m,b) {
    if (!showResEl.checked) return;
    ctx.save();
    ctx.lineWidth = 1.25;
    for (let p of points) {
      const s = dataToScreen(p);
      // predicted y
      const yhat = m*p.x + b;
      const s2 = dataToScreen({ x: p.x, y: yhat });
      ctx.beginPath();
      ctx.strokeStyle = '#f97316';
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s2.x, s2.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawLine(m,b,opts={color:'#ef476f',wide:2,dashed:false}) {
    // compute intersection with x=0 and x=100
    const y0 = m*0 + b;
    const y1 = m*100 + b;
    // clip to 0..100 for drawing range
    let xA=0, yA=y0, xB=100, yB=y1;
    // if both points out of box, try clip by y bounds too
    const pts = [];
    function pushIfIn(x,y) {
      if (y>=-1000 && y<=1100 && x>=-1000 && x<=1100) pts.push({x,y});
    }
    pushIfIn(xA,yA); pushIfIn(xB,yB);
    // If y out of bounds, clip at y=0..100 using param t
    if (yA < 0 || yA > 100 || yB < 0 || yB > 100) {
      pts.length = 0;
      // check intersect with edges x=0, x=100, y=0, y=100
      const candidates = [
        {x:0, y:m*0+b},
        {x:100, y:m*100+b},
      ];
      // intersection with y=0: solve 0 = m x + b -> x = -b/m if m != 0
      if (Math.abs(m) > 1e-8) candidates.push({x: (-b)/m, y:0});
      if (Math.abs(m) > 1e-8) candidates.push({x: (100 - b)/m, y:100});
      for (let c of candidates) {
        if (c.x >= 0-1e-6 && c.x <= 100+1e-6 && c.y >= 0-1e-6 && c.y <= 100+1e-6) pts.push(c);
      }
    }
    if (pts.length < 2) return; // nothing to draw
    // take two extreme by x
    pts.sort((a,b2)=>a.x-b2.x);
    const a = pts[0], b2 = pts[pts.length-1];
    const sa = dataToScreen(a), sb = dataToScreen(b2);

    ctx.save();
    ctx.lineWidth = opts.wide || 2;
    ctx.strokeStyle = opts.color || '#000';
    if (opts.dashed) ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(sa.x, sa.y);
    ctx.lineTo(sb.x, sb.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawLegend(stats) {
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.strokeStyle = '#e6eef8';
    ctx.lineWidth = 1;
    const w = 260, h = 86;
    const x = width - pad - w, y = pad + 6;
    roundRect(ctx, x, y, w, h, 8, true, true);
    ctx.fillStyle = '#0f172a';
    ctx.font = '12px system-ui,Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Model summary', x+12, y+20);
    ctx.font = '13px monospace';
    if (stats) {
      ctx.fillStyle = '#111827';
      ctx.fillText(`OLS: m=${stats.ols.m.toFixed(4)}, b=${stats.ols.b.toFixed(3)}`, x+12, y+40);
      ctx.fillText(`GD:  m=${stats.gd.m.toFixed(4)}, b=${stats.gd.b.toFixed(3)}`, x+12, y+58);
      ctx.fillStyle = '#6b7280';
      ctx.font = '12px monospace';
      ctx.fillText(`R²=${stats.r2.toFixed(4)}  RMSE=${stats.rmse.toFixed(3)}`, x+12, y+76);
    } else {
      ctx.fillText('No data', x+12, y+40);
    }
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Compute analytic OLS
  function computeOLS(pts) {
    const n = pts.length;
    if (n === 0) return null;
    if (n === 1) return { m:0, b: pts[0].y };
    let sx=0, sy=0;
    for (let p of pts) { sx += p.x; sy += p.y; }
    const mx = sx/n, my = sy/n;
    let num = 0, den = 0;
    for (let p of pts) {
      num += (p.x - mx)*(p.y - my);
      den += (p.x - mx)*(p.x - mx);
    }
    if (Math.abs(den) < 1e-12) return { m:0, b:my }; // vertical variance zero; degenerate
    const m = num/den;
    const b = my - m*mx;
    return { m, b };
  }

  function computeStats(pts, model) {
    if (!model || pts.length === 0) return null;
    const n = pts.length;
    let sse = 0, sst = 0;
    let sy=0;
    for (let p of pts) sy += p.y;
    const my = sy/n;
    for (let p of pts) {
      const yhat = model.m*p.x + model.b;
      sse += (p.y - yhat)*(p.y - yhat);
      sst += (p.y - my)*(p.y - my);
    }
    const r2 = (sst === 0) ? 1 : Math.max(0, 1 - sse/sst);
    const rmse = Math.sqrt(sse/n);
    return { sse, sst, r2, rmse };
  }

  // Update UI stats and left panel
  function updateStats(olsModel, gdModel) {
    const ols = olsModel || {m:0,b:0};
    const gd = gdModel || {m:0,b:0};
    const bestModel = olsModel || gdModel || {m:0,b:0};
    const stats = computeStats(points, bestModel) || { sse:0, sst:0, r2:0, rmse:0 };
    const text = [];
    text.push(`Points: ${points.length}`);
    if (points.length >= 2) {
      text.push('');
      text.push(`OLS: slope m = ${ols.m.toFixed(6)}`);
      text.push(`     intercept b = ${ols.b.toFixed(6)}`);
      text.push('');
      text.push(`GD:  slope m = ${gd.m.toFixed(6)}`);
      text.push(`     intercept b = ${gd.b.toFixed(6)}`);
      text.push('');
      text.push(`R² (OLS) = ${computeStats(points, ols).r2.toFixed(6)}`);
      text.push(`RMSE (OLS) = ${computeStats(points, ols).rmse.toFixed(6)}`);
    } else if (points.length === 1) {
      text.push('');
      text.push('Only one point — infinite fits; intercept shown as y of the point');
    } else {
      text.push('');
      text.push('Add points to compute regression.');
    }
    statsEl.textContent = text.join('\n');
    draw(); // ensure legend updated
  }

  function updatePointList() {
    pointListEl.innerHTML = '';
    points.forEach((p,i) => {
      const row = document.createElement('div');
      row.className = 'point-row';
      const lbl = document.createElement('div');
      lbl.textContent = `${i}: (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`;
      const actions = document.createElement('div');
      actions.style.display = 'flex';
      actions.style.gap = '6px';
      const btnDel = document.createElement('button');
      btnDel.textContent = 'Delete';
      btnDel.className = 'small-btn';
      btnDel.onclick = () => { points.splice(i,1); updateAfterChange(); };
      const btnCenter = document.createElement('button');
      btnCenter.textContent = 'Center';
      btnCenter.className = 'ghost';
      btnCenter.onclick = () => { p.x = 50; p.y = 50; updateAfterChange(); };
      actions.appendChild(btnCenter);
      actions.appendChild(btnDel);
      row.appendChild(lbl);
      row.appendChild(actions);
      pointListEl.appendChild(row);
    });
  }

  // Main draw
  function draw() {
    clearCanvas();
    drawGrid();

    const ols = computeOLS(points);
    const gd = { m: gdParams.m, b: gdParams.b };
    // draw lines behind points
    if (showOlsEl.checked && ols) drawLine(ols.m, ols.b, { color:'#ef476f', wide:2, dashed:false });
    if (showGdEl.checked && points.length >= 1) drawLine(gd.m, gd.b, { color:'#06b6d4', wide:2, dashed:true });

    // residuals (for OLS by default)
    if (showResEl.checked && ols) drawResiduals(ols.m, ols.b);

    drawPoints();

    // draw small legend with numeric stats
    const stats = {
      ols: ols || {m:0,b:0},
      gd: gd,
      r2: (ols? computeStats(points, ols).r2 : 0),
      rmse: (ols? computeStats(points, ols).rmse : 0)
    };
    drawLegend(stats);
  }

  // Interaction
  function findPointNear(px,py) {
    for (let i=points.length-1;i>=0;i--) {
      const p = points[i];
      const s = dataToScreen(p);
      const dx = s.x - px, dy = s.y - py;
      if (Math.sqrt(dx*dx + dy*dy) <= pointRadius+6) return {p, i};
    }
    return null;
  }

  let lastClickTime = 0;
  canvas.addEventListener('pointerdown', (ev) => {
    ev.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const hit = findPointNear(px,py);
    if (hit) {
      // Check double-click for deletion
      const now = Date.now();
      if (now - lastClickTime < 330) {
        // double-click: delete
        points.splice(hit.i, 1);
        updateAfterChange();
        lastClickTime = 0;
        return;
      }
      lastClickTime = now;
      // start dragging
      dragging = hit.p;
      // highlight
      draw();
      canvas.setPointerCapture(ev.pointerId);
    } else {
      // add new point
      const d = screenToData(px,py);
      points.push({ x: d.x, y: d.y });
      updateAfterChange();
    }
  });

  canvas.addEventListener('pointermove', (ev) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const d = screenToData(px,py);
    dragging.x = d.x;
    dragging.y = d.y;
    updateAfterChange(false);
  });

  canvas.addEventListener('pointerup', (ev) => {
    if (dragging) {
      dragging = null;
      updateAfterChange();
    }
    try { canvas.releasePointerCapture(ev.pointerId); } catch(e){}
  });

  // Helpers for adding points
  function addRandomPoint() {
    const x = Math.random()*100;
    const y = Math.random()*100;
    points.push({x,y});
    updateAfterChange();
  }

  function generateRandom(n, noise=8) {
    for (let i=0;i<n;i++) addRandomPoint();
    // optionally jitter noise small? Already random
  }

  function generateFromLine(n, noise=8) {
    // random slope and intercept chosen if none
    trueLine.m = (Math.random()*2 - 1) * 1.2; // -1.2 .. 1.2
    trueLine.b = 20 + Math.random()*60; // 20 .. 80
    points = [];
    for (let i=0;i<n;i++) {
      const x = Math.random()*100;
      const y = trueLine.m*x + trueLine.b + (randNorm()*noise);
      points.push({ x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) });
    }
    updateAfterChange();
  }

  // Gaussian approx random
  function randNorm() {
    // Box-Muller
    let u=0,v=0;
    while(u===0) u = Math.random();
    while(v===0) v = Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2*Math.PI*v);
  }

  // Gradient Descent routine
  function runGD(iterations, lr, onStep) {
    if (points.length === 0) return;
    // Initialize parameters to current OLS or zeros
    const ols = computeOLS(points);
    gdParams.m = ols ? ols.m : 0;
    gdParams.b = ols ? ols.b : 0;
    gdStep = 0;
    gdRunning = true;
    return new Promise((resolve) => {
      function stepBatch() {
        if (!gdRunning) { resolve(false); return; }
        const batch = Math.min(200, iterations - gdStep);
        for (let k=0;k<batch;k++) {
          const grads = computeGradient(points, gdParams);
          gdParams.m -= lr * grads.dm;
          gdParams.b -= lr * grads.db;
          gdStep++;
          if (gdStep >= iterations) break;
        }
        onStep && onStep();
        if (gdStep < iterations && gdRunning) {
          // schedule next
          setTimeout(stepBatch, 12);
        } else {
          gdRunning = false;
          resolve(true);
        }
      }
      stepBatch();
    });
  }

  function stopGD() {
    gdRunning = false;
  }

  function computeGradient(pts, params) {
    // dM = -2/N * sum x*(y - (m x + b))
    // dB = -2/N * sum (y - (m x + b))
    const N = pts.length;
    let dm = 0, db = 0;
    for (let p of pts) {
      const pred = params.m*p.x + params.b;
      const err = p.y - pred;
      dm += -2 * p.x * err;
      db += -2 * err;
    }
    dm /= N; db /= N;
    return { dm, db };
  }

  // Update after points change
  function updateAfterChange(alsoUpdateList=true) {
    document.getElementById('count').textContent = points.length;
    if (alsoUpdateList) updatePointList();
    // recompute OLS and update GD initial guess maybe
    const ols = computeOLS(points);
    if (!gdRunning) {
      // set gdParams to ols so it's visible
      if (ols) { gdParams.m = ols.m; gdParams.b = ols.b; }
    }
    updateStats(ols, gdParams);
    draw();
  }

  // Hook buttons/inputs
  document.getElementById('btn-ols').addEventListener('click', () => {
    // quick compute and set GD params to OLS
    const ols = computeOLS(points);
    if (!ols) { alert('Need at least one point'); return; }
    gdParams.m = ols.m; gdParams.b = ols.b;
    updateAfterChange();
  });

  document.getElementById('btn-gd').addEventListener('click', () => {
    // show GD line (no immediate effect)
    updateAfterChange();
  });

  document.getElementById('btn-reset').addEventListener('click', () => {
    points = [];
    updateAfterChange();
  });

  document.getElementById('btn-gen').addEventListener('click', () => {
    const n = Math.max(1, Math.min(500, Number(document.getElementById('randN').value) || 10));
    for (let i=0;i<n;i++) generateRandom(1);
  });

  document.getElementById('btn-gen-noise').addEventListener('click', () => {
    const n = Math.max(1, Math.min(500, Number(document.getElementById('randN').value) || 10));
    const noise = Number(noiseEl.value) || 8;
    generateFromLine(n, noise);
  });

  document.getElementById('btn-random').addEventListener('click', addRandomPoint);

  document.getElementById('btn-add-slope').addEventListener('click', () => {
    // Add a few points lying close to a random line
    const m = (Math.random()*2 - 1) * 1.2;
    const b = 10 + Math.random()*80;
    for (let i=0;i<8;i++) {
      const x = 5 + Math.random()*90;
      const y = m*x + b + randNorm()*6;
      points.push({ x: Math.max(0,Math.min(100,x)), y: Math.max(0,Math.min(100,y)) });
    }
    updateAfterChange();
  });

  document.getElementById('btn-center').addEventListener('click', () => {
    for (let p of points) { p.x = Math.max(0, Math.min(100, p.x - 50 + 50)); p.y = Math.max(0, Math.min(100, p.y - 50 + 50)); }
    updateAfterChange();
  });

  document.getElementById('noise').addEventListener('input', (e) => {
    noiseValEl.textContent = e.target.value;
  });

  lrEl.addEventListener('input', (e) => {
    lrValEl.textContent = Number(e.target.value).toFixed(4);
  });

  document.getElementById('run-gd').addEventListener('click', async () => {
    if (points.length === 0) { alert('Add points first'); return; }
    const iters = Math.max(1, Math.min(1000000, Number(itersEl.value) || 200));
    const lr = Number(lrEl.value);
    document.getElementById('run-gd').disabled = true;
    document.getElementById('stop-gd').disabled = false;
    await runGD(iters, lr, () => {
      updateAfterChange(false);
    });
    document.getElementById('run-gd').disabled = false;
    document.getElementById('stop-gd').disabled = true;
    updateAfterChange();
  });

  document.getElementById('stop-gd').addEventListener('click', () => {
    stopGD();
    document.getElementById('run-gd').disabled = false;
    document.getElementById('stop-gd').disabled = true;
  });

  showResEl.addEventListener('change', draw);
  showOlsEl.addEventListener('change', draw);
  showGdEl.addEventListener('change', draw);
  showPointsEl.addEventListener('change', draw);

  // Keyboard: press "g" to generate, "c" to clear
  window.addEventListener('keydown', (e) => {
    if (e.key === 'g') { generateRandom(10); }
    if (e.key === 'c') { points = []; updateAfterChange(); }
  });

  // initial rendering
  updateAfterChange();

  // small animation to show GD line moving if running
  function animate() {
    if (gdRunning) {
      // lightly nudge draw
      updateAfterChange(false);
    }
    requestAnimationFrame(animate);
  }
  animate();

  // Ensure canvas resizes initially
  setTimeout(resize, 50);

  // Expose some functions to console for exploration
  window.lr = () => lrEl.value;
  window.pointsData = points;
})();
</script>
</body>
</html>