<!DOCTYPE html>
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .description {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .control-panel {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .visualization {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .graph-container, .result-container {
            width: 48%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            min-height: 300px;
        }
        .result-container {
            overflow-y: auto;
        }
        .node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            cursor: pointer;
        }
        .edge {
            position: absolute;
            height: 2px;
            background-color: #333;
            pointer-events: none;
        }
        .arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid #333;
        }
        .step {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .current-step {
            background-color: #e8f4fd;
            font-weight: bold;
        }
        label {
            display: inline-block;
            margin-right: 5px;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Topological Sort Visualization</h1>
        
        <div class="description">
            <p>Topological sort is an algorithm that orders the nodes in a directed acyclic graph (DAG) such that for every directed edge from node A to node B, node A appears before node B in the ordering.</p>
            <p>Use this tool to visualize the topological sorting process. You can either use a predefined graph or create your own by adding nodes and edges.</p>
        </div>
        
        <div class="control-panel">
            <button id="addNodeBtn">Add Node</button>
            <button id="addEdgeBtn">Add Edge</button>
            <button id="resetBtn">Reset</button>
            <button id="topologicalSortBtn">Run Topological Sort</button>
            <button id="nextStepBtn" disabled>Next Step</button>
            <select id="presetGraphs">
                <option value="">Select a preset graph</option>
                <option value="linear">Linear Dependencies</option>
                <option value="tree">Tree Structure</option>
                <option value="complex">Complex DAG</option>
            </select>
        </div>
        
        <div class="control-panel">
            <label for="nodeName">Node Name:</label>
            <input type="text" id="nodeName" placeholder="Enter node name" maxlength="1">
            <label for="fromNode">From Node:</label>
            <select id="fromNode"></select>
            <label for="toNode">To Node:</label>
            <select id="toNode"></select>
        </div>
        
        <div id="errorMessage" class="error"></div>
        
        <div class="visualization">
            <div class="graph-container" id="graphContainer">
                <!-- Graph will be drawn here -->
            </div>
            <div class="result-container" id="resultContainer">
                <h3>Topological Order:</h3>
                <div id="topologicalOrder"></div>
                <h3>Algorithm Steps:</h3>
                <div id="algorithmSteps"></div>
            </div>
        </div>
    </div>

    <script>
        // Graph data structure
        class Graph {
            constructor() {
                this.nodes = new Set();
                this.adjacencyList = new Map();
                this.inDegree = new Map();
            }
            
            addNode(node) {
                if (!this.nodes.has(node)) {
                    this.nodes.add(node);
                    this.adjacencyList.set(node, []);
                    this.inDegree.set(node, 0);
                }
            }
            
            addEdge(from, to) {
                if (this.nodes.has(from) && this.nodes.has(to)) {
                    this.adjacencyList.get(from).push(to);
                    this.inDegree.set(to, this.inDegree.get(to) + 1);
                }
            }
            
            // Kahn's algorithm for topological sort
            topologicalSort() {
                const result = [];
                const steps = [];
                const inDegreeCopy = new Map(this.inDegree);
                const queue = [];
                
                // Initialize queue with nodes having in-degree 0
                for (const node of this.nodes) {
                    if (inDegreeCopy.get(node) === 0) {
                        queue.push(node);
                    }
                }
                
                steps.push("Initialization: Added nodes with in-degree 0 to queue: " + queue.join(", "));
                
                let stepCount = 1;
                while (queue.length > 0) {
                    const current = queue.shift();
                    result.push(current);
                    
                    steps.push(`Step ${stepCount}: Processing node ${current}. Current topological order: [${result.join(", ")}]`);
                    
                    // Reduce in-degree of neighbors
                    for (const neighbor of this.adjacencyList.get(current)) {
                        inDegreeCopy.set(neighbor, inDegreeCopy.get(neighbor) - 1);
                        
                        // If in-degree becomes 0, add to queue
                        if (inDegreeCopy.get(neighbor) === 0) {
                            queue.push(neighbor);
                            steps.push(`  -> Node ${neighbor} now has in-degree 0, added to queue`);
                        } else {
                            steps.push(`  -> Node ${neighbor} in-degree reduced to ${inDegreeCopy.get(neighbor)}`);
                        }
                    }
                    
                    stepCount++;
                }
                
                // Check for cycles
                if (result.length !== this.nodes.size) {
                    steps.push("Cycle detected! Graph is not a DAG.");
                    return { order: [], steps, hasCycle: true };
                }
                
                steps.push("Topological sort completed successfully!");
                return { order: result, steps, hasCycle: false };
            }
        }

        // Visualization controller
        class TopologicalSortVisualizer {
            constructor() {
                this.graph = new Graph();
                this.nodePositions = new Map();
                this.nodeElements = new Map();
                this.edgeElements = [];
                this.currentStep = 0;
                this.algorithmSteps = [];
                
                this.initializeEventListeners();
                this.updateNodeSelects();
            }
            
            initializeEventListeners() {
                document.getElementById('addNodeBtn').addEventListener('click', () => this.addNode());
                document.getElementById('addEdgeBtn').addEventListener('click', () => this.addEdge());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('topologicalSortBtn').addEventListener('click', () => this.runTopologicalSort());
                document.getElementById('nextStepBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('presetGraphs').addEventListener('change', (e) => this.loadPresetGraph(e.target.value));
                
                // Allow adding nodes by pressing Enter in the node name input
                document.getElementById('nodeName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addNode();
                    }
                });
            }
            
            addNode() {
                const nodeNameInput = document.getElementById('nodeName');
                const nodeName = nodeNameInput.value.trim().toUpperCase();
                
                if (!nodeName) {
                    this.showError("Please enter a node name");
                    return;
                }
                
                if (this.graph.nodes.has(nodeName)) {
                    this.showError(`Node ${nodeName} already exists`);
                    return;
                }
                
                this.graph.addNode(nodeName);
                this.createNodeElement(nodeName);
                this.updateNodeSelects();
                nodeNameInput.value = '';
                this.hideError();
            }
            
            addEdge() {
                const fromNode = document.getElementById('fromNode').value;
                const toNode = document.getElementById('toNode').value;
                
                if (!fromNode || !toNode) {
                    this.showError("Please select both from and to nodes");
                    return;
                }
                
                if (fromNode === toNode) {
                    this.showError("Cannot create an edge from a node to itself");
                    return;
                }
                
                // Check if edge already exists
                if (this.graph.adjacencyList.get(fromNode).includes(toNode)) {
                    this.showError(`Edge from ${fromNode} to ${toNode} already exists`);
                    return;
                }
                
                this.graph.addEdge(fromNode, toNode);
                this.createEdgeElement(fromNode, toNode);
                this.hideError();
            }
            
            createNodeElement(nodeName) {
                const graphContainer = document.getElementById('graphContainer');
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `node-${nodeName}`;
                node.textContent = nodeName;
                
                // Position nodes in a circular layout
                const nodeCount = this.graph.nodes.size;
                const angle = (2 * Math.PI * (nodeCount - 1)) / Math.max(6, nodeCount);
                const radius = 150;
                const centerX = graphContainer.offsetWidth / 2;
                const centerY = graphContainer.offsetHeight / 2;
                
                const x = centerX + radius * Math.cos(angle) - 20;
                const y = centerY + radius * Math.sin(angle) - 20;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                graphContainer.appendChild(node);
                this.nodeElements.set(nodeName, node);
                this.nodePositions.set(nodeName, { x: x + 20, y: y + 20 }); // Center of the node
            }
            
            createEdgeElement(fromNode, toNode) {
                const graphContainer = document.getElementById('graphContainer');
                const fromPos = this.nodePositions.get(fromNode);
                const toPos = this.nodePositions.get(toNode);
                
                if (!fromPos || !toPos) return;
                
                // Calculate edge line
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Create line element
                const line = document.createElement('div');
                line.className = 'edge';
                line.style.width = `${length}px`;
                line.style.left = `${fromPos.x}px`;
                line.style.top = `${fromPos.y}px`;
                line.style.transform = `rotate(${angle}rad)`;
                line.style.transformOrigin = '0 0';
                
                // Create arrowhead
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.style.left = `${toPos.x - 10 * Math.cos(angle)}px`;
                arrow.style.top = `${toPos.y - 10 * Math.sin(angle)}px`;
                arrow.style.transform = `rotate(${angle}rad)`;
                
                graphContainer.appendChild(line);
                graphContainer.appendChild(arrow);
                
                this.edgeElements.push({ line, arrow, from: fromNode, to: toNode });
            }
            
            updateNodeSelects() {
                const fromNodeSelect = document.getElementById('fromNode');
                const toNodeSelect = document.getElementById('toNode');
                
                // Clear options
                fromNodeSelect.innerHTML = '';
                toNodeSelect.innerHTML = '';
                
                // Add options for each node
                for (const node of this.graph.nodes) {
                    const option1 = document.createElement('option');
                    option1.value = node;
                    option1.textContent = node;
                    fromNodeSelect.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = node;
                    option2.textContent = node;
                    toNodeSelect.appendChild(option2);
                }
            }
            
            runTopologicalSort() {
                const result = this.graph.topologicalSort();
                this.algorithmSteps = result.steps;
                this.currentStep = 0;
                
                // Display the steps
                const stepsContainer = document.getElementById('algorithmSteps');
                stepsContainer.innerHTML = '';
                
                this.algorithmSteps.forEach((step, index) => {
                    const stepElement = document.createElement('div');
                    stepElement.className = 'step';
                    stepElement.id = `step-${index}`;
                    stepElement.textContent = step;
                    stepsContainer.appendChild(stepElement);
                });
                
                // Enable next step button
                document.getElementById('nextStepBtn').disabled = false;
                
                // Reset node colors
                this.resetNodeColors();
                
                // Highlight the first step
                this.highlightStep(0);
                
                // Display result
                const orderContainer = document.getElementById('topologicalOrder');
                if (result.hasCycle) {
                    orderContainer.innerHTML = '<span style="color: red;">Cycle detected! Graph is not a DAG.</span>';
                } else {
                    orderContainer.textContent = result.order.join(' â†’ ');
                }
            }
            
            nextStep() {
                if (this.currentStep < this.algorithmSteps.length - 1) {
                    this.currentStep++;
                    this.highlightStep(this.currentStep);
                    
                    // Extract node being processed from step text
                    const stepText = this.algorithmSteps[this.currentStep];
                    const match = stepText.match(/Processing node ([A-Z])/);
                    if (match) {
                        const node = match[1];
                        this.highlightNode(node);
                    }
                }
                
                // Disable button if we've reached the last step
                if (this.currentStep === this.algorithmSteps.length - 1) {
                    document.getElementById('nextStepBtn').disabled = true;
                }
            }
            
            highlightStep(stepIndex) {
                // Remove highlight from all steps
                document.querySelectorAll('.step').forEach(step => {
                    step.classList.remove('current-step');
                });
                
                // Highlight current step
                const currentStepElement = document.getElementById(`step-${stepIndex}`);
                if (currentStepElement) {
                    currentStepElement.classList.add('current-step');
                    currentStepElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            highlightNode(nodeName) {
                // Reset all nodes to default color
                this.resetNodeColors();
                
                // Highlight the current node
                const nodeElement = this.nodeElements.get(nodeName);
                if (nodeElement) {
                    nodeElement.style.backgroundColor = '#2196F3';
                }
            }
            
            resetNodeColors() {
                for (const nodeElement of this.nodeElements.values()) {
                    nodeElement.style.backgroundColor = '#4CAF50';
                }
            }
            
            loadPresetGraph(preset) {
                this.reset();
                
                switch(preset) {
                    case 'linear':
                        // A -> B -> C -> D
                        this.graph.addNode('A');
                        this.graph.addNode('B');
                        this.graph.addNode('C');
                        this.graph.addNode('D');
                        this.graph.addEdge('A', 'B');
                        this.graph.addEdge('B', 'C');
                        this.graph.addEdge('C', 'D');
                        break;
                    
                    case 'tree':
                        //     A
                        //    / \
                        //   B   C
                        //  / \   \
                        // D   E   F
                        this.graph.addNode('A');
                        this.graph.addNode('B');
                        this.graph.addNode('C');
                        this.graph.addNode('D');
                        this.graph.addNode('E');
                        this.graph.addNode('F');
                        this.graph.addEdge('A', 'B');
                        this.graph.addEdge('A', 'C');
                        this.graph.addEdge('B', 'D');
                        this.graph.addEdge('B', 'E');
                        this.graph.addEdge('C', 'F');
                        break;
                    
                    case 'complex':
                        // A -> B -> D -> F
                        // A -> C -> E -> F
                        // B -> E
                        this.graph.addNode('A');
                        this.graph.addNode('B');
                        this.graph.addNode('C');
                        this.graph.addNode('D');
                        this.graph.addNode('E');
                        this.graph.addNode('F');
                        this.graph.addEdge('A', 'B');
                        this.graph.addEdge('A', 'C');
                        this.graph.addEdge('B', 'D');
                        this.graph.addEdge('B', 'E');
                        this.graph.addEdge('C', 'E');
                        this.graph.addEdge('D', 'F');
                        this.graph.addEdge('E', 'F');
                        break;
                    
                    default:
                        return;
                }
                
                // Create visualization for the preset graph
                for (const node of this.graph.nodes) {
                    this.createNodeElement(node);
                }
                
                for (const [from, neighbors] of this.graph.adjacencyList.entries()) {
                    for (const to of neighbors) {
                        this.createEdgeElement(from, to);
                    }
                }
