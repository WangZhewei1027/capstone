<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Breadth-First Search (BFS) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --accent-2:#7c3aed;
      --cell:#0b1220;
      --wall:#111827;
      --visited:#fde68a;
      --frontier:#60a5fa;
      --path:#34d399;
      --start:#ef4444;
      --end:#f97316;
      --text:#e6eef8;
      --muted:#9aa8bd;
      --control-bg:#0b1220;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(180deg,#071229 0%, #071833 60%, #0b1730 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app {
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:18px;
      padding:28px;
      height:100vh;
      box-sizing:border-box;
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding:16px;
      border-radius:12px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.45);
      overflow:auto;
    }

    .left {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    h1{
      margin:0 0 6px 0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    .controls {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }

    button, select, input[type=number], input[type=range]{
      background:var(--control-bg);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--text);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button.primary {
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      color:white;
      border:none;
      box-shadow: 0 6px 16px rgba(96,165,250,0.12);
    }
    button.warn{
      background:linear-gradient(90deg,#ef4444,#f97316);
      color:white;
      border:none;
    }

    .tools {
      display:flex;
      gap:8px;
      margin-top:10px;
    }

    .tool {
      padding:8px 10px;
      border-radius:8px;
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.02);
      display:flex;
      gap:8px;
      align-items:center;
      cursor:pointer;
      font-size:13px;
    }
    .tool.active{
      outline:2px solid rgba(96,165,250,0.12);
      box-shadow: inset 0 -4px 0 rgba(96,165,250,0.06);
      background:linear-gradient(180deg, rgba(96,165,250,0.04), rgba(124,58,237,0.02));
    }

    .small {
      font-size:12px;
      padding:6px 8px;
    }

    .grid-wrap {
      display:flex;
      gap:18px;
      align-items:flex-start;
    }

    .grid {
      display:grid;
      background:linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));
      border-radius:8px;
      padding:10px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
      user-select:none;
    }
    .cell {
      width:28px;
      height:28px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:rgba(255,255,255,0.85);
      border-radius:6px;
      transition:background 120ms linear, transform 90ms ease;
      box-sizing:border-box;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .cell.empty { background: rgba(255,255,255,0.01); color:var(--muted); }
    .cell.wall { background: var(--wall); color:rgba(255,255,255,0.65); }
    .cell.start { background:var(--start); color:white; font-weight:700; }
    .cell.end { background:var(--end); color:white; font-weight:700; }
    .cell.frontier { background:var(--frontier); color:black; }
    .cell.visited { background:var(--visited); color:black; }
    .cell.path { background:var(--path); color:white; font-weight:700; }

    .legend {
      display:flex;
      gap:8px;
      flex-direction:column;
    }
    .legend-row { display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted); }

    .swatch {
      width:16px; height:16px; border-radius:4px; border:1px solid rgba(255,255,255,0.02);
    }

    .info {
      margin-top:6px;
      font-size:13px;
      color:var(--muted);
      line-height:1.5;
    }

    .right {
      display:flex;
      flex-direction:column;
    }

    .board-area {
      display:flex;
      gap:12px;
      align-items:flex-start;
    }

    .stats {
      margin-top:12px;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      font-size:13px;
    }

    .stat {
      background:var(--glass);
      padding:8px;
      border-radius:8px;
      text-align:center;
      border:1px solid rgba(255,255,255,0.02);
    }
    .stat strong { display:block; font-size:18px; }

    .queue-box {
      margin-top:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:8px;
      border:1px solid rgba(255,255,255,0.03);
      font-size:13px;
    }
    .queue-list { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; color:var(--muted); }
    .queue-item { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; font-weight:600; color:var(--text); font-size:12px; }

    .pseudocode {
      margin-top:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:10px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
      white-space:pre;
    }

    .footer {
      margin-top:18px;
      font-size:12px;
      color:var(--muted);
    }

    @media (max-width:1000px){
      .app { grid-template-columns: 1fr; padding:14px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel left">
      <div>
        <h1>Breadth-First Search (BFS)</h1>
        <p class="lead">Interactive visualization: draw walls, pick start & end, then step through or run BFS to find the shortest path on a grid.</p>
      </div>

      <div class="controls">
        <label>Rows <input id="rows" type="number" min="5" max="40" value="16" style="width:72px"></label>
        <label>Cols <input id="cols" type="number" min="5" max="60" value="28" style="width:72px"></label>
        <button id="resize" title="Resize grid">Resize Grid</button>
        <button id="randomWalls">Random Walls</button>
        <button id="clearWalls">Clear Walls</button>
      </div>

      <div class="tools" style="margin-top:12px;">
        <div class="tool active" id="tool-wall" data-tool="wall">Draw Walls</div>
        <div class="tool" id="tool-start" data-tool="start">Set Start</div>
        <div class="tool" id="tool-end" data-tool="end">Set End</div>
        <div class="tool" id="tool-erase" data-tool="erase">Erase</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px;align-items:center;">
        <button class="primary" id="run">Run</button>
        <button id="step">Step</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
        <div style="display:flex;flex-direction:column;margin-left:8px;">
          <label style="font-size:12px;color:var(--muted)">Speed</label>
          <input id="speed" type="range" min="50" max="1200" value="220" step="10" style="width:160px">
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px;align-items:center;">
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--start)"></div>
          <div style="font-size:13px;">Start</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--end)"></div>
          <div style="font-size:13px;">End</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--wall)"></div>
          <div style="font-size:13px;">Wall</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--frontier)"></div>
          <div style="font-size:13px;">Frontier (Queue)</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--visited)"></div>
          <div style="font-size:13px;">Visited</div>
        </div>
        <div style="display:flex;gap:6px;align-items:center;">
          <div class="swatch" style="background:var(--path)"></div>
          <div style="font-size:13px;">Final Path</div>
        </div>
      </div>

      <div class="info">
        Controls:
        <ul style="margin:6px 0 0 18px;">
          <li>Left-click and drag to paint walls (or erase). Use the tool buttons to place Start/End.</li>
          <li>Run will animate BFS until the end is found or all reachable cells are visited.</li>
          <li>Step advances one BFS expansion (dequeue one node). Pause stops the animation.</li>
          <li>BFS finds the shortest path in an unweighted grid (4-neighbors).</li>
        </ul>
      </div>

      <div class="pseudocode">
BFS(start, goal):
  Q = empty queue
  enqueue Q with start
  mark start visited
  while Q not empty:
    current = dequeue Q
    if current == goal:
      return reconstruct_path(goal)
    for each neighbor of current:
      if neighbor not visited and not wall:
        mark visited
        parent[neighbor] = current
        enqueue neighbor
  return no path
      </div>

      <div class="footer">
        Tip: Resize the grid, add walls and try different configurations. BFS explores in waves and guarantees the shortest path on an unweighted grid.
      </div>
    </div>

    <div class="panel right">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <strong style="font-size:16px">Grid</strong>
          <div style="font-size:13px;color:var(--muted)">Click cells to interact. Drag to paint.</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:13px;color:var(--muted)">Algorithm State</div>
          <div style="font-weight:700;font-size:15px" id="state">Idle</div>
        </div>
      </div>

      <div style="margin-top:12px;" class="board-area">
        <div>
          <div id="grid" class="grid"></div>
        </div>
        <div style="min-width:220px;">
          <div class="stats">
            <div class="stat">
              <div style="color:var(--muted)">Visit Count</div>
              <strong id="visitCount">0</strong>
            </div>
            <div class="stat">
              <div style="color:var(--muted)">Queue Size</div>
              <strong id="queueSize">0</strong>
            </div>
          </div>

          <div class="queue-box" id="queueBox">
            <div style="font-weight:700">Queue (front → back)</div>
            <div id="queueList" class="queue-list"></div>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:700">Found Path</div>
            <div id="pathInfo" style="color:var(--muted);margin-top:6px">Length: -</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    // BFS Visualizer JavaScript
    (function(){
      // Grid data and state
      const DEFAULT_ROWS = 16;
      const DEFAULT_COLS = 28;

      let rows = DEFAULT_ROWS;
      let cols = DEFAULT_COLS;
      let gridEl = document.getElementById('grid');

      // Cell states: 'empty', 'wall', 'start', 'end', 'visited', 'frontier', 'path'
      let cells = []; // 2D array of state strings
      let start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};
      let end = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};

      // BFS runtime structures
      let visited = null; // 2D bool
      let parent = null; // 2D parent pointers {r,c} or null
      let queue = []; // array of {r,c}
      let intervalId = null;
      let isRunning = false;
      let animationDelay = 220; // ms
      let exploring = false;
      let found = false;

      // UI elements
      const rowsInput = document.getElementById('rows');
      const colsInput = document.getElementById('cols');
      const resizeBtn = document.getElementById('resize');
      const randomWallsBtn = document.getElementById('randomWalls');
      const clearWallsBtn = document.getElementById('clearWalls');
      const runBtn = document.getElementById('run');
      const stepBtn = document.getElementById('step');
      const pauseBtn = document.getElementById('pause');
      const resetBtn = document.getElementById('reset');
      const speedRange = document.getElementById('speed');
      const stateEl = document.getElementById('state');
      const queueListEl = document.getElementById('queueList');
      const queueSizeEl = document.getElementById('queueSize');
      const visitCountEl = document.getElementById('visitCount');
      const pathInfoEl = document.getElementById('pathInfo');

      // Tools
      const toolEls = Array.from(document.querySelectorAll('.tool'));
      let currentTool = 'wall';
      toolEls.forEach(t => t.addEventListener('click', ()=> {
        toolEls.forEach(x => x.classList.remove('active'));
        t.classList.add('active');
        currentTool = t.dataset.tool;
      }));

      // Prevent context menu to allow right-click behavior if needed
      document.addEventListener('contextmenu', e => e.preventDefault());

      // Initialize
      function initGrid(r = rows, c = cols){
        rows = r;
        cols = c;
        rowsInput.value = rows;
        colsInput.value = cols;

        // Initialize cell states
        cells = new Array(rows);
        visited = new Array(rows);
        parent = new Array(rows);
        for(let i=0;i<rows;i++){
          cells[i] = new Array(cols).fill('empty');
          visited[i] = new Array(cols).fill(false);
          parent[i] = new Array(cols).fill(null);
        }

        // Place start and end (safely inside)
        start = {r: Math.max(0, Math.min(rows-1, Math.floor(rows/2))), c: Math.max(0, Math.min(cols-1, Math.floor(cols/4)))};
        end = {r: Math.max(0, Math.min(rows-1, Math.floor(rows/2))), c: Math.max(0, Math.min(cols-1, Math.floor(cols*3/4)))};
        cells[start.r][start.c] = 'start';
        cells[end.r][end.c] = 'end';

        renderGrid();
        resetBFSState();
      }

      function renderGrid(){
        // CSS grid columns
        gridEl.style.gridTemplateColumns = `repeat(${cols}, 28px)`;
        gridEl.innerHTML = '';
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const div = document.createElement('div');
            div.className = 'cell ' + cells[r][c];
            div.dataset.r = r;
            div.dataset.c = c;
            // Show small label for start/end; visited frontier will be colored
            if(cells[r][c] === 'start') div.textContent = 'S';
            else if(cells[r][c] === 'end') div.textContent = 'E';
            else div.textContent = '';

            // Mouse interactions
            div.addEventListener('mousedown', onCellMouseDown);
            div.addEventListener('mouseenter', onCellMouseEnter);
            div.addEventListener('mouseup', onCellMouseUp);
            // store element for faster updates
            gridEl.appendChild(div);
          }
        }
      }

      // Helpers to update single cell class and text
      function updateCellStyle(r,c){
        const idx = r*cols + c;
        const el = gridEl.children[idx];
        if(!el) return;
        const state = cells[r][c];
        el.className = 'cell ' + state;
        el.textContent = (state === 'start') ? 'S' : (state === 'end') ? 'E' : (state === 'path') ? '•' : (state === 'visited') ? '' : '';
      }

      // Mouse painting handling
      let mouseDown = false;
      let paintMode = null;

      function onCellMouseDown(e){
        e.preventDefault();
        mouseDown = true;
        const r = +this.dataset.r;
        const c = +this.dataset.c;
        // Determine action based on current tool
        if(currentTool === 'wall'){
          paintMode = 'wall';
          toggleWallAt(r,c,true);
        } else if(currentTool === 'erase'){
          paintMode = 'erase';
          toggleWallAt(r,c,false);
        } else if(currentTool === 'start'){
          setStart(r,c);
        } else if(currentTool === 'end'){
          setEnd(r,c);
        }
      }
      function onCellMouseEnter(e){
        if(!mouseDown) return;
        const r = +this.dataset.r;
        const c = +this.dataset.c;
        if(paintMode === 'wall') toggleWallAt(r,c,true);
        if(paintMode === 'erase') toggleWallAt(r,c,false);
      }
      function onCellMouseUp(e){
        mouseDown = false;
        paintMode = null;
      }
      window.addEventListener('mouseup', ()=> { mouseDown = false; paintMode = null; });

      function toggleWallAt(r,c,make){
        // can't toggle start or end
        if((r === start.r && c === start.c) || (r === end.r && c === end.c)) return;
        cells[r][c] = make ? 'wall' : 'empty';
        updateCellStyle(r,c);
        resetBFSState();
      }

      function setStart(r,c){
        if(cells[r][c] === 'wall' || (r===end.r && c===end.c)) return;
        // clear old start
        cells[start.r][start.c] = 'empty';
        updateCellStyle(start.r,start.c);
        start = {r,c};
        cells[r][c] = 'start';
        updateCellStyle(r,c);
        resetBFSState();
      }

      function setEnd(r,c){
        if(cells[r][c] === 'wall' || (r===start.r && c===start.c)) return;
        // clear old end
        cells[end.r][end.c] = 'empty';
        updateCellStyle(end.r,end.c);
        end = {r,c};
        cells[r][c] = 'end';
        updateCellStyle(r,c);
        resetBFSState();
      }

      // BFS functions
      function resetBFSState(){
        // Clear visited/frontier/path but keep walls and start/end
        visited = new Array(rows);
        parent = new Array(rows);
        for(let i=0;i<rows;i++){
          visited[i] = new Array(cols).fill(false);
          parent[i] = new Array(cols).fill(null);
          for(let j=0;j<cols;j++){
            if(cells[i][j] === 'visited' || cells[i][j] === 'frontier' || cells[i][j] === 'path'){
              cells[i][j] = 'empty';
              updateCellStyle(i,j);
            }
          }
        }
        queue = [];
        exploring = false;
        found = false;
        isRunning = false;
        clearInterval(intervalId);
        intervalId = null;
        stateEl.textContent = 'Idle';
        queueListEl.innerHTML = '';
        queueSizeEl.textContent = '0';
        visitCountEl.textContent = '0';
        pathInfoEl.textContent = 'Length: -';
        runBtn.disabled = false;
      }

      function initializeBFS(){
        // Called before run/step to (re)start BFS from the current start
        resetBFSState();
        queue = [];
        enqueue(start.r,start.c);
        visited[start.r][start.c] = true;
        // mark start as visited visually? Keep as 'start' cell
        stateEl.textContent = 'Running';
      }

      function enqueue(r,c){
        queue.push({r,c});
        // mark as frontier unless it's start or end
        const keyState = cells[r][c];
        if(!(r===start.r && c===start.c) && !(r===end.r && c===end.c)){
          cells[r][c] = 'frontier';
          updateCellStyle(r,c);
        }
        updateQueueUI();
      }

      function dequeue(){
        const el = queue.shift();
        updateQueueUI();
        return el;
      }

      function updateQueueUI(){
        queueListEl.innerHTML = '';
        queue.forEach(q => {
          const item = document.createElement('div');
          item.className = 'queue-item';
          item.textContent = `[${q.r},${q.c}]`;
          queueListEl.appendChild(item);
        });
        queueSizeEl.textContent = queue.length;
      }

      function neighbors(r,c){
        const out = [];
        const dirs = [[-1,0],[1,0],[0,-1],[0,1]]; // 4-neighbors
        for(const d of dirs){
          const nr = r + d[0];
          const nc = c + d[1];
          if(nr>=0 && nr<rows && nc>=0 && nc<cols) out.push({r:nr,c:nc});
        }
        return out;
      }

      function stepBFS(){
        // Perform one dequeue and expand; return status: 'running' | 'found' | 'done'
        if(found || queue.length === 0){
          stateEl.textContent = found ? 'Found' : 'Done - no path';
          isRunning = false;
          clearInterval(intervalId);
          intervalId = null;
          return 'done';
        }
        const cur = dequeue();
        const r = cur.r, c = cur.c;

        // mark as visited (but keep start/end appearance)
        if(!(r===start.r && c===start.c) && !(r===end.r && c===end.c)){
          cells[r][c] = 'visited';
          updateCellStyle(r,c);
        }
        visitCountEl.textContent = (+visitCountEl.textContent || 0) + 1;

        // If this is the goal
        if(r === end.r && c === end.c){
          found = true;
          reconstructPath();
          stateEl.textContent = 'Found';
          isRunning = false;
          clearInterval(intervalId);
          intervalId = null;
          return 'found';
        }

        // Expand neighbors
        for(const nb of neighbors(r,c)){
          const nr = nb.r, nc = nb.c;
          if(visited[nr][nc]) continue;
          if(cells[nr][nc] === 'wall') continue;
          visited[nr][nc] = true;
          parent[nr][nc] = {r,c};
          enqueue(nr,nc);
        }
        return 'running';
      }

      function reconstructPath(){
        // Use parent pointers from end to start
        let path = [];
        let cur = {r:end.r, c:end.c};
        while(cur){
          path.push(cur);
          const p = parent[cur.r][cur.c];
          if(!p) break;
          cur = p;
        }
        // If last is not start, no path
        if(!(path.length && path[path.length-1].r === start.r && path[path.length-1].c === start.c)){
          pathInfoEl.textContent = 'Length: - (no path)';
          return;
        }
        // Visualize path
        for(const node of path){
          if((node.r === start.r && node.c === start.c) || (node.r === end.r && node.c === end.c)) continue;
          cells[node.r][node.c] = 'path';
          updateCellStyle(node.r,node.c);
        }
        pathInfoEl.textContent = 'Length: ' + (path.length - 1);
      }

      // Controls
      resizeBtn.addEventListener('click', ()=> {
        const r = parseInt(rowsInput.value)||rows;
        const c = parseInt(colsInput.value)||cols;
        if(r<5 || c<5 || r>40 || c>60){
          alert('Rows 5-40, Cols 5-60');
          return;
        }
        initGrid(r,c);
      });

      randomWallsBtn.addEventListener('click', ()=> {
        // randomize walls with some probability
        resetBFSState();
        const prob = 0.28; // 28% walls by default
        for(let i=0;i<rows;i++){
          for(let j=0;j<cols;j++){
            if((i===start.r && j===start.c) || (i===end.r && j===end.c)) continue;
            cells[i][j] = (Math.random() < prob) ? 'wall' : 'empty';
            updateCellStyle(i,j);
          }
        }
      });

      clearWallsBtn.addEventListener('click', ()=> {
        for(let i=0;i<rows;i++){
          for(let j=0;j<cols;j++){
            if(cells[i][j] === 'wall') {
              cells[i][j] = 'empty';
              updateCellStyle(i,j);
            }
          }
        }
        resetBFSState();
      });

      runBtn.addEventListener('click', ()=> {
        if(isRunning) return;
        initializeBFS();
        isRunning = true;
        animationDelay = parseInt(speedRange.value);
        intervalId = setInterval(()=> {
          const res = stepBFS();
          if(res === 'done' || res === 'found'){
            // nothing extra
          }
        }, animationDelay);
      });

      stepBtn.addEventListener('click', ()=> {
        if(!isRunning && queue.length === 0){
          initializeBFS();
        }
        // Do one step
        isRunning = false;
        clearInterval(intervalId);
        intervalId = null;
        stepBFS();
      });

      pauseBtn.addEventListener('click', ()=> {
        isRunning = false;
        clearInterval(intervalId);
        intervalId = null;
        stateEl.textContent = 'Paused';
      });

      resetBtn.addEventListener('click', ()=> {
        resetBFSState();
      });

      speedRange.addEventListener('input', ()=> {
        animationDelay = parseInt(speedRange.value);
        if(isRunning){
          clearInterval(intervalId);
          intervalId = setInterval(()=> {
            stepBFS();
          }, animationDelay);
        }
      });

      // Initialize first time
      initGrid(DEFAULT_ROWS, DEFAULT_COLS);

      // Optional: keyboard shortcuts
      window.addEventListener('keydown', (e)=> {
        if(e.key === 'r') randomWallsBtn.click();
        if(e.key === 'c') clearWallsBtn.click();
        if(e.key === ' ') { e.preventDefault(); runBtn.click(); }
        if(e.key === 'p') pauseBtn.click();
        if(e.key === 's') stepBtn.click();
      });

      // For accessibility: expose a function to programmatically run BFS to completion quickly (without animation)
      // This can be useful when user wants immediate answer.
      // Add a modifier: shift+Run will compute instantly
      runBtn.addEventListener('click', (ev)=> {
        if(ev.shiftKey){
          // compute quickly without animation
          initializeBFS();
          while(queue.length && !found){
            stepBFS();
          }
        }
      });

      // End of script
    })();
  </script>
</body>
</html>