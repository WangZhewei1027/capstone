<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heap (Min/Max) Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    margin-bottom: 5px;
  }
  #heapType {
    margin-bottom: 10px;
  }
  input, button {
    padding: 8px;
    margin: 4px 0;
    font-size: 1rem;
  }
  #heapVisual {
    margin-top: 20px;
  }
  .heap-array {
    font-family: monospace;
    background: #f0f0f0;
    padding: 10px;
    border-radius: 6px;
    display: inline-block;
  }
  #treeCanvas {
    margin-top: 20px;
    border: 1px solid #ccc;
    background: #fafafa;
  }
  #controls {
    margin-bottom: 10px;
  }
  #messages {
    margin-top: 10px;
    min-height: 24px;
    color: #d33;
    font-weight: bold;
  }
</style>
</head>
<body>
<h1>Heap (Min/Max) Demonstration</h1>

<label for="heapType">Select Heap Type:</label>
<select id="heapType">
  <option value="min">Min Heap</option>
  <option value="max">Max Heap</option>
</select>

<div id="controls">
  <input type="number" id="newValue" placeholder="Enter value" />
  <button id="insertBtn">Insert</button>
  <button id="extractBtn">Extract Root</button>
  <button id="clearBtn">Clear</button>
</div>

<div id="messages"></div>

<h3>Heap Array Representation:</h3>
<div class="heap-array" id="heapArray">[]</div>

<h3>Heap Tree Visualization:</h3>
<canvas id="treeCanvas" width="600" height="300"></canvas>

<script>
// Heap implementation supporting Min and Max heap types
class Heap {
  constructor(type = 'min') {
    this.type = type;
    this.data = [];
  }

  // Compare function depends on heap type
  compare(a, b) {
    if (this.type === 'min') return a < b;
    else return a > b;
  }

  insert(value) {
    this.data.push(value);
    this.bubbleUp(this.data.length - 1);
  }

  bubbleUp(index) {
    if (index === 0) return;
    const parentIndex = Math.floor((index - 1) / 2);
    if (this.compare(this.data[index], this.data[parentIndex])) {
      this.swap(index, parentIndex);
      this.bubbleUp(parentIndex);
    }
  }

  extractRoot() {
    if (this.data.length === 0) return null;
    if (this.data.length === 1) return this.data.pop();

    const root = this.data[0];
    this.data[0] = this.data.pop();
    this.bubbleDown(0);
    return root;
  }

  bubbleDown(index) {
    const leftIndex = 2 * index + 1;
    const rightIndex = 2 * index + 2;
    let swapIndex = index;

    if (
      leftIndex < this.data.length &&
      this.compare(this.data[leftIndex], this.data[swapIndex])
    ) {
      swapIndex = leftIndex;
    }

    if (
      rightIndex < this.data.length &&
      this.compare(this.data[rightIndex], this.data[swapIndex])
    ) {
      swapIndex = rightIndex;
    }

    if (swapIndex !== index) {
      this.swap(index, swapIndex);
      this.bubbleDown(swapIndex);
    }
  }

  swap(i, j) {
    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
  }

  clear() {
    this.data = [];
  }

  getHeap() {
    return this.data.slice();
  }
}

// Drawing the heap tree on canvas
function drawHeapTree(heapArray, canvas, type) {
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  ctx.clearRect(0, 0, width, height);

  if (heapArray.length === 0) {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText('Heap is empty', width / 2 - 50, height / 2);
    return;
  }

  // Calculate x,y positions for each node in a binary tree layout
  const nodePositions = [];
  const levels = Math.floor(Math.log2(heapArray.length)) + 1;
  const levelHeight = height / (levels + 1);

  // For each level, calculate horizontal spacing
  for (let level = 0; level < levels; level++) {
    const levelCount = Math.pow(2, level);
    const horizontalSpacing = width / (levelCount + 1);
    for (let i = 0; i < levelCount; i++) {
      const nodeIndex = Math.pow(2, level) - 1 + i;
      if (nodeIndex >= heapArray.length) break;
      const x = horizontalSpacing * (i + 1);
      const y = levelHeight * (level + 1);
      nodePositions[nodeIndex] = { x, y };
    }
  }

  // Draw edges
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  for (let i = 1; i < heapArray.length; i++) {
    const parentIndex = Math.floor((i - 1) / 2);
    const from = nodePositions[parentIndex];
    const to = nodePositions[i];
    ctx.beginPath();
    ctx.moveTo(from.x, from.y + 20);
    ctx.lineTo(to.x, to.y - 20);
    ctx.stroke();
  }

  // Draw nodes
  const radius = 20;
  for (let i = 0; i < heapArray.length; i++) {
    const node = nodePositions[i];
    ctx.beginPath();
    ctx.fillStyle = type === 'min' ? '#4caf50' : '#ff5722';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Draw text (value)
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(heapArray[i], node.x, node.y);
  }
}

// Main app logic
document.addEventListener('DOMContentLoaded', () => {
  const heapTypeSelect = document.getElementById('heapType');
  const insertBtn = document.getElementById('insertBtn');
  const extractBtn = document.getElementById('extractBtn');
  const clearBtn = document.getElementById('clearBtn');
  const newValueInput = document.getElementById('newValue');
  const heapArrayDiv = document.getElementById('heapArray');
  const treeCanvas = document.getElementById('treeCanvas');
  const messages = document.getElementById('messages');

  let heap = new Heap(heapTypeSelect.value);

  function updateDisplay() {
    const arr = heap.getHeap();
    heapArrayDiv.textContent = JSON.stringify(arr);
    drawHeapTree(arr, treeCanvas, heap.type);
  }

  function showMessage(msg, isError = false) {
    messages.textContent = msg;
    messages.style.color = isError ? '#d33' : '#333';
    if (msg !== '') {
      setTimeout(() => {
        if (messages.textContent === msg) messages.textContent = '';
      }, 3000);
    }
  }

  insertBtn.addEventListener('click', () => {
    const valStr = newValueInput.value.trim();
    if (valStr === '') {
      showMessage('Please enter a value to insert.', true);
      return;
    }
    const val = Number(valStr);
    if (isNaN(val)) {
      showMessage('Invalid number entered.', true);
      return;
    }
    heap.insert(val);
    newValueInput.value = '';
    updateDisplay();
    showMessage(`Inserted value ${val}.`, false);
  });

  extractBtn.addEventListener('click', () => {
    const root = heap.extractRoot();
    if (root === null) {
      showMessage('Heap is empty, nothing to extract.', true);
      return;
    }
    updateDisplay();
    showMessage(`Extracted root value ${root}.`, false);
  });

  clearBtn.addEventListener('click', () => {
    heap.clear();
    updateDisplay();
    showMessage('Heap cleared.', false);
  });

  heapTypeSelect.addEventListener('change', () => {
    heap = new Heap(heapTypeSelect.value);
    updateDisplay();
    showMessage(`Switched to ${heapTypeSelect.options[heapTypeSelect.selectedIndex].text}. Heap cleared.`, false);
  });

  updateDisplay();
});
</script>
</body>
</html>