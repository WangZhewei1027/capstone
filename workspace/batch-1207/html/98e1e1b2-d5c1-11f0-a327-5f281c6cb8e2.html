<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Heap Sort Visualization</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#4f46e5;
    --muted:#94a3b8;
    --good:#16a34a;
    --bad:#ef4444;
    --panel:#071028;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,var(--bg),#071027);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:18px;}
  .app{width:1100px;max-width:98vw;background:linear-gradient(180deg,var(--card),#041025);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(2,6,23,0.7);}
  h1{margin:0 0 8px 0;font-size:18px;color:#e6eef8;}
  .top{display:flex;gap:12px;align-items:center;margin-bottom:12px;}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
  .controls > *{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:#e6eef8;}
  input[type=range]{accent-color:var(--accent); width:140px;}
  button{cursor:pointer;border:none;background:linear-gradient(180deg,var(--accent),#3b34d8);padding:8px 12px;border-radius:8px;color:white;font-weight:600;}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600;}
  .main{display:flex;gap:12px;}
  .left{width:420px;background:linear-gradient(180deg,var(--panel),#041424);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);}
  .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:13px;line-height:1.4;color:#cbd5e1;}
  .line{padding:4px 6px;border-radius:6px;margin-bottom:4px;}
  .line.highlight{background:linear-gradient(90deg,rgba(79,70,229,0.15),rgba(79,70,229,0.06));box-shadow:0 4px 18px rgba(79,70,229,0.06);border-left:4px solid var(--accent);}
  .right{flex:1;background:linear-gradient(180deg,var(--panel),#041424);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:8px;align-items:stretch;}
  canvas{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:block;}
  .status{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;}
  .legend{display:flex;gap:8px;align-items:center;}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:999px;font-size:13px;background:rgba(255,255,255,0.02);}
  .dot{width:10px;height:10px;border-radius:50%;}
  .dot.compare{background:#f59e0b;}
  .dot.swap{background:#ef4444;}
  .dot.sorted{background:#16a34a;}
  .footer-note{font-size:12px;color:var(--muted);margin-top:8px;}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:4px;}
  .row{display:flex;gap:8px;align-items:center;}
  .small{font-size:13px;color:var(--muted);}
  input[type=number]{width:70px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}
  .muted{color:var(--muted);}
  .valueBox{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:46px;text-align:center;}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Heap Sort visualization">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <div>
      <h1>Heap Sort — Interactive Visualization</h1>
      <div class="small muted">Build a max-heap, then repeatedly extract the maximum element to sort the array.</div>
    </div>
    <div class="legend">
      <div class="chip"><span class="dot compare"></span> compare</div>
      <div class="chip"><span class="dot swap"></span> swap</div>
      <div class="chip"><span class="dot sorted"></span> placed</div>
    </div>
  </div>

  <div class="top">
    <div class="controls" style="flex:1;">
      <label style="display:inline-block;">Array size:
        <input id="size" type="number" min="5" max="40" value="12" />
      </label>
      <label style="display:inline-block;">Speed:
        <input id="speed" type="range" min="1" max="10" value="6" />
      </label>
      <label style="display:inline-block;">Max value:
        <input id="maxVal" type="number" min="5" max="200" value="60" />
      </label>
      <button id="randomBtn" class="secondary">Randomize</button>
      <button id="startBtn">Start</button>
      <button id="stepBtn" class="secondary">Step</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>
    <div style="text-align:right;">
      <div class="small muted">Current action:</div>
      <div class="valueBox" id="actionLabel">idle</div>
    </div>
  </div>

  <div class="main">
    <div class="left">
      <div style="font-weight:700;margin-bottom:8px;">Pseudocode (highlighted)</div>
      <div class="code" id="codeBlock" aria-hidden="false">
        <!-- Lines will be injected -->
      </div>
      <div class="footer-note">You can play/pause, step through each comparison/swap, or reset with a new random array.</div>
    </div>

    <div class="right">
      <div class="status">
        <div class="small muted">Array visualization & heap tree</div>
        <div class="small muted">Comparisons: <span id="compCount">0</span> • Swaps: <span id="swapCount">0</span></div>
      </div>
      <canvas id="canvas" width="620" height="420"></canvas>
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="small muted">Heap size: <span id="heapSizeLabel">0</span></div>
        <div class="small muted">Sorted (placed) elements shown in green on the right of the array</div>
      </div>
    </div>
  </div>

  <script>
  // Heap Sort Visualization
  // Single-file interactive demo with play/pause/step and pseudocode highlighting.

  (function(){
    // DOM
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const sizeInput = document.getElementById('size');
    const speedInput = document.getElementById('speed');
    const maxValInput = document.getElementById('maxVal');
    const randomBtn = document.getElementById('randomBtn');
    const startBtn = document.getElementById('startBtn');
    const stepBtn = document.getElementById('stepBtn');
    const resetBtn = document.getElementById('resetBtn');
    const codeBlock = document.getElementById('codeBlock');
    const actionLabel = document.getElementById('actionLabel');
    const compCountEl = document.getElementById('compCount');
    const swapCountEl = document.getElementById('swapCount');
    const heapSizeLabel = document.getElementById('heapSizeLabel');

    // Pseudocode lines for highlighting
    const lines = [
      "heapSort(A):",
      "  n = A.length",
      "  // build max heap",
      "  for i = floor(n/2)-1 downto 0:",
      "    heapify(A, n, i)",
      "  // extract elements from heap",
      "  for end = n-1 downto 1:",
      "    swap(A[0], A[end])",
      "    heapify(A, end, 0)",
      "",
      "heapify(A, heapSize, i):",
      "  largest = i",
      "  left = 2*i + 1",
      "  right = 2*i + 2",
      "  if left < heapSize and A[left] > A[largest]:",
      "    largest = left",
      "  if right < heapSize and A[right] > A[largest]:",
      "    largest = right",
      "  if largest != i:",
      "    swap(A[i], A[largest])",
      "    heapify(A, heapSize, largest)"
    ];

    // Render pseudocode
    function renderCode() {
      codeBlock.innerHTML = '';
      lines.forEach((text, idx) => {
        const div = document.createElement('div');
        div.className = 'line';
        div.id = 'line-' + idx;
        div.textContent = text;
        codeBlock.appendChild(div);
      });
    }
    renderCode();

    // State
    let array = [];
    let heapSize = 0;
    let comparisons = 0;
    let swaps = 0;
    let highlights = { compare: [], swap: [], heapifyIndex: null, building: false };
    let sortedBoundary = null; // index from which elements are 'placed' (i.e., sorted tail)
    let running = false;
    let paused = true;
    let resumeResolve = null;
    let stepRequested = false;

    // Initialize
    function randomArray(n, maxVal) {
      const a = [];
      for (let i=0;i<n;i++) a.push(Math.floor(Math.random() * maxVal) + 1);
      return a;
    }

    function resetMetrics() {
      comparisons = 0; swaps = 0;
      compCountEl.textContent = comparisons;
      swapCountEl.textContent = swaps;
    }

    function setAction(text) {
      actionLabel.textContent = text;
    }

    // Draw visual: array bars on top, tree below
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w = canvas.width, h = canvas.height;
      const pad = 12;
      const arrayAreaH = 80;
      const treeAreaH = h - arrayAreaH - pad*2;

      // Draw array bars
      const n = array.length;
      const barGap = 6;
      const barW = Math.max(6, (w - pad*2 - barGap*(n-1)) / n);
      const maxVal = Math.max(1, ...array);
      for (let i=0;i<n;i++){
        const x = pad + i*(barW + barGap);
        const val = array[i];
        const barH = (arrayAreaH - 24) * (val / maxVal);
        const y = pad + (arrayAreaH - barH);
        // Determine color:
        let fill = '#2b3440';
        if (highlights.swap && highlights.swap.includes(i)) fill = '#ef4444';
        else if (highlights.compare && highlights.compare.includes(i)) fill = '#f59e0b';
        else if (sortedBoundary !== null && i >= sortedBoundary) fill = '#16a34a';
        else fill = '#3b82f6';
        ctx.fillStyle = fill;
        roundRect(ctx, x, y, barW, barH, 4);
        ctx.fill();

        // border
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeRect(x, y, barW, barH);

        // value text
        ctx.fillStyle = '#e6eef8';
        ctx.font = '12px ui-monospace, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(String(val), x + barW/2, y - 6);
      }

      // Draw heap tree
      const treeTop = pad + arrayAreaH + 6;
      if (n === 0) return;
      // node positions by index
      const positions = [];
      // compute levels
      let level = 0;
      while ((1<<level) <= n) level++;
      // levelCount = level
      for (let i=0;i<n;i++){
        const lvl = Math.floor(Math.log2(i+1));
        const indexInLevel = i - ((1<<lvl)-1);
        const itemsInThisLevel = Math.min(n - ((1<<lvl)-1), 1<<lvl);
        const spacing = (w - pad*2) / (itemsInThisLevel);
        const x = pad + spacing*(indexInLevel) + spacing/2;
        const y = treeTop + lvl * 78;
        positions[i] = {x,y};
      }
      // draw edges
      ctx.lineWidth = 2;
      for (let i=0;i<n;i++){
        const left = 2*i+1, right = 2*i+2;
        const p = positions[i];
        if (!p) continue;
        if (left < n){
          drawEdge(p, positions[left], left);
        }
        if (right < n){
          drawEdge(p, positions[right], right);
        }
      }
      // draw nodes
      for (let i=0;i<n;i++){
        const p = positions[i];
        const nodeR = 18;
        // fill based on state
        let nodeFill = '#082032';
        if (highlights.swap && highlights.swap.includes(i)) nodeFill = '#ef4444';
        else if (highlights.compare && highlights.compare.includes(i)) nodeFill = '#f59e0b';
        else if (sortedBoundary !== null && i >= sortedBoundary) nodeFill = '#064e3b';
        else nodeFill = '#08304b';
        ctx.beginPath();
        ctx.fillStyle = nodeFill;
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        roundRect(ctx, p.x - nodeR, p.y - nodeR, nodeR*2, nodeR*2, 12);
        ctx.fill();
        ctx.stroke();

        // index label small
        ctx.fillStyle = '#9fb2c9';
        ctx.font = '11px ui-monospace, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(String(i), p.x, p.y - 6);

        // value
        ctx.fillStyle = '#e6eef8';
        ctx.font = '13px ui-monospace, monospace';
        ctx.fillText(String(array[i]), p.x, p.y + 10);
      }

      // heap size label
      heapSizeLabel.textContent = String(heapSize);
    }

    function drawEdge(p1, p2, childIndex) {
      ctx.beginPath();
      // color line differently if child is in sorted boundary (extracted) - draw faded
      if (sortedBoundary !== null && childIndex >= sortedBoundary) ctx.strokeStyle = 'rgba(16,185,129,0.12)';
      else ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 2;
      ctx.moveTo(p1.x, p1.y + 16);
      ctx.quadraticCurveTo((p1.x + p2.x)/2, (p1.y + p2.y)/2, p2.x, p2.y - 16);
      ctx.stroke();
    }

    function roundRect(ctx, x, y, w, h, r) {
      const radius = r || 4;
      ctx.beginPath();
      ctx.moveTo(x+radius, y);
      ctx.arcTo(x+w, y, x+w, y+h, radius);
      ctx.arcTo(x+w, y+h, x, y+h, radius);
      ctx.arcTo(x, y+h, x, y, radius);
      ctx.arcTo(x, y, x+w, y, radius);
      ctx.closePath();
    }

    // Helpers to control pausing and stepping
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // wait() returns when allowed to proceed one atomic visualization step.
    // If running but not paused: waits for delay
    // If paused: waits until resume (play) OR a single step is requested.
    async function wait() {
      const baseDelay = 600; // base milliseconds
      const speed = Number(speedInput.value) || 6;
      const delay = Math.max(40, baseDelay - (speed-1)*60); // faster => smaller delay

      if (!paused) {
        await sleep(delay);
        return;
      } else {
        // paused: return on step or resume
        setAction('paused');
        return new Promise(res=>{
          resumeResolve = (mode) => {
            resumeResolve = null;
            if (mode === 'step') {
              // one step: resolve immediately
              res();
            } else {
              // resumed: wait delay then continue
              sleep(delay).then(res);
            }
          };
        });
      }
    }

    // Highlight helpers
    function setCompare(i,j) {
      highlights.compare = [i];
      if (typeof j === 'number') highlights.compare.push(j);
      highlights.swap = [];
      updateUI();
    }
    function setSwap(i,j) {
      highlights.swap = [i];
      if (typeof j === 'number') highlights.swap.push(j);
      highlights.compare = [];
      updateUI();
    }
    function clearHighlights() {
      highlights.compare = [];
      highlights.swap = [];
      updateUI();
    }

    // Update pseudocode highlight and UI
    function highlightLine(idx) {
      // clear
      for (let k=0;k<lines.length;k++){
        const el = document.getElementById('line-'+k);
        if (el) el.classList.remove('highlight');
      }
      if (typeof idx === 'number' && idx >= 0 && idx < lines.length) {
        const el = document.getElementById('line-'+idx);
        if (el) el.classList.add('highlight');
      }
    }

    function updateUI() {
      compCountEl.textContent = comparisons;
      swapCountEl.textContent = swaps;
      draw();
    }

    // Async heapify with visualization
    async function heapify(i) {
      highlightLine(11); // "heapify..."
      setAction(`heapify: index ${i}`);
      await wait();

      let largest = i;
      highlightLine(12); // largest = i
      await wait();

      const left = 2*i + 1;
      const right = 2*i + 2;
      highlightLine(13);
      await wait();

      if (left < heapSize) {
        highlightLine(14); // compare left
        setCompare(left, largest);
        setAction(`compare A[${left}] (${array[left]}) vs A[${largest}] (${array[largest]})`);
        comparisons++; updateUI();
        await wait();
        if (array[left] > array[largest]) {
          largest = left;
          highlightLine(15); // largest = left
          setAction(`largest = ${left}`);
          await wait();
        }
      }

      if (right < heapSize) {
        highlightLine(16); // compare right
        setCompare(right, largest);
        setAction(`compare A[${right}] (${array[right]}) vs A[${largest}] (${array[largest]})`);
        comparisons++; updateUI();
        await wait();
        if (array[right] > array[largest]) {
          largest = right;
          highlightLine(17); // largest = right
          setAction(`largest = ${right}`);
          await wait();
        }
      }

      if (largest !== i) {
        // swap and recurse
        highlightLine(18); // if largest != i
        setAction(`swap A[${i}] (${array[i]}) and A[${largest}] (${array[largest]})`);
        setSwap(i, largest);
        await wait();
        // perform swap
        const tmp = array[i]; array[i] = array[largest]; array[largest] = tmp;
        swaps++; updateUI();
        await wait();
        highlightLine(19); // swap line
        await wait();
        // recursive heapify on largest
        await heapify(largest);
      } else {
        clearHighlights();
        highlightLine(null);
        setAction('heapify done');
        await wait();
      }
    }

    // Heap sort main routine (async)
    async function heapSort() {
      running = true;
      paused = false;
      startBtn.textContent = 'Pause';
      setAction('build max-heap');
      highlightLine(2);
      await wait();

      heapSize = array.length;
      // build max heap
      for (let i = Math.floor(heapSize/2) - 1; i >= 0; i--) {
        highlightLine(3);
        setAction(`build: heapify index ${i}`);
        await wait();
        await heapify(i);
      }
      setAction('max heap built');
      highlightLine(null);
      await wait();

      // extract elements
      for (let end = array.length - 1; end >= 1; end--) {
        highlightLine(6);
        setAction(`extract max -> swap A[0] and A[${end}]`);
        setSwap(0,end);
        await wait();
        // swap root with end
        const tmp = array[0]; array[0] = array[end]; array[end] = tmp;
        swaps++; updateUI();
        // mark that element as sorted
        sortedBoundary = end;
        await wait();

        heapSize = end; // reduce heap
        setAction(`heapify at root for heapSize=${heapSize}`);
        await wait();
        await heapify(0);
      }

      // done
      sortedBoundary = 0;
      highlights = {compare:[], swap:[], heapifyIndex:null};
      updateUI();
      setAction('sorted');
      running = false;
      paused = true;
      startBtn.textContent = 'Start';
      highlightLine(null);
    }

    // Controls
    function initArray() {
      const n = Math.max(5, Math.min(40, Number(sizeInput.value) || 12));
      const maxVal = Math.max(5, Number(maxValInput.value) || 60);
      array = randomArray(n, maxVal);
      heapSize = array.length;
      sortedBoundary = array.length;
      resetMetrics();
      clearHighlights();
      setAction('ready');
      draw();
    }

    randomBtn.addEventListener('click', () => {
      if (running) return;
      initArray();
    });

    resetBtn.addEventListener('click', () => {
      if (running) return;
      initArray();
    });

    startBtn.addEventListener('click', async () => {
      if (!running) {
        // start
        // reset metrics if starting fresh
        if (sortedBoundary === null || sortedBoundary === array.length) {
          // new run
        }
        paused = false;
        running = true;
        startBtn.textContent = 'Pause';
        stepRequested = false;
        heapSize = array.length;
        // start heap sort
        heapSort().catch(err=>{
          console.error(err);
          running=false;
          paused=true;
        });
      } else {
        // toggle pause
        paused = !paused;
        if (!paused) {
          // resume
          setAction('running');
          startBtn.textContent = 'Pause';
          if (resumeResolve) resumeResolve('resume');
          else resumeResolve = null;
        } else {
          setAction('paused');
          startBtn.textContent = 'Resume';
        }
      }
    });

    stepBtn.addEventListener('click', () => {
      if (!running) {
        // start in paused mode and take one step
        paused = true;
        running = true;
        startBtn.textContent = 'Resume';
        heapSize = array.length;
        // start heapSort but it will immediately hit wait() and pause
        heapSort().catch(err=>{
          console.error(err);
          running=false;
          paused=true;
        });
      }
      // Trigger single step resolution
      if (resumeResolve) {
        resumeResolve('step');
      } else {
        // nothing currently waiting; still set a token that wait() will check
        // but our wait() always sets resumeResolve when paused; so this is unlikely
      }
    });

    // Handle manual resumeResolve calls from outside (buttons)
    window.addEventListener('click', (e)=>{
      // no-op
    });

    // If user pressed space or Enter while focused on buttons, allow keyboard step/pause
    document.addEventListener('keydown', (e)=>{
      if (e.code === 'Space') {
        e.preventDefault();
        startBtn.click();
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        stepBtn.click();
      } else if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        randomBtn.click();
      }
    });

    // initialize UI
    initArray();

    // keep drawing occasionally to reflect changes
    let anim = setInterval(draw, 200);

    // expose some things for debugging (not required)
    window.__heapViz = { array, draw };

  })();
  </script>
</div>
</body>
</html>