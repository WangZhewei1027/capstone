<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Insertion Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#38bdf8;
      --muted:#94a3b8;
      --bar:#60a5fa;
      --bar-compare:#fb7185;
      --bar-key:#f97316;
      --bar-shift:#34d399;
      --bar-sorted:#7c3aed;
      --text:#e6eef8;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{margin:0;background:linear-gradient(180deg,#071029 0%, #071527 100%);color:var(--text);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px;}
    .container{width:100%;max-width:1100px;border-radius:12px;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow: 0 8px 30px rgba(2,6,23,0.6);}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;}
    header h1{font-size:20px;margin:0;color:var(--accent);}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .controls > *{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--text);font-size:13px;}
    .controls label{display:flex;gap:8px;align-items:center;}
    input[type=range]{width:140px;}
    button{cursor:pointer;border:none;background:linear-gradient(90deg,var(--accent),#7dd3fc);color:#021028;padding:8px 12px;border-radius:8px;font-weight:600;}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);}
    .main{display:grid;grid-template-columns: 1fr 380px;gap:18px;align-items:start;}
    .visualizer{background:rgba(255,255,255,0.02);border-radius:10px;padding:12px;min-height:320px;display:flex;flex-direction:column;gap:12px;}
    .bars-wrap{flex:1;display:flex;align-items:end;gap:6px;padding:6px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);position:relative;overflow:hidden;}
    .bar{flex:1 1 auto;height:40px;border-radius:6px;background:var(--bar);display:flex;align-items:end;justify-content:center;color:rgba(0,0,0,0.6);font-size:12px;position:relative;transition:height 200ms, transform 200ms, background-color 160ms;}
    .bar .val{position:absolute;bottom:6px;width:100%;text-align:center;font-weight:600;color:rgba(3,7,18,0.7);font-size:12px;}
    .floating-key{position:absolute;pointer-events:none;z-index:10;padding:6px 8px;border-radius:6px;background:var(--bar-key);color:#021028;font-weight:700;transform:translate(-50%,-100%);box-shadow:0 8px 20px rgba(7,11,26,0.7);display:none;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;font-size:12px;color:var(--muted);}
    .legend span{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);}
    .legend .sw{width:12px;height:12px;border-radius:3px;display:inline-block;}
    .panel{background:rgba(255,255,255,0.01);padding:12px;border-radius:10px;min-height:320px;overflow:auto;}
    .panel h3{margin:0 0 8px 0;color:var(--accent);font-size:15px;}
    .pseudo{background:linear-gradient(180deg, rgba(10,14,22,0.4), rgba(255,255,255,0.01));padding:10px;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono",monospace;font-size:13px;color:var(--muted);line-height:1.5;}
    .pseudo .line{padding:4px 6px;border-radius:6px;}
    .pseudo .active{background:linear-gradient(90deg, rgba(56,189,248,0.12), rgba(124,58,237,0.06));color:var(--text);}
    .stats{margin-top:10px;font-size:13px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;}
    .input-row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}
    textarea{width:100%;min-height:56px;background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--text);resize:vertical;font-size:13px;}
    .small{font-size:12px;color:var(--muted);}
    footer{margin-top:12px;font-size:12px;color:var(--muted);display:flex;justify-content:space-between;flex-wrap:wrap;gap:8px;}
    @media (max-width:900px){ .main{grid-template-columns:1fr; } .controls{justify-content:center;} }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Insertion Sort Visualizer">
    <header>
      <h1>Insertion Sort â€” Visualizer</h1>
      <div class="controls" aria-hidden="false">
        <label class="small">Size
          <input id="sizeRange" type="range" min="5" max="60" value="20" />
        </label>
        <label class="small">Speed
          <input id="speedRange" type="range" min="50" max="1200" value="220" />
        </label>
        <label class="small">Order
          <select id="orderSelect">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </label>
        <button id="generateBtn" class="secondary">Generate</button>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <button id="stepBtn" class="secondary">Step</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
    </header>

    <div class="main">
      <div class="visualizer" aria-live="polite">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="legend" role="list" aria-label="Legend">
            <span><i class="sw" style="background:var(--bar)"></i> Unsorted</span>
            <span><i class="sw" style="background:var(--bar-key)"></i> Key</span>
            <span><i class="sw" style="background:var(--bar-compare)"></i> Comparing</span>
            <span><i class="sw" style="background:var(--bar-shift)"></i> Shift</span>
            <span><i class="sw" style="background:var(--bar-sorted)"></i> Sorted</span>
          </span>
          </div>
          <div class="small">Tip: use Step to progress one operation at a time.</div>
        </div>

        <div class="bars-wrap" id="barsWrap" aria-label="Array visualization">
          <!-- bars inserted here -->
          <div id="floatingKey" class="floating-key" aria-hidden="true"></div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="small" id="status">Ready</div>
          <div class="small" id="opsCounter">Operations: 0</div>
        </div>
      </div>

      <div class="panel">
        <h3>Pseudocode</h3>
        <div class="pseudo" id="pseudo">
          <div class="line" data-line="1">for i = 1 to n-1</div>
          <div class="line" data-line="2" style="padding-left:12px">key = A[i]</div>
          <div class="line" data-line="3" style="padding-left:12px">j = i - 1</div>
          <div class="line" data-line="4" style="padding-left:12px">while j >= 0 and A[j] > key</div>
          <div class="line" data-line="5" style="padding-left:24px">A[j + 1] = A[j]</div>
          <div class="line" data-line="6" style="padding-left:24px">j = j - 1</div>
          <div class="line" data-line="7" style="padding-left:12px">A[j + 1] = key</div>
        </div>

        <h3 style="margin-top:12px">Array Input (optional)</h3>
        <div class="input-row">
          <textarea id="arrayInput" placeholder="e.g., 5,3,8,1,2 (leave blank to use random)"></textarea>
        </div>
        <div class="stats">
          <div id="complexity">Time Complexity: Best O(n), Average O(n^2), Worst O(n^2)</div>
          <div>Space Complexity: O(1)</div>
        </div>

        <footer>
          <div class="small">Insertion Sort: builds the sorted array one element at a time by inserting the current element into the correct position.</div>
          <div class="small">Highlights: key (orange), comparing (red), shifting (green), sorted (purple)</div>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Insertion Sort Visualizer
    (function(){
      const barsWrap = document.getElementById('barsWrap');
      const floatingKeyEl = document.getElementById('floatingKey');
      const sizeRange = document.getElementById('sizeRange');
      const speedRange = document.getElementById('speedRange');
      const generateBtn = document.getElementById('generateBtn');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const orderSelect = document.getElementById('orderSelect');
      const arrayInput = document.getElementById('arrayInput');
      const statusEl = document.getElementById('status');
      const opsCounter = document.getElementById('opsCounter');
      const pseudo = document.getElementById('pseudo');
      const lines = Array.from(pseudo.querySelectorAll('.line'));

      let array = [];
      let initialArray = [];
      let bars = [];
      let generator = null;
      let running = false;
      let paused = false;
      let timer = null;
      let ops = 0;
      const colors = {
        default: 'var(--bar)',
        compare: 'var(--bar-compare)',
        key: 'var(--bar-key)',
        shift: 'var(--bar-shift)',
        sorted: 'var(--bar-sorted)'
      };

      function logStatus(s){
        statusEl.textContent = s;
      }

      function setOps(n){
        ops = n;
        opsCounter.textContent = 'Operations: ' + ops;
      }

      function clearHighlight(){
        lines.forEach(l => l.classList.remove('active'));
      }

      function highlight(lineNum){
        clearHighlight();
        const el = pseudo.querySelector('[data-line="'+lineNum+'"]');
        if(el) el.classList.add('active');
      }

      function generateRandom(n){
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(Math.floor(Math.random()*100)+5);
        }
        return arr;
      }

      function createBars(arr){
        barsWrap.innerHTML = '';
        bars = [];
        const max = Math.max(...arr, 1);
        arr.forEach((v,i)=>{
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = (v/max*100) + '%';
          bar.dataset.index = i;
          const val = document.createElement('div');
          val.className = 'val';
          val.textContent = v;
          bar.appendChild(val);
          barsWrap.appendChild(bar);
          bars.push(bar);
        });
        // re-add floating key element
        barsWrap.appendChild(floatingKeyEl);
        floatingKeyEl.style.display = 'none';
      }

      function updateBars(){
        const max = Math.max(...array,1);
        array.forEach((v,i)=>{
          const b = bars[i];
          b.style.height = (v/max*100) + '%';
          b.querySelector('.val').textContent = v;
          b.style.background = 'var(--bar)';
          b.style.transform = 'translateY(0)';
        });
      }

      function colorBar(idx, colorKey){
        if(idx < 0 || idx >= bars.length) return;
        bars[idx].style.background = colors[colorKey] || colorKey;
      }

      function markSorted(upto){
        for(let k=0;k<=upto;k++){
          if(bars[k]) bars[k].style.background = colors.sorted;
        }
      }

      function showFloatingKey(value, fromBarIndex){
        floatingKeyEl.textContent = value;
        const bar = bars[fromBarIndex];
        if(!bar) return;
        const rect = barsWrap.getBoundingClientRect();
        const bRect = bar.getBoundingClientRect();
        floatingKeyEl.style.left = (bRect.left - rect.left + bRect.width/2) + 'px';
        floatingKeyEl.style.top = (bRect.top - rect.top) + 'px';
        floatingKeyEl.style.display = 'block';
      }

      function moveFloatingToIndex(idx){
        const bar = bars[idx];
        if(!bar) return;
        const rect = barsWrap.getBoundingClientRect();
        const bRect = bar.getBoundingClientRect();
        floatingKeyEl.style.left = (bRect.left - rect.left + bRect.width/2) + 'px';
      }

      function hideFloating(){
        floatingKeyEl.style.display = 'none';
      }

      // Generator that yields step objects describing operations
      function* insertionSortGen(arr, order){
        const n = arr.length;
        for(let i=1;i<n;i++){
          yield {type:'select', i}; // selecting i
          let key = arr[i];
          yield {type:'keyAssigned', i, key};
          let j = i-1;
          yield {type:'initWhile', i, j, key};
          // condition check
          while(j >= 0 && ((order==='asc' && arr[j] > key) || (order==='desc' && arr[j] < key))){
            yield {type:'compare', i, j, key};
            // shift arr[j] to arr[j+1]
            arr[j+1] = arr[j];
            yield {type:'shift', from:j, to:j+1, i};
            j = j - 1;
            yield {type:'decrement', j, i};
          }
          yield {type:'exitWhile', i, j, key};
          arr[j+1] = key;
          yield {type:'insert', pos:j+1, key, i};
          // mark sorted prefix optionally; but not final mark of full sorted
          yield {type:'mark', upto:i};
        }
        yield {type:'done'};
      }

      // Step executor: performs a single yielded operation and updates visualization
      function handleStep(step){
        if(!step) return;
        const t = step.type;
        switch(t){
          case 'select':
            logStatus('Selecting i = ' + step.i);
            highlight(1);
            // color current index
            updateBars();
            colorBar(step.i, 'key');
            break;
          case 'keyAssigned':
            highlight(2);
            showFloatingKey(step.key, step.i);
            colorBar(step.i, 'key');
            break;
          case 'initWhile':
            highlight(3);
            // position floating key above the key bar
            moveFloatingToIndex(step.i);
            break;
          case 'compare':
            highlight(4);
            logStatus(`Comparing A[${step.j}] and key (${array[step.j]} ? ${step.key})`);
            // color comparing bar and key
            colorBar(step.j, 'compare');
            moveFloatingToIndex(step.i);
            break;
          case 'shift':
            highlight(5);
            logStatus(`Shifting A[${step.from}] -> position ${step.to}`);
            // animate height change by updating bars (array already mutated in generator)
            updateBars();
            // color the shifted bar
            colorBar(step.to, 'shift');
            // small transform to show movement
            bars[step.to].style.transform = 'translateY(-6px)';
            break;
          case 'decrement':
            highlight(6);
            logStatus(`j becomes ${step.j}`);
            // clear transforms after short while
            setTimeout(()=>{ bars.forEach(b=>b.style.transform='translateY(0)'); }, Math.min(180, speedRange.value));
            break;
          case 'exitWhile':
            highlight(4);
            logStatus('Exit while, will insert key at j+1');
            moveFloatingToIndex(step.i); // still above original index until insert
            break;
          case 'insert':
            highlight(7);
            logStatus(`Inserting key (${step.key}) at position ${step.pos}`);
            // place key into array (already mutated)
            updateBars();
            // animate by showing floating key move to insert position then hide
            moveFloatingToIndex(step.pos);
            setTimeout(()=>{ hideFloating(); }, Math.min(200, speedRange.value));
            break;
          case 'mark':
            markSorted(step.upto);
            break;
          case 'done':
            clearHighlight();
            logStatus('Sorting complete');
            // mark all as sorted
            for(let k=0;k<bars.length;k++) bars[k].style.background = colors.sorted;
            hideFloating();
            break;
        }
      }

      // Controls interactions
      function prepareFromInputOrRandom(){
        const txt = arrayInput.value.trim();
        if(txt){
          const parts = txt.split(',').map(s=>s.trim()).filter(s=>s.length>0);
          const parsed = parts.map(s=>Number(s)).filter(n=>!Number.isNaN(n));
          if(parsed.length > 0){
            array = parsed.slice();
            return;
          }
        }
        const n = Number(sizeRange.value);
        array = generateRandom(n);
      }

      function resetAll(){
        running = false;
        paused = false;
        if(timer) { clearTimeout(timer); timer=null; }
        setOps(0);
        clearHighlight();
        prepareFromInputOrRandom();
        initialArray = array.slice();
        createBars(array);
        logStatus('Ready');
        generator = null;
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
        resetBtn.disabled = false;
        generateBtn.disabled = false;
      }

      generateBtn.addEventListener('click', ()=>{
        resetAll();
      });

      sizeRange.addEventListener('input', ()=>{
        // generate new array when size changes
        resetAll();
      });

      // Start running continuously
      startBtn.addEventListener('click', ()=>{
        if(!generator){
          // start fresh
          prepareFromInputOrRandom();
          initialArray = array.slice();
          createBars(array);
          generator = insertionSortGen(array, orderSelect.value);
        }
        running = true;
        paused = false;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        generateBtn.disabled = true;
        stepBtn.disabled = true;
        resetBtn.disabled = true;
        runLoop();
      });

      // Pause
      pauseBtn.addEventListener('click', ()=>{
        paused = true;
        running = false;
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
        resetBtn.disabled = false;
        generateBtn.disabled = false;
        logStatus('Paused');
        if(timer){ clearTimeout(timer); timer = null; }
      });

      // Single step
      stepBtn.addEventListener('click', ()=>{
        if(!generator){
          prepareFromInputOrRandom();
          initialArray = array.slice();
          createBars(array);
          generator = insertionSortGen(array, orderSelect.value);
        }
        const res = generator.next();
        if(!res.done){
          handleStep(res.value);
          setOps(ops+1);
        } else {
          handleStep(res.value);
        }
        if(res.done){
          generator = null;
          startBtn.disabled = false;
          pauseBtn.disabled = true;
          stepBtn.disabled = true;
          resetBtn.disabled = false;
          generateBtn.disabled = false;
        }
      });

      // Reset to initial unsorted array
      resetBtn.addEventListener('click', ()=>{
        if(generator && !paused){
          // if running, stop
          paused = true;
          running = false;
          if(timer){ clearTimeout(timer); timer=null; }
        }
        array = initialArray.slice();
        updateBars();
        hideFloating();
        generator = null;
        setOps(0);
        clearHighlight();
        logStatus('Reset to initial array');
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
        generateBtn.disabled = false;
      });

      orderSelect.addEventListener('change', ()=>{
        // update pseudocode comparisons visually (we keep same pseudocode)
      });

      function runLoop(){
        if(!running) return;
        const stepDelay = Number(speedRange.value);
        const res = generator.next();
        if(res.done){
          handleStep(res.value);
          running = false;
          generator = null;
          startBtn.disabled = false;
          pauseBtn.disabled = true;
          stepBtn.disabled = true;
          resetBtn.disabled = false;
          generateBtn.disabled = false;
          return;
        } else {
          handleStep(res.value);
          setOps(ops+1);
          // schedule next
          timer = setTimeout(()=>{
            runLoop();
          }, stepDelay);
        }
      }

      // initialize on load
      resetAll();

      // Accessibility: keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === ' '){
          e.preventDefault();
          if(running) { pauseBtn.click(); } else { startBtn.click(); }
        } else if(e.key === 'ArrowRight'){
          stepBtn.click();
        } else if(e.key === 'r' && (e.ctrlKey || e.metaKey)){
          e.preventDefault();
          resetBtn.click();
        }
      });

      // Small UX: disable pause button initially
      pauseBtn.disabled = true;

      // Provide ability to paste array then press generate to use it
      generateBtn.addEventListener('click', ()=>{
        resetAll();
      });

      // Update bars when window resizes to keep floating position correct
      window.addEventListener('resize', ()=>{
        // if floating visible, reposition it relative to current index if possible
        // no-op for now
      });

    })();
  </script>
</body>
</html>