<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weighted Graph Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        #graph-canvas {
            border: 1px solid #ddd;
            background: #f8f9fa;
        }
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .node {
            cursor: pointer;
        }
        .weight-label {
            font-size: 12px;
            font-weight: bold;
            fill: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Weighted Graph Visualization</h1>
        
        <div class="controls">
            <button onclick="addNode()">Add Node</button>
            <button onclick="addEdge()">Add Edge</button>
            <button onclick="findShortestPath()">Find Shortest Path</button>
            <button onclick="clearGraph()">Clear Graph</button>
            <button onclick="generateRandomGraph()">Generate Random Graph</button>
        </div>

        <div>
            <svg id="graph-canvas" width="1000" height="600"></svg>
        </div>

        <div class="info-panel">
            <h3>Graph Information</h3>
            <p id="graph-info">Nodes: 0, Edges: 0</p>
            <p id="shortest-path">Shortest path will appear here</p>
            <p><strong>Instructions:</strong> Click "Add Node" to add nodes, then "Add Edge" to connect them with weights</p>
        </div>
    </div>

    <script>
        class WeightedGraph {
            constructor() {
                this.nodes = new Map();
                this.edges = [];
            }

            addNode(id, x, y) {
                this.nodes.set(id, { id, x, y, edges: [] });
            }

            addEdge(from, to, weight) {
                if (this.nodes.has(from) && this.nodes.has(to)) {
                    const edge = { from, to, weight };
                    this.edges.push(edge);
                    this.nodes.get(from).edges.push(edge);
                    this.nodes.get(to).edges.push({ from: to, to: from, weight });
                }
            }

            dijkstra(start, end) {
                const distances = new Map();
                const previous = new Map();
                const unvisited = new Set();

                // Initialize distances
                for (const nodeId of this.nodes.keys()) {
                    distances.set(nodeId, nodeId === start ? 0 : Infinity);
                    previous.set(nodeId, null);
                    unvisited.add(nodeId);
                }

                while (unvisited.size > 0) {
                    // Get node with smallest distance
                    let current = null;
                    for (const nodeId of unvisited) {
                        if (current === null || distances.get(nodeId) < distances.get(current)) {
                            current = nodeId;
                        }
                    }

                    if (current === end || distances.get(current) === Infinity) break;

                    unvisited.delete(current);

                    // Update distances to neighbors
                    const currentNode = this.nodes.get(current);
                    for (const edge of currentNode.edges) {
                        if (unvisited.has(edge.to)) {
                            const alt = distances.get(current) + edge.weight;
                            if (alt < distances.get(edge.to)) {
                                distances.set(edge.to, alt);
                                previous.set(edge.to, current);
                            }
                        }
                    }
                }

                // Reconstruct path
                const path = [];
                let current = end;
                while (previous.get(current) !== null) {
                    path.unshift(current);
                    current = previous.get(current);
                }
                if (path.length > 0) path.unshift(start);

                return {
                    path: distances.get(end) !== Infinity ? path : [],
                    distance: distances.get(end)
                };
            }
        }

        class GraphRenderer {
            constructor(svgElement) {
                this.svg = svvgElement;
                this.graph = new WeightedGraph();
                this.nodeCounter = 0;
                this.isAddingEdge = false;
                this.edgeStartNode = null;
                this.selectedNodes = new Set();
                this.init();
            }

            init() {
                this.svg.innerHTML = '';
                this.updateInfo();
            }

            addNode(x, y) {
                const nodeId = `N${++this.nodeCounter}`;
                this.graph.addNode(nodeId, x, y);
                this.render();
                return nodeId;
            }

            addEdgeWithWeight(from, to, weight) {
                this.graph.addEdge(from, to, weight);
                this.render();
            }

            render() {
                this.svg.innerHTML = '';

                // Render edges
                this.graph.edges.forEach(edge => {
                    const fromNode = this.graph.nodes.get(edge.from);
                    const toNode = this.graph.nodes.get(edge.to);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromNode.x);
                    line.setAttribute('y1', fromNode.y);
                    line.setAttribute('x2', toNode.x);
                    line.setAttribute('y2', toNode.y);
                    line.setAttribute('stroke', this.selectedNodes.has(edge.from) && 
                                              this.selectedNodes.has(edge.to) ? '#28a745' : '#007bff');
                    line.setAttribute('stroke-width', '2');
                    this.svg.appendChild(line);

                    // Weight label
                    const midX = (fromNode.x + toNode.x) / 2;
                    const midY = (fromNode.y + toNode.y) / 2;
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', midX);
                    text.setAttribute('y', midY - 5);
                    text.setAttribute('class', 'weight-label');
                    text.textContent = edge.weight;
                    this.svg.appendChild(text);
                });

                // Render nodes
                for (const [id, node] of this.graph.nodes) {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', '20');
                    circle.setAttribute('fill', this.selectedNodes.has(id) ? '#28a745' : '#007bff');
                    circle.setAttribute('class', 'node');
                    circle.setAttribute('data-nodeid', id);
                    
                    circle.addEventListener('click', (e) => this.handleNodeClick(id, e));
                    this.svg.appendChild(circle);

                    // Node label
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = id;
                    this.svg.appendChild(text);
                }

                this.updateInfo();
            }

            handleNodeClick(nodeId, event) {
                if (this.isAddingEdge) {
                    if (this.edgeStartNode === null) {
                        this.edgeStartNode = nodeId;
                        this.selectedNodes.add(nodeId);
                    } else {
                        const weight = prompt(`Enter weight for edge between ${this.edgeStartNode} and ${nodeId}:`, '1');
                        if (weight && !isNaN(parseFloat(weight))) {
                            this.addEdgeWithWeight(this.edgeStartNode, nodeId, parseFloat(weight));
                        }
                        this.isAddingEdge = false;
                        this.edgeStartNode = null;
                        this.selectedNodes.clear();
                    }
                    this.render();
                } else {
                    // Select/deselect node for path finding
                    if (this.selectedNodes.has(nodeId)) {
                        this.selectedNodes.delete(nodeId);
                    } else {
                        this.selectedNodes.add(nodeId);
                    }
                    this.render();
                }
                event.stopPropagation();
            }

            findShortestPath() {
                const selected = Array.from(this.selectedNodes);
                if (selected.length !== 2) {
                    alert('Please select exactly 2 nodes for path finding');
                    return;
                }

                const result = this.graph.dijkstra(selected[0], selected[1]);
                const pathInfo = document.getElementById('shortest-path');
                
                if (result.path.length > 0) {
                    pathInfo.textContent = `Shortest path from ${selected[0]} to ${selected[1]}: ${result.path.join(' â†’ ')} (Distance: ${result.distance})`;
                    this.highlightPath(result.path);
                } else {
                    pathInfo.textContent = `No path found between ${selected[0]} and ${selected[1]}`;
                }
            }

            highlightPath(path) {
                this.selectedNodes.clear();
                path.forEach(node => this.selectedNodes.add(node));
                this.render();
            }

            clear() {
                this.graph = new WeightedGraph();
                this.nodeCounter = 0;
                this.selectedNodes.clear();
                this.isAddingEdge = false;
                this.edgeStartNode = null;
                this.init();
            }

            updateInfo() {
                const info = document.getElementById('graph-info');
                info.textContent = `Nodes: ${this.graph.nodes.size}, Edges: ${this.graph.edges.length}`;
            }

            generateRandomGraph() {
                this.clear();
                
                // Add 6-8 random nodes
                const nodeCount = Math.floor(Math.random() * 3) + 6;
                const nodes = [];
                
                for (let i = 0; i < nodeCount; i++) {
                    const x = 100 + Math.random() * 800;
                    const y = 100 + Math.random() * 400;
                    nodes.push(this.addNode(x, y));
                }

                // Add random edges
                for (let i = 0; i < nodeCount * 1.5; i++) {
                    const from = nodes[Math.floor(Math.random() * nodes.length)];
                    const to = nodes[Math.floor(Math.random() * nodes.length)];
                    if (from !== to) {
                        const weight = Math.floor(Math.random() * 20) + 1;
                        this.addEdgeWithWeight(from, to, weight);
                    }
                }
            }
        }

        // Initialize the application
        const svg = document.getElementById('graph-canvas');
        const renderer = new GraphRenderer(svg);

        // Add node on canvas click
        svg.addEventListener('click', (event) => {
            if (!renderer.isAddingEdge) {
                const rect = svg.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                renderer.addNode(x, y);
            }
        });

        // Global functions for button controls
        function addNode() {
            renderer.isAddingEdge = false;
            renderer.edgeStartNode = null;
            renderer.selectedNodes.clear();
        }

        function addEdge() {
            renderer.isAddingEdge = true;
            renderer.edgeStartNode = null;
            renderer.selectedNodes.clear();
            alert('Click on two nodes to create an edge. Enter weight when prompted.');
        }

        function findShortestPath() {
            renderer.findShortestPath();
        }

        function clearGraph() {
            renderer.clear();
            document.getElementById('shortest-path').textContent = 'Shortest path will appear here';
        }

        function generateRandomGraph() {
            renderer.generateRandomGraph();
        }
    </script>
</body>
</html>