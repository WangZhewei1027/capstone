<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth-First Search (DFS) Visualization</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .description {
            margin-bottom: 20px;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .graph-container {
            flex: 1;
            min-width: 300px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .visualization-container {
            flex: 1;
            min-width: 300px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            overflow: auto;
        }
        
        #graph-canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .node.visited {
            background-color: #e74c3c;
        }
        
        .node.current {
            background-color: #f39c12;
        }
        
        .node.start {
            background-color: #2ecc71;
        }
        
        .edge {
            position: absolute;
            height: 3px;
            background-color: #7f8c8d;
            transform-origin: 0 0;
            z-index: -1;
        }
        
        .log {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            font-family: monospace;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-entry.visited {
            background-color: #ffebee;
            color: #c62828;
        }
        
        .log-entry.current {
            background-color: #fff3e0;
            color: #ef6c00;
        }
        
        .log-entry.start {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        .stack-visualization {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
            min-height: 100px;
        }
        
        .stack-item {
            padding: 5px 10px;
            margin: 2px 0;
            background-color: #e3f2fd;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
        }
        
        .stack-item.current {
            background-color: #fff3e0;
            font-weight: bold;
        }
        
        .algorithm-explanation {
            margin-top: 20px;
            max-width: 800px;
            line-height: 1.6;
        }
        
        code {
            background-color: #f1f1f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>Depth-First Search (DFS) Visualization</h1>
    
    <div class="description">
        <p>Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. 
        The algorithm starts at the root node and explores as far as possible along each branch before backtracking.</p>
    </div>
    
    <div class="controls">
        <button id="start-btn">Start DFS</button>
        <button id="pause-btn" disabled>Pause</button>
        <button id="reset-btn">Reset</button>
        <button id="step-btn" disabled>Step Forward</button>
        <select id="speed-select">
            <option value="1000">Slow</option>
            <option value="500" selected>Medium</option>
            <option value="200">Fast</option>
        </select>
    </div>
    
    <div class="container">
        <div class="graph-container">
            <h2>Graph Visualization</h2>
            <div id="graph-canvas"></div>
        </div>
        
        <div class="visualization-container">
            <h2>DFS Process</h2>
            <div class="log" id="log"></div>
            
            <h3>Stack Visualization</h3>
            <div class="stack-visualization" id="stack"></div>
            
            <h3>Visited Nodes</h3>
            <table id="visited-table">
                <thead>
                    <tr>
                        <th>Node</th>
                        <th>Visited Order</th>
                    </tr>
                </thead>
                <tbody id="visited-body">
                </tbody>
            </table>
        </div>
    </div>
    
    <div class="algorithm-explanation">
        <h2>DFS Algorithm Explanation</h2>
        <p>The Depth-First Search algorithm follows these steps:</p>
        <ol>
            <li>Start by putting any one of the graph's vertices on top of a stack.</li>
            <li>Take the top item of the stack and add it to the visited list.</li>
            <li>Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.</li>
            <li>Keep repeating steps 2 and 3 until the stack is empty.</li>
        </ol>
        
        <p>DFS can be implemented recursively or iteratively. This visualization demonstrates the iterative approach using a stack.</p>
        
        <h3>Pseudocode</h3>
        <pre><code>
DFS(G, start):
  stack = new Stack()
  visited = new Set()
  
  stack.push(start)
  
  while stack is not empty:
    current = stack.pop()
    
    if current is not in visited:
      mark current as visited
      
      for each neighbor of current:
        if neighbor is not visited:
          stack.push(neighbor)
        </code></pre>
        
        <h3>Time Complexity</h3>
        <p>The time complexity of DFS is O(V + E) where V is the number of vertices and E is the number of edges in the graph.</p>
    </div>

    <script>
        // Graph representation
        const graph = {
            'A': ['B', 'C'],
            'B': ['A', 'D', 'E'],
            'C': ['A', 'F'],
            'D': ['B'],
            'E': ['B', 'F'],
            'F': ['C', 'E']
        };

        // Node positions for visualization
        const nodePositions = {
            'A': { x: 200, y: 100 },
            'B': { x: 100, y: 200 },
            'C': { x: 300, y: 200 },
            'D': { x: 50, y: 300 },
            'E': { x: 150, y: 300 },
            'F': { x: 250, y: 300 }
        };

        // DFS Algorithm State
        let visited = new Set();
        let stack = [];
        let currentNode = null;
        let isRunning = false;
        let animationSpeed = 500;
        let stepTimeout = null;
        let visitOrder = 0;
        let visitedOrderMap = {};

        // DOM Elements
        const graphCanvas = document.getElementById('graph-canvas');
        const logElement = document.getElementById('log');
        const stackElement = document.getElementById('stack');
        const visitedBody = document.getElementById('visited-body');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const stepBtn = document.getElementById('step-btn');
        const speedSelect = document.getElementById('speed-select');

        // Initialize the visualization
        function init() {
            renderGraph();
            updateVisitedTable();
            updateControls();
        }

        // Render the graph on the canvas
        function renderGraph() {
            graphCanvas.innerHTML = '';
            
            // Draw edges first (so they appear behind nodes)
            for (const node in graph) {
                if (nodePositions[node]) {
                    const fromX = nodePositions[node].x;
                    const fromY = nodePositions[node].y;
                    
                    for (const neighbor of graph[node]) {
                        if (nodePositions[neighbor] && node < neighbor) { // Draw each edge only once
                            const toX = nodePositions[neighbor].x;
                            const toY = nodePositions[neighbor].y;
                            
                            const edge = document.createElement('div');
                            edge.className = 'edge';
                            
                            // Calculate distance and angle
                            const dx = toX - fromX;
                            const dy = toY - fromY;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                            
                            // Position and style the edge
                            edge.style.width = `${length}px`;
                            edge.style.left = `${fromX}px`;
                            edge.style.top = `${fromY}px`;
                            edge.style.transform = `rotate(${angle}deg)`;
                            
                            graphCanvas.appendChild(edge);
                        }
                    }
                }
            }
            
            // Draw nodes
            for (const node in nodePositions) {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = `node-${node}`;
                nodeElement.textContent = node;
                nodeElement.style.left = `${nodePositions[node].x - 20}px`;
                nodeElement.style.top = `${nodePositions[node].y - 20}px`;
                
                // Set node color based on state
                if (node === currentNode) {
                    nodeElement.classList.add('current');
                } else if (visited.has(node)) {
                    nodeElement.classList.add('visited');
                }
                
                graphCanvas.appendChild(nodeElement);
            }
        }

        // Update the visited nodes table
        function updateVisitedTable() {
            visitedBody.innerHTML = '';
            
            // Sort nodes by visit order
            const sortedNodes = Object.keys(visitedOrderMap).sort((a, b) => 
                visitedOrderMap[a] - visitedOrderMap[b]
            );
            
            for (const node of sortedNodes) {
                const row = document.createElement('tr');
                
                const nodeCell = document.createElement('td');
                nodeCell.textContent = node;
                row.appendChild(nodeCell);
                
                const orderCell = document.createElement('td');
                orderCell.textContent = visitedOrderMap[node];
                row.appendChild(orderCell);
                
                visitedBody.appendChild(row);
            }
        }

        // Update the stack visualization
        function updateStackVisualization() {
            stackElement.innerHTML = '';
            
            // Display the stack from top to bottom
            for (let i = stack.length - 1; i >= 0; i--) {
                const stackItem = document.createElement('div');
                stackItem.className = 'stack-item';
                stackItem.textContent = stack[i];
                
                if (i === stack.length - 1) {
                    stackItem.classList.add('current');
                }
                
                stackElement.appendChild(stackItem);
            }
        }

        // Add a log entry
        function addLogEntry(message, type = '') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = message;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        // DFS Algorithm Step
        function dfsStep() {
            if (stack.length === 0) {
                // DFS complete
                addLogEntry('DFS traversal complete!', 'start');
                stopDFS();
                return;
            }
            
            // Pop the top node from the stack
            currentNode = stack.pop();
            addLogEntry(`Popped ${currentNode} from stack`, 'current');
            
            // If we haven't visited this node yet
            if (!visited.has(currentNode)) {
                // Mark as visited
                visited.add(currentNode);
                visitedOrderMap[currentNode] = ++visitOrder;
                addLogEntry(`Visited node ${currentNode} (order: ${visitOrder})`, 'visited');
                
                // Add unvisited neighbors to the stack
                const neighbors = graph[currentNode] || [];
                const unvisitedNeighbors = neighbors.filter(neighbor => !visited.has(neighbor));
                
                if (unvisitedNeighbors.length > 0) {
                    addLogEntry(`Adding unvisited neighbors of ${currentNode} to stack: ${unvisitedNeighbors.join(', ')}`);
                    stack.push(...unvisitedNeighbors.reverse()); // Reverse to maintain DFS order
                } else {
                    addLogEntry(`No unvisited neighbors for ${currentNode}`);
                }
            } else {
                addLogEntry(`Node ${currentNode} already visited, skipping`);
            }
            
            // Update visualizations
            renderGraph();
            updateVisitedTable();
            updateStackVisualization();
            
            // Continue if running
            if (isRunning) {
                stepTimeout = setTimeout(dfsStep, animationSpeed);
            }
        }

        // Start DFS
        function startDFS() {
            if (!isRunning) {
                isRunning = true;
                
                // Initialize DFS if not already started
                if (stack.length === 0 && visited.size === 0) {
                    stack.push('A'); // Start from node A
                    addLogEntry('Starting DFS from node A', 'start');
                }
                
                updateControls();
                dfsStep();
            }
        }

        // Pause DFS
        function pauseDFS() {
            isRunning = false;
            if (stepTimeout) {
                clearTimeout(stepTimeout);
                stepTimeout = null;
            }
            updateControls();
        }

        // Stop DFS
        function stopDFS() {
            isRunning = false;
            if (stepTimeout) {
                clearTimeout(stepTimeout);
                stepTimeout = null;
            }
            updateControls();
        }

        // Reset DFS
        function resetDFS() {
            stopDFS();
            visited = new Set();
            stack = [];
            currentNode = null;
            visitOrder = 0;
            visitedOrderMap = {};
            logElement.innerHTML = '';
            updateVisitedTable();
            updateStackVisualization();
            renderGraph();
            updateControls();
        }

        // Step forward one step
        function stepForward() {
            if (!isRunning) {
                // Initialize DFS if not already started
                if (stack.length === 0 && visited.size === 0) {
                    stack.push('A'); // Start from node A
                    addLogEntry('Starting DFS from node A', 'start');
                    updateVisitedTable();
                    updateStackVisualization();
                    renderGraph();
                } else {
                    dfsStep();
                }
            }
        }

        // Update control buttons state
        function updateControls() {
            startBtn.disabled = isRunning;
            pauseBtn.disabled = !isRunning;
            stepBtn.disabled = isRunning;
        }

        // Event Listeners
        startBtn.addEventListener('click', startDFS);
        pauseBtn.addEventListener('click', pauseDFS);
        resetBtn.addEventListener('click', resetDFS);
        stepBtn.addEventListener('click', stepForward);
        
        speedSelect.addEventListener('change', function() {
            animationSpeed = parseInt(this.value);
            if (isRunning) {
                pauseDFS();
                startDFS();
            }
        });

        // Initialize the visualization
        init();
    </script>
</body>
</html>