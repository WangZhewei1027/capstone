<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Floyd–Warshall Algorithm Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 12px; background: #f7f9fc; color:#111;}
  h1 { margin: 0 0 8px 0; font-size: 20px; }
  p.lead { margin: 6px 0 16px 0; color:#333; max-width: 900px; }
  .controls { display:flex; gap:12px; flex-wrap:wrap; margin-bottom:12px; align-items:center;}
  .panel { background: white; border: 1px solid #e0e6ef; padding: 10px; border-radius: 8px; box-shadow: 0 1px 2px rgba(20,30,50,0.04); }
  label { font-size: 13px; color:#333; margin-right:6px;}
  input[type="number"] { width:68px; padding:6px; border-radius:6px; border:1px solid #cfd8e6; }
  button { padding:8px 10px; border-radius:6px; border:1px solid #cfd8e6; background: #fff; cursor:pointer; }
  button.primary { background: linear-gradient(#1e90ff,#0c7bd9); color:white; border-color: #0c7bd9; }
  button.warn { background: linear-gradient(#ffb37d,#ff8a3d); border-color:#ff8a3d; color:#2b1b10; }
  select { padding:6px; border-radius:6px; border:1px solid #cfd8e6; }
  .layout { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
  .left { width:520px; min-width:320px;}
  .right { flex:1; min-width:300px;}
  table.matrix { border-collapse: collapse; margin-top:8px; }
  table.matrix td, table.matrix th { border:1px solid #e6edf6; padding:6px 8px; text-align:center; min-width:52px; font-family:monospace; }
  table.matrix th { background:#fbfdff; font-weight:600; }
  td.editable { cursor:text; background:#fff; }
  td.current { background:#fffbe6; }
  td.knode { background:#e8f3ff; }
  td.updated { background:#e6ffee; transition: background 0.8s ease; }
  canvas { background: linear-gradient(180deg,#ffffff,#fbfdff); border:1px solid #e6edf6; border-radius:8px; display:block; }
  .status { margin-top:10px; font-size:14px; }
  .legend { margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:13px;}
  .legend .item { display:inline-flex; gap:8px; align-items:center; }
  .swatch { width:14px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,0.06);}
  .small { font-size:13px; color:#444; }
  .note { font-size:13px; color:#666; margin-top:8px; }
  .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .matrix-scroll { max-height:360px; overflow:auto; padding-right:6px; }
  .footer { margin-top:12px; font-size:13px; color:#666; }
  a { color:#0c7bd9; text-decoration: none; }
</style>
</head>
<body>
  <h1>Floyd–Warshall Algorithm — Interactive Demonstration</h1>
  <p class="lead">This demo runs the Floyd–Warshall all-pairs shortest paths algorithm step-by-step. You can edit the adjacency (weight) matrix, generate random graphs, step through or autoplay the algorithm, and reconstruct shortest paths. Use negative weights to see how the algorithm handles them; if a negative cycle exists you'll be notified.</p>

  <div class="controls">
    <div class="panel">
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <label>Nodes:</label>
        <input id="nodeCount" type="number" min="2" max="12" value="6"/>
        <button id="resizeBtn">Resize</button>
        <button id="randBtn" class="primary">Random Graph</button>
        <button id="clearBtn">Clear (∞)</button>
      </div>

      <div style="display:flex; gap:8px; align-items:center;">
        <button id="initBtn">Initialize Matrices</button>
        <button id="runAllBtn" class="primary">Run to End</button>
        <button id="stepBtn">Step</button>
        <button id="playBtn">Play</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <label>Speed:</label>
        <input id="speed" type="range" min="100" max="2000" value="600"/>
        <span id="speedVal" class="small">600ms</span>
      </div>
    </div>

    <div class="panel" style="min-width:300px;">
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
        <label>From:</label>
        <select id="fromSelect"></select>
        <label>To:</label>
        <select id="toSelect"></select>
        <button id="showPathBtn">Show Path</button>
        <button id="clearPathBtn">Clear Highlight</button>
      </div>

      <div class="status panel" id="info" style="border:none; padding:0;">
        <div id="iteration">Iteration: k = - (not started)</div>
        <div id="pair">Pair (i, j): -</div>
        <div id="distanceInfo">Selected distance: -</div>
        <div id="negCycle" style="color:#b34141; font-weight:600; margin-top:6px;"></div>
      </div>
    </div>
  </div>

  <div class="layout">
    <div class="left panel">
      <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
        <div style="font-weight:600;">Adjacency / Weight Matrix (use Infinity as empty)</div>
        <div class="small">Double-click a cell to edit. Use "Initialize Matrices" to load to algorithm.</div>
      </div>
      <div class="matrix-scroll" id="matrixWrap" style="margin-top:8px;">
        <!-- Matrix table inserted here -->
      </div>
      <div class="legend">
        <div class="item small"><span class="swatch" style="background:#e8f3ff;border-color:#bfe0ff"></span> current k node</div>
        <div class="item small"><span class="swatch" style="background:#fffbe6;border-color:#ffe89d"></span> current pair (i,j)</div>
        <div class="item small"><span class="swatch" style="background:#e6ffee;border-color:#b5f0cf"></span> recently updated</div>
      </div>
      <div class="note">Notes: Use large positive number or "Infinity" for no direct edge. The graph is directed. Diagonal values default to 0.</div>
    </div>

    <div class="right panel">
      <canvas id="graphCanvas" width="720" height="480"></canvas>
      <div class="footer">
        Click "Show Path" after selecting From/To to reconstruct the current best path using the algorithm's current next matrix. If any dist[v][v] &lt; 0 a negative cycle exists and shortest paths may be undefined.
      </div>
    </div>
  </div>

<script>
(function(){
  // Utility
  const INF = Infinity;
  const ui = {
    nodeCount: document.getElementById('nodeCount'),
    resizeBtn: document.getElementById('resizeBtn'),
    randBtn: document.getElementById('randBtn'),
    clearBtn: document.getElementById('clearBtn'),
    initBtn: document.getElementById('initBtn'),
    runAllBtn: document.getElementById('runAllBtn'),
    stepBtn: document.getElementById('stepBtn'),
    playBtn: document.getElementById('playBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    resetBtn: document.getElementById('resetBtn'),
    matrixWrap: document.getElementById('matrixWrap'),
    fromSelect: document.getElementById('fromSelect'),
    toSelect: document.getElementById('toSelect'),
    showPathBtn: document.getElementById('showPathBtn'),
    clearPathBtn: document.getElementById('clearPathBtn'),
    iteration: document.getElementById('iteration'),
    pair: document.getElementById('pair'),
    distanceInfo: document.getElementById('distanceInfo'),
    negCycle: document.getElementById('negCycle'),
    canvas: document.getElementById('graphCanvas'),
    speed: document.getElementById('speed'),
    speedVal: document.getElementById('speedVal')
  };

  let n = parseInt(ui.nodeCount.value,10) || 5;
  let adj = []; // editable adjacency matrix (user view)
  let dist = []; // current distances
  let nextM = []; // next matrix for path reconstruction
  let initialDist = [];
  // Floyd-Warshall iterative state
  let kIdx = -1, iIdx = 0, jIdx = 0;
  let playing = false;
  let autoplayTimer = null;
  let lastUpdated = null; // {i,j, timestamp}
  let highlightedPathEdges = [];
  let nodesPos = []; // positions for canvas

  // Initialize matrices
  function make2D(arr,n,size,fill){
    arr.length = 0;
    for(let i=0;i<n;i++){
      let row = [];
      for(let j=0;j<n;j++){
        row.push(fill(i,j));
      }
      arr.push(row);
    }
  }

  function createEmptyAdj(n){
    // default: no edges (Infinity), diagonal 0
    let m = [];
    for(let i=0;i<n;i++){
      let row = [];
      for(let j=0;j<n;j++){
        row.push(i===j ? 0 : INF);
      }
      m.push(row);
    }
    return m;
  }

  function randomGraph(n, density=0.45, maxW=12, allowNeg=false){
    let m = createEmptyAdj(n);
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        if(i===j) continue;
        if(Math.random() < density){
          let sign = allowNeg && Math.random()<0.12 ? -1 : 1;
          let w = Math.floor(Math.random()*(maxW-1))+1;
          m[i][j] = sign * w;
        } else {
          m[i][j] = INF;
        }
      }
    }
    return m;
  }

  function renderMatrix(){
    // create a table with header
    ui.matrixWrap.innerHTML = '';
    const tbl = document.createElement('table');
    tbl.className = 'matrix';
    const thead = document.createElement('thead');
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th')); // corner
    for(let j=0;j<n;j++){
      const th = document.createElement('th');
      th.textContent = j;
      headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    tbl.appendChild(thead);

    const tbody = document.createElement('tbody');
    for(let i=0;i<n;i++){
      const tr = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = i;
      tr.appendChild(th);
      for(let j=0;j<n;j++){
        const td = document.createElement('td');
        td.dataset.i = i;
        td.dataset.j = j;
        td.className = 'editable';
        td.contentEditable = 'true';
        td.spellcheck = false;
        td.style.minWidth = '74px';
        td.style.maxWidth = '220px';
        td.style.overflow = 'auto';
        td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';
        // events
        td.addEventListener('blur', onCellEdit);
        td.addEventListener('keydown', function(e){
          if(e.key === 'Enter'){ e.preventDefault(); td.blur(); }
        });
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    tbl.appendChild(tbody);
    ui.matrixWrap.appendChild(tbl);
    updateSelects();
    scheduleCanvasDraw();
  }

  function onCellEdit(e){
    const td = e.target;
    const i = parseInt(td.dataset.i,10);
    const j = parseInt(td.dataset.j,10);
    const val = td.textContent.trim();
    let parsed = parseNumberOrInfinity(val);
    if(parsed === null){ // invalid -> revert
      td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';
      return;
    }
    adj[i][j] = parsed;
    // keep diagonal zero if edited to something else? allow editing diagonal to create negative cycles if user wants.
    td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';
    setNotInitializedState();
    scheduleCanvasDraw();
  }

  function parseNumberOrInfinity(text){
    if(text === '' || text.toLowerCase() === 'inf' || text === '∞' || text.toLowerCase() === 'infinity') return INF;
    // parse number with possible sign
    const v = Number(text);
    if(!Number.isFinite(v)) return null;
    return v;
  }

  function setNotInitializedState(){
    ui.iteration.textContent = 'Iteration: k = - (not started)';
    ui.pair.textContent = 'Pair (i, j): -';
    ui.distanceInfo.textContent = 'Selected distance: -';
    ui.negCycle.textContent = '';
    kIdx = -1;
    iIdx = 0;
    jIdx = 0;
    playing = false;
    stopAutoplay();
  }

  // Initialize algorithm's working matrices from adj
  function initializeAlgorithm(){
    dist = [];
    nextM = [];
    for(let i=0;i<n;i++){
      dist[i] = [];
      nextM[i] = [];
      for(let j=0;j<n;j++){
        dist[i][j] = adj[i][j];
        nextM[i][j] = isFinite(adj[i][j]) ? j : null;
      }
      // ensure diagonal next points to itself
      nextM[i][i] = i;
      if(!isFinite(dist[i][i])) dist[i][i] = 0;
    }
    initialDist = dist.map(r => r.slice());
    kIdx = 0;
    iIdx = 0;
    jIdx = 0;
    ui.iteration.textContent = 'Iteration: k = 0';
    ui.pair.textContent = `Pair (i, j): (0, 0)`;
    ui.distanceInfo.textContent = 'Selected distance: -';
    ui.negCycle.textContent = '';
    lastUpdated = null;
    highlightedPathEdges = [];
    renderStateMatrix(); // show dist matrix with highlights
    scheduleCanvasDraw();
  }

  function renderStateMatrix(){
    // color cells depending on current k and current pair and any recent updates
    const tds = ui.matrixWrap.querySelectorAll('td.editable');
    tds.forEach(td=>{
      const i = parseInt(td.dataset.i,10);
      const j = parseInt(td.dataset.j,10);
      td.classList.remove('knode','current','updated');
      // display current dist (not original adjacency)
      td.textContent = isFinite(dist[i][j]) ? String(dist[i][j]) : '∞';
      if(kIdx >= 0 && i === kIdx) td.classList.add('knode');
      if(i === iIdx && j === jIdx) td.classList.add('current');
      if(lastUpdated && lastUpdated.i === i && lastUpdated.j === j){
        td.classList.add('updated');
        // clear updated after some time
        setTimeout(()=>{ td.classList.remove('updated'); }, 800);
      }
    });
    updateSelects();
    updateInfoDisplays();
  }

  function updateSelects(){
    // fill from/to selects with node indices
    const currentLen = ui.fromSelect.children.length;
    if(currentLen !== n){
      ui.fromSelect.innerHTML = '';
      ui.toSelect.innerHTML = '';
      for(let i=0;i<n;i++){
        const o1 = document.createElement('option'); o1.value = i; o1.textContent = i;
        const o2 = document.createElement('option'); o2.value = i; o2.textContent = i;
        ui.fromSelect.appendChild(o1);
        ui.toSelect.appendChild(o2);
      }
    }
  }

  function floydStep(){
    if(kIdx < 0 || kIdx >= n) return false;
    // process current (iIdx, jIdx)
    const i = iIdx, j = jIdx, k = kIdx;
    const kij = (isFinite(dist[i][k]) && isFinite(dist[k][j])) ? dist[i][k] + dist[k][j] : INF;
    if(kij < dist[i][j]){
      dist[i][j] = kij;
      // update next matrix to reconstruct path: next[i][j] = next[i][k]
      nextM[i][j] = nextM[i][k];
      lastUpdated = {i:i,j:j,ts:Date.now()};
      // mark changed
    }
    // advance indices
    jIdx++;
    if(jIdx >= n){ jIdx = 0; iIdx++; }
    if(iIdx >= n){ iIdx = 0; kIdx++; ui.iteration.textContent = `Iteration: k = ${kIdx}`; }
    // update displays
    ui.pair.textContent = `Pair (i, j): (${iIdx}, ${jIdx})`;
    renderStateMatrix();
    checkNegativeCycle();
    // return whether finished
    return !(kIdx < n);
  }

  function runToEnd(){
    // run Floyd–Warshall to completion synchronously (fast)
    for(let k = kIdx < 0 ? 0 : kIdx; k < n; k++){
      for(let i = (k === kIdx ? iIdx : 0); i < n; i++){
        for(let j = (k === kIdx && i === iIdx ? jIdx : 0); j < n; j++){
          const alt = (isFinite(dist[i][k]) && isFinite(dist[k][j])) ? dist[i][k] + dist[k][j] : INF;
          if(alt < dist[i][j]){
            dist[i][j] = alt;
            nextM[i][j] = nextM[i][k];
          }
        }
      }
    }
    kIdx = n;
    iIdx = 0; jIdx = 0;
    ui.iteration.textContent = 'Iteration: finished';
    ui.pair.textContent = 'Pair (i, j): -';
    renderStateMatrix();
    checkNegativeCycle();
    scheduleCanvasDraw();
  }

  function checkNegativeCycle(){
    let found = false;
    for(let v=0; v<n; v++){
      if(isFinite(dist[v][v]) && dist[v][v] < 0){
        found = true;
      }
    }
    if(found){
      ui.negCycle.textContent = 'Negative cycle detected (some dist[v][v] < 0). Shortest paths may be undefined.';
    } else {
      ui.negCycle.textContent = '';
    }
  }

  function scheduleCanvasDraw(){
    drawGraph();
  }

  // Canvas graph visualization
  const canvas = ui.canvas;
  const ctx = canvas.getContext('2d');

  function computeNodePositions(){
    nodesPos = [];
    const w = canvas.width, h = canvas.height;
    const r = Math.min(w,h)/2 - 80;
    const cx = w/2, cy = h/2;
    for(let i=0;i<n;i++){
      const ang = -Math.PI/2 + (2*Math.PI*i)/n;
      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);
      nodesPos.push({x,y});
    }
  }

  function drawGraph(){
    computeNodePositions();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw edges
    ctx.font = '13px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // draw all directed edges that are finite in adj (original) as faint lines
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        if(i===j) continue;
        const wgt = adj[i][j];
        if(!isFinite(wgt)) continue;
        drawEdge(nodesPos[i], nodesPos[j], String(wgt), '#d6e6ff', 1, false);
      }
    }
    // draw shortest-path edges highlighted if path selected
    for(const e of highlightedPathEdges){
      drawEdge(nodesPos[e.u], nodesPos[e.v], '', '#2c7be5', 3, true);
    }
    // draw nodes
    for(let i=0;i<n;i++){
      const p = nodesPos[i];
      const rad = 20;
      // if current k, draw special color
      if(kIdx >= 0 && i === kIdx){
        ctx.fillStyle = '#e8f3ff';
        ctx.strokeStyle = '#bfe0ff';
      } else {
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#dbe8ff';
      }
      ctx.lineWidth = 2;
      roundRect(ctx, p.x-rad, p.y-rad, rad*2, rad*2, 8, true, true);
      ctx.fillStyle = '#0c1f3a';
      ctx.font = '13px system-ui, Arial';
      ctx.fillText(String(i), p.x, p.y);
    }
  }

  function drawEdge(a,b,label,color,lineWidth,arrow){
    // draw curved arrow to avoid overlap for pair (i,j) and (j,i)
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    // simple straight with small offset
    const dx = b.x - a.x, dy = b.y - a.y;
    const distAB = Math.hypot(dx,dy);
    const ux = dx / distAB, uy = dy / distAB;
    const startX = a.x + ux*22;
    const startY = a.y + uy*22;
    const endX = b.x - ux*22;
    const endY = b.y - uy*22;
    const mx = (startX+endX)/2, my = (startY+endY)/2;
    // curve control
    const nx = -uy, ny = ux;
    const curveOffset = 14;
    const cx = mx + nx*curveOffset;
    const cy = my + ny*curveOffset;
    ctx.moveTo(startX,startY);
    ctx.quadraticCurveTo(cx,cy,endX,endY);
    ctx.stroke();
    // draw arrowhead
    if(arrow){
      // find point near end for arrow
      const t = 0.94;
      // quadratic bezier point and derivative
      const qx = (1-t)*(1-t)*startX + 2*(1-t)*t*cx + t*t*endX;
      const qy = (1-t)*(1-t)*startY + 2*(1-t)*t*cy + t*t*endY;
      const dxq = 2*(1-t)*(cx - startX) + 2*t*(endX - cx);
      const dyq = 2*(1-t)*(cy - startY) + 2*t*(endY - cy);
      const ang = Math.atan2(dyq,dxq);
      const ah = 8;
      ctx.beginPath();
      ctx.moveTo(qx, qy);
      ctx.lineTo(qx - ah*Math.cos(ang-0.4), qy - ah*Math.sin(ang-0.4));
      ctx.lineTo(qx - ah*Math.cos(ang+0.4), qy - ah*Math.sin(ang+0.4));
      ctx.closePath();
      ctx.fill();
    }
    // draw label near midpoint
    if(label){
      ctx.fillStyle = '#0c1f3a';
      ctx.font = '12px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // compute point at t=0.5 on quadratic
      const t = 0.5;
      const qx = (1-t)*(1-t)*startX + 2*(1-t)*t*cx + t*t*endX;
      const qy = (1-t)*(1-t)*startY + 2*(1-t)*t*cy + t*t*endY;
      // small background
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(qx-18, qy-10, 36, 20);
      ctx.fillStyle = '#0c1f3a';
      ctx.fillText(label, qx, qy);
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Path reconstruction using nextM (current)
  function reconstructPath(u,v){
    if(nextM[u][v] === null) return null;
    const path = [u];
    let cur = u;
    const maxSteps = n+5;
    for(let i=0;i<maxSteps && cur !== v; i++){
      cur = nextM[cur][v];
      if(cur === null || cur === undefined){ return null; }
      path.push(cur);
      if(path.length > n+2) return null;
    }
    if(path[path.length-1] !== v) return null;
    return path;
  }

  function highlightPath(u,v){
    highlightedPathEdges = [];
    const path = reconstructPath(u,v);
    if(!path){
      alert('No path found (using current algorithm state).');
      return;
    }
    for(let i=0;i<path.length-1;i++){
      highlightedPathEdges.push({u: path[i], v: path[i+1]});
    }
    scheduleCanvasDraw();
    // show distance
    const d = dist[u][v];
    ui.distanceInfo.textContent = 'Selected distance: ' + (isFinite(d) ? String(d) : '∞');
  }

  // Event wiring
  ui.resizeBtn.addEventListener('click', ()=>{
    const newN = Math.max(2, Math.min(12, parseInt(ui.nodeCount.value,10) || 2));
    n = newN;
    adj = createEmptyAdj(n);
    renderMatrix();
    setNotInitializedState();
  });

  ui.randBtn.addEventListener('click', ()=>{
    const allowNeg = confirm('Allow some negative edges? (May create negative cycles)');
    adj = randomGraph(n, 0.45, 12, allowNeg);
    renderMatrix();
    setNotInitializedState();
  });

  ui.clearBtn.addEventListener('click', ()=>{
    adj = createEmptyAdj(n);
    renderMatrix();
    setNotInitializedState();
  });

  ui.initBtn.addEventListener('click', ()=>{
    initializeAlgorithm();
  });

  ui.stepBtn.addEventListener('click', ()=>{
    if(kIdx < 0){ alert('Initialize matrices first (click "Initialize Matrices").'); return; }
    if(kIdx >= n){ alert('Algorithm already finished. Reset or re-initialize.'); return; }
    const finished = floydStep();
    if(finished){
      ui.iteration.textContent = 'Iteration: finished';
      ui.pair.textContent = 'Pair (i, j): -';
      renderStateMatrix();
    }
  });

  ui.runAllBtn.addEventListener('click', ()=>{
    if(kIdx < 0){ alert('Initialize matrices first (click "Initialize Matrices").'); return; }
    runToEnd();
  });

  ui.playBtn.addEventListener('click', ()=>{
    if(kIdx < 0){ alert('Initialize matrices first (click "Initialize Matrices").'); return; }
    if(kIdx >= n){ alert('Algorithm already finished.'); return; }
    playing = true;
    ui.playBtn.disabled = true;
    ui.pauseBtn.disabled = false;
    scheduleAutoplay();
  });

  ui.pauseBtn.addEventListener('click', ()=>{
    playing = false;
    ui.playBtn.disabled = false;
    ui.pauseBtn.disabled = true;
    stopAutoplay();
  });

  ui.resetBtn.addEventListener('click', ()=>{
    if(!initialDist || !initialDist.length) { initializeAlgorithm(); return; }
    // revert dist and next to initial
    dist = initialDist.map(r=>r.slice());
    nextM = [];
    for(let i=0;i<n;i++){
      nextM[i] = [];
      for(let j=0;j<n;j++){
        nextM[i][j] = isFinite(adj[i][j]) ? j : null;
      }
      nextM[i][i] = i;
    }
    kIdx = 0; iIdx=0; jIdx=0;
    lastUpdated = null;
    ui.iteration.textContent = 'Iteration: k = 0';
    ui.pair.textContent = 'Pair (i, j): (0,0)';
    renderStateMatrix();
    scheduleCanvasDraw();
  });

  ui.showPathBtn.addEventListener('click', ()=>{
    const u = parseInt(ui.fromSelect.value,10);
    const v = parseInt(ui.toSelect.value,10);
    highlightPath(u,v);
  });

  ui.clearPathBtn.addEventListener('click', ()=>{
    highlightedPathEdges = [];
    scheduleCanvasDraw();
    ui.distanceInfo.textContent = 'Selected distance: -';
  });

  ui.speed.addEventListener('input', ()=>{
    ui.speedVal.textContent = ui.speed.value + 'ms';
    if(playing){
      stopAutoplay();
      scheduleAutoplay();
    }
  });

  function scheduleAutoplay(){
    if(!playing) return;
    const delay = parseInt(ui.speed.value,10) || 600;
    autoplayTimer = setTimeout(()=>{
      const finished = floydStep();
      if(finished){
        playing = false;
        ui.playBtn.disabled = false;
        ui.pauseBtn.disabled = true;
        stopAutoplay();
        ui.iteration.textContent = 'Iteration: finished';
      } else {
        scheduleAutoplay();
      }
    }, delay);
  }

  function stopAutoplay(){
    if(autoplayTimer){ clearTimeout(autoplayTimer); autoplayTimer = null; }
  }

  function start(){
    // initial adjacency
    adj = randomGraph(n, 0.45, 12, false);
    renderMatrix();
    setNotInitializedState();
    computeNodePositions();
    drawGraph();
    window.addEventListener('resize', ()=>{ /* no-op for now */ });
  }

  // helper: draw once on load
  start();

  // expose small keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ // space toggles play/pause
      e.preventDefault();
      if(playing) ui.pauseBtn.click(); else ui.playBtn.click();
    }
  });

  // show current matrix values update animation
  // keep canvas responsive: redraw on interval if changes
  setInterval(()=>{
    // occasionally re-render updated class remove (safety)
    if(lastUpdated && Date.now() - lastUpdated.ts > 900) lastUpdated = null;
  }, 500);

})();
</script>
</body>
</html>