<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Hash Table Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#4fd1c5;
      --muted:#94a3b8;
      --good:#16a34a;
      --bad:#ef4444;
      --slot:#071226;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071024 0%, #071833 60%);color:#e6eef8;padding:18px;box-sizing:border-box}
    .wrap{max-width:1100px;margin:0 auto;}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:18px}
    h1{font-size:20px;margin:0;color:var(--accent)}
    .desc{color:var(--muted);font-size:13px}
    .controls{display:flex;flex-wrap:wrap;gap:10px;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px}
    label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    input[type="text"],select{background:#021524;border:1px solid rgba(255,255,255,0.04);color:#dbeafe;padding:8px;border-radius:6px;min-width:200px}
    input[type="range"]{width:180px}
    button{background:linear-gradient(180deg,#0ea5a4,#0a7f7e);border:none;padding:8px 12px;color:#022;border-radius:8px;cursor:pointer;font-weight:600}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    main{display:flex;gap:16px;margin-top:14px}
    .left{flex:0 0 420px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:10px}
    .right{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:10px;min-height:320px}
    .table-visual{display:flex;flex-wrap:wrap;gap:8px;padding:8px}
    .bucket{background:var(--slot);border-radius:8px;padding:8px;min-width:80px;min-height:56px;color:#bfeedd;border:1px solid rgba(255,255,255,0.03);position:relative}
    .bucket h3{margin:0;font-size:12px;color:var(--muted);font-weight:700}
    .chain{margin-top:8px;display:flex;flex-direction:column;gap:6px}
    .node{background:linear-gradient(180deg,#0b2b3a,#07202a);padding:6px;border-radius:6px;color:#dff3f0;font-weight:700;border:1px solid rgba(255,255,255,0.02);display:flex;align-items:center;gap:6px;justify-content:space-between}
    .index-badge{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.02);padding:4px 6px;border-radius:6px;font-size:12px;color:var(--muted)}
    .array-slot{width:110px;height:64px;background:var(--slot);border-radius:8px;display:flex;flex-direction:column;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,0.03);position:relative}
    .slot-key{font-weight:800;color:#dbeafe}
    .slot-val{font-size:12px;color:var(--muted)}
    .slot.empty{opacity:0.45}
    .slot.deleted{opacity:0.5;color:var(--muted);border-style:dashed}
    .status{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px;min-height:42px}
    .controls-row{display:flex;gap:8px;flex-wrap:wrap}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend .item{display:flex;align-items:center;gap:8px}
    .swatch{width:14px;height:14px;border-radius:4px}
    .sw-ok{background:var(--good)}
    .sw-empty{background:transparent;border:1px solid rgba(255,255,255,0.04)}
    .sw-del{background:transparent;border:2px dashed rgba(255,255,255,0.06)}
    .explain{font-size:13px;color:var(--muted);line-height:1.4;margin-top:12px}
    .hashbar{display:flex;gap:8px;align-items:center;margin-top:8px}
    .pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;font-weight:700;color:var(--muted);font-size:13px}
    .highlight{outline:3px solid rgba(79,209,197,0.14);box-shadow:0 6px 18px rgba(11,30,40,0.6)}
    .small{font-size:12px}
    code{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;color:#c1e8e3;font-family:monospace;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Interactive Hash Table Demo</h1>
        <div class="desc">Explore hashing with separate chaining and open addressing (linear/quadratic). Insert, search, delete and watch collisions/probes.</div>
      </div>
      <div style="text-align:right">
        <div class="small" style="color:var(--muted)">Simple polynomial hash for strings, modulo table size.</div>
      </div>
    </header>

    <div class="controls">
      <label>
        Table size: <span id="sizeLabel">11</span>
        <input id="sizeRange" type="range" min="5" max="41" step="1" value="11">
      </label>

      <label>
        Collision strategy:
        <select id="strategy">
          <option value="chaining">Separate Chaining</option>
          <option value="linear">Open Addressing — Linear Probing</option>
          <option value="quadratic">Open Addressing — Quadratic Probing</option>
        </select>
      </label>

      <label>
        Key (string or number)
        <input id="keyInput" type="text" placeholder="e.g. apple or 42">
      </label>

      <label>
        Value (optional)
        <input id="valueInput" type="text" placeholder="any data">
      </label>

      <div style="display:flex;align-items:center;gap:8px">
        <button id="insertBtn">Insert</button>
        <button id="searchBtn" class="secondary">Search</button>
        <button id="deleteBtn" class="secondary">Delete</button>
      </div>

      <div style="display:flex;align-items:center;gap:8px;margin-left:auto">
        <button id="fillBtn" class="secondary">Fill Randomly</button>
        <button id="clearBtn" class="secondary">Reset</button>
      </div>
    </div>

    <main>
      <div class="left">
        <div class="hashbar">
          <div class="pill">Hash function: h(k) = (Σ charCode * p^i) mod M</div>
          <div class="pill" id="hashOutput">Index: —</div>
        </div>

        <div class="explain">
          This demo uses a simple polynomial rolling hash for strings (p=31). Numbers are used directly (mod table size). Collisions are handled using the selected strategy. Open addressing supports linear and quadratic probing.
          <div style="margin-top:8px">
            Example: Insert "cat" — compute numeric hash → index = hash % M. If occupied, probes continue.
          </div>
        </div>

        <div style="margin-top:12px">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="stepToggle" class="secondary">Step Mode: Off</button>
            <label style="font-size:13px;color:var(--muted);margin-left:6px">If on, each probe shows a highlight you advance manually.</label>
          </div>
          <div class="legend">
            <div class="item"><div class="swatch sw-ok"></div><div class="small">Occupied</div></div>
            <div class="item"><div class="swatch sw-empty" style="border:1px solid rgba(255,255,255,0.04)"></div><div class="small">Empty</div></div>
            <div class="item"><div class="swatch sw-del" style="border-color:rgba(255,255,255,0.06)"></div><div class="small">Deleted (tombstone)</div></div>
          </div>
        </div>

        <div class="status" id="status">Ready.</div>
      </div>

      <div class="right">
        <div id="visualArea" class="table-visual" aria-live="polite"></div>
        <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <button id="prevStep" class="secondary">◀ Prev Probe</button>
          <button id="nextStep" class="secondary">Next Probe ▶</button>
          <div style="margin-left:auto;color:var(--muted);font-size:13px">
            Probes: <span id="probeCount">0</span>
          </div>
        </div>

        <footer>
          Quick hints: Try inserting keys that collide (e.g., "a", "k", "u" in a small table) to observe chaining vs probing. Deleted slots in open addressing are marked as tombstones.
        </footer>
      </div>
    </main>
  </div>

  <script>
    // Hash Table demo script
    (function(){
      // Utilities
      function isNumberString(s){
        return /^-?\d+(\.\d+)?$/.test(s);
      }

      function makeKey(k){
        // store keys as strings internally to keep consistent behavior
        return String(k);
      }

      // Simple polynomial rolling hash for strings
      function stringHash(s, M){
        let hash = 0;
        const p = 31;
        let pow = 1;
        for (let i = 0; i < s.length; i++){
          const code = s.charCodeAt(i);
          hash = (hash + (code + 1) * pow) % M;
          pow = (pow * p) % M;
        }
        return hash;
      }

      function computeHash(key, M){
        if (isNumberString(key)) {
          // numeric-like: use numeric value
          let n = Number(key);
          // handle negative numbers
          n = Math.floor(Math.abs(n));
          return n % M;
        } else {
          return stringHash(String(key), M);
        }
      }

      // Data structures
      class HashTableChaining {
        constructor(M){
          this.M = M;
          this.buckets = Array.from({length:M}, ()=>[]);
        }
        insert(key, value){
          const k = makeKey(key);
          const idx = computeHash(k, this.M);
          const bucket = this.buckets[idx];
          // if key exists, update
          for (let node of bucket){
            if (node.key === k){
              node.value = value;
              return {index:idx, updated:true};
            }
          }
          bucket.push({key:k, value:value});
          return {index:idx, updated:false};
        }
        search(key){
          const k = makeKey(key);
          const idx = computeHash(k, this.M);
          const bucket = this.buckets[idx];
          for (let i=0;i<bucket.length;i++){
            if (bucket[i].key === k) return {found:true,index:idx,chainIndex:i,node:bucket[i]};
          }
          return {found:false,index:idx};
        }
        delete(key){
          const k = makeKey(key);
          const idx = computeHash(k, this.M);
          const bucket = this.buckets[idx];
          for (let i=0;i<bucket.length;i++){
            if (bucket[i].key === k){
              const removed = bucket.splice(i,1)[0];
              return {removed:true,index:idx,removedNode:removed};
            }
          }
          return {removed:false,index:idx};
        }
        clear(){
          this.buckets = Array.from({length:this.M}, ()=>[]);
        }
      }

      class HashTableOpen {
        constructor(M, probeStrategy='linear'){
          this.M = M;
          this.probeStrategy = probeStrategy; // 'linear' or 'quadratic'
          this.slots = Array.from({length:M}, ()=>({state:'empty', key:null, value:null}));
        }
        _probeSequence(hash){
          const M = this.M;
          if (this.probeStrategy === 'linear'){
            return function*(key){
              for (let i=0;i<M;i++){
                yield (hash + i) % M;
              }
            };
          } else {
            // quadratic probing: (hash + i^2) % M
            return function*(key){
              for (let i=0;i<M;i++){
                yield (hash + i*i) % M;
              }
            };
          }
        }
        insert(key, value){
          const k = makeKey(key);
          const hash = computeHash(k, this.M);
          const generatorFn = this._probeSequence(hash);
          const gen = generatorFn();
          let idx;
          let firstTombstone = null;
          for (let step=0; step<this.M; step++){
            const next = gen.next();
            if (next.done) break;
            idx = next.value;
            const slot = this.slots[idx];
            if (slot.state === 'empty'){
              const placeIdx = firstTombstone !== null ? firstTombstone : idx;
              this.slots[placeIdx] = {state:'occupied', key:k, value:value};
              return {placed:true,index:placeIdx,probes:step+1,usedTombstone:firstTombstone!==null};
            } else if (slot.state === 'deleted'){
              if (firstTombstone === null) firstTombstone = idx;
            } else if (slot.state === 'occupied'){
              if (slot.key === k){
                slot.value = value;
                return {placed:true,index:idx,updated:true,probes:step+1};
              }
            }
          }
          // table full but maybe we have a tombstone recorded
          if (firstTombstone !== null){
            this.slots[firstTombstone] = {state:'occupied', key:k, value:value};
            return {placed:true,index:firstTombstone,probes:this.M,usedTombstone:true};
          }
          return {placed:false,probes:this.M}; // full
        }
        search(key){
          const k = makeKey(key);
          const hash = computeHash(k, this.M);
          const generatorFn = this._probeSequence(hash);
          const gen = generatorFn();
          for (let step=0; step<this.M; step++){
            const next = gen.next();
            if (next.done) break;
            const idx = next.value;
            const slot = this.slots[idx];
            if (slot.state === 'empty'){
              return {found:false,index:idx,probes:step+1};
            } else if (slot.state === 'occupied'){
              if (slot.key === k) return {found:true,index:idx,probes:step+1,node:slot};
            } // if deleted, continue probing
          }
          return {found:false,probes:this.M};
        }
        delete(key){
          const k = makeKey(key);
          const h = computeHash(k, this.M);
          const generatorFn = this._probeSequence(h);
          const gen = generatorFn();
          for (let step=0; step<this.M; step++){
            const next = gen.next();
            if (next.done) break;
            const idx = next.value;
            const slot = this.slots[idx];
            if (slot.state === 'empty') return {deleted:false,probes:step+1};
            if (slot.state === 'occupied' && slot.key === k){
              const removed = slot;
              this.slots[idx] = {state:'deleted', key:null, value:null};
              return {deleted:true,index:idx,removed,probes:step+1};
            }
          }
          return {deleted:false,probes:this.M};
        }
        clear(){
          this.slots = Array.from({length:this.M}, ()=>({state:'empty', key:null, value:null}));
        }
      }

      // UI wiring
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const strategyEl = document.getElementById('strategy');
      const keyInput = document.getElementById('keyInput');
      const valueInput = document.getElementById('valueInput');
      const insertBtn = document.getElementById('insertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const fillBtn = document.getElementById('fillBtn');
      const visualArea = document.getElementById('visualArea');
      const status = document.getElementById('status');
      const hashOutput = document.getElementById('hashOutput');
      const stepToggle = document.getElementById('stepToggle');
      const prevStep = document.getElementById('prevStep');
      const nextStep = document.getElementById('nextStep');
      const probeCount = document.getElementById('probeCount');

      let tableSize = Number(sizeRange.value);
      sizeLabel.textContent = tableSize;

      let mode = strategyEl.value; // 'chaining' or 'linear' or 'quadratic'
      let stepMode = false;
      let probeIndex = -1;
      let currentProbes = [];

      let table = createTable();

      function createTable(){
        if (mode === 'chaining') return new HashTableChaining(tableSize);
        else return new HashTableOpen(tableSize, mode === 'linear' ? 'linear' : 'quadratic');
      }

      function resetProbes(){
        probeIndex = -1;
        currentProbes = [];
        renderProbeCount();
      }

      function renderProbeCount(){
        probeCount.textContent = currentProbes.length>0 ? (probeIndex+1) + " / " + currentProbes.length : "0";
      }

      function render(){
        visualArea.innerHTML = '';
        hashOutput.textContent = 'Index: —';
        resetProbes();

        if (mode === 'chaining'){
          for (let i=0;i<table.M;i++){
            const bucketEl = document.createElement('div');
            bucketEl.className = 'bucket';
            const h3 = document.createElement('h3');
            h3.textContent = 'Bucket';
            bucketEl.appendChild(h3);

            const idxBadge = document.createElement('div');
            idxBadge.className = 'index-badge';
            idxBadge.textContent = i;
            bucketEl.appendChild(idxBadge);

            const chain = document.createElement('div');
            chain.className = 'chain';
            const nodes = table.buckets[i];
            if (nodes.length === 0){
              const empty = document.createElement('div');
              empty.className = 'node slot empty';
              empty.textContent = '(empty)';
              chain.appendChild(empty);
            } else {
              for (let node of nodes){
                const n = document.createElement('div');
                n.className = 'node';
                const left = document.createElement('div');
                left.textContent = node.key;
                const right = document.createElement('div');
                right.style.fontSize='12px';
                right.style.color='var(--muted)';
                right.textContent = node.value !== null && node.value !== undefined && node.value !== '' ? node.value : '—';
                n.appendChild(left);
                n.appendChild(right);
                chain.appendChild(n);
              }
            }
            bucketEl.appendChild(chain);
            visualArea.appendChild(bucketEl);
          }
        } else {
          // open addressing - render array slots
          for (let i=0;i<table.M;i++){
            const slot = table.slots[i];
            const slotEl = document.createElement('div');
            slotEl.className = 'array-slot slot';
            if (slot.state === 'empty') slotEl.classList.add('empty');
            if (slot.state === 'deleted') slotEl.classList.add('deleted');
            const idxBadge = document.createElement('div');
            idxBadge.className = 'index-badge';
            idxBadge.textContent = i;
            slotEl.appendChild(idxBadge);

            const keyEl = document.createElement('div');
            keyEl.className = 'slot-key';
            keyEl.textContent = slot.state === 'occupied' ? slot.key : (slot.state === 'deleted' ? '— (deleted)' : '(empty)');
            const valEl = document.createElement('div');
            valEl.className = 'slot-val';
            valEl.textContent = slot.state === 'occupied' ? (slot.value !== undefined && slot.value !== null && slot.value !== '' ? slot.value : '—') : '';

            slotEl.appendChild(keyEl);
            slotEl.appendChild(valEl);

            visualArea.appendChild(slotEl);
          }
        }
      }

      // Actions
      insertBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        if (!key){
          status.innerHTML = '<span style="color:var(--bad)">Please enter a key to insert.</span>';
          return;
        }
        const value = valueInput.value;
        if (mode === 'chaining'){
          const idx = computeHash(key, table.M);
          hashOutput.textContent = 'Index: ' + idx;
          const res = table.insert(key, value);
          if (res.updated){
            status.innerHTML = '<span style="color:var(--good)">Updated key "'+key+'" at bucket '+res.index+'.</span>';
          } else {
            status.innerHTML = '<span style="color:var(--good)">Inserted "'+key+'" → bucket '+res.index+'.</span>';
          }
          render();
        } else {
          const hash = computeHash(key, table.M);
          hashOutput.textContent = 'Index: ' + hash;
          const seq = probeSequenceForUI(hash, table);
          currentProbes = seq;
          probeIndex = -1;
          renderProbeCount();
          if (!stepMode){
            const res = table.insert(key, value);
            if (res.placed){
              status.innerHTML = '<span style="color:var(--good)">Inserted "'+key+'" at index '+res.index+' after '+res.probes+' probes.</span>';
            } else {
              status.innerHTML = '<span style="color:var(--bad)">Table full — could not insert.</span>';
            }
            render();
          } else {
            // Step mode: set up probes and highlight first probe
            status.innerHTML = '<span style="color:var(--muted)">Step mode: advance through probes to insert.</span>';
            probeIndex = -1;
            stepInsertState = {key, value, hash, done:false};
            nextStepAction = ()=>{
              // perform one probe step visually; if we find spot, commit
              if (!stepInsertState || stepInsertState.done) return;
              probeIndex++;
              renderProbes(currentProbes, probeIndex);
              if (probeIndex >= currentProbes.length) {
                status.innerHTML = '<span style="color:var(--bad)">No free slot found (table full).</span>';
                stepInsertState.done = true;
                render();
                return;
              }
              const idx = currentProbes[probeIndex];
              const slot = table.slots[idx];
              if (slot.state === 'empty' || slot.state === 'deleted'){
                // commit insertion
                table.slots[idx] = {state:'occupied', key:makeKey(key), value:value};
                status.innerHTML = '<span style="color:var(--good)">Inserted "'+key+'" at index '+idx+' (probe '+(probeIndex+1)+').</span>';
                stepInsertState.done = true;
                render(); // final render clears highlights
                resetProbes();
              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){
                slot.value = value;
                status.innerHTML = '<span style="color:var(--good)">Updated existing key at index '+idx+' (probe '+(probeIndex+1)+').</span>';
                stepInsertState.done = true;
                render();
                resetProbes();
              } else {
                status.innerHTML = '<span style="color:var(--muted)">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+slot.key+').</span>';
              }
            };
            // show first probe (do not auto-advance)
            nextStepAction();
          }
        }
      });

      let nextStepAction = null;
      let prevStepAction = null;
      let stepInsertState = null;
      let stepSearchState = null;
      let stepDeleteState = null;

      searchBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        if (!key){
          status.innerHTML = '<span style="color:var(--bad)">Please enter a key to search.</span>';
          return;
        }
        if (mode === 'chaining'){
          const res = table.search(key);
          hashOutput.textContent = 'Index: ' + res.index;
          if (res.found){
            status.innerHTML = '<span style="color:var(--good)">Found "'+key+'" in bucket '+res.index+' (chain index '+res.chainIndex+'). Value: '+res.node.value+'</span>';
          } else {
            status.innerHTML = '<span style="color:var(--muted)">Not found in bucket '+res.index+'.</span>';
          }
        } else {
          const hash = computeHash(key, table.M);
          hashOutput.textContent = 'Index: ' + hash;
          const seq = probeSequenceForUI(hash, table);
          currentProbes = seq;
          probeIndex = -1;
          renderProbeCount();
          if (!stepMode){
            const res = table.search(key);
            if (res.found){
              status.innerHTML = '<span style="color:var(--good)">Found "'+key+'" at index '+res.index+' after '+res.probes+' probes. Value: '+res.node.value+'</span>';
            } else {
              status.innerHTML = '<span style="color:var(--muted)">Not found after '+res.probes+' probes.</span>';
            }
            render();
          } else {
            // step search
            stepSearchState = {key, hash, done:false};
            status.innerHTML = '<span style="color:var(--muted)">Step search: advance probes.</span>';
            nextStepAction = ()=>{
              if (!stepSearchState || stepSearchState.done) return;
              probeIndex++;
              renderProbes(currentProbes, probeIndex);
              if (probeIndex >= currentProbes.length){
                status.innerHTML = '<span style="color:var(--muted)">Not found — reached max probes.</span>';
                stepSearchState.done = true;
                resetProbes();
                render();
                return;
              }
              const idx = currentProbes[probeIndex];
              const slot = table.slots[idx];
              if (slot.state === 'empty'){
                status.innerHTML = '<span style="color:var(--muted)">Probe '+(probeIndex+1)+': index '+idx+' is empty → not found.</span>';
                stepSearchState.done = true;
                resetProbes();
                render();
                return;
              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){
                status.innerHTML = '<span style="color:var(--good)">Found at index '+idx+' (probe '+(probeIndex+1)+'). Value: '+slot.value+'</span>';
                stepSearchState.done = true;
                resetProbes();
                render();
                return;
              } else {
                status.innerHTML = '<span style="color:var(--muted)">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+(slot.key||'deleted')+')</span>';
              }
            };
            nextStepAction();
          }
        }
      });

      deleteBtn.addEventListener('click', ()=>{
        const key = keyInput.value.trim();
        if (!key){
          status.innerHTML = '<span style="color:var(--bad)">Please enter a key to delete.</span>';
          return;
        }
        if (mode === 'chaining'){
          const res = table.delete(key);
          hashOutput.textContent = 'Index: ' + res.index;
          if (res.removed){
            status.innerHTML = '<span style="color:var(--good)">Deleted "'+key+'" from bucket '+res.index+'.</span>';
          } else {
            status.innerHTML = '<span style="color:var(--muted)">Key not found in bucket '+res.index+'.</span>';
          }
          render();
        } else {
          const hash = computeHash(key, table.M);
          hashOutput.textContent = 'Index: ' + hash;
          const seq = probeSequenceForUI(hash, table);
          currentProbes = seq;
          probeIndex = -1;
          renderProbeCount();
          if (!stepMode){
            const res = table.delete(key);
            if (res.deleted){
              status.innerHTML = '<span style="color:var(--good)">Deleted "'+key+'" at index '+res.index+' after '+res.probes+' probes.</span>';
            } else {
              status.innerHTML = '<span style="color:var(--muted)">Key not found after '+res.probes+' probes.</span>';
            }
            render();
          } else {
            stepDeleteState = {key, hash, done:false};
            status.innerHTML = '<span style="color:var(--muted)">Step delete: advance probes.</span>';
            nextStepAction = ()=>{
              if (!stepDeleteState || stepDeleteState.done) return;
              probeIndex++;
              renderProbes(currentProbes, probeIndex);
              if (probeIndex >= currentProbes.length){
                status.innerHTML = '<span style="color:var(--muted)">Not found — reached max probes.</span>';
                stepDeleteState.done = true;
                render();
                resetProbes();
                return;
              }
              const idx = currentProbes[probeIndex];
              const slot = table.slots[idx];
              if (slot.state === 'empty'){
                status.innerHTML = '<span style="color:var(--muted)">Probe '+(probeIndex+1)+': index '+idx+' is empty → not found.</span>';
                stepDeleteState.done = true;
                render();
                resetProbes();
                return;
              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){
                table.slots[idx] = {state:'deleted', key:null, value:null};
                status.innerHTML = '<span style="color:var(--good)">Deleted at index '+idx+' (probe '+(probeIndex+1)+').</span>';
                stepDeleteState.done = true;
                render();
                resetProbes();
                return;
              } else {
                status.innerHTML = '<span style="color:var(--muted)">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+(slot.key||'deleted')+')</span>';
              }
            };
            nextStepAction();
          }
        }
      });

      // Step buttons
      nextStep.addEventListener('click', ()=>{
        if (nextStepAction) nextStepAction();
      });
      prevStep.addEventListener('click', ()=>{
        if (!currentProbes || currentProbes.length===0) return;
        if (probeIndex > 0) probeIndex--;
        renderProbes(currentProbes, probeIndex);
        renderProbeCount();
      });

      stepToggle.addEventListener('click', ()=>{
        stepMode = !stepMode;
        stepToggle.textContent = 'Step Mode: ' + (stepMode ? 'On' : 'Off');
        if (!stepMode){
          // cancel any pending step state
          nextStepAction = null;
          stepInsertState = null;
          stepSearchState = null;
          stepDeleteState = null;
          resetProbes();
          render();
        }
      });

      fillBtn.addEventListener('click', ()=>{
        const items = ['apple','banana','cherry','date','fig','grape','kiwi','lime','mango','nectarine','orange','pear','quince','raspberry','strawberry','tomato','ugli','vanilla','watermelon','yam','zucchini','alpha','beta','gamma'];
        let added = 0;
        if (mode === 'chaining'){
          table.clear();
          for (let i=0;i<table.M && added < table.M; i++){
            const key = items[(Math.floor(Math.random()*items.length))];
            table.insert(key, 'v:'+key);
            added++;
          }
          status.innerHTML = '<span style="color:var(--good)">Filled chaining table with sample items.</span>';
        } else {
          table.clear();
          for (let i=0;i<table.M && added < table.M-2;i++){
            const key = items[(Math.floor(Math.random()*items.length))];
            const res = table.insert(key, 'v:'+key);
            if (res.placed) added++;
          }
          status.innerHTML = '<span style="color:var(--good)">Filled open addressing table with sample items.</span>';
        }
        render();
      });

      clearBtn.addEventListener('click', ()=>{
        table.clear();
        status.innerHTML = '<span style="color:var(--muted)">Table reset.</span>';
        render();
      });

      sizeRange.addEventListener('input', ()=>{
        tableSize = Number(sizeRange.value);
        sizeLabel.textContent = tableSize;
      });

      sizeRange.addEventListener('change', ()=>{
        tableSize = Number(sizeRange.value);
        sizeLabel.textContent = tableSize;
        // recreate table with new size
        tableSize = Number(sizeRange.value);
        table = createTableSize(tableSize);
        render();
        status.innerHTML = '<span style="color:var(--muted)">Table size changed to '+tableSize+'.</span>';
      });

      strategyEl.addEventListener('change', ()=>{
        mode = strategyEl.value;
        table = createTable(); // new table with current size & mode
        render();
        status.innerHTML = '<span style="color:var(--muted)">Switched strategy to '+(mode==='chaining'?'Separate Chaining':(mode==='linear'?'Linear Probing':'Quadratic Probing'))+'</span>';
      });

      function createTableSize(sz){
        if (mode === 'chaining') return new HashTableChaining(sz);
        else return new HashTableOpen(sz, mode === 'linear' ? 'linear' : 'quadratic');
      }

      function probeSequenceForUI(hash, table){
        const seq = [];
        const M = table.M;
        if (table instanceof HashTableOpen){
          if (table.probeStrategy === 'linear'){
            for (let i=0;i<M;i++) seq.push((hash+i)%M);
          } else {
            for (let i=0;i<M;i++) seq.push((hash + i*i)%M);
          }
        }
        return seq;
      }

      function clearHighlights(){
        const slotEls = visualArea.querySelectorAll('.array-slot, .bucket');
        slotEls.forEach(el=>el.classList.remove('highlight'));
      }

      function renderProbes(seq, index){
        clearHighlights();
        const slotEls = visualArea.querySelectorAll('.array-slot');
        seq.forEach((idx,i)=>{
          if (slotEls[idx]){
            if (i === index) slotEls[idx].classList.add('highlight');
            else slotEls[idx].classList.remove('highlight');
          }
        });
        renderProbeCount();
      }

      // initial render
      function init(){
        table = createTable();
        render();
        status.innerHTML = '<span style="color:var(--muted)">Ready. Try inserting keys like "a", "k", "u" to create collisions on small tables.</span>';
      }

      init();

      // small helper: update hash display as user types
      keyInput.addEventListener('input', ()=>{
        const k = keyInput.value.trim();
        if (!k){ hashOutput.textContent = 'Index: —'; return; }
        hashOutput.textContent = 'Index: ' + computeHash(k, table.M);
      });

      // Expose some debug shortcuts:
      window.htDemo = {table, computeHash};

    })();
  </script>
</body>
</html>