<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f4f8;
  }
  h1 {
    text-align:center;
    color: #333;
  }
  #controls {
    margin-bottom: 20px;
    display: flex;
    justify-content:center;
    gap: 10px;
    flex-wrap: wrap;
  }
  input[type=number] {
    width: 100px;
    padding: 6px 8px;
    font-size: 16px;
  }
  button {
    padding: 7px 15px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    background-color: #1e88e5;
    color: white;
    border-radius: 4px;
  }
  button:hover:not(:disabled) {
    background-color: #1565c0;
  }
  button:disabled {
    background-color: #a0a0a0;
    cursor: default;
  }
  #log {
    max-width: 600px;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 3px 10px rgb(0 0 0 / 0.2);
    height: 150px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 14px;
    color: #444;
  }
  #tree-container {
    margin-top: 30px;
    text-align: center;
  }
  svg {
    max-width: 90%;
    height: 320px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 3px 10px rgb(0 0 0 / 0.12);
  }
  .node {
    cursor: pointer;
    transition: transform 0.3s ease;
  }
  .node circle {
    fill: #42a5f5;
    stroke: #1e88e5;
    stroke-width: 3px;
    transition: fill 0.3s ease;
  }
  .node text {
    fill: white;
    font-weight: bold;
    user-select: none;
    pointer-events: none;
  }
  .node.highlight circle {
    fill: #ff7043;
  }
  line.edge {
    stroke: #90caf9;
    stroke-width: 2px;
  }
</style>
</head>
<body>

<h1>Binary Search Tree (BST) Interactive Demo</h1>

<div id="controls">
  <input type="number" id="inputValue" placeholder="Value" />
  <button id="insertBtn">Insert</button>
  <button id="searchBtn">Search</button>
  <button id="deleteBtn">Delete</button>
  <button id="clearBtn" title="Clear the entire tree">Clear Tree</button>
</div>

<div id="log" aria-live="polite" aria-atomic="false"></div>

<div id="tree-container">
  <svg id="bst-svg" role="img" aria-label="Binary Search Tree Visualization"></svg>
</div>

<script>
(() => {
  // BST Node class
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      this.x = 0;
      this.y = 0;
    }
  }

  // BST class
  class BST {
    constructor() {
      this.root = null;
    }

    insert(value) {
      const newNode = new Node(value);
      if (this.root === null) {
        this.root = newNode;
        return true;
      } else {
        return this._insertNode(this.root, newNode);
      }
    }

    _insertNode(node, newNode) {
      if (newNode.value === node.value) {
        return false; // no duplicates allowed
      }
      if (newNode.value < node.value) {
        if (node.left === null) {
          node.left = newNode;
          return true;
        } else {
          return this._insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
          return true;
        } else {
          return this._insertNode(node.right, newNode);
        }
      }
    }

    search(value) {
      return this._searchNode(this.root, value);
    }

    _searchNode(node, value) {
      if (node === null) return null;
      if (value === node.value) return node;
      if (value < node.value) return this._searchNode(node.left, value);
      else return this._searchNode(node.right, value);
    }

    delete(value) {
      let deleted = false;
      this.root = this._deleteNode(this.root, value, (d) => { deleted = d; });
      return deleted;
    }

    _deleteNode(node, value, deletedFlag) {
      if (node === null) return null;
      if (value < node.value) {
        node.left = this._deleteNode(node.left, value, deletedFlag);
        return node;
      } else if (value > node.value) {
        node.right = this._deleteNode(node.right, value, deletedFlag);
        return node;
      } else {
        deletedFlag(true);
        // node with only one child or no child
        if (node.left === null) return node.right;
        else if (node.right === null) return node.left;

        // node with two children: get inorder successor (smallest in the right subtree)
        let minNode = this._minValueNode(node.right);
        node.value = minNode.value;

        // Delete the inorder successor
        node.right = this._deleteNode(node.right, minNode.value, () => {});
        return node;
      }
    }

    _minValueNode(node) {
      let current = node;
      while (current.left !== null) {
        current = current.left;
      }
      return current;
    }

    clear() {
      this.root = null;
    }

    // inorder traversal for debug or logs (returns array of values)
    inorder() {
      const result = [];
      this._inorder(this.root, result);
      return result;
    }

    _inorder(node, arr) {
      if (node !== null) {
        this._inorder(node.left, arr);
        arr.push(node.value);
        this._inorder(node.right, arr);
      }
    }
  }

  // Visualization code
  const svg = document.getElementById('bst-svg');
  const LOG = document.getElementById('log');

  let bst = new BST();

  // Dimensions for visualization
  const nodeRadius = 20;
  const verticalGap = 70;

  // Calculate positions for all nodes
  // We use an in-order traversal to determine x position and levels for y.
  function calculateNodePositions() {
    let x = 0;
    function assignPositions(node, depth) {
      if (!node) return;
      assignPositions(node.left, depth + 1);
      node.x = x++;
      node.y = depth;
      assignPositions(node.right, depth + 1);
    }
    assignPositions(bst.root, 0);
  }

  // Render the BST into SVG
  function renderBST(highlightValue = null) {
    svg.innerHTML = '';

    if (!bst.root) {
      svg.setAttribute('viewBox', '0 0 400 150');
      const emptyText = document.createElementNS('http://www.w3.org/2000/svg','text');
      emptyText.setAttribute('x', '50%');
      emptyText.setAttribute('y','50%');
      emptyText.setAttribute('text-anchor','middle');
      emptyText.setAttribute('dominant-baseline','middle');
      emptyText.setAttribute('fill','#666');
      emptyText.textContent = 'Tree is empty';
      svg.appendChild(emptyText);
      return;
    }

    calculateNodePositions();

    // The horizontal positioning will be based on in-order index scaled to SVG width
    const nodes = [];
    function collectNodes(node) {
      if (!node) return;
      collectNodes(node.left);
      nodes.push(node);
      collectNodes(node.right);
    }
    collectNodes(bst.root);

    // Calculate spacing
    const count = nodes.length;
    const width = Math.max(400, count * (nodeRadius*3));
    const height = (getMaxDepth(bst.root) + 1) * verticalGap + 40;

    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `-30 0 ${width+60} ${height}`);

    // Helper to get max depth
    function getMaxDepth(node) {
      if (!node) return 0;
      return 1 + Math.max(getMaxDepth(node.left), getMaxDepth(node.right));
    }

    // Map x (inorder index) to SVG coordinate
    const hSpacing = width / (count + 1);
    // y is based on depth

    function getX(node) {
      return (node.x + 1) * hSpacing;
    }
    function getY(node) {
      return (node.y * verticalGap) + 40;
    }

    // Draw edges first (lines)
    function drawEdges(node) {
      if (!node) return;
      if (node.left) drawLine(node, node.left);
      if (node.right) drawLine(node, node.right);
      drawEdges(node.left);
      drawEdges(node.right);
    }
    function drawLine(parent, child) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('class', 'edge');
      line.setAttribute('x1', getX(parent));
      line.setAttribute('y1', getY(parent) + nodeRadius);
      line.setAttribute('x2', getX(child));
      line.setAttribute('y2', getY(child) - nodeRadius);
      svg.appendChild(line);
    }
    drawEdges(bst.root);

    // Draw nodes
    function drawNode(node) {
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class', 'node');
      g.setAttribute('transform', `translate(${getX(node)},${getY(node)})`);
      if (highlightValue !== null && node.value === highlightValue) {
        g.classList.add('highlight');
      }
      // Circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r', nodeRadius);
      circle.setAttribute('tabindex', '0');
      circle.setAttribute('aria-label', `Node with value ${node.value}`);
      g.appendChild(circle);
      // Text label
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('dy', '0.35em');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = node.value;
      g.appendChild(text);

      svg.appendChild(g);
    }

    function drawAllNodes(node) {
      if (!node) return;
      drawAllNodes(node.left);
      drawNode(node);
      drawAllNodes(node.right);
    }
    drawAllNodes(bst.root);
  }

  // Log helper
  function log(msg) {
    const p = document.createElement('div');
    p.textContent = msg;
    LOG.appendChild(p);
    LOG.scrollTop = LOG.scrollHeight;
  }
  function clearLog() {
    LOG.innerHTML = '';
  }

  // Button and input refs
  const inputValue = document.getElementById('inputValue');
  const insertBtn = document.getElementById('insertBtn');
  const searchBtn = document.getElementById('searchBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const clearBtn = document.getElementById('clearBtn');

  // Input validation and helpers
  function getInputNumber() {
    const val = inputValue.value.trim();
    if (val === '') return null;
    const num = Number(val);
    if (Number.isNaN(num) || !Number.isInteger(num)) return null;
    if (num < -1000000 || num > 1000000) return null; // arbitrary range limit
    return num;
  }

  function disableButtons(disabled) {
    insertBtn.disabled = disabled;
    searchBtn.disabled = disabled;
    deleteBtn.disabled = disabled;
  }

  // Event listeners
  insertBtn.addEventListener('click', () => {
    const num = getInputNumber();
    if (num === null) {
      alert('Please enter a valid integer between -1,000,000 and 1,000,000.');
      return;
    }
    const success = bst.insert(num);
    if (success) {
      log(`Inserted ${num} into the BST.`);
    } else {
      log(`Value ${num} already exists in the BST. No duplicates allowed.`);
    }
    inputValue.value = '';
    renderBST();
  });

  searchBtn.addEventListener('click', () => {
    const num = getInputNumber();
    if (num === null) {
      alert('Please enter a valid integer to search.');
      return;
    }
    disableButtons(true);
    log(`Searching for value ${num}...`);
    // Highlight search path with animation
    let path = [];
    function findPath(node, val) {
      if (!node) return false;
      path.push(node);
      if (val === node.value) return true;
      if (val < node.value) return findPath(node.left, val);
      else return findPath(node.right, val);
    }
    path = [];
    const found = findPath(bst.root, num);

    // Animate highlights (one node at a time)
    let i = 0;
    function highlightStep() {
      if (i > 0) {
        // Remove highlight from previous node
        const prevNode = path[i-1];
        unhighlightValue(prevNode.value);
      }
      if (i >= path.length) {
        if (found) {
          log(`Value ${num} found in the BST.`);
          highlightValue(num); // final highlight
        } else {
          log(`Value ${num} NOT found in the BST.`);
        }
        disableButtons(false);
        return;
      }
      highlightValue(path[i].value);
      i++;
      setTimeout(highlightStep, 800);
    }
    highlightStep();
  });

  deleteBtn.addEventListener('click', () => {
    const num = getInputNumber();
    if (num === null) {
      alert('Please enter a valid integer to delete.');
      return;
    }
    const deleted = bst.delete(num);
    if (deleted) {
      log(`Deleted ${num} from the BST.`);
    } else {
      log(`Value ${num} not found in the BST. Nothing deleted.`);
    }
    inputValue.value = '';
    renderBST();
  });

  clearBtn.addEventListener('click', () => {
    if (!bst.root) {
      log('Tree is already empty.');
      return;
    }
    if (confirm('Are you sure you want to clear the entire tree?')) {
      bst.clear();
      log('Cleared the entire BST.');
      renderBST();
    }
  });

  inputValue.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      insertBtn.click();
    }
  });

  // Highlight node by value
  function highlightValue(value) {
    // Add highlight class to the node group
    const nodes = svg.querySelectorAll('.node');
    nodes.forEach(n => {
      const textEl = n.querySelector('text');
      if (textEl && textEl.textContent == value) {
        n.classList.add('highlight');
      }
    });
  }

  // Remove highlight from node by value
  function unhighlightValue(value) {
    const nodes = svg.querySelectorAll('.node.highlight');
    nodes.forEach(n => {
      const textEl = n.querySelector('text');
      if (textEl && textEl.textContent == value) {
        n.classList.remove('highlight');
      }
    });
  }

  // Initial render
  renderBST();

  log('Binary Search Tree demonstration initialized.');
  log('Use the input box and buttons above to insert, search, and delete nodes.');

})();
</script>

</body>
</html>