<!DOCTYPE html>
# Huffman Coding Visualization

Here's an interactive visualization of Huffman coding that helps you understand how this algorithm generates efficient prefix codes for data compression.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .input-section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .input-section label {
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }
        .input-section textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            resize: vertical;
        }
        .input-section button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        .input-section button:hover {
            background-color: #2980b9;
        }
        .results-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .results-section > div {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
        }
        h2 {
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
        .tree-visualization {
            overflow-x: auto;
            margin-top: 20px;
        }
        .tree-container {
            position: relative;
            min-height: 300px;
            margin-top: 20px;
        }
        .tree-node {
            position: absolute;
            border: 2px solid #3498db;
            background-color: white;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            z-index: 2;
        }
        .tree-leaf {
            background-color: #e74c3c;
            color: white;
        }
        .tree-connector {
            position: absolute;
            height: 40px;
            width: 2px;
            background-color: #3498db;
            z-index: 1;
        }
        .binary-label {
            position: absolute;
            font-size: 12px;
            z-index: 3;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .explanation {
            line-height: 1.6;
            margin-top: 20px;
        }
        .bits-saving {
            font-weight: bold;
            color: #27ae60;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Huffman Coding Visualization</h1>
        
        <div class="input-section">
            <label for="input-text">Enter text to encode:</label>
            <textarea id="input-text" placeholder="Type your text here...">Huffman coding is a popular compression algorithm</textarea>
            <button id="encode-btn">Generate Huffman Codes</button>
        </div>
        
        <div class="results-section">
            <div id="frequency-table-container">
                <h2>Character Frequencies</h2>
                <table id="frequency-table">
                    <thead>
                        <tr>
                            <th>Character</th>
                            <th>Frequency</th>
                        </tr>
                    </thead>
                    <tbody id="frequency-table-body">
                        <!-- Will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
            
            <div id="huffman-codes-container">
                <h2>Huffman Codes</h2>
                <table id="huffman-codes-table">
                    <thead>
                        <tr>
                            <th>Character</th>
                            <th>Huffman Code</th>
                            <th>Length</th>
                        </tr>
                    </thead>
                    <tbody id="huffman-codes-body">
                        <!-- Will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <div id="tree-container" class="tree-container">
            <h2>Huffman Tree Visualization</h2>
            <!-- Will be populated by JavaScript -->
        </div>
        
        <div id="explanation" class="explanation">
            <h2>How Huffman Coding Works</h2>
            <p>Huffman coding is an efficient algorithm for lossless data compression. The fundamental idea is to assign variable-length codes to input characters, with shorter codes assigned to more frequent characters.</p>
            <p>The algorithm works as follows:</p>
            <ol>
                <li>Calculate the frequency of each character in the input text.</li>
                <li>Create a leaf node for each character and add it to a priority queue.</li>
                <li>While there is more than one node in the queue:
                    <ul>
                        <li>Remove the two nodes of highest priority (lowest frequency) from the queue</li>
                        <li>Create a new internal node with these two nodes as children and with frequency equal to the sum of the two nodes' frequencies</li>
                        <li>Add the new node to the queue</li>
                    </ul>
                </li>
                <li>The remaining node is the root of the Huffman tree</li>
                <li>Traverse the tree to assign binary codes to each character</li>
            </ol>
            <p>In this visualization, you can see the frequency table, the generated Huffman codes, and a visual representation of the Huffman tree.</p>
            <p id="bits-saving-info" class="bits-saving"></p>
        </div>
    </div>

    <script>
        // Huffman Tree Node class
        class HuffmanNode {
            constructor(char, frequency, left = null, right = null) {
                this.char = char;
                this.frequency = frequency;
                this.left = left;
                this.right = right;
            }
        }

        // Function to build frequency table
        function buildFrequencyTable(text) {
            const freqTable = {};
            for (let char of text) {
                freqTable[char] = (freqTable[char] || 0) + 1;
            }
            return freqTable;
        }

        // Function to build Huffman tree
        function buildHuffmanTree(freqTable) {
            // Create leaf nodes for each character
            const nodes = [];
            for (let char in freqTable) {
                nodes.push(new HuffmanNode(char, freqTable[char]));
            }
            
            // Build the tree by combining nodes with lowest frequencies
            while (nodes.length > 1) {
                // Sort nodes by frequency (ascending)
                nodes.sort((a, b) => a.frequency - b.frequency);
                
                // Take the two nodes with the smallest frequencies
                const left = nodes.shift();
                const right = nodes.shift();
                
                // Create a new node with these two as children
                const parent = new HuffmanNode(
                    null, 
                    left.frequency + right.frequency, 
                    left, 
                    right
                );
                
                // Add the new node to the list
                nodes.push(parent);
            }
            
            // The last remaining node is the root of the Huffman tree
            return nodes[0];
        }

        // Function to generate Huffman codes
        function generateHuffmanCodes(root) {
            const codes = {};
            
            function traverse(node, code) {
                if (node.char !== null) {
                    // Leaf node - assign the code
                    codes[node.char] = code;
                    return;
                }
                
                // Traverse left with '0'
                if (node.left) {
                    traverse(node.left, code + '0');
                }
                
                // Traverse right with '1'
                if (node.right) {
                    traverse(node.right, code + '1');
                }
            }
            
            // Start traversal from the root with an empty code
            traverse(root, '');
            return codes;
        }

        // Function to display the frequency table
        function displayFrequencyTable(freqTable) {
            const tableBody = document.getElementById('frequency-table-body');
            tableBody.innerHTML = '';
            
            const sortedFreq = Object.entries(freqTable)
                .sort((a, b) => b[1] - a[1]);
            
            for (let [char, freq] of sortedFreq) {
                const row = document.createElement('tr');
                
                const charCell = document.createElement('td');
                charCell.textContent = char === ' ' ? '[space]' : char;
                row.appendChild(charCell);
                
                const freqCell = document.createElement('td');
                freqCell.textContent = freq;
                row.appendChild(freqCell);
                
                tableBody.appendChild(row);
            }
        }

        // Function to display Huffman codes
        function displayHuffmanCodes(codes, freqTable) {
            const tableBody = document.getElementById('huffman-codes-body');
            tableBody.innerHTML = '';
            
            const sortedCodes = Object.entries(codes)
                .sort((a, b) => freqTable[b[0]] - freqTable[a[0]]);
            
            for (let [char, code] of sortedCodes) {
                const row = document.createElement('tr');
                
                const charCell = document.createElement('td');
                charCell.textContent = char === ' ' ? '[space]' : char;
                row.appendChild(charCell);
                
                const codeCell = document.createElement('td');
                codeCell.textContent = code;
                row.appendChild(codeCell);
                
                const lengthCell = document.createElement('td');
                lengthCell.textContent = code.length;
                row.appendChild(lengthCell);
                
                tableBody.appendChild(row);
            }
        }

        // Function to calculate the positions of nodes in the tree for visualization
        function calculateTreeLayout(root) {
            const nodes = [];
            const edges = [];
            let maxDepth = 0;
            
            function traverse(node, depth, x, parentX, parentY, code) {
                if (!node) return;
                
                maxDepth = Math.max(maxDepth, depth);
                
                // Leaf node
                if (node.char !== null) {
                    nodes.push({
                        char: node.char,
                        frequency: node.frequency,
                        x: x,
                        y: depth * 100 + 50,
                        isLeaf: true,
                        code: code
                    });
                } else {
                    // Internal node
                    nodes.push({
                        char: null,
                        frequency: node.frequency,
                        x: x,
                        y: depth * 100 + 50,
                        isLeaf: false,
                        code: code
                    });
                }
                
                // Calculate positions for children
                const span = Math.pow(2, maxDepth - depth - 1) * 50;
                
                // Left child (0)
                if (node.left) {
                    const childX = x - span / 2;
                    
                    edges.push({
                        fromX: x,
                        fromY: depth * 100 + 50,
                        toX: childX,
                        toY: (depth + 1) * 100 + 50,
                        label: '0',
                        labelX: (x + childX) / 2,
                        labelY: (depth * 100 + 50 + (depth + 1) * 100 + 50) / 2 - 10
                    });
                    
                    traverse(node.left, depth + 1, childX, x, depth * 100 + 50, code + '0');
                }
                
                // Right child (1)
                if (node.right) {
                    const childX = x + span / 2;
                    
                    edges.push({
                        fromX: x,
                        fromY: depth * 100 + 50,
                        toX: childX,
                        toY: (depth + 1) * 100 + 50,
                        label: '1',
                        labelX: (x + childX) / 2,
                        labelY: (depth * 100 + 50 + (depth + 1) * 100 + 50) / 2 - 10
                    });
                    
                    traverse(node.right, depth + 1, childX, x, depth * 100 + 50, code + '1');
                }
            }
            
            // Start traversal from root
            traverse(root, 0, 600, null, null, '');
            
            return { nodes, edges, maxDepth };
        }

        // Function to visualize the Huffman tree
        function visualizeHuffmanTree(root) {
            const container = document.getElementById('tree-container');
            
            // Clear previous visualization
            while (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
            
            // Create a div for the tree
            const treeDiv = document.createElement('div');
            treeDiv.className = 'tree-visualization';
            container.appendChild(treeDiv);
            
            // Calculate node positions
            const layout = calculateTreeLayout(root);
            
            // Set container height based on tree depth
            treeDiv.style.height = `${(layout.maxDepth + 1) * 100 + 100}px`;
            treeDiv.style.position = 'relative';
            
            // Draw edges first (so they appear behind nodes)
            for (let edge of layout.edges) {
                const edgeDiv = document.createElement('div');
                edgeDiv.className = 'tree-connector';
                
                // Calculate angle and length for the edge
                const dx = edge.toX - edge.fromX;
                const dy = edge.toY - edge.fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                edgeDiv.style.width = `${length}px`;
                edgeDiv.style.left = `${edge.fromX}px`;
                edgeDiv.style.top = `${edge.fromY}px`;
                edgeDiv.style.transform = `rotate(${angle}deg)`;
                edgeDiv.style.transformOrigin = '0 0';
                
                treeDiv.appendChild(edgeDiv);
                
                // Add binary label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'binary-label';
                labelDiv.textContent = edge.label;
                labelDiv.style.left = `${edge.labelX}px`;
                labelDiv.style.top = `${edge.labelY}px`;
                treeDiv.appendChild(labelDiv);
            }
            
            // Draw nodes
            for (let node of layout.nodes) {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `tree-node ${node.isLeaf ? 'tree-leaf' : ''}`;
                nodeDiv.style.left = `${node.x - 25}px`;
                nodeDiv.style.top = `${node.y - 25}px`;
                
                // Node content
                if (node.isLeaf) {
                    nodeDiv.innerHTML = `
                        <div style="text-align: center; font-size: 14px;">
                            <div>${node.char === ' ' ? '[space]' : node.char}</div>
                            <div style="font-size: 10px;">${node.frequency}</div>
                        </div>
                    `;
                } else {
                    nodeDiv.innerHTML = `
                        <div style="text-align: center; font-size: 12px;">
                            <div>${node.frequency}</div>
                        </div>
                    `;
                }
                
                treeDiv.appendChild(nodeDiv);
            }
        }

        // Function to calculate bit savings
        function calculateBitSavings(text, codes) {
            // Standard encoding (8 bits per character)
            const standardBits = text.length * 8;
            
            // Huffman encoding
            let huffmanBits = 0;
            for (let char of text) {
                huffmanBits += codes[char].length;
            }
            
            const savings = standardBits - huffmanBits;
            const percentage = ((savings / standardBits) * 100).toFixed(2);
            
            return {
                standardBits,
                huffmanBits,
                savings,
                percentage
            };
        }

        // Main function to process the input text
        function processText() {
            const inputText = document.getElementById('input-text').value;
            
            if (!inputText.trim()) {
                alert('Please enter some text to encode.');
                return;
            }
            
            // Build frequency table
            const freqTable = buildFrequencyTable(inputText);
            displayFrequencyTable(freqTable);
            
            // Build Huffman tree
            const root = buildHuffmanTree(freqTable);
            
            // Generate Huffman codes
            const codes = generateHuffmanCodes(root);
            displayHuffmanCodes(codes, freqTable);
            
            // Visualize the tree
            visualizeHuffmanTree(root);
            
            // Calculate and display bit savings
            const savings = calculateBitSavings(inputText, codes);
            document.getElementById('bits-saving-info').textContent = 
                `Bit Usage: Standard = ${savings.standardBits} bits, Huffman = ${savings.huffmanBits} bits. ` +
                `Savings: ${savings.savings} bits (${savings.percentage}%)`;
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listener for the encode button
