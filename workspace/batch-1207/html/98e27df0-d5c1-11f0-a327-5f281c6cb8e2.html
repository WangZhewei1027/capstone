<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Prim's Algorithm Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#94a3b8;
    --accent:#3b82f6;
    --accent-2:#fb923c;
    --good:#10b981;
    --danger:#ef4444;
    --card:#071029;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;padding:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,var(--bg),#071225);color:#e6eef8;}
  .container{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100vh;}
  .left{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;display:flex;flex-direction:column;align-items:stretch;}
  .canvas-wrap{flex:1;border-radius:8px;background:var(--card);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;}
  canvas{background:transparent;display:block;max-width:100%;max-height:100%;}
  .hint{position:absolute;left:10px;top:10px;background:var(--glass);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px}
  .right{width:380px;display:flex;flex-direction:column;gap:12px;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;min-height:80px}
  .controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  label{font-size:13px;color:var(--muted);min-width:110px}
  input[type=range]{flex:1}
  .btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,var(--accent),#2563eb);color:white;border:none}
  .btn.warn{background:linear-gradient(180deg,var(--accent-2),#ef7a2a);color:white;border:none}
  .small{font-size:13px;color:var(--muted)}
  .info{display:flex;gap:8px;flex-wrap:wrap}
  .stat{background:var(--glass);padding:8px;border-radius:8px;min-width:120px}
  .pq, .log{max-height:200px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;font-size:13px;color:var(--muted)}
  .pq-item{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px}
  .pq-weight{font-weight:600;color:white;padding:2px 6px;border-radius:6px;background:rgba(0,0,0,0.25)}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:13px}
  .swatch{width:18px;height:10px;border-radius:4px;display:inline-block}
  .pseudocode{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px}
  .pseudocode div{padding:4px 6px;border-radius:6px}
  .pseudocode .highlight{background:linear-gradient(90deg, rgba(59,130,246,0.12), rgba(59,130,246,0.06));border-left:3px solid rgba(59,130,246,0.9);color:white}
  .footer{font-size:13px;color:var(--muted);margin-top:6px}
  .node-label{font-size:12px}
  .small-muted{font-size:12px;color:var(--muted)}
  .top-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .controls .btn-row{display:flex;gap:8px}
  .controls select{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:8px}
  .credits{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  .node-click-hint{position:absolute;right:10px;top:10px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="container">
  <div class="left">
    <div class="top-row">
      <div style="display:flex;flex-direction:column">
        <div style="font-weight:600">Prim's Algorithm — Minimum Spanning Tree</div>
        <div class="small-muted">Click a node to choose start. Step through or autoplay.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small-muted">Nodes:</div>
        <div id="nodeCountDisplay" class="small-muted">8</div>
      </div>
    </div>
    <div class="canvas-wrap" id="canvasWrap">
      <div class="hint" id="hint">Click a node to set start • Step through Prim's algorithm</div>
      <canvas id="graphCanvas" width="900" height="700"></canvas>
      <div class="node-click-hint">Start node: <b id="startLabel">None</b></div>
    </div>
  </div>

  <div class="right">
    <div class="panel controls">
      <div class="row">
        <label for="nodesRange">Nodes</label>
        <input id="nodesRange" type="range" min="4" max="18" value="8">
        <div style="width:36px;text-align:right" id="nodesVal">8</div>
      </div>
      <div class="row">
        <label for="densityRange">Edge density</label>
        <input id="densityRange" type="range" min="10" max="90" value="45">
        <div style="width:36px;text-align:right" id="densityVal">45%</div>
      </div>
      <div class="row">
        <label for="maxW">Max weight</label>
        <input id="maxW" type="range" min="5" max="100" value="40">
        <div style="width:36px;text-align:right" id="maxWVal">40</div>
      </div>
      <div class="row">
        <label>Generate</label>
        <div style="display:flex;gap:8px">
          <button class="btn primary" id="regenBtn">Generate Graph</button>
          <button class="btn" id="randomStartBtn">Random Start</button>
        </div>
      </div>

      <div style="height:8px"></div>

      <div class="row">
        <label>Algorithm</label>
        <div class="btn-row">
          <button class="btn primary" id="stepBtn">Step</button>
          <button class="btn" id="runBtn">Auto Run</button>
          <button class="btn warn" id="resetAlgBtn">Reset</button>
        </div>
      </div>

      <div class="row">
        <label for="speedRange">Speed</label>
        <input id="speedRange" type="range" min="100" max="2000" value="600">
        <div style="width:56px;text-align:right" id="speedVal">600ms</div>
      </div>
      <div style="height:6px"></div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small-muted">Priority Queue</div>
        <div style="flex:1"></div>
        <div class="small-muted">Total MST Weight:</div>
        <div style="min-width:50px;text-align:right;font-weight:700" id="mstWeight">0</div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:600">Priority Queue (min-first)</div>
        <div class="small-muted">Items: <span id="pqSize">0</span></div>
      </div>
      <div class="pq" id="pqBox"></div>
      <div class="legend">
        <div class="item"><span class="swatch" style="background:linear-gradient(90deg,var(--accent),#1e40af)"></span> MST edge</div>
        <div class="item"><span class="swatch" style="background:linear-gradient(90deg,var(--accent-2),#fb7b2f)"></span> Frontier (in PQ)</div>
        <div class="item"><span class="swatch" style="background:#ef4444"></span> Considered (popped)</div>
        <div class="item"><span class="swatch" style="background:rgba(255,255,255,0.06)"></span> Ignored / removed</div>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:600;margin-bottom:8px">Pseudocode</div>
      <div class="pseudocode" id="pseudocode">
        <div data-line="0">1. Choose a start vertex S. Mark visited[S] = true</div>
        <div data-line="1">2. Insert all edges incident to S into a min-priority queue PQ (by weight)</div>
        <div data-line="2">3. While PQ not empty and not all vertices visited:</div>
        <div data-line="3">&nbsp;&nbsp;&nbsp;a) e = extract-min(PQ)  (edge with smallest weight)</div>
        <div data-line="4">&nbsp;&nbsp;&nbsp;b) If e connects visited to unvisited vertex v:</div>
        <div data-line="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add e to MST; mark v visited; insert edges incident to v into PQ</div>
        <div data-line="6">&nbsp;&nbsp;&nbsp;c) Else: discard e</div>
        <div data-line="7">4. Return MST when all vertices are visited</div>
      </div>
    </div>

    <div class="panel" style="padding:10px">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <div class="stat"><div class="small-muted">Visited</div><div id="visitedCount" style="font-weight:700">0</div></div>
        <div class="stat"><div class="small-muted">Edges in MST</div><div id="mstCount" style="font-weight:700">0</div></div>
        <div class="stat"><div class="small-muted">Steps</div><div id="stepsTaken" style="font-weight:700">0</div></div>
      </div>
      <div class="log" id="logBox" style="max-height:120px"></div>
    </div>

    <div class="credits panel" style="text-align:center;font-size:12px">
      Interactive visualization of Prim's greedy MST algorithm. Click nodes to choose a start vertex. Edges labeled with weights.
    </div>
  </div>
</div>

<script>
(function(){
  // Canvas and graph rendering
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('canvasWrap');

  // UI elements
  const nodesRange = document.getElementById('nodesRange');
  const densityRange = document.getElementById('densityRange');
  const nodesVal = document.getElementById('nodesVal');
  const densityVal = document.getElementById('densityVal');
  const maxW = document.getElementById('maxW');
  const maxWVal = document.getElementById('maxWVal');
  const regenBtn = document.getElementById('regenBtn');
  const randomStartBtn = document.getElementById('randomStartBtn');
  const startLabel = document.getElementById('startLabel');
  const stepBtn = document.getElementById('stepBtn');
  const runBtn = document.getElementById('runBtn');
  const resetAlgBtn = document.getElementById('resetAlgBtn');
  const speedRange = document.getElementById('speedRange');
  const speedVal = document.getElementById('speedVal');
  const pqBox = document.getElementById('pqBox');
  const pqSize = document.getElementById('pqSize');
  const mstWeightEl = document.getElementById('mstWeight');
  const visitedCountEl = document.getElementById('visitedCount');
  const mstCountEl = document.getElementById('mstCount');
  const stepsTakenEl = document.getElementById('stepsTaken');
  const logBox = document.getElementById('logBox');
  const pseudocode = document.getElementById('pseudocode');
  const nodeCountDisplay = document.getElementById('nodeCountDisplay');

  const hint = document.getElementById('hint');

  // State
  let W=40;
  let N=8;
  let density=0.45;
  let nodes=[], edges=[], adj=[];
  let edgeIdCounter=0;

  // Prim state
  let startNode = null;
  let visited = [];
  let visitedCount = 0;
  let pq = []; // array of edge ids (in PQ)
  let stepsTaken = 0;
  let mstEdgeIds = new Set();
  let totalMstWeight = 0;
  let lastPoppedEdge = null; // edge id currently popped and under consideration
  let intervalHandle = null;
  let running=false;
  let finished=false;

  function resizeCanvas(){
    const r = wrap.getBoundingClientRect();
    canvas.width = Math.floor(r.width - 24);
    canvas.height = Math.floor(r.height - 24);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // Utility
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function ensureConnectedGraph(){
    // Guarantee connected graph by creating a random spanning tree first
    // then add extra edges according to density
    edges = [];
    edgeIdCounter = 0;
    adj = Array.from({length:N}, ()=>[]);
    // create nodes positions on circle
    nodes = [];
    const cx = canvas.width/2;
    const cy = canvas.height/2;
    const radius = Math.min(canvas.width, canvas.height) * 0.38;
    for(let i=0;i<N;i++){
      const angle = (i/N) * Math.PI*2 - Math.PI/2;
      const jitter = 0.6 + Math.random()*0.8;
      const x = cx + Math.cos(angle)*radius*jitter;
      const y = cy + Math.sin(angle)*radius*jitter;
      nodes.push({id:i,x,y});
    }

    // Build random spanning tree
    const perm = shuffle(Array.from({length:N}, (_,i)=>i));
    for(let i=1;i<N;i++){
      const u = perm[i];
      const v = perm[randInt(0,i-1)];
      addEdge(u,v,randInt(1,W));
    }
    // Add random extra edges according to density
    for(let u=0;u<N;u++){
      for(let v=u+1;v<N;v++){
        if(edgeExists(u,v)) continue;
        if(Math.random() < density) addEdge(u,v,randInt(1,W));
      }
    }
    // Ensure all nodes have at least degree 1 (should be true due to spanning tree)
  }

  function edgeExists(u,v){
    return adj[u].some(eid => {
      const e = edges[eid];
      return (e.u===u && e.v===v) || (e.u===v && e.v===u);
    });
  }

  function addEdge(u,v,w){
    const eid = edgeIdCounter++;
    const edge = {id:eid,u,v,w,inPQ:false,removed:false,inMST:false,considered:false};
    edges.push(edge);
    adj[u].push(eid);
    adj[v].push(eid);
  }

  function regenGraph(){
    N = parseInt(nodesRange.value);
    nodeCountDisplay.textContent = N;
    W = parseInt(maxW.value);
    density = parseInt(densityRange.value)/100;
    nodesVal.textContent = N;
    densityVal.textContent = (density*100|0)+'%';
    maxWVal.textContent = W;
    ensureConnectedGraph();
    resetAlgorithmState(true);
    resizeCanvas();
    draw();
  }

  function resetAlgorithmState(hard=false){
    // resets algorithm state but preserves graph unless hard true
    startNode = null;
    startLabel.textContent = 'None';
    visited = Array.from({length:N}, ()=>false);
    visitedCount = 0;
    pq = [];
    stepsTaken = 0;
    mstEdgeIds = new Set();
    totalMstWeight = 0;
    lastPoppedEdge = null;
    running = false;
    finished = false;
    clearInterval(intervalHandle);
    intervalHandle = null;
    runBtn.textContent = 'Auto Run';
    // reset edge properties
    for(const e of edges){
      e.inPQ = false;
      e.removed = false;
      e.inMST = false;
      e.considered = false;
    }
    updateStats();
    logBox.innerHTML = '<div class="small-muted">Algorithm reset. Choose a start node or press Random Start.</div>';
    highlightPseudo(null);
    draw();
  }

  function startWith(nodeIndex){
    resetAlgorithmState(false);
    startNode = nodeIndex;
    startLabel.textContent = 'V' + nodeIndex;
    // Initialize as first step but don't push edges yet until step pressed - to highlight initialization separately
    // We'll treat the first Step as initialization: mark visited[start] = true and push edges
    log(`Start node set to V${nodeIndex}. Press Step to initialize.`);
    draw();
  }

  function initializePrim(){
    if(startNode === null) {
      log('Choose a start node first.');
      return false;
    }
    if(visited[startNode]) return false;
    visited[startNode] = true;
    visitedCount = 1;
    // push incident edges
    for(const eid of adj[startNode]){
      const e = edges[eid];
      if(!e.removed && !e.inPQ){
        e.inPQ = true;
        pq.push(eid);
      }
    }
    sortPQ();
    highlightPseudo(1);
    log(`Initialized at V${startNode}. Inserted ${adj[startNode].length} incident edges into PQ.`);
    updateStats();
    draw();
    return true;
  }

  function sortPQ(){
    pq.sort((a,b)=> edges[a].w - edges[b].w || (edges[a].id - edges[b].id));
  }

  function popPQ(){
    if(pq.length===0) return null;
    sortPQ();
    const eid = pq.shift();
    edges[eid].inPQ = false;
    return eid;
  }

  function step(){
    if(finished){
      log('Algorithm finished.');
      return;
    }
    // If not initialized (start node not visited), initialize
    if(startNode === null){
      log('Choose a start node (click a node) or pick Random Start.');
      return;
    }
    if(!visited[startNode]){
      // initialization step
      initializePrim();
      stepsTaken++;
      highlightPseudo(2);
      updateStats();
      return;
    }

    // If lastPoppedEdge is null => need to pop one
    if(lastPoppedEdge === null){
      if(pq.length === 0){
        finished = true;
        highlightPseudo(7); // done
        log('PQ empty. Algorithm complete.');
        updateStats();
        draw();
        return;
      }
      // Pop one
      const eid = popPQ();
      if(eid===null){
        finished=true;
        log('PQ empty. Algorithm complete.');
        highlightPseudo(7);
        updateStats();
        draw();
        return;
      }
      lastPoppedEdge = eid;
      edges[eid].considered = true;
      stepsTaken++;
      highlightPseudo(3);
      log(`Consider edge e${eid} (V${edges[eid].u} - V${edges[eid].v}, w=${edges[eid].w})`);
      updateStats();
      draw();
      return;
    } else {
      // We have an edge under consideration -> decide accept/discard
      const eid = lastPoppedEdge;
      const e = edges[eid];
      const u = e.u, v = e.v;
      const uVis = visited[u], vVis = visited[v];

      if(uVis && vVis){
        // discard
        e.removed = true;
        e.considered = false;
        lastPoppedEdge = null;
        stepsTaken++;
        highlightPseudo(6);
        log(`Discarded e${eid} — both endpoints already visited.`);
        updateStats();
        draw();
        // continue later
        return;
      } else {
        // Accept edge into MST
        e.inMST = true;
        e.removed = true;
        e.considered = false;
        mstEdgeIds.add(eid);
        totalMstWeight += e.w;
        // find new vertex
        let newV = uVis ? v : u;
        visited[newV] = true;
        visitedCount++;
        // push incident edges of newV
        let pushed=0;
        for(const ne of adj[newV]){
          const edgeN = edges[ne];
          if(!edgeN.removed && !edgeN.inPQ && !edgeN.inMST){
            // Only push edges that connect to unvisited vertices maybe; but PQ often holds edges incident to visited nodes that reach unvisited nodes.
            // However pushing all ensures availability; we still check validity at pop.
            edgeN.inPQ = true;
            pq.push(ne);
            pushed++;
          }
        }
        sortPQ();
        lastPoppedEdge = null;
        stepsTaken++;
        highlightPseudo(4);
        log(`Accepted e${eid} into MST. New vertex: V${newV}. Inserted ${pushed} incident edges.`);
        updateStats();
        draw();
        if(visitedCount === N){
          finished = true;
          highlightPseudo(7);
          log('All vertices visited. MST complete.');
          draw();
        }
        return;
      }
    }
  }

  function startAutoRun(){
    if(finished){ log('Already finished. Reset to run again.'); return; }
    if(startNode === null){ log('Choose a start node first.'); return; }
    if(running){
      // stop
      clearInterval(intervalHandle);
      running=false;
      runBtn.textContent = 'Auto Run';
      return;
    }
    running=true;
    runBtn.textContent = 'Pause';
    const delay = parseInt(speedRange.value);
    intervalHandle = setInterval(()=>{
      if(!running) return;
      step();
      if(finished){
        clearInterval(intervalHandle);
        running=false;
        runBtn.textContent = 'Auto Run';
      }
    }, delay);
  }

  function resetAlgorithm(){
    resetAlgorithmState(false);
  }

  function log(msg){
    const el = document.createElement('div');
    el.textContent = `${stepsTaken>0?('['+stepsTaken+'] '):''}${msg}`;
    logBox.prepend(el);
  }

  function updateStats(){
    pqSize.textContent = pq.length;
    mstWeightEl.textContent = totalMstWeight;
    visitedCountEl.textContent = visitedCount;
    mstCountEl.textContent = mstEdgeIds.size;
    stepsTakenEl.textContent = stepsTaken;
  }

  function highlightPseudo(lineIndex){
    const lines = pseudocode.querySelectorAll('[data-line]');
    lines.forEach(div => div.classList.remove('highlight'));
    if(lineIndex === null) return;
    const el = pseudocode.querySelector('[data-line="'+lineIndex+'"]');
    if(el) el.classList.add('highlight');
  }

  // Drawing functions
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // edges
    for(const e of edges){
      drawEdge(e);
    }
    // nodes
    for(const n of nodes){
      drawNode(n);
    }
  }

  function drawEdge(e){
    const u = nodes[e.u], v = nodes[e.v];
    const x1 = u.x, y1 = u.y, x2 = v.x, y2 = v.y;
    // color logic
    let color = 'rgba(200,200,200,0.15)';
    let width = 2;
    if(e.inMST) { color = 'linear'; }
    if(e.considered) { color = '#ef4444'; width = 4; }
    else if(e.inMST) { color = '#3b82f6'; width = 4; }
    else if(e.inPQ) { color = '#fb923c'; width = 3; }
    else if(e.removed) { color = 'rgba(255,255,255,0.06)'; width = 2; }

    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.lineWidth = width;
    if(e.inMST){
      // gradient for MST
      const g = ctx.createLinearGradient(x1,y1,x2,y2);
      g.addColorStop(0, '#60a5fa');
      g.addColorStop(1, '#1e3a8a');
      ctx.strokeStyle = g;
    } else {
      ctx.strokeStyle = color;
    }
    ctx.stroke();

    // weight label at midpoint with small background
    const mx = (x1+x2)/2;
    const my = (y1+y2)/2;
    ctx.font = "12px ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto";
    const txt = String(e.w);
    const metrics = ctx.measureText(txt);
    const w = metrics.width + 12;
    const h = 18;
    // draw small rounded rect
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(ctx, mx - w/2, my - h/2, w, h, 6, true, false);
    // weight text
    ctx.fillStyle = '#eaf2ff';
    ctx.fillText(txt, mx - metrics.width/2, my + 4);
    // If considered, add label
    if(e.considered){
      ctx.beginPath();
      ctx.fillStyle = 'rgba(239,68,68,0.14)';
      roundRect(ctx, mx - w/2 - 2, my - h/2 - 2, w+4, h+4, 8, true, false);
    }
  }

  function drawNode(n){
    const r = 18;
    const isStart = (startNode === n.id);
    const vis = visited[n.id];
    // node circle
    ctx.beginPath();
    ctx.arc(n.x,n.y,r,0,Math.PI*2);
    if(isStart && !vis){
      ctx.fillStyle = 'rgba(99,102,241,0.14)';
      ctx.strokeStyle = '#6366f1';
    } else if(vis){
      ctx.fillStyle = 'rgba(16,185,129,0.12)';
      ctx.strokeStyle = '#10b981';
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    }
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();

    // label circle inside
    ctx.beginPath();
    ctx.arc(n.x,n.y,8,0,Math.PI*2);
    if(vis) ctx.fillStyle = '#10b981';
    else if(isStart) ctx.fillStyle = '#6366f1';
    else ctx.fillStyle = '#1e293b';
    ctx.fill();

    // node id text
    ctx.fillStyle = '#e6eef8';
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('V'+n.id, n.x, n.y);

    // hoverable region is same - we detect clicks separately using distance
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Canvas interaction: click to choose start
  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    // find node clicked (within radius)
    for(const n of nodes){
      const dx = x - n.x, dy = y - n.y;
      if(Math.sqrt(dx*dx+dy*dy) < 22){
        startWith(n.id);
        draw();
        return;
      }
    }
  });

  // UI events
  nodesRange.addEventListener('input', ()=>{
    nodesVal.textContent = nodesRange.value;
    nodeCountDisplay.textContent = nodesRange.value;
  });
  nodesRange.addEventListener('change', regenGraph);
  densityRange.addEventListener('input', ()=>{
    densityVal.textContent = densityRange.value + '%';
  });
  densityRange.addEventListener('change', regenGraph);
  maxW.addEventListener('input', ()=>{ maxWVal.textContent = maxW.value; });
  maxW.addEventListener('change', regenGraph);

  regenBtn.addEventListener('click', regenGraph);
  randomStartBtn.addEventListener('click', ()=>{
    if(nodes.length===0) return;
    const r = randInt(0, N-1);
    startWith(r);
  });

  stepBtn.addEventListener('click', ()=>{
    if(running){
      clearInterval(intervalHandle);
      running=false;
      runBtn.textContent='Auto Run';
    }
    step();
  });

  runBtn.addEventListener('click', ()=>{
    startAutoRun();
  });

  resetAlgBtn.addEventListener('click', ()=>{
    resetAlgorithm();
  });

  speedRange.addEventListener('input', ()=>{
    speedVal.textContent = speedRange.value + 'ms';
  });

  // PQ box rendering
  function renderPQ(){
    pqBox.innerHTML = '';
    // show entries with weight and endpoints
    // We'll show edges in pq sorted
    const pqSorted = pq.slice().sort((a,b)=>edges[a].w - edges[b].w);
    for(const eid of pqSorted){
      const e = edges[eid];
      const div = document.createElement('div');
      div.className = 'pq-item';
      const left = document.createElement('div');
      left.textContent = `e${eid}: V${e.u} - V${e.v}`;
      left.style.color = 'var(--muted)';
      const right = document.createElement('div');
      right.className = 'pq-weight';
      right.textContent = e.w;
      div.appendChild(left);
      div.appendChild(right);
      pqBox.appendChild(div);
    }
    pqSize.textContent = pqSorted.length;
  }

  // Periodic draw update to show PQ & stats
  function tick(){
    renderPQ();
    updateStats();
    draw();
    requestAnimationFrame(tick);
  }

  // Initial setup
  nodesRange.value = N;
  nodesVal.textContent = N;
  densityRange.value = 45;
  densityVal.textContent = '45%';
  maxW.value = W;
  maxWVal.textContent = W;
  speedVal.textContent = speedRange.value + 'ms';
  nodeCountDisplay.textContent = N;

  // Kick off
  window.addEventListener('load', ()=>{
    regenGraph();
    resizeCanvas();
    requestAnimationFrame(tick);
  });

  // Expose some for debugging
  window._primDemo = {
    step, startAutoRun, regenGraph, resetAlgorithm
  };

})();
</script>
</body>
</html>