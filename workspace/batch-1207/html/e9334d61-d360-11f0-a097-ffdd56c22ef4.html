<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adjacency List — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1720;
      --panel:#0b1320;
      --accent:#7dd3fc;
      --muted:#94a3b8;
      --card:#0b1220;
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background:linear-gradient(180deg,#071023 0%, #06111a 100%);
      color:#e6eef8;
    }
    .container{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:18px;
      padding:18px;
      height:100%;
      box-sizing:border-box;
    }
    .panel{
      background:linear-gradient(180deg,#061226 0%, #071429 100%);
      border-radius:10px;
      padding:14px;
      box-shadow: 0 8px 30px rgba(6,11,18,0.6);
      overflow:auto;
      max-height:calc(100vh - 36px);
    }
    h1{
      margin:6px 0 12px 0;
      font-size:18px;
      color:var(--accent);
    }
    label{font-size:13px;color:var(--muted);display:block;margin-top:10px}
    input[type="text"], select, input[type="number"]{
      width:100%;
      padding:8px 10px;
      margin-top:6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color: #e6eef8;
      box-sizing:border-box;
    }
    button{
      background:linear-gradient(180deg,#0ea5a9 0%,#047481 100%);
      border:0;
      color:#022028;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      margin-top:8px;
      font-weight:600;
    }
    .mutebtn{
      background:linear-gradient(180deg,#334155,#0f1724);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
    }
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;padding:6px 8px;border-radius:6px}
    .graphPanel{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
    }
    .canvasWrap{
      background:linear-gradient(180deg,#031126,#031426);
      border-radius:10px;
      flex:1;
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.03);
    }
    svg{width:100%;height:100%;display:block}
    .adjList{
      background:linear-gradient(180deg,#071426,#06101b);
      border-radius:10px;
      padding:10px;
      margin-top:10px;
      max-height:220px;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.03);
    }
    .item{
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
      padding:6px 6px;
      border-radius:6px;
      transition:background .12s;
    }
    .item:hover{background:rgba(255,255,255,0.02)}
    .nodeBadge{
      background:linear-gradient(90deg,#083049,#055a6b);
      padding:6px 8px;
      border-radius:6px;
      font-weight:700;
      color:var(--accent);
      min-width:36px;
      text-align:center;
    }
    .edgeList{font-size:13px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
    .chip{
      background:rgba(255,255,255,0.03);
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      cursor:pointer;
    }
    .chip:hover{background:rgba(255,255,255,0.06)}
    .controlsGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .footerNote{font-size:12px;color:var(--muted);margin-top:8px}
    .topRow{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px}
    .dot{width:12px;height:12px;border-radius:50%}
    .directed{background:#f97316}
    .undirected{background:#7dd3fc}
    .highlight{outline:3px solid rgba(125,211,252,0.14);box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    .smallbtn{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);cursor:pointer}
    .selectWrap{display:flex;gap:8px}
    .help{font-size:13px;color:var(--muted);margin-top:6px}
    a.link{color:var(--accent);text-decoration:none}
  </style>
</head>
<body>
  <div class="container">
    <div class="panel" id="controls">
      <h1>Adjacency List — Interactive</h1>
      <div class="topRow">
        <div style="font-size:14px;color:#cfeeff">Graph Editor</div>
        <div class="legend">
          <span class="dot undirected" title="Undirected"></span><span style="color:var(--muted)">Undirected</span>
          <span class="dot directed" style="margin-left:6px" title="Directed"></span><span style="color:var(--muted)">Directed</span>
        </div>
      </div>

      <label>Mode</label>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="modeAddNode" class="smallbtn">Add Node</button>
        <button id="modeAddEdge" class="smallbtn">Add Edge</button>
        <button id="modeSelect" class="smallbtn">Select / Drag</button>
      </div>

      <label style="margin-top:12px">Add node (label)</label>
      <div class="row">
        <input id="nodeLabel" type="text" placeholder="e.g. A, 1, NodeX" />
        <button id="addNodeBtn">Add</button>
      </div>

      <label style="margin-top:12px">Add edge</label>
      <div class="controlsGrid">
        <select id="fromSelect"></select>
        <select id="toSelect"></select>
      </div>
      <div class="row" style="margin-top:8px">
        <input id="weight" type="number" placeholder="weight (optional)" />
        <select id="edgeType">
          <option value="undirected">Undirected</option>
          <option value="directed">Directed</option>
        </select>
      </div>
      <div class="row">
        <button id="addEdgeBtn">Add Edge</button>
        <button id="removeEdgeBtn" class="mutebtn">Remove Selected</button>
      </div>

      <label style="margin-top:12px">Actions</label>
      <div class="row">
        <button id="randomizeBtn" class="mutebtn">Randomize Layout</button>
        <button id="clearBtn" class="mutebtn">Clear Graph</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="sample1" class="smallbtn">Sample: Triangle</button>
        <button id="sample2" class="smallbtn">Sample: Directed Chain</button>
        <button id="sample3" class="smallbtn">Sample: Weighted</button>
      </div>

      <label style="margin-top:12px">Import / Export</label>
      <div class="row">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn" class="mutebtn">Import JSON</button>
      </div>
      <textarea id="ioArea" style="width:100%;height:84px;margin-top:8px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:#e6eef8"></textarea>

      <div class="help">
        Tip: Switch to "Add Edge" then click two nodes in the canvas to create edges quickly. Click a node to highlight its adjacency list. Export to share or import JSON to load a graph.
      </div>
      <div class="footerNote">Representation used: adjacency list — for each node we store its neighbors (and weights). This demo updates both the internal structure and visualization in real time.</div>
    </div>

    <div class="graphPanel">
      <div class="panel" style="padding:10px;">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700;color:var(--accent)">Graph Visualization</div>
          <div style="display:flex;gap:8px">
            <div id="info" style="color:var(--muted)">Nodes: 0 — Edges: 0</div>
            <button id="helpClear" class="smallbtn mutebtn">Reset View</button>
          </div>
        </div>
        <div style="margin-top:8px;color:var(--muted);font-size:13px">Click nodes to inspect. Drag nodes to reposition. Use modes to add nodes/edges.</div>
      </div>

      <div class="canvasWrap panel" id="canvasWrap">
        <svg id="svgCanvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid slice">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,5 L0,10 z" fill="#f97316" />
            </marker>
            <marker id="arrowBlue" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,5 L0,10 z" fill="#7dd3fc" />
            </marker>
          </defs>
          <g id="edges"></g>
          <g id="nodes"></g>
          <g id="labels"></g>
        </svg>
      </div>

      <div class="adjList panel" id="adjList">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700;color:var(--accent)">Adjacency List</div>
          <div style="color:var(--muted);font-size:13px" id="adjCount">0 entries</div>
        </div>
        <div id="listContent" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

<script>
/*
  Interactive adjacency list demo
  - Graph stored as adjacency list: Map of node -> array of {to, weight, directed, id}
  - Visualization: SVG with draggable nodes, lines for edges, arrowheads for directed.
  - UI: Add/remove nodes and edges, import/export JSON, sample graphs, highlight neighbors.
*/

// Utilities
function uid(prefix='id'){ return prefix + Math.random().toString(36).substr(2,9); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// Graph data structure
class Graph {
  constructor(){
    // nodes: Map label -> {id,label,x,y,fx?,fy?}
    this.nodes = new Map();
    // adj: Map label -> Array of edges {id,to,weight,directed}
    this.adj = new Map();
  }
  addNode(label,opts={}){
    if(!label) return null;
    if(this.nodes.has(label)) return this.nodes.get(label);
    const node = {
      id: uid('n_'),
      label: String(label),
      x: opts.x ?? (Math.random()*900 + 150),
      y: opts.y ?? (Math.random()*400 + 150),
      vx: 0, vy: 0
    };
    this.nodes.set(node.label, node);
    this.adj.set(node.label, []);
    return node;
  }
  removeNode(label){
    if(!this.nodes.has(label)) return;
    this.nodes.delete(label);
    this.adj.delete(label);
    // remove edges pointing to label
    for(const [u,edges] of this.adj.entries()){
      this.adj.set(u, edges.filter(e => e.to !== label));
    }
  }
  addEdge(from,to,opts={}){
    if(!this.nodes.has(from) || !this.nodes.has(to)) return null;
    const directed = !!opts.directed;
    const weight = (opts.weight==null || opts.weight== '') ? null : Number(opts.weight);
    const id = uid('e_');
    const e = {id, to, weight, directed};
    this.adj.get(from).push(e);
    if(!directed){
      // store reverse as well; indicate undirected by having directed=false
      const e2 = {id: uid('e_'), to: from, weight, directed:false, mirrorOf:id};
      this.adj.get(to).push(e2);
    }
    return e;
  }
  removeEdgeById(edgeId){
    for(const [u,edges] of this.adj.entries()){
      const newEdges = edges.filter(e => e.id !== edgeId && e.mirrorOf !== edgeId);
      this.adj.set(u,newEdges);
    }
  }
  getEdgeCount(){
    let c = 0;
    for(const edges of this.adj.values()){
      c += edges.length;
    }
    // if undirected edges are stored twice, we can approximate by halving identical mirror entries.
    // but since we store undirected as two separate entries, we consider each logical undirected edge as 1.
    // We'll count directed edges as-is and try to deduplicate undirected by checking mirrorOf relationships.
    // Simpler: count unique ids (for directed edges id present once, undirected have two different ids for the two entries).
    // We stored original id for one side; we can approximate by counting edges and dividing by 2 when both directions exist.
    // For UI we display number of entries in adjacency list and also approximate unique edges:
    return c;
  }
  toJSON(){
    const nodes = [];
    for(const n of this.nodes.values()){
      nodes.push({label:n.label,x:n.x,y:n.y});
    }
    const edges = [];
    // We'll export edges by iterating adj and exporting only edges where "directed" true OR where a matching reverse exists and include once.
    const seenPairs = new Set();
    for(const [u,edgesArr] of this.adj.entries()){
      for(const e of edgesArr){
        const a = u, b = e.to;
        const key = e.directed ? (e.id) : [a,b].sort().join('|');
        if(seenPairs.has(key)) continue;
        seenPairs.add(key);
        edges.push({from:a,to:b,weight:e.weight,directed:!!e.directed});
      }
    }
    return {nodes,edges};
  }
  fromJSON(obj){
    this.nodes.clear(); this.adj.clear();
    if(!obj) return;
    (obj.nodes||[]).forEach(n=>this.addNode(n.label,{x:n.x,y:n.y}));
    (obj.edges||[]).forEach(e=>{
      this.addEdge(e.from,e.to,{weight:e.weight,directed:!!e.directed});
    });
  }
}

// Instantiate
const graph = new Graph();

// UI elements
const svg = document.getElementById('svgCanvas');
const nodesGroup = document.getElementById('nodes');
const edgesGroup = document.getElementById('edges');
const labelsGroup = document.getElementById('labels');

const fromSelect = document.getElementById('fromSelect');
const toSelect = document.getElementById('toSelect');
const nodeLabelInput = document.getElementById('nodeLabel');
const addNodeBtn = document.getElementById('addNodeBtn');
const addEdgeBtn = document.getElementById('addEdgeBtn');
const removeEdgeBtn = document.getElementById('removeEdgeBtn');
const weightInput = document.getElementById('weight');
const edgeTypeSel = document.getElementById('edgeType');
const listContent = document.getElementById('listContent');
const adjCount = document.getElementById('adjCount');
const info = document.getElementById('info');
const modeAddNode = document.getElementById('modeAddNode');
const modeAddEdge = document.getElementById('modeAddEdge');
const modeSelect = document.getElementById('modeSelect');
const randomizeBtn = document.getElementById('randomizeBtn');
const clearBtn = document.getElementById('clearBtn');
const sample1 = document.getElementById('sample1');
const sample2 = document.getElementById('sample2');
const sample3 = document.getElementById('sample3');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const ioArea = document.getElementById('ioArea');

// Modes and selection
let mode = 'select'; // select, addNode, addEdge
let selectedNode = null;
let pendingEdgeFrom = null;
let selectedEdgeId = null;

// Dragging
let dragging = null;
let dragOffset = {x:0,y:0};

function setMode(m){
  mode = m;
  [modeAddNode, modeAddEdge, modeSelect].forEach(btn => btn.classList.remove('highlight'));
  if(m==='addNode') modeAddNode.classList.add('highlight');
  if(m==='addEdge') modeAddEdge.classList.add('highlight');
  if(m==='select') modeSelect.classList.add('highlight');
  pendingEdgeFrom = null;
  updateCursor();
}
function updateCursor(){
  const wrap = document.getElementById('canvasWrap');
  wrap.style.cursor = mode === 'select' ? 'default' : (mode === 'addNode' ? 'crosshair' : 'pointer');
}

modeAddNode.addEventListener('click', ()=>setMode('addNode'));
modeAddEdge.addEventListener('click', ()=>setMode('addEdge'));
modeSelect.addEventListener('click', ()=>setMode('select'));

addNodeBtn.addEventListener('click', ()=>{
  const label = nodeLabelInput.value.trim() || null;
  const newNode = graph.addNode(label ?? uid('v'));
  if(newNode) {
    nodeLabelInput.value = '';
    render();
  }
});
addEdgeBtn.addEventListener('click', ()=>{
  const from = fromSelect.value;
  const to = toSelect.value;
  if(!from || !to) return;
  const directed = edgeTypeSel.value === 'directed';
  const weight = weightInput.value;
  graph.addEdge(from,to,{directed,weight});
  render();
});
removeEdgeBtn.addEventListener('click', ()=>{
  if(selectedEdgeId){
    graph.removeEdgeById(selectedEdgeId);
    selectedEdgeId = null;
    render();
  }
});

randomizeBtn.addEventListener('click', ()=>{
  for(const n of graph.nodes.values()){
    n.x = Math.random()*1000 + 100;
    n.y = Math.random()*500 + 50;
  }
  render();
});
clearBtn.addEventListener('click', ()=>{
  graph.nodes.clear(); graph.adj.clear();
  selectedNode = null; selectedEdgeId = null;
  render();
});

sample1.addEventListener('click', ()=>{
  graph.nodes.clear(); graph.adj.clear();
  graph.addNode('A',{x:200,y:240});
  graph.addNode('B',{x:500,y:120});
  graph.addNode('C',{x:780,y:320});
  graph.addEdge('A','B',{directed:false});
  graph.addEdge('B','C',{directed:false});
  graph.addEdge('C','A',{directed:false});
  render();
});
sample2.addEventListener('click', ()=>{
  graph.nodes.clear(); graph.adj.clear();
  graph.addNode('1',{x:180,y:300});
  graph.addNode('2',{x:360,y:300});
  graph.addNode('3',{x:540,y:300});
  graph.addNode('4',{x:720,y:300});
  graph.addEdge('1','2',{directed:true});
  graph.addEdge('2','3',{directed:true});
  graph.addEdge('3','4',{directed:true});
  render();
});
sample3.addEventListener('click', ()=>{
  graph.nodes.clear(); graph.adj.clear();
  graph.addNode('X',{x:200,y:200});
  graph.addNode('Y',{x:500,y:240});
  graph.addNode('Z',{x:820,y:200});
  graph.addEdge('X','Y',{weight:5,directed:false});
  graph.addEdge('Y','Z',{weight:2,directed:true});
  render();
});

exportBtn.addEventListener('click', ()=>{
  ioArea.value = JSON.stringify(graph.toJSON(),null,2);
});
importBtn.addEventListener('click', ()=>{
  try{
    const obj = JSON.parse(ioArea.value);
    graph.fromJSON(obj);
    render();
  }catch(e){
    alert('Invalid JSON');
  }
});

document.getElementById('helpClear').addEventListener('click', ()=>{
  // reset view: randomize positions in center
  for(const n of graph.nodes.values()){
    n.x += (Math.random()-0.5)*200;
    n.y += (Math.random()-0.5)*200;
  }
  render();
});

// SVG Interaction
svg.addEventListener('click', (ev)=>{
  const pt = screenToSvg(ev.clientX, ev.clientY);
  if(mode === 'addNode'){
    const label = nodeLabelInput.value.trim() || uid('v');
    graph.addNode(label,{x:pt.x,y:pt.y});
    nodeLabelInput.value = '';
    render();
  }else if(mode === 'addEdge'){
    // clicking on blank area resets pending
    pendingEdgeFrom = null;
    updateStatus(`Click nodes to create an edge`);
  }
});

function screenToSvg(cx,cy){
  const rect = svg.getBoundingClientRect();
  const vb = svg.viewBox.baseVal;
  const scaleX = vb.width / rect.width;
  const scaleY = vb.height / rect.height;
  return {x: (cx - rect.left) * scaleX + vb.x, y: (cy - rect.top) * scaleY + vb.y};
}

function updateSelectOptions(){
  const vals = Array.from(graph.nodes.keys());
  fromSelect.innerHTML = vals.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
  toSelect.innerHTML = fromSelect.innerHTML;
}

function escapeHtml(s){
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;');
}

function updateInfo(){
  const nodeCount = graph.nodes.size;
  // We approximate unique edges for display by exporting JSON edges length
  const uniqueEdges = graph.toJSON().edges.length;
  info.textContent = `Nodes: ${nodeCount} — Edges: ${uniqueEdges}`;
  adjCount.textContent = `${graph.nodes.size} entries`;
}

function render(){
  // Clear groups
  edgesGroup.innerHTML = '';
  nodesGroup.innerHTML = '';
  labelsGroup.innerHTML = '';

  updateSelectOptions();
  updateInfo();

  // Draw edges
  const edges = [];
  for(const [u,arr] of graph.adj.entries()){
    for(const e of arr){
      // For undirected edges we stored two entries; only render one visual line in that case:
      // We'll render edges when either directed OR when u <= e.to to avoid duplicates
      if(!e.directed && u > e.to) continue;
      edges.push({from:u,to:e.to,weight:e.weight,directed:e.directed,id:e.id});
    }
  }
  edges.forEach(ed=>{
    const a = graph.nodes.get(ed.from);
    const b = graph.nodes.get(ed.to);
    if(!a || !b) return;
    // line
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x);
    line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x);
    line.setAttribute('y2',b.y);
    line.setAttribute('stroke', ed.directed ? '#f97316' : '#7dd3fc');
    line.setAttribute('stroke-width','2.5');
    if(ed.directed){
      line.setAttribute('marker-end','url(#arrow)');
    }else{
      line.setAttribute('marker-end','url(#arrowBlue)');
    }
    line.dataset.edgeId = ed.id;
    line.style.opacity = 0.85;
    line.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      selectEdge(ed.id);
    });
    edgesGroup.appendChild(line);

    // weight label
    if(ed.weight != null){
      const midx = (a.x + b.x)/2, midy = (a.y + b.y)/2;
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x',midx);
      text.setAttribute('y',midy - 8);
      text.setAttribute('fill','#cbd5e1');
      text.setAttribute('font-size','12');
      text.setAttribute('text-anchor','middle');
      text.textContent = String(ed.weight);
      labelsGroup.appendChild(text);
    }
  });

  // Draw nodes
  for(const n of graph.nodes.values()){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform',`translate(${n.x},${n.y})`);
    g.style.cursor = 'grab';
    g.dataset.label = n.label;

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r',22);
    circle.setAttribute('fill','url(#grad)'); // not defined; fallback to style
    circle.setAttribute('stroke','#0ea5a9');
    circle.setAttribute('stroke-width','1.6');
    circle.style.fill = 'rgba(255,255,255,0.03)';
    circle.style.filter = 'drop-shadow(0 6px 16px rgba(2,6,23,0.6))';
    g.appendChild(circle);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x',0);
    text.setAttribute('y',6);
    text.setAttribute('fill','#bfeffd');
    text.setAttribute('font-size','12');
    text.setAttribute('font-weight','700');
    text.setAttribute('text-anchor','middle');
    text.textContent = n.label;
    g.appendChild(text);

    // Attach listeners
    g.addEventListener('mousedown', (ev)=>{
      ev.stopPropagation();
      if(mode === 'addEdge'){
        if(!pendingEdgeFrom){
          pendingEdgeFrom = n.label;
          updateStatus(`Selected source "${n.label}". Now click target node.`);
        }else{
          const from = pendingEdgeFrom;
          const to = n.label;
          const directed = edgeTypeSel.value === 'directed';
          const weight = weightInput.value;
          graph.addEdge(from,to,{directed,weight});
          pendingEdgeFrom = null;
          render();
        }
        return;
      }
      if(mode === 'addNode'){
        // create node at click
        const p = screenToSvg(ev.clientX,ev.clientY);
        const label = nodeLabelInput.value.trim() || uid('v');
        graph.addNode(label,{x:p.x,y:p.y});
        render();
        return;
      }
      // start dragging / select node
      setSelectedNode(n.label);
      dragging = n;
      const pt = screenToSvg(ev.clientX,ev.clientY);
      dragOffset.x = n.x - pt.x;
      dragOffset.y = n.y - pt.y;
    });

    g.addEventListener('mouseover', ()=>{
      if(selectedNode === n.label) return;
      circle.setAttribute('stroke','#38bdf8');
      circle.setAttribute('stroke-width','2.6');
    });
    g.addEventListener('mouseout', ()=>{
      if(selectedNode === n.label) return;
      circle.setAttribute('stroke','#0ea5a9');
      circle.setAttribute('stroke-width','1.6');
    });

    nodesGroup.appendChild(g);
  }

  // attach global listeners for drag end
  window.onmousemove = function(ev){
    if(!dragging) return;
    const pt = screenToSvg(ev.clientX,ev.clientY);
    dragging.x = pt.x + dragOffset.x;
    dragging.y = pt.y + dragOffset.y;
    render(); // simple approach: re-render each movement
  };
  window.onmouseup = function(){
    dragging = null;
  };

  // Build adjacency list UI
  listContent.innerHTML = '';
  const sortedNodes = Array.from(graph.nodes.keys()).sort();
  for(const label of sortedNodes){
    const div = document.createElement('div');
    div.className = 'item';
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.gap = '8px';

    const badge = document.createElement('div');
    badge.className = 'nodeBadge';
    badge.textContent = label;
    badge.addEventListener('click', ()=>{ focusOnNode(label); });
    left.appendChild(badge);

    const edgesWrap = document.createElement('div');
    edgesWrap.className = 'edgeList';
    const edges = graph.adj.get(label) || [];
    if(edges.length === 0){
      const empty = document.createElement('div');
      empty.style.color = 'var(--muted)';
      empty.textContent = '(no neighbors)';
      edgesWrap.appendChild(empty);
    }else{
      edges.forEach(e=>{
        // show neighbor chip
        const ch = document.createElement('div');
        ch.className = 'chip';
        ch.textContent = `${e.to}${e.weight!=null ? ` (${e.weight})` : ''}${e.directed ? ' →' : ''}`;
        ch.title = `Click to highlight ${e.to}. Double-click to remove this edge.`;
        ch.addEventListener('click', ()=>{ focusOnNode(e.to); });
        ch.addEventListener('dblclick', ()=>{
          if(confirm(`Remove edge ${label} → ${e.to}?`)){
            graph.removeEdgeById(e.id);
            render();
          }
        });
        edgesWrap.appendChild(ch);
      });
    }

    left.appendChild(edgesWrap);
    div.appendChild(left);

    const right = document.createElement('div');
    const remBtn = document.createElement('button');
    remBtn.className = 'smallbtn mutebtn';
    remBtn.textContent = 'Remove';
    remBtn.addEventListener('click', ()=>{
      if(confirm(`Remove node "${label}" and its edges?`)){
        graph.removeNode(label);
        render();
      }
    });
    right.appendChild(remBtn);
    div.appendChild(right);

    listContent.appendChild(div);
  }

  // highlight selected node/edge
  applyHighlights();
}

// Selection handling
function setSelectedNode(label){
  selectedNode = label;
  selectedEdgeId = null;
  applyHighlights();
  // scroll adjacency pane to entry
  const entries = Array.from(listContent.querySelectorAll('.nodeBadge'));
  for(const b of entries){
    if(b.textContent === label){
      b.scrollIntoView({behavior:'smooth',block:'center'});
      b.classList.add('highlight');
      setTimeout(()=>b.classList.remove('highlight'),800);
      break;
    }
  }
}

function selectEdge(edgeId){
  selectedEdgeId = edgeId;
  selectedNode = null;
  applyHighlights();
}

function applyHighlights(){
  // reset
  for(const c of nodesGroup.querySelectorAll('g')){
    c.style.opacity = 1;
    c.querySelector('circle').setAttribute('stroke','#0ea5a9');
    c.querySelector('circle').setAttribute('stroke-width','1.6');
  }
  for(const l of edgesGroup.querySelectorAll('line')){
    l.style.opacity = 0.85;
    l.setAttribute('stroke-width','2.5');
  }

  if(selectedNode){
    // dim non-neighbors
    const neighbors = new Set([selectedNode]);
    for(const e of graph.adj.get(selectedNode) || []) neighbors.add(e.to);
    for(const g of nodesGroup.querySelectorAll('g')){
      const lab = g.dataset.label;
      if(!neighbors.has(lab)) g.style.opacity = 0.25;
      else {
        g.style.opacity = 1;
        if(lab === selectedNode){
          g.querySelector('circle').setAttribute('stroke','#f97316');
          g.querySelector('circle').setAttribute('stroke-width','2.6');
        }else{
          g.querySelector('circle').setAttribute('stroke','#7dd3fc');
          g.querySelector('circle').setAttribute('stroke-width','2.2');
        }
      }
    }
    // highlight incident edges
    for(const l of edgesGroup.querySelectorAll('line')){
      const id = l.dataset.edgeId;
      // find corresponding edge in exported edges
      // simple heuristic: if either endpoint is selected, highlight
      // We'll parse coordinates to match endpoints
      const x1 = Number(l.getAttribute('x1')), y1 = Number(l.getAttribute('y1'));
      const x2 = Number(l.getAttribute('x2')), y2 = Number(l.getAttribute('y2'));
      const a = findNodeAt(x1,y1), b = findNodeAt(x2,y2);
      if(a === selectedNode || b === selectedNode){
        l.style.opacity = 1;
        l.setAttribute('stroke-width','3.4');
      }else{
        l.style.opacity = 0.12;
      }
    }
  }else if(selectedEdgeId){
    // highlight this edge
    for(const l of edgesGroup.querySelectorAll('line')){
      if(l.dataset.edgeId === selectedEdgeId){
        l.style.opacity = 1;
        l.setAttribute('stroke-width','4');
      }else{
        l.style.opacity = 0.16;
      }
    }
    // dim nodes not part of edge
    let ep = null;
    // locate edge endpoints by id in graph data
    for(const [u,edges] of graph.adj.entries()){
      for(const e of edges){
        if(e.id === selectedEdgeId || e.mirrorOf === selectedEdgeId){
          ep = {from:u,to:e.to};
          break;
        }
      }
      if(ep) break;
    }
    for(const g of nodesGroup.querySelectorAll('g')){
      const lab = g.dataset.label;
      if(ep && (lab === ep.from || lab === ep.to)){
        g.style.opacity = 1;
        g.querySelector('circle').setAttribute('stroke','#f97316');
      }else{
        g.style.opacity = 0.24;
      }
    }
  }else{
    // no selection; full view
    for(const g of nodesGroup.querySelectorAll('g')) g.style.opacity = 1;
    for(const l of edgesGroup.querySelectorAll('line')) l.style.opacity = 0.85;
  }

  updateInfo();
}

function findNodeAt(x,y){
  for(const n of graph.nodes.values()){
    // match by coordinates
    if(Math.abs(n.x - x) < 1e-6 && Math.abs(n.y - y) < 1e-6) return n.label;
  }
  // fallback: find nearest
  let nearest=null; let dist=1e9;
  for(const n of graph.nodes.values()){
    const d = Math.hypot(n.x-x,n.y-y);
    if(d < dist){ dist=d; nearest=n.label; }
  }
  return nearest;
}

function focusOnNode(label){
  setSelectedNode(label);
  // center view by nudging svg viewBox (simple approach: not implemented complex pan; scroll to node element)
  // highlight will show neighbors
}

// small status update
function updateStatus(msg){
  const old = info.textContent;
  info.textContent = msg;
  setTimeout(()=>{ if(info.textContent === msg) updateInfo(); }, 2000);
}

// Initial render
setMode('select');
render();

// Helpful keyboard shortcuts
window.addEventListener('keydown', (ev)=>{
  if(ev.key === 'n') setMode('addNode');
  if(ev.key === 'e') setMode('addEdge');
  if(ev.key === 'Escape') { setMode('select'); pendingEdgeFrom = null; }
});
</script>
</body>
</html>