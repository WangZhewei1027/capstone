<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Tree Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3dd6a0;
      --muted:#93a4bf;
      --danger:#ff6b6b;
      --card:#0b1624;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071427 0%, #071f33 100%);color:#e6f0ff}
    .app{
      display:flex;
      flex-direction:column;
      min-height:100vh;
      padding:18px;
      gap:14px;
      box-sizing:border-box;
    }
    header{
      display:flex;
      align-items:center;
      gap:12px;
    }
    h1{font-size:18px;margin:0}
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      background:var(--panel);
      padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,0.5);
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls .left, .controls .right{display:flex;gap:8px;align-items:center;}
    input[type="number"]{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);outline:none}
    button{
      padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);color:#dff5ea;cursor:pointer;
    }
    button.secondary{background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);color:var(--muted)}
    button.danger{background:linear-gradient(180deg,rgba(255,0,0,0.06),transparent);color:var(--danger)}
    .panel{
      display:flex;gap:12px;
    }
    .leftPanel{
      flex:1;
      min-height:420px;
      background:var(--card);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);
      box-shadow:0 8px 30px rgba(2,6,23,0.6);
    }
    #canvasWrap{width:100%;height:520px;overflow:hidden;border-radius:8px;background:linear-gradient(180deg,rgba(7,26,46,0.2),rgba(6,16,30,0.2));display:flex;align-items:center;justify-content:center}
    svg{width:100%;height:100%}
    .rightPanel{
      width:360px;min-width:260px;
      background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);
    }
    .info{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:8px}
    .info .row{display:flex;justify-content:space-between;gap:8px;align-items:center}
    .log{height:240px;overflow:auto;background:var(--glass);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;color:#cfeee0}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend .item{display:flex;gap:6px;align-items:center;color:var(--muted);font-size:13px}
    .node-svg{transition:transform 160ms ease}
    .small{font-size:13px;color:var(--muted)}
    footer{margin-top:auto;color:var(--muted);font-size:12px;display:flex;justify-content:space-between;align-items:center}
    .controls .speed{display:flex;align-items:center;gap:8px}
    .speed input[type="range"]{width:120px}
    .traversalButtons{display:flex;gap:6px;flex-wrap:wrap}
    @media (max-width:900px){
      .panel{flex-direction:column}
      .rightPanel{width:100%}
      #canvasWrap{height:420px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Binary Search Tree (BST) Visualizer</h1>
      <div style="color:var(--muted);font-size:13px">Insert, delete, search and animate traversals</div>
    </header>

    <div class="controls">
      <div class="left">
        <input id="valueInput" type="number" placeholder="Value (integer)" />
        <button id="insertBtn">Insert</button>
        <button id="deleteBtn" class="danger">Delete</button>
        <button id="searchBtn" class="secondary">Search</button>
        <button id="clearBtn" class="secondary">Clear</button>
        <button id="randomBtn" class="secondary">Randomize</button>
      </div>

      <div class="right" style="margin-left:auto;align-items:center">
        <div class="speed small" title="Animation speed">
          <label style="color:var(--muted);font-size:13px">Speed</label>
          <input id="speedRange" type="range" min="0" max="1000" value="320" />
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="leftPanel">
        <div id="canvasWrap">
          <svg id="svgCanvas" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
      </div>

      <div class="rightPanel">
        <div class="info">
          <div class="row"><div>Nodes</div><div id="nodeCount">0</div></div>
          <div class="row"><div>Height</div><div id="height">0</div></div>
          <div class="row"><div>Min / Max</div><div id="minmax">—</div></div>
          <div class="row"><div>Time complexities</div>
            <div style="text-align:right;font-size:12px;color:var(--muted)">
              Search/Insert/Delete:<br/>
              Avg: O(log n) · Worst: O(n)
            </div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02);margin:10px 0"/>

        <div style="display:flex;flex-direction:column;gap:8px">
          <div class="traversalButtons">
            <button id="inorderBtn" class="secondary">In-order</button>
            <button id="preorderBtn" class="secondary">Pre-order</button>
            <button id="postorderBtn" class="secondary">Post-order</button>
            <button id="levelBtn" class="secondary">Level-order</button>
            <button id="stepTraversal" class="secondary">Step traversal</button>
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <button id="pauseBtn" class="secondary">Pause</button>
            <button id="resumeBtn" class="secondary">Resume</button>
          </div>

          <div class="small" style="color:var(--muted)">Legend</div>
          <div class="legend">
            <div class="item"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#1e90b0"/></svg> Visited</div>
            <div class="item"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#3dd6a0"/></svg> Inserted / Found</div>
            <div class="item"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#ff6b6b"/></svg> Deleted / Removing</div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02);margin:10px 0"/>

        <div class="small" style="color:var(--muted)">Console</div>
        <div id="log" class="log"></div>
      </div>
    </div>

    <footer>
      <div>Tip: Use "Randomize" to insert several nodes quickly. Duplicate values are ignored.</div>
      <div style="opacity:0.8">Built with plain JavaScript • Visualization only</div>
    </footer>
  </div>

<script>
/*
  Binary Search Tree Visualizer
  - Insert/delete/search
  - Traversals with animation
  - SVG rendering
  - Simple layout: root centered, spread halves per level
*/

// Model: BST Node
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    // UI properties
    this.x = 0;
    this.y = 0;
    this.id = Node._id++;
  }
}
Node._id = 1;

// BST class with methods
class BST {
  constructor() {
    this.root = null;
    this.size = 0;
  }

  insert(value) {
    if (this.root === null) {
      this.root = new Node(value);
      this.size++;
      return { inserted: this.root, path: [this.root] };
    }
    let node = this.root;
    const path = [];
    while (node) {
      path.push(node);
      if (value === node.value) return { inserted: null, path };
      if (value < node.value) {
        if (!node.left) {
          node.left = new Node(value);
          this.size++;
          path.push(node.left);
          return { inserted: node.left, path };
        } else node = node.left;
      } else {
        if (!node.right) {
          node.right = new Node(value);
          this.size++;
          path.push(node.right);
          return { inserted: node.right, path };
        } else node = node.right;
      }
    }
  }

  search(value) {
    let node = this.root;
    const path = [];
    while (node) {
      path.push(node);
      if (value === node.value) return { found: node, path };
      node = value < node.value ? node.left : node.right;
    }
    return { found: null, path };
  }

  // helper to find min node and parent from a given node
  _minNodeWithParent(node, parent=null) {
    let p = parent;
    let cur = node;
    while (cur.left) {
      p = cur;
      cur = cur.left;
    }
    return { minNode: cur, parent: p };
  }

  delete(value) {
    // returns {deletedNode, path}
    let node = this.root;
    let parent = null;
    const path = [];
    while (node && node.value !== value) {
      path.push(node);
      parent = node;
      node = value < node.value ? node.left : node.right;
    }
    if (!node) return { deletedNode: null, path };
    path.push(node);

    // Case 1: no children or one child, case 2: two children
    if (!node.left || !node.right) {
      const child = node.left ? node.left : node.right;
      if (!parent) {
        // deleting root
        this.root = child;
      } else if (parent.left === node) {
        parent.left = child;
      } else parent.right = child;
      this.size--;
      return { deletedNode: node, path };
    } else {
      // two children: find inorder successor (min in right subtree)
      const { minNode: succ, parent: succParent } = this._minNodeWithParent(node.right, node);
      // We'll copy successor's value into node, then delete successor node
      const succPath = [];
      // build path from root to successor for animation clarity
      let cur = this.root;
      while (cur && cur !== succ) {
        succPath.push(cur);
        cur = (succ.value < cur.value) ? cur.left : cur.right;
      }
      succPath.push(succ);
      // Replace value
      const oldValue = node.value;
      node.value = succ.value;
      // Now delete successor which has at most one child (right child)
      const succChild = succ.right;
      if (succParent.left === succ) succParent.left = succChild;
      else succParent.right = succChild;
      this.size--;
      // return node as the "deleted" (conceptually we removed succ and moved its value)
      return { deletedNode: succ, path: path.concat(succPath) };
    }
  }

  // Traversals returning arrays
  inorder(node=this.root, arr=[]) {
    if (!node) return arr;
    this.inorder(node.left, arr);
    arr.push(node);
    this.inorder(node.right, arr);
    return arr;
  }
  preorder(node=this.root, arr=[]) {
    if (!node) return arr;
    arr.push(node);
    this.preorder(node.left, arr);
    this.preorder(node.right, arr);
    return arr;
  }
  postorder(node=this.root, arr=[]) {
    if (!node) return arr;
    this.postorder(node.left, arr);
    this.postorder(node.right, arr);
    arr.push(node);
    return arr;
  }
  levelOrder() {
    const arr = [];
    if (!this.root) return arr;
    const q = [this.root];
    while (q.length) {
      const n = q.shift();
      arr.push(n);
      if (n.left) q.push(n.left);
      if (n.right) q.push(n.right);
    }
    return arr;
  }

  height(node=this.root) {
    if (!node) return 0;
    return 1 + Math.max(this.height(node.left), this.height(node.right));
  }

  min(node=this.root) {
    if (!node) return null;
    while (node.left) node=node.left;
    return node.value;
  }
  max(node=this.root) {
    if (!node) return null;
    while (node.right) node=node.right;
    return node.value;
  }
}

// UI & Rendering
const svg = document.getElementById('svgCanvas');
const logEl = document.getElementById('log');
const nodeCountEl = document.getElementById('nodeCount');
const heightEl = document.getElementById('height');
const minmaxEl = document.getElementById('minmax');
const valueInput = document.getElementById('valueInput');
const speedRange = document.getElementById('speedRange');

let tree = new BST();
let running = false;
let paused = false;
let animationDelay = 320; // ms
let pendingTimeouts = [];

// utility logging
function log(...args){
  const time = new Date().toLocaleTimeString();
  const text = args.map(a=> (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logEl.innerHTML = `<div style="margin-bottom:6px">[${time}] ${text}</div>` + logEl.innerHTML;
}

// cleanup timeouts
function clearPending(){
  pendingTimeouts.forEach(t => clearTimeout(t));
  pendingTimeouts = [];
  running = false;
  paused = false;
}

function schedule(fn, delay){
  const t = setTimeout(()=>{
    fn();
    // remove from pending
    pendingTimeouts = pendingTimeouts.filter(x=>x!==t);
  }, delay);
  pendingTimeouts.push(t);
  return t;
}

// Rendering functions
function clearSVG(){
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}

function computeLayout() {
  // Set positions: root centered, spread halves each level.
  const width = 1200;
  const levelHeight = 86;
  function place(node, x, y, spread) {
    if (!node) return;
    node.x = x;
    node.y = y;
    if (node.left) place(node.left, x - spread, y + levelHeight, spread/1.9);
    if (node.right) place(node.right, x + spread, y + levelHeight, spread/1.9);
  }
  if (tree.root) {
    place(tree.root, width/2, 60, width/4);
  }
}

function drawTree(highlights = {}) {
  // highlights: visited: Set(ids), active: Set(ids), removed: Set(ids)
  clearSVG();
  computeLayout();
  const width = 1200, height = 520;

  // draw edges first
  function drawEdges(node) {
    if (!node) return;
    if (node.left) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', node.x);
      line.setAttribute('y1', node.y+20);
      line.setAttribute('x2', node.left.x);
      line.setAttribute('y2', node.left.y-20);
      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      line.setAttribute('stroke-width','2');
      svg.appendChild(line);
    }
    if (node.right) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', node.x);
      line.setAttribute('y1', node.y+20);
      line.setAttribute('x2', node.right.x);
      line.setAttribute('y2', node.right.y-20);
      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      line.setAttribute('stroke-width','2');
      svg.appendChild(line);
    }
    drawEdges(node.left);
    drawEdges(node.right);
  }
  drawEdges(tree.root);

  // draw nodes
  function drawNode(node) {
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.classList.add('node-svg');
    // background circle
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 20);
    circle.setAttribute('cx', 0);
    circle.setAttribute('cy', 0);
    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
    circle.setAttribute('stroke-width', 1.6);

    // decide fill based on highlights
    const fill = highlights.removed && highlights.removed.has(node.id) ? '#ff6b6b'
                : highlights.inserted && highlights.inserted.has(node.id) ? '#3dd6a0'
                : highlights.visited && highlights.visited.has(node.id) ? '#1e90b0'
                : 'rgba(255,255,255,0.02)';

    circle.setAttribute('fill', fill);

    // text
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x',0);
    text.setAttribute('y',6);
    text.setAttribute('text-anchor','middle');
    text.setAttribute('font-size','13');
    text.setAttribute('font-family','monospace');
    text.setAttribute('fill', fill === 'rgba(255,255,255,0.02)' ? '#cfeee0' : '#072021');
    text.textContent = node.value;

    g.appendChild(circle);
    g.appendChild(text);

    svg.appendChild(g);

    if (node.left) drawNode(node.left);
    if (node.right) drawNode(node.right);
  }

  drawNode(tree.root);

  updateStats();
}

function updateStats() {
  nodeCountEl.textContent = tree.size;
  heightEl.textContent = tree.height();
  const mn = tree.min(); const mx = tree.max();
  minmaxEl.textContent = (mn===null ? '—' : mn) + (mn===null ? '' : '  /  ' + mx);
}

// Controls and interactions
document.getElementById('insertBtn').addEventListener('click', ()=>{
  const v = parseInt(valueInput.value);
  if (Number.isNaN(v)) {
    log('Enter an integer value to insert.');
    return;
  }
  clearPending();
  animateInsert(v);
});

document.getElementById('deleteBtn').addEventListener('click', ()=>{
  const v = parseInt(valueInput.value);
  if (Number.isNaN(v)) {
    log('Enter an integer value to delete.');
    return;
  }
  clearPending();
  animateDelete(v);
});

document.getElementById('searchBtn').addEventListener('click', ()=>{
  const v = parseInt(valueInput.value);
  if (Number.isNaN(v)) {
    log('Enter an integer value to search.');
    return;
  }
  clearPending();
  animateSearch(v);
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  clearPending();
  tree = new BST();
  Node._id = 1;
  drawTree();
  log('Tree cleared.');
});

document.getElementById('randomBtn').addEventListener('click', ()=>{
  clearPending();
  // generate random set of unique ints
  const count = 8 + Math.floor(Math.random()*8);
  const vals = new Set();
  while (vals.size < count) vals.add(Math.floor(Math.random()*90)+1);
  const arr = Array.from(vals);
  log('Randomizing tree with', arr.length, 'values:', arr.join(', '));
  // insert with animation
  let delay = 0;
  arr.forEach((v,i) => {
    schedule(()=> {
      tree.insert(v);
      drawTree({inserted: new Set([getNodeByValue(v)?.id])});
    }, delay);
    delay += 140;
  });
  schedule(()=> {
    drawTree();
    log('Random insertion complete.');
  }, delay+200);
});

document.getElementById('inorderBtn').addEventListener('click', ()=> {
  clearPending();
  const list = tree.inorder();
  animateTraversal(list, 'In-order');
});
document.getElementById('preorderBtn').addEventListener('click', ()=> {
  clearPending();
  const list = tree.preorder();
  animateTraversal(list, 'Pre-order');
});
document.getElementById('postorderBtn').addEventListener('click', ()=> {
  clearPending();
  const list = tree.postorder();
  animateTraversal(list, 'Post-order');
});
document.getElementById('levelBtn').addEventListener('click', ()=> {
  clearPending();
  const list = tree.levelOrder();
  animateTraversal(list, 'Level-order');
});

document.getElementById('stepTraversal').addEventListener('click', ()=> {
  clearPending();
  const list = tree.inorder();
  // step mode: show one node at a time using prompt-less stepping (Pause/Resume used)
  runStepTraversal(list);
});

document.getElementById('pauseBtn').addEventListener('click', ()=>{
  paused = true;
  clearPending(); // stop further scheduled actions
  log('Paused.');
});
document.getElementById('resumeBtn').addEventListener('click', ()=>{
  if (!running) log('Nothing to resume.');
  paused = false;
  log('Resume not implemented for mid-animation. Start an action again.');
});

// speed control
speedRange.addEventListener('input', ()=>{
  animationDelay = parseInt(speedRange.value);
});

// helper to get node by value (search first occurrence)
function getNodeByValue(val){
  const s = tree.search(val);
  return s.found;
}

// Animations
function animateInsert(value) {
  const res = tree.insert(value);
  if (!res.inserted) {
    drawTree({visited: new Set(res.path.map(n=>n.id))});
    log('Value', value, 'already exists — duplicates are ignored.');
    return;
  }
  running = true;
  const path = res.path; // nodes visited + inserted node at end
  const visitedSet = new Set();
  const insertedSet = new Set([res.inserted.id]);
  let t = 0;
  const stepDelay = Math.max(80, animationDelay/1.6);
  path.forEach((node,i) => {
    schedule(()=> {
      visitedSet.add(node.id);
      drawTree({visited: visitedSet, inserted: insertedSet});
      if (i < path.length - 1) log('Visiting', node.value);
      else log('Inserted', node.value);
    }, t);
    t += stepDelay;
  });
  schedule(()=> {
    running = false;
    drawTree({inserted: insertedSet});
  }, t+60);
}

function animateSearch(value) {
  const res = tree.search(value);
  const path = res.path;
  running = true;
  const visitedSet = new Set();
  let t = 0;
  const stepDelay = Math.max(80, animationDelay/1.6);
  path.forEach((node,i)=>{
    schedule(()=> {
      visitedSet.add(node.id);
      drawTree({visited: visitedSet});
      log('Checking', node.value);
    }, t);
    t += stepDelay;
  });
  schedule(()=> {
    running = false;
    if (res.found) {
      drawTree({inserted: new Set([res.found.id])});
      log('Found', value);
    } else {
      drawTree({visited: visitedSet});
      log('Not found:', value);
    }
  }, t+50);
}

function animateDelete(value) {
  const res = tree.delete(value);
  if (!res.deletedNode) {
    drawTree({visited: new Set(res.path.map(n=>n.id))});
    log('Value', value, 'not found; cannot delete.');
    return;
  }
  running = true;
  const path = res.path;
  const visitedSet = new Set();
  const removedSet = new Set([res.deletedNode.id]);
  let t = 0;
  const stepDelay = Math.max(90, animationDelay/1.8);
  path.forEach((node,i) => {
    schedule(()=> {
      visitedSet.add(node.id);
      drawTree({visited: visitedSet, removed: removedSet});
      log('Visiting', node.value);
    }, t);
    t += stepDelay;
  });
  schedule(()=> {
    // final refresh (tree already updated by delete)
    drawTree({removed: removedSet});
    running = false;
    log('Deleted', value);
  }, t+120);
}

function animateTraversal(list, name) {
  if (!list || list.length === 0) {
    log(name + ' traversal: tree empty.');
    return;
  }
  running = true;
  const visited = new Set();
  let t = 0;
  const stepDelay = Math.max(200, animationDelay);
  list.forEach((node,i) => {
    schedule(()=> {
      visited.add(node.id);
      drawTree({visited});
      log(name + ' visiting', node.value);
    }, t);
    t += stepDelay;
  });
  schedule(()=> {
    running = false;
    drawTree();
    log(name + ' complete. Sequence:', list.map(n=>n.value).join(', '));
  }, t+80);
}

// step traversal: manual stepping using "Pause" and "Resume" isn't ideal, implement simple stepper
function runStepTraversal(list) {
  if (!list.length) { log('Tree empty.'); return; }
  let idx = 0;
  running = true;
  paused = true; // start paused, user presses Resume to advance? We'll implement a "click to step" by clicking the svg
  log('Step traversal: click anywhere on the canvas to advance through nodes (or press Clear to stop).');
  function stepOnce() {
    if (idx >= list.length) {
      svg.removeEventListener('click', onClick);
      running = false;
      drawTree();
      log('Step traversal complete.');
      return;
    }
    const node = list[idx++];
    drawTree({visited:new Set([node.id])});
    log('Step visiting', node.value);
  }
  function onClick(){
    stepOnce();
  }
  svg.addEventListener('click', onClick);
  // initial highlight first node
  stepOnce();
}

// initial draw
drawTree();
log('BST visualizer ready. Examples: insert 50, 30, 70, 20, 40, 60, 80.');

</script>
</body>
</html>