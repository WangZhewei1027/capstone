<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Linked List Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1720; --panel:#0b1220; --accent:#2dd4bf; --muted:#94a3b8; --card:#071122;
      --node-bg:#0ea5a1; --node-text:#021B1A; --node-border:#065f5b;
      --danger:#fb7185; --success:#34d399;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background:linear-gradient(180deg,#071422 0%, #08162a 100%); color:#e6eef6;
      min-height:100vh; display:flex; align-items:flex-start; justify-content:center; padding:28px;
    }
    .app{
      width:1100px; max-width:96vw; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px; box-shadow: 0 8px 30px rgba(2,6,23,0.6); overflow:hidden; display:flex;
      border:1px solid rgba(255,255,255,0.025);
    }
    .sidebar{
      width:340px; padding:20px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-right:1px solid rgba(255,255,255,0.02);
    }
    .main{
      flex:1; padding:18px; position:relative;
    }
    h1{margin:0 0 10px 0; font-size:18px; letter-spacing:0.2px}
    p.lead{margin:6px 0 18px 0; color:var(--muted); font-size:13px}
    label{display:block; font-size:13px; margin-top:12px; color:var(--muted)}
    input[type="text"], input[type="number"], select {
      width:100%; padding:10px 12px; margin-top:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02); color:inherit; outline:none; font-size:14px;
    }
    .controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:14px}
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px; border-radius:8px;
      cursor:pointer; font-size:13px;
    }
    button.primary{background:linear-gradient(90deg, var(--accent), #60f0d3); color:#013033; font-weight:600; border:0}
    button.danger{background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--danger)}
    .small{padding:6px 8px; font-size:12px}
    .row{display:flex; gap:8px; align-items:center}
    .muted{color:var(--muted); font-size:13px}
    .visual-area{
      height:420px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border:1px dashed rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center;
      position:relative; overflow:auto; padding:18px;
    }
    .list{
      display:flex; align-items:center; gap:14px; padding:12px;
    }
    .node{
      min-width:72px; height:64px; background:linear-gradient(180deg,#2dd4bf,#06b6a4); color:var(--node-text);
      border-radius:10px; box-shadow:0 6px 16px rgba(2,15,16,0.35); display:flex; align-items:center; justify-content:center;
      font-weight:700; font-size:16px; position:relative; transition:transform .25s ease, opacity .25s ease;
      border:2px solid var(--node-border);
    }
    .node.small{min-width:60px; height:52px; font-size:14px}
    .arrow{
      font-size:20px; color:var(--muted);
      user-select:none;
    }
    .null{
      font-size:13px; color:var(--muted);
      width:64px; text-align:center;
    }
    .node.highlight{ box-shadow:0 8px 26px rgba(34,197,94,0.25); transform:scale(1.08)}
    .node.found{ box-shadow:0 8px 26px rgba(59,130,246,0.22); transform:scale(1.08); background:linear-gradient(180deg,#60a5fa,#3b82f6); color:white; border-color:#1e40af}
    .node.new{ animation:pop .28s ease; }
    .node.removed{ animation:fadeOut .28s ease forwards }
    @keyframes pop { from{transform:scale(.6); opacity:0} to{transform:scale(1); opacity:1}}
    @keyframes fadeOut { to{opacity:0; transform:translateY(-8px) } }
    .log{
      margin-top:12px; font-family:monospace; background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; font-size:13px;
      color:var(--muted); max-height:120px; overflow:auto; border:1px solid rgba(255,255,255,0.02)
    }
    .controls-grid{ display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:12px; }
    .footer{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:12px}
    .small-muted{ font-size:12px; color:var(--muted) }
    .speed{ display:flex; gap:10px; align-items:center; margin-top:8px }
    input[type="range"]{ width:150px }
    .chip{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); color:var(--muted) }
    .topbar{ display:flex; gap:8px; align-items:center; justify-content:space-between }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px }
    .centered{ display:flex; align-items:center; justify-content:center; flex-direction:column; gap:8px; color:var(--muted) }
    .credits{ font-size:12px; color:var(--muted) }
    /* responsive */
    @media(max-width:900px){
      .app{flex-direction:column}
      .sidebar{width:100%}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Linked List Visualizer">
    <div class="sidebar" aria-hidden="false">
      <h1>Linked List Visualizer</h1>
      <p class="lead">Interactive singly linked list: insert, delete, search, reverse. Step-through to watch algorithms.</p>

      <label>Value</label>
      <input id="valueInput" type="text" placeholder="e.g., 5 or hello" />

      <div class="controls">
        <button id="btnPrepend" class="primary small">Prepend (head)</button>
        <button id="btnAppend" class="primary small">Append (tail)</button>
      </div>

      <label>Index (0-based)</label>
      <input id="indexInput" type="number" placeholder="index e.g., 0, 1, 2" min="0" />

      <div class="controls">
        <button id="btnInsertAt" class="small">Insert at index</button>
        <button id="btnDeleteAt" class="small">Delete at index</button>
      </div>

      <label>Search / Delete by value</label>
      <div class="controls">
        <button id="btnSearch" class="small">Search</button>
        <button id="btnDeleteValue" class="small danger">Delete by value</button>
      </div>

      <div class="controls-grid">
        <button id="btnReverse" class="small">Reverse</button>
        <button id="btnClear" class="small">Clear</button>
        <button id="btnRandom" class="small">Random List</button>
        <button id="btnSample" class="small">Load Sample</button>
      </div>

      <label>Speed</label>
      <div class="speed">
        <input id="speedRange" type="range" min="100" max="1200" value="480" />
        <div class="chip small-muted" id="speedLabel">480ms</div>
      </div>

      <label>Mode</label>
      <div class="row">
        <div class="chip">Step mode:</div>
        <input id="stepToggle" type="checkbox" style="margin-left:6px" />
        <button id="btnNext" class="small">Next Step</button>
      </div>

      <div class="hint">Tip: Use step mode to walk algorithms (search and reverse step-by-step).</div>

      <div style="margin-top:12px">
        <div class="small-muted">Operation log</div>
        <div id="log" class="log" aria-live="polite"></div>
      </div>

      <div style="margin-top:12px" class="credits">Built with plain JavaScript — educational demo.</div>
    </div>

    <div class="main">
      <div class="topbar">
        <div class="small-muted">Visual representation (→ points to next)</div>
        <div class="small-muted">Head → leftmost · Tail → rightmost</div>
      </div>

      <div class="visual-area" id="visualArea" role="region" aria-label="Linked list visualization">
        <div id="listContainer" class="list" aria-hidden="false">
          <!-- nodes will be rendered here -->
        </div>
      </div>

      <div style="margin-top:12px; display:flex; gap:10px; align-items:center; justify-content:flex-end">
        <div class="small-muted">Length: </div><div id="lengthChip" class="chip">0</div>
      </div>

    </div>
  </div>

  <script>
    // Linked List implementation + visualizer
    (function(){
      // Node & LinkedList
      class Node {
        constructor(value){
          this.value = value;
          this.next = null;
        }
      }
      class LinkedList {
        constructor(){
          this.head = null;
          this._length = 0;
        }
        get length(){ return this._length; }
        toArray(){
          const arr=[];
          let cur=this.head;
          while(cur){ arr.push(cur.value); cur=cur.next; }
          return arr;
        }
        prepend(value){
          const n=new Node(value);
          n.next=this.head;
          this.head=n;
          this._length++;
          return n;
        }
        append(value){
          const n=new Node(value);
          if(!this.head){ this.head=n; this._length++; return n; }
          let cur=this.head;
          while(cur.next) cur=cur.next;
          cur.next=n;
          this._length++;
          return n;
        }
        insertAt(value, index){
          if(index<0) return null;
          if(index===0) return this.prepend(value);
          if(index>=this._length){
            return this.append(value);
          }
          let cur=this.head;
          for(let i=0;i<index-1;i++) cur=cur.next;
          const node=new Node(value);
          node.next=cur.next;
          cur.next=node;
          this._length++;
          return node;
        }
        deleteAt(index){
          if(index<0 || index>=this._length || !this.head) return null;
          if(index===0){
            const removed=this.head;
            this.head=this.head.next;
            removed.next=null;
            this._length--;
            return removed;
          }
          let cur=this.head;
          for(let i=0;i<index-1;i++) cur=cur.next;
          const removed=cur.next;
          cur.next = removed ? removed.next : null;
          if(removed) removed.next=null;
          this._length--;
          return removed;
        }
        deleteValue(value){
          if(!this.head) return -1;
          if(this.head.value===value){
            this.head=this.head.next;
            this._length--;
            return 0;
          }
          let prev=this.head; let cur=this.head.next; let idx=1;
          while(cur){
            if(cur.value===value){
              prev.next=cur.next;
              this._length--;
              return idx;
            }
            prev=cur; cur=cur.next; idx++;
          }
          return -1;
        }
        indexOf(value){
          let cur=this.head; let idx=0;
          while(cur){
            if(cur.value===value) return idx;
            cur=cur.next; idx++;
          }
          return -1;
        }
        clear(){ this.head=null; this._length=0; }
        replaceArray(arr){
          this.clear();
          for(let v of arr) this.append(v);
        }
      }

      // DOM elements
      const valueInput = document.getElementById('valueInput');
      const indexInput = document.getElementById('indexInput');
      const btnPrepend = document.getElementById('btnPrepend');
      const btnAppend = document.getElementById('btnAppend');
      const btnInsertAt = document.getElementById('btnInsertAt');
      const btnDeleteAt = document.getElementById('btnDeleteAt');
      const btnSearch = document.getElementById('btnSearch');
      const btnDeleteValue = document.getElementById('btnDeleteValue');
      const btnReverse = document.getElementById('btnReverse');
      const btnClear = document.getElementById('btnClear');
      const btnRandom = document.getElementById('btnRandom');
      const btnSample = document.getElementById('btnSample');
      const listContainer = document.getElementById('listContainer');
      const logEl = document.getElementById('log');
      const lengthChip = document.getElementById('lengthChip');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const stepToggle = document.getElementById('stepToggle');
      const btnNext = document.getElementById('btnNext');

      // state
      const list = new LinkedList();
      let currentGenerator = null;
      let stepMode = false;
      let running = false;

      // utilities
      function log(message){
        const time = new Date().toLocaleTimeString();
        const line = document.createElement('div');
        line.textContent = `[${time}] ${message}`;
        logEl.prepend(line);
      }
      function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
      function getDelay(){ return Number(speedRange.value) || 480; }

      // Render function
      function render(opts = {}){
        // opts:
        // highlightIndices: array of indexes to highlight
        // newIndex: index of newly inserted node
        // removedIndex: index removed (for animation)
        // foundIndex: index found
        // dimAfter: index - for partial render (used in reverse step)
        // message: optional
        const arr = list.toArray();
        listContainer.innerHTML='';
        const highlight = new Set((opts.highlightIndices||[]));
        const found = opts.foundIndex != null ? opts.foundIndex : null;
        const newIdx = opts.newIndex != null ? opts.newIndex : null;
        const removedIdx = opts.removedIndex != null ? opts.removedIndex : null;
        const dimAfter = opts.dimAfter != null ? opts.dimAfter : null;

        arr.forEach((val,i)=>{
          const node = document.createElement('div');
          node.className='node';
          if(i===newIdx) node.classList.add('new');
          if(i===removedIdx) node.classList.add('removed');
          if(highlight.has(i)) node.classList.add('highlight');
          if(found === i) node.classList.add('found');
          node.textContent = String(val);
          node.dataset.index = String(i);
          listContainer.appendChild(node);
          // arrow or null
          const arrowSur = document.createElement('div');
          arrowSur.className = 'arrow';
          arrowSur.style.marginLeft = '6px';
          arrowSur.style.marginRight = '6px';
          arrowSur.textContent = '→';
          // dim remaining
          if(dimAfter != null){
            if(i >= dimAfter) {
              node.style.opacity = '0.45';
              arrowSur.style.opacity = '0.35';
            }
          }
          if(i < arr.length - 1){
            listContainer.appendChild(arrowSur);
          } else {
            const nullBox = document.createElement('div');
            nullBox.className='null';
            nullBox.textContent='null';
            listContainer.appendChild(nullBox);
          }
        });

        lengthChip.textContent = String(list.length);
        if(opts.message) log(opts.message);
      }

      // Simple operations with small animations
      async function doPrepend(){
        if(running) return;
        const v = valueInput.value.trim();
        if(v===''){ log('Provide a value to prepend.'); return; }
        running=true;
        const node = list.prepend(v);
        render({newIndex:0, message:`Prepended ${v} at head.`});
        await sleep(220);
        running=false;
      }
      async function doAppend(){
        if(running) return;
        const v = valueInput.value.trim();
        if(v===''){ log('Provide a value to append.'); return; }
        running=true;
        const idx = list.length;
        list.append(v);
        render({newIndex:idx, message:`Appended ${v} at tail.`});
        await sleep(220);
        running=false;
      }
      async function doInsertAt(){
        if(running) return;
        const v = valueInput.value.trim();
        const idx = Number(indexInput.value);
        if(v===''){ log('Provide a value to insert.'); return; }
        if(Number.isNaN(idx) || idx<0){ log('Provide a valid index (0-based).'); return; }
        running=true;
        const capped = Math.min(idx, Math.max(0,list.length));
        list.insertAt(v, capped);
        render({newIndex:capped, message:`Inserted ${v} at index ${capped}.`});
        await sleep(220);
        running=false;
      }
      async function doDeleteAt(){
        if(running) return;
        const idx = Number(indexInput.value);
        if(Number.isNaN(idx) || idx<0 || idx>=list.length){ log('Index out of bounds.'); return; }
        running=true;
        const removed = list.deleteAt(idx);
        render({removedIndex:idx, message:`Deleted value ${removed?removed.value:'?'} at index ${idx}.`});
        await sleep(300);
        render({message:`Updated list after deletion.`});
        running=false;
      }
      async function doDeleteValue(){
        if(running) return;
        const v = valueInput.value.trim();
        if(v===''){ log('Provide a value to delete.'); return; }
        running=true;
        const idx = list.deleteValue(v);
        if(idx>=0){
          render({removedIndex:idx, message:`Deleted value ${v} at index ${idx}.`});
          await sleep(320);
          render({message:'Updated list after deletion.'});
        } else {
          render({message:`Value ${v} not found.`});
        }
        running=false;
      }

      // Search (supports step mode)
      function* searchGenerator(value){
        const arr = list.toArray();
        for(let i=0;i<arr.length;i++){
          yield {highlight:i, message:`Checking index ${i}: ${arr[i]}`};
          if(String(arr[i])===String(value)){
            yield {found:i, message:`Found ${value} at index ${i}.`};
            return i;
          }
        }
        yield {message:`Value ${value} not found.`};
        return -1;
      }

      // Reverse (supports step mode) - yields partial states: rev + remaining
      function* reverseGenerator(){
        const arr = list.toArray();
        let rev = [];
        for(let step=0; step<arr.length; step++){
          const moved = arr.shift(); // take front
          rev.unshift(moved);
          // produce combined array that shows reversed portion on left and remaining dimmed
          yield {array: [...rev, ...arr], dimAfter: rev.length, message:`Moved ${moved} to reversed list (step ${step+1}/${rev.length + arr.length}).`};
        }
        // done
        return rev;
      }

      // Runner for generators
      async function runGenerator(gen){
        if(running) return;
        running=true;
        currentGenerator = gen;
        let step = gen.next();
        while(!step.done){
          const payload = step.value;
          // handle payload
          if(payload.array){
            // render with custom array and dimming after index
            const containerContent = payload.array;
            // temporarily replace list rendering with provided array
            listContainer.innerHTML='';
            containerContent.forEach((val,i)=>{
              const node = document.createElement('div');
              node.className='node';
              node.textContent = String(val);
              if(i >= payload.dimAfter) { node.style.opacity = '0.45'; }
              listContainer.appendChild(node);
              if(i < containerContent.length - 1){
                const arrow = document.createElement('div'); arrow.className='arrow'; arrow.textContent='→';
                if(i >= payload.dimAfter) arrow.style.opacity='0.35';
                listContainer.appendChild(arrow);
              } else {
                const nullBox = document.createElement('div'); nullBox.className='null'; nullBox.textContent='null';
                listContainer.appendChild(nullBox);
              }
            });
            lengthChip.textContent = String(containerContent.length);
            if(payload.message) log(payload.message);
          } else if(payload.highlight != null){
            render({highlightIndices:[payload.highlight], message:payload.message});
          } else if(payload.found != null){
            render({foundIndex:payload.found, message:payload.message});
          } else if(payload.message){
            log(payload.message);
          }
          // If in step mode, break after yielding one step and wait for manual next.
          if(stepMode){
            // keep generator accessible and wait for manual resume
            currentGenerator = gen;
            running=false;
            return;
          } else {
            // automatic: wait delay then continue
            await sleep(getDelay());
            step = gen.next(step.value);
          }
        }
        // finish: if reverse generator returned a final array, apply to underlying list
        if(step.value && Array.isArray(step.value)){
          list.replaceArray(step.value);
          render({message:'List reversed.'});
        } else {
          // if search returned an index or nothing, just ensure render
          render({message:'Operation finished.'});
        }
        currentGenerator = null;
        running=false;
      }

      // UI handlers for search and reverse
      async function doSearch(){
        if(running) return;
        const v = valueInput.value.trim();
        if(v===''){ log('Provide a value to search.'); return; }
        const gen = searchGenerator(v);
        await runGenerator(gen);
      }
      async function doReverse(){
        if(running) return;
        if(list.length <=1){ log('List too short to reverse.'); return; }
        const gen = reverseGenerator();
        // run generator; at the end get returned reversed array, then update list
        // We need to adapt runGenerator to apply final returned array.
        if(stepMode){
          // handle step mode separately to support finishing the whole algorithm on subsequent Next
          currentGenerator = gen;
          // perform first step
          const step = gen.next();
          if(!step.done){
            const payload = step.value;
            if(payload.array){
              // temp render
              listContainer.innerHTML='';
              const containerContent = payload.array;
              containerContent.forEach((val,i)=>{
                const node = document.createElement('div');
                node.className='node';
                node.textContent = String(val);
                if(i >= payload.dimAfter) { node.style.opacity = '0.45'; }
                listContainer.appendChild(node);
                if(i < containerContent.length - 1){
                  const arrow = document.createElement('div'); arrow.className='arrow'; arrow.textContent='→';
                  if(i >= payload.dimAfter) arrow.style.opacity='0.35';
                  listContainer.appendChild(arrow);
                } else {
                  const nullBox = document.createElement('div'); nullBox.className='null'; nullBox.textContent='null';
                  listContainer.appendChild(nullBox);
                }
              });
              lengthChip.textContent = String(containerContent.length);
            }
            if(payload.message) log(payload.message);
            running=false;
            return;
          } else {
            // immediately done
            const res = step.value;
            if(Array.isArray(res)) list.replaceArray(res);
            render({message:'List reversed.'});
            currentGenerator = null;
            running=false;
            return;
          }
        } else {
          // auto mode
          running=true;
          // iterate generator and update underlying list at end
          let step = gen.next();
          while(!step.done){
            const payload = step.value;
            if(payload.array){
              listContainer.innerHTML='';
              const containerContent = payload.array;
              containerContent.forEach((val,i)=>{
                const node = document.createElement('div');
                node.className='node';
                node.textContent = String(val);
                if(i >= payload.dimAfter) { node.style.opacity = '0.45'; }
                listContainer.appendChild(node);
                if(i < containerContent.length - 1){
                  const arrow = document.createElement('div'); arrow.className='arrow'; arrow.textContent='→';
                  if(i >= payload.dimAfter) arrow.style.opacity='0.35';
                  listContainer.appendChild(arrow);
                } else {
                  const nullBox = document.createElement('div'); nullBox.className='null'; nullBox.textContent='null';
                  listContainer.appendChild(nullBox);
                }
              });
              lengthChip.textContent = String(containerContent.length);
              if(payload.message) log(payload.message);
            } else if(payload.message){
              log(payload.message);
            }
            await sleep(getDelay());
            step = gen.next();
          }
          // apply final reversed array from return value if provided
          if(step.value && Array.isArray(step.value)){
            list.replaceArray(step.value);
            render({message:'List reversed.'});
          } else {
            render({message:'Reverse completed.'});
          }
          running=false;
          currentGenerator = null;
        }
      }

      // Step resume (Next Step)
      async function resumeStep(){
        if(running) return;
        if(!currentGenerator){ log('Nothing to step.'); return; }
        running=true;
        const g = currentGenerator;
        const step = g.next();
        if(!step.done){
          const payload = step.value;
          if(payload.array){
            listContainer.innerHTML='';
            const containerContent = payload.array;
            containerContent.forEach((val,i)=>{
              const node = document.createElement('div');
              node.className='node';
              node.textContent = String(val);
              if(i >= payload.dimAfter) { node.style.opacity = '0.45'; }
              listContainer.appendChild(node);
              if(i < containerContent.length - 1){
                const arrow = document.createElement('div'); arrow.className='arrow'; arrow.textContent='→';
                if(i >= payload.dimAfter) arrow.style.opacity='0.35';
                listContainer.appendChild(arrow);
              } else {
                const nullBox = document.createElement('div'); nullBox.className='null'; nullBox.textContent='null';
                listContainer.appendChild(nullBox);
              }
            });
            lengthChip.textContent = String(containerContent.length);
          } else if(payload.highlight != null){
            render({highlightIndices:[payload.highlight], message:payload.message});
          } else if(payload.found != null){
            render({foundIndex:payload.found, message:payload.message});
          } else if(payload.message){
            log(payload.message);
          }
          running=false;
          return;
        } else {
          // generator finished; check return value:
          if(step.value && Array.isArray(step.value)){
            list.replaceArray(step.value);
            render({message:'Operation finished.'});
          } else {
            render({message:'Operation finished.'});
          }
          currentGenerator = null;
          running=false;
        }
      }

      // Random & sample data
      function randomList(size=6){
        list.clear();
        for(let i=0;i<size;i++){
          const v = Math.floor(Math.random()*100);
          list.append(v);
        }
        render({message:`Generated random list of ${size} items.`});
      }
      function sampleList(){
        list.clear();
        ['A','B','C','D','E'].forEach(x=>list.append(x));
        render({message:'Loaded sample list A→B→C→D→E.'});
      }

      // Button wiring
      btnPrepend.addEventListener('click', doPrepend);
      btnAppend.addEventListener('click', doAppend);
      btnInsertAt.addEventListener('click', doInsertAt);
      btnDeleteAt.addEventListener('click', doDeleteAt);
      btnDeleteValue.addEventListener('click', doDeleteValue);
      btnSearch.addEventListener('click', doSearch);
      btnReverse.addEventListener('click', doReverse);
      btnClear.addEventListener('click', ()=>{ list.clear(); render({message:'List cleared.'}); });
      btnRandom.addEventListener('click', ()=>randomList(6));
      btnSample.addEventListener('click', sampleList);
      btnNext.addEventListener('click', resumeStep);
      speedRange.addEventListener('input', ()=> speedLabel.textContent = speedRange.value + 'ms');
      stepToggle.addEventListener('change', ()=> {
        stepMode = stepToggle.checked;
        log('Step mode ' + (stepMode ? 'enabled' : 'disabled') + '.');
      });

      // initialize
      sampleList();
      render({message:'Ready.'});
      speedLabel.textContent = speedRange.value + 'ms';
    })();
  </script>
</body>
</html>