<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Two Pointers — Interactive Playground</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --card:#071022;
      --accent:#22c1c3;
      --muted:#9aa6b2;
      --good:#16a34a;
      --bad:#ef4444;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%; margin:0; background: linear-gradient(180deg,#071322 0%, #041423 100%); color:#e6eef6;}
    .wrap{max-width:1100px; margin:28px auto; padding:20px;}
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    header h1{font-size:20px;margin:0}
    .topbar{display:flex;gap:12px;align-items:center;margin-top:8px}
    select,input,button{background:var(--card); border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px; border-radius:8px; outline:none}
    button{cursor:pointer}
    .grid{display:grid;grid-template-columns:380px 1fr; gap:18px;}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;flex-direction:column; gap:10px}
    label{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:13px;color:var(--muted)}
    .array-input{width:100%; padding:8px; font-family:monospace; border-radius:8px; background:transparent; color:#dff3ff; border:1px solid rgba(255,255,255,0.04)}
    .visual{min-height:320px; display:flex; flex-direction:column; gap:12px}
    .array-row{display:flex; gap:10px; justify-content:center; align-items:flex-end; flex-wrap:nowrap; overflow:auto; padding:10px 4px}
    .cell{min-width:56px;height:56px;border-radius:8px;background:var(--glass);display:flex;align-items:center;justify-content:center;font-weight:600;color:#dff3ff;position:relative;box-shadow: 0 2px 6px rgba(0,0,0,0.5)}
    .cell.small{min-width:44px;height:44px;border-radius:7px}
    .cell-muted{opacity:0.36}
    .pointer{position:absolute; top:-28px; left:50%; transform:translateX(-50%); font-size:12px; padding:2px 6px; border-radius:6px}
    .pointer.left{background:linear-gradient(90deg,#3aa6ff, #22c1c3); color:#042022}
    .pointer.right{background:linear-gradient(90deg,#ff7b7b,#ffb86b); color:#2b0b00}
    .cell.highlight{box-shadow:0 6px 20px rgba(34,193,195,0.14); transform:translateY(-6px)}
    .cell.found{border:2px solid rgba(22,163,74,0.9); box-shadow:0 6px 20px rgba(22,163,74,0.14); transform:translateY(-6px)}
    .cell.swap{border:2px dashed rgba(255,183,77,0.95)}
    .log{font-family:monospace;background:rgba(255,255,255,0.02); padding:10px;border-radius:8px; color:var(--muted); font-size:13px; min-height:80px; max-height:200px; overflow:auto}
    .pseudocode{font-family:monospace; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:10px;border-radius:8px; color:#bfe9e9; font-size:13px; white-space:pre-wrap; line-height:1.4}
    .footer-keys{display:flex; gap:8px; font-size:13px; color:var(--muted); margin-top:8px; flex-wrap:wrap}
    .meta{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .badge{background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; font-size:13px; color:var(--muted)}
    .controls .row .mini{font-size:12px;padding:6px 8px}
    .found-msg{color:var(--good); font-weight:700}
    .notfound-msg{color:var(--bad); font-weight:700}
    footer{margin-top:18px; font-size:13px; color:var(--muted)}
    .link{color:var(--accent); text-decoration:none}
    @media (max-width:900px){
      .grid{grid-template-columns:1fr; }
      .array-row{padding:12px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div style="width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#0366d6,#22c1c3);font-weight:700;font-size:20px">2P</div>
      <div>
        <h1>Two Pointers — Interactive Playground</h1>
        <div class="small">Explore common two-pointer patterns (two-sum on sorted array, reverse, partition, remove duplicates) with step-by-step animation.</div>
      </div>
    </header>

    <div class="grid">
      <div class="panel controls">
        <label>Mode</label>
        <div class="row">
          <select id="mode">
            <option value="two_sum">Two-sum (sorted)</option>
            <option value="reverse">Reverse array (in-place)</option>
            <option value="partition">Partition by parity (evens left)</option>
            <option value="remove_dups">Remove duplicates (sorted)</option>
          </select>
          <div style="flex:1"></div>
          <button id="helpBtn" title="Show algorithm info">Info</button>
        </div>

        <label style="margin-top:8px">Array (comma-separated integers)</label>
        <input class="array-input" id="arrayInput" value="1,2,3,4,5,6,7,8,9" />

        <div class="row">
          <button id="randomBtn" class="mini">Random</button>
          <input id="size" type="number" min="2" value="9" style="width:72px" />
          <input id="minVal" type="number" value="0" style="width:90px" />
          <input id="maxVal" type="number" value="20" style="width:90px" />
          <div style="flex:1"></div>
          <label><input id="autoSort" type="checkbox" /> Auto-sort input when needed</label>
        </div>

        <div id="twoSumControls" style="display:flex; gap:8px; margin-top:8px; align-items:center">
          <label>Target</label>
          <input id="targetInput" type="number" value="10" style="width:120px" />
        </div>

        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="startBtn">Start</button>
          <button id="stepBtn">Step</button>
          <button id="playBtn">Play</button>
          <button id="resetBtn">Reset</button>
          <div style="flex:1"></div>
        </div>

        <div class="row" style="margin-top:12px;align-items:center">
          <label>Speed</label>
          <input id="speed" type="range" min="200" max="2000" value="800" style="flex:1" />
          <span class="small" id="speedLabel">800 ms</span>
        </div>

        <div class="meta" style="margin-top:12px">
          <div class="badge">Time: <span id="complexity">O(n)</span></div>
          <div class="badge">Space: <span id="space">O(1)</span></div>
          <div class="badge">Ops: <span id="ops">0</span></div>
        </div>

        <div style="margin-top:12px">
          <div class="small">Quick keys: Space = Step, P = Play/Pause, R = Reset</div>
        </div>
      </div>

      <div class="panel visual">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div style="display:flex; gap:8px; align-items:center">
            <div class="small">Array visualization</div>
            <div class="badge" id="modeBadge">Two-sum</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center">
            <div id="status" class="small">Idle</div>
            <div id="result" style="font-weight:700"></div>
          </div>
        </div>

        <div class="array-row" id="arrayRow" aria-live="polite"></div>

        <div style="display:flex; gap:12px">
          <div style="flex:1">
            <div class="pseudocode" id="pseudocode">
              // Pseudocode shown here
            </div>
          </div>
          <div style="width:320px">
            <div class="log" id="log">Messages will appear here...</div>
            <div style="margin-top:8px" id="extraInfo"></div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Two pointers is a family of techniques where two indices (pointers) traverse an array from ends or together to solve problems in O(n) time using O(1) space. Try different modes and step through the pointers.
    </footer>
  </div>

<script>
(() => {
  // DOM refs
  const modeSel = document.getElementById('mode');
  const arrayInput = document.getElementById('arrayInput');
  const randomBtn = document.getElementById('randomBtn');
  const sizeInput = document.getElementById('size');
  const minVal = document.getElementById('minVal');
  const maxVal = document.getElementById('maxVal');
  const autoSort = document.getElementById('autoSort');
  const targetInput = document.getElementById('targetInput');
  const startBtn = document.getElementById('startBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playBtn = document.getElementById('playBtn');
  const resetBtn = document.getElementById('resetBtn');
  const speed = document.getElementById('speed');
  const speedLabel = document.getElementById('speedLabel');
  const arrayRow = document.getElementById('arrayRow');
  const pseudocode = document.getElementById('pseudocode');
  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  const complexityEl = document.getElementById('complexity');
  const spaceEl = document.getElementById('space');
  const opsEl = document.getElementById('ops');
  const resultEl = document.getElementById('result');
  const modeBadge = document.getElementById('modeBadge');
  const extraInfo = document.getElementById('extraInfo');
  const helpBtn = document.getElementById('helpBtn');

  // State
  let arr = [];
  let originalArr = [];
  let state = null;
  let playing = false;
  let timer = null;
  let ops = 0;

  const modes = {
    two_sum: {
      name: "Two-sum (sorted)",
      complexity: "O(n)",
      space: "O(1)",
      description: "Find two numbers that add up to target in a sorted array by moving left and right pointers inward.",
      pseudocode:
`left = 0
right = n - 1
while left < right:
  sum = a[left] + a[right]
  if sum == target:
    return (left, right)
  elif sum < target:
    left += 1
  else:
    right -= 1
return not found`,
      init: (A, opts) => {
        // opts: {target, autosort}
        const target = opts.target;
        let B = A.slice();
        if (opts.autosort) B.sort((a,b)=>a-b);
        return {
          arr: B,
          left: 0,
          right: B.length - 1,
          target,
          found: null,
          done: false,
          name: 'two_sum'
        };
      },
      step: (s) => {
        if (s.done) return s;
        const a = s.arr;
        if (s.left >= s.right) {
          log("Pointers crossed — target not found");
          s.done = true;
          s.found = null;
          return s;
        }
        const sum = a[s.left] + a[s.right];
        log(`Check a[${s.left}](${a[s.left]}) + a[${s.right}](${a[s.right]}) = ${sum}`);
        if (sum === s.target) {
          log(`Found! indices (${s.left}, ${s.right})`);
          s.found = [s.left, s.right];
          s.done = true;
        } else if (sum < s.target) {
          s.left++;
        } else {
          s.right--;
        }
        return s;
      }
    },

    reverse: {
      name: "Reverse array (in-place)",
      complexity: "O(n/2) -> O(n)",
      space: "O(1)",
      description: "Swap elements from the ends moving inward until pointers meet.",
      pseudocode:
`left = 0
right = n - 1
while left < right:
  swap(a[left], a[right])
  left += 1
  right -= 1`,
      init: (A) => {
        return {
          arr: A.slice(),
          left: 0,
          right: A.length - 1,
          done: false,
          name: 'reverse',
          swapping: false
        };
      },
      step: (s) => {
        if (s.done) return s;
        if (s.left >= s.right) {
          log('Reversal complete');
          s.done = true;
          return s;
        }
        log(`Swap a[${s.left}](${s.arr[s.left]}) <-> a[${s.right}](${s.arr[s.right]})`);
        // swap
        const tmp = s.arr[s.left];
        s.arr[s.left] = s.arr[s.right];
        s.arr[s.right] = tmp;
        s.left++;
        s.right--;
        return s;
      }
    },

    partition: {
      name: "Partition by parity (evens left)",
      complexity: "O(n)",
      space: "O(1)",
      description: "Move left forward until odd, right backward until even, then swap — partition evens to left.",
      pseudocode:
`left = 0
right = n - 1
while left < right:
  while left < right and a[left] is even: left++
  while left < right and a[right] is odd: right--
  if left < right:
    swap(a[left], a[right])`,
      init: (A) => {
        return {
          arr: A.slice(),
          left: 0,
          right: A.length - 1,
          done: false,
          name: 'partition'
        };
      },
      step: (s) => {
        if (s.done) return s;
        const a = s.arr;
        while (s.left < s.right && (a[s.left] % 2 === 0)) {
          log(`a[${s.left}](${a[s.left]}) is even → left++`);
          s.left++;
          return s; // show single pointer movement per step
        }
        while (s.left < s.right && (a[s.right] % 2 !== 0)) {
          log(`a[${s.right}](${a[s.right]}) is odd → right--`);
          s.right--;
          return s;
        }
        if (s.left < s.right) {
          log(`Swap a[${s.left}](${a[s.left]}) <-> a[${s.right}](${a[s.right]})`);
          const tmp = a[s.left];
          a[s.left] = a[s[right];
          a[s.right] = tmp;
          s.left++;
          s.right--;
          return s;
        } else {
          log('Partition complete');
          s.done = true;
          return s;
        }
      }
    },

    remove_dups: {
      name: "Remove duplicates (sorted)",
      complexity: "O(n)",
      space: "O(1)",
      description: "Use slow and fast pointers (two pointers) to overwrite duplicates in-place and return new length.",
      pseudocode:
`if n == 0: return 0
slow = 0
for fast in 1..n-1:
  if a[fast] != a[slow]:
    slow += 1
    a[slow] = a[fast]
return slow + 1`,
      init: (A, opts) => {
        let B = A.slice();
        if (opts && opts.autosort) B.sort((a,b)=>a-b);
        return {
          arr: B,
          slow: 0,
          fast: 1,
          done: false,
          name: 'remove_dups'
        };
      },
      step: (s) => {
        const a = s.arr;
        if (s.done) return s;
        if (a.length === 0) { s.done = true; return s; }
        if (s.fast >= a.length) {
          log(`Finished. New length = ${s.slow + 1}`);
          s.done = true;
          return s;
        }
        log(`Compare a[fast=${s.fast}](${a[s.fast]}) vs a[slow=${s.slow}](${a[s.slow]})`);
        if (a[s.fast] !== a[s.slow]) {
          s.slow++;
          a[s.slow] = a[s.fast];
          log(`Keep a[${s.fast}] (${a[s.fast]}) → write to a[${s.slow}]`);
        } else {
          log(`Duplicate found at ${s.fast}, skip`);
        }
        s.fast++;
        return s;
      }
    }
  };

  // Utility functions
  function parseArray(text) {
    const parts = text.split(/[\s,]+/).filter(Boolean);
    const nums = parts.map(p => {
      const n = Number(p.trim());
      return Number.isFinite(n) ? Math.trunc(n) : NaN;
    });
    if (nums.some(isNaN)) return null;
    return nums;
  }

  function randomArray(n, min, max) {
    const r = [];
    for (let i=0;i<n;i++){
      r.push(Math.floor(Math.random()*(max-min+1))+min);
    }
    return r;
  }

  function log(msg) {
    ops++;
    opsEl.textContent = ops;
    const time = new Date().toLocaleTimeString();
    logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
  }

  function render() {
    arrayRow.innerHTML = '';
    const s = state;
    if (!s) return;
    const A = s.arr;
    A.forEach((v,i) => {
      const div = document.createElement('div');
      div.className = 'cell';
      if (A.length > 14) div.classList.add('small');
      div.textContent = v;
      // pointers
      if (s.name === 'two_sum') {
        if (i === s.left) {
          const p = elPointer('left', 'L');
          div.appendChild(p);
          div.classList.add('highlight');
        }
        if (i === s.right) {
          const p = elPointer('right', 'R');
          div.appendChild(p);
          div.classList.add('highlight');
        }
        if (s.found && (i===s.found[0] || i===s.found[1])) {
          div.classList.remove('highlight');
          div.classList.add('found');
        }
      } else if (s.name === 'reverse') {
        if (i === s.left) {
          div.appendChild(elPointer('left','L'));
          div.classList.add('highlight');
        }
        if (i === s.right) {
          div.appendChild(elPointer('right','R'));
          div.classList.add('highlight');
        }
        // show completed swapped region muted?
        if (i < s.left || i > s.right) {
          // after swapping these were processed
        }
      } else if (s.name === 'partition') {
        if (i === s.left) { div.appendChild(elPointer('left','L')); div.classList.add('highlight'); }
        if (i === s.right) { div.appendChild(elPointer('right','R')); div.classList.add('highlight'); }
      } else if (s.name === 'remove_dups') {
        if (i === s.slow) {
          div.appendChild(elPointer('left','slow'));
          div.classList.add('highlight');
        }
        if (i === s.fast) {
          div.appendChild(elPointer('right','fast'));
          div.classList.add('highlight');
        }
        // show kept area vs leftover
        if (i > s.slow) {
          div.classList.add('cell-muted');
        }
      }
      arrayRow.appendChild(div);
    });
  }

  function elPointer(cls, label) {
    const p = document.createElement('div');
    p.className = 'pointer ' + (cls === 'left' ? 'left' : 'right');
    p.textContent = label;
    return p;
  }

  function updateUIForMode() {
    const m = modeSel.value;
    modeBadge.textContent = modes[m].name;
    complexityEl.textContent = modes[m].complexity;
    spaceEl.textContent = modes[m].space;
    opsEl.textContent = '0';
    ops = 0;
    // show/hide target
    document.getElementById('twoSumControls').style.display = (m==='two_sum') ? 'flex' : 'none';
    // set pseudocode
    pseudocode.textContent = modes[m].pseudocode;
    // reset
    resetState();
  }

  function start() {
    const parsed = parseArray(arrayInput.value);
    if (!parsed) {
      alert('Invalid array input. Use comma or space separated integers.');
      return;
    }
    originalArr = parsed.slice();
    arr = parsed.slice();
    const mkey = modeSel.value;
    const mode = modes[mkey];
    const opts = {};
    if (mkey === 'two_sum') {
      opts.target = Number(targetInput.value);
      if (!Number.isFinite(opts.target)) { alert('Invalid target'); return; }
      opts.autosort = autoSort.checked;
    }
    if (mkey === 'remove_dups') {
      opts.autosort = autoSort.checked;
    }
    state = mode.init(arr, opts);
    ops = 0; opsEl.textContent = ops;
    log(`Start mode: ${mode.name}`);
    statusEl.textContent = 'Running';
    resultEl.textContent = '';
    render();
  }

  function step() {
    if (!state) { log('Press Start to initialize the algorithm'); return; }
    if (state.done) { log('Algorithm already finished'); return; }
    const mode = modes[state.name];
    state = mode.step(state);
    render();
    // check results display
    if (state.name === 'two_sum') {
      if (state.done) {
        if (state.found) {
          resultEl.innerHTML = `Found indices <span class="found-msg">${state.found[0]}, ${state.found[1]}</span>`;
        } else {
          resultEl.innerHTML = `<span class="notfound-msg">Not found</span>`;
        }
        statusEl.textContent = 'Done';
      } else {
        statusEl.textContent = 'Stepping';
      }
    } else if (state.name === 'reverse') {
      if (state.done) { statusEl.textContent = 'Done'; resultEl.textContent = 'Array reversed'; }
      else statusEl.textContent = 'Stepping';
    } else if (state.name === 'partition') {
      if (state.done) { statusEl.textContent = 'Done'; resultEl.textContent = 'Partitioned'; }
      else statusEl.textContent = 'Stepping';
    } else if (state.name === 'remove_dups') {
      if (state.done) { statusEl.textContent = 'Done'; resultEl.textContent = `New length = ${state.slow+1}`; }
      else statusEl.textContent = 'Stepping';
    }
  }

  function playToggle() {
    if (!state) { start(); }
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    if (playing) {
      runLoop();
    } else {
      clearTimeout(timer);
    }
  }

  function runLoop() {
    if (!playing || !state || state.done) { playing = false; playBtn.textContent = 'Play'; return; }
    step();
    timer = setTimeout(runLoop, Number(speed.value));
  }

  function resetState() {
    if (timer) clearTimeout(timer);
    playing = false;
    playBtn.textContent = 'Play';
    state = null;
    arrayRow.innerHTML = '';
    logEl.textContent = '';
    statusEl.textContent = 'Idle';
    resultEl.textContent = '';
    ops = 0; opsEl.textContent = ops;
    pseudocode.textContent = modes[modeSel.value].pseudocode;
    extraInfo.innerHTML = `<div class="small">${modes[modeSel.value].description}</div>`;
  }

  // Button events
  randomBtn.addEventListener('click', () => {
    const n = Math.max(2, Number(sizeInput.value) || 9);
    const min = Number(minVal.value)||0;
    const max = Number(maxVal.value)||20;
    const arr = randomArray(n, min, max);
    arrayInput.value = arr.join(',');
  });

  startBtn.addEventListener('click', () => { start(); });
  stepBtn.addEventListener('click', () => { step(); });
  playBtn.addEventListener('click', () => { playToggle(); });
  resetBtn.addEventListener('click', () => { resetState(); });

  modeSel.addEventListener('change', () => {
    updateUIForMode();
  });

  speed.addEventListener('input', () => {
    speedLabel.textContent = speed.value + ' ms';
  });

  helpBtn.addEventListener('click', () => {
    alert(`${modes[modeSel.value].name}\n\n${modes[modeSel.value].description}\n\nPseudocode:\n${modes[modeSel.value].pseudocode}`);
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); step(); }
    if (e.key === 'p' || e.key === 'P') { playToggle(); }
    if (e.key === 'r' || e.key === 'R') { resetState(); }
  });

  // Init UI
  updateUIForMode();

  // Provide initial render of input array
  arrayInput.addEventListener('change', () => {
    const parsed = parseArray(arrayInput.value);
    if (!parsed) return;
    // quick preview
    arrayRow.innerHTML = '';
    parsed.forEach(v => {
      const d = document.createElement('div');
      d.className = 'cell';
      d.textContent = v;
      arrayRow.appendChild(d);
    });
  });
  // Trigger initial preview
  arrayInput.dispatchEvent(new Event('change'));

  // Explainers for each mode (small)
  extraInfo.innerHTML = `<div class="small">${modes[modeSel.value].description}</div>`;

  // Accessibility: resize behavior
  window.addEventListener('resize', render);
})();
</script>
</body>
</html>