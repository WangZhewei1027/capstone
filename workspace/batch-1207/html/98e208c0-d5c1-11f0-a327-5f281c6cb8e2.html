<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Counting Sort - Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --card:#071026;
      --accent:#60a5fa;
      --accent-2:#34d399;
      --muted:#94a3b8;
      --good:#10b981;
      --danger:#fb7185;
      --white:#e6eef6;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{
      margin:0;
      padding:20px;
      background:linear-gradient(180deg,var(--bg),#071027 120%);
      color:var(--white);
      min-height:100vh;
    }
    .container{
      max-width:1100px;
      margin:0 auto;
    }
    header{
      display:flex;
      align-items:center;
      gap:16px;
    }
    h1{margin:0;font-size:20px;}
    p.lead{margin:6px 0 18px;color:var(--muted);font-size:13px;}
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:16px;
      align-items:center;
    }
    .card{
      background:linear-gradient(180deg,var(--card),#071026 120%);
      border-radius:10px;
      padding:14px;
      box-shadow:0 6px 20px rgba(2,6,23,0.6);
    }
    .card.small{padding:10px;}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px;}
    input[type="text"]{background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:8px;border-radius:8px;min-width:260px;}
    button{
      background:linear-gradient(180deg,var(--accent),#2b76d8);
      color:white;border:0;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600;
    }
    button.secondary{background:linear-gradient(180deg,#7c8aa7,#56647e);font-weight:600;}
    button.warn{background:linear-gradient(180deg,var(--danger),#d05a73);}
    button:disabled{opacity:0.45;cursor:not-allowed}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
    .array-visual {display:flex;gap:6px;flex-wrap:wrap;padding:12px;align-items:flex-end;min-height:120px;}
    .box{
      width:48px;height:48px;border-radius:8px;background:linear-gradient(180deg,#082033,#061526);display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(255,255,255,0.04);position:relative;color:var(--white);font-weight:700;
      transition:transform 160ms ease, box-shadow 160ms ease, background 160ms;
    }
    .box.small{width:40px;height:40px;font-weight:600;}
    .box.index{font-weight:600;font-size:12px;color:var(--muted);height:auto;padding:6px 10px;border-radius:999px;background:transparent;border:0;}
    .box.active{transform:translateY(-8px);box-shadow:0 10px 30px rgba(80,144,255,0.18);background:linear-gradient(180deg,#1564ff,#103b9b);}
    .box.countActive{transform:translateY(-8px);box-shadow:0 10px 30px rgba(52,211,153,0.12);background:linear-gradient(180deg,#34d399,#0f8564);}
    .array-wrap{display:flex;flex-direction:column;gap:8px;}
    .label-row{display:flex;gap:6px;align-items:center;}
    .small-muted{font-size:12px;color:var(--muted)}
    .legend{display:flex;gap:8px;align-items:center;}
    .legend .sw{width:12px;height:12px;border-radius:3px;}
    .sw.active{background:#1564ff}
    .sw.count{background:#059669}
    .visual-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px;}
    .counts-row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    .index-label{font-size:12px;color:var(--muted);text-align:center;margin-bottom:6px;}
    .explain{margin-top:12px;color:var(--muted);font-size:13px;line-height:1.4}
    .stats{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;}
    .stat{background:linear-gradient(180deg,#081423,#071226);padding:8px 10px;border-radius:8px;font-size:13px;color:var(--muted)}
    .controls .number{min-width:40px;}
    .range-slider{display:flex;gap:8px;align-items:center}
    .footer{margin-top:18px;color:var(--muted);font-size:13px}
    pre.pseudocode{background:#061226;border-radius:8px;padding:10px;color:var(--muted);overflow:auto;font-size:13px}
    @media (max-width:880px){
      .visual-grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Counting Sort - Interactive Visualization</h1>
        <p class="lead">Step through a stable counting sort on integer arrays. Supports negative values by shifting the counts range automatically.</p>
      </div>
    </header>

    <div class="controls card">
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <div>
          <label>Array (comma or space separated integers)</label>
          <input id="arrInput" type="text" value="4, 2, -1, 3, 2, 4, 0, -1" />
        </div>

        <div>
          <label>Randomize</label>
          <div class="row">
            <input id="randLen" type="number" min="1" max="60" value="8" style="width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)"/>
            <input id="randMin" type="number" value="-2" style="width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)"/>
            <input id="randMax" type="number" value="5" style="width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)"/>
            <button id="btnRandom" class="secondary">Generate</button>
          </div>
        </div>

        <div>
          <label>Animation speed (ms per step)</label>
          <div class="range-slider">
            <input id="speed" type="range" min="10" max="1000" value="220" />
            <div class="small-muted" id="speedLabel">220 ms</div>
          </div>
        </div>

        <div style="margin-left:auto">
          <label>Controls</label>
          <div style="display:flex;gap:8px">
            <button id="btnStart">Run</button>
            <button id="btnPause" class="secondary" disabled>Pause</button>
            <button id="btnStep" class="secondary">Step</button>
            <button id="btnReset" class="warn">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div class="visual-grid">
      <div class="card">
        <div class="array-wrap">
          <div class="label-row">
            <div style="flex:1">
              <label>Input Array</label>
              <div class="small-muted">Left-to-right is the array order (index 0 .. n-1).</div>
            </div>
            <div class="legend">
              <div class="sw active"></div><div class="small-muted">Active element</div>
              <div style="width:12px"></div>
              <div class="sw count"></div><div class="small-muted">Counts active</div>
            </div>
          </div>

          <div id="inputArray" class="array-visual card small"></div>

          <div class="stats">
            <div class="stat">n = <span id="statN">0</span></div>
            <div class="stat">min = <span id="statMin">0</span></div>
            <div class="stat">max = <span id="statMax">0</span></div>
            <div class="stat">range = <span id="statRange">0</span></div>
            <div class="stat">stable = yes</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div>
          <label>Counts array (indices represent values)</label>
          <div class="small-muted">Index shown is actual value (shifted for negatives). Boxes show current counts / prefix sums during phases.</div>
          <div id="countsWrap" style="margin-top:12px;overflow:auto;padding-bottom:6px">
            <div id="countsIndices" class="counts-row"></div>
            <div id="countsValues" class="counts-row" style="margin-top:8px"></div>
          </div>

          <div style="margin-top:12px">
            <label>Output Array (sorted)</label>
            <div id="outputArray" class="array-visual card small" style="min-height:60px"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start">
        <div style="flex:1;min-width:300px">
          <label>Explanation</label>
          <div class="explain">
            Counting Sort sorts integers by counting how many of each value occur, then using prefix sums to compute positions. This demo:
            <ol>
              <li>Builds a counts array spanning min..max values (handles negatives by shifting).</li>
              <li>Tallies occurrences for each input element.</li>
              <li>Computes prefix sums (cumulative counts).</li>
              <li>Places elements into the output array by iterating the input from right-to-left (stable).</li>
            </ol>
            The sort is stable because we fill the output using counts and iterate inputs from end to start.
          </div>
        </div>

        <div style="min-width:320px">
          <label>Pseudocode (stable counting sort)</label>
          <pre class="pseudocode">
countingSort(A):
  minVal = min(A)
  k = max(A) - minVal + 1
  counts = array of zeros size k
  for x in A:
    counts[x - minVal]++
  for i in 1..k-1:
    counts[i] += counts[i-1]
  B = array of size len(A)
  for i from len(A)-1 down to 0:
    v = A[i]
    counts[v - minVal]--
    B[counts[v - minVal]] = v
  return B
          </pre>
        </div>
      </div>
    </div>

    <div class="footer">
      Tip: If the value range is very large, Counting Sort becomes inefficient in memory (counts size = range). This demo will prevent extremely large ranges.
    </div>
  </div>

  <script>
    // Interactive Counting Sort Demo
    (function(){
      const arrInput = document.getElementById('arrInput');
      const btnRandom = document.getElementById('btnRandom');
      const randLen = document.getElementById('randLen');
      const randMin = document.getElementById('randMin');
      const randMax = document.getElementById('randMax');
      const btnStart = document.getElementById('btnStart');
      const btnPause = document.getElementById('btnPause');
      const btnStep = document.getElementById('btnStep');
      const btnReset = document.getElementById('btnReset');
      const speed = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');

      const inputArrayDiv = document.getElementById('inputArray');
      const countsIndicesDiv = document.getElementById('countsIndices');
      const countsValuesDiv = document.getElementById('countsValues');
      const outputArrayDiv = document.getElementById('outputArray');

      const statN = document.getElementById('statN');
      const statMin = document.getElementById('statMin');
      const statMax = document.getElementById('statMax');
      const statRange = document.getElementById('statRange');

      let baseState = { arr: [], min:0, max:0, range:0, counts:[], output:[] };
      let gen = null;
      let running = false;
      let paused = false;
      let currentStep = null;
      let stepTimer = null;

      const MAX_RANGE = 200; // don't allow crazy ranges for visualization

      function parseArrayFromInput(){
        const s = arrInput.value.trim();
        if(!s) return [];
        // split on comma or whitespace
        const parts = s.split(/[\s,]+/).filter(p => p.length);
        const nums = parts.map(p => {
          const n = Number(p);
          return Number.isFinite(n) && Number.isInteger(n) ? n : NaN;
        });
        if (nums.some(isNaN)) {
          alert('Please enter only integers (comma or space separated).');
          return null;
        }
        return nums;
      }

      function renderAll(highlights = {}) {
        // highlights: {inputIndex, countIndex, outputIndex, phase}
        const arr = baseState.arr;
        const counts = baseState.counts;
        const output = baseState.output;
        const min = baseState.min;
        const max = baseState.max;
        inputArrayDiv.innerHTML = '';
        outputArrayDiv.innerHTML = '';

        // Input array boxes
        arr.forEach((v, i) => {
          const b = document.createElement('div');
          b.className = 'box';
          if (highlights.inputIndex === i && highlights.phase === 'count') b.classList.add('active');
          if (highlights.inputIndex === i && highlights.phase === 'place') b.classList.add('active');
          b.textContent = v;
          const idx = document.createElement('div');
          idx.style.position = 'absolute';
          idx.style.bottom = '-18px';
          idx.style.fontSize = '11px';
          idx.style.color = 'var(--muted)';
          idx.textContent = 'i=' + i;
          b.appendChild(idx);
          inputArrayDiv.appendChild(b);
        });

        // counts indices row (show actual value labels)
        countsIndicesDiv.innerHTML = '';
        countsValuesDiv.innerHTML = '';
        counts.forEach((c, j) => {
          const valIndex = document.createElement('div');
          valIndex.className = 'box index small';
          valIndex.textContent = (j + min);
          countsIndicesDiv.appendChild(valIndex);

          const valBox = document.createElement('div');
          valBox.className = 'box small';
          if (highlights.countIndex === j && highlights.phase === 'count') {
            valBox.classList.add('countActive');
          }
          if (highlights.countIndex === j && highlights.phase === 'prefix') {
            valBox.classList.add('countActive');
          }
          if (highlights.countIndex === j && highlights.phase === 'place') {
            // count being decremented to compute position
            valBox.classList.add('countActive');
          }
          valBox.textContent = c;
          const idx = document.createElement('div');
          idx.style.position = 'absolute';
          idx.style.bottom = '-18px';
          idx.style.fontSize = '11px';
          idx.style.color = 'var(--muted)';
          idx.textContent = 'idx';
          valBox.appendChild(idx);
          countsValuesDiv.appendChild(valBox);
        });

        // Output boxes
        output.forEach((v, i) => {
          const b = document.createElement('div');
          b.className = 'box';
          if (v === null || typeof v === 'undefined') {
            b.style.opacity = 0.18;
            b.textContent = '';
          } else {
            b.textContent = v;
          }
          if (highlights.outputIndex === i && highlights.phase === 'place') {
            b.classList.add('active');
          }
          const idx = document.createElement('div');
          idx.style.position = 'absolute';
          idx.style.bottom = '-18px';
          idx.style.fontSize = '11px';
          idx.style.color = 'var(--muted)';
          idx.textContent = 'pos=' + i;
          b.appendChild(idx);
          outputArrayDiv.appendChild(b);
        });

        // stats
        statN.textContent = arr.length;
        statMin.textContent = baseState.arr.length ? baseState.min : '-';
        statMax.textContent = baseState.arr.length ? baseState.max : '-';
        statRange.textContent = baseState.arr.length ? baseState.range : '-';
      }

      // Generator that yields step-by-step actions
      function* countingSortSteps(arr) {
        if (!Array.isArray(arr)) return;
        const n = arr.length;
        if (n === 0) {
          yield {phase:'done'};
          return;
        }
        let minVal = Math.min(...arr);
        let maxVal = Math.max(...arr);
        let range = maxVal - minVal + 1;
        if (range > MAX_RANGE) {
          throw new Error(`Range too large for visualization (${range} > ${MAX_RANGE}). Choose a tighter range.`);
        }
        // init
        const counts = new Array(range).fill(0);
        const output = new Array(n).fill(null);

        // expose initial
        baseState.min = minVal;
        baseState.max = maxVal;
        baseState.range = range;
        baseState.counts = counts;
        baseState.output = output;
        yield {phase:'init'};

        // Tally counts
        for (let i = 0; i < n; i++) {
          const v = arr[i];
          const idx = v - minVal;
          // highlight input i and count idx
          yield {phase:'count', inputIndex:i, countIndex: idx};
          counts[idx] += 1;
          // reflect update
          baseState.counts = counts.slice();
          yield {phase:'afterCount', inputIndex:i, countIndex: idx};
        }

        // Prefix sums (cumulative)
        for (let j = 1; j < counts.length; j++) {
          yield {phase:'prefix', countIndex: j};
          counts[j] += counts[j-1];
          baseState.counts = counts.slice();
          yield {phase:'afterPrefix', countIndex: j};
        }

        // Place into output array, iterating input from right to left for stability
        for (let i = n - 1; i >= 0; i--) {
          const v = arr[i];
          const idx = v - minVal;
          yield {phase:'place', inputIndex:i, countIndex: idx};
          counts[idx] -= 1;
          const pos = counts[idx];
          output[pos] = v;
          baseState.counts = counts.slice();
          baseState.output = output.slice();
          yield {phase:'afterPlace', inputIndex:i, outputIndex: pos, countIndex: idx};
        }

        // done
        yield {phase:'done'};
      }

      // Control logic for stepping and running
      async function runAuto(){
        if (!gen) return;
        running = true;
        paused = false;
        updateButtons();
        try {
          while (true) {
            const res = gen.next();
            if (res.done) break;
            const step = res.value;
            applyStep(step);
            if (step.phase === 'done') break;
            await sleep(Number(speed.value));
            if (paused) break;
          }
        } catch (err) {
          alert('Error: ' + err.message);
          running = false;
          paused = true;
        }
        running = false;
        updateButtons();
      }

      function stepOnce(){
        if (!gen) return;
        try {
          const res = gen.next();
          if (!res.done) {
            applyStep(res.value);
          } else {
            applyStep({phase:'done'});
          }
        } catch (err) {
          alert('Error: ' + err.message);
          running = false;
          paused = true;
          updateButtons();
        }
      }

      function applyStep(step){
        // Update baseState and visuals according to yielded step.
        currentStep = step;
        const highlights = {
          inputIndex: step.inputIndex,
          countIndex: step.countIndex,
          outputIndex: step.outputIndex,
          phase: step.phase
        };
        // baseState has been updated inside generator for arrays; just render
        renderAll(highlights);
        // If done, collapse run state
        if (step.phase === 'done') {
          running = false;
          paused = false;
          updateButtons();
        }
      }

      function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

      function updateButtons(){
        btnStart.disabled = running || paused;
        btnPause.disabled = !running;
        btnStep.disabled = running;
        btnReset.disabled = running;
        arrInput.disabled = running;
        btnRandom.disabled = running;
        randLen.disabled = running;
        randMin.disabled = running;
        randMax.disabled = running;

        if (running) {
          btnStart.textContent = 'Running...';
          btnPause.textContent = 'Pause';
          btnPause.classList.remove('secondary');
          btnPause.classList.add('warn');
        } else {
          btnStart.textContent = 'Run';
          btnPause.classList.remove('warn');
          btnPause.classList.add('secondary');
        }
      }

      // Initialization and event wiring
      btnRandom.addEventListener('click', () => {
        const len = Math.max(1, Math.min(60, parseInt(randLen.value) || 8));
        const lo = parseInt(randMin.value) || 0;
        const hi = parseInt(randMax.value) || (lo + 5);
        if (hi < lo) {
          alert('randMax should be >= randMin');
          return;
        }
        const out = [];
        for (let i = 0; i < len; i++){
          const v = Math.floor(Math.random() * (hi - lo + 1)) + lo;
          out.push(v);
        }
        arrInput.value = out.join(', ');
        prepareFromInput();
      });

      speed.addEventListener('input', () => {
        speedLabel.textContent = speed.value + ' ms';
      });

      btnStart.addEventListener('click', async () => {
        if (running) return;
        if (paused) {
          // resume
          paused = false;
          running = true;
          updateButtons();
          await runAuto();
          return;
        }
        // fresh start
        const parsed = parseArrayFromInput();
        if (parsed === null) return;
        const [ok, errMsg] = prepareFromParsed(parsed);
        if (!ok) {
          alert(errMsg);
          return;
        }
        gen = countingSortSteps(baseState.arr.slice());
        // kick off
        await runAuto();
      });

      btnPause.addEventListener('click', () => {
        if (!running) return;
        paused = true;
        running = false;
        updateButtons();
      });

      btnStep.addEventListener('click', () => {
        if (running) return;
        const parsed = parseArrayFromInput();
        if (!gen) {
          // initialize generator if not present
          if (parsed === null) return;
          const [ok, errMsg] = prepareFromParsed(parsed);
          if (!ok) {
            alert(errMsg);
            return;
          }
          gen = countingSortSteps(baseState.arr.slice());
        }
        stepOnce();
      });

      btnReset.addEventListener('click', () => {
        running = false;
        paused = false;
        gen = null;
        currentStep = null;
        prepareFromInput();
        updateButtons();
      });

      // Prepare state from input field and render initial visuals
      function prepareFromInput(){
        const parsed = parseArrayFromInput();
        if (parsed === null) return;
        const [ok, errMsg] = prepareFromParsed(parsed);
        if (!ok) {
          alert(errMsg);
          return;
        }
        gen = null;
        renderAll({});
        updateButtons();
      }

      function prepareFromParsed(parsed){
        if (!parsed) parsed = [];
        // Validate range
        if (parsed.length > 0) {
          const minVal = Math.min(...parsed);
          const maxVal = Math.max(...parsed);
          const range = maxVal - minVal + 1;
          if (range > MAX_RANGE) {
            return [false, `The value range (${range}) is too large for visualization. Keep range <= ${MAX_RANGE}.`];
          }
          baseState.arr = parsed.slice();
          baseState.min = minVal;
          baseState.max = maxVal;
          baseState.range = range;
          baseState.counts = new Array(range).fill(0);
          baseState.output = new Array(parsed.length).fill(null);
        } else {
          baseState.arr = [];
          baseState.min = 0;
          baseState.max = 0;
          baseState.range = 0;
          baseState.counts = [];
          baseState.output = [];
        }
        return [true, null];
      }

      // On load, prepare initial example
      prepareFromInput();

      // Allow pressing Enter in the array input to reset visuals
      arrInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          prepareFromInput();
        }
      });

      // small helper: resize counts area if it's wide - already handled by overflow:auto

    })();
  </script>
</body>
</html>