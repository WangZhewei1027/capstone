<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Deque (Double-Ended Queue) Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#60a5fa; --muted:#94a3b8; --good:#10b981; --danger:#ef4444;
      --cell:#071028; --cell-border:#18324a;
    }
    body{
      margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:linear-gradient(180deg, #071029 0%, #071120 100%); color:#e6eef8;
      display:flex; min-height:100vh; align-items:center; justify-content:center; padding:28px;
    }
    .app{
      width:100%; max-width:1100px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border:1px solid rgba(255,255,255,0.03); border-radius:12px; padding:18px; box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      display:grid; grid-template-columns: 420px 1fr; gap:18px;
    }
    h1{ margin:0 0 6px 0; font-size:20px; color:#eaf2ff; }
    p.lead{ margin:0 0 12px 0; color:var(--muted); font-size:13px; }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .controls{ display:flex; flex-direction:column; gap:10px; }
    .row{ display:flex; gap:8px; align-items:center; }
    input[type="text"]{ padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }
    button{
      padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); color:inherit;
      cursor:pointer; font-weight:600;
    }
    button.primary{ background:linear-gradient(180deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06)); border-color:rgba(96,165,250,0.18); color:var(--accent); }
    button.warn{ background:linear-gradient(180deg, rgba(239,68,68,0.08), rgba(239,68,68,0.03)); border-color:rgba(239,68,68,0.12); color:var(--danger); }
    button.ghost{ background:transparent; border:1px dashed rgba(255,255,255,0.03); color:var(--muted); font-weight:500; }
    .info{ font-size:13px; color:var(--muted); }
    .buffer-visual{ display:flex; gap:6px; flex-wrap:wrap; padding:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:8px; border:1px solid rgba(255,255,255,0.02); }
    .cell{
      width:64px; height:56px; background:linear-gradient(180deg, var(--cell), rgba(8,12,24,0.4)); border-radius:8px; display:flex; align-items:center; justify-content:center;
      border:1px solid var(--cell-border); position:relative; color:#cfe8ff; font-weight:700; font-size:14px;
    }
    .cell.empty{ color:var(--muted); font-weight:600; opacity:0.6; }
    .label{ position:absolute; top:6px; left:6px; font-size:11px; color:var(--muted); font-weight:600; }
    .marker{ position:absolute; bottom:6px; right:6px; font-size:11px; padding:3px 6px; border-radius:999px; background:rgba(255,255,255,0.03); color:var(--muted); }
    .marker.head{ background:linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06)); color:var(--accent); font-weight:700; border:1px solid rgba(96,165,250,0.06);}
    .marker.tail{ background:linear-gradient(90deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03)); color:var(--good); font-weight:700; border:1px solid rgba(16,185,129,0.04);}
    .controls-grid{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .log{ max-height:240px; overflow:auto; padding:8px; background:rgba(0,0,0,0.06); border-radius:8px; color:var(--muted); font-size:13px; border:1px solid rgba(255,255,255,0.02); }
    .status{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .badge{ padding:6px 8px; background:rgba(255,255,255,0.02); border-radius:8px; font-size:13px; color:var(--muted); border:1px solid rgba(255,255,255,0.02); }
    .legend{ display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; }
    .legend .sw{ width:12px; height:12px; border-radius:2px; display:inline-block; margin-right:6px; }
    .note{ font-size:12px; color:var(--muted); margin-top:8px; }
    footer{ grid-column:1/-1; margin-top:12px; color:var(--muted); font-size:13px; display:flex; justify-content:space-between; align-items:center; }
    @media(max-width:900px){
      .app{ grid-template-columns: 1fr; }
      .cell{ width:46px; height:48px; font-size:13px;}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Deque demonstration">
    <div class="panel">
      <h1>Deque (Double-Ended Queue)</h1>
      <p class="lead">A deque allows inserting and removing elements from both ends. This demo uses a circular buffer implementation that grows when needed.</p>

      <div class="controls">
        <div class="row">
          <input id="valueInput" type="text" placeholder="value (e.g. 42 or text)" />
          <button id="pushFrontBtn" class="primary">Push Front</button>
          <button id="pushBackBtn" class="primary">Push Back</button>
        </div>

        <div class="row">
          <button id="popFrontBtn">Pop Front</button>
          <button id="popBackBtn">Pop Back</button>
          <button id="peekFrontBtn" class="ghost">Peek Front</button>
          <button id="peekBackBtn" class="ghost">Peek Back</button>
        </div>

        <div class="row">
          <button id="clearBtn" class="warn">Clear</button>
          <button id="fillRandomBtn">Fill Random (6)</button>
          <button id="randomWalkBtn">Random Walk (auto)</button>
        </div>

        <div class="row">
          <div class="status">
            <div class="badge">Size: <span id="sizeBadge">0</span></div>
            <div class="badge">Capacity: <span id="capBadge">8</span></div>
            <div class="badge">Head: <span id="headBadge">0</span></div>
            <div class="badge">Tail: <span id="tailBadge">0</span></div>
          </div>
        </div>

        <div class="note">Tip: Try pushing front/back and observe head/tail positions and how the circular buffer uses empty slots. Capacity doubles when full.</div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex; gap:12px; align-items:center; margin-bottom:10px;">
        <div style="flex:1;">
          <div class="buffer-visual" id="bufferVisual" aria-live="polite"></div>
        </div>
      </div>

      <div style="display:flex; gap:12px;">
        <div style="flex:1;">
          <div class="info" style="margin-bottom:8px;">Logical contents (front ‚Üí back):</div>
          <div class="panel" id="logicalView" style="min-height:44px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;"></div>
        </div>

        <div style="width:260px;">
          <div style="margin-bottom:8px;" class="info">Operation log</div>
          <div class="log" id="opLog" aria-live="polite"></div>
        </div>
      </div>

      <footer>
        <div class="legend">
          <div><span class="sw" style="background:linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06)); border:1px solid rgba(96,165,250,0.06)"></span> head</div>
          <div><span class="sw" style="background:linear-gradient(90deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03)); border:1px solid rgba(16,185,129,0.04)"></span> tail</div>
          <div style="margin-left:16px; color:var(--muted);">Circular buffer with dynamic resize</div>
        </div>
        <div style="color:var(--muted)">Implemented in JavaScript ‚Ä¢ Interactive</div>
      </footer>
    </div>
  </div>

  <script>
    // Deque implemented with circular buffer + resizing
    class Deque {
      constructor(initialCapacity = 8) {
        const cap = Math.max(4, Math.ceil(initialCapacity));
        this._cap = this._nextPow2(cap);
        this._buf = new Array(this._cap).fill(undefined);
        this._head = 0; // index of first element
        this._size = 0;
      }

      _nextPow2(n){
        return 1 << Math.ceil(Math.log2(n));
      }

      size(){ return this._size; }
      capacity(){ return this._cap; }
      isEmpty(){ return this._size === 0; }

      _idx(i){ // logical index -> physical index
        return (this._head + i) & (this._cap - 1);
      }

      _growIfNeeded(){
        if (this._size < this._cap) return;
        const newCap = this._cap * 2;
        const newBuf = new Array(newCap);
        // copy in logical order
        for (let i=0;i<this._size;i++){
          newBuf[i] = this._buf[this._idx(i)];
        }
        this._buf = newBuf;
        this._cap = newCap;
        this._head = 0;
      }

      pushBack(value){
        this._growIfNeeded();
        const tailIdx = this._idx(this._size);
        this._buf[tailIdx] = value;
        this._size++;
        return this._size;
      }

      pushFront(value){
        this._growIfNeeded();
        // move head backward
        this._head = (this._head - 1) & (this._cap - 1);
        this._buf[this._head] = value;
        this._size++;
        return this._size;
      }

      popBack(){
        if (this._size === 0) return undefined;
        const lastIdx = this._idx(this._size - 1);
        const val = this._buf[lastIdx];
        this._buf[lastIdx] = undefined;
        this._size--;
        return val;
      }

      popFront(){
        if (this._size === 0) return undefined;
        const val = this._buf[this._head];
        this._buf[this._head] = undefined;
        this._head = (this._head + 1) & (this._cap - 1);
        this._size--;
        return val;
      }

      peekFront(){
        if (this._size===0) return undefined;
        return this._buf[this._head];
      }

      peekBack(){
        if (this._size===0) return undefined;
        return this._buf[this._idx(this._size-1)];
      }

      clear(){
        this._buf = new Array(this._cap).fill(undefined);
        this._head = 0;
        this._size = 0;
      }

      toArray(){
        const arr = [];
        for (let i=0;i<this._size;i++) arr.push(this._buf[this._idx(i)]);
        return arr;
      }

      rawBuffer(){ // for visualization: returns copy of internal buffer
        return this._buf.slice();
      }

      headIndex(){ return this._head; }
      tailIndex(){ return this._idx(this._size); } // index of where next pushBack would write
    }

    // Simple UI wiring and visualization
    const dq = new Deque(8);

    const bufferVisual = document.getElementById('bufferVisual');
    const logicalView = document.getElementById('logicalView');
    const opLog = document.getElementById('opLog');
    const sizeBadge = document.getElementById('sizeBadge');
    const capBadge = document.getElementById('capBadge');
    const headBadge = document.getElementById('headBadge');
    const tailBadge = document.getElementById('tailBadge');

    const valueInput = document.getElementById('valueInput');
    const pushFrontBtn = document.getElementById('pushFrontBtn');
    const pushBackBtn = document.getElementById('pushBackBtn');
    const popFrontBtn = document.getElementById('popFrontBtn');
    const popBackBtn = document.getElementById('popBackBtn');
    const peekFrontBtn = document.getElementById('peekFrontBtn');
    const peekBackBtn = document.getElementById('peekBackBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fillRandomBtn = document.getElementById('fillRandomBtn');
    const randomWalkBtn = document.getElementById('randomWalkBtn');

    function log(msg, cls){
      const time = new Date().toLocaleTimeString();
      const el = document.createElement('div');
      el.textContent = `[${time}] ${msg}`;
      if (cls) el.style.color = cls;
      opLog.prepend(el);
    }

    function render(highlight = {}) {
      // highlight: {type:"head"|"tail"|"idx", idx: number}
      bufferVisual.innerHTML = '';
      logicalView.innerHTML = '';

      const buf = dq.rawBuffer();
      const cap = dq.capacity();
      const head = dq.headIndex();
      const tail = dq.tailIndex();
      const size = dq.size();

      capBadge.textContent = cap;
      sizeBadge.textContent = size;
      headBadge.textContent = head;
      tailBadge.textContent = tail;

      for (let i=0;i<cap;i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        const val = buf[i];
        if (val === undefined){
          cell.classList.add('empty');
          cell.textContent = '‚Äî';
        } else {
          cell.textContent = String(val);
        }
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = i;
        cell.appendChild(label);

        if (i === head) {
          const m = document.createElement('div'); m.className = 'marker head'; m.textContent = 'head';
          cell.appendChild(m);
        }
        // For tail marker, show the index where next pushBack would write.
        if (i === tail) {
          const m = document.createElement('div'); m.className = 'marker tail'; m.textContent = 'tail';
          cell.appendChild(m);
        }

        // highlight if requested
        if (highlight.type === 'idx' && highlight.idx === i) {
          cell.style.boxShadow = 'inset 0 0 0 3px rgba(96,165,250,0.08)';
          cell.style.borderColor = 'rgba(96,165,250,0.12)';
        }
        if (highlight.type === 'head' && i===head){
          cell.style.border = '2px solid rgba(96,165,250,0.18)';
        }
        if (highlight.type === 'tail' && i===tail){
          cell.style.border = '2px solid rgba(16,185,129,0.12)';
        }

        bufferVisual.appendChild(cell);
      }

      const logical = dq.toArray();
      if (logical.length === 0){
        const empty = document.createElement('div');
        empty.className = 'info';
        empty.textContent = '(empty)';
        logicalView.appendChild(empty);
      } else {
        logical.forEach((v, idx) => {
          const el = document.createElement('div');
          el.style.padding = '8px 10px';
          el.style.borderRadius = '8px';
          el.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), transparent)';
          el.style.border = '1px solid rgba(255,255,255,0.02)';
          el.style.fontWeight = '700';
          el.textContent = String(v);
          if (idx === 0){
            const s = document.createElement('span'); s.style.fontWeight=600; s.style.marginLeft='8px'; s.style.fontSize='12px'; s.style.color='var(--muted)'; s.textContent='(front)';
            el.appendChild(s);
          }
          logicalView.appendChild(el);
        });
      }
    }

    // safe read value (string) - attempt to parse number if looks numeric
    function readValue(){
      const raw = valueInput.value.trim();
      if (raw === '') return null;
      // detect JSON-ish
      if (/^-?\d+(\.\d+)?$/.test(raw)) return Number(raw);
      try {
        return JSON.parse(raw);
      } catch {
        return raw;
      }
    }

    // button handlers with light animation
    function pushFront(){
      const v = readValue();
      if (v === null) { log('No value provided to pushFront', 'orange'); return; }
      dq.pushFront(v);
      log(`pushFront(${JSON.stringify(v)})`);
      render({type:'head', idx:dq.headIndex()});
    }
    function pushBack(){
      const v = readValue();
      if (v === null) { log('No value provided to pushBack', 'orange'); return; }
      dq.pushBack(v);
      log(`pushBack(${JSON.stringify(v)})`);
      render({type:'tail', idx:dq.tailIndex()});
    }
    function popFront(){
      const v = dq.popFront();
      log(`popFront() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
      render({type:'head', idx:dq.headIndex()});
    }
    function popBack(){
      const v = dq.popBack();
      log(`popBack() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
      render({type:'tail', idx:dq.tailIndex()});
    }
    function peekFront(){
      const v = dq.peekFront();
      log(`peekFront() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
      render({type:'head', idx:dq.headIndex()});
    }
    function peekBack(){
      const v = dq.peekBack();
      log(`peekBack() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
      render({type:'tail', idx:dq.tailIndex()});
    }
    function clear(){
      dq.clear();
      log('clear()');
      render();
    }
    function fillRandom(n=6){
      const sample = ['A','B','C','D','E','F','G','H','üçé','üçã','üåü'];
      for (let i=0;i<n;i++){
        const val = sample[Math.floor(Math.random()*sample.length)] + (Math.random()<0.4 ? Math.floor(Math.random()*99) : '');
        if (Math.random() < 0.5) dq.pushBack(val); else dq.pushFront(val);
      }
      log(`fillRandom(${n})`);
      render();
    }

    // Random walk: perform random ops for a while, animate
    let randomWalkTimer = null;
    function startRandomWalk(){
      if (randomWalkTimer !== null) {
        clearInterval(randomWalkTimer);
        randomWalkTimer = null;
        randomWalkBtn.textContent = 'Random Walk (auto)';
        log('Random walk stopped');
        return;
      }
      randomWalkBtn.textContent = 'Stop Random Walk';
      log('Random walk started');
      randomWalkTimer = setInterval(() => {
        const r = Math.random();
        if (r < 0.28){
          // pushFront
          const v = Math.random()<0.5 ? Math.floor(Math.random()*100) : String.fromCharCode(65 + Math.floor(Math.random()*26));
          dq.pushFront(v);
          log(`pushFront(${JSON.stringify(v)})`);
        } else if (r < 0.56){
          const v = Math.random()<0.5 ? Math.floor(Math.random()*100) : String.fromCharCode(65 + Math.floor(Math.random()*26));
          dq.pushBack(v);
          log(`pushBack(${JSON.stringify(v)})`);
        } else if (r < 0.78){
          const v = dq.popFront();
          log(`popFront() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
        } else {
          const v = dq.popBack();
          log(`popBack() ‚Üí ${v === undefined ? 'undefined' : JSON.stringify(v)}`);
        }
        render();
      }, 450);
    }

    // wiring
    pushFrontBtn.addEventListener('click', () => { pushFront(); });
    pushBackBtn.addEventListener('click', () => { pushBack(); });
    popFrontBtn.addEventListener('click', () => { popFront(); });
    popBackBtn.addEventListener('click', () => { popBack(); });
    peekFrontBtn.addEventListener('click', () => { peekFront(); });
    peekBackBtn.addEventListener('click', () => { peekBack(); });
    clearBtn.addEventListener('click', () => { clear(); });
    fillRandomBtn.addEventListener('click', () => { fillRandom(6); });
    randomWalkBtn.addEventListener('click', () => { startRandomWalk(); });

    // allow Enter key to pushBack by default
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') pushBack();
    });

    // initial render and example
    log('Deque demo ready. Try operations on the left.');
    render();

    // Accessibility: focus the input on load
    window.requestAnimationFrame(() => valueInput.focus());
  </script>
</body>
</html>