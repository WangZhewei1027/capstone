<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Depth-First Search (DFS) Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin-bottom: 5px;
  }
  #graph {
    margin-top: 20px;
    border: 1px solid #ccc;
    background-color: #fafafa;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
    max-width: 600px;
    justify-content: center;
  }
  label {
    font-weight: bold;
  }
  input[type="number"] {
    width: 50px;
  }
  button {
    cursor: pointer;
    padding: 8px 16px;
    border: none;
    border-radius: 5px;
    background-color: #4a90e2;
    color: white;
    font-size: 1rem;
    transition: background-color 0.3s ease;
  }
  button:hover:not(:disabled) {
    background-color: #357abd;
  }
  button:disabled {
    background-color: #999;
    cursor: default;
  }
  #log {
    margin-top: 20px;
    width: 600px;
    max-height: 150px;
    overflow-y: auto;
    border: 1px solid #ddd;
    background: white;
    padding: 8px;
    font-family: monospace;
    font-size: 0.9rem;
  }
  svg {
    overflow: visible;
  }
  .node {
    cursor: pointer;
    transition: fill 0.3s;
  }
  .node circle {
    stroke: #666;
    stroke-width: 2px;
  }
  .node.unvisited circle {
    fill: white;
    stroke: #666;
  }
  .node.visiting circle {
    fill: #f4d35e;
    stroke: #f4d35e;
  }
  .node.visited circle {
    fill: #61c0bf;
    stroke: #247f7f;
  }
  .edge {
    stroke: #999;
    stroke-width: 2px;
    fill: none;
    transition: stroke 0.3s;
  }
  .edge.visiting {
    stroke: #f4d35e;
    stroke-width: 3px;
  }
  .edge.visited {
    stroke: #61c0bf;
    stroke-width: 3px;
  }
  #instructions {
    max-width: 600px;
    text-align: center;
    margin-top: 10px;
    font-size: 0.9rem;
    color: #555;
  }
</style>
</head>
<body>
<h1>Depth-First Search (DFS) Visualization</h1>
<div id="instructions">
  Click on a node to choose the <strong>start node</strong>. Then press "Start DFS" to see the algorithm explore the graph step-by-step.
</div>
<div id="controls">
  <label for="nodeCount">Number of nodes (3-10): </label>
  <input type="number" id="nodeCount" min="3" max="10" value="6" />
  <button id="generateBtn">Generate New Graph</button>
  <button id="startBtn" disabled>Start DFS</button>
  <button id="resetBtn" disabled>Reset</button>
</div>
<svg id="graph" width="600" height="500" aria-label="Graph visualization"></svg>
<div id="log" aria-live="polite" aria-atomic="true" role="log"></div>
<script>
(() => {
  const svg = document.getElementById('graph');
  const nodeCountInput = document.getElementById('nodeCount');
  const generateBtn = document.getElementById('generateBtn');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const log = document.getElementById('log');

  const width = 600;
  const height = 500;
  const radius = 20;

  let graph = {};
  let adjacencyList = {};
  let nodes = [];
  let edges = [];
  let startNode = null;
  let dfsStack = [];
  let visited = new Set();
  let dfsInterval = null;

  // Helpers
  function logMessage(msg) {
    const time = new Date().toLocaleTimeString();
    log.innerHTML += `[${time}] ${msg}<br/>`;
    log.scrollTop = log.scrollHeight;
  }

  function clearLog() {
    log.innerHTML = '';
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate a random undirected connected graph using a simple algorithm:
  // 1) Create a chain connecting all nodes to ensure connectivity.
  // 2) Add some random edges.
  function generateGraph(n) {
    adjacencyList = {};
    nodes = [];
    edges = [];
    for (let i = 0; i < n; i++) {
      adjacencyList[i] = new Set();
    }

    // Positions on circle
    const angleStep = (2 * Math.PI) / n;
    for (let i = 0; i < n; i++) {
      const angle = i * angleStep - Math.PI / 2;
      const x = width / 2 + Math.cos(angle) * (height / 2 - 60);
      const y = height / 2 + Math.sin(angle) * (height / 2 - 60);
      nodes.push({ id: i, x, y, state: 'unvisited' }); // state: unvisited, visiting, visited
    }
    // 1) Connect in a chain to ensure connectivity
    for (let i = 0; i < n - 1; i++) {
      adjacencyList[i].add(i + 1);
      adjacencyList[i + 1].add(i);
    }
    edges.push(
      ...Array.from({ length: n - 1 }, (_, i) => ({
        source: i,
        target: i + 1,
        state: 'unvisited', // unvisited, visiting, visited
      }))
    );

    // 2) Add some random edges
    const extraEdgesCount = Math.min(n, 3 + randInt(0, 3));
    let tries = 0;
    while (edges.length < n - 1 + extraEdgesCount && tries < 30) {
      const a = randInt(0, n - 1);
      const b = randInt(0, n - 1);
      if (a !== b && !adjacencyList[a].has(b)) {
        adjacencyList[a].add(b);
        adjacencyList[b].add(a);
        edges.push({ source: a, target: b, state: 'unvisited' });
      }
      tries++;
    }
  }

  // Draw the graph in svg
  function drawGraph() {
    // Clear svg
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // Draw edges
    edges.forEach((edge, i) => {
      const sourceNode = nodes[edge.source];
      const targetNode = nodes[edge.target];
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', sourceNode.x);
      line.setAttribute('y1', sourceNode.y);
      line.setAttribute('x2', targetNode.x);
      line.setAttribute('y2', targetNode.y);
      line.classList.add('edge', edge.state);
      line.setAttribute('data-edge-index', i);
      svg.appendChild(line);
    });

    // Draw nodes
    nodes.forEach((node) => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.classList.add('node', node.state);
      g.setAttribute('tabindex', '0');
      g.setAttribute('role', 'button');
      g.setAttribute('aria-label', `Node ${node.id}${startNode === node.id ? ' (start node)' : ''}`);
      g.setAttribute('data-node-id', node.id);
      g.style.transform = `translate(${node.x}px, ${node.y}px)`;
      // Circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('r', radius);
      circle.setAttribute('cx', 0);
      circle.setAttribute('cy', 0);
      g.appendChild(circle);
      // Text
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 0);
      text.setAttribute('y', 5);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-weight', 'bold');
      text.textContent = node.id;
      g.appendChild(text);

      svg.appendChild(g);
    });
  }

  // Update nodes and edges classes for visualization
  function updateVisualization() {
    const nodeElements = svg.querySelectorAll('.node');
    nodeElements.forEach((el) => {
      const id = Number(el.getAttribute('data-node-id'));
      const nodeObj = nodes[id];
      el.className.baseVal = 'node ' + nodeObj.state;
      el.setAttribute('aria-label', `Node ${id}${startNode === id ? ' (start node)' : ''}`);
    });
    const edgeElements = svg.querySelectorAll('.edge');
    edgeElements.forEach((el) => {
      const index = Number(el.getAttribute('data-edge-index'));
      el.className.baseVal = 'edge ' + edges[index].state;
    });
  }

  // Find edge object index between two nodes (undirected)
  function findEdgeIndex(a, b) {
    return edges.findIndex(
      (e) =>
        (e.source === a && e.target === b) || (e.source === b && e.target === a)
    );
  }

  function resetStates() {
    visited = new Set();
    dfsStack = [];
    nodes.forEach((node) => (node.state = 'unvisited'));
    edges.forEach((edge) => (edge.state = 'unvisited'));
    updateVisualization();
  }

  function handleNodeClick(e) {
    if (dfsStack.length > 0) return; // Disable changing start node during run
    const target = e.currentTarget;
    const nodeId = Number(target.getAttribute('data-node-id'));
    if (startNode !== null) {
      nodes[startNode].state = 'unvisited';
    }
    startNode = nodeId;
    nodes[startNode].state = 'visiting';
    updateVisualization();
    startBtn.disabled = false;
    logMessage(`Start node selected: Node ${startNode}`);
  }

  async function runDFS() {
    if (startNode === null) return;
    startBtn.disabled = true;
    generateBtn.disabled = true;
    nodeCountInput.disabled = true;
    resetBtn.disabled = false;

    resetStates();
    nodes[startNode].state = 'visiting';
    updateVisualization();
    logMessage(`Starting DFS from node ${startNode}`);

    const stack = [startNode];
    visited.add(startNode);

    while (stack.length > 0) {
      const current = stack[stack.length - 1];
      const currentNode = nodes[current];
      currentNode.state = 'visiting';
      updateVisualization();

      // Find unvisited neighbors
      const neighbors = Array.from(adjacencyList[current]).filter((n) => !visited.has(n));

      if (neighbors.length === 0) {
        // Mark node visited, pop stack
        currentNode.state = 'visited';
        logMessage(`Visited node ${current}`);
        stack.pop();
        updateVisualization();
        await delay(800);
      } else {
        const next = neighbors[0];
        // Mark edge visiting
        const edgeIndex = findEdgeIndex(current, next);
        if (edgeIndex !== -1) {
          edges[edgeIndex].state = 'visiting';
          updateVisualization();
          logMessage(`Exploring edge (${current} â†’ ${next})`);
        }

        await delay(800);

        visited.add(next);
        stack.push(next);
        nodes[next].state = 'visiting';

        if (edgeIndex !== -1) {
          edges[edgeIndex].state = 'visited';
        }
        updateVisualization();
        logMessage(`Discovered node ${next}`);
        await delay(800);
      }
    }
    logMessage('DFS Complete.');
    startBtn.disabled = true;
    generateBtn.disabled = false;
    nodeCountInput.disabled = false;
  }

  function delay(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }

  // Reset everything, allow new graph generation or DFS start
  function reset() {
    clearTimeout(dfsInterval);
    dfsInterval = null;
    startNode = null;
    resetBtn.disabled = true;
    startBtn.disabled = true;
    generateBtn.disabled = false;
    nodeCountInput.disabled = false;
    clearLog();
    nodes.forEach((node) => (node.state = 'unvisited'));
    edges.forEach((edge) => (edge.state = 'unvisited'));
    updateVisualization();
  }

  // Init
  function init() {
    generateGraph(Number(nodeCountInput.value));
    clearLog();
    drawGraph();
    updateVisualization();

    startNode = null;
    startBtn.disabled = true;
    resetBtn.disabled = true;
  }

  // Event listeners
  generateBtn.addEventListener('click', () => {
    reset();
    generateGraph(Number(nodeCountInput.value));
    drawGraph();
    updateVisualization();
  });

  startBtn.addEventListener('click', async () => {
    await runDFS();
  });

  resetBtn.addEventListener('click', () => {
    reset();
  });

  // Add click handlers on nodes (delegation after graph draw)
  function addNodeClickHandlers() {
    const nodeElements = svg.querySelectorAll('.node');
    nodeElements.forEach((el) => {
      el.addEventListener('click', handleNodeClick);
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          handleNodeClick.call(el, e);
        }
      });
    });
  }

  // After graph draw
  function refreshHandlers() {
    addNodeClickHandlers();
  }

  nodeCountInput.addEventListener('change', (e) => {
    let val = Number(e.target.value);
    if (val < 3) val = 3;
    if (val > 10) val = 10;
    e.target.value = val;
  });

  // After generating or regenerating graph: reset and add handlers
  generateBtn.addEventListener('click', () => {
    setTimeout(refreshHandlers, 50);
  });

  // Initial load
  init();
  refreshHandlers();
})();
</script>
</body>
</html>