<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Heap (Min / Max) Interactive Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#06b6d4;
    --muted:#94a3b8;
    --good:#16a34a;
    --danger:#ef4444;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;}
  body{
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,var(--bg),#071028 40%);
    color:#e6eef6;
    padding:20px;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    display:grid;
    grid-template-columns: 420px 1fr;
    gap:18px;
  }

  .panel{
    background:linear-gradient(180deg,var(--card), rgba(255,255,255,0.02));
    border-radius:12px;
    padding:16px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
  }
  .controls h2{
    margin:0 0 8px 0;
    font-size:18px;
    letter-spacing:0.2px;
  }
  .row{
    display:flex;
    gap:8px;
    align-items:center;
    margin-bottom:10px;
    flex-wrap:wrap;
  }
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;}
  select,input[type=number],input[type=text]{
    padding:8px 10px;
    border-radius:8px;
    border:none;
    background:var(--glass);
    color:inherit;
    outline: none;
    min-width:0;
  }
  button{
    padding:8px 10px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.06);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    color:inherit;
    cursor:pointer;
  }
  button.primary{
    background:linear-gradient(180deg,var(--accent),#0891b2);
    border:none;
    color:#072024;
    font-weight:600;
  }
  button.warn{
    background:linear-gradient(180deg,#f97316,#ea580c);
    border:none;
    color:white;
  }
  .small{font-size:13px;padding:6px 8px;border-radius:6px;}
  .muted{color:var(--muted);font-size:13px;}
  .big{
    display:flex;
    gap:12px;
    align-items:center;
  }

  /* array view */
  .array-view{
    display:flex;
    gap:8px;
    align-items:flex-end;
    padding:12px 6px;
    overflow:auto;
  }
  .box{
    min-width:46px;
    height:48px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border:1px solid rgba(255,255,255,0.04);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    position:relative;
    transition: transform 300ms ease, box-shadow 200ms ease;
  }
  .box.index{
    font-size:12px;
    color:var(--muted);
    position:absolute;
    top:-18px;
    left:6px;
  }
  .box.highlight{
    box-shadow: 0 6px 20px rgba(3,105,161,0.25);
    transform: translateY(-6px) scale(1.02);
    border-color: rgba(6,182,212,0.9);
  }
  .box.swap{
    background:linear-gradient(90deg,#fffbeb,#fff7ed);
    color:#452b00;
    border-color:#f59e0b;
    box-shadow: 0 8px 28px rgba(245,158,11,0.18);
  }

  /* tree area */
  .canvas-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border-radius:10px;
    padding:12px;
    height:380px;
    position:relative;
    overflow:hidden;
  }
  svg {
    width:100%;
    height:100%;
    display:block;
  }
  .node{
    transition: transform 400ms ease;
  }
  .node circle{
    fill:var(--card);
    stroke:rgba(255,255,255,0.06);
    stroke-width:1.2;
    transition: fill 200ms ease, r 200ms ease;
  }
  .node text{
    fill:var(--muted);
    font-weight:700;
    font-size:12px;
  }
  .node.highlight circle{
    fill:var(--accent);
  }
  .node.swap circle{
    fill:#fffbeb;
    stroke:#f59e0b;
  }
  .link {
    stroke: rgba(255,255,255,0.06);
    stroke-width:2;
  }

  .log{
    margin-top:12px;
    font-family:monospace;
    font-size:12px;
    line-height:1.4;
    max-height:180px;
    overflow:auto;
    background:rgba(255,255,255,0.02);
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .footer{
    margin-top:12px;
    font-size:13px;
    color:var(--muted);
  }
  .badge{
    font-size:12px;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(255,255,255,0.03);
    color:var(--muted);
    border:1px solid rgba(255,255,255,0.02);
  }
  .legend{display:flex;gap:10px; margin-top:8px; flex-wrap:wrap;}
  .legend div{font-size:12px;color:var(--muted);}
  .controls .muted {margin-top:6px;}
  .center{display:flex;align-items:center;justify-content:center;}
  @media (max-width:980px){
    .wrap{grid-template-columns:1fr; padding-bottom:120px;}
    .canvas-wrap{height:300px;}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel controls">
      <h2>Heap (Min / Max) — Interactive Visualizer</h2>
      <div class="row">
        <label for="type">Type</label>
        <select id="type">
          <option value="min">Min Heap (smallest root)</option>
          <option value="max">Max Heap (largest root)</option>
        </select>
        <div style="flex:1"></div>
        <span class="badge" id="countBadge">0 items</span>
      </div>

      <div class="row">
        <div style="flex:1">
          <label for="value">Value to insert</label>
          <input id="value" type="number" value="7" />
        </div>
        <div style="width:120px">
          <label>&nbsp;</label>
          <button id="insertBtn" class="primary" style="width:100%;">Insert</button>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Quick actions</label>
          <div style="display:flex;gap:8px;">
            <button id="extractBtn" class="small">Extract root</button>
            <button id="peekBtn" class="small">Peek root</button>
            <button id="clearBtn" class="small">Clear</button>
          </div>
        </div>
        <div style="width:140px">
          <label>Animation</label>
          <div style="display:flex;gap:6px;">
            <button id="toggleAnim" class="small">Animate: ON</button>
            <button id="stepBtn" class="small">Step Mode</button>
          </div>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Build / Generate</label>
          <div style="display:flex;gap:8px;">
            <input id="listInput" type="text" placeholder="e.g. 5,3,8,1,9" />
            <button id="buildBtn" class="small">Build heap</button>
            <button id="randBtn" class="small">Random</button>
          </div>
          <div class="muted">Paste a comma-separated list, or generate random values. Building uses bottom-up heapify (O(n)).</div>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>Heap sort</label>
          <div style="display:flex;gap:8px;">
            <button id="heapSortBtn" class="small">Heap sort</button>
            <button id="visualSortBtn" class="small">Visualize sort</button>
          </div>
          <div class="muted">Heap sort repeatedly extracts root to produce a sorted array.</div>
        </div>
      </div>

      <div class="row">
        <label>Array representation</label>
        <div class="array-view" id="arrayView" style="min-height:72px;"></div>
      </div>

      <div class="row">
        <label>Legend & Tips</label>
        <div class="legend">
          <div class="muted">Nodes are shown by level (root at top). Swapping during bubble-up/sink-down is animated when Animation is ON.</div>
        </div>
      </div>

      <div class="log" id="log"></div>
      <div class="footer">Try inserting numbers, building from an array, and visualizing heapify and heap sort. Switch between min and max to see behavior differences.</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div>
          <strong id="title">Heap Visualization</strong>
          <div class="muted" id="subtitle">Tree & links (SVG)</div>
        </div>
        <div class="muted">Interactive demo • <span id="opsInfo">No operations yet</span></div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <svg id="svgCanvas" viewBox="0 0 1000 400" preserveAspectRatio="xMidYMid meet"></svg>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px;align-items:center;">
        <div class="muted">Swap speed:</div>
        <input id="speed" type="range" min="50" max="1200" value="360" style="flex:1" />
        <div class="muted" id="speedVal">360ms</div>
      </div>

    </div>
  </div>

<script>
/*
  Heap visualizer (single-file).
  - Supports Min/Max heaps
  - Visual tree (SVG) and array boxes
  - Animate bubble-up / sink-down swaps
  - Build heap (bottom-up), heap sort, insert, extract
  - Step-by-step mode via awaiting manual "Next" (Step Mode toggles)
*/

(() => {
  const svg = document.getElementById('svgCanvas');
  const arrayView = document.getElementById('arrayView');
  const logEl = document.getElementById('log');
  const countBadge = document.getElementById('countBadge');
  const typeSel = document.getElementById('type');
  const valueInput = document.getElementById('value');
  const insertBtn = document.getElementById('insertBtn');
  const extractBtn = document.getElementById('extractBtn');
  const peekBtn = document.getElementById('peekBtn');
  const clearBtn = document.getElementById('clearBtn');
  const buildBtn = document.getElementById('buildBtn');
  const listInput = document.getElementById('listInput');
  const randBtn = document.getElementById('randBtn');
  const heapSortBtn = document.getElementById('heapSortBtn');
  const visualSortBtn = document.getElementById('visualSortBtn');
  const toggleAnim = document.getElementById('toggleAnim');
  const stepBtn = document.getElementById('stepBtn');
  const speedRange = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const opsInfo = document.getElementById('opsInfo');

  let animate = true;
  let stepMode = false;
  let pendingStepResolve = null;

  // Utility: wait for ms
  const wait = ms => new Promise(r => setTimeout(r, ms));

  // Wait until user clicks "next step" when stepMode active
  function waitForStep() {
    if (!stepMode) return Promise.resolve();
    opsInfo.textContent = 'Waiting for Next Step... (click Step Mode button to toggle off)';
    return new Promise(resolve => {
      pendingStepResolve = resolve;
    });
  }

  stepBtn.addEventListener('click', () => {
    stepMode = !stepMode;
    stepBtn.classList.toggle('primary', stepMode);
    stepBtn.textContent = stepMode ? 'Step: ON (click to disable)' : 'Step Mode';
    if (!stepMode && pendingStepResolve) {
      pendingStepResolve();
      pendingStepResolve = null;
    }
  });

  toggleAnim.addEventListener('click', () => {
    animate = !animate;
    toggleAnim.textContent = 'Animate: ' + (animate ? 'ON' : 'OFF');
    toggleAnim.classList.toggle('primary', animate);
  });

  speedRange.addEventListener('input', () => {
    speedVal.textContent = speedRange.value + 'ms';
  });

  // Heap class
  class Heap {
    constructor(isMin = true) {
      this.isMin = !!isMin;
      this.data = [];
      this.logEnabled = true;
      this.stepCallbacks = []; // (type, i, j) called on swaps
    }
    cmp(a,b){
      return this.isMin ? a < b : a > b;
    }
    size(){ return this.data.length; }
    peek(){ return this.size() ? this.data[0] : null; }

    // register step callback to visualize swaps or steps
    onStep(cb){ this.stepCallbacks.push(cb); }

    // bubble up index i
    async bubbleUp(i){
      while(i > 0){
        const p = Math.floor((i-1)/2);
        if (this.cmp(this.data[i], this.data[p])) {
          // swap
          [this.data[i], this.data[p]] = [this.data[p], this.data[i]];
          await this._notify('swap', i, p);
          i = p;
        } else break;
      }
    }

    // sink down index i (heapify down)
    async sinkDown(i){
      const n = this.size();
      while(true){
        const left = 2*i + 1;
        const right = left + 1;
        let candidate = i;
        if (left < n && this.cmp(this.data[left], this.data[candidate])) candidate = left;
        if (right < n && this.cmp(this.data[right], this.data[candidate])) candidate = right;
        if (candidate !== i){
          [this.data[i], this.data[candidate]] = [this.data[candidate], this.data[i]];
          await this._notify('swap', i, candidate);
          i = candidate;
        } else break;
      }
    }

    // Insert value
    async insert(val){
      this.data.push(val);
      await this._notify('insert', this.size()-1);
      await this.bubbleUp(this.size()-1);
    }

    // Extract root
    async extract(){
      if (this.size()===0) return null;
      const root = this.data[0];
      const last = this.data.pop();
      if (this.size() > 0){
        this.data[0] = last;
        await this._notify('replaceRoot', 0);
        await this.sinkDown(0);
      } else {
        await this._notify('removeLast', null);
      }
      return root;
    }

    // Build heap from array using bottom-up heapify
    async buildFromArray(arr){
      this.data = arr.slice();
      await this._notify('buildStart', null);
      for (let i = Math.floor(this.size()/2)-1; i >= 0; i--){
        await this._notify('heapifyStart', i);
        await this.sinkDown(i);
      }
      await this._notify('buildEnd', null);
    }

    // Heap sort (non-destructive: copies heap)
    heapSortArray(){
      const copy = new Heap(this.isMin);
      copy.data = this.data.slice();
      const out = [];
      while(copy.size()){
        out.push(copy.data[0]);
        const last = copy.data.pop();
        if (copy.size() > 0){
          copy.data[0] = last;
          // simple sink on copy (no animation)
          let i=0;
          while(true){
            const left = 2*i+1, right = left+1;
            let candidate = i;
            if (left < copy.size() && copy.cmp(copy.data[left], copy.data[candidate])) candidate = left;
            if (right < copy.size() && copy.cmp(copy.data[right], copy.data[candidate])) candidate = right;
            if (candidate !== i){
              [copy.data[i], copy.data[candidate]] = [copy.data[candidate], copy.data[i]];
              i = candidate;
            } else break;
          }
        }
      }
      return out;
    }

    // Internal: notify callbacks with optional animation delays
    async _notify(type, i, j){
      for (const cb of this.stepCallbacks) {
        // cb returns a promise that resolves when visualization done
        const p = cb(type, i, j, this.data.slice());
        if (p && typeof p.then === 'function') {
          await p;
        }
      }
    }
  }

  // Visualization helpers
  function log(msg){
    const el = document.createElement('div');
    el.textContent = (new Date()).toTimeString().slice(0,8) + ' • ' + msg;
    logEl.prepend(el);
  }
  function setCount(n){
    countBadge.textContent = n + (n===1 ? ' item' : ' items');
  }

  // Position nodes for binary heap
  function computeLayout(n, width = 1000, height = 380){
    // compute level & position
    const nodes = [];
    for (let i=0;i<n;i++){
      const level = Math.floor(Math.log2(i+1));
      const firstIndexInLevel = Math.pow(2,level) - 1;
      const posInLevel = i - firstIndexInLevel;
      const nodesInLevel = Math.pow(2,level);
      const y = 40 + level * 70;
      const horizontalGap = width / (nodesInLevel + 1);
      const x = horizontalGap * (posInLevel + 1);
      nodes.push({i, x, y, level});
    }
    return nodes;
  }

  // Render heap (array boxes + svg tree)
  function renderHeap(heap, highlight = {}) {
    const arr = heap.data;
    // arrayView
    arrayView.innerHTML = '';
    arr.forEach((v, idx) => {
      const b = document.createElement('div');
      b.className = 'box';
      if (highlight.idx === idx) b.classList.add('highlight');
      if (highlight.swap && (highlight.swap[0]===idx || highlight.swap[1]===idx)) b.classList.add('swap');
      const idxElem = document.createElement('div');
      idxElem.className = 'box index';
      idxElem.textContent = idx;
      b.appendChild(idxElem);
      const content = document.createElement('div');
      content.textContent = v;
      b.appendChild(content);
      arrayView.appendChild(b);
    });

    setCount(arr.length);

    // SVG tree
    const width = 1000, height = 400;
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.innerHTML = '';
    if (arr.length === 0) {
      // show a small placeholder instruction
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', width/2);
      text.setAttribute('y', height/2);
      text.setAttribute('text-anchor','middle');
      text.setAttribute('fill','rgba(255,255,255,0.12)');
      text.setAttribute('font-size','16');
      text.textContent = 'Heap is empty — insert values or build from an array';
      svg.appendChild(text);
      return;
    }
    const nodes = computeLayout(arr.length, width, height);
    // draw links
    nodes.forEach(n => {
      const left = 2*n.i + 1;
      const right = left + 1;
      if (left < arr.length){
        const n2 = nodes[left];
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', n.x);
        line.setAttribute('y1', n.y + 18);
        line.setAttribute('x2', n2.x);
        line.setAttribute('y2', n2.y - 18);
        line.setAttribute('class','link');
        svg.appendChild(line);
      }
      if (right < arr.length){
        const n2 = nodes[right];
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', n.x);
        line.setAttribute('y1', n.y + 18);
        line.setAttribute('x2', n2.x);
        line.setAttribute('y2', n2.y - 18);
        line.setAttribute('class','link');
        svg.appendChild(line);
      }
    });

    nodes.forEach(n => {
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('transform', `translate(${n.x}, ${n.y})`);
      g.setAttribute('class','node');
      // highlight logic
      if (highlight.idx === n.i) g.classList.add('highlight');
      if (highlight.swap && (highlight.swap[0]===n.i || highlight.swap[1]===n.i)) g.classList.add('swap');

      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r', 20);
      g.appendChild(circle);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('text-anchor','middle');
      text.setAttribute('dy','6');
      text.textContent = arr[n.i];
      g.appendChild(text);

      const idxText = document.createElementNS('http://www.w3.org/2000/svg','text');
      idxText.setAttribute('text-anchor','middle');
      idxText.setAttribute('dy','36');
      idxText.setAttribute('font-size','10');
      idxText.setAttribute('fill','rgba(255,255,255,0.25)');
      idxText.textContent = n.i;
      g.appendChild(idxText);

      svg.appendChild(g);
    });
  }

  // Animation callback used by heap to visualize steps
  function makeVisualizer(heap){
    return async (type, i, j, snapshot) => {
      // type: 'swap', 'insert', 'replaceRoot', 'removeLast', 'buildStart', 'heapifyStart', 'buildEnd'
      // i, j are indices involved (j may be undefined)
      // snapshot is the current array after the operation
      opsInfo.textContent = type + (i !== null && i !== undefined ? ` (${i}${j!==undefined?','+j:''})` : '');
      const ms = parseInt(speedRange.value,10) || 360;
      if (type === 'swap'){
        // show swap highlight and animate
        renderHeap(heap, {swap:[i,j]});
        if (animate) await wait(ms);
        else await wait(50);
      } else if (type === 'insert'){
        renderHeap(heap, {idx:i});
        if (animate) await wait(Math.min(ms, 300));
      } else if (type === 'replaceRoot' || type === 'removeLast'){
        renderHeap(heap, {});
        if (animate) await wait(Math.min(ms, 220));
      } else if (type === 'buildStart'){
        log('Starting build from array: ' + snapshot.join(', '));
        renderHeap(heap,{});
        await wait(120);
      } else if (type === 'heapifyStart'){
        log('Heapify at index ' + i);
        renderHeap(heap,{idx:i});
        if (animate) await wait(ms/1.6);
      } else if (type === 'buildEnd'){
        log('Build finished');
        renderHeap(heap,{});
        await wait(220);
      } else {
        renderHeap(heap,{});
        await wait(90);
      }

      // Wait for step mode if active (pauses between steps)
      if (stepMode) {
        await waitForStep();
      }
    };
  }

  // Create heap instance
  let heap = new Heap(true);
  heap.onStep(makeVisualizer(heap));

  // UI wiring
  function refreshTitle(){
    const isMin = typeSel.value === 'min';
    document.getElementById('title').textContent = (isMin ? 'Min Heap' : 'Max Heap') + ' Visualization';
    document.getElementById('subtitle').textContent = (isMin ? 'Root is smallest element' : 'Root is largest element');
  }

  function resetHeap(isMin){
    heap = new Heap(isMin);
    heap.onStep(makeVisualizer(heap));
    renderHeap(heap,{});
    log('Heap reset to ' + (isMin ? 'Min' : 'Max'));
    opsInfo.textContent = 'Reset';
  }

  typeSel.addEventListener('change', () => {
    const isMin = typeSel.value === 'min';
    resetHeap(isMin);
    refreshTitle();
  });

  insertBtn.addEventListener('click', async () => {
    const val = Number(valueInput.value);
    if (!Number.isFinite(val)) {
      alert('Please enter a valid number.');
      return;
    }
    log('Inserting ' + val);
    await heap.insert(val);
    renderHeap(heap,{});
    opsInfo.textContent = 'Inserted ' + val;
  });

  extractBtn.addEventListener('click', async () => {
    if (heap.size()===0){
      log('Extract attempted on empty heap');
      return;
    }
    log('Extract root -> ' + heap.peek());
    const root = await heap.extract();
    renderHeap(heap,{});
    opsInfo.textContent = 'Extracted ' + root;
  });

  peekBtn.addEventListener('click', () => {
    const p = heap.peek();
    log('Peek: ' + (p===null? 'null' : p));
    opsInfo.textContent = 'Peek ' + (p===null? 'null' : p);
  });

  clearBtn.addEventListener('click', () => {
    resetHeap(typeSel.value === 'min');
    renderHeap(heap,{});
  });

  buildBtn.addEventListener('click', async () => {
    const txt = listInput.value.trim();
    if (!txt) {
      alert('Please paste a comma-separated list like: 5,3,8,1,9');
      return;
    }
    const parts = txt.split(',').map(s => s.trim()).filter(Boolean).map(Number);
    if (parts.some(x => !Number.isFinite(x))){
      alert('Invalid list: ensure all items are numbers.');
      return;
    }
    // limit size to avoid overflow visuals
    if (parts.length > 60){
      if (!confirm('Large list >60 items. This may be slow to visualize. Proceed?')) return;
    }
    log('Building heap from array: ' + parts.join(', '));
    await heap.buildFromArray(parts);
    renderHeap(heap,{});
    opsInfo.textContent = 'Built from array';
  });

  randBtn.addEventListener('click', async () => {
    const n = Math.min(30, Math.max(5, Math.floor(Math.random()*20)+5));
    const arr = Array.from({length:n}, () => Math.floor(Math.random()*99)+1);
    listInput.value = arr.join(',');
    log('Generated random array ('+n+' items)');
    await heap.buildFromArray(arr);
    renderHeap(heap,{});
    opsInfo.textContent = 'Random build';
  });

  heapSortBtn.addEventListener('click', () => {
    if (heap.size()===0){
      alert('Heap empty');
      return;
    }
    const sorted = heap.heapSortArray();
    // For min heap, repeated extracts produce ascending order; for max heap descending.
    log('Heap sort result: ' + sorted.join(', '));
    alert('Heap sort result:\n' + sorted.join(', '));
    opsInfo.textContent = 'Heap sorted (see log)';
  });

  visualSortBtn.addEventListener('click', async () => {
    if (heap.size()===0){
      alert('Heap empty');
      return;
    }
    // Visualize extracting repeatedly
    log('Visual heap sort starting...');
    const copy = new Heap(heap.isMin);
    copy.data = heap.data.slice();
    copy.onStep(async (t,i,j,snap) => {
      // reuse global visualizer but operate on displayed heap for clarity
      const ms = parseInt(speedRange.value,10) || 360;
      // We'll animate swaps on the displayed heap as we perform extracts on the copy,
      // but show the array of extracted elements separately.
      return; // simplified: do non-animated sort but show progress
    });

    const out = [];
    while(copy.size()){
      out.push(copy.data[0]);
      const last = copy.data.pop();
      if (copy.size() > 0){
        copy.data[0] = last;
        // sink down
        let i = 0;
        while(true){
          const left = 2*i + 1;
          const right = left + 1;
          let candidate = i;
          if (left < copy.size() && copy.cmp(copy.data[left], copy.data[candidate])) candidate = left;
          if (right < copy.size() && copy.cmp(copy.data[right], copy.data[candidate])) candidate = right;
          if (candidate !== i){
            [copy.data[i], copy.data[candidate]] = [copy.data[candidate], copy.data[i]];
            i = candidate;
          } else break;
        }
      }
    }
    log('Heap sort result: ' + out.join(', '));
    alert('Heap sort result:\n' + out.join(', '));
    opsInfo.textContent = 'Visual sort done (non-animated)';
  });

  // Initial render
  renderHeap(heap,{});
  refreshTitle();
  log('Ready — select min or max and try operations.');

  // Allow user to proceed next step by clicking the Step Mode button (when in stepMode)
  // We'll make the Step Mode button also act as a "Next" when in stepMode:
  stepBtn.addEventListener('click', () => {
    if (stepMode) {
      // entering step mode; label indicates on. User will toggle off to resume continuous.
      // But we also allow clicking while in mode to release one step:
      if (pendingStepResolve) {
        pendingStepResolve();
        pendingStepResolve = null;
      }
    } else {
      // leaving step mode resume others
      if (pendingStepResolve) {
        pendingStepResolve();
        pendingStepResolve = null;
      }
    }
  });

  // Extra: allow clicking on array box to remove that item (for experimentation)
  arrayView.addEventListener('click', async (ev) => {
    const boxes = [...arrayView.children];
    const idx = boxes.indexOf(ev.target.closest('.box'));
    if (idx >=0){
      if (!confirm('Remove element at index '+idx+' (value '+heap.data[idx]+')?')) return;
      // Remove and rebuild
      heap.data.splice(idx,1);
      renderHeap(heap,{});
      log('Removed element at index ' + idx);
    }
  });

})();
</script>
</body>
</html>