<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 600px;
            margin: auto;
        }
        #output {
            margin-top: 20px;
            white-space: pre-wrap;
        }
        .button {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Huffman Coding Demo</h1>
    <label for="inputText">Enter text to encode:</label><br>
    <textarea id="inputText" rows="4" cols="50"></textarea><br>
    <button class="button" onclick="huffmanEncode()">Encode</button>
    <div id="output"></div>

    <script>
        class Node {
            constructor(value, frequency) {
                this.value = value;
                this.frequency = frequency;
                this.left = null;
                this.right = null;
            }
        }

        class MinHeap {
            constructor() {
                this.nodes = [];
            }

            insert(node) {
                this.nodes.push(node);
                this.bubbleUp();
            }

            bubbleUp() {
                let index = this.nodes.length - 1;
                while (index > 0) {
                    const parentIndex = Math.floor((index - 1) / 2);
                    if (this.nodes[index].frequency >= this.nodes[parentIndex].frequency) break;
                    [this.nodes[index], this.nodes[parentIndex]] = [this.nodes[parentIndex], this.nodes[index]];
                    index = parentIndex;
                }
            }

            remove() {
                const root = this.nodes[0];
                const end = this.nodes.pop();
                if (this.nodes.length > 0) {
                    this.nodes[0] = end;
                    this.bubbleDown();
                }
                return root;
            }

            bubbleDown() {
                let index = 0;
                const length = this.nodes.length;
                const element = this.nodes[0];

                while (true) {
                    let leftChildIndex = 2 * index + 1;
                    let rightChildIndex = 2 * index + 2;
                    let leftChild, rightChild;
                    let swap = null;

                    if (leftChildIndex < length) {
                        leftChild = this.nodes[leftChildIndex];
                        if (leftChild.frequency < element.frequency) {
                            swap = leftChildIndex;
                        }
                    }

                    if (rightChildIndex < length) {
                        rightChild = this.nodes[rightChildIndex];
                        if (
                            (swap === null && rightChild.frequency < element.frequency) ||
                            (swap !== null && rightChild.frequency < leftChild.frequency)
                        ) {
                            swap = rightChildIndex;
                        }
                    }

                    if (swap === null) break;
                    this.nodes[index] = this.nodes[swap];
                    this.nodes[swap] = element;
                    index = swap;
                }
            }

            isEmpty() {
                return this.nodes.length === 0;
            }
        }

        function huffmanEncode() {
            const text = document.getElementById("inputText").value.trim();
            const frequencyMap = {};

            // Count frequency of each character
            for (const char of text) {
                frequencyMap[char] = (frequencyMap[char] || 0) + 1;
            }

            const minHeap = new MinHeap();

            // Build initial heap
            for (const [char, freq] of Object.entries(frequencyMap)) {
                minHeap.insert(new Node(char, freq));
            }

            // Build Huffman tree
            while (minHeap.nodes.length > 1) {
                const left = minHeap.remove();
                const right = minHeap.remove();
                const merged = new Node(null, left.frequency + right.frequency);
                merged.left = left;
                merged.right = right;
                minHeap.insert(merged);
            }

            const root = minHeap.remove();
            const huffmanCodes = {};
            generateCodes(root, '', huffmanCodes);

            // Output results
            let output = 'Huffman Codes:\n';
            for (const [char, code] of Object.entries(huffmanCodes)) {
                output += `${char}: ${code}\n`;
            }
            document.getElementById("output").textContent = output;
        }

        function generateCodes(node, code, codes) {
            if (node == null) return;
            if (node.value !== null) {
                codes[node.value] = code;
            }
            generateCodes(node.left, code + '0', codes);
            generateCodes(node.right, code + '1', codes);
        }
    </script>
</body>
</html>