<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Data Structure Visualization</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .heap-type-selector {
            display: flex;
            margin-bottom: 20px;
            background-color: #ecf0f1;
            border-radius: 4px;
            padding: 5px;
        }
        
        .heap-type-btn {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: none;
            border: none;
            color: #7f8c8d;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .heap-type-btn.active {
            background-color: #3498db;
            color: white;
        }
        
        .heap-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            min-height: 300px;
            position: relative;
        }
        
        .heap-level {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
        }
        
        .heap-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 10px;
            background-color: #3498db;
            color: white;
            position: relative;
        }
        
        .heap-node.new {
            animation: highlight 1s ease;
            background-color: #e74c3c;
        }
        
        @keyframes highlight {
            0% { transform: scale(1); background-color: #e74c3c; }
            50% { transform: scale(1.2); background-color: #f1c40f; }
            100% { transform: scale(1); background-color: #3498db; }
        }
        
        .heap-connection {
            position: absolute;
            background-color: #7f8c8d;
            height: 2px;
            transform-origin: 0 0;
        }
        
        .operation-history {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            background-color: #f8f9fa;
        }
        
        .explanation {
            margin-top: 30px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .explanation h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Heap Data Structure Visualization</h1>
        <p class="subtitle">Min Heap and Max Heap Operations</p>
    </header>
    
    <div class="container">
        <div class="panel">
            <h2>Heap Operations</h2>
            
            <div class="heap-type-selector">
                <button class="heap-type-btn active" data-type="min">Min Heap</button>
                <button class="heap-type-btn" data-type="max">Max Heap</button>
            </div>
            
            <div class="controls">
                <input type="number" id="value-input" placeholder="Enter a number" min="-999" max="999">
                <button id="insert-btn">Insert Value</button>
                <button id="extract-btn">Extract Root</button>
                <button id="clear-btn">Clear Heap</button>
                <button id="random-btn">Generate Random Heap</button>
            </div>
            
            <div class="operation-history">
                <h3>Operation History</h3>
                <div id="history"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Heap Visualization</h2>
            <div class="heap-visualization" id="heap-container">
                <!-- Heap visualization will be generated here -->
            </div>
        </div>
    </div>
    
    <div class="explanation">
        <h3>About Heaps</h3>
        <p><strong>Min Heap:</strong> A complete binary tree where each node is smaller than or equal to its children. The smallest element is always at the root.</p>
        <p><strong>Max Heap:</strong> A complete binary tree where each node is greater than or equal to its children. The largest element is always at the root.</p>
        <p><strong>Operations:</strong></p>
        <ul>
            <li><strong>Insert:</strong> Add a new element to the heap and reorganize to maintain heap property</li>
            <li><strong>Extract:</strong> Remove the root element and reorganize the heap</li>
            <li><strong>Heapify:</strong> Process of converting a binary tree into a heap</li>
        </ul>
    </div>

    <script>
        class Heap {
            constructor(type = 'min') {
                this.type = type; // 'min' or 'max'
                this.heap = [];
            }
            
            // Get parent index of a node
            parentIndex(index) {
                return Math.floor((index - 1) / 2);
            }
            
            // Get left child index of a node
            leftChildIndex(index) {
                return 2 * index + 1;
            }
            
            // Get right child index of a node
            rightChildIndex(index) {
                return 2 * index + 2;
            }
            
            // Check if a node has a parent
            hasParent(index) {
                return this.parentIndex(index) >= 0;
            }
            
            // Check if a node has a left child
            hasLeftChild(index) {
                return this.leftChildIndex(index) < this.heap.length;
            }
            
            // Check if a node has a right child
            hasRightChild(index) {
                return this.rightChildIndex(index) < this.heap.length;
            }
            
            // Compare two elements based on heap type
            compare(a, b) {
                if (this.type === 'min') {
                    return a < b;
                } else {
                    return a > b;
                }
            }
            
            // Swap two elements in the heap
            swap(index1, index2) {
                [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];
            }
            
            // Insert a new value into the heap
            insert(value) {
                this.heap.push(value);
                this.heapifyUp();
            }
            
            // Extract the root element from the heap
            extractRoot() {
                if (this.heap.length === 0) return null;
                
                const root = this.heap[0];
                this.heap[0] = this.heap[this.heap.length - 1];
                this.heap.pop();
                this.heapifyDown();
                
                return root;
            }
            
            // Move the last element up to maintain heap property
            heapifyUp() {
                let index = this.heap.length - 1;
                
                while (this.hasParent(index) && 
                       this.compare(this.heap[index], this.heap[this.parentIndex(index)])) {
                    this.swap(index, this.parentIndex(index));
                    index = this.parentIndex(index);
                }
            }
            
            // Move the root element down to maintain heap property
            heapifyDown() {
                let index = 0;
                
                while (this.hasLeftChild(index)) {
                    let childIndex = this.leftChildIndex(index);
                    
                    if (this.hasRightChild(index) && 
                        this.compare(this.heap[this.rightChildIndex(index)], this.heap[childIndex])) {
                        childIndex = this.rightChildIndex(index);
                    }
                    
                    if (this.compare(this.heap[index], this.heap[childIndex])) {
                        break;
                    } else {
                        this.swap(index, childIndex);
                    }
                    
                    index = childIndex;
                }
            }
            
            // Get the root value without removing it
            peek() {
                return this.heap.length > 0 ? this.heap[0] : null;
            }
            
            // Get the size of the heap
            size() {
                return this.heap.length;
            }
            
            // Check if the heap is empty
            isEmpty() {
                return this.heap.length === 0;
            }
            
            // Clear the heap
            clear() {
                this.heap = [];
            }
        }

        // DOM elements
        const heapTypeBtns = document.querySelectorAll('.heap-type-btn');
        const valueInput = document.getElementById('value-input');
        const insertBtn = document.getElementById('insert-btn');
        const extractBtn = document.getElementById('extract-btn');
        const clearBtn = document.getElementById('clear-btn');
        const randomBtn = document.getElementById('random-btn');
        const heapContainer = document.getElementById('heap-container');
        const historyDiv = document.getElementById('history');

        // Initialize heap
        let heap = new Heap('min');
        let operationHistory = [];

        // Update active heap type button
        function updateHeapTypeButtons() {
            heapTypeBtns.forEach(btn => {
                if (btn.dataset.type === heap.type) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Add operation to history
        function addToHistory(operation) {
            const timestamp = new Date().toLocaleTimeString();
            operationHistory.unshift(`${timestamp}: ${operation}`);
            
            // Keep only last 10 operations
            if (operationHistory.length > 10) {
                operationHistory.pop();
            }
            
            // Update history display
            historyDiv.innerHTML = operationHistory.map(op => `<div>${op}</div>`).join('');
        }

        // Visualize the heap
        function visualizeHeap() {
            heapContainer.innerHTML = '';
            
            if (heap.isEmpty()) {
                heapContainer.innerHTML = '<p>Heap is empty</p>';
                return;
            }
            
            // Calculate the number of levels needed
            const levels = Math.floor(Math.log2(heap.size())) + 1;
            
            // Create levels
            let nodeIndex = 0;
            for (let level = 0; level < levels; level++) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'heap-level';
                
                // Number of nodes at this level
                const nodesInLevel = Math.min(Math.pow(2, level), heap.size() - nodeIndex);
                
                for (let i = 0; i < nodesInLevel; i++) {
                    const node = document.createElement('div');
                    node.className = 'heap-node';
                    node.textContent = heap.heap[nodeIndex];
                    node.dataset.index = nodeIndex;
                    
                    // Highlight newly added nodes
                    if (nodeIndex === heap.size() - 1 && operationHistory[0] && 
                        operationHistory[0].includes('Inserted')) {
                        node.classList.add('new');
                    }
                    
                    levelDiv.appendChild(node);
                    nodeIndex++;
                }
                
                heapContainer.appendChild(levelDiv);
            }
            
            // Draw connections between nodes
            drawConnections();
        }

        // Draw connections between parent and child nodes
        function drawConnections() {
            for (let i = 0; i < heap.size(); i++) {
                if (heap.hasLeftChild(i)) {
                    drawConnection(i, heap.leftChildIndex(i));
                }
                
                if (heap.hasRightChild(i)) {
                    drawConnection(i, heap.rightChildIndex(i));
                }
            }
        }

        // Draw a connection between two nodes
        function drawConnection(parentIndex, childIndex) {
            const parentNode = document.querySelector(`.heap-node[data-index="${parentIndex}"]`);
            const childNode = document.querySelector(`.heap-node[data-index="${childIndex}"]`);
            
            if (!parentNode || !childNode) return;
            
            const parentRect = parentNode.getBoundingClientRect();
            const childRect = childNode.getBoundingClientRect();
            const containerRect = heapContainer.getBoundingClientRect();
            
            const parentX = parentRect.left + parentRect.width / 2 - containerRect.left;
            const parentY = parentRect.top + parentRect.height / 2 - containerRect.top;
            const childX = childRect.left + childRect.width / 2 - containerRect.left;
            const childY = childRect.top + childRect.height / 2 - containerRect.top;
            
            const length = Math.sqrt(Math.pow(childX - parentX, 2) + Math.pow(childY - parentY, 2));
            const angle = Math.atan2(childY - parentY, childX - parentX) * 180 / Math.PI;
            
            const connection = document.createElement('div');
            connection.className = 'heap-connection';
            connection.style.width = `${length}px`;
            connection.style.left = `${parentX}px`;
            connection.style.top = `${parentY}px`;
            connection.style.transform = `rotate(${angle}deg)`;
            
            heapContainer.appendChild(connection);
        }

        // Event listeners
        heapTypeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                heap.type = btn.dataset.type;
                updateHeapTypeButtons();
                addToHistory(`Switched to ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);
                visualizeHeap();
            });
        });

        insertBtn.addEventListener('click', () => {
            const value = parseInt(valueInput.value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            
            heap.insert(value);
            addToHistory(`Inserted ${value} into ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);
            visualizeHeap();
            valueInput.value = '';
            valueInput.focus();
        });

        extractBtn.addEventListener('click', () => {
            if (heap.isEmpty()) {
                alert('Heap is empty');
                return;
            }
            
            const root = heap.extractRoot();
            addToHistory(`Extracted root value ${root} from ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);
            visualizeHeap();
        });

        clearBtn.addEventListener('click', () => {
            heap.clear();
            addToHistory('Cleared heap');
            visualizeHeap();
        });

        randomBtn.addEventListener('click', () => {
            heap.clear();
            const count = Math.floor(Math.random() * 10) + 5; // 5-14 nodes
            
            for (let i = 0; i < count; i++) {
                heap.insert(Math.floor(Math.random() * 100));
            }
            
            addToHistory(`Generated random ${heap.type === 'min' ? 'Min' : 'Max'} Heap with ${count} nodes`);
            visualizeHeap();
        });

        // Allow pressing Enter to insert
        valueInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                insertBtn.click();
            }
        });

        // Initialize visualization
        updateHeapTypeButtons();
        visualizeHeap();
        addToHistory('Started with Min Heap');
    </script>
</body>
</html>