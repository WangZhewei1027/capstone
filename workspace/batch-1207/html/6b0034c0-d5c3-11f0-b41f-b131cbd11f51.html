<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weighted Graph Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            padding: 8px 16px;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .canvas-container {
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #fafafa;
        }
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .node-info, .edge-info {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Weighted Graph Visualization</h1>
        
        <div class="controls">
            <button id="addNodeBtn">Add Node</button>
            <button id="addEdgeBtn">Add Edge</button>
            <button id="clearBtn">Clear Graph</button>
            <button id="dijkstraBtn">Run Dijkstra's Algorithm</button>
            <button id="resetBtn">Reset</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="graphCanvas" width="1000" height="600"></canvas>
        </div>
        
        <div class="info-panel">
            <h3>Instructions:</h3>
            <p><strong>Add Node:</strong> Click anywhere on the canvas to add a node</p>
            <p><strong>Add Edge:</strong> Click on two nodes to create a weighted edge between them</p>
            <p><strong>Run Dijkstra:</strong> Select a start node to find shortest paths to all other nodes</p>
            <p><strong>Edge Weight:</strong> Click on an edge to edit its weight</p>
        </div>
    </div>

    <script>
        class WeightedGraph {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.selectedNodes = [];
                this.startNode = null;
                this.mode = 'addNode'; // 'addNode', 'addEdge', 'dijkstra'
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodeRadius = 20;
                
                this.setupEventListeners();
                this.draw();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                document.getElementById('addNodeBtn').addEventListener('click', () => {
                    this.mode = 'addNode';
                    this.updateButtons();
                });
                
                document.getElementById('addEdgeBtn').addEventListener('click', () => {
                    this.mode = 'addEdge';
                    this.selectedNodes = [];
                    this.updateButtons();
                });
                
                document.getElementById('dijkstraBtn').addEventListener('click', () => {
                    this.mode = 'dijkstra';
                    this.selectedNodes = [];
                    this.updateButtons();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.nodes = [];
                    this.edges = [];
                    this.selectedNodes = [];
                    this.startNode = null;
                    this.draw();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.selectedNodes = [];
                    this.startNode = null;
                    this.draw();
                });
            }
            
            updateButtons() {
                const buttons = ['addNodeBtn', 'addEdgeBtn', 'dijkstraBtn'];
                buttons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    btn.disabled = btnId.replace('Btn', '') === this.mode;
                });
            }
            
            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                switch(this.mode) {
                    case 'addNode':
                        this.addNode(x, y);
                        break;
                    case 'addEdge':
                        this.handleEdgeModeClick(x, y);
                        break;
                    case 'dijkstra':
                        this.handleDijkstraModeClick(x, y);
                        break;
                }
            }
            
            addNode(x, y) {
                // Generate a unique label (A, B, C, ...)
                const label = String.fromCharCode(65 + this.nodes.length);
                this.nodes.push({ x, y, label, distance: Infinity, previous: null });
                this.draw();
            }
            
            handleEdgeModeClick(x, y) {
                const clickedNode = this.getNodeAt(x, y);
                
                if (clickedNode) {
                    this.selectedNodes.push(clickedNode);
                    
                    if (this.selectedNodes.length === 2) {
                        const weight = prompt('Enter edge weight:', '1');
                        if (weight && !isNaN(weight)) {
                            this.addEdge(this.selectedNodes[0], this.selectedNodes[1], parseInt(weight));
                        }
                        this.selectedNodes = [];
                    }
                }
            }
            
            handleDijkstraModeClick(x, y) {
                const clickedNode = this.getNodeAt(x, y);
                
                if (clickedNode) {
                    if (!this.startNode) {
                        this.startNode = clickedNode;
                        this.runDijkstra();
                    } else {
                        // Show path to clicked node
                        this.highlightPath(clickedNode);
                    }
                }
            }
            
            getNodeAt(x, y) {
                for (let node of this.nodes) {
                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
                    if (distance <= this.nodeRadius) {
                        return node;
                    }
                }
                return null;
            }
            
            addEdge(node1, node2, weight) {
                // Check if edge already exists
                const existingEdge = this.edges.find(edge => 
                    (edge.from === node1 && edge.to === node2) || 
                    (edge.from === node2 && edge.to === node1)
                );
                
                if (!existingEdge) {
                    this.edges.push({ from: node1, to: node2, weight });
                }
                this.draw();
            }
            
            runDijkstra() {
                // Reset distances
                this.nodes.forEach(node => {
                    node.distance = Infinity;
                    node.previous = null;
                });
                
                this.startNode.distance = 0;
                
                const unvisited = [...this.nodes];
                
                while (unvisited.length > 0) {
                    // Find node with smallest distance
                    unvisited.sort((a, b) => a.distance - b.distance);
                    const current = unvisited.shift();
                    
                    if (current.distance === Infinity) break;
                    
                    // Update distances to neighbors
                    this.edges.forEach(edge => {
                        if (edge.from === current || edge.to === current) {
                            const neighbor = edge.from === current ? edge.to : edge.from;
                            
                            if (unvisited.includes(neighbor)) {
                                const newDistance = current.distance + edge.weight;
                                if (newDistance < neighbor.distance) {
                                    neighbor.distance = newDistance;
                                    neighbor.previous = current;
                                }
                            }
                        }
                    });
                }
                
                this.draw();
            }
            
            highlightPath(targetNode) {
                this.draw();
                
                // Draw the path from start to target
                let current = targetNode;
                const path = [];
                
                while (current && current !== this.startNode) {
                    path.unshift(current);
                    current = current.previous;
                }
                
                if (current === this.startNode) {
                    path.unshift(this.startNode);
                    
                    // Draw the path
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 3;
                    
                    for (let i = 0; i < path.length - 1; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(path[i].x, path[i].y);
                        this.ctx.lineTo(path[i + 1].x, path[i + 1].y);
                        this.ctx.stroke();
                    }
                    
                    // Highlight nodes in path
                    path.forEach(node => {
                        this.ctx.fillStyle = '#ff0000';
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '16px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(node.label, node.x, node.y);
                    });
                }
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges
                this.edges.forEach(edge => {
                    this.drawEdge(edge);
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    this.drawNode(node);
                });
                
                // Highlight selected nodes
                this.selectedNodes.forEach(node => {
                    this.ctx.strokeStyle = '#ff9900';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
                
                // Highlight start node for Dijkstra
                if (this.startNode) {
                    this.ctx.strokeStyle = '#00cc00';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(this.startNode.x, this.startNode.y, this.nodeRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            drawEdge(edge) {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(edge.from.x, edge.from.y);
                this.ctx.lineTo(edge.to.x, edge.to.y);
                this.ctx.stroke();
                
                // Draw weight
                const midX = (edge.from.x + edge.to.x) / 2;
                const midY = (edge.from.y + edge.to.y) / 2;
                
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(midX - 15, midY - 10, 30, 20);
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(edge.weight.toString(), midX, midY);
            }
            
            drawNode(node) {
                // Node circle
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.beginPath();
                this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Node label
                this.ctx.fillStyle = 'white';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.label, node.x, node.y);
                
                // Display distance if calculated
                if (node.distance !== Infinity) {
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(node.distance.toString(), node.x, node.y + 25);
                }
            }
        }
        
        // Initialize the graph when the page loads
        window.addEventListener('load', () => {
            new WeightedGraph();
        });
    </script>
</body>
</html>