<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Graph Visualization (Directed/Undirected)</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f0f2f5;
  }
  h1 {
    text-align: center;
    margin: 1rem 0 0.5rem;
  }
  #container {
    max-width: 900px;
    margin: 0 auto 2rem;
    background: #fff;
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgb(0 0 0 / 0.1);
  }
  #controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }
  label {
    font-weight: 600;
  }
  select {
    font-size: 1rem;
    padding: 0.2rem 0.4rem;
  }
  button {
    padding: 0.45rem 1rem;
    font-size: 1rem;
    font-weight: 600;
    background-color: #0078d7;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #005fa3;
  }
  #graphCanvas {
    display: block;
    margin: 0 auto;
    background: #ffffff;
    border: 1px solid #ddd;
    border-radius: 6px;
  }
  #legend {
    margin-top: 1rem;
    text-align: center;
  }
  #legend span {
    display: inline-block;
    margin: 0 1rem;
    font-size: 1.1rem;
  }
  #legend .edge-color {
    width: 20px;
    height: 3px;
    background: #0078d7;
    display: inline-block;
    vertical-align: middle;
    margin-right: 0.4rem;
  }
</style>
</head>
<body>
  <h1>Graph Visualization: Directed & Undirected Graph</h1>
  <div id="container">
    <div id="controls">
      <label for="graphType">Graph Type:</label>
      <select id="graphType">
        <option value="undirected">Undirected Graph</option>
        <option value="directed">Directed Graph</option>
      </select>
      <button id="resetBtn">Reset Graph</button>
    </div>
    <canvas id="graphCanvas" width="800" height="600"></canvas>
    <div id="legend">
      <span><strong>Legend:</strong></span>
      <span><svg style="width:20px;height:14px;vertical-align:middle;" viewBox="0 0 20 14" xmlns="http://www.w3.org/2000/svg">
        <circle cx="7" cy="7" r="6" fill="#0078d7" />
      </svg> Node</span>
      <span><div class="edge-color"></div> Edge</span>
      <span>Arrowhead (only in Directed)</span>
    </div>
    <p style="text-align:center; max-width: 650px; margin: 20px auto;">
      <em>Click on canvas to add nodes. Click a node to select it, then click another to add an edge between them. Switch graph type to see differences.</em>
    </p>
  </div>

<script>
(() => {
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const graphTypeSelect = document.getElementById('graphType');
  const resetBtn = document.getElementById('resetBtn');

  const NODE_RADIUS = 20;
  const ARROW_SIZE = 10;

  // Graph data
  let nodes = [];
  let edges = []; // edges: array of objects { from: nodeIndex, to: nodeIndex }
  let selectedNodeIndex = null;
  let graphType = graphTypeSelect.value; // 'directed' or 'undirected'

  // Utility: distance between points
  function distance(x1,y1,x2,y2) {
    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
  }

  // Check if point is inside node circle
  function getNodeAt(x, y) {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      if (distance(x,y,node.x,node.y) <= NODE_RADIUS) return i;
    }
    return -1;
  }

  // Draw arrowhead on ctx at (x,y) pointing towards (fromX, fromY)
  function drawArrowhead(ctx, fromX, fromY, toX, toY) {
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.save();
    ctx.beginPath();
    ctx.translate(toX, toY);
    ctx.rotate(angle);
    ctx.moveTo(0, 0);
    ctx.lineTo(-ARROW_SIZE, ARROW_SIZE / 2);
    ctx.lineTo(-ARROW_SIZE, -ARROW_SIZE / 2);
    ctx.closePath();
    ctx.fillStyle = '#0078d7';
    ctx.fill();
    ctx.restore();
  }

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges
    edges.forEach(({from, to}) => {
      const fromNode = nodes[from];
      const toNode = nodes[to];

      // Calculate line endpoints so arrows/tails don't overlap nodes
      const dx = toNode.x - fromNode.x;
      const dy = toNode.y - fromNode.y;
      const angle = Math.atan2(dy, dx);
      const fromX = fromNode.x + Math.cos(angle) * NODE_RADIUS;
      const fromY = fromNode.y + Math.sin(angle) * NODE_RADIUS;
      const toX = toNode.x - Math.cos(angle) * NODE_RADIUS;
      const toY = toNode.y - Math.sin(angle) * NODE_RADIUS;

      ctx.strokeStyle = '#0078d7';
      ctx.fillStyle = '#0078d7';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();

      if (graphType === 'directed') {
        drawArrowhead(ctx, fromX, fromY, toX, toY);
      } else {
        // For undirected graph, optionally draw something at midpoint to suggest connection
        // We'll draw a small circle at midpoint:
        /*
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        ctx.beginPath();
        ctx.arc(midX, midY, 4, 0, 2 * Math.PI);
        ctx.fill();
        */
      }
    });

    // Draw nodes
    nodes.forEach((node,i) => {
      ctx.beginPath();
      ctx.fillStyle = (i === selectedNodeIndex) ? '#005fa3' : '#0078d7';
      ctx.strokeStyle = '#003f6b';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'rgba(0,0,0,0.1)';
      ctx.shadowBlur = 3;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.stroke();

      // Draw node label as its index+1
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(i + 1, node.x, node.y);
    });
  }

  // Add node at position
  function addNode(x, y) {
    nodes.push({x, y});
    draw();
  }

  // Add edge from selectedNodeIndex to target index
  function addEdge(from, to) {
    if (from === to) {
      alert("Cannot create edge from a node to itself.");
      return;
    }

    // For undirected graph, we do not want duplicate edges (from->to or to->from)
    // For directed, prevent duplicate same direction edges.

    if (graphType === 'undirected') {
      const exists = edges.some(e =>
        (e.from === from && e.to === to) || (e.from === to && e.to === from));
      if (exists) {
        alert("This edge already exists.");
        return;
      }
      edges.push({from, to});
    } else {
      const exists = edges.some(e => e.from === from && e.to === to);
      if (exists) {
        alert("This directed edge already exists.");
        return;
      }
      edges.push({from, to});
    }
    draw();
  }

  // Reset everything
  function resetGraph() {
    nodes = [];
    edges = [];
    selectedNodeIndex = null;
    draw();
  }

  // Event handlers
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const clickedNodeIndex = getNodeAt(x, y);

    if (clickedNodeIndex === -1) {
      // Clicked empty space - add node
      addNode(x, y);
      selectedNodeIndex = null;
    } else {
      // Clicked a node
      if (selectedNodeIndex === null) {
        selectedNodeIndex = clickedNodeIndex;
      } else if (selectedNodeIndex === clickedNodeIndex) {
        // Clicked same node again, deselect
        selectedNodeIndex = null;
      } else {
        // Add edge from selectedNodeIndex -> clickedNodeIndex
        addEdge(selectedNodeIndex, clickedNodeIndex);
        selectedNodeIndex = null;
      }
    }
    draw();
  });

  graphTypeSelect.addEventListener('change', (e) => {
    graphType = e.target.value;
    // When switching graph type, edges remain but directionality changes
    // No further validation needed here.
    selectedNodeIndex = null;
    draw();
  });

  resetBtn.addEventListener('click', () => {
    resetGraph();
  });

  // Initial draw
  draw();

})();
</script>
</body>
</html>