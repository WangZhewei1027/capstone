<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Adjacency Matrix Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    text-align: center;
  }
  #container {
    display: flex;
    gap: 40px;
    justify-content: center;
    flex-wrap: wrap;
  }
  #graphCanvas {
    border: 1px solid #ccc;
    background-color: #f9f9f9;
  }
  table {
    border-collapse: collapse;
    margin-top: 10px;
  }
  th, td {
    border: 1px solid #666;
    padding: 5px 8px;
    text-align: center;
    width: 30px;
    height: 30px;
    user-select: none;
    cursor: pointer;
  }
  th {
    background-color: #e0e0e0;
  }
  td.active {
    background-color: #4CAF50;
    color: white;
  }
  td:hover {
    background-color: #9fcd8a;
  }
  #info {
    margin-top: 20px;
    text-align: center;
  }
  #controls {
    margin-bottom: 20px;
    text-align: center;
  }
  input[type=number] {
    width: 50px;
  }
  button {
    margin-left: 10px;
    padding: 5px 12px;
    cursor: pointer;
  }
  #directedLabel {
    cursor: pointer;
    user-select: none;
    margin-left: 10px;
  }
</style>
</head>
<body>
<h1>Adjacency Matrix Visualization</h1>
<div id="controls">
  Number of nodes: <input type="number" id="numNodes" min="2" max="15" value="5" />
  <label id="directedLabel"><input type="checkbox" id="directedCheck" /> Directed graph</label>
  <button id="generateBtn">Generate Matrix</button>
</div>
<div id="container">
  <div>
    <h3>Adjacency Matrix (click cells to toggle edges)</h3>
    <div id="matrixContainer"></div>
  </div>
  <div>
    <h3>Graph Visualization</h3>
    <canvas id="graphCanvas" width="500" height="500"></canvas>
  </div>
</div>
<div id="info">
  <p>Click on the matrix cells to add or remove edges between nodes.</p>
  <p>Green cells indicate edges from row-node to column-node.</p>
</div>

<script>
(() => {
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const matrixContainer = document.getElementById('matrixContainer');
  const numNodesInput = document.getElementById('numNodes');
  const generateBtn = document.getElementById('generateBtn');
  const directedCheck = document.getElementById('directedCheck');

  let numNodes = Number(numNodesInput.value);
  let directed = directedCheck.checked;
  let adjacencyMatrix = [];

  // Coordinates for nodes on canvas
  let nodesCoords = [];

  // Initialize adjacency matrix with zeros
  function initMatrix(n) {
    adjacencyMatrix = [];
    for (let i = 0; i < n; i++) {
      const row = Array(n).fill(0);
      adjacencyMatrix.push(row);
    }
  }

  // Generate adjacency matrix HTML table
  function generateMatrixTable() {
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const emptyTH = document.createElement('th');
    headerRow.appendChild(emptyTH);
    // Column headers (Nodes)
    for (let c = 0; c < numNodes; c++) {
      const th = document.createElement('th');
      th.textContent = `N${c}`;
      headerRow.appendChild(th);
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (let r = 0; r < numNodes; r++) {
      const tr = document.createElement('tr');
      const rowHeader = document.createElement('th');
      rowHeader.textContent = `N${r}`;
      tr.appendChild(rowHeader);
      for (let c = 0; c < numNodes; c++) {
        const td = document.createElement('td');
        td.dataset.row = r;
        td.dataset.col = c;
        if (adjacencyMatrix[r][c] === 1) td.classList.add('active');
        td.title = `Edge from N${r} â†’ N${c}`;
        td.addEventListener('click', () => {
          toggleEdge(r, c);
        });
        // For undirected: disable cell when c < r to avoid duplicates
        if (!directed && c < r) {
          td.style.backgroundColor = '#f0f0f0';
          td.style.cursor = 'default';
          td.title = 'Undirected edges mirrored';
          td.removeEventListener('click', () => {});
        }
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);

    matrixContainer.innerHTML = '';
    matrixContainer.appendChild(table);
  }

  // Toggle edge presence in adjacency matrix and update UI
  function toggleEdge(row, col) {
    if (!directed && col < row) {
      // For undirected graph, edge toggle handled in mirrored cell
      row = col;
      col = row;
    }
    adjacencyMatrix[row][col] = adjacencyMatrix[row][col] === 1 ? 0 : 1;

    if (!directed && row !== col) {
      // Mirror the undirected edge
      adjacencyMatrix[col][row] = adjacencyMatrix[row][col];
    }

    generateMatrixTable();
    drawGraph();
  }

  // Calculate coordinates for nodes arranged in a circle
  function calculateNodePositions(radius = 200, centerX = 250, centerY = 250) {
    nodesCoords = [];
    for (let i = 0; i < numNodes; i++) {
      const angle = (2 * Math.PI * i) / numNodes - Math.PI / 2; // start from top (12 o'clock)
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      nodesCoords.push({ x, y });
    }
  }

  // Draw arrowhead for directed edges
  function drawArrowhead(ctx, fromX, fromY, toX, toY, radius = 7) {
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(dy, dx);
    ctx.save();
    ctx.translate(toX, toY);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-radius, radius / 2);
    ctx.lineTo(-radius, -radius / 2);
    ctx.closePath();
    ctx.fillStyle = 'black';
    ctx.fill();
    ctx.restore();
  }

  // Draw the graph on the canvas
  function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    calculateNodePositions();

    // Draw edges
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#444';
    ctx.fillStyle = '#444';

    for (let r = 0; r < numNodes; r++) {
      for (let c = 0; c < numNodes; c++) {
        if (adjacencyMatrix[r][c] === 1) {
          if (!directed && c < r) {
            // Skip drawing mirrored edges for undirected graph
            continue;
          }
          const from = nodesCoords[r];
          const to = nodesCoords[c];

          // For self loop, draw a loop
          if (r === c) {
            const node = from;
            const loopRadius = 20;
            ctx.beginPath();
            ctx.arc(node.x, node.y - loopRadius, loopRadius, 0, Math.PI * 2);
            ctx.stroke();
            if (directed) {
              // Draw arrowhead on loop (top center)
              const arrowX = node.x;
              const arrowY = node.y - 2 * loopRadius;
              drawArrowhead(ctx, node.x, node.y - loopRadius - 5, arrowX, arrowY);
            }
          } else {
            // Draw line or curved edge
            const distX = to.x - from.x;
            const distY = to.y - from.y;
            const distance = Math.hypot(distX, distY);
            const offsetX = (distX / distance) * 15;
            const offsetY = (distY / distance) * 15;

            ctx.beginPath();
            
            // For undirected or directed edges, if reverse edge also exists, curve lines
            const reverseExists = adjacencyMatrix[c][r] === 1;
            if (directed && reverseExists && r < c) {
              // Draw curved edges to distinguish forward and reverse edges
              const cpX = (from.x + to.x) / 2 + (distY / distance) * 40;
              const cpY = (from.y + to.y) / 2 - (distX / distance) * 40;
              ctx.moveTo(from.x + offsetX, from.y + offsetY);
              ctx.quadraticCurveTo(cpX, cpY, to.x - offsetX, to.y - offsetY);
              ctx.stroke();

              // Arrowhead for this edge
              // Approximate position for arrowhead on curve: near to.x, to.y shifted back a bit
              const t = 0.9; // Parameter close to end of curve
              // Quadratic Bezier formula for point at t:
              const qx = (1 - t) * (1 - t) * (from.x + offsetX) + 2 * (1 - t) * t * cpX + t * t * (to.x - offsetX);
              const qy = (1 - t) * (1 - t) * (from.y + offsetY) + 2 * (1 - t) * t * cpY + t * t * (to.y - offsetY);

              // Derivative for angle:
              const dx = 2 * (1 - t) * (cpX - (from.x + offsetX)) + 2 * t * ((to.x - offsetX) - cpX);
              const dy = 2 * (1 - t) * (cpY - (from.y + offsetY)) + 2 * t * ((to.y - offsetY) - cpY);

              ctx.save();
              ctx.translate(qx, qy);
              ctx.rotate(Math.atan2(dy, dx));
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(-7, 4);
              ctx.lineTo(-7, -4);
              ctx.closePath();
              ctx.fill();
              ctx.restore();

            } else if (directed) {
              // Straight line with arrowhead
              ctx.moveTo(from.x + offsetX, from.y + offsetY);
              ctx.lineTo(to.x - offsetX, to.y - offsetY);
              ctx.stroke();

              drawArrowhead(ctx, from.x + offsetX, from.y + offsetY, to.x - offsetX, to.y - offsetY);

            } else {
              // Undirected: straight line without arrow
              ctx.moveTo(from.x + offsetX, from.y + offsetY);
              ctx.lineTo(to.x - offsetX, to.y - offsetY);
              ctx.stroke();
            }
          }
        }
      }
    }

    // Draw nodes on top
    const nodeRadius = 18;
    ctx.fillStyle = '#2196f3';
    ctx.strokeStyle = '#0b5394';
    ctx.lineWidth = 3;
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < numNodes; i++) {
      const { x, y } = nodesCoords[i];
      ctx.beginPath();
      ctx.fillStyle = '#2196f3';
      ctx.strokeStyle = '#0b5394';
      ctx.lineWidth = 3;
      ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.fillText(`N${i}`, x, y);
    }
  }

  // Generate graph & UI based on current settings
  function generate() {
    numNodes = Math.min(Math.max(2, Math.round(Number(numNodesInput.value))), 15);
    directed = directedCheck.checked;
    numNodesInput.value = numNodes; // sanitize input
    initMatrix(numNodes);
    generateMatrixTable();
    drawGraph();
  }

  generateBtn.addEventListener('click', generate);

  // Initialize on load
  generate();
})();
</script>
</body>
</html>