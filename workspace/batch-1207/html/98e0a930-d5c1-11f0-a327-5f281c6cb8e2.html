<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Queue Data Structure — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#4f46e5;
      --muted:#9aa4bd;
      --ok:#10b981;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
      --slot-empty: rgba(255,255,255,0.03);
      --slot-border: rgba(255,255,255,0.08);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071129 0%, #081026 40%, #05111b 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1000px;
      margin:28px auto;
      padding:20px;
    }
    .header{
      display:flex;
      align-items:baseline;
      gap:16px;
      margin-bottom:12px;
    }
    h1{font-size:20px;margin:0}
    p.lead{margin:6px 0 18px;color:var(--muted);font-size:13px}
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:18px;
    }
    .control-row{
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="text"], input[type="number"], select{
      padding:8px 10px;
      border-radius:8px;
      background:var(--glass);
      border:1px solid var(--slot-border);
      color:inherit;
      outline:none;
      width:140px;
      box-sizing:border-box;
    }
    button{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:inherit;
      cursor:pointer;
      transition:transform .08s ease, box-shadow .08s ease;
    }
    button:active{transform:translateY(1px)}
    button.primary{
      background: linear-gradient(180deg, var(--accent), #4338ca);
      box-shadow: 0 6px 18px rgba(79,70,229,0.18);
      border: none;
      font-weight:600;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:14px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .viz{
      margin-top:18px;
      padding:18px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      min-height:180px;
      position:relative;
      overflow:visible;
    }
    .queue-row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .slot{
      width:72px;
      height:64px;
      border-radius:8px;
      background:var(--slot-empty);
      border:1px dashed var(--slot-border);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      transition:all .25s ease;
      box-sizing:border-box;
      font-weight:700;
      color:#e6eef8;
      font-size:18px;
    }
    .slot.filled{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 6px 18px rgba(2,6,23,0.5) inset;
    }
    .slot .idx{
      position:absolute;
      top:6px;
      left:6px;
      font-size:11px;
      color:var(--muted);
      font-weight:600;
    }
    .pointer{
      position:absolute;
      font-size:12px;
      color:var(--muted);
      top:-24px;
      transform:translateX(-50%);
      background:transparent;
      padding:2px 6px;
      border-radius:6px;
    }
    .pointer.front{ color: var(--ok); font-weight:700 }
    .pointer.rear{ color: var(--accent); font-weight:700 }
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }
    .log{
      margin-top:14px;
      max-height:160px;
      overflow:auto;
      font-family:monospace;
      font-size:13px;
      color:var(--muted);
      border-radius:8px;
      padding:10px;
      background:rgba(255,255,255,0.01);
      border:1px solid rgba(255,255,255,0.02);
    }
    .floating{
      position:absolute;
      pointer-events:none;
      z-index:80;
      transition:transform var(--dur) cubic-bezier(.2,.9,.2,1), opacity .22s ease;
      will-change:transform, opacity;
      padding:8px 12px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      box-shadow:0 10px 24px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.04);
      font-weight:700;
    }
    .small{
      font-size:12px;
      color:var(--muted);
    }
    .info {
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }
    .footer{
      margin-top:18px;
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      color:var(--muted);
      font-size:13px;
    }
    .badge{
      padding:6px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--muted);
      font-weight:600;
      font-size:13px;
    }
    .ops{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* responsive tweak */
    @media (max-width:680px){
      .slot{width:56px;height:54px;font-size:16px}
      input[type="text"]{width:110px}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div>
        <h1>Queue — Interactive Demo</h1>
        <p class="lead">A queue is a FIFO (First-In-First-Out) data structure. Use the controls below to enqueue and dequeue items and watch how front/rear move in a circular buffer visualization.</p>
      </div>
    </div>

    <div class="panel">
      <div class="controls">
        <div class="control-row">
          <input id="valueInput" type="text" placeholder="Value to enqueue" />
          <button id="enqueueBtn" class="primary">Enqueue</button>
          <button id="dequeueBtn">Dequeue</button>
          <button id="peekBtn">Peek</button>
          <button id="clearBtn">Clear</button>
        </div>

        <div class="control-row">
          <label class="small">Capacity</label>
          <input id="capacityInput" type="number" value="7" min="2" max="15" />
          <button id="setCapBtn">Reset Capacity</button>
        </div>

        <div class="control-row">
          <button id="fillBtn">Fill Random</button>
          <button id="randOpBtn">Random Ops</button>
          <label class="small">Anim ms</label>
          <input id="durSlider" type="range" min="100" max="1200" value="420" />
          <span id="durLabel" class="small">420</span>
        </div>
      </div>

      <div class="viz panel" id="viz">
        <div id="queueRow" class="queue-row" aria-live="polite"></div>
      </div>

      <div class="legend">
        <div class="small"><span style="color:var(--ok);font-weight:700">Front</span> = next to dequeue</div>
        <div class="small"><span style="color:var(--accent);font-weight:700">Rear</span> = where new items are enqueued</div>
        <div class="small">Circular buffer indexes shown in corners</div>
      </div>

      <div class="footer">
        <div class="badge" id="status">Size: 0 &nbsp; | &nbsp; Capacity: 7</div>
        <div class="ops">
          <div class="small">Complexity: Enqueue O(1), Dequeue O(1), Peek O(1)</div>
        </div>
      </div>

      <div class="log" id="log" aria-live="polite"></div>
    </div>
  </div>

  <script>
    // Queue implementation (circular buffer)
    class VisualQueue {
      constructor(capacity = 7) {
        this.setCapacity(capacity);
      }
      setCapacity(cap){
        this.capacity = Math.max(1, Math.floor(cap));
        this._arr = new Array(this.capacity).fill(undefined);
        this.front = 0; // index of next dequeue
        this.rear = 0;  // index where next enqueue will write
        this.count = 0;
      }
      enqueue(value){
        if(this.isFull()) throw new Error('Queue is full');
        this._arr[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.count++;
      }
      dequeue(){
        if(this.isEmpty()) throw new Error('Queue is empty');
        const val = this._arr[this.front];
        this._arr[this.front] = undefined;
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return val;
      }
      peek(){
        if(this.isEmpty()) return undefined;
        return this._arr[this.front];
      }
      size(){ return this.count; }
      isEmpty(){ return this.count === 0; }
      isFull(){ return this.count === this.capacity; }
      clear(){
        this._arr.fill(undefined);
        this.front = 0;
        this.rear = 0;
        this.count = 0;
      }
      arraySnapshot(){ return this._arr.slice(); }
    }

    // DOM elements
    const queueRow = document.getElementById('queueRow');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const valueInput = document.getElementById('valueInput');
    const enqueueBtn = document.getElementById('enqueueBtn');
    const dequeueBtn = document.getElementById('dequeueBtn');
    const peekBtn = document.getElementById('peekBtn');
    const clearBtn = document.getElementById('clearBtn');
    const capacityInput = document.getElementById('capacityInput');
    const setCapBtn = document.getElementById('setCapBtn');
    const fillBtn = document.getElementById('fillBtn');
    const randOpBtn = document.getElementById('randOpBtn');
    const durSlider = document.getElementById('durSlider');
    const durLabel = document.getElementById('durLabel');

    let animDur = Number(durSlider.value);
    durLabel.textContent = animDur;

    const q = new VisualQueue(Number(capacityInput.value) || 7);

    // create slots
    function renderSlots(animated=false){
      queueRow.innerHTML = '';
      const arr = q.arraySnapshot();
      arr.forEach((val, idx) => {
        const slot = document.createElement('div');
        slot.className = 'slot' + (val !== undefined ? ' filled' : '');
        slot.dataset.idx = idx;
        slot.innerHTML = '<div class="idx">' + idx + '</div>' + (val === undefined ? '' : String(val));
        queueRow.appendChild(slot);
      });
      // add pointers
      updatePointers();
      updateStatus();
    }

    function updatePointers(){
      // remove existing pointer labels
      document.querySelectorAll('.pointer').forEach(n => n.remove());
      // If queue empty still show front==rear position? We'll show front marker at index "front" and rear marker at index "rear - 1" (last enqueued).
      const cap = q.capacity;
      // Front marker (points to element to be dequeued)
      const frontIdx = q.front;
      const frontSlot = queueRow.querySelector('.slot[data-idx="'+frontIdx+'"]');
      const frontPointer = document.createElement('div');
      frontPointer.className = 'pointer front';
      frontPointer.textContent = 'Front';
      if(frontSlot){
        frontSlot.appendChild(frontPointer);
        frontPointer.style.top = '-28px';
        frontPointer.style.left = '50%';
      }
      // Rear pointer - note rear points to next write index; visually show arrow at the slot where last item resides when not empty
      let rearPosIdx = (q.rear - 1 + cap) % cap;
      if(q.isEmpty()){
        // empty: show rear at same as front (rear points to next write spot)
        rearPosIdx = q.rear;
      }
      const rearSlot = queueRow.querySelector('.slot[data-idx="'+rearPosIdx+'"]');
      const rearPointer = document.createElement('div');
      rearPointer.className = 'pointer rear';
      rearPointer.textContent = 'Rear';
      if(rearSlot){
        rearSlot.appendChild(rearPointer);
        rearPointer.style.top = '60px';
        rearPointer.style.left = '50%';
      }
    }

    function updateStatus(){
      statusEl.innerHTML = `Size: ${q.size()} &nbsp; | &nbsp; Capacity: ${q.capacity}`;
    }

    function log(msg, type='info'){
      const line = document.createElement('div');
      const time = new Date().toLocaleTimeString();
      line.textContent = `[${time}] ${msg}`;
      line.style.color = type === 'error' ? 'var(--danger)' : 'var(--muted)';
      logEl.prepend(line);
    }

    // Animation helpers
    function createFloating(value){
      const f = document.createElement('div');
      f.className = 'floating';
      f.style.setProperty('--dur', animDur + 'ms');
      f.textContent = String(value);
      document.body.appendChild(f);
      return f;
    }

    function getSlotRect(idx){
      const slot = queueRow.querySelector('.slot[data-idx="'+idx+'"]');
      if(!slot) return null;
      return slot.getBoundingClientRect();
    }

    function animateEnqueue(value, targetIdx){
      return new Promise(resolve => {
        const inputRect = valueInput.getBoundingClientRect();
        const targetRect = getSlotRect(targetIdx);
        const f = createFloating(value);
        // start at input
        const startX = inputRect.left + inputRect.width/2;
        const startY = inputRect.top + inputRect.height/2;
        f.style.left = startX + 'px';
        f.style.top = startY + 'px';
        f.style.transform = 'translate(-50%, -50%) scale(1)';
        f.style.opacity = '1';
        // force reflow
        f.getBoundingClientRect();
        // compute target center
        const tx = targetRect.left + targetRect.width/2;
        const ty = targetRect.top + targetRect.height/2;
        // animate by translating to target center via transform
        requestAnimationFrame(()=>{
          f.style.transition = `transform ${animDur}ms cubic-bezier(.2,.9,.2,1), opacity ${Math.max(80, animDur*0.12)}ms`;
          const dx = tx - startX;
          const dy = ty - startY;
          f.style.transform = `translate(${dx}px, ${dy}px) translate(-50%, -50%) scale(0.96)`;
        });
        setTimeout(()=>{
          // fade out into slot
          // update model into DOM
          const slot = queueRow.querySelector('.slot[data-idx="'+targetIdx+'"]');
          slot.classList.add('filled');
          slot.innerHTML = '<div class="idx">' + targetIdx + '</div>' + String(value);
          // add tiny pop
          slot.style.transition = 'transform 160ms ease';
          slot.style.transform = 'scale(1.04)';
          setTimeout(()=> slot.style.transform = '', 160);
          f.style.opacity = '0';
          setTimeout(()=>{ f.remove(); resolve(); }, Math.max(60, animDur*0.12 + 40));
        }, animDur + 8);
      });
    }

    function animateDequeue(fromIdx){
      return new Promise(resolve => {
        const slot = queueRow.querySelector('.slot[data-idx="'+fromIdx+'"]');
        if(!slot) { resolve(); return; }
        const val = slot.textContent.replace(/\d+$/, '').trim(); // fallback
        const rect = slot.getBoundingClientRect();
        const f = createFloating(slot.textContent.replace(/^\d+\s*/, ''));
        f.style.left = rect.left + rect.width/2 + 'px';
        f.style.top = rect.top + rect.height/2 + 'px';
        f.style.transform = 'translate(-50%,-50%) scale(1)';
        // animate upward + fade
        requestAnimationFrame(()=>{
          f.style.transition = `transform ${animDur}ms cubic-bezier(.2,.9,.2,1), opacity ${Math.max(80, animDur*0.12)}ms`;
          f.style.transform = 'translate(-50%,-200%) scale(0.9)';
          f.style.opacity = '0';
        });
        setTimeout(()=>{
          // clear slot visually
          slot.classList.remove('filled');
          slot.innerHTML = '<div class="idx">' + fromIdx + '</div>';
          f.remove();
          resolve();
        }, animDur + 30);
      });
    }

    // UI actions
    async function handleEnqueue(value){
      if(value === '' || value == null){
        alert('Enter a value to enqueue.');
        return;
      }
      if(q.isFull()){
        log('Enqueue failed: queue is full', 'error');
        alert('Queue is full. Increase capacity or dequeue items.');
        return;
      }
      const targetIdx = q.rear;
      // perform model change after animation to keep consistent
      try{
        // animate to slot
        await animateEnqueue(value, targetIdx);
        q.enqueue(value);
        updatePointers();
        updateStatus();
        log(`Enqueued "${value}"`);
      }catch(e){
        log('Error: ' + e.message, 'error');
      }
    }

    async function handleDequeue(){
      if(q.isEmpty()){
        log('Dequeue failed: queue is empty', 'error');
        alert('Queue is empty.');
        return;
      }
      const fromIdx = q.front;
      const val = q.peek();
      await animateDequeue(fromIdx);
      const popped = q.dequeue();
      updatePointers();
      updateStatus();
      log(`Dequeued "${popped}"`);
    }

    function handlePeek(){
      if(q.isEmpty()){
        log('Peek: queue is empty');
        alert('Queue is empty.');
        return;
      }
      const val = q.peek();
      log(`Peek: "${val}"`);
      alert('Peek -> ' + val);
    }

    function handleClear(){
      q.clear();
      renderSlots();
      log('Cleared queue');
    }

    function handleSetCapacity(){
      const cap = Number(capacityInput.value) || 1;
      if(cap < 1) return;
      q.setCapacity(cap);
      renderSlots();
      log('Capacity set to ' + cap);
    }

    function randomValue(){
      // random small string or number
      const pick = Math.random();
      if(pick < 0.4) return String(Math.floor(Math.random()*90)+10);
      if(pick < 0.8) return ['A','B','C','D','X','Y','Z'][Math.floor(Math.random()*7)];
      return Math.random().toString(36).slice(2,6);
    }

    async function handleFillRandom(){
      q.clear();
      renderSlots();
      const c = q.capacity;
      const fillCount = Math.floor(Math.random()*(c-1))+1;
      for(let i=0;i<fillCount;i++){
        const v = randomValue();
        await handleEnqueue(v);
      }
      log(`Filled random (${q.size()} items)`);
    }

    async function handleRandomOps(){
      // perform a short sequence of random ops
      const steps = 6 + Math.floor(Math.random()*6);
      for(let i=0;i<steps;i++){
        await new Promise(r => setTimeout(r, 120));
        const pick = Math.random();
        if(pick < 0.55){
          // enqueue if not full
          if(!q.isFull()){
            await handleEnqueue(randomValue());
          } else {
            // if full, try dequeue instead
            if(!q.isEmpty()) await handleDequeue();
          }
        } else {
          // dequeue if not empty
          if(!q.isEmpty()){
            await handleDequeue();
          } else {
            if(!q.isFull()) await handleEnqueue(randomValue());
          }
        }
      }
      log('Random ops sequence finished');
    }

    // attach events
    enqueueBtn.addEventListener('click', ()=> {
      const v = valueInput.value.trim();
      handleEnqueue(v);
      valueInput.value = '';
      valueInput.focus();
    });

    valueInput.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter') enqueueBtn.click();
    });

    dequeueBtn.addEventListener('click', ()=> handleDequeue());
    peekBtn.addEventListener('click', ()=> handlePeek());
    clearBtn.addEventListener('click', ()=> handleClear());
    setCapBtn.addEventListener('click', ()=> handleSetCapacity());
    fillBtn.addEventListener('click', ()=> handleFillRandom());
    randOpBtn.addEventListener('click', ()=> handleRandomOps());

    durSlider.addEventListener('input', ()=>{
      animDur = Number(durSlider.value);
      durLabel.textContent = animDur;
    });

    // init
    renderSlots();
    log('Queue initialized');

    // make sure window resizes keep pointers correct
    window.addEventListener('resize', ()=> updatePointers());
  </script>
</body>
</html>