<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sliding Window Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#4f46e5;
      --muted:#94a3b8;
      --card:#0b1220;
      --good:#10b981;
      --bad:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(180deg,#071020 0%, #071827 100%);
      color:#e6eef8;
    }
    .container{
      max-width:1200px;
      margin:18px auto;
      padding:18px;
    }
    header{
      display:flex;
      gap:16px;
      align-items:center;
      margin-bottom:16px;
    }
    header h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .layout{
      display:grid;
      grid-template-columns: 320px 1fr 360px;
      gap:16px;
      align-items:start;
    }
    .panel{
      background:var(--panel);
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      min-height:120px;
    }
    label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px;}
    input[type="text"], input[type="number"], select{
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      background:transparent;
      color:inherit;
      outline:none;
      box-sizing:border-box;
    }
    .row{display:flex; gap:8px; align-items:center;}
    .row.space{justify-content:space-between;}
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:8px 10px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color:inherit;
      cursor:pointer;
      user-select:none;
    }
    .btn.primary{
      background:linear-gradient(180deg,var(--accent),#3760e3);
      color:#fff;
      border:none;
      box-shadow: 0 6px 20px rgba(79,70,229,0.18);
    }
    .controls{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;}
    .vis{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:12px;
      height:420px;
      display:flex;
      flex-direction:column;
      gap:12px;
      justify-content:flex-start;
    }
    .bars{
      display:flex;
      gap:6px;
      align-items:end;
      height:280px;
      padding:8px;
      border-radius:8px;
      background:var(--glass);
      overflow:hidden;
      position:relative;
    }
    .bar{
      width:36px;
      background:linear-gradient(180deg,#60a5fa,#2563eb);
      border-radius:6px 6px 3px 3px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#08122b;
      font-weight:600;
      font-size:13px;
      position:relative;
    }
    .bar .val{
      transform:translateY(-6px);
      font-size:12px;
      color:#0b1220;
      padding:4px 6px;
      border-radius:6px;
      background:rgba(255,255,255,0.9);
    }
    .bar.label{
      background:transparent;
      color:var(--muted);
    }
    .bar.in-window{
      outline: 3px solid rgba(79,70,229,0.18);
      box-shadow: 0 8px 22px rgba(79,70,229,0.08);
      transform:translateY(-6px);
    }
    .bar.out-of-window{
      filter:grayscale(60%) brightness(0.8);
      opacity:0.7;
    }
    .pointers{
      display:flex;
      gap:12px;
      font-size:13px;
      color:var(--muted);
      align-items:center;
      flex-wrap:wrap;
    }
    .status{
      margin-top:8px;
      background:rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      font-size:14px;
      color:#dbeafe;
    }
    .code{
      background:#07102a;
      border-radius:8px;
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size:13px;
      color:#cbd5e1;
      line-height:1.5;
      white-space:pre-wrap;
    }
    .deque{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    }
    .dq-item{
      padding:6px 10px;
      background:linear-gradient(180deg,#111827,#0b1220);
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      color:#9fb4ff;
      font-weight:600;
    }
    .small{font-size:13px;color:var(--muted);}
    footer{margin-top:14px; font-size:13px; color:var(--muted);}
    .hint{font-size:13px; color:var(--muted); margin-top:6px;}
    /* responsive */
    @media (max-width:1050px){
      .layout{
        grid-template-columns: 1fr;
      }
      .panel{min-height:unset;}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Sliding Window Visualizer</h1>
      <div class="small" style="margin-left:auto; color:var(--muted);">Interactive demo: fixed-size and variable-size sliding window techniques</div>
    </header>

    <div class="layout">
      <div class="panel">
        <label for="mode">Mode</label>
        <select id="mode">
          <option value="fixed">Fixed-size window (sum / avg / max)</option>
          <option value="deque">Fixed-size window — optimized max (deque)</option>
          <option value="varsum">Variable window — longest subarray with sum ≤ S</option>
          <option value="kdistinct">Variable window — longest substring with ≤ K distinct</option>
        </select>

        <div style="height:8px"></div>

        <label>Array / String (comma-separated numbers or plain string)</label>
        <input id="inputData" type="text" value="2,1,3,4,6,2,3,5,1" />

        <div class="controls" style="margin-top:10px;">
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="randomBtn" class="btn">Randomize</button>
            <button id="applyBtn" class="btn primary">Apply</button>
          </div>
        </div>

        <div style="height:10px"></div>

        <div id="fixedControls">
          <label>Window size k</label>
          <input id="kInput" type="number" min="1" value="3" />
          <div style="height:10px"></div>
          <label>Operation</label>
          <select id="operation">
            <option value="sum">Sum</option>
            <option value="avg">Average</option>
            <option value="max">Max (naive)</option>
          </select>
        </div>

        <div id="dequeControls" style="display:none;">
          <label>Window size k</label>
          <input id="kInput2" type="number" min="1" value="3" />
          <div class="hint">Shows step-by-step monotonic deque algorithm for maximum in a sliding window.</div>
        </div>

        <div id="varsumControls" style="display:none;">
          <label>Threshold S (sum ≤ S)</label>
          <input id="sInput" type="number" step="1" value="10" />
          <div class="hint">Finds the longest contiguous subarray whose sum does not exceed S.</div>
        </div>

        <div id="kdistinctControls" style="display:none;">
          <label>K (max distinct characters)</label>
          <input id="kInput3" type="number" min="1" value="2" />
          <div class="hint">Input will be treated as a string. Finds the longest substring with at most K distinct characters.</div>
        </div>

        <hr style="border:none; height:1px; background:rgba(255,255,255,0.02); margin:12px 0;">

        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <button id="prevBtn" class="btn">⟨ Prev</button>
          <button id="playBtn" class="btn primary">Play ▶</button>
          <button id="nextBtn" class="btn">Next ⟩</button>
          <div style="width:8px"></div>
          <label class="small" style="margin:0">Speed</label>
          <input id="speed" type="range" min="200" max="2000" step="50" value="800" />
        </div>

      </div>

      <div class="panel vis">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:12px; align-items:center;">
            <div class="small">Array visualization</div>
            <div class="small" id="arrayInfo" style="color:var(--muted)"></div>
          </div>
          <div class="small" id="stepIndicator" style="color:var(--muted)">Step 0 / 0</div>
        </div>

        <div id="bars" class="bars" aria-hidden="false"></div>

        <div class="pointers">
          <div class="small">Left: <span id="leftIdx">-</span></div>
          <div class="small">Right: <span id="rightIdx">-</span></div>
          <div class="small">Window indices: <span id="windowIdx">-</span></div>
          <div class="small">Current value: <strong id="currentValue">-</strong></div>
          <div class="small">Best / Result: <strong id="bestValue">-</strong></div>
        </div>

        <div class="status" id="description" style="min-height:40px;">Press Apply to build steps. Use Play / Next to animate.</div>
      </div>

      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:start; gap:8px;">
          <div>
            <div class="small">Algorithm state</div>
            <div style="height:8px"></div>
            <div id="dequeView" style="display:none;">
              <div class="small">Deque (indices → values)</div>
              <div class="deque" id="dequeContainer"></div>
            </div>
          </div>
          <div style="text-align:right;">
            <div class="small">Pseudo-code</div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div id="codeArea" class="code">
          Choose a mode and press Apply to view pseudo-code and run steps.
        </div>

        <div style="height:8px"></div>
        <div class="hint">Tip: Try the deque mode to see how we maintain a monotonic queue for O(n) max per window. Variable modes demonstrate two-pointer expansion/shrink patterns.</div>
      </div>
    </div>

    <footer>
      Built for education — demonstrates sliding-window patterns: fixed-size, optimized deque for max, and variable-size (two-pointer) techniques.
    </footer>
  </div>

  <script>
    // Utility helpers
    function $(id){return document.getElementById(id);}
    function parseArrayInput(str){
      str = str.trim();
      if(!str) return [];
      // if string contains commas or digits, try parse numbers; else treat as plain string
      if(/[,\d\-]/.test(str) && /[,\d]/.test(str)) {
        // parse numbers separated by commas/spaces
        const parts = str.split(/[\s,]+/).filter(Boolean);
        const arr = parts.map(x => {
          const n = Number(x);
          return isNaN(n) ? 0 : n;
        });
        return arr;
      }
      // fallback: treat as characters
      return str.split('');
    }

    // DOM refs
    const modeEl = $('mode');
    const inputDataEl = $('inputData');
    const randomBtn = $('randomBtn');
    const applyBtn = $('applyBtn');
    const kInput = $('kInput');
    const kInput2 = $('kInput2');
    const kInput3 = $('kInput3');
    const sInput = $('sInput');
    const operationEl = $('operation');
    const prevBtn = $('prevBtn');
    const nextBtn = $('nextBtn');
    const playBtn = $('playBtn');
    const barsDiv = $('bars');
    const leftIdx = $('leftIdx');
    const rightIdx = $('rightIdx');
    const windowIdx = $('windowIdx');
    const currentValue = $('currentValue');
    const bestValue = $('bestValue');
    const description = $('description');
    const stepIndicator = $('stepIndicator');
    const codeArea = $('codeArea');
    const dequeView = $('dequeView');
    const dequeContainer = $('dequeContainer');
    const dequeControls = $('dequeControls');
    const fixedControls = $('fixedControls');
    const varsumControls = $('varsumControls');
    const kdistinctControls = $('kdistinctControls');
    const arrayInfo = $('arrayInfo');
    const speedEl = $('speed');

    let data = [];
    let steps = [];
    let currentStep = 0;
    let timer = null;

    function randomArray(n=9, min=-2, max=9){
      const a=[];
      for(let i=0;i<n;i++) a.push(Math.floor(Math.random()*(max-min+1))+min);
      return a;
    }

    function randomString(n=12){
      const chars = 'abacdecfghijklmnopqrstuvwxyz';
      let s='';
      for(let i=0;i<n;i++) s += chars[Math.floor(Math.random()*chars.length)];
      return s;
    }

    function setModeUI(){
      const mode = modeEl.value;
      fixedControls.style.display = (mode==='fixed') ? 'block' : 'none';
      dequeControls.style.display = (mode==='deque') ? 'block' : 'none';
      varsumControls.style.display = (mode==='varsum') ? 'block' : 'none';
      kdistinctControls.style.display = (mode==='kdistinct') ? 'block' : 'none';
      // update pseudo-code
      updateCodeSnippet(mode);
    }

    modeEl.addEventListener('change', ()=>{
      setModeUI();
      // change input placeholder depending on mode
      if(modeEl.value==='kdistinct'){
        inputDataEl.value = 'abcbaacbb';
      } else if(modeEl.value==='varsum'){
        inputDataEl.value = '2,1,3,4,6,2,3,5,1';
      }
    });

    randomBtn.addEventListener('click', ()=>{
      const m = modeEl.value;
      if(m==='kdistinct'){
        inputDataEl.value = randomString(12);
      } else {
        inputDataEl.value = randomArray(9,1,9).join(',');
      }
    });

    applyBtn.addEventListener('click', buildSteps);
    prevBtn.addEventListener('click', ()=>{ pause(); stepTo(currentStep-1); });
    nextBtn.addEventListener('click', ()=>{ pause(); stepTo(currentStep+1); });
    playBtn.addEventListener('click', togglePlay);

    function togglePlay(){
      if(timer) pause();
      else play();
    }
    function play(){
      if(steps.length===0) return;
      playBtn.textContent = 'Pause ⏸';
      timer = setInterval(()=> {
        if(currentStep >= steps.length-1){
          pause();
        } else {
          stepTo(currentStep+1);
        }
      }, Number(speedEl.value));
    }
    function pause(){
      if(timer) clearInterval(timer);
      timer = null;
      playBtn.textContent = 'Play ▶';
    }

    function updateCodeSnippet(mode){
      let text = '';
      if(mode==='fixed'){
        text = `Fixed-size sliding window (naive):
for i from 0 to n-k:
  window = arr[i..i+k-1]
  compute sum/avg/max by scanning window
Time: O(n*k) (naive)\n\nTip: Use cumulative sums for sums/averages in O(n).`;
      } else if(mode==='deque'){
        text = `Monotonic deque for sliding-window maximum (O(n)):
deque = empty (store indices)
for i in 0..n-1:
  // remove out-of-window indices
  while deque not empty and deque.front <= i - k:
    pop front
  // maintain decreasing values
  while deque not empty and arr[i] >= arr[deque.back]:
    pop back
  push i onto back
  if i >= k-1:
    max = arr[deque.front]\n\nThis maintains a decreasing queue of candidates.`;
      } else if(mode==='varsum'){
        text = `Two-pointer for longest subarray with sum ≤ S:
left = 0, sum = 0, best = 0
for right in 0..n-1:
  sum += arr[right]
  while sum > S and left <= right:
    sum -= arr[left]
    left += 1
  // now sum ≤ S, update best length
  best = max(best, right - left + 1)`;
      } else if(mode==='kdistinct'){
        text = `Sliding window for longest substring with ≤ K distinct chars:
left = 0, best = 0
freq = empty map
for right in 0..n-1:
  freq[s[right]]++
  while distinct(freq) > K:
    freq[s[left]]--
    if freq[s[left]] == 0: remove
    left++
  best = max(best, right - left + 1)`;
      }
      codeArea.textContent = text;
    }

    // Build visual bars (numbers or chars)
    function renderBars(){
      barsDiv.innerHTML = '';
      const max = Math.max(...data.map(v => typeof v === 'number' ? Math.abs(v) : 1), 1);
      const n = data.length;
      arrayInfo.textContent = `n = ${n}`;
      for(let i=0;i<n;i++){
        const v = data[i];
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.dataset.index = i;
        if(typeof v === 'number'){
          const h = Math.max(14, Math.round((Math.abs(v)/max)*220)+16);
          bar.style.height = `${h}px`;
          // color: positives blue, negatives red, zero neutral
          if(v < 0){
            bar.style.background = 'linear-gradient(180deg,#fca5a5,#ef4444)';
            bar.style.color = '#2b0b0b';
          } else {
            bar.style.background = 'linear-gradient(180deg,#60a5fa,#2563eb)';
            bar.style.color = '#07122b';
          }
          const span = document.createElement('div');
          span.className = 'val';
          span.textContent = v;
          bar.appendChild(span);
        } else {
          // char
          bar.style.height = `60px`;
          bar.style.width = '40px';
          bar.style.background = 'linear-gradient(180deg,#94a3b8,#475569)';
          bar.style.borderRadius = '8px';
          bar.style.color = '#08122b';
          const span = document.createElement('div');
          span.className = 'val';
          span.textContent = v;
          bar.appendChild(span);
        }
        barsDiv.appendChild(bar);
      }
    }

    // Steps structure: array of step objects: {left, right, window: [i..j], deque: [{idx,val}], current, best, desc}
    function buildSteps(){
      pause();
      steps = [];
      currentStep = 0;
      dequeView.style.display = 'none';
      dequeContainer.innerHTML = '';
      const raw = inputDataEl.value;
      data = parseArrayInput(raw);
      if(data.length===0){ alert('Input empty'); return; }
      renderBars();
      const mode = modeEl.value;
      if(mode==='fixed'){
        const k = Number(kInput.value);
        if(k <=0){ alert('k must be >=1'); return;}
        buildFixedSteps(data, k, operationEl.value);
      } else if(mode==='deque'){
        const k = Number(kInput2.value);
        if(k <=0){ alert('k must be >=1'); return;}
        buildDequeSteps(data, k);
      } else if(mode==='varsum'){
        const S = Number(sInput.value);
        buildVarSumSteps(data, S);
      } else if(mode==='kdistinct'){
        const k = Number(kInput3.value);
        const s = typeof data === 'string' ? data : (Array.isArray(data) ? data.join('') : inputDataEl.value);
        buildKDistinctSteps(s, k);
      }
      stepTo(0);
    }

    // ------ Fixed-size naive steps ------
    function buildFixedSteps(arr, k, operation){
      const n = arr.length;
      if(k > n){
        description.textContent = `Window size k=${k} is larger than array length ${n}. No steps.`;
        steps = [];
        return;
      }
      let best = (operation === 'max') ? -Infinity : (operation === 'sum' || operation === 'avg') ? null : null;
      for(let i=0;i<=n-k;i++){
        const left = i;
        const right = i+k-1;
        const window = arr.slice(left, right+1).map(x=>x);
        let current;
        if(operation==='sum'){
          current = window.reduce((a,b)=>Number(a)+Number(b),0);
          best = (best===null)?current:Math.max(best,current);
        } else if(operation==='avg'){
          current = window.reduce((a,b)=>Number(a)+Number(b),0)/k;
          best = (best===null)?current:Math.max(best,current);
        } else if(operation==='max'){
          current = window.reduce((a,b)=>Math.max(a,b), -Infinity);
          best = Math.max(best,current);
        }
        steps.push({
          left, right, window: [left,right],
          deque: [],
          current,
          best,
          desc: `Window [${left}..${right}] → values: [${window.join(', ')}]. ${operation} = ${Number.isFinite(current) ? current : current}`
        });
      }
      description.textContent = `Naive sliding window (${operation}) produced ${steps.length} windows.`;
      updateCodeSnippet('fixed');
    }

    // ------ Deque optimized max steps ------
    function buildDequeSteps(arr, k){
      const n = arr.length;
      if(k > n){
        description.textContent = `Window size k=${k} is larger than array length ${n}. No steps.`;
        steps = [];
        return;
      }
      dequeView.style.display = 'block';
      updateCodeSnippet('deque');

      let dq = []; // will store indices
      let bestResults = [];
      for(let i=0;i<n;i++){
        // Step: process arr[i] insertion with description of pops
        let stepBefore = {
          left: null, right: i,
          window: null,
          deque: dq.slice(),
          current: null,
          best: null,
          desc: `Processing index ${i}, value=${arr[i]}.`
        };
        steps.push({...stepBefore, desc: `Processing index ${i}, value=${arr[i]}. Remove outdated at front if any.`});
        // remove out-of-window from front
        if(dq.length && dq[0] <= i - k){
          let popped = dq[0];
          dq = dq.slice(1);
          steps.push({
            left: null, right: i,
            window: null,
            deque: dq.slice(),
            current: null,
            best: null,
            desc: `Removed index ${popped} from front (out of window range).`
          });
        }
        // remove from back while arr[i] >= arr[dq.back]
        while(dq.length && arr[i] >= arr[dq[dq.length-1]]){
          let popped = dq[dq.length-1];
          dq.pop();
          steps.push({
            left: null, right: i,
            window: null,
            deque: dq.slice(),
            current: null,
            best: null,
            desc: `Popped index ${popped} from back because arr[${i}] (${arr[i]}) >= arr[${popped}] (${arr[popped]}).`
          });
        }
        // push i
        dq.push(i);
        steps.push({
          left: null, right: i,
          window: null,
          deque: dq.slice(),
          current: null,
          best: null,
          desc: `Pushed index ${i}. Deque now: [${dq.join(', ')}] (indices).`
        });
        // if we have first full window, record max
        if(i >= k-1){
          const left = i - k + 1;
          const right = i;
          const maxVal = arr[dq[0]];
          steps.push({
            left, right,
            window: [left,right],
            deque: dq.slice(),
            current: maxVal,
            best: null,
            desc: `Window [${left}..${right}] full. Current max = arr[${dq[0]}] = ${maxVal}.`
          });
        }
      }
      description.textContent = `Deque steps generated (${steps.length} internal steps) for k=${k}.`;
    }

    // ------ Variable sum ≤ S steps ------
    function buildVarSumSteps(arr, S){
      const n = arr.length;
      let left = 0, sum = 0, best = 0, bestRange = null;
      updateCodeSnippet('varsum');
      for(let right=0; right<n; right++){
        sum += Number(arr[right]);
        steps.push({
          left, right,
          window: [left,right],
          deque: [],
          current: sum,
          best,
          desc: `Added arr[${right}] = ${arr[right]}; sum = ${sum}.`
        });
        while(sum > S && left <= right){
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: sum,
            best,
            desc: `sum (${sum}) > S (${S}). Shrinking: remove arr[${left}] = ${arr[left]}.`
          });
          sum -= Number(arr[left]);
          left++;
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: sum,
            best,
            desc: `After shrinking left -> ${left}, sum = ${sum}.`
          });
        }
        // now sum <= S
        if(sum <= S){
          const len = right - left + 1;
          if(len > best){
            best = len;
            bestRange = [left,right];
            steps.push({
              left, right,
              window: [left,right],
              deque: [],
              current: sum,
              best,
              desc: `Valid window [${left}..${right}] (sum=${sum}). New best length = ${best}.`
            });
          } else {
            steps.push({
              left, right,
              window: [left,right],
              deque: [],
              current: sum,
              best,
              desc: `Valid window [${left}..${right}] (sum=${sum}). Best remains ${best}.`
            });
          }
        }
      }
      description.textContent = `Two-pointer steps generated for S=${S}. Best length = ${best}${bestRange ? ` in [${bestRange[0]}..${bestRange[1]}]` : ''}.`;
    }

    // ------ K distinct chars steps ------
    function buildKDistinctSteps(str, K){
      // treat str as string of chars
      const arr = str.split('');
      const n = arr.length;
      let left = 0, best = 0, bestRange = null;
      const freq = {};
      updateCodeSnippet('kdistinct');
      for(let right=0; right<n; right++){
        const ch = arr[right];
        freq[ch] = (freq[ch]||0)+1;
        steps.push({
          left, right,
          window: [left,right],
          deque: [],
          current: Object.keys(freq).length,
          best,
          desc: `Added '${ch}' at ${right}. Distinct now = ${Object.keys(freq).length}.`
        });
        while(Object.keys(freq).length > K){
          const rem = arr[left];
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: Object.keys(freq).length,
            best,
            desc: `Too many distinct (>${K}). Removing '${rem}' at left=${left}.`
          });
          freq[rem]--;
          if(freq[rem] === 0) delete freq[rem];
          left++;
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: Object.keys(freq).length,
            best,
            desc: `After removal left=${left}. Distinct = ${Object.keys(freq).length}.`
          });
        }
        // now valid
        const len = right - left + 1;
        if(len > best){
          best = len; bestRange = [left,right];
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: Object.keys(freq).length,
            best,
            desc: `Valid substring '${arr.slice(left,right+1).join('')}'. New best length = ${best}.`
          });
        } else {
          steps.push({
            left, right,
            window: [left,right],
            deque: [],
            current: Object.keys(freq).length,
            best,
            desc: `Valid substring '${arr.slice(left,right+1).join('')}'. Best remains ${best}.`
          });
        }
      }
      description.textContent = `Longest substring with ≤ ${K} distinct: length=${best}${bestRange? `, range [${bestRange[0]}..${bestRange[1]}]` : ''}.`;
    }

    // Step rendering
    function stepTo(i){
      if(steps.length===0){
        stepIndicator.textContent = 'Step 0 / 0';
        description.textContent = 'No steps available. Press Apply to generate steps.';
        leftIdx.textContent = '-';
        rightIdx.textContent = '-';
        windowIdx.textContent = '-';
        currentValue.textContent = '-';
        bestValue.textContent = '-';
        renderBars();
        return;
      }
      if(i < 0) i = 0;
      if(i > steps.length-1) i = steps.length-1;
      currentStep = i;
      const s = steps[i];
      // update indicator
      stepIndicator.textContent = `Step ${i+1} / ${steps.length}`;
      // update description
      description.textContent = s.desc || '';
      // update pointers
      leftIdx.textContent = (s.left == null) ? '-' : s.left;
      rightIdx.textContent = (s.right == null) ? '-' : s.right;
      windowIdx.textContent = (s.window && s.window.length===2) ? `[${s.window[0]}..${s.window[1]}]` : '-';
      currentValue.textContent = s.current == null ? '-' : s.current;
      bestValue.textContent = s.best == null ? '-' : s.best;

      // highlight bars depending on window
      const barElems = barsDiv.querySelectorAll('.bar');
      barElems.forEach(b => {
        b.classList.remove('in-window','out-of-window');
      });

      if(s.window && s.window.length===2){
        const L = s.window[0], R = s.window[1];
        barElems.forEach(b => {
          const idx = Number(b.dataset.index);
          if(idx >= L && idx <= R) b.classList.add('in-window');
          else b.classList.add('out-of-window');
        });
      } else if(typeof s.left === 'number' && typeof s.right === 'number'){
        // when left/right denote pointers but not full window
        const L = s.left, R = s.right;
        barElems.forEach(b => {
          const idx = Number(b.dataset.index);
          if(idx >= L && idx <= R) b.classList.add('in-window');
          else b.classList.add('out-of-window');
        });
      } else {
        barElems.forEach(b => b.classList.remove('out-of-window'));
      }

      // deque view
      if(s.deque && s.deque.length){
        dequeView.style.display = 'block';
      } else {
        // only show deque view in deque mode (we keep block when used)
        // But hide if no deque
        if(modeEl.value !== 'deque') dequeView.style.display = 'none';
      }
      dequeContainer.innerHTML = '';
      if(s.deque && s.deque.length){
        s.deque.forEach(idx=>{
          const item = document.createElement('div');
          item.className = 'dq-item';
          item.textContent = `${idx} → ${data[idx]}`;
          dequeContainer.appendChild(item);
        });
      }

      // simple auto-scroll: center current window
      // Not necessary but helpful for long arrays: shift container scrollLeft
      // Compute bounding
      const firstIn = barsDiv.querySelector('.bar.in-window');
      if(firstIn){
        const rect = firstIn.getBoundingClientRect();
        const parentRect = barsDiv.getBoundingClientRect();
        const offset = (rect.left - parentRect.left) - parentRect.width/2 + rect.width/2;
        barsDiv.scrollLeft += offset;
      }
    }

    // initialize UI
    setModeUI();
    renderBars();

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key === ' ') { e.preventDefault(); togglePlay(); }
      if(e.key === 'ArrowRight') { e.preventDefault(); stepTo(currentStep+1); pause(); }
      if(e.key === 'ArrowLeft') { e.preventDefault(); stepTo(currentStep-1); pause(); }
    });

    // initial
    // Build default steps on load
    buildSteps();

  </script>
</body>
</html>