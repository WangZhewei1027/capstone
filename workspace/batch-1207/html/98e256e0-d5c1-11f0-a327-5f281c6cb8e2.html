<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bellman-Ford Algorithm Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#7c3aed;
      --muted:#94a3b8;
      --card:#0b1220;
      --ok:#16a34a;
      --bad:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{background: linear-gradient(180deg,#071029 0%, #071727 50%); color:#e6eef8; display:flex; gap:12px; padding:14px; box-sizing:border-box;}
    .sidebar{
      width:360px;
      min-width:260px;
      background:var(--panel);
      padding:12px;
      border-radius:12px;
      box-shadow: 0 6px 22px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .canvas-wrap{
      flex:1;
      position:relative;
      border-radius:12px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
    }
    .topbar{
      display:flex;
      gap:8px;
      align-items:center;
    }
    button, .seg {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button.active, .seg.active { border-color: var(--accent); color:#c7b3ff; box-shadow: 0 4px 18px rgba(124,58,237,0.12); }
    button.small { padding:6px 8px; font-size:12px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .hint{ font-size:12px; color:var(--muted); margin-top:6px;}
    canvas{ flex:1; display:block; background:
      radial-gradient(1200px 800px at 10% 10%, rgba(124,58,237,0.04), transparent 6%),
      radial-gradient(700px 400px at 90% 90%, rgba(16,185,129,0.02), transparent 4%); cursor:crosshair;
    }
    .panel-section {
      background:var(--glass);
      border-radius:10px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .row { display:flex; gap:8px; align-items:center; }
    .table {
      max-height:220px;
      overflow:auto;
      margin-top:8px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.02);
      padding:6px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    }
    .table .item { display:flex; gap:10px; align-items:center; padding:6px 6px; border-radius:6px; }
    .badge { font-size:12px; color: #111827; background: rgba(255,255,255,0.06); padding:4px 8px; border-radius:6px; min-width:38px; text-align:center; }
    .status { font-size:13px; }
    .log { max-height:160px; overflow:auto; font-size:13px; color:var(--muted); background:transparent; padding:6px; border-radius:6px; }
    .footer {
      display:flex;
      gap:8px;
      margin-top:auto;
      align-items:center;
      justify-content:space-between;
    }
    .small-muted { font-size:12px; color:var(--muted); }
    .danger { color:var(--bad); font-weight:600; }
    .ok { color:var(--ok); font-weight:600; }
    .node-label { font-weight:700; font-size:13px; color:#e6eef8; }
    .controls .seg { padding:6px 8px; }
    .help { font-size:12px; color:var(--muted); }
    input[type=range]{ width:120px; }
  </style>
</head>
<body>
  <div class="sidebar panel-section">
    <div class="topbar">
      <div style="font-weight:800; font-size:16px; color:#fff;">Bellman-Ford Visualizer</div>
      <div style="margin-left:auto; font-size:12px; color:var(--muted);">Step-by-step relaxation</div>
    </div>

    <div class="controls">
      <button id="btn-add-node" class="seg active">Add Node</button>
      <button id="btn-add-edge" class="seg">Add Edge</button>
      <button id="btn-select-source" class="seg">Select Source</button>
      <button id="btn-set-target" class="seg">Select Target</button>
      <button id="btn-clear" class="seg small">Clear</button>
    </div>
    <div class="hint">Click canvas to add nodes. For edges: click source node then target node. Double-click node to delete it. Double-click edge to delete it.</div>

    <div class="panel-section" style="margin-top:8px;">
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="btn-run" class="seg">Run Bellman‑Ford</button>
        <button id="btn-step-back" class="seg small">⟵</button>
        <button id="btn-step" class="seg small">⟶</button>
        <button id="btn-play" class="seg small">Play</button>
        <label class="small-muted" style="margin-left:auto">Speed:</label>
        <input id="speed" type="range" min="200" max="2000" value="800" step="50" />
      </div>
      <div class="hint">Step through relaxations. After n-1 iterations, Bellman-Ford detects negative cycles if present.</div>
    </div>

    <div class="panel-section">
      <div style="display:flex; gap:8px; align-items:center;">
        <div class="small-muted">Iterations:</div>
        <div id="lbl-iteration" class="badge">0</div>
        <div style="width:8px;"></div>
        <div class="small-muted">Current Edge:</div>
        <div id="lbl-edge" class="badge">—</div>
      </div>

      <div class="table" id="distance-table" aria-live="polite"></div>
    </div>

    <div class="panel-section">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700">Log</div>
        <div class="small-muted">Negative cycle: <span id="neg-status" class="small-muted">unknown</span></div>
      </div>
      <div class="log" id="log"></div>
    </div>

    <div class="footer">
      <div class="small-muted">Click a node as Target to highlight shortest path.</div>
      <div style="display:flex; gap:8px;">
        <div id="lbl-source" class="badge">S: —</div>
        <div id="lbl-target" class="badge">T: —</div>
      </div>
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="canvas"></canvas>
  </div>

<script>
/*
  Bellman-Ford Visualizer
  - Add nodes by clicking canvas.
  - Add edges by selecting "Add Edge" and clicking source then target. You will be prompted for weight (can be negative).
  - Select source: choose source node for algorithm.
  - Select target: choose a target node to highlight final path.
  - Run Bellman-Ford: produces step history. Use arrows to step, Play to animate.
  - Double-click node to delete. Double-click edge to delete (click near edge).
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

function resizeCanvas(){
  DPR = window.devicePixelRatio || 1;
  canvas.width = Math.floor(canvas.clientWidth * DPR);
  canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 10);

// Graph model
let nodes = []; // {id,x,y}
let edges = []; // {id,u,v,w}
let nodeIdCounter = 0;
let edgeIdCounter = 0;

const stateMode = {
  addNode:true, addEdge:false, selectSource:false, selectTarget:false
};

const elements = {
  btnAddNode: document.getElementById('btn-add-node'),
  btnAddEdge: document.getElementById('btn-add-edge'),
  btnSelectSource: document.getElementById('btn-select-source'),
  btnSetTarget: document.getElementById('btn-set-target'),
  btnClear: document.getElementById('btn-clear'),
  btnRun: document.getElementById('btn-run'),
  btnStep: document.getElementById('btn-step'),
  btnStepBack: document.getElementById('btn-step-back'),
  btnPlay: document.getElementById('btn-play'),
  lblIteration: document.getElementById('lbl-iteration'),
  lblEdge: document.getElementById('lbl-edge'),
  distanceTable: document.getElementById('distance-table'),
  log: document.getElementById('log'),
  negStatus: document.getElementById('neg-status'),
  lblSource: document.getElementById('lbl-source'),
  lblTarget: document.getElementById('lbl-target'),
  speed: document.getElementById('speed')
};

// Interaction state
let edgeTemp = null; // {fromNodeId}
let selectedSource = null;
let selectedTarget = null;

// Visualization state
let history = []; // snapshots array
let stepIndex = 0;
let playing = false;
let playTimer = null;

function setMode(mode){
  // mode is one of addNode, addEdge, selectSource, selectTarget
  for(let k in stateMode) stateMode[k] = false;
  stateMode[mode] = true;
  elements.btnAddNode.classList.toggle('active', stateMode.addNode);
  elements.btnAddEdge.classList.toggle('active', stateMode.addEdge);
  elements.btnSelectSource.classList.toggle('active', stateMode.selectSource);
  elements.btnSetTarget.classList.toggle('active', stateMode.selectTarget);
}
elements.btnAddNode.addEventListener('click', ()=> setMode('addNode'));
elements.btnAddEdge.addEventListener('click', ()=> setMode('addEdge'));
elements.btnSelectSource.addEventListener('click', ()=> setMode('selectSource'));
elements.btnSetTarget.addEventListener('click', ()=> setMode('selectTarget'));
elements.btnClear.addEventListener('click', ()=> {
  if(!confirm('Clear entire graph?')) return;
  nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;
  history = []; stepIndex = 0; playing = false; clearInterval(playTimer); playTimer=null;
  selectedSource = null; selectedTarget = null;
  elements.lblSource.textContent = 'S: —';
  elements.lblTarget.textContent = 'T: —';
  elements.negStatus.textContent = 'unknown';
  elements.distanceTable.innerHTML = '';
  elements.log.innerHTML = '';
  draw();
});

elements.btnRun.addEventListener('click', ()=> {
  if(nodes.length===0){ alert('Add nodes first'); return; }
  if(selectedSource==null){ alert('Select a source node first. Click "Select Source" and then a node.'); return; }
  runBellmanFord();
});

elements.btnStep.addEventListener('click', ()=> {
  if(history.length===0){ alert('Run algorithm first'); return; }
  if(stepIndex < history.length-1){
    stepIndex++;
    applySnapshot(stepIndex);
  }
});
elements.btnStepBack.addEventListener('click', ()=> {
  if(history.length===0) return;
  if(stepIndex>0){ stepIndex--; applySnapshot(stepIndex); }
});
elements.btnPlay.addEventListener('click', ()=> {
  if(history.length===0){ alert('Run algorithm first'); return; }
  if(playing){ playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }
  else {
    playing=true; elements.btnPlay.textContent='Pause';
    playTimer = setInterval(()=>{
      if(stepIndex < history.length-1){ stepIndex++; applySnapshot(stepIndex); }
      else { playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }
    }, parseInt(elements.speed.value));
  }
});

elements.speed.addEventListener('input', ()=> {
  if(playing){
    clearInterval(playTimer);
    playTimer = setInterval(()=>{
      if(stepIndex < history.length-1){ stepIndex++; applySnapshot(stepIndex); }
      else { playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }
    }, parseInt(elements.speed.value));
  }
});

// Canvas events
canvas.addEventListener('click', (ev)=> {
  const rect = canvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left);
  const y = (ev.clientY - rect.top);
  if(stateMode.addNode){
    addNode(x,y);
    return;
  }
  const clickedNode = findNodeAt(x,y);
  if(stateMode.addEdge){
    if(edgeTemp==null){
      if(clickedNode){
        edgeTemp = {from: clickedNode.id};
        // set temporary indicator
      }
    } else {
      if(clickedNode && clickedNode.id !== edgeTemp.from){
        // prompt weight
        let w = prompt('Edge weight (number, can be negative):', '1');
        if(w===null) { edgeTemp=null; draw(); return; }
        w = parseFloat(w);
        if(Number.isNaN(w)){ alert('Invalid number'); edgeTemp=null; draw(); return; }
        addEdge(edgeTemp.from, clickedNode.id, w);
      }
      edgeTemp = null;
    }
    draw();
    return;
  }
  if(stateMode.selectSource){
    if(clickedNode){
      selectedSource = clickedNode.id;
      elements.lblSource.textContent = 'S: ' + labelForNode(selectedSource);
      setMode('addNode');
    }
    return;
  }
  if(stateMode.selectTarget){
    if(clickedNode){
      selectedTarget = clickedNode.id;
      elements.lblTarget.textContent = 'T: ' + labelForNode(selectedTarget);
      setMode('addNode');
    }
    return;
  }
  // Not in any mode - maybe select target for path highlight
  if(clickedNode){
    selectedTarget = clickedNode.id;
    elements.lblTarget.textContent = 'T: ' + labelForNode(selectedTarget);
    draw();
  }
});

// double-click to delete nodes / edges
canvas.addEventListener('dblclick', (ev)=> {
  const rect = canvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left);
  const y = (ev.clientY - rect.top);
  const clickedNode = findNodeAt(x,y);
  if(clickedNode){
    if(!confirm('Delete node ' + labelForNode(clickedNode.id) + ' and its incident edges?')) return;
    deleteNode(clickedNode.id);
    return;
  }
  const clickedEdge = findEdgeNear(x,y);
  if(clickedEdge){
    if(!confirm('Delete edge ' + labelForNode(clickedEdge.u) + ' → ' + labelForNode(clickedEdge.v) + ' ?')) return;
    deleteEdge(clickedEdge.id);
    return;
  }
});

// Helpers
function addNode(x,y){
  const id = nodeIdCounter++;
  nodes.push({id:id, x:x, y:y});
  draw();
}
function deleteNode(id){
  nodes = nodes.filter(n=>n.id!==id);
  edges = edges.filter(e=> e.u !== id && e.v !== id);
  if(selectedSource === id) selectedSource=null;
  if(selectedTarget === id) selectedTarget=null;
  draw();
}
function addEdge(u,v,w){
  const id = edgeIdCounter++;
  edges.push({id:id, u:u, v:v, w: w});
  draw();
}
function deleteEdge(id){
  edges = edges.filter(e=>e.id!==id);
  draw();
}
function findNodeAt(x,y){
  for(let i=nodes.length-1;i>=0;i--){
    const n = nodes[i];
    const dx = n.x - x, dy = n.y - y;
    if(Math.sqrt(dx*dx+dy*dy) <= 18) return n;
  }
  return null;
}
function findEdgeNear(x,y){
  // Returns first edge near click (distance to segment <8)
  for(let e of edges){
    const a = nodes.find(n=>n.id===e.u);
    const b = nodes.find(n=>n.id===e.v);
    if(!a||!b) continue;
    const dist = distancePointToSegment({x,y}, a, b);
    if(dist < 8) return e;
  }
  return null;
}
function distancePointToSegment(p, a, b){
  const vx = b.x - a.x, vy = b.y - a.y;
  const wx = p.x - a.x, wy = p.y - a.y;
  const c1 = vx*wx + vy*wy;
  if(c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);
  const c2 = vx*vx + vy*vy;
  if(c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);
  const t = c1 / c2;
  const projx = a.x + t*vx, projy = a.y + t*vy;
  return Math.hypot(p.x-projx, p.y-projy);
}
function labelForNode(id){
  return String.fromCharCode(65 + (id % 26)) + (Math.floor(id/26) ? (Math.floor(id/26)) : '');
}

// Drawing
function draw(snapshot=null){
  // snapshot: optional for highlighting current frame (history[stepIndex])
  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);
  // draw edges
  for(let e of edges){
    drawEdge(e, snapshot);
  }
  // draw nodes
  for(let n of nodes){
    drawNode(n, snapshot);
  }
  // if adding edge and have temp from, draw fade line to mouse? We don't track mouse - skip
  if(edgeTemp && edgeTemp.from != null){
    const fromNode = nodes.find(nn=>nn.id===edgeTemp.from);
    // draw ring around from
    if(fromNode){
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(124,58,237,0.6)';
      ctx.lineWidth = 3;
      ctx.arc(fromNode.x, fromNode.y, 22, 0, Math.PI*2);
      ctx.stroke();
    }
  }
}

function drawNode(n, snapshot){
  const r = 18;
  // Determine highlight
  let fill = 'rgba(8,12,20,0.9)';
  let stroke = 'rgba(255,255,255,0.06)';
  let textColor = '#e6eef8';
  if(n.id === selectedSource) { stroke = 'rgba(124,58,237,0.95)'; fill = 'rgba(124,58,237,0.12)'; }
  if(n.id === selectedTarget) { stroke = 'rgba(16,185,129,0.95)'; fill = 'rgba(16,185,129,0.08)'; }
  // If snapshot includes updated nodes or in negative cycle set, color accordingly
  if(snapshot){
    const dist = snapshot.distances[n.id];
    if(Number.isFinite(dist) && snapshot.updated && snapshot.updated.has(n.id)){
      fill = 'rgba(34,197,94,0.12)'; stroke = 'rgba(34,197,94,0.9)';
    }
    if(snapshot.negativeCycleNodes && snapshot.negativeCycleNodes.has(n.id)){
      fill = 'rgba(239,68,68,0.14)'; stroke = 'rgba(239,68,68,0.9)';
    }
  }
  ctx.beginPath();
  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  roundRect(ctx, n.x - r, n.y - r, r*2, r*2, 40);
  ctx.fill();
  ctx.stroke();

  // label
  ctx.fillStyle = textColor;
  ctx.font = 'bold 13px system-ui,Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(labelForNode(n.id), n.x, n.y - 2);

  // distance bubble
  if(snapshot && snapshot.distances){
    const d = snapshot.distances[n.id];
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    const w = 56, h = 22;
    roundRect(ctx, n.x - w/2, n.y + 14, w, h, 6);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = 'rgba(200,220,255,0.95)';
    ctx.font = '12px system-ui,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(Number.isFinite(d) ? d.toString() : '∞', n.x, n.y + 14 + h/2);
  }
}

function drawEdge(e, snapshot){
  const a = nodes.find(n=>n.id===e.u);
  const b = nodes.find(n=>n.id===e.v);
  if(!a || !b) return;
  // arrow
  const dx = b.x - a.x, dy = b.y - a.y;
  const ang = Math.atan2(dy, dx);
  const offset = 22;
  const fromX = a.x + Math.cos(ang) * offset;
  const fromY = a.y + Math.sin(ang) * offset;
  const toX = b.x - Math.cos(ang) * offset;
  const toY = b.y - Math.sin(ang) * offset;

  // Determine color
  let color = 'rgba(255,255,255,0.06)';
  let width = 1.2;
  let dashed = false;

  if(snapshot){
    // Highlight current edge
    if(snapshot.currentEdge && snapshot.currentEdge.id === e.id){
      color = 'rgba(124,58,237,0.95)';
      width = 3.0;
    }
    // If relaxed this step, color green
    if(snapshot.relaxedEdge && snapshot.relaxedEdge.id === e.id){
      color = 'rgba(34,197,94,0.95)';
      width = 3.2;
    }
    // If part of negative cycle, red
    if(snapshot.negativeCycleEdges && snapshot.negativeCycleEdges.has(e.id)){
      color = 'rgba(239,68,68,0.95)';
      width = 3.0;
      dashed = false;
    }
  }

  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  if(dashed) ctx.setLineDash([6,6]); else ctx.setLineDash([]);
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  // arrow head
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.setLineDash([]);
  const arrowSize = 8;
  ctx.moveTo(toX, toY);
  ctx.lineTo(toX - arrowSize * Math.cos(ang - Math.PI/8), toY - arrowSize * Math.sin(ang - Math.PI/8));
  ctx.lineTo(toX - arrowSize * Math.cos(ang + Math.PI/8), toY - arrowSize * Math.sin(ang + Math.PI/8));
  ctx.closePath();
  ctx.fill();

  // weight label near middle
  const mx = (fromX + toX)/2, my = (fromY + toY)/2;
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = '12px system-ui,Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(e.w, mx, my - 10);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}

// Bellman-Ford algorithm: produce history of snapshots for visualization
function runBellmanFord(){
  // Build adjacency list from edges
  const n = nodes.length;
  const nodeIds = nodes.map(n=>n.id);
  const idIndex = {};
  nodeIds.forEach((id, i)=> idIndex[id] = i);

  // Initialize distances
  const INF = Infinity;
  let dist = {};
  let pred = {};
  for(let id of nodeIds){
    dist[id] = INF;
    pred[id] = null;
  }
  dist[selectedSource] = 0;

  history = [];
  // initial snapshot
  history.push({
    iteration: 0,
    edgeIndex: -1,
    currentEdge: null,
    relaxedEdge: null,
    distances: {...dist},
    predecessors: {...pred},
    updated: new Set(),
    negativeCycleEdges: new Set(),
    negativeCycleNodes: new Set(),
    log: ['Initialized distances (source ' + labelForNode(selectedSource) + ' = 0)']
  });

  // Relax edges n-1 times, record each relaxation attempt as a snapshot
  let log = [];
  for(let iter=1; iter<=n-1; iter++){
    let anyUpdateThisIter = false;
    for(let ei=0; ei<edges.length; ei++){
      const e = edges[ei];
      const u = e.u, v = e.v, w = e.w;
      const oldDistV = dist[v];
      const currEdgeInfo = {id:e.id, u:u, v:v, w:w};
      let distancesBefore = {...dist};
      let predsBefore = {...pred};
      // create snapshot for current edge attempt before relaxation action
      history.push({
        iteration: iter,
        edgeIndex: ei,
        currentEdge: currEdgeInfo,
        relaxedEdge: null,
        distances: {...dist},
        predecessors: {...pred},
        updated: new Set(),
        negativeCycleEdges: new Set(),
        negativeCycleNodes: new Set(),
        log: null
      });

      if(Number.isFinite(dist[u]) && dist[u] + w < dist[v]){
        // relax
        dist[v] = dist[u] + w;
        pred[v] = u;
        anyUpdateThisIter = true;
        const stepLog = 'Iter ' + iter + ': Relax edge ' + labelForNode(u) + '→' + labelForNode(v) + ' (w=' + w + '), updated dist[' + labelForNode(v) + '] = ' + dist[v];
        history.push({
          iteration: iter,
          edgeIndex: ei,
          currentEdge: currEdgeInfo,
          relaxedEdge: currEdgeInfo,
          distances: {...dist},
          predecessors: {...pred},
          updated: new Set([v]),
          negativeCycleEdges: new Set(),
          negativeCycleNodes: new Set(),
          log: stepLog
        });
      } else {
        const stepLog = 'Iter ' + iter + ': Edge ' + labelForNode(u) + '→' + labelForNode(v) + ' (w=' + w + '), no change';
        // Repeat state (no change) to show attempt
        history.push({
          iteration: iter,
          edgeIndex: ei,
          currentEdge: currEdgeInfo,
          relaxedEdge: null,
          distances: {...dist},
          predecessors: {...pred},
          updated: new Set(),
          negativeCycleEdges: new Set(),
          negativeCycleNodes: new Set(),
          log: stepLog
        });
      }
    }
    if(!anyUpdateThisIter){
      // early stop; record that we have converged
      history.push({
        iteration: iter,
        edgeIndex: edges.length,
        currentEdge: null,
        relaxedEdge: null,
        distances: {...dist},
        predecessors: {...pred},
        updated: new Set(),
        negativeCycleEdges: new Set(),
        negativeCycleNodes: new Set(),
        log: 'Terminated early at iteration ' + iter + ' (no changes)'
      });
      break;
    }
  }

  // After n-1 iterations, detect negative cycles: run one more pass and see edges that can still relax
  const possibleNegEdges = new Set();
  for(let e of edges){
    const u=e.u, v=e.v, w=e.w;
    if(Number.isFinite(dist[u]) && dist[u] + w < dist[v]){
      possibleNegEdges.add(e.id);
    }
  }

  let negativeCycleNodes = new Set();
  let negativeCycleEdges = new Set();
  if(possibleNegEdges.size>0){
    // From nodes involved, follow predecessors to extract cycles
    for(let eid of possibleNegEdges){
      negativeCycleEdges.add(eid);
      const e = edges.find(x=>x.id===eid);
      if(!e) continue;
      // find a node reachable from v by following predecessors up to n times to form a cycle
      let node = e.v;
      // move up n steps to ensure within cycle
      for(let i=0;i<n;i++) node = (pred[node] !== null) ? pred[node] : node;
      // now record cycle by following successors (pred pointers) until we loop
      let current = node;
      const visited = new Set();
      for(let i=0;i<n*2;i++){
        if(visited.has(current)) break;
        visited.add(current);
        negativeCycleNodes.add(current);
        if(pred[current] === null) break;
        // find edge pred[current] -> current
        const ed = edges.find(x=> x.u === pred[current] && x.v === current);
        if(ed) negativeCycleEdges.add(ed.id);
        current = pred[current];
      }
    }
    // record detection snapshot
    history.push({
      iteration: Number.MAX_SAFE_INTEGER,
      edgeIndex: -1,
      currentEdge: null,
      relaxedEdge: null,
      distances: {...dist},
      predecessors: {...pred},
      updated: new Set(),
      negativeCycleEdges: negativeCycleEdges,
      negativeCycleNodes: negativeCycleNodes,
      log: 'Negative cycle detected! Edges involved highlighted in red.'
    });
  } else {
    history.push({
      iteration: Number.MAX_SAFE_INTEGER,
      edgeIndex: -1,
      currentEdge: null,
      relaxedEdge: null,
      distances: {...dist},
      predecessors: {...pred},
      updated: new Set(),
      negativeCycleEdges: new Set(),
      negativeCycleNodes: new Set(),
      log: 'No negative cycle detected.'
    });
  }

  // Final snapshot
  stepIndex = 0;
  applySnapshot(0);
  elements.log.innerHTML = '';
  // show first log
  setTimeout(()=> appendLog(history[0].log), 10);
  draw();
}

function appendLog(msg){
  if(!msg) return;
  const div = document.createElement('div');
  div.textContent = msg;
  elements.log.prepend(div);
}

// Apply snapshot at given index to UI and draw
function applySnapshot(index){
  if(index < 0 || index >= history.length) return;
  stepIndex = index;
  const snap = history[index];
  elements.lblIteration.textContent = snap.iteration === Number.MAX_SAFE_INTEGER ? 'final' : snap.iteration;
  elements.lblEdge.textContent = snap.currentEdge ? (labelForNode(snap.currentEdge.u) + '→' + labelForNode(snap.currentEdge.v)) : '—';
  // update table
  renderDistanceTable(snap.distances, snap.predecessors);
  // update log if available
  if(snap.log){
    appendLog(snap.log);
    if(snap.log.includes('Negative cycle')) elements.negStatus.textContent = 'YES', elements.negStatus.className='danger';
    else if(snap.log.includes('No negative')) elements.negStatus.textContent='NO', elements.negStatus.className='ok';
    else elements.negStatus.textContent='running', elements.negStatus.className='';
  }
  // prepare highlight info & draw
  draw(snap);

  // If target is selected, highlight path from source to target (overlay)
  if(selectedTarget !== null){
    highlightPath(snap.predecessors, snap.distances, selectedTarget);
  }
}

// Render distance table
function renderDistanceTable(distances, predecessors){
  const items = [];
  for(let n of nodes){
    const id = n.id;
    const d = distances && distances[id];
    const p = predecessors && predecessors[id];
    items.push({id,d,p});
  }
  // sort by id for consistent display
  items.sort((a,b)=>a.id-b.id);
  elements.distanceTable.innerHTML = '';
  for(let it of items){
    const div = document.createElement('div');
    div.className = 'item';
    const lbl = document.createElement('div');
    lbl.style.flex = '1';
    lbl.innerHTML = '<div class="node-label">' + labelForNode(it.id) + '</div><div class="small-muted">pred: ' + (it.p!==null ? labelForNode(it.p) : '—') + '</div>';
    const val = document.createElement('div');
    val.className = 'badge';
    val.textContent = Number.isFinite(it.d) ? it.d : '∞';
    div.appendChild(lbl);
    div.appendChild(val);
    elements.distanceTable.appendChild(div);
  }
}

// Highlight path overlay from source to target using current predecessors
function highlightPath(predecessors, distances, targetId){
  // draw path arrow overlay on top
  // reconstruct path
  const path = [];
  let cur = targetId;
  const seen = new Set();
  while(cur !== null && !seen.has(cur)){
    seen.add(cur);
    path.push(cur);
    cur = predecessors[cur] !== undefined ? predecessors[cur] : null;
  }
  path.reverse();
  // If first node must be source, otherwise path invalid
  if(path.length === 0 || path[0] !== selectedSource){
    // no valid path
    return;
  }
  // draw arrows for path
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let i=0;i<path.length-1;i++){
    const a = nodes.find(n=>n.id===path[i]);
    const b = nodes.find(n=>n.id===path[i+1]);
    if(!a || !b) continue;
    const dx = b.x - a.x, dy = b.y - a.y;
    const ang = Math.atan2(dy, dx);
    const offset = 22;
    const fromX = a.x + Math.cos(ang) * offset;
    const fromY = a.y + Math.sin(ang) * offset;
    const toX = b.x - Math.cos(ang) * offset;
    const toY = b.y - Math.sin(ang) * offset;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(99,102,241,0.95)';
    ctx.lineWidth = 4;
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    // arrow head
    ctx.beginPath();
    ctx.fillStyle = 'rgba(99,102,241,0.95)';
    const arrowSize = 10;
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - arrowSize * Math.cos(ang - Math.PI/8), toY - arrowSize * Math.sin(ang - Math.PI/8));
    ctx.lineTo(toX - arrowSize * Math.cos(ang + Math.PI/8), toY - arrowSize * Math.sin(ang + Math.PI/8));
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

// Initialize with sample graph
function seedSampleGraph(){
  nodes = [];
  edges = [];
  nodeIdCounter = 0; edgeIdCounter = 0;
  // positions
  addNode(120,80); // A id 0
  addNode(300,60); // B id 1
  addNode(520,80); // C id 2
  addNode(200,220); // D id 3
  addNode(420,220); // E id 4

  addEdge(0,1,6);
  addEdge(0,3,7);
  addEdge(1,2,5);
  addEdge(1,3,8);
  addEdge(1,4,-4);
  addEdge(2,1,-2);
  addEdge(3,2,-3);
  addEdge(3,4,9);
  addEdge(4,0,2);
  draw();
}
seedSampleGraph();

// Responsive canvas sizing
function fitCanvas(){
  const wrap = document.querySelector('.canvas-wrap');
  const rect = wrap.getBoundingClientRect();
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  resizeCanvas();
}
window.addEventListener('resize', fitCanvas);
setTimeout(fitCanvas, 10);

// Provide simple keyboard shortcuts
window.addEventListener('keydown', (ev)=>{
  if(ev.key === '1') setMode('addNode');
  if(ev.key === '2') setMode('addEdge');
  if(ev.key === '3') setMode('selectSource');
  if(ev.key === '4') setMode('selectTarget');
  if(ev.key === ' ') { ev.preventDefault(); elements.btnPlay.click(); }
  if(ev.key === 'ArrowRight') elements.btnStep.click();
  if(ev.key === 'ArrowLeft') elements.btnStepBack.click();
});

// Draw once initially
draw();

</script>
</body>
</html>