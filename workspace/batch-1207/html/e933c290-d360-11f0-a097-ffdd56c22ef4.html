<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Merge Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --card:#0b1226;
      --bar:#60a5fa;
      --bar2:#34d399;
      --danger:#ef4444;
      --yellow:#f59e0b;
      --white:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{background:linear-gradient(180deg,#071025 0%,#071827 100%);color:var(--white);padding:18px;box-sizing:border-box;}
    .container{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 380px;gap:20px;align-items:start;}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    header h1{font-size:20px;margin:0;color:var(--white)}
    header p{margin:0;color:var(--muted);font-size:13px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .left{min-height:360px;padding:12px;display:flex;flex-direction:column;gap:12px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .controls .btn{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .controls .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--white)}
    .controls input[type=range]{accent-color:var(--accent)}
    .settings{display:flex;flex-direction:column;gap:8px}
    .small{font-size:13px;color:var(--muted)}
    .vis{height:320px;background:linear-gradient(180deg,#071827 0%, #071827 100%);border-radius:8px;display:flex;align-items:end;padding:12px;gap:4px;border:1px solid rgba(255,255,255,0.03);position:relative;overflow:hidden}
    .bar{flex:1 1 auto;margin:0 2px;background:linear-gradient(180deg,var(--bar) 0%, #2b6ecb 100%);border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:rgba(255,255,255,0.9);font-size:11px;font-weight:700}
    .bar.small{font-size:10px}
    .bar .val{transform:translateY(-6px);padding-bottom:6px}
    .legend{display:flex;gap:8px;flex-wrap:wrap;font-size:13px;color:var(--muted);align-items:center}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
    .right{padding:12px;display:flex;flex-direction:column;gap:12px;min-height:360px}
    .panel h3{margin:0 0 8px 0;font-size:15px}
    .code{background:#051123;padding:12px;border-radius:8px;color:var(--muted);font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;line-height:1.45;overflow:auto;max-height:220px;border:1px solid rgba(255,255,255,0.03)}
    .code .line{padding:4px 8px;border-radius:6px}
    .code .line.active{background:linear-gradient(90deg, rgba(59,130,246,0.12), rgba(59,130,246,0.04));color:var(--white);border-left:3px solid rgba(59,130,246,0.75);padding-left:6px}
    .input-area{display:flex;gap:8px;align-items:center}
    textarea{width:100%;min-height:56px;background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--white);resize:vertical}
    .controls-row{display:flex;gap:8px;align-items:center}
    .footer{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted)}
    .status{font-weight:700}
    .oplog{background:#02101a;border-radius:8px;padding:8px;color:var(--muted);font-size:13px;max-height:160px;overflow:auto;border:1px solid rgba(255,255,255,0.02)}
    .op{padding:6px;border-radius:6px}
    .op.compare{color:var(--danger)}
    .op.write{color:var(--bar2)}
    .op.copy{color:var(--yellow)}
    .mode-select{padding:6px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
    @media(max-width:980px){
      .container{grid-template-columns:1fr; padding:8px}
      .right{order:3}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Merge Sort â€” Visualizer & Explorer</h1>
        <p>Interactive demonstration of Merge Sort (Top-down and Bottom-up) with step playback, pseudocode highlighting, and operation log.</p>
      </div>
      <div style="text-align:right">
        <div class="small">Algorithm: Stable, O(n log n) time, O(n) extra space</div>
      </div>
    </header>

    <div class="panel left">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Array Controls</strong>
          <div class="small">Create and manipulate the array to sort.</div>
        </div>
        <div class="legend">
          <div class="chip"><span style="width:12px;height:12px;background:linear-gradient(180deg,var(--bar) 0%, #2b6ecb 100%);border-radius:4px;display:inline-block"></span> Normal</div>
          <div class="chip"><span style="width:12px;height:12px;background:var(--danger);display:inline-block;border-radius:4px"></span> Comparing</div>
          <div class="chip"><span style="width:12px;height:12px;background:var(--yellow);display:inline-block;border-radius:4px"></span> Merging</div>
          <div class="chip"><span style="width:12px;height:12px;background:var(--bar2);display:inline-block;border-radius:4px"></span> Written</div>
          <div class="chip"><span style="width:12px;height:12px;background:var(--white);display:inline-block;border-radius:4px"></span> Sorted</div>
        </div>
      </div>

      <div class="controls" style="margin-top:8px">
        <label class="small">Size: <span id="sizeLabel">30</span></label>
        <input id="sizeRange" type="range" min="5" max="120" value="30" />
        <button class="btn" id="randomBtn">Randomize</button>
        <button class="btn secondary" id="reverseBtn">Reverse</button>
        <select id="modeSelect" class="mode-select" title="Choose merge sort variant">
          <option value="topdown">Top-down (Recursive)</option>
          <option value="bottomup">Bottom-up (Iterative)</option>
        </select>
      </div>

      <div class="input-area" style="margin-top:8px">
        <textarea id="customInput" placeholder="Enter comma-separated numbers (e.g. 5,3,9,1)"></textarea>
        <div style="display:flex;flex-direction:column;gap:8px">
          <button class="btn" id="applyInput">Apply</button>
          <button class="btn secondary" id="clearInput">Clear</button>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <button class="btn" id="startBtn">Start</button>
        <button class="btn secondary" id="stepBtn">Step</button>
        <button class="btn secondary" id="pauseBtn">Pause</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
        <label class="small">Speed</label>
        <input id="speedRange" type="range" min="10" max="1000" value="200" />
      </div>

      <div class="panel" style="margin-top:8px;padding:10px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <strong>Array Visualization</strong>
          <div class="small">Values are shown on the bars.</div>
        </div>
        <div class="vis" id="visArea" aria-label="Array visualization"></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
        <div class="small">Status: <span id="status" class="status">Ready</span></div>
        <div class="small">Operations: <span id="opCount">0</span></div>
      </div>
    </div>

    <div class="panel right">
      <div>
        <h3>Pseudocode</h3>
        <div class="small">Highlighted line maps to the operation currently being animated.</div>
        <div class="code" id="codeBox" aria-hidden="false"></div>
      </div>

      <div>
        <h3>Operation Log</h3>
        <div class="oplog" id="opLog"></div>
      </div>

      <div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:8px">
        <div class="small">Tip: Use Step to advance one recorded operation at a time for detailed inspection.</div>
        <div class="small">Sorted elements turn white when finalized.</div>
      </div>
    </div>
  </div>

<script>
/*
  Merge Sort Visualizer
  - Records operations (compare, write, markSorted) into an operations array.
  - Supports Top-down (recursive) and Bottom-up (iterative) variants.
  - Player with play/pause/step/reset, speed control, custom input and randomize.
*/

// Utilities
const $ = (id) => document.getElementById(id);

const state = {
  array: [],
  bars: [],
  ops: [],
  opIndex: 0,
  playing: false,
  speed: 200,
  mode: 'topdown',
  size: 30,
  locked: false // lock controls during playback preparation/execution
};

// Pseudocode lines for highlighting
const pseudocode = {
  topdown: [
    "function mergeSort(arr, l, r):",
    "  if l >= r: return",
    "  mid = floor((l + r) / 2)",
    "  mergeSort(arr, l, mid)",
    "  mergeSort(arr, mid+1, r)",
    "  merge(arr, l, mid, r)",
    "",
    "function merge(arr, l, mid, r):",
    "  i = l; j = mid+1; k = l",
    "  while i <= mid and j <= r:",
    "    if arr[i] <= arr[j]: arr[k] = arr[i]; i += 1",
    "    else: arr[k] = arr[j]; j += 1",
    "    k += 1",
    "  copy remaining elements from left or right",
    "  return"
  ],
  bottomup: [
    "function mergeSortBottomUp(arr):",
    "  n = arr.length",
    "  width = 1",
    "  while width < n:",
    "    for i = 0; i < n; i += 2*width:",
    "      merge subarrays [i, i+width-1] and [i+width, i+2*width-1]",
    "    width *= 2",
    "",
    "function merge(arr, l, mid, r):",
    "  (same as top-down merge)"
  ]
};

// DOM elements
const visArea = $('visArea');
const sizeRange = $('sizeRange');
const sizeLabel = $('sizeLabel');
const randomBtn = $('randomBtn');
const reverseBtn = $('reverseBtn');
const applyInput = $('applyInput');
const customInput = $('customInput');
const clearInput = $('clearInput');
const startBtn = $('startBtn');
const stepBtn = $('stepBtn');
const pauseBtn = $('pauseBtn');
const resetBtn = $('resetBtn');
const speedRange = $('speedRange');
const statusEl = $('status');
const opCountEl = $('opCount');
const opLog = $('opLog');
const modeSelect = $('modeSelect');
const codeBox = $('codeBox');

function init(){
  attachEvents();
  state.size = parseInt(sizeRange.value);
  sizeLabel.textContent = state.size;
  state.speed = parseInt(speedRange.value);
  state.mode = modeSelect.value;
  renderCode();
  generateRandom(state.size);
  drawArray();
  updateStatus('Ready');
}

function attachEvents(){
  sizeRange.addEventListener('input', ()=>{
    state.size = parseInt(sizeRange.value);
    sizeLabel.textContent = state.size;
  });
  sizeRange.addEventListener('change', ()=>{
    generateRandom(state.size);
    drawArray();
  });
  randomBtn.addEventListener('click', ()=>{ generateRandom(state.size); drawArray(); });
  reverseBtn.addEventListener('click', ()=>{ state.array.reverse(); drawArray(); });
  applyInput.addEventListener('click', applyCustomInput);
  clearInput.addEventListener('click', ()=>{ customInput.value = ''; });
  startBtn.addEventListener('click', startPlayback);
  stepBtn.addEventListener('click', stepOnce);
  pauseBtn.addEventListener('click', pausePlayback);
  resetBtn.addEventListener('click', resetPlayback);
  speedRange.addEventListener('input', ()=>{ state.speed = parseInt(speedRange.value); });
  modeSelect.addEventListener('change', ()=>{
    state.mode = modeSelect.value;
    renderCode();
  });
}

function updateStatus(txt){
  statusEl.textContent = txt;
}

// Array and drawing
function generateRandom(n){
  const arr = [];
  for(let i=0;i<n;i++){
    arr.push(randInt(5, 100));
  }
  state.array = arr;
  state.ops = [];
  state.opIndex = 0;
  opCountEl.textContent = 0;
  opLog.innerHTML = '';
  updateStatus('Array randomized');
}

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

function drawArray(highlight = {}) {
  // highlight can indicate states for indices: comparing, merging, written, sorted
  visArea.innerHTML = '';
  const arr = state.array;
  const max = Math.max(...arr, 1);
  const n = arr.length;
  const maxBarWidth = Math.max(3, Math.floor((visArea.clientWidth - (n-1)*4)/n));
  state.bars = [];
  for(let i=0;i<n;i++){
    const v = arr[i];
    const h = (v / max) * 100; // percent height
    const bar = document.createElement('div');
    bar.className = 'bar';
    if(n>60) bar.classList.add('small');
    bar.style.height = h + '%';
    bar.style.flexBasis = (100/n) + '%';
    bar.dataset.index = i;
    bar.innerHTML = `<div class="val">${v}</div>`;
    // color states
    if(highlight.compare && highlight.compare.includes(i)){
      bar.style.background = 'linear-gradient(180deg, #ef4444, #b91c1c)';
    } else if(highlight.merging && highlight.merging.includes(i)){
      bar.style.background = 'linear-gradient(180deg, var(--yellow), #b7791f)';
    } else if(highlight.written && highlight.written.includes(i)){
      bar.style.background = 'linear-gradient(180deg, var(--bar2), #0ea5a0)';
    } else if(highlight.sorted && highlight.sorted.includes(i)){
      bar.style.background = 'linear-gradient(180deg, #ffffff, #d1e8ff)'; 
      bar.style.color = '#001827';
    } else {
      bar.style.background = 'linear-gradient(180deg,var(--bar) 0%, #2b6ecb 100%)';
      bar.style.color = '';
    }

    visArea.appendChild(bar);
    state.bars.push(bar);
  }
}

// Recording operations for playback
// Operation format examples:
// {type: 'compare', i, j, line}
// {type: 'write', index, value, line}
// {type: 'copy', from, to, line} (copy remaining elements)
// {type: 'markSorted', indices[] }
function recordTopDown(arr){
  const ops = [];
  const aux = arr.slice();

  function merge(a, l, mid, r){
    // create copies (not pushing separate ops for creation)
    let i = l, j = mid+1, k = l;
    // We'll record comparisons and writes.
    while(i <= mid && j <= r){
      ops.push({type:'compare', i:i, j:j, line:9}); // pseudocode line 9
      if(a[i] <= a[j]){
        ops.push({type:'write', index:k, value:a[i], from:i, line:10});
        aux[k++] = a[i++];
      } else {
        ops.push({type:'write', index:k, value:a[j], from:j, line:11});
        aux[k++] = a[j++];
      }
    }
    while(i <= mid){
      ops.push({type:'copy', from:i, to:k, value:a[i], line:13});
      aux[k++] = a[i++];
    }
    while(j <= r){
      ops.push({type:'copy', from:j, to:k, value:a[j], line:13});
      aux[k++] = a[j++];
    }
    // write back to original array and record writes
    for(let t=l;t<=r;t++){
      ops.push({type:'write', index:t, value:aux[t], from:null, line:6});
      a[t] = aux[t];
    }
    // mark these indices as merged/final (not necessarily globally sorted)
    ops.push({type:'merged', indices: range(l, r), line:6});
  }

  function sort(a, l, r){
    if(l >= r) return;
    const mid = Math.floor((l + r)/2);
    sort(a, l, mid);
    sort(a, mid+1, r);
    merge(a, l, mid, r);
  }

  sort(arr.slice(), 0, arr.length-1);
  return ops;
}

function recordBottomUp(arr){
  const ops = [];
  const n = arr.length;
  let a = arr.slice();
  let aux = new Array(n);
  let width = 1;
  while(width < n){
    for(let i=0;i<n;i += 2*width){
      const l = i;
      const mid = Math.min(i+width-1, n-1);
      const r = Math.min(i+2*width-1, n-1);
      if(mid >= r) continue; // nothing to merge
      // Merge [l,mid] and [mid+1,r]
      let p = l, q = mid+1, k = l;
      while(p <= mid && q <= r){
        ops.push({type:'compare', i:p, j:q, line:3}); // line index into bottomup pseudocode approximate
        if(a[p] <= a[q]){
          ops.push({type:'write', index:k, value:a[p], from:p, line:7});
          aux[k++] = a[p++];
        } else {
          ops.push({type:'write', index:k, value:a[q], from:q, line:7});
          aux[k++] = a[q++];
        }
      }
      while(p <= mid){ ops.push({type:'copy', from:p, to:k, value:a[p], line:7}); aux[k++] = a[p++]; }
      while(q <= r){ ops.push({type:'copy', from:q, to:k, value:a[q], line:7}); aux[k++] = a[q++]; }
      for(let t=l;t<=r;t++){
        ops.push({type:'write', index:t, value:aux[t], from:null, line:7});
        a[t] = aux[t];
      }
      ops.push({type:'merged', indices: range(l,r), line:6});
    }
    width *= 2;
  }
  return ops;
}

// Helpers
function range(a,b){ const res=[]; for(let i=a;i<=b;i++) res.push(i); return res; }

// Playback engine
let playTimer = null;
function prepareOps(){
  state.ops = [];
  state.opIndex = 0;
  opLog.innerHTML = '';
  if(state.mode === 'topdown'){
    updateStatus('Recording operations (top-down)...');
    state.ops = recordTopDown(state.array.slice());
  } else {
    updateStatus('Recording operations (bottom-up)...');
    state.ops = recordBottomUp(state.array.slice());
  }
  opCountEl.textContent = state.ops.length;
  updateStatus('Ready to play. Operations recorded: ' + state.ops.length);
  // Reset colors
  drawArray();
}

function startPlayback(){
  if(state.playing) return;
  if(state.ops.length === 0){
    prepareOps();
    if(state.ops.length === 0){
      updateStatus('Nothing to sort (array trivial)');
      return;
    }
  }
  state.playing = true;
  updateStatus('Playing');
  playStep(); // immediate first step to avoid delay
  playTimer = setInterval(playStep, state.speed);
}

function playStep(){
  if(state.opIndex >= state.ops.length){
    finishPlayback();
    return;
  }
  animateOp(state.ops[state.opIndex]);
  state.opIndex++;
}

function pausePlayback(){
  if(!state.playing) return;
  state.playing = false;
  clearInterval(playTimer);
  playTimer = null;
  updateStatus('Paused');
}

function resetPlayback(){
  pausePlayback();
  state.ops = [];
  state.opIndex = 0;
  opLog.innerHTML = '';
  opCountEl.textContent = 0;
  drawArray();
  updateStatus('Reset');
}

function finishPlayback(){
  pausePlayback();
  // mark all indices sorted
  const all = range(0, state.array.length-1);
  drawArray({sorted: all});
  updateStatus('Completed');
  logOperation({type:'done', text:'Sorting complete'});
}

function stepOnce(){
  if(state.ops.length === 0 && state.opIndex === 0){
    prepareOps();
    if(state.ops.length === 0) return;
  }
  if(state.opIndex >= state.ops.length){
    finishPlayback();
    return;
  }
  // perform single op (do not start interval)
  animateOp(state.ops[state.opIndex]);
  state.opIndex++;
  updateStatus('Stepped (op ' + state.opIndex + ' / ' + state.ops.length + ')');
}

function animateOp(op){
  // For each op, we will update the array state (in-memory) and re-render bars with colors
  // Also append to op log and highlight pseudocode line
  const n = state.array.length;
  const highlight = {compare:[], merging:[], written:[], sorted:[]};
  switch(op.type){
    case 'compare':
      highlight.compare.push(op.i, op.j);
      logOperation({type:'compare', text: `Compare indices ${op.i} and ${op.j}`});
      highlightCodeLine(op.line);
      drawArray(highlight);
      break;
    case 'write':
      // apply value
      state.array[op.index] = op.value;
      highlight.written.push(op.index);
      logOperation({type:'write', text: `Write value ${op.value} to index ${op.index}`});
      highlightCodeLine(op.line);
      drawArray(highlight);
      break;
    case 'copy':
      state.array[op.to] = op.value;
      highlight.written.push(op.to);
      highlight.merging.push(op.from);
      logOperation({type:'copy', text: `Copy from ${op.from} to ${op.to} (${op.value})`});
      highlightCodeLine(op.line);
      drawArray(highlight);
      break;
    case 'merged':
      // briefly mark merged indices (these are the range that got merged)
      highlight.merging = op.indices.slice();
      logOperation({type:'merged', text: `Merged indices [${op.indices[0]}, ${op.indices[op.indices.length-1]}]`});
      highlightCodeLine(op.line);
      drawArray(highlight);
      break;
    case 'done':
      logOperation({type:'done', text: op.text || 'Done'});
      highlightCodeLine(-1);
      break;
    default:
      logOperation({type:'info', text: JSON.stringify(op)});
      drawArray();
      break;
  }
}

// Logging
function logOperation(entry){
  const el = document.createElement('div');
  el.className = 'op';
  if(entry.type === 'compare') el.classList.add('compare');
  if(entry.type === 'write' || entry.type === 'copy') el.classList.add('write');
  el.textContent = entry.text;
  opLog.appendChild(el);
  opLog.scrollTop = opLog.scrollHeight;
  opCountEl.textContent = state.opIndex + 1;
}

// Code rendering and highlighting
function renderCode(){
  codeBox.innerHTML = '';
  const lines = pseudocode[state.mode === 'topdown' ? 'topdown' : 'bottomup'];
  lines.forEach((l, idx)=>{
    const div = document.createElement('div');
    div.className = 'line';
    div.id = 'code-line-' + (idx+1);
    div.textContent = (idx+1).toString().padStart(2,' ') + '  ' + l;
    codeBox.appendChild(div);
  });
}

function highlightCodeLine(line){
  // Clear all
  const lines = codeBox.querySelectorAll('.line');
  lines.forEach(el => el.classList.remove('active'));
  if(typeof line === 'number' && line > 0){
    const el = $('code-line-' + line);
    if(el) el.classList.add('active');
  }
}

// Custom Input handling
function applyCustomInput(){
  const txt = customInput.value.trim();
  if(!txt) return;
  const parts = txt.split(',').map(s=>s.trim()).filter(Boolean);
  const nums = [];
  for(const p of parts){
    const v = Number(p);
    if(Number.isFinite(v)) nums.push(v);
    else {
      alert('Invalid number: ' + p);
      return;
    }
  }
  if(nums.length === 0) return;
  state.array = nums.slice();
  state.ops = [];
  state.opIndex = 0;
  opLog.innerHTML = '';
  opCountEl.textContent = 0;
  drawArray();
  updateStatus('Custom array applied');
}

// Initialize UI
init();

</script>
</body>
</html>