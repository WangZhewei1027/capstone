<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .canvas-container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
        }
        canvas {
            border: 1px solid #ddd;
            background-color: #fff;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .algorithm-steps {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            height: 220px;
            overflow-y: auto;
        }
        .step {
            margin-bottom: 10px;
            padding: 8px;
            border-left: 3px solid #3498db;
            background-color: #f8f9fa;
        }
        .node {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
        }
        .explanation {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        .current-node {
            background-color: #e74c3c;
        }
        .visited-node {
            background-color: #2ecc71;
        }
        .mst-edge {
            background-color: #2ecc71;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Prim's Algorithm Visualization</h1>
        
        <div class="explanation">
            <h2>What is Prim's Algorithm?</h2>
            <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It starts with an arbitrary node and grows the spanning tree by adding the smallest edge that connects a node in the tree to a node outside the tree.</p>
        </div>
        
        <div class="controls">
            <h2>Controls</h2>
            <button id="generateGraph">Generate New Graph</button>
            <button id="startAlgorithm">Start Algorithm</button>
            <button id="stepAlgorithm" disabled>Next Step</button>
            <button id="resetAlgorithm" disabled>Reset</button>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>Unvisited Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>Current Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                    <span>Visited Node / MST Edge</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="graphCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="algorithm-steps">
            <h2>Algorithm Steps</h2>
            <div id="stepsContainer"></div>
        </div>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // Control buttons
        const generateGraphBtn = document.getElementById('generateGraph');
        const startAlgorithmBtn = document.getElementById('startAlgorithm');
        const stepAlgorithmBtn = document.getElementById('stepAlgorithm');
        const resetAlgorithmBtn = document.getElementById('resetAlgorithm');
        const stepsContainer = document.getElementById('stepsContainer');
        
        // Graph data
        let nodes = [];
        let edges = [];
        let mstEdges = [];
        let visited = [];
        let currentStep = 0;
        let algorithmRunning = false;
        let animationId = null;
        
        // Generate a random graph
        function generateRandomGraph() {
            nodes = [];
            edges = [];
            mstEdges = [];
            visited = [];
            currentStep = 0;
            stepsContainer.innerHTML = '';
            
            // Create 8 random nodes
            for (let i = 0; i < 8; i++) {
                // Ensure nodes are not too close to each other
                let x, y, validPosition;
                do {
                    validPosition = true;
                    x = 50 + Math.random() * 700;
                    y = 50 + Math.random() * 400;
                    
                    // Check if this position is too close to existing nodes
                    for (const node of nodes) {
                        const dx = node.x - x;
                        const dy = node.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 80) {
                            validPosition = false;
                            break;
                        }
                    }
                } while (!validPosition);
                
                nodes.push({ id: i, x: x, y: y });
            }
            
            // Create edges - connect each node to a few others
            for (let i = 0; i < nodes.length; i++) {
                // Each node connects to 2-4 other nodes
                const numConnections = 2 + Math.floor(Math.random() * 3);
                const connected = new Set();
                
                // Ensure we don't connect to ourselves
                connected.add(i);
                
                for (let j = 0; j < numConnections; j++) {
                    let target;
                    do {
                        target = Math.floor(Math.random() * nodes.length);
                    } while (connected.has(target));
                    
                    connected.add(target);
                    
                    // Calculate distance as weight
                    const dx = nodes[i].x - nodes[target].x;
                    const dy = nodes[i].y - nodes[target].y;
                    const weight = Math.floor(Math.sqrt(dx * dx + dy * dy) / 10);
                    
                    edges.push({ 
                        from: i, 
                        to: target, 
                        weight: weight 
                    });
                }
            }
            
            // Remove duplicate edges (since we might have added both directions)
            const uniqueEdges = [];
            const edgeSet = new Set();
            
            for (const edge of edges) {
                const key1 = `${edge.from}-${edge.to}`;
                const key2 = `${edge.to}-${edge.from}`;
                
                if (!edgeSet.has(key1) && !edgeSet.has(key2)) {
                    uniqueEdges.push(edge);
                    edgeSet.add(key1);
                    edgeSet.add(key2);
                }
            }
            
            edges = uniqueEdges;
            drawGraph();
        }
        
        // Draw the graph on canvas
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            for (const edge of edges) {
                const fromNode = nodes[edge.from];
                const toNode = nodes[edge.to];
                
                // Check if this edge is in MST
                const isMSTEdge = mstEdges.some(e => 
                    (e.from === edge.from && e.to === edge.to) || 
                    (e.from === edge.to && e.to === edge.from)
                );
                
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.strokeStyle = isMSTEdge ? '#2ecc71' : '#bdc3c7';
                ctx.lineWidth = isMSTEdge ? 3 : 1;
                ctx.stroke();
                
                // Draw weight
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                
                ctx.fillStyle = isMSTEdge ? '#2ecc71' : '#7f8c8d';
                ctx.font = '12px Arial';
                ctx.fillText(edge.weight, midX, midY);
            }
            
            // Draw nodes
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
                
                // Color based on node state
                if (visited.includes(i)) {
                    ctx.fillStyle = '#2ecc71'; // Visited - green
                } else if (i === currentStep && algorithmRunning) {
                    ctx.fillStyle = '#e74c3c'; // Current - red
                } else {
                    ctx.fillStyle = '#3498db'; // Unvisited - blue
                }
                
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node ID
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, node.x, node.y);
            }
        }
        
        // Prim's Algorithm implementation
        function primsAlgorithm() {
            if (visited.length === 0) {
                // Start with node 0
                visited.push(0);
                addStep("Started with node 0");
                return true;
            }
            
            if (visited.length === nodes.length) {
                addStep("Algorithm complete! Minimum spanning tree found.");
                algorithmRunning = false;
                stepAlgorithmBtn.disabled = true;
                startAlgorithmBtn.disabled = false;
                return false;
            }
            
            // Find the minimum edge connecting visited and unvisited nodes
            let minEdge = null;
            let minWeight = Infinity;
            
            for (const edge of edges) {
                const fromVisited = visited.includes(edge.from);
                const toVisited = visited.includes(edge.to);
                
                // Edge connects visited and unvisited
                if ((fromVisited && !toVisited) || (!fromVisited && toVisited)) {
                    if (edge.weight < minWeight) {
                        minWeight = edge.weight;
                        minEdge = edge;
                    }
                }
            }
            
            if (minEdge) {
                // Add the edge to MST
                mstEdges.push(minEdge);
                
                // Add the new node to visited
                const newNode = visited.includes(minEdge.from) ? minEdge.to : minEdge.from;
                visited.push(newNode);
                
                addStep(`Added edge (${minEdge.from}, ${minEdge.to}) with weight ${minEdge.weight} to MST`);
                addStep(`Added node ${newNode} to visited set`);
                
                return true;
            }
            
            return false;
        }
        
        // Add a step to the steps container
        function addStep(description) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            stepDiv.textContent = description;
            stepsContainer.appendChild(stepDiv);
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
        }
        
        // Step through the algorithm
        function stepAlgorithm() {
            if (primsAlgorithm()) {
                drawGraph();
            }
        }
        
        // Run algorithm automatically
        function runAlgorithm() {
            if (algorithmRunning) {
                if (primsAlgorithm()) {
                    drawGraph();
                    animationId = setTimeout(runAlgorithm, 1500);
                } else {
                    algorithmRunning = false;
                    stepAlgorithmBtn.disabled = true;
                    startAlgorithmBtn.disabled = false;
                }
            }
        }
        
        // Event listeners
        generateGraphBtn.addEventListener('click', () => {
            generateRandomGraph();
            startAlgorithmBtn.disabled = false;
            stepAlgorithmBtn.disabled = false;
            resetAlgorithmBtn.disabled = false;
            algorithmRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
        });
        
        startAlgorithmBtn.addEventListener('click', () => {
            algorithmRunning = true;
            startAlgorithmBtn.disabled = true;
            stepAlgorithmBtn.disabled = true;
            resetAlgorithmBtn.disabled = false;
            runAlgorithm();
        });
        
        stepAlgorithmBtn.addEventListener('click', () => {
            if (!algorithmRunning) {
                algorithmRunning = true;
                startAlgorithmBtn.disabled = true;
                resetAlgorithmBtn.disabled = false;
            }
            stepAlgorithm();
        });
        
        resetAlgorithmBtn.addEventListener('click', () => {
            mstEdges = [];
            visited = [];
            currentStep = 0;
            algorithmRunning = false;
            stepsContainer.innerHTML = '';
            startAlgorithmBtn.disabled = false;
            stepAlgorithmBtn.disabled = false;
            resetAlgorithmBtn.disabled = true;
            
            if (animationId) {
                clearTimeout(animationId);
            }
            
            drawGraph();
        });
        
        // Initialize
        generateRandomGraph();
    </script>
</body>
</html>