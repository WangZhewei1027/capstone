<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Tree Visualization & Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  #controls {
    margin-bottom: 15px;
  }
  #tree-container {
    text-align: center;
  }
  svg {
    border: 1px solid #ccc;
    max-width: 100%;
    height: 500px;
  }
  .node circle {
    fill: #69a3f3;
    stroke: #1e70bf;
    stroke-width: 2px;
  }
  .node text {
    fill: white;
    font-weight: bold;
    font-size: 14px;
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
  }
  .link {
    fill: none;
    stroke: #aaa;
    stroke-width: 2px;
  }
  #log {
    margin-top: 20px;
    height: 120px;
    overflow-y: auto;
    background: #f9f9f9;
    border: 1px solid #ddd;
    padding: 8px;
    font-family: monospace;
    white-space: pre-wrap;
  }
  input[type=number] {
    width: 80px;
    padding: 5px;
    font-size: 14px;
  }
  button {
    padding: 6px 14px;
    font-size: 14px;
    margin-left: 5px;
    cursor: pointer;
  }
  #traversal-buttons button {
    margin: 2px;
  }
</style>
</head>
<body>
<h1>Binary Tree Visualization & Demo</h1>

<div id="controls">
  <label for="nodeValue">Node Value (integer): </label>
  <input type="number" id="nodeValue" />
  <button id="insertBtn">Insert</button>
  <button id="clearBtn">Clear Tree</button>
</div>

<div id="traversal-buttons">
  <button id="inorderBtn">Inorder Traversal</button>
  <button id="preorderBtn">Preorder Traversal</button>
  <button id="postorderBtn">Postorder Traversal</button>
  <button id="levelorderBtn">Level-order Traversal</button>
</div>

<div id="tree-container">
  <svg id="treeSVG" width="1000" height="500"></svg>
</div>

<h3>Traversal Output:</h3>
<div id="log"></div>

<script>
  // Binary Tree Node class
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
  }

  // Binary Search Tree class with visualization
  class BinaryTree {
    constructor() {
      this.root = null;
    }

    insert(value) {
      if (this.root === null) {
        this.root = new Node(value);
      } else {
        this._insertNode(this.root, value);
      }
    }

    _insertNode(node, value) {
      if (value === node.value) {
        // Disallow duplicates for this demo
        alert("Duplicate nodes not allowed.");
        return;
      }
      if (value < node.value) {
        if (node.left === null) {
          node.left = new Node(value);
        } else {
          this._insertNode(node.left, value);
        }
      } else {
        if (node.right === null) {
          node.right = new Node(value);
        } else {
          this._insertNode(node.right, value);
        }
      }
    }

    inorderTraversal(callback) {
      function inorder(node) {
        if (node === null) return;
        inorder(node.left);
        callback(node.value);
        inorder(node.right);
      }
      inorder(this.root);
    }

    preorderTraversal(callback) {
      function preorder(node) {
        if (node === null) return;
        callback(node.value);
        preorder(node.left);
        preorder(node.right);
      }
      preorder(this.root);
    }

    postorderTraversal(callback) {
      function postorder(node) {
        if (node === null) return;
        postorder(node.left);
        postorder(node.right);
        callback(node.value);
      }
      postorder(this.root);
    }

    levelOrderTraversal(callback) {
      if (!this.root) return;
      const queue = [this.root];
      while (queue.length > 0) {
        const node = queue.shift();
        callback(node.value);
        if (node.left !== null) queue.push(node.left);
        if (node.right !== null) queue.push(node.right);
      }
    }

    clear() {
      this.root = null;
    }
  }

  // Visualization & UI
  const svg = document.getElementById("treeSVG");
  const WIDTH = svg.clientWidth;
  const HEIGHT = svg.clientHeight;
  const NODE_RADIUS = 20;
  const VERTICAL_GAP = 70;

  let tree = new BinaryTree();

  // To compute positions we do a tree layout (basic)
  // First, get the height, then do an inorder traversal to assign x based on order,
  // and y based on depth

  function getHeight(node) {
    if (!node) return 0;
    return 1 + Math.max(getHeight(node.left), getHeight(node.right));
  }

  // Assign x position tracking inorder index
  function assignPositions(root) {
    let positions = new Map();
    let x = 0;
    function inorderPosition(node, depth) {
      if (!node) return;
      inorderPosition(node.left, depth + 1);
      positions.set(node, { depth, x: x++ });
      inorderPosition(node.right, depth + 1);
    }
    inorderPosition(root, 0);
    return positions;
  }

  // Draw tree function
  function drawTree() {
    // Clear svg
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    if (!tree.root) return;

    const height = getHeight(tree.root);
    const positions = assignPositions(tree.root);

    // Find max x for scaling horizontally
    let maxX = 0;
    for (let pos of positions.values()) {
      if (pos.x > maxX) maxX = pos.x;
    }

    // Functions to convert logical x,y to svg coords
    function getCoordX(x) {
      if (maxX === 0) return WIDTH / 2;
      return (x * (WIDTH - 2 * NODE_RADIUS - 20)) / maxX + NODE_RADIUS + 10;
    }
    function getCoordY(depth) {
      return depth * VERTICAL_GAP + NODE_RADIUS + 10;
    }

    // Draw links first
    for (let [node, pos] of positions.entries()) {
      if (node.left) {
        let leftPos = positions.get(node.left);
        drawLink(
          getCoordX(pos.x),
          getCoordY(pos.depth),
          getCoordX(leftPos.x),
          getCoordY(leftPos.depth)
        );
      }
      if (node.right) {
        let rightPos = positions.get(node.right);
        drawLink(
          getCoordX(pos.x),
          getCoordY(pos.depth),
          getCoordX(rightPos.x),
          getCoordY(rightPos.depth)
        );
      }
    }

    // Draw nodes on top of links
    for (let [node, pos] of positions.entries()) {
      drawNode(getCoordX(pos.x), getCoordY(pos.depth), node.value);
    }
  }

  function drawNode(cx, cy, value) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute("class", "node");

    const circle = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    circle.setAttribute("cx", cx);
    circle.setAttribute("cy", cy);
    circle.setAttribute("r", NODE_RADIUS);

    const text = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "text"
    );
    text.setAttribute("x", cx);
    text.setAttribute("y", cy + 1); // +1 for vertical center visually
    text.textContent = value;

    g.appendChild(circle);
    g.appendChild(text);
    svg.appendChild(g);
  }

  function drawLink(x1, y1, x2, y2) {
    const path = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    path.setAttribute("class", "link");

    // Draw smooth curve from parent to child
    const deltaX = x2 - x1;
    const deltaY = y2 - y1;
    const c1x = x1;
    const c1y = y1 + deltaY / 2;
    const c2x = x2;
    const c2y = y1 + deltaY / 2;

    const d = `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;

    path.setAttribute("d", d);

    svg.appendChild(path);
  }

  // Logging function
  function log(msg) {
    const logDiv = document.getElementById("log");
    logDiv.textContent += msg + "\n";
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function clearLog() {
    document.getElementById("log").textContent = "";
  }

  // UI controls
  document.getElementById("insertBtn").addEventListener("click", () => {
    const valInput = document.getElementById("nodeValue");
    const val = parseInt(valInput.value);
    if (isNaN(val)) {
      alert("Please enter a valid integer value.");
      return;
    }
    tree.insert(val);
    drawTree();
    valInput.value = "";
    valInput.focus();
  });

  document.getElementById("clearBtn").addEventListener("click", () => {
    if (confirm("Are you sure you want to clear the entire tree?")) {
      tree.clear();
      drawTree();
      clearLog();
    }
  });

  document.getElementById("inorderBtn").addEventListener("click", () => {
    clearLog();
    log("Inorder Traversal:");
    let values = [];
    tree.inorderTraversal((val) => values.push(val));
    log(values.join(" → "));
  });

  document.getElementById("preorderBtn").addEventListener("click", () => {
    clearLog();
    log("Preorder Traversal:");
    let values = [];
    tree.preorderTraversal((val) => values.push(val));
    log(values.join(" → "));
  });

  document.getElementById("postorderBtn").addEventListener("click", () => {
    clearLog();
    log("Postorder Traversal:");
    let values = [];
    tree.postorderTraversal((val) => values.push(val));
    log(values.join(" → "));
  });

  document.getElementById("levelorderBtn").addEventListener("click", () => {
    clearLog();
    log("Level-order Traversal:");
    let values = [];
    tree.levelOrderTraversal((val) => values.push(val));
    log(values.join(" → "));
  });

  // Insert sample values on load
  window.onload = () => {
    [50, 30, 70, 20, 40, 60, 80].forEach((v) => tree.insert(v));
    drawTree();
  };
</script>

</body>
</html>