<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Depth-First Search (DFS) Visualizer</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#94a3b8;
    --accent:#06b6d4;
    --accent-2:#7c3aed;
    --card:#0b1116;
    --good:#10b981;
    --warn:#f59e0b;
    --danger:#ef4444;
    --node-size:36px;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:var(--muted);background:linear-gradient(180deg,#021124 0%, #071022 40%);}
  .app{display:flex;gap:12px;padding:18px;box-sizing:border-box;height:100%;}
  .controls{width:360px;min-width:300px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(2,6,23,0.6);}
  .controls h2{margin:6px 0 12px;color:#dbeafe;font-size:18px;}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}
  label{font-size:13px;color:var(--muted);min-width:110px;}
  input[type="number"], select, textarea{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:6px;font-size:13px;outline:none;width:100%;}
  input[type="range"]{width:160px;}
  button{background:linear-gradient(180deg,var(--accent),#0891b2);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-weight:600;}
  .canvas{flex:1;min-width:400px;background:linear-gradient(180deg,#031126 0%, #071029 100%);border-radius:12px;padding:12px;display:flex;flex-direction:column;}
  .svg-wrap{flex:1;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));position:relative;overflow:hidden;}
  svg{width:100%;height:100%;}
  .bottom-controls{display:flex;gap:8px;align-items:center;margin-top:10px;}
  .small{font-size:13px;color:var(--muted);}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  .legend .item{display:flex;gap:8px;align-items:center;padding:6px 8px;background:rgba(255,255,255,0.02);border-radius:6px;font-size:13px;}
  .node{cursor:pointer;stroke:#071428;stroke-width:2px;}
  .node.unvisited{fill:#0b1220;stroke:#19303b;}
  .node.discovered{fill:#ffb020;stroke:#663c00;}
  .node.current{fill:#06b6d4;stroke:#02323a;}
  .node.finished{fill:#10b981;stroke:#064f3b;}
  .label{font-size:12px;fill:#e6f0ff;pointer-events:none;font-weight:600;}
  .edge{stroke:rgba(255,255,255,0.08);stroke-width:2;stroke-linecap:round;}
  .edge.highlight{stroke:#ef4444;stroke-width:3;opacity:0.95;}
  .edge.tree{stroke:#7c3aed;stroke-width:3;opacity:0.9;}
  .panel{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;margin-top:8px;font-size:13px;}
  .stack-list{display:flex;flex-direction:column;gap:6px;}
  .stack-item{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:6px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}
  .times{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;}
  .time-badge{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;color:var(--muted);min-width:62px;text-align:center;}
  .footer-note{color:var(--muted);font-size:12px;margin-top:8px;}
  .controls .muted{font-size:13px;color:var(--muted);margin-bottom:6px;}
  .flex{display:flex;gap:8px;align-items:center;}
  input[type="text"]{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted);}
  .row-buttons{display:flex;gap:8px;flex-wrap:wrap;}
  .big-btn{padding:10px 14px;border-radius:8px;font-weight:700;}
  .status{font-weight:700;color:#c7f9ff;}
  .info-line{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;}
  .hint{color:#9fb6cc;font-size:12px}
  textarea{height:70px;}
  .adj-label{font-size:12px;color:#cbd5e1}
  .credits{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="app">
  <div class="controls">
    <h2>DFS Visualizer</h2>
    <div class="info-line">
      <div class="muted">Algorithm</div>
      <div>
        <select id="algo">
          <option value="recursive">Recursive DFS</option>
          <option value="iterative">Iterative (stack) DFS</option>
        </select>
      </div>
    </div>

    <div class="row">
      <label>Nodes</label>
      <input id="nodeCount" type="number" min="3" max="32" value="9"/>
    </div>
    <div class="row">
      <label>Density</label>
      <input id="density" type="range" min="0" max="1" step="0.05" value="0.25"/>
      <div class="small" id="densityLabel">0.25</div>
    </div>

    <div class="row">
      <label>Start node</label>
      <select id="startNode"></select>
    </div>

    <div class="row">
      <label>Graph</label>
      <div style="flex:1;display:flex;gap:8px;">
        <button id="gen" class="big-btn">Generate</button>
        <button id="randomize" class="ghost">Randomize</button>
      </div>
    </div>

    <div class="row">
      <label>Adjacency (optional)</label>
      <textarea id="adjInput" placeholder="Optional custom adjacency list: one line per node: neighbors separated by spaces&#10;e.g.&#10;1 2&#10;0 3&#10;..."></textarea>
    </div>

    <div class="row">
      <label>Controls</label>
      <div class="row-buttons" style="flex:1;">
        <button id="run" class="big-btn">Run</button>
        <button id="step" class="ghost">Step</button>
        <button id="play" class="ghost">Play</button>
        <button id="reset" class="ghost">Reset</button>
      </div>
    </div>

    <div class="row">
      <label>Speed</label>
      <input id="speed" type="range" min="50" max="2000" step="50" value="650"/>
      <div class="small" id="speedLabel">650 ms</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div style="font-weight:700;color:#e6f0ff">Runtime</div>
        <div class="small muted">Current step: <span id="stepCounter">0</span>/<span id="totalSteps">0</span></div>
      </div>

      <div style="display:flex;gap:12px;margin-top:8px;">
        <div style="flex:1">
          <div class="small muted">Call stack / Stack (top on right)</div>
          <div id="stackBox" class="stack-list" style="margin-top:8px;"></div>
        </div>
        <div style="flex:1">
          <div class="small muted">Visited order</div>
          <div id="visitedOrder" class="panel" style="margin-top:8px;min-height:42px"></div>
        </div>
      </div>

      <div style="margin-top:10px;">
        <div class="small muted">Discovery / Finish times</div>
        <div id="timesBox" class="times"></div>
      </div>

      <div class="footer-note">Click a node in the canvas to set start node. Edges are undirected. Use the adjacency textarea to provide an exact graph.</div>
    </div>

    <div class="credits">Built for learning — shows both recursive and iterative DFS with step-by-step state snapshots.</div>
  </div>

  <div class="canvas">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <div style="display:flex;gap:8px;align-items:center;">
        <div style="font-weight:800;color:#e6f0ff">Graph canvas</div>
        <div class="small muted">(click nodes to choose start)</div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;">
        <div class="legend">
          <div class="item"><div style="width:12px;height:12px;background:#0b1220;border-radius:3px;border:1px solid #19303b"></div> unvisited</div>
          <div class="item"><div style="width:12px;height:12px;background:#ffb020;border-radius:3px"></div> discovered</div>
          <div class="item"><div style="width:12px;height:12px;background:#06b6d4;border-radius:3px"></div> current</div>
          <div class="item"><div style="width:12px;height:12px;background:#10b981;border-radius:3px"></div> finished</div>
        </div>
      </div>
    </div>

    <div class="svg-wrap" id="svgWrap">
      <svg id="svgCanvas" viewBox="0 0 900 640" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <div class="bottom-controls">
      <div class="small muted">Highlighted edge: <span id="edgeLabel">—</span></div>
      <div style="flex:1"></div>
      <div class="small muted">Algorithm: <span id="algoLabel"></span></div>
    </div>
  </div>
</div>

<script>
(() => {
  // Utility helpers
  const $ = (s,el=document) => el.querySelector(s);
  const $$ = (s,el=document) => Array.from(el.querySelectorAll(s));

  // Elements
  const svg = $('#svgCanvas');
  const nodeCountInput = $('#nodeCount');
  const densityInput = $('#density');
  const densityLabel = $('#densityLabel');
  const genBtn = $('#gen');
  const randomizeBtn = $('#randomize');
  const startSelect = $('#startNode');
  const adjInput = $('#adjInput');
  const runBtn = $('#run');
  const stepBtn = $('#step');
  const playBtn = $('#play');
  const resetBtn = $('#reset');
  const algoSelect = $('#algo');
  const algoLabel = $('#algoLabel');
  const speedInput = $('#speed');
  const speedLabel = $('#speedLabel');
  const stackBox = $('#stackBox');
  const visitedOrder = $('#visitedOrder');
  const timesBox = $('#timesBox');
  const stepCounter = $('#stepCounter');
  const totalSteps = $('#totalSteps');
  const edgeLabel = $('#edgeLabel');

  // State
  let nodes = []; // {id,x,y}
  let edges = []; // {u,v,svgLine,svgGroup}
  let adj = []; // adjacency list: array of arrays
  let snapshots = []; // array of states for animation
  let playing = false;
  let playTimer = null;
  let curStep = 0;
  let discovery = [];
  let finish = [];

  // Config
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  // Initial
  densityLabel.textContent = densityInput.value;
  speedLabel.textContent = speedInput.value + ' ms';
  algoLabel.textContent = algoSelect.value === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';

  // SVG helpers
  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function drawGraph(){
    clearSVG();
    // edges behind nodes
    edges.forEach(e=>{
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('class','edge');
      line.setAttribute('x1', nodes[e.u].x);
      line.setAttribute('y1', nodes[e.u].y);
      line.setAttribute('x2', nodes[e.v].x);
      line.setAttribute('y2', nodes[e.v].y);
      g.appendChild(line);
      svg.appendChild(g);
      e.svgLine = line;
      e.svgGroup = g;
    });

    // node circles and labels
    nodes.forEach(n=>{
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-id', n.id);
      group.style.cursor = 'pointer';
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('class','node unvisited');
      circle.setAttribute('r', 18);
      circle.setAttribute('cx', n.x);
      circle.setAttribute('cy', n.y);
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','label');
      text.setAttribute('x', n.x);
      text.setAttribute('y', n.y+4);
      text.setAttribute('text-anchor','middle');
      text.textContent = String(n.id);
      group.appendChild(circle);
      group.appendChild(text);
      svg.appendChild(group);

      group.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        setStartNode(n.id);
      });

      n.svg = {group, circle, text};
    });

    // allow clicking background to clear start selection
    svg.addEventListener('click', (ev)=>{/*placeholder*/});
  }

  function setStartNode(id){
    startSelect.value = id;
    highlightStartSelect();
  }

  // Graph generation
  function genNodes(n){
    const cx = 450, cy = 300;
    const radius = Math.min(260, 32*n);
    nodes = [];
    for(let i=0;i<n;i++){
      const angle = (i/n) * Math.PI*2 - Math.PI/2;
      const x = cx + Math.cos(angle)*(radius + (Math.random()*40-20));
      const y = cy + Math.sin(angle)*(radius + (Math.random()*40-20));
      nodes.push({id:i,x,y});
    }
  }

  // edges helper: add undirected edge if not exists
  function addEdge(edgesArr,u,v){
    if(u===v) return;
    const key = (a,b)=> a<b? a+'-'+b : b+'-'+a;
    const present = edgesArr.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));
    if(!present) edgesArr.push({u,v});
  }

  function genEdgesByDensity(n, density){
    const e = [];
    // ensure connectivity by creating a chain first
    for(let i=1;i<n;i++){
      addEdge(e,i-1, i);
    }
    // add random edges
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(Math.random() < density){
          addEdge(e,i,j);
        }
      }
    }
    return e;
  }

  function buildAdjFromEdges(edgesList, n){
    const A = Array.from({length:n}, ()=>[]);
    edgesList.forEach(e=>{
      A[e.u].push(e.v);
      A[e.v].push(e.u);
    });
    // sort neighbors for deterministic behavior
    A.forEach(arr => arr.sort((a,b)=>a-b));
    return A;
  }

  function parseAdjInput(txt){
    const lines = txt.trim().split(/\n+/).map(s=>s.trim());
    if(lines.length===0 || lines.length < Number(nodeCountInput.value)) return null;
    const parsed = lines.map((line,idx)=>{
      if(!line) return [];
      return line.split(/[\s,]+/).map(x=>Number(x)).filter(x=>!isNaN(x));
    });
    // check valid
    for(let i=0;i<parsed.length;i++){
      if(!Array.isArray(parsed[i])) return null;
      parsed[i].forEach(v=>{
        if(v<0 || v>=parsed.length) throw new Error('Adjacency contains out-of-range node: ' + v);
      });
    }
    // build edges from it
    const edgesList = [];
    parsed.forEach((nbrs,i)=>{
      nbrs.forEach(j=> { if(i<j) edgesList.push({u:i,v:j}); });
    });
    return {adj:parsed, edges:edgesList};
  }

  function generateGraph(){
    const n = clamp(Number(nodeCountInput.value)||9, 3, 32);
    genNodes(n);

    const adjTxt = adjInput.value.trim();
    if(adjTxt){
      try {
        const res = parseAdjInput(adjTxt);
        if(res){
          adj = res.adj;
          // ensure position array length matches
          if(nodes.length !== adj.length){
            // adjust nodes count to match adjacency length
            nodeCountInput.value = adj.length;
            genNodes(adj.length);
          }
          edges = res.edges.slice();
        } else {
          // fallback to random generation
          edges = genEdgesByDensity(n, Number(densityInput.value));
          adj = buildAdjFromEdges(edges,n);
        }
      } catch(err){
        alert('Adjacency parse error: ' + err.message);
        edges = genEdgesByDensity(n, Number(densityInput.value));
        adj = buildAdjFromEdges(edges,n);
      }
    } else {
      edges = genEdgesByDensity(n, Number(densityInput.value));
      adj = buildAdjFromEdges(edges,n);
    }

    // Draw and populate start select
    drawGraph();
    populateStartSelect();
    resetAnimationState();
  }

  function populateStartSelect(){
    startSelect.innerHTML = '';
    nodes.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.textContent = 'Node ' + n.id;
      startSelect.appendChild(opt);
    });
    // default to 0
    startSelect.value = nodes.length? nodes[0].id : 0;
    highlightStartSelect();
  }

  function highlightStartSelect(){
    // highlight the chosen start node visually (outline)
    nodes.forEach(n=>{
      n.svg.circle.style.filter = '';
      if(String(n.id) === String(startSelect.value)){
        n.svg.circle.style.stroke = '#ffff';
        n.svg.circle.style.strokeWidth = 2.5;
      } else {
        n.svg.circle.style.strokeWidth = 2;
        n.svg.circle.style.stroke = ''; // CSS will handle default
      }
    });
  }

  // Snapshot model:
  // { visited: Array(boolean), discoveredTimes: Array|null or number, finishTimes: Array|null, callStack: Array, iterStack: Array, highlightedEdge: [u,v] or null, event: string }
  function pushSnapshot(state){
    // deep-ish copy of arrays for safety
    snapshots.push({
      visited: state.visited.slice(),
      discoveredTimes: state.discoveredTimes.slice(),
      finishTimes: state.finishTimes.slice(),
      callStack: state.callStack.slice(),
      iterStack: state.iterStack ? state.iterStack.map(x=>Object.assign({},x)) : null,
      highlightedEdge: state.highlightedEdge ? state.highlightedEdge.slice() : null,
      event: state.event || ''
    });
  }

  // DFS implementations that generate snapshots (do not animate directly)
  function generateRecursiveDFS(start){
    const n = nodes.length;
    const visited = Array(n).fill(false);
    const discoveredTimes = Array(n).fill(null);
    const finishTimes = Array(n).fill(null);
    let time = 0;
    const callStack = [];
    const state = {visited, discoveredTimes, finishTimes, callStack, iterStack:null, highlightedEdge:null, event:''};
    snapshots = [];

    function dfs(u, parentEdge){
      // push call
      callStack.push(u);
      state.event = 'call ' + u;
      state.highlightedEdge = parentEdge ? [parentEdge[0],parentEdge[1]] : null;
      pushSnapshot(state);

      if(!visited[u]){
        visited[u] = true;
        discoveredTimes[u] = ++time;
        state.event = 'discover ' + u;
        state.highlightedEdge = parentEdge ? [parentEdge[0],parentEdge[1]] : null;
        pushSnapshot(state);
      }

      for(const v of adj[u]){
        state.event = 'check edge ' + u + '→' + v;
        state.highlightedEdge = [u,v];
        pushSnapshot(state);
        if(!visited[v]){
          // record tree edge
          state.event = 'tree edge ' + u + '→' + v;
          state.highlightedEdge = [u,v];
          pushSnapshot(state);
          dfs(v, [u,v]);
          // after return snapshot
          state.event = 'back to ' + u;
          state.highlightedEdge = [u,v];
          pushSnapshot(state);
        } else {
          state.event = 'skip visited ' + v;
          pushSnapshot(state);
        }
      }

      // finish
      finishTimes[u] = ++time;
      state.event = 'finish ' + u;
      state.highlightedEdge = null;
      pushSnapshot(state);
      callStack.pop();
      state.event = 'return ' + u;
      pushSnapshot(state);
    }

    dfs(start, null);

    return {snapshots, discoveredTimes, finishTimes};
  }

  function generateIterativeDFS(start){
    const n = nodes.length;
    const visited = Array(n).fill(false);
    const discoveredTimes = Array(n).fill(null);
    const finishTimes = Array(n).fill(null);
    let time = 0;
    const iterStack = []; // frames: {node, nextIndex, parent}
    const state = {visited, discoveredTimes, finishTimes, callStack: [], iterStack, highlightedEdge:null, event:''};
    snapshots = [];

    // push initial frame
    iterStack.push({node:start, nextIndex:0, parent:null});
    state.event='push '+start;
    state.highlightedEdge=null;
    pushSnapshot(state);

    while(iterStack.length){
      const frame = iterStack[iterStack.length-1];
      const u = frame.node;
      if(!visited[u]){
        visited[u] = true;
        discoveredTimes[u] = ++time;
        state.event = 'discover ' + u;
        pushSnapshot(state);
      }
      if(frame.nextIndex < adj[u].length){
        const v = adj[u][frame.nextIndex];
        frame.nextIndex++;
        state.highlightedEdge = [u,v];
        state.event = 'check edge ' + u + '→' + v;
        pushSnapshot(state);
        if(!visited[v]){
          state.event = 'tree edge push ' + v;
          iterStack.push({node:v,nextIndex:0,parent:u});
          pushSnapshot(state);
        } else {
          state.event = 'skip visited ' + v;
          pushSnapshot(state);
        }
      } else {
        // all neighbors processed
        finishTimes[u] = ++time;
        state.event = 'finish ' + u;
        state.highlightedEdge = null;
        pushSnapshot(state);
        iterStack.pop();
        state.event = 'pop ' + u;
        pushSnapshot(state);
      }
    }
    return {snapshots, discoveredTimes, finishTimes};
  }

  // Animation / UI update
  function applySnapshot(idx){
    if(idx < 0) idx = 0;
    if(idx >= snapshots.length) idx = snapshots.length-1;
    const s = snapshots[idx];
    // update nodes styling
    s.visited.forEach((v,i)=>{
      const c = nodes[i].svg.circle;
      c.classList.remove('unvisited','discovered','current','finished');
      if(s.finishTimes[i] !== null){
        c.classList.add('finished');
      } else if(s.visited[i]){
        // currently discovered but maybe current
        if(s.callStack && s.callStack.length && Number(s.callStack[s.callStack.length-1]) === i){
          c.classList.add('current');
        } else if(s.iterStack && s.iterStack.length && Number(s.iterStack[s.iterStack.length-1].node) === i){
          c.classList.add('current');
        } else {
          c.classList.add('discovered');
        }
      } else {
        c.classList.add('unvisited');
      }
    });

    // update edges styling
    edges.forEach(e=>{
      e.svgLine.classList.remove('highlight','tree');
      if(s.highlightedEdge){
        const [a,b] = s.highlightedEdge;
        if( (e.u===a && e.v===b) || (e.u===b && e.v===a) ){
          e.svgLine.classList.add('highlight');
        }
      }
    });

    // show stack / callStack
    stackBox.innerHTML = '';
    const stackArr = (s.iterStack && s.iterStack.length) ? s.iterStack.map(f=>String(f.node)) : s.callStack;
    if(stackArr && stackArr.length){
      // display items, left to right with top at right
      const frag = document.createDocumentFragment();
      for(let i=0;i<stackArr.length;i++){
        const div = document.createElement('div');
        div.className = 'stack-item';
        div.textContent = 'Node ' + stackArr[i];
        frag.appendChild(div);
      }
      stackBox.appendChild(frag);
    } else {
      stackBox.innerHTML = '<div class="stack-item" style="opacity:0.6">Empty</div>';
    }

    // visited order
    visitedOrder.innerHTML = '';
    const visitedList = [];
    for(let i=0;i<s.discoveredTimes.length;i++){
      if(s.discoveredTimes[i] !== null) visitedList.push({id:i,t:s.discoveredTimes[i]});
    }
    visitedList.sort((a,b)=>a.t-b.t);
    if(visitedList.length){
      visitedList.forEach(it=>{
        const d = document.createElement('div');
        d.className = 'small';
        d.style.padding='4px';
        d.textContent = `Node ${it.id} (d=${it.t})`;
        visitedOrder.appendChild(d);
      });
    } else {
      visitedOrder.textContent = '';
    }

    // times grid
    timesBox.innerHTML = '';
    for(let i=0;i<s.discoveredTimes.length;i++){
      const div = document.createElement('div');
      div.className = 'time-badge';
      div.innerHTML = `<div style="font-weight:700;color:#cfefff">#${i}</div><div style="font-size:12px">d:${s.discoveredTimes[i]??'–'} f:${s.finishTimes[i]??'–'}</div>`;
      timesBox.appendChild(div);
    }

    // edge label and counters
    edgeLabel.textContent = s.highlightedEdge ? `${s.highlightedEdge[0]} → ${s.highlightedEdge[1]}` : '—';
    stepCounter.textContent = idx;
    totalSteps.textContent = snapshots.length-1;
  }

  function resetAnimationState(){
    snapshots = [];
    curStep = 0;
    playing = false;
    if(playTimer) { clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play'; }
    // reset node styles
    nodes.forEach(n=>{
      n.svg.circle.classList.remove('discovered','finished','current');
      n.svg.circle.classList.add('unvisited');
    });
    edges.forEach(e=> e.svgLine.classList.remove('highlight','tree'));
    visitedOrder.innerHTML = '';
    stackBox.innerHTML = '<div class="stack-item" style="opacity:0.6">Empty</div>';
    timesBox.innerHTML = '';
    stepCounter.textContent = '0';
    totalSteps.textContent = '0';
    edgeLabel.textContent = '—';
  }

  function prepareAndRun(){
    // produce snapshots using chosen algorithm and starting node
    resetAnimationState();
    const start = Number(startSelect.value);
    if(isNaN(start) || start < 0 || start >= nodes.length){ alert('Invalid start node'); return; }
    if(algoSelect.value === 'recursive'){
      const res = generateRecursiveDFS(start);
      snapshots = res.snapshots;
    } else {
      const res = generateIterativeDFS(start);
      snapshots = res.snapshots;
    }
    // ensure there is at least one snapshot to show (even empty)
    if(snapshots.length === 0) snapshots.push({
      visited:Array(nodes.length).fill(false),
      discoveredTimes:Array(nodes.length).fill(null),
      finishTimes:Array(nodes.length).fill(null),
      callStack:[],
      iterStack:null,
      highlightedEdge:null,
      event:'init'
    });
    // step counters start at 0 meaning before any step; we'll show snapshot[0] for step 0
    curStep = 0;
    applySnapshot(curStep);
  }

  function doStep(){
    if(snapshots.length === 0) return;
    if(curStep < snapshots.length-1){
      curStep++;
      applySnapshot(curStep);
    }
  }

  function doPlay(){
    if(playing){
      playing = false;
      playBtn.textContent = 'Play';
      if(playTimer){ clearInterval(playTimer); playTimer = null; }
    } else {
      playing = true;
      playBtn.textContent = 'Pause';
      const delay = Number(speedInput.value);
      playTimer = setInterval(()=>{
        if(curStep < snapshots.length-1){
          curStep++;
          applySnapshot(curStep);
        } else {
          // end
          playing = false;
          playBtn.textContent = 'Play';
          clearInterval(playTimer);
          playTimer = null;
        }
      }, delay);
    }
  }

  // Event wiring
  genBtn.addEventListener('click', ()=>{
    generateGraph();
  });

  randomizeBtn.addEventListener('click', ()=>{
    // slight randomization but keep node count
    densityInput.value = (Math.random()*0.6 + 0.05).toFixed(2);
    densityLabel.textContent = densityInput.value;
    generateGraph();
  });

  densityInput.addEventListener('input', ()=>{
    densityLabel.textContent = densityInput.value;
  });

  nodeCountInput.addEventListener('change', ()=>{
    nodeCountInput.value = clamp(Number(nodeCountInput.value)||9, 3, 32);
  });

  startSelect.addEventListener('change', highlightStartSelect);

  algoSelect.addEventListener('change', ()=>{
    algoLabel.textContent = algoSelect.value === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';
  });

  runBtn.addEventListener('click', ()=>{
    prepareAndRun();
    // jump to last step
    if(snapshots.length) {
      curStep = snapshots.length-1;
      applySnapshot(curStep);
    }
  });

  stepBtn.addEventListener('click', ()=>{
    if(snapshots.length === 0){
      prepareAndRun();
    } else {
      doStep();
    }
  });

  playBtn.addEventListener('click', ()=>{
    if(snapshots.length === 0) prepareAndRun();
    doPlay();
  });

  resetBtn.addEventListener('click', ()=>{
    resetAnimationState();
  });

  speedInput.addEventListener('input', ()=>{
    speedLabel.textContent = speedInput.value + ' ms';
    if(playing){
      // restart timer with new speed
      clearInterval(playTimer);
      playTimer = setInterval(()=>{
        if(curStep < snapshots.length-1){
          curStep++;
          applySnapshot(curStep);
        } else {
          playing = false;
          playBtn.textContent = 'Play';
          clearInterval(playTimer);
          playTimer = null;
        }
      }, Number(speedInput.value));
    }
  });

  adjInput.addEventListener('change', ()=>{
    // if adjacency provided, auto-generate graph from it
    generateGraph();
  });

  // initial generation
  generateGraph();

  // Expose some keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){
      e.preventDefault();
      playBtn.click();
    } else if(e.key === 'ArrowRight'){
      stepBtn.click();
    } else if(e.key === 'r' && (e.ctrlKey||e.metaKey)){
      e.preventDefault();
      genBtn.click();
    }
  });

  // Make SVG responsive to viewBox size changes
  function resizeSVG(){
    // nothing needed; viewBox used
  }
  window.addEventListener('resize', resizeSVG);
})();
</script>
</body>
</html>