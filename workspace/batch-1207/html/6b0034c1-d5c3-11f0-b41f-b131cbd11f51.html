<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjacency Matrix Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        input[type="number"] {
            padding: 8px;
            width: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .matrix-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        table {
            border-collapse: collapse;
            margin: 0 auto;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            min-width: 40px;
        }
        th {
            background-color: #f2f2f2;
        }
        td {
            background-color: white;
            transition: background-color 0.2s;
        }
        td:hover {
            background-color: #f0f8ff;
        }
        .node-label {
            font-weight: bold;
            padding: 5px 10px;
        }
        .edge-cell {
            cursor: pointer;
        }
        .edge-present {
            background-color: #4CAF50;
            color: white;
        }
        .graph-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .graph-visualization {
            flex: 1;
            min-width: 300px;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        .info-panel {
            flex: 1;
            min-width: 300px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Adjacency Matrix Visualization</h1>
        
        <div class="controls">
            <label for="nodeCount">Number of nodes:</label>
            <input type="number" id="nodeCount" min="2" max="10" value="5">
            <button id="generateBtn">Generate Matrix</button>
            <button id="clearBtn">Clear All Edges</button>
            <button id="randomBtn">Random Graph</button>
        </div>

        <div class="matrix-container">
            <table id="adjacencyMatrix"></table>
        </div>

        <div class="graph-section">
            <div class="graph-visualization">
                <h3>Graph Visualization</h3>
                <canvas id="graphCanvas" width="400" height="400"></canvas>
            </div>
            <div class="info-panel">
                <h3>About Adjacency Matrices</h3>
                <p>An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</p>
                <ul>
                    <li>For an unweighted graph: 1 indicates an edge, 0 indicates no edge</li>
                    <li>For a weighted graph: values represent edge weights</li>
                    <li>The matrix is symmetric for undirected graphs</li>
                    <li>Diagonal elements are typically 0 (no self-loops)</li>
                </ul>
                <div id="matrixInfo">
                    <p><strong>Matrix Properties:</strong></p>
                    <p id="edgeCount">Total edges: 0</p>
                    <p id="symmetryCheck">Symmetric: Not applicable</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const nodeCountInput = document.getElementById('nodeCount');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            const randomBtn = document.getElementById('randomBtn');
            const matrixTable = document.getElementById('adjacencyMatrix');
            const graphCanvas = document.getElementById('graphCanvas');
            const ctx = graphCanvas.getContext('2d');
            const edgeCountDisplay = document.getElementById('edgeCount');
            const symmetryCheckDisplay = document.getElementById('symmetryCheck');

            let nodeCount = parseInt(nodeCountInput.value);
            let adjacencyMatrix = [];
            let graphNodes = [];

            // Initialize the adjacency matrix
            function initializeMatrix() {
                adjacencyMatrix = [];
                for (let i = 0; i < nodeCount; i++) {
                    adjacencyMatrix[i] = [];
                    for (let j = 0; j < nodeCount; j++) {
                        adjacencyMatrix[i][j] = 0;
                    }
                }
                generateNodes();
                renderMatrix();
                drawGraph();
                updateMatrixInfo();
            }

            // Generate node positions for graph visualization
            function generateNodes() {
                graphNodes = [];
                const centerX = graphCanvas.width / 2;
                const centerY = graphCanvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.7;
                
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (2 * Math.PI * i) / nodeCount;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    graphNodes.push({ x, y });
                }
            }

            // Render the adjacency matrix table
            function renderMatrix() {
                matrixTable.innerHTML = '';
                
                // Create header row
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th></th>'; // Empty corner cell
                for (let i = 0; i < nodeCount; i++) {
                    const th = document.createElement('th');
                    th.textContent = String.fromCharCode(65 + i); // A, B, C, ...
                    headerRow.appendChild(th);
                }
                matrixTable.appendChild(headerRow);
                
                // Create matrix rows
                for (let i = 0; i < nodeCount; i++) {
                    const row = document.createElement('tr');
                    
                    // Row header
                    const rowHeader = document.createElement('th');
                    rowHeader.textContent = String.fromCharCode(65 + i);
                    row.appendChild(rowHeader);
                    
                    // Matrix cells
                    for (let j = 0; j < nodeCount; j++) {
                        const cell = document.createElement('td');
                        cell.textContent = adjacencyMatrix[i][j];
                        cell.classList.add('edge-cell');
                        
                        if (adjacencyMatrix[i][j] === 1) {
                            cell.classList.add('edge-present');
                        }
                        
                        cell.addEventListener('click', function() {
                            toggleEdge(i, j);
                        });
                        
                        row.appendChild(cell);
                    }
                    
                    matrixTable.appendChild(row);
                }
            }

            // Toggle an edge between two nodes
            function toggleEdge(i, j) {
                // For undirected graph, toggle both (i,j) and (j,i)
                adjacencyMatrix[i][j] = adjacencyMatrix[i][j] === 0 ? 1 : 0;
                adjacencyMatrix[j][i] = adjacencyMatrix[i][j]; // Keep symmetric
                
                renderMatrix();
                drawGraph();
                updateMatrixInfo();
            }

            // Draw the graph visualization
            function drawGraph() {
                // Clear canvas
                ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
                
                // Draw edges
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        if (adjacencyMatrix[i][j] === 1) {
                            ctx.beginPath();
                            ctx.moveTo(graphNodes[i].x, graphNodes[i].y);
                            ctx.lineTo(graphNodes[j].x, graphNodes[j].y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw nodes
                ctx.fillStyle = '#2196F3';
                for (let i = 0; i < nodeCount; i++) {
                    ctx.beginPath();
                    ctx.arc(graphNodes[i].x, graphNodes[i].y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw node label
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(String.fromCharCode(65 + i), graphNodes[i].x, graphNodes[i].y);
                    ctx.fillStyle = '#2196F3';
                }
            }

            // Update matrix information display
            function updateMatrixInfo() {
                let edgeCount = 0;
                let isSymmetric = true;
                
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        if (adjacencyMatrix[i][j] === 1) {
                            edgeCount++;
                        }
                        // Check symmetry
                        if (adjacencyMatrix[i][j] !== adjacencyMatrix[j][i]) {
                            isSymmetric = false;
                        }
                    }
                }
                
                edgeCountDisplay.textContent = `Total edges: ${edgeCount}`;
                symmetryCheckDisplay.textContent = `Symmetric: ${isSymmetric ? 'Yes' : 'No'}`;
            }

            // Generate a random graph
            function generateRandomGraph() {
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        // 30% chance of having an edge
                        adjacencyMatrix[i][j] = Math.random() < 0.3 ? 1 : 0;
                        adjacencyMatrix[j][i] = adjacencyMatrix[i][j]; // Keep symmetric
                    }
                }
                
                renderMatrix();
                drawGraph();
                updateMatrixInfo();
            }

            // Clear all edges
            function clearAllEdges() {
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = 0; j < nodeCount; j++) {
                        adjacencyMatrix[i][j] = 0;
                    }
                }
                
                renderMatrix();
                drawGraph();
                updateMatrixInfo();
            }

            // Event listeners
            generateBtn.addEventListener('click', function() {
                nodeCount = parseInt(nodeCountInput.value);
                if (nodeCount < 2) nodeCount = 2;
                if (nodeCount > 10) nodeCount = 10;
                nodeCountInput.value = nodeCount;
                initializeMatrix();
            });

            clearBtn.addEventListener('click', clearAllEdges);
            randomBtn.addEventListener('click', generateRandomGraph);

            // Initialize on page load
            initializeMatrix();
        });
    </script>
</body>
</html>