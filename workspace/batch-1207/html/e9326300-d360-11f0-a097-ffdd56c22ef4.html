<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Deque (Double-Ended Queue) — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1320;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --success:#34d399;
      --danger:#fb7185;
      --card:#111827;
      --glass: rgba(255,255,255,0.03);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071634 100%); color:#e6eef8}
    .wrap{max-width:1100px;margin:24px auto;padding:20px;}
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    header h1{font-size:20px;margin:0}
    header p{margin:0;color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:18px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,0.6);}
    .controls{display:flex;flex-direction:column;gap:10px;}
    label{font-size:13px;color:var(--muted)}
    input[type="text"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:var(--glass);color:inherit;width:100%;box-sizing:border-box}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap}
    button{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.05));border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.03)}
    button.warn{border-color: rgba(251,113,133,0.18);background: rgba(251,113,133,0.06)}
    button.success{border-color: rgba(52,211,153,0.12);background: rgba(52,211,153,0.04)}
    .visual{display:flex;flex-direction:column;gap:14px;}
    .deque-viewport{min-height:120px;padding:18px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;overflow:auto}
    .deque{display:flex;gap:8px;align-items:center;transition:all .25s ease}
    .slot{min-width:64px;height:64px;border-radius:8px;background:var(--card);display:flex;align-items:center;justify-content:center;font-weight:700;color:#e6eef8;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 14px rgba(2,6,23,0.5);}
    .slot.empty{opacity:0.14;font-weight:500;color:var(--muted);background:transparent;border:1px dashed rgba(255,255,255,0.03)}
    .pointer-row{display:flex;gap:8px;justify-content:center;margin-top:8px;font-size:13px;color:var(--muted)}
    .info{font-size:13px;color:var(--muted);display:flex;gap:12px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;color:#cfe8ff;overflow:auto;font-size:12px}
    .log{height:120px;overflow:auto;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;font-size:13px;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:999px;font-weight:700}
    footer{margin-top:18px;color:var(--muted);font-size:12px}
    .row{display:flex;gap:8px;align-items:center}
    .muted{color:var(--muted)}
    .code-title{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px}
    .demo-controls{display:flex;gap:8px;flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div style="width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:900">DQ</div>
      <div>
        <h1>Deque (Double-Ended Queue) — Interactive Demo</h1>
        <p>Push/pop from both ends. Underlying implementation: circular buffer (resizing). Try operations below and watch the state change.</p>
      </div>
    </header>

    <div class="grid">
      <!-- Controls -->
      <div class="panel controls">
        <label>Value
          <input id="valueInput" type="text" placeholder='e.g. 42 or "hello"' />
        </label>

        <div class="btn-row">
          <button id="pushFrontBtn">Push Front</button>
          <button id="pushBackBtn">Push Back</button>
          <button id="popFrontBtn" class="ghost">Pop Front</button>
          <button id="popBackBtn" class="ghost">Pop Back</button>
        </div>

        <div class="btn-row">
          <button id="peekFrontBtn" class="ghost">Peek Front</button>
          <button id="peekBackBtn" class="ghost">Peek Back</button>
          <button id="clearBtn" class="warn">Clear</button>
          <button id="fillRandomBtn" class="success">Fill Random</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;">
          <label style="margin:0">Rotate
            <select id="rotateAmount" style="margin-left:8px;padding:6px;border-radius:6px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.03)">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </label>
          <div class="demo-controls">
            <button id="rotateLeftBtn" class="ghost">Rotate Left</button>
            <button id="rotateRightBtn" class="ghost">Rotate Right</button>
          </div>
        </div>

        <div style="margin-top:6px" class="row">
          <button id="runExampleBtn" class="ghost">Run Example Sequence</button>
          <button id="showCodeBtn" class="ghost">Show/Hide Code</button>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0" />

        <div class="info">
          <div class="small">Size: <span id="sizeBadge" class="badge">0</span></div>
          <div class="small">Capacity: <span id="capBadge" class="badge">8</span></div>
          <div class="small">Empty: <span id="emptyBadge" class="badge">true</span></div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:12px 0" />

        <div>
          <div class="small" style="margin-bottom:6px">Operation Log</div>
          <div id="opLog" class="log"></div>
        </div>

      </div>

      <!-- Visualization + Code -->
      <div class="panel visual">
        <div class="deque-viewport">
          <div>
            <div class="deque" id="dequeVisual" aria-live="polite"></div>
            <div class="pointer-row" id="pointerRow"></div>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div class="small muted">Implementation: circular buffer with resize (amortized O(1) for push/pop)</div>
          <div style="display:flex;gap:10px;align-items:center">
            <div class="small">Animation: </div>
            <label style="display:flex;align-items:center;gap:6px">
              <input type="range" id="speed" min="50" max="800" value="200" />
            </label>
          </div>
        </div>

        <div id="codeBlock" style="display:none;">
          <div class="code-title"><strong>Deque.js (source)</strong><span class="small muted">Click "Show/Hide Code" to toggle</span></div>
          <pre id="sourceCode"></pre>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:6px">
          <div class="small muted">Try inputs like: numbers, words, or JSON (will be parsed if valid)</div>
          <div><button id="copyStateBtn" class="ghost">Copy State (JSON)</button></div>
        </div>
      </div>
    </div>

    <footer>
      Tip: A deque supports push/pop at both ends. This demo uses a circular array and doubles capacity when full.
    </footer>
  </div>

  <script>
    // Deque implementation (circular buffer with resizing)
    class Deque {
      constructor(initialCapacity = 8) {
        this._cap = Math.max(8, initialCapacity | 0);
        this._buf = new Array(this._cap);
        this._head = 0; // index of front element
        this._len = 0;  // number of elements
      }

      _idx(i) {
        // convert logical index i (0..len-1) to buffer index
        return (this._head + i) % this._cap;
      }

      size() { return this._len; }
      capacity() { return this._cap; }
      isEmpty() { return this._len === 0; }

      // internal grow: double capacity
      _grow() {
        const newCap = this._cap * 2;
        const newBuf = new Array(newCap);
        for (let i = 0; i < this._len; i++) {
          newBuf[i] = this._buf[this._idx(i)];
        }
        this._buf = newBuf;
        this._cap = newCap;
        this._head = 0;
      }

      pushBack(value) {
        if (this._len === this._cap) this._grow();
        this._buf[this._idx(this._len)] = value;
        this._len++;
      }

      pushFront(value) {
        if (this._len === this._cap) this._grow();
        // move head backwards (circularly)
        this._head = (this._head - 1 + this._cap) % this._cap;
        this._buf[this._head] = value;
        this._len++;
      }

      popBack() {
        if (this._len === 0) return undefined;
        const i = this._idx(this._len - 1);
        const val = this._buf[i];
        this._buf[i] = undefined;
        this._len--;
        return val;
      }

      popFront() {
        if (this._len === 0) return undefined;
        const val = this._buf[this._head];
        this._buf[this._head] = undefined;
        this._head = (this._head + 1) % this._cap;
        this._len--;
        return val;
      }

      peekFront() {
        if (this._len === 0) return undefined;
        return this._buf[this._head];
      }

      peekBack() {
        if (this._len === 0) return undefined;
        return this._buf[this._idx(this._len - 1)];
      }

      clear() {
        this._buf = new Array(this._cap);
        this._head = 0;
        this._len = 0;
      }

      toArray() {
        const res = [];
        for (let i = 0; i < this._len; i++) res.push(this._buf[this._idx(i)]);
        return res;
      }

      // rotate left by k (front element moves to back), k >= 0
      rotateLeft(k = 1) {
        if (this._len === 0) return;
        k = ((k % this._len) + this._len) % this._len;
        this._head = (this._head + k) % this._cap;
      }

      // rotate right by k (back element moves to front)
      rotateRight(k = 1) {
        this.rotateLeft(-k);
      }

      // for debugging: show internal buffer and head/len
      debugBuffer() {
        return { head: this._head, len: this._len, cap: this._cap, buf: this._buf.slice() };
      }
    }

    // UI wiring
    const dq = new Deque(8);
    const valueInput = document.getElementById('valueInput');
    const dequeVisual = document.getElementById('dequeVisual');
    const pointerRow = document.getElementById('pointerRow');
    const sizeBadge = document.getElementById('sizeBadge');
    const capBadge = document.getElementById('capBadge');
    const emptyBadge = document.getElementById('emptyBadge');
    const opLog = document.getElementById('opLog');
    const speedRange = document.getElementById('speed');
    const codeBlock = document.getElementById('codeBlock');
    const sourceCode = document.getElementById('sourceCode');

    // Buttons
    document.getElementById('pushFrontBtn').onclick = () => performOp('pushFront');
    document.getElementById('pushBackBtn').onclick = () => performOp('pushBack');
    document.getElementById('popFrontBtn').onclick = () => performOp('popFront');
    document.getElementById('popBackBtn').onclick = () => performOp('popBack');
    document.getElementById('peekFrontBtn').onclick = () => performOp('peekFront');
    document.getElementById('peekBackBtn').onclick = () => performOp('peekBack');
    document.getElementById('clearBtn').onclick = () => performOp('clear');
    document.getElementById('fillRandomBtn').onclick = () => performOp('fillRandom');
    document.getElementById('rotateLeftBtn').onclick = () => performOp('rotateLeft');
    document.getElementById('rotateRightBtn').onclick = () => performOp('rotateRight');
    document.getElementById('runExampleBtn').onclick = runExample;
    document.getElementById('showCodeBtn').onclick = () => {
      codeBlock.style.display = codeBlock.style.display === 'none' ? 'block' : 'none';
    };
    document.getElementById('copyStateBtn').onclick = () => {
      navigator.clipboard?.writeText(JSON.stringify({arr: dq.toArray(), head: dq._head, len: dq._len, cap: dq._cap}, null, 2));
      log('State copied to clipboard');
    };

    // show source code
    sourceCode.textContent = Deque.toString();

    function parseInputValue(text) {
      text = (text ?? '').trim();
      if (text === '') return undefined;
      // Try to parse JSON number/string/array/object/true/false/null
      try {
        return JSON.parse(text);
      } catch (e) {
        return text;
      }
    }

    function log(...parts) {
      const time = new Date().toLocaleTimeString();
      const line = `[${time}] ${parts.join(' ')}`;
      const el = document.createElement('div');
      el.textContent = line;
      opLog.prepend(el);
    }

    function render() {
      // animate based on speed: not heavy animation, but we can transition style
      const arr = dq.toArray();
      dequeVisual.innerHTML = '';
      pointerRow.innerHTML = '';

      if (arr.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'slot empty';
        empty.style.minWidth = '160px';
        empty.textContent = 'Deque is empty';
        dequeVisual.appendChild(empty);
      } else {
        arr.forEach((v, i) => {
          const s = document.createElement('div');
          s.className = 'slot';
          s.style.transitionDuration = (speedRange.value / 1000) + 's';
          s.title = `index ${i}`;
          s.textContent = formatVal(v);
          dequeVisual.appendChild(s);
        });
      }

      // pointers: show head (=front index) and back index relative to logical array
      const headBadge = document.createElement('div');
      headBadge.textContent = 'front';
      headBadge.style.opacity = '0.9';
      const backBadge = document.createElement('div');
      backBadge.textContent = 'back';
      backBadge.style.opacity = '0.9';

      if (arr.length === 0) {
        pointerRow.appendChild(headBadge);
      } else if (arr.length === 1) {
        pointerRow.appendChild(headBadge);
      } else {
        // align labels: create placeholders to position them under elements
        for (let i = 0; i < arr.length; i++) {
          const spot = document.createElement('div');
          spot.style.minWidth = '64px';
          spot.style.textAlign = 'center';
          spot.style.fontSize = '12px';
          spot.style.opacity = '0.9';
          if (i === 0) spot.textContent = 'front';
          else if (i === arr.length - 1) spot.textContent = 'back';
          pointerRow.appendChild(spot);
        }
      }

      sizeBadge.textContent = dq.size();
      capBadge.textContent = dq.capacity();
      emptyBadge.textContent = dq.isEmpty() ? 'true' : 'false';
    }

    function formatVal(v) {
      if (v === undefined) return 'undefined';
      if (v === null) return 'null';
      if (typeof v === 'object') return JSON.stringify(v);
      return String(v);
    }

    function performOp(op) {
      const valRaw = valueInput.value;
      const parsed = parseInputValue(valRaw);

      switch (op) {
        case 'pushFront':
          if (valRaw.trim() === '') { log('pushFront: no value provided'); return; }
          dq.pushFront(parsed);
          log(`pushFront(${formatVal(parsed)})`);
          break;
        case 'pushBack':
          if (valRaw.trim() === '') { log('pushBack: no value provided'); return; }
          dq.pushBack(parsed);
          log(`pushBack(${formatVal(parsed)})`);
          break;
        case 'popFront':
          {
            const r = dq.popFront();
            log(`popFront() -> ${formatVal(r)}`);
          }
          break;
        case 'popBack':
          {
            const r = dq.popBack();
            log(`popBack() -> ${formatVal(r)}`);
          }
          break;
        case 'peekFront':
          {
            const r = dq.peekFront();
            log(`peekFront() -> ${formatVal(r)}`);
          }
          break;
        case 'peekBack':
          {
            const r = dq.peekBack();
            log(`peekBack() -> ${formatVal(r)}`);
          }
          break;
        case 'clear':
          dq.clear();
          log('clear()');
          break;
        case 'fillRandom':
          dq.clear();
          const n = 6 + Math.floor(Math.random() * 6);
          for (let i = 0; i < n; i++) dq.pushBack(Math.floor(Math.random() * 100));
          log(`fillRandom(${n} items)`);
          break;
        case 'rotateLeft':
          dq.rotateLeft(parseInt(document.getElementById('rotateAmount').value || '1', 10));
          log(`rotateLeft(${document.getElementById('rotateAmount').value})`);
          break;
        case 'rotateRight':
          dq.rotateRight(parseInt(document.getElementById('rotateAmount').value || '1', 10));
          log(`rotateRight(${document.getElementById('rotateAmount').value})`);
          break;
      }
      render();
    }

    // Example sequence to illustrate behavior and resizing
    async function runExample() {
      // We'll perform a sequence with pauses
      const seq = [
        ['pushBack', 'A'],
        ['pushBack', 'B'],
        ['pushFront', '0'],
        ['pushBack', 'C'],
        ['pushBack', 'D'],
        ['pushBack', 'E'],
        ['pushBack', 'F'],
        ['pushBack', 'G'],
        ['pushBack', 'H'],
        ['popFront'],
        ['popBack'],
        ['pushFront', 'Z'],
        ['rotateLeft', 2],
        ['rotateRight', 1],
      ];
      const pause = t => new Promise(r => setTimeout(r, t));
      const spd = Math.max(80, 900 - speedRange.value); // shorter wait for faster slider
      for (const step of seq) {
        const [op, arg] = step;
        if (op === 'pushBack') {
          valueInput.value = String(arg);
          performOp('pushBack');
        } else if (op === 'pushFront') {
          valueInput.value = String(arg);
          performOp('pushFront');
        } else if (op === 'popFront') performOp('popFront');
        else if (op === 'popBack') performOp('popBack');
        else if (op === 'rotateLeft') {
          document.getElementById('rotateAmount').value = String(arg || 1);
          performOp('rotateLeft');
        } else if (op === 'rotateRight') {
          document.getElementById('rotateAmount').value = String(arg || 1);
          performOp('rotateRight');
        }
        await pause(spd);
      }
      log('Example sequence finished');
    }

    // Initial render
    render();

    // simple keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') performOp('pushBack');
      if (e.key === 'F2') performOp('pushFront');
      if (e.key === 'Delete') performOp('popBack');
    });

    // Accessibility helpers: announce changes
    const observer = new MutationObserver(() => {
      // Could do ARIA live updates if needed
    });
    observer.observe(dequeVisual, { childList: true, subtree: true });

    // Show the Deque class source nicely
    // Already put Deque.toString() earlier.

    // Small helper: show internal debug on double-click visual
    dequeVisual.addEventListener('dblclick', () => {
      const dbg = dq.debugBuffer();
      log('debugBuffer ->', JSON.stringify(dbg));
      alert('Internal buffer snapshot (see log):\n' + JSON.stringify(dbg, null, 2));
    });

    // seed with a couple values for convenience
    dq.pushBack(10);
    dq.pushBack(20);
    log('Initialized with [10, 20]');
    render();
  </script>
</body>
</html>