<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Window Algorithm Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 800px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .array-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 8px;
        }
        
        .array-element {
            width: 50px;
            height: 50px;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        .window-element {
            background-color: #e74c3c;
        }
        
        .window-highlight {
            position: relative;
            border: 3px solid #e74c3c;
            border-radius: 8px;
            padding: 5px;
            transition: all 0.5s ease-in-out;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .stat-box {
            background-color: #ecf0f1;
            border-radius: 5px;
            padding: 10px 15px;
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff9e6;
            border-left: 4px solid #f39c12;
            border-radius: 0 5px 5px 0;
        }
        
        .algorithm {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            border-radius: 0 5px 5px 0;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .problem-selector {
            margin: 15px 0;
        }
        
        select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
        }
    </style>
</head>
<body>
    <h1>Sliding Window Algorithm Visualization</h1>
    
    <div class="description">
        The sliding window technique is used to optimize algorithms that involve arrays or sequences. 
        Instead of processing each window separately, we maintain a window that "slides" through the data, 
        updating the result efficiently as the window moves.
    </div>
    
    <div class="container">
        <div class="problem-selector">
            <label for="problem-type">Select Problem Type: </label>
            <select id="problem-type">
                <option value="maxSum">Maximum Sum of Subarray</option>
                <option value="longestSubstring">Longest Substring Without Repeating Characters</option>
            </select>
        </div>
        
        <div class="controls">
            <button id="prev-btn">Previous Step</button>
            <button id="next-btn">Next Step</button>
            <button id="reset-btn">Reset</button>
            <button id="auto-btn">Auto Play</button>
        </div>
        
        <div class="array-container" id="array-container">
            <!-- Array elements will be generated here -->
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div>Current Window Size</div>
                <div class="stat-value" id="window-size">3</div>
            </div>
            <div class="stat-box">
                <div>Current Max/Result</div>
                <div class="stat-value" id="current-max">0</div>
            </div>
            <div class="stat-box">
                <div>Window Position</div>
                <div class="stat-value" id="window-position">0-2</div>
            </div>
        </div>
        
        <div class="explanation" id="explanation">
            Click "Next Step" to see how the sliding window algorithm works step by step.
        </div>
        
        <div class="algorithm" id="algorithm-code">
// Sliding Window Algorithm (Maximum Sum)
function maxSumSubarray(arr, k) {
    let maxSum = 0;
    let windowSum = 0;
    
    // Calculate sum of first window
    for (let i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    maxSum = windowSum;
    
    // Slide the window
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i-k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}
        </div>
    </div>

    <script>
        // Sample data
        const array = [2, 1, 5, 1, 3, 2, 8, 5, 7];
        const windowSize = 3;
        let currentStep = 0;
        let maxSum = 0;
        let windowSum = 0;
        let autoPlayInterval;
        let currentProblem = 'maxSum';
        
        // DOM elements
        const arrayContainer = document.getElementById('array-container');
        const windowSizeElement = document.getElementById('window-size');
        const currentMaxElement = document.getElementById('current-max');
        const windowPositionElement = document.getElementById('window-position');
        const explanationElement = document.getElementById('explanation');
        const algorithmCodeElement = document.getElementById('algorithm-code');
        const problemTypeSelector = document.getElementById('problem-type');
        
        // Initialize the visualization
        function init() {
            arrayContainer.innerHTML = '';
            
            // Create array elements
            for (let i = 0; i < array.length; i++) {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = array[i];
                element.id = `element-${i}`;
                arrayContainer.appendChild(element);
            }
            
            updateVisualization();
            updateAlgorithmCode();
        }
        
        // Update the visualization based on current step
        function updateVisualization() {
            // Reset all elements
            for (let i = 0; i < array.length; i++) {
                const element = document.getElementById(`element-${i}`);
                element.classList.remove('window-element');
                element.classList.remove('window-highlight');
            }
            
            if (currentProblem === 'maxSum') {
                updateMaxSumProblem();
            } else {
                updateLongestSubstringProblem();
            }
            
            updateButtons();
        }
        
        function updateMaxSumProblem() {
            if (currentStep === 0) {
                explanationElement.textContent = "Initial state. We'll calculate the sum of the first window of size " + windowSize + ".";
                windowSizeElement.textContent = windowSize;
                currentMaxElement.textContent = "0";
                windowPositionElement.textContent = "Not set";
            } 
            else if (currentStep === 1) {
                // Highlight first window
                for (let i = 0; i < windowSize; i++) {
                    const element = document.getElementById(`element-${i}`);
                    element.classList.add('window-element');
                }
                
                // Calculate initial window sum
                windowSum = 0;
                for (let i = 0; i < windowSize; i++) {
                    windowSum += array[i];
                }
                maxSum = windowSum;
                
                explanationElement.textContent = `Calculated sum of first window [${array.slice(0, windowSize).join(', ')}] = ${windowSum}. This is our initial maximum sum.`;
                currentMaxElement.textContent = maxSum;
                windowPositionElement.textContent = `0-${windowSize-1}`;
            }
            else if (currentStep > 1 && currentStep <= array.length - windowSize + 1) {
                const windowStart = currentStep - 1;
                const windowEnd = windowStart + windowSize - 1;
                
                // Remove highlight from previous window
                for (let i = windowStart - 1; i < windowStart; i++) {
                    const element = document.getElementById(`element-${i}`);
                    if (element) element.classList.remove('window-element');
                }
                
                // Highlight current window
                for (let i = windowStart; i <= windowEnd; i++) {
                    const element = document.getElementById(`element-${i}`);
                    element.classList.add('window-element');
                }
                
                // Update window sum using sliding window technique
                windowSum = windowSum - array[windowStart - 1] + array[windowEnd];
                maxSum = Math.max(maxSum, windowSum);
                
                explanationElement.textContent = `Window slides to position ${windowStart}-${windowEnd}. New sum = Previous sum (${windowSum + array[windowStart - 1] - array[windowEnd]}) - ${array[windowStart - 1]} + ${array[windowEnd]} = ${windowSum}. Maximum sum so far: ${maxSum}.`;
                currentMaxElement.textContent = maxSum;
                windowPositionElement.textContent = `${windowStart}-${windowEnd}`;
            }
            else if (currentStep > array.length - windowSize + 1) {
                explanationElement.textContent = `Algorithm complete! The maximum sum of any subarray of size ${windowSize} is ${maxSum}.`;
                currentMaxElement.textContent = maxSum;
                windowPositionElement.textContent = "Complete";
            }
        }
        
        function updateLongestSubstringProblem() {
            // Simplified visualization for longest substring problem
            if (currentStep === 0) {
                explanationElement.textContent = "Initial state. We'll find the longest substring without repeating characters.";
                windowSizeElement.textContent = "Variable";
                currentMaxElement.textContent = "0";
                windowPositionElement.textContent = "Not set";
            } 
            else if (currentStep <= array.length) {
                // Highlight the current window
                const windowStart = Math.max(0, currentStep - 5);
                const windowEnd = currentStep - 1;
                
                for (let i = windowStart; i <= windowEnd; i++) {
                    const element = document.getElementById(`element-${i}`);
                    if (element) element.classList.add('window-element');
                }
                
                // Simple simulation for demonstration
                const currentLength = Math.min(currentStep, 5);
                maxSum = Math.max(maxSum, currentLength);
                
                explanationElement.textContent = `Checking substring up to position ${windowEnd}. Current length: ${currentLength}. Longest so far: ${maxSum}.`;
                currentMaxElement.textContent = maxSum;
                windowPositionElement.textContent = `${windowStart}-${windowEnd}`;
            }
            else {
                explanationElement.textContent = `Algorithm complete! The longest substring without repeating characters has length ${maxSum}.`;
                currentMaxElement.textContent = maxSum;
                windowPositionElement.textContent = "Complete";
            }
        }
        
        function updateAlgorithmCode() {
            if (currentProblem === 'maxSum') {
                algorithmCodeElement.textContent = `// Sliding Window Algorithm (Maximum Sum)
function maxSumSubarray(arr, k) {
    let maxSum = 0;
    let windowSum = 0;
    
    // Calculate sum of first window
    for (let i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    maxSum = windowSum;
    
    // Slide the window
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i-k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}`;
            } else {
                algorithmCodeElement.textContent = `// Sliding Window Algorithm (Longest Substring)
function longestSubstringWithoutRepeating(s) {
    let charSet = new Set();
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        while (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }
        charSet.add(s[right]);
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`;
            }
        }
        
        function updateButtons() {
            document.getElementById('prev-btn').disabled = currentStep === 0;
            document.getElementById('next-btn').disabled = currentStep > array.length - windowSize + 2;
        }
        
        // Event listeners
        document.getElementById('next-btn').addEventListener('click', () => {
            currentStep++;
            updateVisualization();
        });
        
        document.getElementById('prev-btn').addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateVisualization();
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            currentStep = 0;
            maxSum = 0;
            windowSum = 0;
            updateVisualization();
            stopAutoPlay();
        });
        
        document.getElementById('auto-btn').addEventListener('click', () => {
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        });
        
        problemTypeSelector.addEventListener('change', (e) => {
            currentProblem = e.target.value;
            currentStep = 0;
            maxSum = 0;
            windowSum = 0;
            updateAlgorithmCode();
            updateVisualization();
            stopAutoPlay();
        });
        
        function startAutoPlay() {
            document.getElementById('auto-btn').textContent = 'Stop Auto Play';
            autoPlayInterval = setInterval(() => {
                if (currentStep <= array.length - windowSize + 2) {
                    currentStep++;
                    updateVisualization();
                } else {
                    stopAutoPlay();
                }
            }, 1500);
        }
        
        function stopAutoPlay() {
            document.getElementById('auto-btn').textContent = 'Auto Play';
            clearInterval(autoPlayInterval);
            autoPlayInterval = null;
        }
        
        // Initialize the visualization
        init();
    </script>
</body>
</html>