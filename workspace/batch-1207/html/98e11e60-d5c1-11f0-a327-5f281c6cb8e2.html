<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Binary Tree Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --node:#0ea5a4;
      --node-border:#08363a;
      --highlight:#f59e0b;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
      --font-sans: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071427 60%);font-family:var(--font-sans);color:#e6eef8}
    .app {
      display:flex;
      gap:16px;
      padding:18px;
      box-sizing:border-box;
      height:100vh;
      align-items:stretch;
    }
    .panel{
      width:360px;
      background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    h1{margin:0;font-size:18px;color:#dbeafe}
    .controls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    input[type="number"], input[type="text"]{
      background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:8px;border-radius:8px;min-width:0;
    }
    button{
      background:var(--accent);border:none;color:#03203b;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;
      box-shadow: 0 4px 8px rgba(59,130,246,0.14);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);box-shadow:none;}
    button.warn{background:var(--danger);color:white;}
    .row{display:flex;gap:8px;align-items:center;}
    .small{font-size:13px;color:var(--muted)}
    .vis {
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      padding:12px;
      position:relative;
      min-width:0;
      overflow:hidden;
    }
    #svgCanvas{
      width:100%;height:100%;background:transparent;display:block;border-radius:8px;
    }
    .legend{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;font-size:13px;color:var(--muted)
    }
    .badge{
      padding:6px 8px;border-radius:999px;background:var(--glass);color:var(--muted);font-weight:600;border:1px solid rgba(255,255,255,0.02);
    }
    .status{
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    }
    .footer{
      font-size:13px;color:var(--muted);margin-top:auto;
    }
    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
    .traversal-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .result{
      background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted);font-size:13px;min-height:36px;
    }
    .node-label{
      font-weight:700;color:#021016;
    }
    .help{font-size:13px;color:var(--muted)}
    a{color:var(--accent)}
    /* Tooltip-ish small */
    .mini{font-size:12px;color:var(--muted)}
    /* Responsive */
    @media (max-width:920px){
      .app{flex-direction:column;padding:12px;}
      .panel{width:100%;}
      .vis{height:58vh;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel" aria-hidden="false">
      <h1>Binary Tree (BST) Visualizer</h1>
      <div class="small">Interactive Binary Search Tree with insert, delete, search, and animated traversals.</div>

      <div class="controls">
        <div style="flex:1">
          <div class="row" style="gap:6px;">
            <input id="valueInput" type="number" placeholder="Value (integer)" />
            <button id="insertBtn">Insert</button>
            <button id="deleteBtn" class="ghost">Delete</button>
          </div>
          <div class="row" style="margin-top:6px;">
            <input id="searchInput" type="number" placeholder="Search value" />
            <button id="searchBtn" class="ghost">Search</button>
            <button id="clearHighlights" class="ghost">Clear</button>
          </div>
        </div>
      </div>

      <div class="controls-grid">
        <div>
          <div class="row">
            <input id="randomCount" type="number" min="1" max="25" value="8" />
            <button id="randomBtn" class="ghost">Random Tree</button>
            <button id="clearBtn" class="ghost">Clear Tree</button>
          </div>
          <div class="mini" style="margin-top:6px">Random adds unique values in range 1..99.</div>
        </div>

        <div>
          <div class="small">Traversal</div>
          <div class="traversal-controls" style="margin-top:6px;">
            <button id="preorder" class="ghost">Preorder</button>
            <button id="inorder" class="ghost">Inorder</button>
            <button id="postorder" class="ghost">Postorder</button>
            <button id="bfs" class="ghost">Level-order</button>
            <div style="display:flex;align-items:center;gap:6px;margin-left:auto;">
              <label class="mini">Speed</label>
              <input id="speed" type="range" min="200" max="1200" value="520" />
            </div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
        <div class="badge">Nodes: <span id="nodeCount">0</span></div>
        <div class="badge">Height: <span id="treeHeight">0</span></div>
        <div class="badge">Last Op: <span id="lastOp">—</span></div>
      </div>

      <div style="margin-top:8px">
        <div class="small">Traversal result</div>
        <div id="result" class="result" aria-live="polite">—</div>
      </div>

      <div class="footer">
        Tip: Insert integers. The layout uses an in-order horizontal spacing so BST structure is clear. Click nodes to remove them. Drag the background to pan (hold mouse + move).
      </div>
    </div>

    <div class="vis" id="visualArea">
      <svg id="svgCanvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet">
        <defs>
          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="6" stdDeviation="8" flood-color="#000" flood-opacity="0.45"/>
          </filter>
        </defs>
        <!-- edges and nodes drawn by JS -->
      </svg>
      <!-- small legend -->
      <div style="position:absolute;right:14px;bottom:12px;display:flex;gap:8px;align-items:center;">
        <div class="legend">
          <div style="display:flex;align-items:center;gap:6px;">
            <svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#0ea5a4"/></svg><div class="mini">Node</div>
          </div>
          <div style="display:flex;align-items:center;gap:6px;">
            <svg width="18" height="18"><rect width="18" height="4" y="7" fill="#94a3b8"/></svg><div class="mini">Edge</div>
          </div>
          <div style="display:flex;align-items:center;gap:6px;">
            <svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#f59e0b"/></svg><div class="mini">Highlight</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Binary Search Tree visualizer
    (function(){
      // Basic BST implementation with nodes
      class TreeNode {
        constructor(val){
          this.val = val;
          this.left = null;
          this.right = null;
          // visualization coordinates
          this.x = 0; this.y = 0;
          this.id = TreeNode._nextId++;
        }
      }
      TreeNode._nextId = 1;

      class BST {
        constructor(){
          this.root = null;
          this._count = 0;
        }
        insert(val){
          if(this.root === null){
            this.root = new TreeNode(val);
            this._count++;
            return this.root;
          }
          let cur = this.root;
          while(true){
            if(val === cur.val) return null; // no duplicates
            if(val < cur.val){
              if(cur.left) cur = cur.left;
              else { cur.left = new TreeNode(val); this._count++; return cur.left; }
            } else {
              if(cur.right) cur = cur.right;
              else { cur.right = new TreeNode(val); this._count++; return cur.right; }
            }
          }
        }
        contains(val){
          let cur = this.root;
          while(cur){
            if(val === cur.val) return cur;
            cur = val < cur.val ? cur.left : cur.right;
          }
          return null;
        }
        remove(val){
          let deleted = false;
          function removeNode(node, val){
            if(!node) return null;
            if(val < node.val){
              node.left = removeNode(node.left, val);
              return node;
            } else if(val > node.val){
              node.right = removeNode(node.right, val);
              return node;
            } else {
              // found
              deleted = true;
              // no children
              if(!node.left && !node.right) return null;
              // one child
              if(!node.left) return node.right;
              if(!node.right) return node.left;
              // two children: find inorder successor (smallest in right)
              let succParent = node;
              let succ = node.right;
              while(succ.left){
                succParent = succ;
                succ = succ.left;
              }
              node.val = succ.val;
              // remove successor
              if(succParent === node) succParent.right = succ.right;
              else succParent.left = succ.right;
              return node;
            }
          }
          this.root = removeNode(this.root, val);
          if(deleted) this._count--;
          return deleted;
        }
        clear(){ this.root = null; this._count = 0; TreeNode._nextId = 1; }
        count(){ return this._count; }
        height(){
          function h(n){ if(!n) return 0; return 1 + Math.max(h(n.left), h(n.right)); }
          return h(this.root);
        }
        inorder(callback){
          const res = [];
          function go(n){
            if(!n) return;
            go(n.left);
            res.push(n);
            go(n.right);
          }
          go(this.root);
          if(callback) res.forEach(callback);
          return res;
        }
        preorder(callback){
          const res = [];
          function go(n){
            if(!n) return;
            res.push(n);
            go(n.left);
            go(n.right);
          }
          go(this.root);
          if(callback) res.forEach(callback);
          return res;
        }
        postorder(callback){
          const res = [];
          function go(n){
            if(!n) return;
            go(n.left);
            go(n.right);
            res.push(n);
          }
          go(this.root);
          if(callback) res.forEach(callback);
          return res;
        }
        levelOrder(callback){
          const res = [];
          if(!this.root) return res;
          const q = [this.root];
          while(q.length){
            const n = q.shift();
            res.push(n);
            if(n.left) q.push(n.left);
            if(n.right) q.push(n.right);
          }
          if(callback) res.forEach(callback);
          return res;
        }
      }

      // DOM elements
      const svg = document.getElementById('svgCanvas');
      const insertBtn = document.getElementById('insertBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const randomCount = document.getElementById('randomCount');
      const valueInput = document.getElementById('valueInput');
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      const clearHighlights = document.getElementById('clearHighlights');
      const nodeCountEl = document.getElementById('nodeCount');
      const treeHeightEl = document.getElementById('treeHeight');
      const lastOpEl = document.getElementById('lastOp');
      const resultEl = document.getElementById('result');
      const inorderBtn = document.getElementById('inorder');
      const preorderBtn = document.getElementById('preorder');
      const postorderBtn = document.getElementById('postorder');
      const bfsBtn = document.getElementById('bfs');
      const speedSlider = document.getElementById('speed');
      const visualArea = document.getElementById('visualArea');

      // state
      const tree = new BST();
      let elementsMap = new Map(); // node.id -> {g,line,...}
      let highlightTimer = null;
      let currentAnim = null;
      let pan = {x:0,y:0};
      let viewBox = {w:1200,h:700,x:0,y:0};

      // layout constants
      const margin = {top:40, bottom:40, left:40, right:40};
      const levelHeight = 90;
      const nodeRadius = 26;

      // utility create SVG elements
      function svgEl(tag, attrs){ const el = document.createElementNS("http://www.w3.org/2000/svg", tag); if(attrs) for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }

      // render tree (clear and redraw)
      function render(){
        // clear SVG
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        // re-add defs (shadow)
        const defs = svg.querySelector('defs');
        // create defs manually to keep filter
        const defsNew = svgEl('defs');
        const filter = svgEl('filter',{id:'shadow',x:'-50%',y:'-50%',width:'200%',height:'200%'});
        const fe = document.createElementNS("http://www.w3.org/2000/svg",'feDropShadow');
        fe.setAttribute('dx','0'); fe.setAttribute('dy','6'); fe.setAttribute('stdDeviation','8'); fe.setAttribute('flood-color','#000'); fe.setAttribute('flood-opacity','0.45');
        filter.appendChild(fe);
        defsNew.appendChild(filter);
        svg.appendChild(defsNew);

        elementsMap.clear();
        if(!tree.root){
          updateStats();
          return;
        }

        // compute positions: use inorder horizontal spacing
        let counter = 0;
        const nodesInOrder = [];
        function inorderAssign(n, depth){
          if(!n) return;
          inorderAssign(n.left, depth+1);
          nodesInOrder.push({node:n, depth:depth});
          inorderAssign(n.right, depth+1);
        }
        inorderAssign(tree.root, 0);
        const total = nodesInOrder.length;
        const svgW = viewBox.w - margin.left - margin.right;
        nodesInOrder.forEach((entry, idx) => {
          const n = entry.node;
          const depth = entry.depth;
          const x = margin.left + ((idx+1) * svgW / (total+1));
          const y = margin.top + depth * levelHeight + nodeRadius;
          n.x = x;
          n.y = y;
        });

        // draw edges first (lines)
        function drawEdges(n){
          if(!n) return;
          if(n.left){
            const line = svgEl('line', {
              x1:n.x, y1:n.y, x2:n.left.x, y2:n.left.y,
              stroke:'#94a3b8', 'stroke-width':2, 'stroke-linecap':'round'
            });
            svg.appendChild(line);
          }
          if(n.right){
            const line = svgEl('line', {
              x1:n.x, y1:n.y, x2:n.right.x, y2:n.right.y,
              stroke:'#94a3b8', 'stroke-width':2, 'stroke-linecap':'round'
            });
            svg.appendChild(line);
          }
          drawEdges(n.left);
          drawEdges(n.right);
        }
        drawEdges(tree.root);

        // draw nodes
        function drawNodes(n){
          if(!n) return;
          const g = svgEl('g', {cursor:'pointer', 'data-id': n.id});
          // shadow circle
          const shadow = svgEl('circle', {cx:n.x, cy:n.y+4, r:nodeRadius, fill:'rgba(0,0,0,0.18)'});
          // main circle
          const c = svgEl('circle', {cx:n.x, cy:n.y, r:nodeRadius, fill:'#0ea5a4', stroke:'#08363a', 'stroke-width':2});
          c.style.filter = 'url(#shadow)';
          // label
          const t = svgEl('text', {x:n.x, y:n.y+6, 'text-anchor':'middle', 'font-size':14, 'font-family': 'inherit', fill:'#021016', 'font-weight':700});
          t.textContent = String(n.val);

          g.appendChild(shadow);
          g.appendChild(c);
          g.appendChild(t);
          svg.appendChild(g);

          // store
          elementsMap.set(n.id, {group:g, circle:c, label:t, node:n});

          // click to delete quickly
          g.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            // delete node on click
            tree.remove(n.val);
            lastOpEl.textContent = 'Deleted ' + n.val;
            cancelAnimation();
            render();
          });

          drawNodes(n.left);
          drawNodes(n.right);
        }
        drawNodes(tree.root);

        updateStats();
      }

      function updateStats(){
        nodeCountEl.textContent = String(tree.count());
        treeHeightEl.textContent = String(tree.height());
      }

      // Traversals with animation
      function animateTraversal(nodes, label){
        cancelAnimation();
        lastOpEl.textContent = label;
        const speed = Number(speedSlider.value);
        resultEl.textContent = '';
        let i = 0;
        currentAnim = setInterval(()=>{
          // clear previous highlights
          elementsMap.forEach((el, id)=>{
            el.circle.setAttribute('fill','#0ea5a4');
            el.circle.setAttribute('r', nodeRadius);
          });
          if(i >= nodes.length){
            clearInterval(currentAnim);
            currentAnim = null;
            lastOpEl.textContent = 'Traversal complete';
            return;
          }
          const n = nodes[i];
          const el = elementsMap.get(n.id);
          if(el){
            el.circle.setAttribute('fill','#f59e0b');
            el.circle.setAttribute('r', nodeRadius+2);
          }
          // append to result text
          const arr = nodes.slice(0,i+1).map(x=>x.val);
          resultEl.textContent = arr.join(', ');
          i++;
        }, speed);
      }

      function cancelAnimation(){
        if(currentAnim){ clearInterval(currentAnim); currentAnim = null; }
        // clear highlights
        elementsMap.forEach((el, id)=>{
          el.circle.setAttribute('fill','#0ea5a4');
          el.circle.setAttribute('r', nodeRadius);
        });
      }

      // Search with path highlight (non-animated)
      function highlightSearch(val){
        cancelAnimation();
        const path = [];
        let cur = tree.root;
        while(cur){
          path.push(cur);
          if(val === cur.val) break;
          cur = val < cur.val ? cur.left : cur.right;
        }
        // highlight path progressively
        let i = 0;
        const speed = Number(speedSlider.value);
        currentAnim = setInterval(()=>{
          elementsMap.forEach((el)=>{ el.circle.setAttribute('fill','#0ea5a4'); el.circle.setAttribute('r', nodeRadius); });
          if(i >= path.length){
            clearInterval(currentAnim); currentAnim = null;
            const found = path.length && path[path.length-1].val === val;
            lastOpEl.textContent = found ? 'Found ' + val : 'Not found';
            return;
          }
          const n = path[i];
          const el = elementsMap.get(n.id);
          if(el){
            el.circle.setAttribute('fill', i === path.length-1 && n.val===val ? '#10b981' : '#f59e0b');
            el.circle.setAttribute('r', nodeRadius + (i===path.length-1 && n.val===val ? 4 : 2));
          }
          i++;
        }, speed);
      }

      // Events
      insertBtn.addEventListener('click', ()=>{
        const v = Number(valueInput.value);
        if(Number.isNaN(v)){ alert('Enter an integer to insert.'); return; }
        const node = tree.insert(v);
        if(node === null){
          lastOpEl.textContent = 'Value exists';
          return;
        }
        lastOpEl.textContent = 'Inserted ' + v;
        cancelAnimation();
        render();
      });
      deleteBtn.addEventListener('click', ()=>{
        const v = Number(valueInput.value);
        if(Number.isNaN(v)){ alert('Enter an integer to delete.'); return; }
        const ok = tree.remove(v);
        lastOpEl.textContent = ok ? 'Deleted ' + v : 'Not found';
        cancelAnimation();
        render();
      });
      clearBtn.addEventListener('click', ()=>{
        tree.clear();
        lastOpEl.textContent = 'Cleared tree';
        cancelAnimation();
        render();
      });
      randomBtn.addEventListener('click', ()=>{
        tree.clear();
        const count = Math.max(1, Math.min(25, Number(randomCount.value) || 8));
        const used = new Set();
        while(used.size < count){
          used.add(Math.floor(Math.random()*99)+1);
        }
        [...used].forEach(v=>tree.insert(v));
        lastOpEl.textContent = 'Random tree (' + count + ' nodes)';
        cancelAnimation();
        render();
      });
      inorderBtn.addEventListener('click', ()=>{
        const nodes = tree.inorder();
        animateTraversal(nodes, 'Inorder');
      });
      preorderBtn.addEventListener('click', ()=>{
        const nodes = tree.preorder();
        animateTraversal(nodes, 'Preorder');
      });
      postorderBtn.addEventListener('click', ()=>{
        const nodes = tree.postorder();
        animateTraversal(nodes, 'Postorder');
      });
      bfsBtn.addEventListener('click', ()=>{
        const nodes = tree.levelOrder();
        animateTraversal(nodes, 'Level-order');
      });
      searchBtn.addEventListener('click', ()=>{
        const v = Number(searchInput.value);
        if(Number.isNaN(v)){ alert('Enter an integer to search.'); return; }
        highlightSearch(v);
      });
      clearHighlights.addEventListener('click', ()=>{
        cancelAnimation();
        resultEl.textContent = '—';
        lastOpEl.textContent = 'Cleared highlights';
      });

      // click background to unfocus / clear
      svg.addEventListener('click', (ev)=>{
        // clear selection
        cancelAnimation();
      });

      // Make background pannable (drag to pan)
      let isPanning = false;
      let panStart = null;
      visualArea.addEventListener('mousedown', (ev)=>{
        if(ev.target.closest('g')) return; // clicked a node
        isPanning = true;
        panStart = {x: ev.clientX, y: ev.clientY, vbX:viewBox.x, vbY:viewBox.y};
        visualArea.style.cursor = 'grabbing';
        ev.preventDefault();
      });
      window.addEventListener('mousemove', (ev)=>{
        if(!isPanning) return;
        const dx = (ev.clientX - panStart.x);
        const dy = (ev.clientY - panStart.y);
        // translate to viewBox units: assume viewBox width maps to element width
        const rect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / rect.width;
        const scaleY = viewBox.h / rect.height;
        viewBox.x = panStart.vbX - dx*scaleX;
        viewBox.y = panStart.vbY - dy*scaleY;
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      });
      window.addEventListener('mouseup', ()=>{
        if(isPanning){ isPanning=false; visualArea.style.cursor='default'; }
      });

      // zoom with wheel
      visualArea.addEventListener('wheel', (ev)=>{
        ev.preventDefault();
        const zoomFactor = ev.deltaY > 0 ? 1.08 : 0.92;
        const rect = svg.getBoundingClientRect();
        const mx = ev.clientX - rect.left;
        const my = ev.clientY - rect.top;
        const svgMouseX = viewBox.x + mx * (viewBox.w / rect.width);
        const svgMouseY = viewBox.y + my * (viewBox.h / rect.height);
        viewBox.w *= zoomFactor;
        viewBox.h *= zoomFactor;
        viewBox.x = svgMouseX - (mx * (viewBox.w / rect.width));
        viewBox.y = svgMouseY - (my * (viewBox.h / rect.height));
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      }, {passive:false});

      // keyboard shortcuts
      window.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Delete'){
          const v = Number(valueInput.value);
          if(!Number.isNaN(v)){
            tree.remove(v); render();
          }
        }
      });

      // initial render
      render();

      // expose tree for debugging (dev console)
      window.__bst = tree;
    })();
  </script>
</body>
</html>