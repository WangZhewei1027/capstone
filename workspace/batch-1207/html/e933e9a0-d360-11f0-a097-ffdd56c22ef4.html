<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Counting Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --success:#10b981;
      --danger:#ef4444;
      --card:#071126;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,var(--bg),#061024);
      color:#e6eef6;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:16px;
      box-sizing:border-box;
    }
    .app{
      max-width:1200px;
      margin:0 auto;
    }
    header{
      display:flex;
      align-items:center;
      gap:16px;
      margin-bottom:12px;
    }
    h1{
      font-size:20px;
      margin:0;
    }
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:12px;
      align-items:center;
    }
    .panel{
      background:linear-gradient(180deg,var(--panel),#081223);
      border-radius:10px;
      padding:12px;
      box-shadow:0 4px 18px rgba(2,6,23,0.6);
      margin-bottom:12px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    label{font-size:13px;color:var(--muted)}
    input[type="text"]{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:var(--card);
      color:inherit;
      min-width:260px;
    }
    button{
      padding:8px 12px;
      border-radius:8px;
      border:0;
      background:var(--accent);
      color:#042027;
      cursor:pointer;
      font-weight:600;
    }
    button.secondary{
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
    }
    button.danger{
      background:var(--danger);
      color:white;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }
    .flex{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .viz{
      display:flex;
      gap:16px;
      align-items:flex-end;
      justify-content:space-between;
      margin-top:12px;
    }
    .area{
      flex:1;
      min-height:160px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .title{
      font-size:13px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .bars{
      display:flex;
      gap:6px;
      align-items:end;
      height:120px;
      padding:8px;
      overflow:auto;
    }
    .bar{
      width:28px;
      display:flex;
      align-items:end;
      justify-content:center;
      flex-direction:column;
      gap:6px;
      transition:transform 220ms ease, background 220ms ease;
      padding-bottom:4px;
    }
    .bar .blk{
      width:100%;
      border-radius:6px 6px 4px 4px;
      background:linear-gradient(180deg,#60a5fa,#2563eb);
      height:40px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#02102a;
      font-weight:700;
      font-size:12px;
    }
    .bar .val{
      font-size:12px;
      color:var(--muted);
      text-align:center;
      margin-top:6px;
    }
    .bar.highlight .blk{
      background:linear-gradient(180deg,#06b6d4,#0891b2);
      transform:translateY(-6px) scale(1.1);
      box-shadow:0 10px 24px rgba(6,182,212,0.12);
    }
    .bar.placing .blk{
      background:linear-gradient(180deg,#34d399,#10b981);
      transform:translateY(-6px) scale(1.05);
      box-shadow:0 10px 24px rgba(16,185,129,0.12);
    }
    .counts{
      display:flex;
      gap:6px;
      align-items:end;
      height:80px;
      padding:8px;
      overflow:auto;
    }
    .count{
      width:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:6px;
    }
    .count .cell{
      min-height:22px;
      border-radius:6px;
      background:rgba(255,255,255,0.03);
      padding:6px;
      font-size:13px;
      color:var(--muted);
      width:100%;
      text-align:center;
    }
    .count .cell.highlight{
      background:linear-gradient(180deg,#fbbf24,#f97316);
      color:#02100a;
      font-weight:700;
      transform:translateY(-4px);
      box-shadow:0 8px 18px rgba(249,115,22,0.12);
    }
    .count .label{
      font-size:12px;
      color:var(--muted);
    }
    .outbar{
      width:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:6px;
    }
    .outbar .cell{
      min-height:28px;
      border-radius:6px;
      background:rgba(255,255,255,0.02);
      padding:6px;
      width:100%;
      text-align:center;
      color:var(--muted);
      font-weight:700;
    }
    .outbar .cell.filled{
      background:linear-gradient(180deg,#a78bfa,#7c3aed);
      color:#fff;
      box-shadow:0 10px 24px rgba(124,58,237,0.09);
    }
    .desc{
      font-size:13px;
      color:var(--muted);
      margin-top:8px;
      line-height:1.4;
      min-height:44px;
    }
    .footer{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }
    input[type="range"]{width:160px}
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      background:transparent;
      color:var(--muted);
    }
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .chip{
      display:flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      background:var(--glass);
      border-radius:8px;
      color:var(--muted);
      font-size:13px;
    }
    .chip .swatch{
      width:12px;
      height:12px;
      border-radius:3px;
    }
    .sw-count{background:#f97316}
    .sw-input{background:#06b6d4}
    .sw-output{background:#7c3aed}
    pre{
      white-space:pre-wrap;
      font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
      background:rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      color:#cbd5e1;
      font-size:13px;
      margin:0;
    }
    @media (max-width:880px){
      .viz{flex-direction:column}
      .bars{height:100px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Counting Sort — Visualizer & Interactive Demo</h1>
    </header>

    <div class="panel controls">
      <div class="row" style="flex-wrap:wrap;gap:8px;">
        <label>Array (comma-separated integers):</label>
        <input id="arrayInput" type="text" placeholder="e.g. 3,6,4,1,3,4,1,4" />
        <button id="setArr" class="small">Set Array</button>
        <button id="randArr" class="small secondary">Random</button>
        <label style="margin-left:8px;">Max value (domain 0..k):</label>
        <input id="maxVal" type="number" min="0" max="200" value="6" style="width:80px;padding:6px;border-radius:8px;background:var(--card);border:1px solid rgba(255,255,255,0.04);color:inherit;" />
        <label class="toggle"><input id="stableChk" type="checkbox" checked/> Stable</label>
      </div>

      <div style="display:flex;gap:12px;margin-top:10px;align-items:center;">
        <button id="playBtn">Play</button>
        <button id="pauseBtn" class="small secondary">Pause</button>
        <button id="stepF" class="small">Step →</button>
        <button id="stepB" class="small secondary">← Back</button>
        <button id="resetBtn" class="small danger">Reset</button>

        <div style="margin-left:8px;">
          <label style="font-size:13px;color:var(--muted);">Speed:</label>
          <input id="speed" type="range" min="50" max="1200" step="50" value="500" />
        </div>
      </div>
    </div>

    <div class="viz">
      <div class="area panel" style="flex:1.3">
        <div class="title">
          <div>Input Array</div>
          <div style="color:var(--muted);font-size:13px;">Elements processed are highlighted</div>
        </div>
        <div class="bars" id="inputBars" aria-hidden="true"></div>
        <div class="desc" id="descInput">Enter an array and click "Set Array" or "Random", then Play to visualize Counting Sort. Stable = maintain order of equal keys.</div>
      </div>

      <div class="area panel" style="flex:0.9">
        <div class="title">
          <div>Counts / Cumulative</div>
          <div style="color:var(--muted);font-size:13px;">Index → count</div>
        </div>
        <div class="counts" id="countsArea"></div>
        <div class="desc" id="descCounts">Counts are initialized to zero. While counting, we increment counts[value]. Then we (optionally) convert to cumulative counts for stable placement.</div>
      </div>

      <div class="area panel" style="flex:1">
        <div class="title">
          <div>Output Array</div>
          <div style="color:var(--muted);font-size:13px;">Result will be filled during placement</div>
        </div>
        <div class="bars" id="outputBars" style="height:120px"></div>
        <div class="desc" id="descOut">The sorted output is progressively built. For a stable algorithm we place from right→left using cumulative counts to get positions.</div>
      </div>
    </div>

    <div class="panel" style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;">
      <div style="flex:1;min-width:320px;">
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Legend</div>
        <div class="legend">
          <div class="chip"><span class="swatch sw-input"></span> Input element</div>
          <div class="chip"><span class="swatch sw-count"></span> Count / cumulative update</div>
          <div class="chip"><span class="swatch sw-output"></span> Output placement</div>
        </div>
        <div style="height:8px"></div>
        <div style="font-size:13px;color:var(--muted);">Algorithm (conceptual):</div>
        <pre>
1) Count occurrences: for x in A: count[x]++
2) Convert counts to positions (cumulative): for i=1..k: count[i]+=count[i-1]
3) Place elements into output:
   - Stable: for i = n-1 downto 0: out[--count[A[i]]] = A[i]
   - Unstable: for v = 0..k: output next count[v] copies of v
        </pre>
      </div>

      <div style="flex:1;min-width:260px;">
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Current Step Info</div>
        <div style="padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;">
          <div id="stepTitle" style="font-weight:700;color:#fff">Idle</div>
          <div id="stepDetail" style="color:var(--muted);margin-top:6px">No steps yet. Configure array and press Play.</div>
        </div>
        <div style="height:12px"></div>
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Pseudocode</div>
        <pre id="pseudocode">
function countingSort(A, k):
  count = [0..k] // zeros
  for x in A:
    count[x]++
  for i in 1..k:
    count[i] += count[i-1]
  output = [size A]
  for i from len(A)-1 downto 0:
    output[--count[A[i]]] = A[i]   // stable placement
  return output
        </pre>
      </div>
    </div>

    <div class="footer">
      <div>Array length: <span id="lenInfo">0</span> • Max value domain k: <span id="kInfo">0</span></div>
      <div style="color:var(--muted)">Tip: Keep k (max) reasonably small for clear visualization. Values must be integers in 0..k.</div>
    </div>
  </div>

<script>
(function(){
  // Elements
  const arrayInput = document.getElementById('arrayInput');
  const setArrBtn = document.getElementById('setArr');
  const randArrBtn = document.getElementById('randArr');
  const maxValInput = document.getElementById('maxVal');
  const stableChk = document.getElementById('stableChk');

  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepF = document.getElementById('stepF');
  const stepB = document.getElementById('stepB');
  const resetBtn = document.getElementById('resetBtn');
  const speedInput = document.getElementById('speed');

  const inputBars = document.getElementById('inputBars');
  const countsArea = document.getElementById('countsArea');
  const outputBars = document.getElementById('outputBars');

  const descInput = document.getElementById('descInput');
  const descCounts = document.getElementById('descCounts');
  const descOut = document.getElementById('descOut');

  const stepTitle = document.getElementById('stepTitle');
  const stepDetail = document.getElementById('stepDetail');

  const lenInfo = document.getElementById('lenInfo');
  const kInfo = document.getElementById('kInfo');

  // State
  let A = [];
  let k = parseInt(maxValInput.value,10) || 6;
  let snapshots = [];
  let current = 0;
  let playing = false;
  let timer = null;
  let speed = parseInt(speedInput.value,10) || 500;

  // Utilities
  function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
  function copyArr(a){return a.slice()}
  function renderArraysFromSnapshot(snap){
    // Input Bars
    inputBars.innerHTML = '';
    (snap.input || A).forEach((v,idx)=>{
      const b = document.createElement('div');
      b.className = 'bar' + ((snap.phase==='counting' && snap.processedIndex===idx) ? ' highlight' : (snap.phase==='placing' && snap.processedIndex===idx ? ' placing' : ''));
      b.style.width = (Math.max(28, Math.min(80, 360/(A.length||1)))) + 'px';
      const blk = document.createElement('div');
      blk.className = 'blk';
      blk.textContent = v;
      const val = document.createElement('div');
      val.className = 'val';
      val.textContent = idx;
      b.appendChild(blk);
      b.appendChild(val);
      inputBars.appendChild(b);
    });

    // Counts
    countsArea.innerHTML = '';
    (snap.counts || []).forEach((c,idx)=>{
      const cc = document.createElement('div');
      cc.className = 'count';
      const cell = document.createElement('div');
      cell.className = 'cell' + ((snap.countsHighlight===idx) ? ' highlight' : '');
      cell.textContent = c;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = idx;
      cc.appendChild(cell);
      cc.appendChild(label);
      countsArea.appendChild(cc);
    });

    // Output
    outputBars.innerHTML = '';
    (snap.output || Array((A||[]).length).fill(null)).forEach((v,idx)=>{
      const o = document.createElement('div');
      o.className = 'outbar';
      const cell = document.createElement('div');
      cell.className = 'cell' + ((v!==null && v!==undefined) ? ' filled' : '');
      if(snap.placedPos === idx && snap.phase==='placing'){
        // highlight recently placed
        cell.style.boxShadow = '0 8px 22px rgba(124,58,237,0.12)';
        cell.style.transform = 'translateY(-6px)';
      }
      cell.textContent = (v!==null && v!==undefined) ? v : '';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = idx;
      o.appendChild(cell);
      o.appendChild(label);
      outputBars.appendChild(o);
    });

    // Update info texts
    let title = '';
    let detail = '';
    switch(snap.phase){
      case 'init':
        title = 'Initialized';
        detail = 'Counts initialized to zeros. Ready to begin.';
        break;
      case 'counting':
        title = `Counting: processed index ${snap.processedIndex}`;
        detail = `Read A[${snap.processedIndex}] = ${snap.readValue}. Increment counts[${snap.readValue}] → ${snap.counts[snap.readValue]}.`;
        break;
      case 'cumulative':
        title = `Cumulative: updating index ${snap.countsHighlight}`;
        detail = `Set counts[${snap.countsHighlight}] = counts[${snap.countsHighlight}] + counts[${snap.countsHighlight-1}] → ${snap.counts[snap.countsHighlight]}`;
        break;
      case 'placing':
        title = `Placing element from A[${snap.processedIndex}]`;
        detail = snap.placementStable ? `Stable placement: out[${snap.placedPos}] = ${snap.readValue} (decremented position)` : `Unstable: placed ${snap.readValue} at out[${snap.placedPos}]`;
        break;
      case 'placing-loop':
        title = `Placing values for v=${snap.placingValue}`;
        detail = `Filling ${snap.remaining} copies of ${snap.placingValue} into next positions starting at index ${snap.nextPos}.`;
        break;
      case 'done':
        title = 'Finished';
        detail = 'Sorting complete. Output is fully filled.';
        break;
      default:
        title = snap.phase || 'Step';
        detail = snap.info || '';
    }
    stepTitle.textContent = title;
    stepDetail.textContent = detail;

    lenInfo.textContent = A.length;
    kInfo.textContent = k;
  }

  // Snapshot builder
  function buildSnapshots(arr, maxK, stable){
    const snaps = [];
    const n = arr.length;
    const Acopy = copyArr(arr);
    let counts = Array(maxK+1).fill(0);

    // initial
    snaps.push({
      phase:'init',
      input: copyArr(Acopy),
      counts: copyArr(counts),
      countsHighlight: null,
      processedIndex: null,
      output: Array(n).fill(null)
    });

    // Counting phase
    for(let i=0;i<n;i++){
      const v = Acopy[i];
      if(v<0 || v>maxK || !Number.isInteger(v)){
        // invalid value - create a special snapshot and abort
        snaps.push({
          phase:'error',
          input: copyArr(Acopy),
          counts: copyArr(counts),
          info: `Value ${v} out of range 0..${maxK}`,
          processedIndex: i,
          output: Array(n).fill(null)
        });
        return snaps;
      }
      counts[v]++;
      snaps.push({
        phase:'counting',
        input: copyArr(Acopy),
        counts: copyArr(counts),
        countsHighlight: v,
        processedIndex: i,
        readValue: v,
        output: Array(n).fill(null)
      });
    }

    // Cumulative
    if(n>0){
      for(let i=1;i<=maxK;i++){
        counts[i] = counts[i] + counts[i-1];
        snaps.push({
          phase:'cumulative',
          input: copyArr(Acopy),
          counts: copyArr(counts),
          countsHighlight: i,
          processedIndex: null,
          output: Array(n).fill(null)
        });
      }
    }

    // Placement
    let output = Array(n).fill(null);
    if(stable){
      // stable: iterate i from n-1 downto 0, place at --counts[val]
      for(let i=n-1;i>=0;i--){
        const v = Acopy[i];
        counts[v] = counts[v] - 1;
        const pos = counts[v];
        output[pos] = v;
        snaps.push({
          phase:'placing',
          input: copyArr(Acopy),
          counts: copyArr(counts),
          processedIndex: i,
          readValue: v,
          placedPos: pos,
          placementStable: true,
          output: copyArr(output)
        });
      }
    } else {
      // unstable: iterate values 0..k, place countsOriginal[v] times sequentially
      // But counts currently are cumulative; convert to original counts
      // To avoid losing original counts, reconstruct from cumulative: originalCount[v] = counts[v] - counts[v-1] (with counts[-1]=0)
      const origCounts = Array(maxK+1).fill(0);
      for(let v=0;v<=maxK;v++){
        origCounts[v] = counts[v] - (v>0?counts[v-1]:0);
      }
      let nextPos = 0;
      for(let v=0;v<=maxK;v++){
        let times = origCounts[v];
        for(let t=0;t<times;t++){
          output[nextPos] = v;
          snaps.push({
            phase:'placing-loop',
            input: copyArr(Acopy),
            counts: copyArr(counts),
            placingValue: v,
            remaining: times - t - 1,
            nextPos: nextPos,
            placedPos: nextPos,
            output: copyArr(output)
          });
          nextPos++;
        }
      }
    }

    snaps.push({
      phase:'done',
      input: copyArr(Acopy),
      counts: copyArr(counts),
      countsHighlight: null,
      processedIndex: null,
      output: copyArr(output)
    });

    return snaps;
  }

  // Playback controls
  function goto(idx){
    idx = clamp(idx, 0, snapshots.length-1);
    current = idx;
    renderArraysFromSnapshot(snapshots[current]);
  }

  function play(){
    if(!snapshots || snapshots.length===0) return;
    if(playing) return;
    playing = true;
    const step = ()=>{
      if(!playing) return;
      if(current < snapshots.length-1){
        current++;
        renderArraysFromSnapshot(snapshots[current]);
        timer = setTimeout(step, speed);
      } else {
        playing = false;
      }
    };
    // if at end, go to start
    if(current >= snapshots.length-1){
      current = -1;
    }
    step();
  }

  function pause(){
    playing = false;
    if(timer) clearTimeout(timer);
    timer = null;
  }

  function stepForward(){
    pause();
    if(current < snapshots.length-1){
      current++;
      renderArraysFromSnapshot(snapshots[current]);
    }
  }

  function stepBackward(){
    pause();
    if(current > 0){
      current--;
      renderArraysFromSnapshot(snapshots[current]);
    }
  }

  function reset(){
    pause();
    snapshots = buildSnapshots(A,k,stableChk.checked);
    current = 0;
    renderArraysFromSnapshot(snapshots[0]);
  }

  // Events
  setArrBtn.addEventListener('click', ()=>{
    const raw = arrayInput.value.trim();
    if(!raw){
      alert('Please enter a comma-separated list of integers.');
      return;
    }
    const parts = raw.split(',').map(s=>s.trim()).filter(s=>s.length>0);
    const parsed = [];
    for(let p of parts){
      const num = Number(p);
      if(!Number.isFinite(num) || !Number.isInteger(num)){
        alert('All values must be integers. Found: ' + p);
        return;
      }
      parsed.push(num);
    }
    A = parsed;
    k = parseInt(maxValInput.value,10) || Math.max(...A,0);
    if(k < Math.max(...A)) {
      if(!confirm(`Given max k=${k} is smaller than some array values (max in array = ${Math.max(...A)}). Increase k to ${Math.max(...A)}?`)){
        return;
      } else {
        k = Math.max(...A);
        maxValInput.value = k;
      }
    }
    snapshots = buildSnapshots(A,k,stableChk.checked);
    current = 0;
    renderArraysFromSnapshot(snapshots[0]);
  });

  randArrBtn.addEventListener('click', ()=>{
    const maxk = parseInt(maxValInput.value,10) || 6;
    const size = Math.min(28, Math.max(3, Math.floor(5 + Math.random()*12)));
    A = Array.from({length:size}, ()=> Math.floor(Math.random()*(maxk+1)));
    arrayInput.value = A.join(',');
    snapshots = buildSnapshots(A,maxk,stableChk.checked);
    current = 0;
    k = maxk;
    renderArraysFromSnapshot(snapshots[0]);
  });

  playBtn.addEventListener('click', ()=>{
    if(!snapshots || snapshots.length===0){
      snapshots = buildSnapshots(A,k,stableChk.checked);
      current = 0;
      renderArraysFromSnapshot(snapshots[0]);
    }
    play();
  });

  pauseBtn.addEventListener('click', ()=>{
    pause();
  });

  stepF.addEventListener('click', stepForward);
  stepB.addEventListener('click', stepBackward);
  resetBtn.addEventListener('click', ()=>{
    // clear everything
    pause();
    A = [];
    arrayInput.value = '';
    snapshots = [];
    current = 0;
    inputBars.innerHTML = '';
    countsArea.innerHTML = '';
    outputBars.innerHTML = '';
    stepTitle.textContent = 'Idle';
    stepDetail.textContent = 'No steps yet. Configure array and press Play.';
    lenInfo.textContent = '0';
    kInfo.textContent = maxValInput.value;
  });

  speedInput.addEventListener('input', ()=>{
    speed = parseInt(speedInput.value,10);
  });

  maxValInput.addEventListener('change', ()=>{
    k = parseInt(maxValInput.value,10) || 0;
    k = Math.max(0,k);
    maxValInput.value = k;
  });

  stableChk.addEventListener('change', ()=>{
    // rebuild with new stable option
    if(A.length>0){
      snapshots = buildSnapshots(A,k,stableChk.checked);
      current = 0;
      renderArraysFromSnapshot(snapshots[0]);
    }
  });

  // Initialize with sample
  A = [3,6,4,1,3,4,1,4];
  arrayInput.value = A.join(',');
  k = 6;
  maxValInput.value = k;
  snapshots = buildSnapshots(A,k,stableChk.checked);
  renderArraysFromSnapshot(snapshots[0]);

  // Keyboard shortcuts
  window.addEventListener('keydown',(e)=>{
    if(e.key===' '){
      e.preventDefault();
      if(playing) pause(); else play();
    } else if(e.key === 'ArrowRight'){
      stepForward();
    } else if(e.key === 'ArrowLeft'){
      stepBackward();
    }
  });

})();
</script>
</body>
</html>