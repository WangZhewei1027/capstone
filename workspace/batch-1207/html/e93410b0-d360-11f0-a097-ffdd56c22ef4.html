<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Binary Search Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --good:#16a34a;
      --bad:#ef4444;
      --box:#0b1b2b;
      --box-border:#123;
      --text:#e6eef8;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071129 0%, #07121a 100%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    .wrap{max-width:1100px;margin:22px auto;padding:20px;color:var(--text);}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    h1{font-size:20px;margin:0}
    p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:16px}
    .card{background:linear-gradient(180deg,var(--panel),#071426);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    .control-group{display:flex;flex-direction:column;gap:8px;min-width:180px}
    label{font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px;align-items:center}
    button{background:linear-gradient(180deg,#0b2b4a,#052040);color:var(--text);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer}
    button:active{transform:translateY(1px)}
    .secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    input[type=number], input[type=text], select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#031827;color:var(--text);width:100%}
    main{display:grid;grid-template-columns:1fr 360px;gap:14px}
    .viz{min-height:240px;padding:14px}
    .array{display:flex;gap:8px;align-items:end;padding:8px;flex-wrap:wrap}
    .cell{width:48px;height:48px;border-radius:6px;background:var(--box);border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;flex-direction:column;color:var(--text);position:relative}
    .cell .val{font-weight:600}
    .cell .idx{font-size:11px;color:var(--muted);position:absolute;top:4px;left:6px}
    .low{box-shadow:0 0 0 3px rgba(96,165,250,0.06), inset 0 -4px 12px rgba(96,165,250,0.06);border-color:rgba(96,165,250,0.25)}
    .high{box-shadow:0 0 0 3px rgba(96,165,250,0.06), inset 0 4px 12px rgba(96,165,250,0.04);border-color:rgba(96,165,250,0.25)}
    .mid{background:linear-gradient(180deg,#063153,#084b67);border:1px solid rgba(96,165,250,0.12);box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    .found{background:linear-gradient(180deg,#0b6b3a,#0c5d34);border:1px solid rgba(16,185,129,0.12);box-shadow:0 6px 18px rgba(16,185,129,0.06)}
    .notfound{background:linear-gradient(180deg,#5a1212,#3d0d0d);border:1px solid rgba(239,68,68,0.12)}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;font-size:13px}
    .legend .item{display:flex;align-items:center;gap:6px}
    .swatch{width:12px;height:12px;border-radius:3px}
    .panel-right{display:flex;flex-direction:column;gap:12px}
    .info{font-size:13px;color:var(--muted);line-height:1.4}
    .status{padding:10px;border-radius:8px;background:linear-gradient(180deg,#021726,#071b2b);border:1px solid rgba(255,255,255,0.02);font-size:14px}
    .pseudocode{background:#02111b;padding:12px;border-radius:8px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono",monospace;font-size:13px;line-height:1.5;white-space:pre}
    .pc-line{padding:2px 6px;border-radius:6px}
    .pc-active{background:rgba(96,165,250,0.08);color:var(--text);box-shadow:inset 0 -4px 10px rgba(96,165,250,0.03)}
    footer{margin-top:16px;color:var(--muted);font-size:13px}
    @media(max-width:900px){
      main{grid-template-columns:1fr; }
      .cell{width:44px;height:44px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Binary Search Visualizer</h1>
        <p class="lead">See how binary search locates a value in a sorted array (or reports it's not present). Step, auto-play, and inspect each comparison.</p>
      </div>
      <div style="text-align:right;color:var(--muted);font-size:13px">
        Algorithm: O(log n) time — works only on sorted arrays
      </div>
    </header>

    <div class="controls card row">
      <div class="control-group" style="min-width:260px">
        <label>Array size: <span id="sizeLabel">12</span></label>
        <input id="size" type="range" min="5" max="30" value="12">
        <div style="display:flex;gap:8px">
          <button id="generate">Generate Sorted Array</button>
          <button id="shuffle" class="secondary" title="Show unsorted array (visual only)">Shuffle</button>
        </div>
      </div>

      <div class="control-group" style="min-width:220px">
        <label>Target value</label>
        <div style="display:flex;gap:8px">
          <input id="target" type="text" placeholder="number or 'random'">
          <button id="pickRandom" class="secondary">Pick random</button>
        </div>
        <div style="font-size:12px;color:var(--muted);margin-top:6px">Tip: leave target blank and press Pick random to pick a value from the array.</div>
      </div>

      <div class="control-group" style="min-width:220px">
        <label>Playback</label>
        <div style="display:flex;gap:8px">
          <button id="stepBack" class="secondary">◀ Step</button>
          <button id="step" >Step ▶</button>
          <button id="auto" class="secondary">Auto ▶</button>
          <button id="pause" class="secondary">Pause ■</button>
          <button id="reset" class="secondary">Reset</button>
        </div>
        <label style="margin-top:6px">Speed (ms per step): <span id="speedLabel">600</span></label>
        <input id="speed" type="range" min="80" max="2000" step="10" value="600">
      </div>
    </div>

    <main>
      <section class="viz card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <div style="font-weight:700">Array</div>
          <div style="display:flex;gap:12px;align-items:center">
            <div class="legend">
              <div class="item"><span class="swatch" style="background:linear-gradient(180deg,#063153,#084b67)"></span> mid</div>
              <div class="item"><span class="swatch" style="background:linear-gradient(180deg,#0b6b3a,#0c5d34)"></span> found</div>
              <div class="item"><span class="swatch" style="background:linear-gradient(180deg,#5a1212,#3d0d0d)"></span> not found</div>
              <div class="item"><span class="swatch" style="background:var(--box)"></span> others</div>
            </div>
          </div>
        </div>

        <div id="arrayArea" class="array" aria-live="polite"></div>

        <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
          <div class="status card" style="flex:1">
            <div id="statusMsg">Press "Generate Sorted Array" to begin.</div>
            <div style="margin-top:8px;font-size:13px;color:var(--muted)"><strong>low</strong>: <span id="lowIdx">-</span> &nbsp; <strong>mid</strong>: <span id="midIdx">-</span> &nbsp; <strong>high</strong>: <span id="highIdx">-</span> &nbsp; <strong>steps</strong>: <span id="stepsCount">0</span></div>
          </div>

          <div style="min-width:200px">
            <label style="font-size:13px;color:var(--muted)">Result</label>
            <div id="result" class="card" style="padding:10px;font-weight:700;text-align:center">—</div>
          </div>
        </div>
      </section>

      <aside class="panel-right">
        <div class="card">
          <div style="font-weight:700;margin-bottom:8px">Pseudocode (iterative)</div>
          <div id="pseudocode" class="pseudocode">
            <div id="pc0" class="pc-line">low = 0</div>
            <div id="pc1" class="pc-line">high = n - 1</div>
            <div id="pc2" class="pc-line">while low <= high:</div>
            <div id="pc3" class="pc-line">  mid = floor((low + high) / 2)</div>
            <div id="pc4" class="pc-line">  if A[mid] == target: return mid</div>
            <div id="pc5" class="pc-line">  else if A[mid] < target: low = mid + 1</div>
            <div id="pc6" class="pc-line">  else: high = mid - 1</div>
            <div id="pc7" class="pc-line">return -1</div>
          </div>
        </div>

        <div class="card info">
          <strong>How it works</strong>
          <p style="margin:8px 0;color:var(--muted)">Binary search repeatedly halves the search interval. Compare the target to the middle element; if equal, you're done. If the target is less, continue on the left half; otherwise, continue on the right half.</p>
          <strong>Complexity</strong>
          <p style="margin:6px 0;color:var(--muted)">Time: O(log n), Space: O(1) iterative (O(log n) call stack if recursive).</p>
        </div>

        <div class="card">
          <div style="font-weight:700;margin-bottom:8px">Controls & tips</div>
          <div style="color:var(--muted);font-size:13px;line-height:1.4">
            - Use "Generate" to create a sorted ascending array. <br>
            - "Shuffle" shows the same numbers unsorted — binary search requires a sorted array to work correctly. <br>
            - Choose a target value or pick random. Step through comparisons to see how low, mid, and high change.
          </div>
        </div>
      </aside>
    </main>

    <footer>
      Interactive demo — implementation uses a precomputed step list so you can freely step backward and forward. Try different array sizes and targets.
    </footer>
  </div>

  <script>
    // Utilities
    const el = id => document.getElementById(id);
    const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

    // State
    let array = [];
    let displayedArray = []; // may be shuffled for visual only
    let steps = []; // list of step states produced by algorithm
    let cur = -1;
    let autoTimer = null;

    // DOM
    const sizeEl = el('size');
    const sizeLabel = el('sizeLabel');
    const generateBtn = el('generate');
    const shuffleBtn = el('shuffle');
    const arrayArea = el('arrayArea');
    const targetEl = el('target');
    const pickRandomBtn = el('pickRandom');
    const stepBtn = el('step');
    const stepBackBtn = el('stepBack');
    const autoBtn = el('auto');
    const pauseBtn = el('pause');
    const resetBtn = el('reset');
    const speedEl = el('speed');
    const speedLabel = el('speedLabel');
    const lowIdxEl = el('lowIdx'), midIdxEl = el('midIdx'), highIdxEl = el('highIdx'), stepsCountEl = el('stepsCount');
    const statusMsg = el('statusMsg');
    const resultEl = el('result');

    // Pseudocode lines
    const pc = [];
    for(let i=0;i<8;i++) pc[i]=el('pc'+i);

    // Init labels
    sizeLabel.textContent = sizeEl.value;
    speedLabel.textContent = speedEl.value;

    // Generate ascending sorted array
    function genSorted(n){
      const arr = [];
      let cur = randInt(1,8);
      for(let i=0;i<n;i++){
        cur += randInt(1,8);
        arr.push(cur);
      }
      return arr;
    }

    // Render displayedArray
    function renderArray(stateIdx = -1){
      arrayArea.innerHTML = '';
      const curState = (stateIdx>=0 && stateIdx<steps.length) ? steps[stateIdx] : null;
      for(let i=0;i<displayedArray.length;i++){
        const v = displayedArray[i];
        const cell = document.createElement('div');
        cell.className = 'cell';
        const idx = document.createElement('div'); idx.className = 'idx'; idx.textContent = i;
        const val = document.createElement('div'); val.className = 'val'; val.textContent = v;
        cell.appendChild(idx);
        cell.appendChild(val);

        if(curState){
          const {low, high, mid, type} = curState;
          if(type === 'found' && mid === i){
            cell.classList.add('found');
          } else if(type === 'notfound'){
            // emphasize nothing particular; keep cells normal
          } else {
            if(mid === i) cell.classList.add('mid');
            if(low === i) cell.classList.add('low');
            if(high === i) cell.classList.add('high');
          }
        }
        arrayArea.appendChild(cell);
      }
    }

    // Build steps from binary search algorithm (iterative)
    function buildSteps(arr, target){
      steps = [];
      let low = 0, high = arr.length - 1, s = 0;
      steps.push({type:'init', low, high, mid:null, steps:s, message:'Initialize low and high'});
      while(low <= high){
        const mid = Math.floor((low + high)/2);
        s++;
        steps.push({type:'compare', low, high, mid, steps:s, message:`Compare A[${mid}] = ${arr[mid]} with ${target}`});
        if(arr[mid] === target){
          steps.push({type:'found', low, high, mid, steps:s, message:`Found target at index ${mid}`});
          return;
        } else if(arr[mid] < target){
          low = mid + 1;
          steps.push({type:'updateLow', low, high, mid, steps:s, message:`Target > A[${mid}]; move low to ${low}`});
        } else {
          high = mid - 1;
          steps.push({type:'updateHigh', low, high, mid, steps:s, message:`Target < A[${mid}]; move high to ${high}`});
        }
      }
      steps.push({type:'notfound', low, high, mid:null, steps:s, message:'Target not in array'});
    }

    // Update UI according to current step index
    function updateUI(){
      // clamp
      if(cur < 0) cur = -1;
      if(cur > steps.length - 1) cur = steps.length - 1;
      const st = (cur >= 0 && cur < steps.length) ? steps[cur] : null;

      // pseudocode highlighting
      pc.forEach(p => p.classList.remove('pc-active'));
      if(!st){
        pc[0].classList.add('pc-active');
        statusMsg.textContent = 'Press Step or Auto to start the search.';
        lowIdxEl.textContent = '-'; midIdxEl.textContent = '-'; highIdxEl.textContent = '-';
        stepsCountEl.textContent = '0';
        resultEl.textContent = '—';
      } else {
        // set active pc line based on step type
        switch(st.type){
          case 'init':
            pc[0].classList.add('pc-active'); pc[1].classList.add('pc-active');
            break;
          case 'compare':
            pc[2].classList.add('pc-active'); pc[3].classList.add('pc-active');
            break;
          case 'found':
            pc[4].classList.add('pc-active');
            break;
          case 'updateLow':
            pc[5].classList.add('pc-active');
            break;
          case 'updateHigh':
            pc[6].classList.add('pc-active');
            break;
          case 'notfound':
            pc[7].classList.add('pc-active');
            break;
        }

        statusMsg.textContent = st.message;
        lowIdxEl.textContent = (st.low !== null && st.low !== undefined) ? st.low : '-';
        midIdxEl.textContent = (st.mid !== null && st.mid !== undefined) ? st.mid : '-';
        highIdxEl.textContent = (st.high !== null && st.high !== undefined) ? st.high : '-';
        stepsCountEl.textContent = st.steps;
        if(st.type === 'found'){
          resultEl.textContent = `Found at index ${st.mid}`;
          resultEl.style.background = 'linear-gradient(180deg,#062b14,#063a2b)';
        } else if(st.type === 'notfound' && cur === steps.length-1){
          resultEl.textContent = 'Not found';
          resultEl.style.background = 'linear-gradient(180deg,#3c1010,#4a0f0f)';
        } else {
          resultEl.textContent = '—';
          resultEl.style.background = '';
        }
      }

      renderArray(cur);
    }

    // Public actions
    function generate(){
      const n = parseInt(sizeEl.value,10);
      array = genSorted(n);
      displayedArray = array.slice();
      buildFromInputs();
      cur = -1;
      buildStepsForCurrentTargetIfPossible();
      updateUI();
    }

    function buildFromInputs(){
      sizeLabel.textContent = sizeEl.value;
    }

    function buildStepsForCurrentTargetIfPossible(){
      // try to parse target
      let targetRaw = targetEl.value.trim();
      let t;
      if(targetRaw === '' || targetRaw.toLowerCase() === 'random'){
        // pick a random value from array
        if(array.length === 0) { steps = []; return; }
        const idx = randInt(0,array.length-1);
        t = array[idx];
        targetEl.value = t;
      } else {
        // try parse number
        const num = Number(targetRaw);
        if(Number.isFinite(num)) t = num;
        else {
          // if not parseable, don't build steps
          steps = [];
          statusMsg.textContent = 'Enter a numeric target or "random".';
          return;
        }
      }
      buildSteps(array, t);
    }

    // Step controls
    function stepForward(){
      if(steps.length === 0) { statusMsg.textContent = 'No steps available. Generate array and choose a target.'; return; }
      if(cur < steps.length - 1){
        cur++;
        updateUI();
      }
    }
    function stepBackward(){
      if(cur > 0){
        cur--;
      } else {
        cur = -1;
      }
      updateUI();
    }
    function autoPlay(){
      if(autoTimer) return;
      if(steps.length === 0){ statusMsg.textContent = 'No steps to play. Generate and set target.'; return; }
      autoTimer = setInterval(()=>{
        if(cur >= steps.length - 1){
          clearInterval(autoTimer);
          autoTimer = null;
          return;
        }
        cur++;
        updateUI();
      }, parseInt(speedEl.value,10));
    }
    function pauseAuto(){
      if(autoTimer){
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }
    function reset(){
      pauseAuto();
      cur = -1;
      updateUI();
    }

    // Shuffle display (visual only)
    function shuffleDisplay(){
      displayedArray = array.slice();
      for(let i=displayedArray.length-1;i>0;i--){
        const j = randInt(0,i);
        [displayedArray[i], displayedArray[j]] = [displayedArray[j], displayedArray[i]];
      }
      cur = -1;
      steps = []; // binary search steps invalid now
      updateUI();
      statusMsg.textContent = 'Array visually shuffled — binary search requires sorted array.';
    }

    // Event listeners
    generateBtn.addEventListener('click', ()=>{
      pauseAuto();
      generate();
    });
    sizeEl.addEventListener('input', ()=>{
      sizeLabel.textContent = sizeEl.value;
    });
    shuffleBtn.addEventListener('click', ()=>{
      shuffleDisplay();
    });
    pickRandomBtn.addEventListener('click', ()=>{
      if(array.length === 0){ statusMsg.textContent = 'Generate an array first.'; return; }
      const idx = randInt(0,array.length-1);
      targetEl.value = array[idx];
    });
    stepBtn.addEventListener('click', ()=>{ pauseAuto(); if(steps.length===0) buildStepsForCurrentTargetIfPossible(); stepForward(); });
    stepBackBtn.addEventListener('click', ()=>{ pauseAuto(); stepBackward(); });
    autoBtn.addEventListener('click', ()=>{ pauseAuto(); if(steps.length===0) buildStepsForCurrentTargetIfPossible(); autoPlay(); });
    pauseBtn.addEventListener('click', ()=>{ pauseAuto(); });
    resetBtn.addEventListener('click', ()=>{ reset(); });
    speedEl.addEventListener('input', ()=>{ speedLabel.textContent = speedEl.value; if(autoTimer){ pauseAuto(); autoPlay(); } });

    // When target or array changes, rebuild steps
    targetEl.addEventListener('change', ()=>{
      pauseAuto();
      if(array.length === 0){ statusMsg.textContent = 'Generate an array first.'; return; }
      // Ensure displayedArray is sorted version of array to run binary search correctly
      displayedArray = array.slice();
      buildStepsForCurrentTargetIfPossible();
      cur = -1;
      updateUI();
    });

    // initialize with a generated array on load
    window.addEventListener('load', ()=>{
      generate();
    });

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key === ' ') { e.preventDefault(); stepForward(); }
      if(e.key === 'ArrowLeft') stepBackward();
      if(e.key === 'ArrowRight') stepForward();
      if(e.key === 'p') { if(autoTimer) pauseAuto(); else autoPlay(); }
    });
  </script>
</body>
</html>