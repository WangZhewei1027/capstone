<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Adjacency List — Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#f7f9fc;--panel:#ffffff;--muted:#6b7280;--accent:#2563eb;--accent-2:#1f2937}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--accent-2)}
  .app{display:grid;grid-template-columns:320px 1fr;gap:18px;padding:18px;height:100%}
  .panel{background:var(--panel);border-radius:10px;padding:14px;box-shadow:0 2px 8px rgba(16,24,40,0.06)}
  h2{margin:0 0 12px 0;font-size:16px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  input,select,button{font-size:13px;padding:8px;border-radius:8px;border:1px solid #e6e9ef;outline:none}
  .row{display:flex;gap:8px;margin-top:8px}
  .row input{flex:1}
  button{background:var(--accent);color:#fff;border:none;cursor:pointer}
  button.secondary{background:#fff;color:var(--accent);border:1px solid #dbeafe}
  button.ghost{background:transparent;color:var(--accent-2);border:1px dashed #e6e9ef}
  .small{padding:6px 8px;font-size:12px;border-radius:6px}
  #svgWrap{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
  svg{width:100%;height:100%}
  .adjList{margin-top:10px;max-height:220px;overflow:auto;font-family:monospace;background:#0f1724;color:#f8fafc;padding:10px;border-radius:8px}
  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .legend{display:flex;gap:8px;align-items:center;margin-top:10px;color:var(--muted);font-size:13px}
  .node-legend{width:12px;height:12px;border-radius:50%;background:var(--accent)}
  footer{margin-top:12px;color:var(--muted);font-size:12px}
  .nodeLabel{pointer-events:none;font-size:12px;fill:#fff;font-weight:600}
  .edgeWeight{pointer-events:none;font-size:12px;fill:var(--accent-2)}
  .highlight{stroke:#f59e0b;stroke-width:3px}
</style>
</head>
<body>
<div class="app">
  <div class="panel" style="display:flex;flex-direction:column;min-height:200px">
    <h2>Adjacency List — Controls</h2>

    <label>Graph type</label>
    <div class="row">
      <button id="toggleDir" class="small">Directed: OFF</button>
      <button id="clearBtn" class="small ghost">Clear</button>
    </div>

    <label style="margin-top:12px">Nodes</label>
    <div class="row">
      <input id="nodeName" placeholder="Label (auto if empty)" />
      <button id="addNodeBtn" class="small">Add Node</button>
    </div>

    <label>Edges</label>
    <div class="row">
      <select id="fromSelect"><option value="">--from--</option></select>
      <select id="toSelect"><option value="">--to--</option></select>
    </div>
    <div class="row">
      <input id="edgeWeight" placeholder="Weight (optional)" />
      <button id="addEdgeBtn" class="small">Add Edge</button>
    </div>

    <div class="controls-grid">
      <button id="randomBtn" class="small secondary">Random Graph</button>
      <button id="removeEdgeBtn" class="small secondary">Remove Edge</button>
      <button id="removeNodeBtn" class="small secondary">Remove Node</button>
      <button id="autoLayoutBtn" class="small secondary">Re-layout</button>
    </div>

    <label style="margin-top:12px">Traversals</label>
    <div class="row">
      <select id="startSelect"><option value="">--start--</option></select>
      <button id="bfsBtn" class="small">BFS</button>
      <button id="dfsBtn" class="small">DFS</button>
    </div>

    <div class="legend">
      <div class="node-legend"></div> Nodes &nbsp; • &nbsp; Edges drawn as lines (arrows show direction) &nbsp; • &nbsp; Click a node to highlight its adjacency
    </div>

    <div style="margin-top:auto">
      <h2 style="margin-top:12px">Adjacency List</h2>
      <pre id="adjList" class="adjList">(graph is empty)</pre>
      <footer>Representation: node → [ {to, weight} , ... ]</footer>
    </div>
  </div>

  <div class="panel" style="display:flex;flex-direction:column;min-height:200px">
    <h2>Graph Visualization</h2>
    <div id="svgWrap">
      <svg id="svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="#94a3b8" />
          </marker>
          <marker id="arrow-highlight" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L12,6 L0,12 z" fill="#1d4ed8" />
          </marker>
        </defs>
      </svg>
    </div>
  </div>
</div>

<script>
/* Adjacency List Interactive Demo
   - Add/Remove nodes & edges
   - Directed / Undirected toggle
   - Visualize graph & adjacency list
   - BFS / DFS animations
*/

const svg = document.getElementById('svg');
const adjListEl = document.getElementById('adjList');
const fromSelect = document.getElementById('fromSelect');
const toSelect = document.getElementById('toSelect');
const startSelect = document.getElementById('startSelect');
const nodeNameInput = document.getElementById('nodeName');
const edgeWeightInput = document.getElementById('edgeWeight');

let directed = false;
let nodeCounter = 0;
const nodes = []; // {id,label,x,y}
const edges = []; // {from,to,weight}
const adj = new Map(); // id -> [{to,weight},...]

// Utility
function uid() { return 'n' + (++nodeCounter); }

function addNode(label) {
  const id = uid();
  const nodeLabel = label && label.trim() ? label.trim() : id;
  nodes.push({id,label:nodeLabel,x:0,y:0});
  adj.set(id, []);
  layoutNodes();
  refreshUI();
  return id;
}

function removeNode(id){
  // remove from nodes array
  const idx = nodes.findIndex(n=>n.id===id);
  if(idx===-1) return;
  nodes.splice(idx,1);
  adj.delete(id);
  // remove edges referencing id
  for(let i=edges.length-1;i>=0;i--){
    if(edges[i].from===id || edges[i].to===id) edges.splice(i,1);
  }
  // also remove adjacency entries pointing to id
  for(const [k,list] of adj.entries()){
    adj.set(k, list.filter(e=>e.to!==id));
  }
  refreshUI();
}

function addEdge(from,to,weight){
  if(!from||!to) return;
  if(!adj.has(from) || !adj.has(to)) return;
  // prevent duplicate edges
  if(edges.some(e=>e.from===from && e.to===to && String(e.weight)===String(weight))) return;
  edges.push({from,to,weight});
  adj.get(from).push({to,weight});
  if(!directed){
    // undirected add symmetric
    if(!adj.get(to).some(e=>e.to===from && String(e.weight)===String(weight))){
      edges.push({from:to,to:from,weight});
      adj.get(to).push({to:from,weight});
    }
  }
  refreshUI();
}

function removeEdge(from,to){
  for(let i=edges.length-1;i>=0;i--){
    if(edges[i].from===from && edges[i].to===to) edges.splice(i,1);
  }
  if(adj.has(from)){
    adj.set(from, adj.get(from).filter(e=>e.to!==to));
  }
  if(!directed){
    for(let i=edges.length-1;i>=0;i--){
      if(edges[i].from===to && edges[i].to===from) edges.splice(i,1);
    }
    if(adj.has(to)){
      adj.set(to, adj.get(to).filter(e=>e.to!==from));
    }
  }
  refreshUI();
}

function clearGraph(){
  nodes.length = 0;
  edges.length = 0;
  adj.clear();
  nodeCounter = 0;
  refreshUI();
}

function layoutNodes(){
  // simple circular layout
  const R = 220;
  const cx = 400, cy = 280;
  const n = nodes.length;
  for(let i=0;i<n;i++){
    const a = (i/n) * Math.PI * 2 - Math.PI/2;
    nodes[i].x = cx + Math.cos(a) * R;
    nodes[i].y = cy + Math.sin(a) * R;
  }
}

function refreshUI(){
  // update selects
  [fromSelect,toSelect,startSelect].forEach(sel=>{
    const cur = sel.value;
    sel.innerHTML = '<option value="">--</option>';
    for(const node of nodes){
      const opt = document.createElement('option');
      opt.value = node.id; opt.textContent = node.label + ' ('+node.id+')';
      sel.appendChild(opt);
    }
    if(cur) sel.value = cur;
  });
  // adjacency map might be missing symmetric edges if toggle changed; recreate from edges
  // Rebuild adj from nodes & edges (preferred)
  adj.clear();
  for(const node of nodes) adj.set(node.id,[]);
  for(const e of edges){
    if(adj.has(e.from)) adj.get(e.from).push({to:e.to,weight:e.weight});
  }
  drawGraph();
  renderAdjList();
}

function drawGraph(highlightNodes = [], highlightEdges = []) {
  // highlightNodes: array of node ids, highlightEdges: [{from,to}]
  while(svg.lastChild) svg.removeChild(svg.lastChild);
  // re-add defs
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  defs.innerHTML = `
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="#94a3b8" />
    </marker>
    <marker id="arrow-highlight" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L12,6 L0,12 z" fill="#1d4ed8" />
    </marker>
  `;
  svg.appendChild(defs);

  // draw edges (z-order below nodes)
  const drawn = new Set();
  for(const e of edges){
    const key = e.from+'->'+e.to;
    // For undirected graphs we have symmetric edges; avoid drawing duplicate (draw only when from id < to id)
    if(!directed){
      const mirrorKey = e.to+'->'+e.from;
      if(drawn.has(mirrorKey)) continue;
      drawn.add(key);
    }

    const from = nodes.find(n=>n.id===e.from);
    const to = nodes.find(n=>n.id===e.to);
    if(!from || !to) continue;

    // if self-loop
    if(from.id === to.id){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      const loop = document.createElementNS('http://www.w3.org/2000/svg','path');
      const r = 26;
      const x = from.x, y=from.y;
      loop.setAttribute('d', `M ${x} ${y-r} C ${x-60} ${y-r-60} ${x+60} ${y-r-60} ${x} ${y-r}`);
      loop.setAttribute('stroke', highlightEdges.some(h=>h.from===from.id && h.to===to.id) ? '#1d4ed8' : '#94a3b8');
      loop.setAttribute('fill','none');
      loop.setAttribute('stroke-width','2');
      loop.setAttribute('marker-end', directed ? 'url(#arrow)' : '');
      g.appendChild(loop);
      // label
      if(e.weight !== undefined && e.weight !== null && e.weight!==''){
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', x+6);
        text.setAttribute('y', y - r - 8);
        text.setAttribute('class','edgeWeight');
        text.textContent = e.weight;
        g.appendChild(text);
      }
      svg.appendChild(g);
      continue;
    }

    // draw a straight line; for aesthetics offset for parallel edges in undirected (small offset)
    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.hypot(dx,dy);
    const nx = dx/len, ny = dy/len;
    const pad = 22; // node radius
    const sx = from.x + nx*pad, sy = from.y + ny*pad;
    const tx = to.x - nx*pad, ty = to.y - ny*pad;

    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',sx); line.setAttribute('y1',sy);
    line.setAttribute('x2',tx); line.setAttribute('y2',ty);
    const isHighlighted = highlightEdges.some(h=>h.from===e.from && h.to===e.to)
                         || (!directed && (highlightEdges.some(h=>h.from===e.to && h.to===e.from)));
    line.setAttribute('stroke', isHighlighted ? '#1d4ed8' : '#94a3b8');
    line.setAttribute('stroke-width', isHighlighted ? 3 : 2);
    if(directed){
      line.setAttribute('marker-end', isHighlighted ? 'url(#arrow-highlight)' : 'url(#arrow)');
    }
    svg.appendChild(line);

    // edge weight label at midpoint
    if(e.weight !== undefined && e.weight !== null && e.weight!==''){
      const mx = (sx+tx)/2, my = (sy+ty)/2;
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', mx + (-ny)*10);
      text.setAttribute('y', my + (nx)*10);
      text.setAttribute('class','edgeWeight');
      text.textContent = e.weight;
      svg.appendChild(text);
    }
  }

  // draw nodes
  for(const node of nodes){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.style.cursor = 'pointer';

    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('r',22);
    const isNodeHighlighted = highlightNodes.includes(node.id);
    circ.setAttribute('fill', isNodeHighlighted ? '#1d4ed8' : '#2563eb');
    circ.setAttribute('stroke', isNodeHighlighted ? '#f59e0b' : '#0b1220');
    circ.setAttribute('stroke-width', isNodeHighlighted ? 3 : 0);
    circ.setAttribute('data-id', node.id);
    g.appendChild(circ);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('class','nodeLabel');
    text.setAttribute('x',0); text.setAttribute('y',6);
    text.setAttribute('text-anchor','middle');
    text.textContent = node.label;
    g.appendChild(text);

    // interaction
    g.addEventListener('click',(ev)=>{
      ev.stopPropagation();
      onNodeClick(node.id);
    });
    svg.appendChild(g);
  }
}

function renderAdjList(){
  if(nodes.length===0){
    adjListEl.textContent = '(graph is empty)';
    return;
  }
  let out = '';
  for(const node of nodes){
    const list = adj.get(node.id) || [];
    const entries = list.map(e=> `{to:${e.to}${e.weight!=='' && e.weight!==undefined && e.weight!==null ? ', w:'+JSON.stringify(e.weight):''}}`);
    out += `${node.id} (${node.label}) -> [ ${entries.join(', ')} ]\n`;
  }
  adjListEl.textContent = out;
}

// node click -> highlight adjacency
function onNodeClick(id){
  const list = adj.get(id) || [];
  const outs = list.map(e=>e.to);
  const highlightsEdges = list.map(e=>({from:id,to:e.to}));
  drawGraph([id, ...outs], highlightsEdges);
}

// Traversals
async function animateSequence(seq){
  for(const id of seq){
    drawGraph([id], []);
    await new Promise(r=>setTimeout(r,650));
  }
  // flash all
  drawGraph([],[]);
}

function bfs(start){
  if(!start) return [];
  const q = [start];
  const seen = new Set([start]);
  const order = [];
  while(q.length){
    const u = q.shift(); order.push(u);
    for(const e of (adj.get(u)||[])){
      if(!seen.has(e.to)){
        seen.add(e.to);
        q.push(e.to);
      }
    }
  }
  return order;
}

function dfs(start){
  if(!start) return [];
  const seen = new Set();
  const order = [];
  function visit(u){
    seen.add(u); order.push(u);
    for(const e of (adj.get(u)||[])){
      if(!seen.has(e.to)) visit(e.to);
    }
  }
  visit(start);
  return order;
}

// UI wiring
document.getElementById('addNodeBtn').addEventListener('click', ()=>{
  addNode(nodeNameInput.value);
  nodeNameInput.value='';
});

document.getElementById('addEdgeBtn').addEventListener('click', ()=>{
  const f = fromSelect.value, t = toSelect.value;
  if(!f || !t){ alert('Choose both endpoints'); return; }
  addEdge(f,t,edgeWeightInput.value.trim());
  edgeWeightInput.value='';
});

document.getElementById('removeEdgeBtn').addEventListener('click', ()=>{
  const f = fromSelect.value, t = toSelect.value;
  if(!f || !t){ alert('Choose both endpoints'); return; }
  removeEdge(f,t);
});

document.getElementById('removeNodeBtn').addEventListener('click', ()=>{
  const id = fromSelect.value || toSelect.value || startSelect.value;
  if(!id){ alert('Choose a node to remove'); return; }
  if(!confirm('Remove node ' + id + ' and all incident edges?')) return;
  removeNode(id);
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  if(!confirm('Clear the entire graph?')) return;
  clearGraph();
});

document.getElementById('toggleDir').addEventListener('click', ()=>{
  directed = !directed;
  document.getElementById('toggleDir').textContent = 'Directed: ' + (directed ? 'ON' : 'OFF');
  // When switching from directed to undirected, ensure symmetric edges exist
  if(!directed){
    // create symmetric pairs
    const newEdges = [];
    for(const e of edges){
      newEdges.push({...e});
      const existsMirror = edges.some(x=>x.from===e.to && x.to===e.from && String(x.weight)===String(e.weight));
      if(!existsMirror){
        newEdges.push({from:e.to,to:e.from,weight:e.weight});
      }
    }
    edges.length = 0;
    for(const e of newEdges) edges.push(e);
  } else {
    // if switching to directed, we keep existing edges as-is (may include both directions)
  }
  refreshUI();
});

document.getElementById('randomBtn').addEventListener('click', ()=>{
  // small random graph
  clearGraph();
  const N = Math.floor(Math.random()*5)+4;
  const ids = [];
  for(let i=0;i<N;i++) ids.push(addNode(('v'+(i+1))));
  const M = Math.floor(Math.random()*(N*(N-1)/2))+N;
  for(let i=0;i<M;i++){
    const a = ids[Math.floor(Math.random()*ids.length)];
    const b = ids[Math.floor(Math.random()*ids.length)];
    if(a===b) continue;
    addEdge(a,b, Math.random()<0.6 ? Math.floor(Math.random()*10) : '');
  }
  layoutNodes();
  refreshUI();
});

document.getElementById('autoLayoutBtn').addEventListener('click', ()=>{
  layoutNodes();
  refreshUI();
});

document.getElementById('bfsBtn').addEventListener('click', async ()=>{
  const s = startSelect.value;
  if(!s){ alert('Choose a start node'); return; }
  const order = bfs(s);
  await animateSequence(order);
});

document.getElementById('dfsBtn').addEventListener('click', async ()=>{
  const s = startSelect.value;
  if(!s){ alert('Choose a start node'); return; }
  const order = dfs(s);
  await animateSequence(order);
});

// click background to reset drawing
svg.addEventListener('click', ()=>drawGraph([],[]));

// initialize with example graph
(function seed(){
  addNode('A'); addNode('B'); addNode('C'); addNode('D'); addNode('E');
  const ids = nodes.map(n=>n.id);
  addEdge(ids[0], ids[1], 5);
  addEdge(ids[0], ids[2], '');
  addEdge(ids[1], ids[2], 3);
  addEdge(ids[2], ids[3], 1);
  addEdge(ids[3], ids[4], '');
  addEdge(ids[4], ids[0], 2);
  layoutNodes();
  refreshUI();
  drawGraph([],[]);
})();
</script>
</body>
</html>