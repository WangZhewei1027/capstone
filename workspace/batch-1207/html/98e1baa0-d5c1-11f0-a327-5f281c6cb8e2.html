<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Priority Queue (Binary Heap) Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #7dd3fc;
      --muted: #94a3b8;
      --card: #071026;
      --good: #10b981;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    body{
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin:0;
      background: linear-gradient(180deg, #071025 0%, #091226 100%);
      color:#e6eef7;
      min-height:100vh;
      padding:24px;
      box-sizing:border-box;
    }
    h1{ margin:0 0 6px 0; font-size:20px; }
    p.lead{ margin:4px 0 18px 0; color:var(--muted); font-size:13px; max-width:900px; }
    .layout{ display:flex; gap:20px; align-items:flex-start; flex-wrap:wrap; }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .controls{ width:360px; min-width:260px; }
    .visual{ flex:1; min-width:340px; max-width:1000px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-top:8px; }
    input[type="text"], input[type="number"], select {
      width:100%;
      padding:8px 10px;
      margin-top:6px;
      background:var(--glass);
      color:var(--accent);
      border:1px solid rgba(125,211,252,0.06);
      border-radius:8px;
      font-size:14px;
      box-sizing:border-box;
    }
    .row{ display:flex; gap:8px; margin-top:10px; align-items:center; }
    button {
      background: linear-gradient(180deg, rgba(125,211,252,0.12), rgba(125,211,252,0.06));
      color:var(--accent);
      border:1px solid rgba(125,211,252,0.09);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:500;
    }
    .muted{ color:var(--muted); font-size:13px; margin-top:8px; }
    .status{ margin-top:12px; font-size:13px; color:var(--muted); display:flex; gap:12px; flex-wrap:wrap; }
    .pill{
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
      color:var(--accent);
    }
    .arrayView{
      margin-top:12px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .item{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color:var(--accent);
      padding:6px 10px;
      border-radius:8px;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .heap-svg{
      width:100%;
      height:420px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      margin-top:12px;
      border:1px solid rgba(255,255,255,0.02);
      overflow:auto;
    }
    .explain{
      font-size:13px;
      color:var(--muted);
      margin-top:10px;
      line-height:1.45;
    }
    .legend{ margin-top:8px; font-size:13px; color:var(--muted); display:flex; gap:12px; flex-wrap:wrap; }
    .legend .dot{ width:12px; height:12px; border-radius:99px; display:inline-block; margin-right:6px; }
    .dot.node{ background:#0ea5e9; }
    .dot.swap{ background:#fb923c; }
    .infoBlock{ margin-top:10px; padding:10px; background:rgba(255,255,255,0.02); border-radius:8px; color:var(--muted); font-size:13px; }
    small.note{ color:var(--muted); display:block; margin-top:8px; font-size:12px; }
    footer{ margin-top:18px; color:var(--muted); font-size:13px; }
    @media (max-width:920px){
      .layout{ flex-direction:column; }
      .controls{ width:100%; }
    }
  </style>
</head>
<body>
  <h1>Priority Queue (Binary Heap) — Interactive Demo</h1>
  <p class="lead">This demo implements a priority queue using a binary heap. You can insert items with numeric priorities, remove the top-priority item, and visualize the heap as an array and as a binary tree. Toggle between min-heap (lower priority values come out first) and max-heap.</p>

  <div class="layout">
    <div class="card controls">
      <label>Heap Type
        <select id="heapType">
          <option value="min">Min-Heap (lowest priority first)</option>
          <option value="max">Max-Heap (highest priority first)</option>
        </select>
      </label>

      <label>Value (string)
        <input id="valInput" type="text" placeholder="example: task-A" value="task-A" />
      </label>

      <label>Priority (number)
        <input id="prioInput" type="number" placeholder="priority (e.g. 5)" value="5" />
      </label>

      <div class="row">
        <button id="enqueueBtn">Enqueue</button>
        <button class="secondary" id="dequeueBtn">Dequeue</button>
        <button class="secondary" id="peekBtn">Peek</button>
      </div>

      <div class="row">
        <button id="randomBtn">Add 10 Random</button>
        <button id="clearBtn" class="secondary">Clear</button>
        <button id="bulkBtn" class="secondary">Add N Items (fast)</button>
        <input id="bulkCount" type="number" value="10000" style="width:110px; margin-left:auto;" />
      </div>

      <div class="status">
        <div class="pill" id="sizePill">Size: 0</div>
        <div class="pill" id="topPill">Top: —</div>
        <div class="pill" id="opsPill">Ops: 0</div>
      </div>

      <div class="muted">Array representation (index -> value:priority)</div>
      <div class="arrayView card" id="arrayContainer" style="margin-top:8px;"></div>

      <div class="infoBlock">
        <strong>Notes</strong>
        <div class="explain">
          - Enqueue inserts an item with the given priority.<br/>
          - Dequeue removes and returns the highest-priority item (based on heap type).<br/>
          - The underlying structure is a binary heap stored in an array; parents/children positions are shown in the visualization.
        </div>
      </div>

      <small class="note">Stable ordering is preserved for equal priorities (insertion order).</small>
    </div>

    <div class="card visual">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <div>
          <strong>Heap Visualization</strong>
          <div class="legend">
            <div><span class="dot node"></span> Node</div>
            <div><span class="dot swap"></span> Recently swapped (brief highlight)</div>
          </div>
        </div>
        <div style="text-align:right" class="muted">
          <div id="timing">Last op time: — ms</div>
          <div id="lastAction">Last: —</div>
        </div>
      </div>

      <div id="svgWrap" class="heap-svg">
        <svg id="heapSvg" width="1200" height="420"></svg>
      </div>

      <div class="muted" style="margin-top:8px;">Console / trace</div>
      <div id="trace" class="card" style="margin-top:8px; font-size:13px; min-height:46px; max-height:160px; overflow:auto;"></div>

      <footer>
        Implementation: binary heap with stable ordering (uses insertion index to break ties). Try enqueueing many items and use "Add N Items (fast)" to benchmark.
      </footer>
    </div>
  </div>

  <script>
    // PriorityQueue implemented with binary heap stored in an array.
    // Each node { value, priority, idx } where idx is insertion index for stability.
    class PriorityQueue {
      constructor(type = 'min') {
        this.heap = [];
        this.type = type; // 'min' or 'max'
        this._counter = 0;
        this.opCount = 0;
      }

      setType(type) {
        if (type !== 'min' && type !== 'max') throw new Error('type must be "min" or "max"');
        this.type = type;
      }

      size() { return this.heap.length; }
      isEmpty() { return this.size() === 0; }

      _compare(a, b) {
        // return true if a has higher priority than b (i.e., a should come before b)
        if (a.priority !== b.priority) {
          return this.type === 'min' ? a.priority < b.priority : a.priority > b.priority;
        }
        // tie-breaker: insertion index (lower idx = earlier insertion, so earlier is higher priority)
        return a.idx < b.idx;
      }

      enqueue(value, priority) {
        const node = { value, priority: Number(priority), idx: this._counter++ };
        this.heap.push(node);
        this._bubbleUp(this.heap.length - 1);
        this.opCount++;
        return node;
      }

      peek() {
        return this.heap[0] || null;
      }

      dequeue() {
        const n = this.heap.length;
        if (n === 0) return null;
        if (n === 1) {
          this.opCount++;
          return this.heap.pop();
        }
        const top = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._sinkDown(0);
        this.opCount++;
        return top;
      }

      clear() {
        this.heap = [];
        this._counter = 0;
        this.opCount++;
      }

      // faster bulk add without animation: push all and heapify in O(n)
      bulkAdd(items) {
        // items: array of {value, priority}
        for (const it of items) {
          this.heap.push({ value: it.value, priority: Number(it.priority), idx: this._counter++ });
        }
        // heapify: from last parent down to 0
        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
          this._sinkDown(i, false);
        }
        this.opCount += items.length;
      }

      _bubbleUp(idx) {
        const heap = this.heap;
        let current = idx;
        while (current > 0) {
          const parent = Math.floor((current - 1) / 2);
          if (this._compare(heap[current], heap[parent])) {
            this._swap(current, parent);
            current = parent;
          } else break;
        }
      }

      _sinkDown(idx, allowSwapTrace = true) {
        const heap = this.heap;
        const n = heap.length;
        let current = idx;
        while (true) {
          const left = current * 2 + 1;
          const right = current * 2 + 2;
          let candidate = current;

          if (left < n && this._compare(heap[left], heap[candidate])) candidate = left;
          if (right < n && this._compare(heap[right], heap[candidate])) candidate = right;
          if (candidate !== current) {
            this._swap(current, candidate, allowSwapTrace);
            current = candidate;
          } else break;
        }
      }

      _swap(i, j, allowSwapTrace=true) {
        const h = this.heap;
        const tmp = h[i];
        h[i] = h[j];
        h[j] = tmp;
        // optional: could log swaps or visualize
      }

      toArray() {
        // return shallow copy for display
        return this.heap.map((n, i) => ({ i, value: n.value, priority: n.priority, idx: n.idx }));
      }
    }

    // ---------- UI & Visualization ----------
    const pq = new PriorityQueue('min');

    // UI elements
    const valInput = document.getElementById('valInput');
    const prioInput = document.getElementById('prioInput');
    const enqueueBtn = document.getElementById('enqueueBtn');
    const dequeueBtn = document.getElementById('dequeueBtn');
    const peekBtn = document.getElementById('peekBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const arrayContainer = document.getElementById('arrayContainer');
    const sizePill = document.getElementById('sizePill');
    const topPill = document.getElementById('topPill');
    const opsPill = document.getElementById('opsPill');
    const heapType = document.getElementById('heapType');
    const heapSvg = document.getElementById('heapSvg');
    const trace = document.getElementById('trace');
    const timing = document.getElementById('timing');
    const lastAction = document.getElementById('lastAction');
    const bulkBtn = document.getElementById('bulkBtn');
    const bulkCount = document.getElementById('bulkCount');

    function logTrace(msg, style='color:#9fbfe6') {
      const el = document.createElement('div');
      el.style.padding = '6px 8px';
      el.style.borderBottom = '1px solid rgba(255,255,255,0.02)';
      el.style.fontSize = '13px';
      el.innerHTML = `<span style="${style}">${msg}</span>`;
      trace.prepend(el);
    }

    function renderAll(highlightSwap = null) {
      // update pills and array view
      const arr = pq.toArray();
      sizePill.textContent = 'Size: ' + pq.size();
      opsPill.textContent = 'Ops: ' + pq.opCount;
      if (pq.peek()) topPill.textContent = `Top: ${pq.peek().value}:${pq.peek().priority}`;
      else topPill.textContent = 'Top: —';

      // array view
      arrayContainer.innerHTML = '';
      if (arr.length === 0) {
        arrayContainer.innerHTML = '<div class="muted" style="padding:10px">empty</div>';
      } else {
        for (const node of arr) {
          const div = document.createElement('div');
          div.className = 'item';
          div.textContent = `${node.i} → ${node.value}:${node.priority}`;
          arrayContainer.appendChild(div);
        }
      }

      // svg visualization
      renderHeapSvg(arr, highlightSwap);
    }

    function renderHeapSvg(nodes, highlightSwap) {
      const svg = heapSvg;
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const width = Math.max(600, svg.clientWidth || 800, 1200);
      const height = svg.clientHeight || 420;
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      if (nodes.length === 0) return;

      // compute positions per level
      const positions = [];
      const levels = Math.floor(Math.log2(nodes.length)) + 1;
      const levelHeight = Math.min(90, Math.max(60, Math.floor(height / (levels + 1))));
      for (let i = 0; i < nodes.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const levelStart = Math.pow(2, level) - 1;
        const posInLevel = i - levelStart;
        const itemsInLevel = Math.pow(2, level);
        const margin = 24;
        const usableWidth = width - margin * 2;
        const spacing = usableWidth / itemsInLevel;
        const x = margin + posInLevel * spacing + spacing / 2;
        const y = 18 + level * levelHeight;
        positions[i] = { x, y };
      }

      // draw lines
      for (let i = 0; i < nodes.length; i++) {
        const left = i * 2 + 1;
        const right = i * 2 + 2;
        const p = positions[i];
        if (left < nodes.length) {
          const c = positions[left];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y+12);
          line.setAttribute('x2', c.x); line.setAttribute('y2', c.y-12);
          line.setAttribute('stroke', 'rgba(255,255,255,0.04)');
          line.setAttribute('stroke-width', '1.2');
          svg.appendChild(line);
        }
        if (right < nodes.length) {
          const c = positions[right];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y+12);
          line.setAttribute('x2', c.x); line.setAttribute('y2', c.y-12);
          line.setAttribute('stroke', 'rgba(255,255,255,0.04)');
          line.setAttribute('stroke-width', '1.2');
          svg.appendChild(line);
        }
      }

      // draw nodes
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const pos = positions[i];
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');

        // circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('cx', pos.x);
        circle.setAttribute('cy', pos.y);
        circle.setAttribute('r', 20);
        circle.setAttribute('fill', (highlightSwap && (highlightSwap[0] === i || highlightSwap[1] === i)) ? '#fb923c' : '#0ea5e9');
        circle.setAttribute('opacity', '0.95');
        g.appendChild(circle);

        // text: value
        const text1 = document.createElementNS('http://www.w3.org/2000/svg','text');
        text1.setAttribute('x', pos.x);
        text1.setAttribute('y', pos.y - 2);
        text1.setAttribute('text-anchor', 'middle');
        text1.setAttribute('font-size', '11px');
        text1.setAttribute('fill', '#001219');
        text1.setAttribute('font-weight', '700');
        text1.textContent = String(node.value).slice(0,8);
        g.appendChild(text1);

        // text: priority
        const text2 = document.createElementNS('http://www.w3.org/2000/svg','text');
        text2.setAttribute('x', pos.x);
        text2.setAttribute('y', pos.y + 14);
        text2.setAttribute('text-anchor', 'middle');
        text2.setAttribute('font-size', '11px');
        text2.setAttribute('fill', '#001219');
        text2.textContent = node.priority;
        g.appendChild(text2);

        // index small
        const text3 = document.createElementNS('http://www.w3.org/2000/svg','text');
        text3.setAttribute('x', pos.x + 28);
        text3.setAttribute('y', pos.y - 10);
        text3.setAttribute('text-anchor', 'start');
        text3.setAttribute('font-size', '10px');
        text3.setAttribute('fill', 'rgba(255,255,255,0.35)');
        text3.textContent = `${node.i}`;
        g.appendChild(text3);

        svg.appendChild(g);
      }
    }

    // Hook up events
    enqueueBtn.addEventListener('click', () => {
      const v = valInput.value.trim();
      const p = prioInput.value;
      if (v === '' || p === '') {
        alert('Please provide value and priority.');
        return;
      }
      const t0 = performance.now();
      const node = pq.enqueue(v, Number(p));
      const t1 = performance.now();
      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;
      lastAction.textContent = `Last: enqueue ${node.value}:${node.priority}`;
      logTrace(`Enqueued ${node.value}:${node.priority}`);
      // animate single swap highlight not available here; just re-render
      renderAll();
    });

    dequeueBtn.addEventListener('click', () => {
      if (pq.isEmpty()) {
        alert('Queue is empty.');
        return;
      }
      const t0 = performance.now();
      const node = pq.dequeue();
      const t1 = performance.now();
      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;
      lastAction.textContent = `Last: dequeue ${node.value}:${node.priority}`;
      logTrace(`Dequeued ${node.value}:${node.priority}`, 'color:#9fe6c0');
      renderAll();
    });

    peekBtn.addEventListener('click', () => {
      const node = pq.peek();
      if (!node) {
        alert('empty');
        return;
      }
      lastAction.textContent = `Last: peek ${node.value}:${node.priority}`;
      logTrace(`Peek ${node.value}:${node.priority}`, 'color:#ffd580');
    });

    heapType.addEventListener('change', (e) => {
      pq.setType(e.target.value);
      logTrace(`Heap type set to ${e.target.value}`, 'color:#c6baff');
      renderAll();
    });

    randomBtn.addEventListener('click', () => {
      // add 10 random items
      const examples = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N'];
      for (let i = 0; i < 10; i++) {
        const v = examples[Math.floor(Math.random()*examples.length)] + '-' + Math.floor(Math.random()*999);
        const p = Math.floor(Math.random()*20);
        pq.enqueue(v, p);
      }
      lastAction.textContent = `Last: added 10 random`;
      logTrace('Added 10 random items');
      renderAll();
    });

    clearBtn.addEventListener('click', () => {
      pq.clear();
      logTrace('Cleared heap', 'color:#ef9a9a');
      lastAction.textContent = `Last: clear`;
      renderAll();
    });

    bulkBtn.addEventListener('click', () => {
      let n = Number(bulkCount.value) || 1000;
      if (n <= 0) return;
      const items = [];
      for (let i = 0; i < n; i++) {
        items.push({ value: 'v' + (Math.floor(Math.random()*100000)), priority: Math.floor(Math.random()*1000) });
      }
      const t0 = performance.now();
      pq.bulkAdd(items);
      const t1 = performance.now();
      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;
      lastAction.textContent = `Last: bulkAdd ${n} items`;
      logTrace(`Bulk added ${n} items in ${(t1 - t0).toFixed(3)} ms`, 'color:#b8f3c6');
      renderAll();
    });

    // initial render
    renderAll();

    // small demonstration: visualize a few steps with brief highlight when enqueueing to show bubble-up swaps.
    // We'll override enqueue to animate swaps for single insert (for teaching).
    // Keep internal original methods
    (function addAnimatedEnqueue() {
      const originalEnqueue = pq.enqueue.bind(pq);
      // We'll implement an alternate function that performs step-by-step bubble up and highlights swaps.
      // But for simplicity, we perform original then highlight node path by comparing array copies.
      enqueueBtn.addEventListener('click', () => {
        // no special sequence needed; previous handler already called enqueue
        // We will not duplicate; instead we can create a small animation by briefly highlighting last inserted and its parents.
        // Find last inserted index = heap.length-1, then show brief flashes moving up
        const arr = pq.toArray();
        const lastIndex = arr.length - 1;
        if (lastIndex < 0) return;
        // compute path up to root
        const path = [];
        let cur = lastIndex;
        while (cur > 0) {
          const parent = Math.floor((cur - 1) / 2);
          path.push([parent, cur]);
          cur = parent;
        }
        // animate highlights sequentially
        let step = 0;
        const doStep = () => {
          if (step >= path.length) {
            // final render
            renderAll();
            return;
          }
          const pair = path[step];
          renderAll(pair);
          step++;
          setTimeout(doStep, 160);
        };
        doStep();
      }, { once: false });
    })();

    // For first-time help
    logTrace('Priority Queue ready. Use the controls to enqueue/dequeue and visualize the heap.', 'color:#bcdfff');
  </script>
</body>
</html>