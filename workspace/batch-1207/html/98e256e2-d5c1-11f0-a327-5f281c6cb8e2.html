<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Kruskal's Algorithm Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root { --bg: #0f1724; --panel: #0b1220; --accent: #2dd4bf; --muted: #94a3b8; }
    html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif; background: linear-gradient(180deg,#071122 0%, #071827 100%); color:#e6eef6; }
    .wrap { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
    .left { width:360px; min-width:280px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border-radius:12px; padding:14px; box-sizing:border-box; }
    .title { font-size:18px; font-weight:700; color:var(--accent); margin-bottom:6px; display:flex; align-items:center; gap:8px; }
    .desc { font-size:13px; color:var(--muted); margin-bottom:12px; line-height:1.35; }
    label { display:block; font-size:13px; margin-top:8px; color:#cfeff3; }
    input[type="range"] { width:100%; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    button { background:transparent; border:1px solid rgba(255,255,255,0.08); color:var(--accent); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.secondary { color:#9fb6d0; border-color: rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); }
    .status { margin-top:12px; background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:13px; color:var(--muted); }
    .lists { margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .box { background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:13px; color:var(--muted); max-height:220px; overflow:auto; }
    .box h4 { margin:0 0 8px 0; font-size:13px; color:#cfeff3; }
    .small { font-size:12px; color:#9fb6d0; }
    .canvas-wrap { flex:1; background:linear-gradient(180deg,#08131c,#071226); border-radius:12px; display:flex; flex-direction:column; padding:10px; box-sizing:border-box; }
    .svg-area { flex:1; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02)); position:relative; overflow:hidden; }
    svg { width:100%; height:100%; display:block; }
    .legend { margin-top:8px; display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; flex-wrap:wrap; }
    .legend .item { display:flex; gap:6px; align-items:center; }
    .swatch { width:14px; height:12px; border-radius:3px; display:inline-block; }
    .sw-accepted { background:#34d399; }
    .sw-rejected { background:#fb7185; }
    .sw-active { background:#facc15; }
    .sw-default { background:#94a3b8; }
    .footer-note { font-size:12px; color:var(--muted); margin-top:8px; }
    .edge-weight { font-family:monospace; font-size:12px; pointer-events:none; }
    .node-label { font-size:13px; pointer-events:none; fill:#e6eef6; font-weight:700; text-anchor:middle; dominant-baseline:central; }
    .node { cursor:grab; }
    .node:active { cursor:grabbing; }
    .small-btn { padding:6px 8px; font-size:12px; border-radius:6px; }
    .compact { font-size:12px; padding:6px 8px; }
    .input-inline { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .input-inline input[type=number] { width:64px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); }
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="title">Kruskal's Algorithm — Interactive Demo</div>
    <div class="desc">
      Build a Minimum Spanning Tree (MST) using Kruskal's algorithm. Use the controls below to generate graphs, step through the algorithm, and see the union-find sets as edges are examined.
      Drag nodes to reposition them. Edge colors: green = accepted, red = rejected (would form cycle), yellow = currently considered.
    </div>

    <label>Nodes: <span id="nodeCountLabel">8</span></label>
    <input id="nodeCount" type="range" min="2" max="12" value="8">

    <label>Edge density (probability): <span id="edgeProbLabel">0.45</span></label>
    <input id="edgeProb" type="range" min="0.05" max="1" step="0.05" value="0.45">

    <div class="controls">
      <button id="randBtn">Generate Random Graph</button>
      <button id="sampleBtn" class="secondary">Load Sample Graph</button>
      <button id="resetBtn" class="secondary">Reset Algorithm</button>
      <button id="stepBtn" class="small-btn">Step</button>
      <button id="playBtn" class="small-btn">Auto Play</button>
      <button id="finishBtn" class="small-btn secondary">Run to Completion</button>
    </div>

    <div class="input-inline">
      <label style="margin:0;">Speed:</label>
      <input id="speed" type="range" min="200" max="2000" step="100" value="800">
      <span class="small" id="speedLabel">800 ms/step</span>
    </div>

    <div class="status" id="statusBox">
      Current edge: <span id="currentEdge">—</span><br>
      Edges considered: <span id="edgesConsidered">0</span> / <span id="totalEdges">0</span><br>
      Total MST weight so far: <strong id="mstWeight">0</strong>
    </div>

    <div class="lists">
      <div class="box">
        <h4>Selected edges (MST)</h4>
        <div id="selectedList">—</div>
      </div>
      <div class="box">
        <h4>Union-Find sets (parents)</h4>
        <div id="ufList">—</div>
      </div>
    </div>

    <div class="legend">
      <div class="item"><span class="swatch sw-accepted"></span>Accepted</div>
      <div class="item"><span class="swatch sw-rejected"></span>Rejected</div>
      <div class="item"><span class="swatch sw-active"></span>Current</div>
      <div class="item"><span class="swatch sw-default"></span>Not yet checked</div>
    </div>

    <div class="footer-note">
      Tip: Click "Load Sample Graph" for a clear example. Use "Run to Completion" to quickly finish. You can drag nodes; edges update automatically.
    </div>
  </div>

  <div class="canvas-wrap">
    <div class="svg-area" id="svgArea">
      <svg id="svg"></svg>
    </div>
  </div>
</div>

<script>
(function(){
  // Utility
  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function randFloat(min,max){ return Math.random()*(max-min)+min; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  // DOM
  const svg = document.getElementById('svg');
  const nodeCountInput = document.getElementById('nodeCount');
  const nodeCountLabel = document.getElementById('nodeCountLabel');
  const edgeProbInput = document.getElementById('edgeProb');
  const edgeProbLabel = document.getElementById('edgeProbLabel');
  const randBtn = document.getElementById('randBtn');
  const sampleBtn = document.getElementById('sampleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playBtn = document.getElementById('playBtn');
  const finishBtn = document.getElementById('finishBtn');
  const speedInput = document.getElementById('speed');
  const speedLabel = document.getElementById('speedLabel');
  const statusBox = document.getElementById('statusBox');
  const currentEdgeSpan = document.getElementById('currentEdge');
  const edgesConsideredSpan = document.getElementById('edgesConsidered');
  const totalEdgesSpan = document.getElementById('totalEdges');
  const mstWeightSpan = document.getElementById('mstWeight');
  const selectedList = document.getElementById('selectedList');
  const ufList = document.getElementById('ufList');
  const svgArea = document.getElementById('svgArea');

  let width, height;
  function resizeSVG(){
    const rect = svgArea.getBoundingClientRect();
    width = rect.width; height = rect.height;
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    render();
  }
  window.addEventListener('resize', resizeSVG);

  // Graph data
  let nodes = [];
  let edges = []; // {id,u,v,w}
  let nodeElems = {}; // id -> svg group
  let edgeElems = {}; // id -> svg group
  let dragging = null;

  // Kruskal state
  let sortedEdges = [];
  let edgeIndex = 0;
  let uf = null;
  let selectedEdges = [];
  let considered = 0;
  let playing = false;
  let playTimer = null;

  // Initialize
  function init(){
    nodeCountLabel.textContent = nodeCountInput.value;
    edgeProbLabel.textContent = edgeProbInput.value;
    speedLabel.textContent = speedInput.value + " ms/step";
    createSampleGraph();
    resizeSVG();
    attachEvents();
  }

  function attachEvents(){
    nodeCountInput.addEventListener('input', ()=>{
      nodeCountLabel.textContent = nodeCountInput.value;
    });
    edgeProbInput.addEventListener('input', ()=>{
      edgeProbLabel.textContent = edgeProbInput.value;
    });
    speedInput.addEventListener('input', ()=>{
      speedLabel.textContent = speedInput.value + " ms/step";
    });
    randBtn.addEventListener('click', ()=> {
      generateRandomGraph(parseInt(nodeCountInput.value), parseFloat(edgeProbInput.value));
    });
    sampleBtn.addEventListener('click', ()=> {
      createSampleGraph();
    });
    resetBtn.addEventListener('click', ()=> {
      resetAlgorithm();
    });
    stepBtn.addEventListener('click', ()=> {
      step();
    });
    playBtn.addEventListener('click', togglePlay);
    finishBtn.addEventListener('click', runToCompletion);
    svg.addEventListener('mousedown', onSvgMouseDown);
    document.addEventListener('mousemove', onDocMouseMove);
    document.addEventListener('mouseup', onDocMouseUp);
  }

  // Graph creation
  function createSampleGraph(){
    // Small clear sample graph with 8 nodes
    nodes = [];
    const cX = 600/2, cY = 380/2;
    const radius = Math.min(260, Math.min(window.innerWidth, window.innerHeight)*0.2);
    const samplePositions = [
      [100,80],[260,60],[460,60],[540,160],[480,300],[320,320],[160,260],[40,170]
    ];
    for(let i=0;i<8;i++){
      nodes.push({id:i, x: samplePositions[i][0]+40, y: samplePositions[i][1]+20});
    }
    edges = [
      {u:0,v:1,w:4},{u:0,v:7,w:8},{u:1,v:2,w:8},{u:1,v:7,w:11},
      {u:2,v:3,w:7},{u:2,v:5,w:4},{u:2,v:8,w:2},{u:3,v:4,w:9},
      {u:3,v:5,w:14},{u:4,v:5,w:10},{u:5,v:6,w:2},{u:6,v:7,w:1}
    ].map((e,i)=>({id:i,u:e.u,v:e.v,w:e.w}));
    // For sample we have 8 nodes (0..7); adjust edges to fit
    edges = [
      {id:0,u:0,v:1,w:3},{id:1,u:0,v:2,w:2},{id:2,u:1,v:2,w:1},
      {id:3,u:1,v:3,w:4},{id:4,u:2,v:4,w:7},{id:5,u:3,v:4,w:2},
      {id:6,u:3,v:5,w:3},{id:7,u:4,v:5,w:1},{id:8,u:0,v:5,w:8}
    ];
    // ensure nodes count matches max index
    const maxNode = Math.max(...nodes.map(n=>n.id));
    // place nodes in a circle to match positions
    const pad = 60;
    const cw = Math.max(520, width || 720);
    for(let i=0;i<nodes.length;i++){
      nodes[i].x = pad + (cw - 2*pad) * (0.15 + 0.7*(i/(nodes.length-1)));
      nodes[i].y = 80 + (i%2?120:0);
    }
    buildGraph();
  }

  function generateRandomGraph(n, prob){
    nodes = [];
    edges = [];
    const margin = 50;
    for(let i=0;i<n;i++){
      nodes.push({id:i,x:rand(margin, (width||800)-margin), y:rand(margin, (height||480)-margin)});
    }
    let id = 0;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(Math.random() <= prob){
          edges.push({id:id++, u:i, v:j, w: rand(1,20)});
        }
      }
    }
    if(edges.length === 0){
      // ensure at least a chain so graph is connected-ish
      for(let i=0;i<n-1;i++) edges.push({id:id++, u:i, v:i+1, w: rand(1,9)});
    }
    buildGraph();
  }

  function buildGraph(){
    // Clear previous
    svg.innerHTML = '';
    nodeElems = {}; edgeElems = {};
    for(let e of edges){
      createEdgeElem(e);
    }
    for(let v of nodes){
      createNodeElem(v);
    }
    resetAlgorithm();
    render();
  }

  // SVG element creation
  function createNodeElem(node){
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute('class','node');
    g.setAttribute('data-id', node.id);
    const circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
    circle.setAttribute('r', 18);
    circle.setAttribute('fill', '#0b1220');
    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
    circle.setAttribute('stroke-width', 2);
    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute('class','node-label');
    text.textContent = node.id;
    g.appendChild(circle);
    g.appendChild(text);
    svg.appendChild(g);
    nodeElems[node.id] = {g: g, circle: circle, text: text};
    updateNodePos(node);
    // Events for dragging
    g.addEventListener('mousedown', (ev)=> {
      dragging = {id: node.id, offsetX: ev.offsetX - node.x, offsetY: ev.offsetY - node.y};
      ev.stopPropagation();
    });
  }

  function createEdgeElem(edge){
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute('data-id', edge.id);
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute('stroke', '#64748b');
    line.setAttribute('stroke-width', 3);
    line.setAttribute('stroke-linecap','round');
    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute('class','edge-weight');
    text.setAttribute('fill','#e6eef6');
    text.setAttribute('text-anchor','middle');
    text.setAttribute('dominant-baseline','central');
    text.textContent = edge.w;
    g.appendChild(line);
    g.appendChild(text);
    svg.appendChild(g);
    edgeElems[edge.id] = {g:g, line:line, text:text};
    // clicking an edge randomizes its weight (for exploration)
    g.addEventListener('dblclick', ()=> {
      edge.w = rand(1,20);
      edgeElems[edge.id].text.textContent = edge.w;
      resetAlgorithm();
    });
    updateEdgePos(edge);
  }

  function updateNodePos(node){
    const e = nodeElems[node.id];
    if(!e) return;
    e.g.setAttribute('transform', `translate(${node.x},${node.y})`);
    // highlight accepted nodes (in MST) by stroke color if connected
    e.circle.setAttribute('stroke', 'rgba(255,255,255,0.08)');
  }

  function updateEdgePos(edge){
    const a = nodes.find(n=>n.id===edge.u);
    const b = nodes.find(n=>n.id===edge.v);
    if(!a || !b) return;
    const e = edgeElems[edge.id];
    // set line endpoints
    e.line.setAttribute('x1', a.x);
    e.line.setAttribute('y1', a.y);
    e.line.setAttribute('x2', b.x);
    e.line.setAttribute('y2', b.y);
    // position weight text at midpoint with slight offset
    const mx = (a.x + b.x)/2;
    const my = (a.y + b.y)/2;
    e.text.setAttribute('x', mx);
    e.text.setAttribute('y', my - 10);
    e.text.textContent = edge.w;
    // layer edges behind nodes
    e.g.style.zIndex = 1;
  }

  // Rendering all
  function render(){
    // Update sizes if needed
    for(let node of nodes) updateNodePos(node);
    for(let edge of edges) updateEdgePos(edge);
    // Update visual states based on kruskal state
    // Colors: default '#64748b', current '#facc15', accepted '#34d399', rejected '#fb7185'
    const acceptedSet = new Set(selectedEdges.map(e=>e.id));
    for(let edge of edges){
      const el = edgeElems[edge.id];
      if(!el) continue;
      if(acceptedSet.has(edge.id)){
        el.line.setAttribute('stroke', '#34d399');
        el.line.setAttribute('stroke-width', 4);
        el.text.setAttribute('fill','#34d399');
      } else if(edge._state === 'current'){
        el.line.setAttribute('stroke', '#facc15');
        el.line.setAttribute('stroke-width', 4);
        el.text.setAttribute('fill','#facc15');
      } else if(edge._state === 'rejected'){
        el.line.setAttribute('stroke', '#fb7185');
        el.line.setAttribute('stroke-width', 3);
        el.text.setAttribute('fill','#fb7185');
      } else {
        el.line.setAttribute('stroke', '#64748b');
        el.line.setAttribute('stroke-width', 3);
        el.text.setAttribute('fill','#e6eef6');
      }
    }
    // Update status UI
    currentEdgeSpan.textContent = (sortedEdges[edgeIndex] ? `${sortedEdges[edgeIndex].u} - ${sortedEdges[edgeIndex].v} (w=${sortedEdges[edgeIndex].w})` : '—');
    edgesConsideredSpan.textContent = considered;
    totalEdgesSpan.textContent = sortedEdges.length;
    let sum = selectedEdges.reduce((a,b)=>a+b.w,0);
    mstWeightSpan.textContent = sum;
    // selected edges list
    if(selectedEdges.length===0) selectedList.textContent = '—';
    else selectedList.innerHTML = selectedEdges.map(e=>`${e.u}—${e.v} (w=${e.w})`).join('<br>');
    // union-find display
    if(uf){
      ufList.innerHTML = Array.from({length: nodes.length}, (_,i)=>`p[${i}] = ${uf.find(i)}`).join('<br>');
    }else{
      ufList.textContent = '—';
    }
  }

  // Union-Find implementation with visible parent (no path compression on find to show structure clearly unless compress param)
  class UnionFind {
    constructor(n){
      this.parent = Array.from({length:n}, (_,i)=>i);
      this.rank = Array.from({length:n}, ()=>0);
    }
    find(x){
      // iterative find with path compression disabled for clarity in display.
      while(this.parent[x] !== x){
        x = this.parent[x];
      }
      return x;
    }
    union(x,y){
      let rx = this.find(x), ry = this.find(y);
      if(rx === ry) return false;
      if(this.rank[rx] < this.rank[ry]) this.parent[rx] = ry;
      else if(this.rank[ry] < this.rank[rx]) this.parent[ry] = rx;
      else { this.parent[ry] = rx; this.rank[rx]++; }
      return true;
    }
  }

  // Kruskal algorithm control
  function resetAlgorithm(){
    // reset states
    for(let e of edges) e._state = null;
    // Sort edges by weight asc, tie-break by ids
    sortedEdges = edges.slice().sort((a,b)=> a.w - b.w || a.id - b.id);
    edgeIndex = 0;
    uf = new UnionFind(nodes.length);
    selectedEdges = [];
    considered = 0;
    playing = false;
    if(playTimer) { clearTimeout(playTimer); playTimer = null; playBtn.textContent = 'Auto Play'; }
    render();
  }

  function step(){
    if(edgeIndex >= sortedEdges.length){
      // done
      currentEdgeSpan.textContent = 'Done';
      return;
    }
    // clear previous current markers
    for(let e of edges) if(e._state === 'current') e._state = null;
    const edge = sortedEdges[edgeIndex];
    edge._state = 'current';
    render();

    // Consider this edge
    considered++;
    const ru = uf.find(edge.u), rv = uf.find(edge.v);
    if(ru !== rv){
      // accept
      uf.union(edge.u, edge.v);
      selectedEdges.push(edge);
      edge._state = 'accepted';
    } else {
      // reject -> forms cycle
      edge._state = 'rejected';
    }
    edgeIndex++;
    // if MST has n-1 edges we can stop early
    if(selectedEdges.length >= nodes.length - 1){
      // mark rest as default (not checked)
      for(let i=edgeIndex;i<sortedEdges.length;i++){
        sortedEdges[i]._state = null;
      }
      edgeIndex = sortedEdges.length;
    }
    render();
  }

  function togglePlay(){
    if(playing){
      playing = false;
      if(playTimer) clearTimeout(playTimer);
      playTimer = null;
      playBtn.textContent = 'Auto Play';
    } else {
      playing = true;
      playBtn.textContent = 'Pause';
      autoStep();
    }
  }

  function autoStep(){
    if(!playing) return;
    step();
    if(edgeIndex >= sortedEdges.length || selectedEdges.length >= nodes.length-1){
      playing = false;
      playBtn.textContent = 'Auto Play';
      return;
    }
    playTimer = setTimeout(autoStep, parseInt(speedInput.value));
  }

  function runToCompletion(){
    // Quickly finish without animation
    while(edgeIndex < sortedEdges.length && selectedEdges.length < nodes.length - 1){
      const edge = sortedEdges[edgeIndex];
      const ru = uf.find(edge.u), rv = uf.find(edge.v);
      if(ru !== rv){
        uf.union(edge.u, edge.v);
        selectedEdges.push(edge);
        edge._state = 'accepted';
      } else {
        edge._state = 'rejected';
      }
      edgeIndex++;
      considered++;
    }
    render();
  }

  // Interaction: dragging nodes updates edges live
  function onSvgMouseDown(e){
    // clicking blank area cancels dragging
    dragging = null;
  }
  function onDocMouseMove(e){
    if(!dragging) return;
    // translate page coords to svg coordinates
    const rect = svg.getBoundingClientRect();
    const x = clamp(e.clientX - rect.left - dragging.offsetX, 20, rect.width-20);
    const y = clamp(e.clientY - rect.top - dragging.offsetY, 20, rect.height-20);
    const node = nodes.find(n=>n.id===dragging.id);
    if(node){ node.x = x; node.y = y; updateNodePos(node); }
    for(let edge of edges) updateEdgePos(edge);
  }
  function onDocMouseUp(e){
    if(dragging){
      dragging = null;
      render();
    }
  }

  // Initialize sample on load
  init();

  // Expose some helpful keyboard shortcuts (optional)
  window.addEventListener('keydown', (ev)=>{
    if(ev.key === ' '){ ev.preventDefault(); togglePlay(); }
    if(ev.key === 'ArrowRight'){ step(); }
    if(ev.key === 'r'){ generateRandomGraph(parseInt(nodeCountInput.value), parseFloat(edgeProbInput.value)); }
  });

})();
</script>
</body>
</html>