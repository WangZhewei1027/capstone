<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }
        .description {
            margin-bottom: 30px;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .graph-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fff;
            flex: 1;
            min-width: 500px;
        }
        .controls {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .step-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #e1f5fe;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        .current-edge {
            background-color: #fff9c4;
        }
        .updated-distance {
            background-color: #c8e6c9;
        }
        .algorithm-steps {
            margin-top: 30px;
        }
        .algorithm-steps ol {
            padding-left: 20px;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bellman-Ford Algorithm Visualization</h1>
        
        <div class="description">
            <p>The Bellman-Ford algorithm is used to find the shortest path from a source node to all other nodes in a weighted graph. Unlike Dijkstra's algorithm, it can handle graphs with negative edge weights and detects negative cycles.</p>
        </div>
        
        <div class="graph-container">
            <canvas id="graphCanvas" width="600" height="400"></canvas>
            <div style="flex: 1; min-width: 300px;">
                <div class="controls">
                    <button id="startBtn">Start Algorithm</button>
                    <button id="stepBtn" disabled>Next Step</button>
                    <button id="resetBtn">Reset</button>
                    <button id="toggleGraphBtn">Toggle Graph Type</button>
                </div>
                <div class="step-info" id="stepInfo">Click "Start Algorithm" to begin visualization.</div>
                <div class="table-container">
                    <table id="distanceTable">
                        <thead>
                            <tr>
                                <th>Step</th>
                                <th>A</th>
                                <th>B</th>
                                <th>C</th>
                                <th>D</th>
                                <th>E</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="algorithm-steps">
            <h2>Algorithm Steps</h2>
            <ol>
                <li>Initialize distances from source to all vertices as infinite, except the source itself which is 0.</li>
                <li>Relax all edges |V| - 1 times where |V| is the number of vertices.</li>
                <li>Check for negative weight cycles by relaxing all edges one more time.</li>
                <li>If any distance can still be improved, a negative cycle exists.</li>
            </ol>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #3498db;"></div>
                <span>Source Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Current Edge</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Updated Distance</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f39c12;"></div>
                <span>Shortest Path</span>
            </div>
        </div>
    </div>

    <script>
        // Graph representations
        const graphs = {
            standard: {
                nodes: [
                    { id: 'A', x: 100, y: 200 },
                    { id: 'B', x: 300, y: 100 },
                    { id: 'C', x: 300, y: 300 },
                    { id: 'D', x: 500, y: 100 },
                    { id: 'E', x: 500, y: 300 }
                ],
                edges: [
                    { from: 'A', to: 'B', weight: 4 },
                    { from: 'A', to: 'C', weight: 2 },
                    { from: 'B', to: 'C', weight: 3 },
                    { from: 'B', to: 'D', weight: 2 },
                    { from: 'B', to: 'E', weight: 3 },
                    { from: 'C', to: 'B', weight: 1 },
                    { from: 'C', to: 'E', weight: 5 },
                    { from: 'D', to: 'E', weight: -5 }
                ]
            },
            negativeCycle: {
                nodes: [
                    { id: 'A', x: 100, y: 200 },
                    { id: 'B', x: 300, y: 100 },
                    { id: 'C', x: 300, y: 300 },
                    { id: 'D', x: 500, y: 200 }
                ],
                edges: [
                    { from: 'A', to: 'B', weight: 1 },
                    { from: 'B', to: 'C', weight: -3 },
                    { from: 'C', to: 'D', weight: -2 },
                    { from: 'D', to: 'B', weight: 2 }
                ]
            }
        };

        // Algorithm state
        let currentGraph = 'standard';
        let distances = {};
        let predecessors = {};
        let step = 0;
        let iteration = 0;
        let currentEdgeIndex = 0;
        let algorithmRunning = false;
        let algorithmComplete = false;
        let nodes = [];
        let edges = [];

        // Canvas setup
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const toggleGraphBtn = document.getElementById('toggleGraphBtn');
        const stepInfo = document.getElementById('stepInfo');
        const tableBody = document.getElementById('tableBody');

        // Initialize the graph
        function initializeGraph() {
            const graph = graphs[currentGraph];
            nodes = [...graph.nodes];
            edges = [...graph.edges];
            
            // Initialize distances
            distances = {};
            predecessors = {};
            
            nodes.forEach(node => {
                distances[node.id] = node.id === 'A' ? 0 : Infinity;
                predecessors[node.id] = null;
            });
            
            step = 0;
            iteration = 0;
            currentEdgeIndex = 0;
            algorithmRunning = false;
            algorithmComplete = false;
            
            stepBtn.disabled = true;
            updateStepInfo('Graph initialized. Click "Start Algorithm" to begin.');
            updateTable();
            drawGraph();
        }

        // Update step information
        function updateStepInfo(message) {
            stepInfo.textContent = message;
        }

        // Draw the graph on canvas
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            edges.forEach((edge, index) => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                
                // Highlight current edge
                if (algorithmRunning && index === currentEdgeIndex) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                } else {
                    ctx.strokeStyle = '#7f8c8d';
                    ctx.lineWidth = 2;
                }
                
                // Draw edge line
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.stroke();
                
                // Draw edge weight
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.fillText(edge.weight, midX, midY - 10);
                
                // Draw arrowhead
                drawArrowhead(fromNode, toNode);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                // Highlight source node
                if (node.id === 'A') {
                    ctx.fillStyle = '#3498db';
                } else {
                    ctx.fillStyle = '#2c3e50';
                }
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw node label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.x, node.y);
                
                // Draw distance
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(
                    distances[node.id] === Infinity ? '∞' : distances[node.id], 
                    node.x, 
                    node.y + 30
                );
            });
        }

        // Draw arrowhead for directed edges
        function drawArrowhead(fromNode, toNode) {
            const arrowSize = 10;
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            const headLength = 15;
            
            // Calculate the point where the arrowhead should be drawn
            const arrowX = toNode.x - 20 * Math.cos(angle);
            const arrowY = toNode.y - 20 * Math.sin(angle);
            
            ctx.fillStyle = algorithmRunning && edges.findIndex(e => e.from === fromNode.id && e.to === toNode.id) === currentEdgeIndex ? '#e74c3c' : '#7f8c8d';
            
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - headLength * Math.cos(angle - Math.PI / 6),
                arrowY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                arrowX - headLength * Math.cos(angle + Math.PI / 6),
                arrowY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // Update the distance table
        function updateTable() {
            tableBody.innerHTML = '';
            
            // Create rows for each iteration
            for (let i = 0; i <= step; i++) {
                const row = document.createElement('tr');
                
                // Step number
                const stepCell = document.createElement('td');
                stepCell.textContent = i === 0 ? 'Initial' : `Iteration ${i}`;
                row.appendChild(stepCell);
                
                // Distance for each node
                nodes.forEach(node => {
                    const cell = document.createElement('td');
                    cell.textContent = distances[node.id] === Infinity ? '∞' : distances[node.id];
                    
                    // Highlight if this distance was updated in this step
                    if (i === step && algorithmRunning) {
                        cell.classList.add('updated-distance');
                    }
                    
                    row.appendChild(cell);
                });
                
                tableBody.appendChild(row);
            }
        }

        // Perform one step of the Bellman-Ford algorithm
        function performStep() {
            if (algorithmComplete) return;
            
            // First iteration: initialize distances
            if (step === 0) {
                step++;
                updateStepInfo(`Step ${step}: Initialized distances. Source node A has distance 0, others have ∞.`);
                updateTable();
                return;
            }
            
            // Check if we've completed all |V| - 1 iterations
            if (iteration >= nodes.length - 1) {
                // Check for negative cycles
                let negativeCycleFound = false;
                
                for (const edge of edges) {
                    const u = edge.from;
                    const v = edge.to;
                    const weight = edge.weight;
                    
                    if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
                        negativeCycleFound = true;
                        break;
                    }
                }
                
                if (negativeCycleFound) {
                    updateStepInfo(`Step ${step}: Negative cycle detected! Graph contains a negative weight cycle.`);
                    algorithmComplete = true;
                    stepBtn.disabled = true;
                } else {
                    updateStepInfo(`Step ${step}: Algorithm completed. No negative cycles detected. Final distances found.`);
                    algorithmComplete = true;
                    stepBtn.disabled = true;
                    
                    // Highlight shortest paths
                    highlightShortestPaths();
                }
                
                return;
            }
            
            // Process next edge
            const edge = edges[currentEdgeIndex];
            const u = edge.from;
            const v = edge.to;
            const weight = edge.weight;
            
            stepInfo.textContent = `Step ${step}: Checking edge ${u} → ${v} (weight: ${weight})`;
            
            // Relaxation step
            if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
                distances[v] = distances[u] + weight;
                predecessors[v] = u;
                updateStepInfo(`Step ${step}: Updated distance to ${v} from ${distances[v] - weight} to ${distances[v]} via ${u}`);
            } else {
                updateStepInfo(`Step ${step}: No improvement for ${v} via ${u}. Current distance: ${distances[v]}`);
            }
            
            // Move to next edge
            currentEdgeIndex++;
            
            // If we've processed all edges in this iteration, move to next iteration
            if (currentEdgeIndex >= edges.length) {
                currentEdgeIndex = 0;
                iteration++;
                step++;
                updateStepInfo(`Step ${step}: Completed iteration ${iteration}. Starting next iteration.`);
            }
            
            updateTable();
            drawGraph();
        }

        // Highlight shortest paths from source
        function highlightShortestPaths() {
            // This would visually highlight the shortest paths in the graph
            // For simplicity, we'll just update the info text
            updateStepInfo(stepInfo.textContent + "\nShortest paths highlighted in orange.");
            
            // In a more complete implementation, we would draw the shortest paths
            // with a different color or style
        }

        // Event listeners
        startBtn.addEventListener('click', () => {
            algorithmRunning = true;
            stepBtn.disabled = false;
            startBtn.disabled = true;
            updateStepInfo('Algorithm started. Click "Next Step" to proceed through the algorithm.');
        });

        stepBtn.addEventListener('click', performStep);

        resetBtn.addEventListener('click', initializeGraph);

        toggleGraphBtn.addEventListener('click', () => {
            currentGraph = currentGraph === 'standard' ? 'negativeCycle' : 'standard';
            initializeGraph();
            updateStepInfo(`Switched to ${currentGraph === 'standard' ? 'standard graph' : 'graph with negative cycle'}.`);
        });

        // Initialize the visualization
        initializeGraph();
    </script>
</body>
</html>