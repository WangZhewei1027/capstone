<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Heap Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#94a3b8;
      --bar:#60a5fa;
      --compare:#f59e0b;
      --swap:#ef4444;
      --heap:#34d399;
      --sorted:#64748b;
      --text:#e6eef8;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071028);color:var(--text)}
    .wrap{max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg,var(--panel),rgba(11,18,32,0.8));box-shadow:0 6px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 6px;font-size:20px;color:var(--accent)}
    p.lead{margin:0 0 18px;color:var(--muted);font-size:13px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}
    .controls > *{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--text);font-size:13px}
    button.btn{cursor:pointer;border:0;padding:10px 12px;background:linear-gradient(180deg,#0b1220,rgba(255,255,255,0.02));color:var(--text);border-radius:8px}
    button.btn.primary{background:linear-gradient(180deg,#0369a1,#164e63);color:white}
    .controls .row{display:flex;gap:8px;align-items:center}
    label{font-size:13px;color:var(--muted);margin-right:6px}
    input[type=range]{width:140px}
    .board{display:flex;gap:12px;align-items:end;height:360px;padding:18px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.02)}
    .bars{flex:1;height:100%;display:flex;align-items:end;gap:2px}
    .bar{flex:1 0 8px;height:40px;background:var(--bar);border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:rgba(255,255,255,0.9);font-size:11px;position:relative;transition:height 180ms linear, background-color 120ms linear, transform 120ms linear}
    .bar.hidden-label{font-size:0}
    .bar .val{position:absolute;top:6px;left:6px;font-size:11px;color:rgba(255,255,255,0.9)}
    .info{display:flex;gap:14px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .chip{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px;border:1px solid rgba(255,255,255,0.02)}
    .legend{display:flex;gap:8px;align-items:center}
    .legend .key{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
    .swatch{width:14px;height:14px;border-radius:4px;box-shadow:inset 0 -2px rgba(0,0,0,0.2)}
    .footer{margin-top:18px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .codebox{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;font-size:12px;color:var(--muted);max-height:140px;overflow:auto}
    .small{font-size:12px;color:var(--muted)}
    @media (max-width:720px){
      .board{height:320px;padding:12px}
      .controls{gap:8px}
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Heap Sort Visualizer">
    <h1>Heap Sort Visualizer</h1>
    <p class="lead">Interactive demonstration of Heap Sort. Build a heap, then repeatedly extract the root to sort the array. Use the controls to step through or animate the algorithm.</p>

    <div class="controls" aria-hidden="false">
      <div class="row">
        <button class="btn primary" id="playBtn" title="Play / Pause">Play</button>
        <button class="btn" id="stepBtn" title="Step one action">Step</button>
        <button class="btn" id="resetBtn" title="Reset array">Reset</button>
        <button class="btn" id="shuffleBtn" title="Shuffle array">Shuffle</button>
      </div>

      <div class="row">
        <label for="size">Size</label>
        <input type="range" id="size" min="8" max="80" value="36">
        <span id="sizeVal" class="small">36</span>
      </div>

      <div class="row">
        <label for="speed">Speed</label>
        <input type="range" id="speed" min="10" max="1000" value="220">
        <span id="speedVal" class="small">220ms</span>
      </div>

      <div class="row">
        <label for="order">Order</label>
        <select id="order" title="Sort order">
          <option value="asc" selected>Ascending</option>
          <option value="desc">Descending</option>
        </select>
      </div>

      <div class="row">
        <button class="btn" id="randomizeBtn">Randomize Values</button>
      </div>
    </div>

    <div class="board" aria-live="polite">
      <div class="bars" id="bars" role="list"></div>
    </div>

    <div class="info" aria-hidden="false">
      <div class="chip">Comparisons: <strong id="comp">0</strong></div>
      <div class="chip">Swaps: <strong id="swaps">0</strong></div>
      <div class="chip">Steps: <strong id="steps">0</strong></div>
      <div class="chip">Phase: <strong id="phase">idle</strong></div>
      <div class="chip">Heap size (current): <strong id="heapSize">-</strong></div>

      <div style="margin-left:auto" class="legend">
        <div class="key"><div class="swatch" style="background:var(--compare)"></div> Compare</div>
        <div class="key"><div class="swatch" style="background:var(--swap)"></div> Swap</div>
        <div class="key"><div class="swatch" style="background:var(--heap)"></div> Heap area</div>
        <div class="key"><div class="swatch" style="background:var(--sorted)"></div> Sorted</div>
      </div>
    </div>

    <div class="footer">
      <div style="flex:1 1 60%">
        <div class="small">How it works: For ascending sort, Heap Sort builds a max-heap; then the largest element (root) is swapped to the end and removed from the heap. The heap is re-heapified and the process repeats.</div>
      </div>
      <div style="max-width:360px">
        <div class="codebox" id="pseudocode">
heapify(n, i):
  largest = i
  left = 2*i + 1
  right = 2*i + 2
  if left < n and arr[left] > arr[largest]: largest = left
  if right < n and arr[right] > arr[largest]: largest = right
  if largest != i:
    swap(arr[i], arr[largest])
    heapify(n, largest)

heapSort(arr):
  build heap: for i from floor(n/2)-1 downto 0: heapify(n, i)
  for end from n-1 downto 1:
    swap(arr[0], arr[end])
    heapify(end, 0)
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  // Elements
  const barsEl = document.getElementById('bars');
  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const sizeInput = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const orderSel = document.getElementById('order');
  const compEl = document.getElementById('comp');
  const swapsEl = document.getElementById('swaps');
  const stepsEl = document.getElementById('steps');
  const phaseEl = document.getElementById('phase');
  const heapSizeEl = document.getElementById('heapSize');

  // State
  let arr = [];
  let bars = [];
  let n = parseInt(sizeInput.value,10);
  let generator = null;
  let running = false;
  let timer = null;
  let delay = parseInt(speedInput.value,10);
  let stats = {comparisons:0, swaps:0, steps:0};
  let lastAction = null;
  let highlight = {}; // indices coloring
  let order = orderSel.value; // 'asc' or 'desc'
  let heapActiveSize = -1;

  // Init
  sizeVal.textContent = n;
  speedVal.textContent = delay + 'ms';

  function createArray(len, min=5, max=100){
    const a = [];
    for(let i=0;i<len;i++){
      a.push(Math.floor(Math.random()*(max-min+1))+min);
    }
    return a;
  }

  function render(){
    barsEl.innerHTML = '';
    bars = [];
    const maxv = Math.max(...arr);
    const showLabels = arr.length <= 40;
    for(let i=0;i<arr.length;i++){
      const el = document.createElement('div');
      el.className = 'bar' + (showLabels ? '' : ' hidden-label');
      el.setAttribute('role','listitem');
      el.style.height = Math.max(6, (arr[i] / maxv) * 100) + '%';
      el.style.backgroundColor = 'var(--bar)';
      el.dataset.index = i;
      const val = document.createElement('div');
      val.className = 'val';
      val.textContent = arr[i];
      el.appendChild(val);
      barsEl.appendChild(el);
      bars.push(el);
    }
    updateHighlights();
  }

  function updateHighlights(){
    for(let i=0;i<bars.length;i++){
      const el = bars[i];
      el.style.backgroundColor = 'var(--bar)';
      el.style.transform = '';
      // If sorted (index >= heapActiveSize)
      if(heapActiveSize >= 0 && i > heapActiveSize){
        el.style.backgroundColor = 'var(--sorted)';
      } else if(heapActiveSize >= 0 && i <= heapActiveSize){
        // heap area
        el.style.backgroundColor = 'var(--heap)';
      }
    }
    if(highlight.compare){
      highlight.compare.forEach(idx => {
        if(bars[idx]) bars[idx].style.backgroundColor = 'var(--compare)';
      });
    }
    if(highlight.swap){
      highlight.swap.forEach(idx => {
        if(bars[idx]) bars[idx].style.backgroundColor = 'var(--swap)';
        if(bars[idx]) bars[idx].style.transform = 'scale(1.02)';
      });
    }
  }

  function setPhase(text){
    phaseEl.textContent = text;
  }

  function resetStats(){
    stats = {comparisons:0, swaps:0, steps:0};
    compEl.textContent = 0;
    swapsEl.textContent = 0;
    stepsEl.textContent = 0;
  }

  // Utility: comparator used by heap (true if a should be chosen over b)
  function comparator(a,b){
    if(order === 'asc'){ // want max-heap: choose larger
      return a > b;
    } else { // desc -> min-heap
      return a < b;
    }
  }

  // Heapify generator: yields action objects
  function* heapifyGen(nLocal, i){
    // nLocal: heap size
    let root = i;
    while(true){
      let selected = root;
      const left = 2*root + 1;
      const right = 2*root + 2;
      if(left < nLocal){
        yield {type:'compare', i:left, j:selected, heapSize:nLocal};
        if(comparator(arr[left], arr[selected])) selected = left;
      }
      if(right < nLocal){
        yield {type:'compare', i:right, j:selected, heapSize:nLocal};
        if(comparator(arr[right], arr[selected])) selected = right;
      }
      if(selected !== root){
        yield {type:'swap', i:root, j:selected, heapSize:nLocal};
        // perform swap
        const tmp = arr[root]; arr[root] = arr[selected]; arr[selected] = tmp;
        root = selected;
        // continue loop to ensure subtree is a heap
      } else {
        // finished heapifying this subtree
        return;
      }
    }
  }

  // Main heap sort generator
  function* heapSortGen(){
    const N = arr.length;
    // Build heap
    setPhase('building heap');
    for(let start=Math.floor(N/2)-1; start>=0; start--){
      yield {type:'heapifyStart', index:start, heapSize:N};
      yield* heapifyGen(N, start);
    }
    yield {type:'heapBuilt', heapSize:N};
    // Extraction phase
    setPhase('extracting');
    for(let end=N-1; end>0; end--){
      // swap root with end
      yield {type:'swap', i:0, j:end, heapSize:end};
      const tmp = arr[0]; arr[0] = arr[end]; arr[end] = tmp;
      // mark end as sorted
      yield {type:'markedSorted', index:end, heapSize:end-1};
      yield* heapifyGen(end, 0);
    }
    yield {type:'markedSorted', index:0, heapSize:0};
    setPhase('done');
    return;
  }

  // Visual action handler
  function handleAction(action){
    stats.steps += 1;
    stepsEl.textContent = stats.steps;
    highlight = {};
    lastAction = action;
    heapActiveSize = (typeof action.heapSize === 'number') ? (action.heapSize - 1) : heapActiveSize;
    heapSizeEl.textContent = (heapActiveSize >= 0) ? (heapActiveSize + 1) : '-';

    if(action.type === 'compare'){
      stats.comparisons += 1;
      compEl.textContent = stats.comparisons;
      setPhase('comparing');
      highlight.compare = [action.i, action.j];
      updateHighlights();
    } else if(action.type === 'swap'){
      stats.swaps += 1;
      swapsEl.textContent = stats.swaps;
      setPhase('swap');
      highlight.swap = [action.i, action.j];
      // update visual heights & labels
      const iEl = bars[action.i];
      const jEl = bars[action.j];
      if(iEl && jEl){
        // swap heights + labels
        const hi = iEl.style.height;
        const hj = jEl.style.height;
        iEl.style.height = hj;
        jEl.style.height = hi;
        const vi = iEl.querySelector('.val').textContent;
        const vj = jEl.querySelector('.val').textContent;
        iEl.querySelector('.val').textContent = vj;
        jEl.querySelector('.val').textContent = vi;
      }
      updateHighlights();
    } else if(action.type === 'heapifyStart'){
      setPhase('heapify: start at ' + action.index);
      highlight = {compare:[], swap:[]};
      updateHighlights();
    } else if(action.type === 'heapBuilt'){
      setPhase('heap built');
      heapActiveSize = action.heapSize - 1;
      heapSizeEl.textContent = action.heapSize;
      updateHighlights();
    } else if(action.type === 'markedSorted'){
      setPhase('marked sorted index ' + action.index);
      heapActiveSize = action.heapSize - 1;
      updateHighlights();
      // color sorted element
      if(bars[action.index]) bars[action.index].style.backgroundColor = 'var(--sorted)';
    } else {
      setPhase(action.type || 'idle');
      updateHighlights();
    }
  }

  // Step executor: advance one action
  function step(){
    if(!generator) generator = heapSortGen();
    const res = generator.next();
    if(res.done){
      running = false;
      playBtn.textContent = 'Play';
      setPhase('finished');
      return false;
    } else {
      handleAction(res.value);
      return true;
    }
  }

  function start(){
    if(running) return;
    running = true;
    playBtn.textContent = 'Pause';
    if(!generator) generator = heapSortGen();
    loop();
  }

  function pause(){
    running = false;
    playBtn.textContent = 'Play';
    if(timer){ clearTimeout(timer); timer=null; }
  }

  function togglePlay(){
    if(running) pause();
    else start();
  }

  function loop(){
    if(!running) return;
    const nextOk = step();
    if(!nextOk){
      running = false;
      playBtn.textContent = 'Play';
      return;
    }
    timer = setTimeout(loop, delay);
  }

  // Controls handlers
  playBtn.addEventListener('click', ()=>{
    togglePlay();
  });
  stepBtn.addEventListener('click', ()=>{
    pause();
    step();
  });
  resetBtn.addEventListener('click', ()=>{
    pause();
    arr = createArray(n,5,200);
    resetStats();
    generator = null;
    heapActiveSize = -1;
    setPhase('idle');
    render();
  });
  shuffleBtn.addEventListener('click', ()=>{
    pause();
    // shuffle arr in place
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;
    }
    resetStats();
    generator = null;
    heapActiveSize = -1;
    setPhase('idle');
    render();
  });
  randomizeBtn.addEventListener('click', ()=>{
    pause();
    arr = createArray(n,5,200);
    resetStats();
    generator = null;
    heapActiveSize = -1;
    setPhase('idle');
    render();
  });

  sizeInput.addEventListener('input', (e)=>{
    n = parseInt(e.target.value,10);
    sizeVal.textContent = n;
    pause();
    arr = createArray(n,5,200);
    resetStats();
    generator = null;
    heapActiveSize = -1;
    render();
  });

  speedInput.addEventListener('input', (e)=>{
    delay = parseInt(e.target.value,10);
    speedVal.textContent = delay + 'ms';
  });

  orderSel.addEventListener('change', (e)=>{
    order = e.target.value;
    pause();
    // keep array but restart algorithm
    resetStats();
    generator = null;
    heapActiveSize = -1;
    setPhase('idle');
    render();
  });

  // Initialize array and render
  arr = createArray(n,5,200);
  render();

  // Keyboard: space to play/pause, right arrow step
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){
      e.preventDefault();
      togglePlay();
    } else if(e.code === 'ArrowRight'){
      e.preventDefault();
      pause();
      step();
    }
  });

  // Accessibility: announce phases (light)
  const live = document.createElement('div');
  live.setAttribute('aria-live','polite');
  live.style.position='absolute';
  live.style.left='-9999px';
  document.body.appendChild(live);
  const obsPhase = new MutationObserver(()=>{ live.textContent = phaseEl.textContent; });
  obsPhase.observe(phaseEl, {childList:true});

  // Helpful: auto-size bars widths based on length
  const resizeObserver = new ResizeObserver(()=>{ /* no-op placeholder */ });
  resizeObserver.observe(barsEl);
})();
</script>
</body>
</html>