<!DOCTYPE html>
# Kruskal's Algorithm Visualization

Here's a complete HTML file that visually demonstrates and explains Kruskal's algorithm for finding the minimum spanning tree in a weighted graph.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-between;
        }
        
        .graph-container {
            flex: 1;
            min-width: 500px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .control-panel {
            flex-basis: 300px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .explanation {
            flex: 1 100%;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-top: 20px;
        }
        
        #graphCanvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
            width: 100%;
            height: 400px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .mst-edge {
            stroke: #e74c3c;
            stroke-width: 3;
        }
        
        .edge-label {
            fill: #2c3e50;
            font-size: 14px;
        }
        
        .node {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 2;
            cursor: pointer;
        }
        
        .node-label {
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
        
        .progress-indicator {
            margin: 20px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        .step {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #27ae60;
        }
        
        .edge-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        
        .edge-item {
            padding: 5px;
            margin: 3px 0;
            border-radius: 3px;
            background-color: #f1f8ff;
        }
        
        .mst-item {
            background-color: #e8f5e9;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
        }
    </style>
</head>
<body>
    <header>
        <h1>Kruskal's Algorithm Visualization</h1>
        <p>Find the Minimum Spanning Tree (MST) of a weighted graph</p>
    </header>
    
    <div class="container">
        <div class="graph-container">
            <h2>Graph Visualization</h2>
            <svg id="graphCanvas" width="100%" height="400"></svg>
        </div>
        
        <div class="control-panel">
            <h2>Controls</h2>
            <div>
                <button id="prevStep">Previous Step</button>
                <button id="nextStep">Next Step</button>
                <button id="reset">Reset</button>
                <button id="autoRun">Auto Run</button>
            </div>
            
            <div class="slider-container">
                <label for="speedSlider">Speed: <span id="speedValue">Medium</span></label>
                <input type="range" id="speedSlider" min="1" max="5" value="3">
            </div>
            
            <div class="progress-indicator">
                <h3>Algorithm Progress</h3>
                <div id="progressText">Ready to start</div>
            </div>
            
            <h3>Edges (sorted by weight)</h3>
            <div id="edgesList" class="edge-list"></div>
            
            <h3>MST Edges</h3>
            <div id="mstEdges" class="edge-list"></div>
        </div>
        
        <div class="explanation">
            <h2>How Kruskal's Algorithm Works</h2>
            
            <div class="step">
                <h3>Step 1: Sort Edges</h3>
                <p>First, we sort all the edges in the graph in non-decreasing order of their weights.</p>
            </div>
            
            <div class="step">
                <h3>Step 2: Initialize Forest</h3>
                <p>We start with a forest where each vertex is its own tree (using a disjoint set/union-find data structure).</p>
            </div>
            
            <div class="step">
                <h3>Step 3: Iterate Through Sorted Edges</h3>
                <p>We iterate through the sorted edges. For each edge:</p>
                <ul>
                    <li>If adding the edge doesn't form a cycle (i.e., the vertices belong to different sets), we add it to the MST</li>
                    <li>If adding the edge forms a cycle (vertices belong to the same set), we skip it</li>
                </ul>
            </div>
            
            <div class="step">
                <h3>Step 4: Completion</h3>
                <p>We continue this process until we have selected (V-1) edges, where V is the number of vertices in the graph.</p>
            </div>
            
            <div class="step">
                <h3>Time Complexity</h3>
                <p>The time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices.</p>
            </div>
        </div>
    </div>

    <script>
        // Graph data structure
        class Graph {
            constructor() {
                this.vertices = [];
                this.edges = [];
            }
            
            addVertex(x, y, label) {
                this.vertices.push({ id: this.vertices.length, x, y, label });
            }
            
            addEdge(v1, v2, weight) {
                this.edges.push({ 
                    id: this.edges.length, 
                    v1: this.vertices[v1], 
                    v2: this.vertices[v2], 
                    weight,
                    inMST: false,
                    considered: false
                });
            }
        }
        
        // Disjoint Set (Union-Find) data structure for cycle detection
        class DisjointSet {
            constructor(size) {
                this.parent = new Array(size);
                this.rank = new Array(size);
                
                for (let i = 0; i < size; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 0;
                }
            }
            
            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]); // Path compression
                }
                return this.parent[x];
            }
            
            union(x, y) {
                let rootX = this.find(x);
                let rootY = this.find(y);
                
                if (rootX === rootY) return false; // Already in the same set
                
                // Union by rank
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
                
                return true;
            }
        }
        
        // Visualization controller
        class KruskalVisualizer {
            constructor(graph) {
                this.graph = graph;
                this.currentStep = 0;
                this.animationSpeed = 1000; // ms
                this.edgesSorted = [...this.graph.edges].sort((a, b) => a.weight - b.weight);
                this.disjointSet = new DisjointSet(this.graph.vertices.length);
                this.mstEdges = [];
                this.autoRunInterval = null;
                
                this.initializeDOM();
                this.renderGraph();
                this.updateControls();
            }
            
            initializeDOM() {
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Control buttons
                document.getElementById('prevStep').addEventListener('click', () => this.previousStep());
                document.getElementById('nextStep').addEventListener('click', () => this.nextStep());
                document.getElementById('reset').addEventListener('click', () => this.reset());
                document.getElementById('autoRun').addEventListener('click', () => this.toggleAutoRun());
                
                // Speed slider
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');
                
                speedSlider.addEventListener('input', (e) => {
                    const speed = e.target.value;
                    this.animationSpeed = 2000 - (speed - 1) * 400; // 2000ms to 400ms
                    
                    // Update speed label
                    const speeds = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Very Fast'];
                    speedValue.textContent = speeds[speed - 1];
                    
                    // Update auto-run if active
                    if (this.autoRunInterval) {
                        clearInterval(this.autoRunInterval);
                        this.startAutoRun();
                    }
                });
            }
            
            renderGraph() {
                // Clear canvas
                this.canvas.innerHTML = '';
                
                // Draw edges
                this.graph.edges.forEach(edge => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', edge.v1.x);
                    line.setAttribute('y1', edge.v1.y);
                    line.setAttribute('x2', edge.v2.x);
                    line.setAttribute('y2', edge.v2.y);
                    
                    if (edge.inMST) {
                        line.setAttribute('class', 'mst-edge');
                    } else if (edge.considered) {
                        line.setAttribute('stroke', '#f39c12');
                        line.setAttribute('stroke-width', '3');
                    } else {
                        line.setAttribute('stroke', '#7f8c8d');
                        line.setAttribute('stroke-width', '2');
                    }
                    
                    this.canvas.appendChild(line);
                    
                    // Edge weight label
                    const midX = (edge.v1.x + edge.v2.x) / 2;
                    const midY = (edge.v1.y + edge.v2.y) / 2;
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', midX);
                    text.setAttribute('y', midY - 10);
                    text.setAttribute('class', 'edge-label');
                    text.textContent = edge.weight;
                    
                    this.canvas.appendChild(text);
                });
                
                // Draw vertices
                this.graph.vertices.forEach(vertex => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', vertex.x);
                    circle.setAttribute('cy', vertex.y);
                    circle.setAttribute('r', 20);
                    circle.setAttribute('class', 'node');
                    
                    this.canvas.appendChild(circle);
                    
                    // Vertex label
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', vertex.x);
                    text.setAttribute('y', vertex.y + 5);
                    text.setAttribute('class', 'node-label');
                    text.textContent = vertex.label;
                    
                    this.canvas.appendChild(text);
                });
                
                // Update edge lists
                this.updateEdgeLists();
            }
            
            updateEdgeLists() {
                const edgesList = document.getElementById('edgesList');
                const mstEdgesList = document.getElementById('mstEdges');
                
                edgesList.innerHTML = '';
                mstEdgesList.innerHTML = '';
                
                // Sorted edges list
                this.edgesSorted.forEach((edge, index) => {
                    const edgeItem = document.createElement('div');
                    edgeItem.className = 'edge-item';
                    
                    if (index === this.currentStep && this.currentStep < this.edgesSorted.length) {
                        edgeItem.style.backgroundColor = '#fff3cd';
                    }
                    
                    if (edge.considered) {
                        edgeItem.style.textDecoration = 'line-through';
                        edgeItem.style.color = '#6c757d';
                    }
                    
                    if (edge.inMST) {
                        edgeItem.className += ' mst-item';
                    }
                    
                    edgeItem.textContent = `${edge.v1.label}-${edge.v2.label} (Weight: ${edge.weight})`;
                    edgesList.appendChild(edgeItem);
                });
                
                // MST edges list
                this.mstEdges.forEach(edge => {
                    const edgeItem = document.createElement('div');
                    edgeItem.className = 'edge-item mst-item';
                    edgeItem.textContent = `${edge.v1.label}-${edge.v2.label} (Weight: ${edge.weight})`;
                    mstEdgesList.appendChild(edgeItem);
                });
            }
            
            nextStep() {
                if (this.currentStep >= this.edgesSorted.length) return;
                
                const edge = this.edgesSorted[this.currentStep];
                edge.considered = true;
                
                const v1Index = this.graph.vertices.indexOf(edge.v1);
                const v2Index = this.graph.vertices.indexOf(edge.v2);
                
                // Check if adding this edge creates a cycle
                if (this.disjointSet.union(v1Index, v2Index)) {
                    // No cycle - add to MST
                    edge.inMST = true;
                    this.mstEdges.push(edge);
                    
                    document.getElementById('progressText').textContent = 
                        `Added edge ${edge.v1.label}-${edge.v2.label} to MST (weight: ${edge.weight})`;
                } else {
                    // Cycle would be created - skip this edge
                    document.getElementById('progressText').textContent = 
                        `Skipped edge ${edge.v1.label}-${edge.v2.label} - would create cycle`;
                }
                
                this.currentStep++;
                this.renderGraph();
                this.updateControls();
                
                // Check if MST is complete
                if (this.mstEdges.length === this.graph.vertices.length - 1) {
                    document.getElementById('progressText').textContent = 
                        `MST Complete! Total weight: ${this.calculateMSTWeight()}`;
                    this.stopAutoRun();
                }
            }
            
            previousStep() {
                if (this.currentStep <= 0) return;
                
                this.currentStep--;
                const edge = this.edgesSorted[this.currentStep];
                edge.considered = false;
                
                if (edge.inMST) {
                    edge.inMST = false;
                    this.mstEdges.pop();
                    
                    // Reset the union operation (simplified - in a real scenario we'd need to track operations)
                    // For visualization purposes, we'll just reset the disjoint set
                    this.resetDisjointSet();
                    
                    // Reapply all MST edges up to the previous step
                    for (let i = 0; i < this.currentStep; i++) {
                        const prevEdge = this.edgesSorted[i];
                        if (prevEdge.inMST) {
                            const v1Index = this.graph.vertices.indexOf(prevEdge.v1);
                            const v2Index = this.graph.vertices.indexOf(prevEdge.v2);
                            this.disjointSet.union(v1Index, v2Index);
                        }
                    }
                }
                
                this.renderGraph();
                this.updateControls();
                document.getElementById('progressText').textContent = `Step ${this.currentStep}`;
            }
            
            resetDisjointSet() {
                this.disjointSet = new DisjointSet(this.graph.vertices.length);
            }
            
            reset() {
                this.currentStep = 0;
                this.mstEdges = [];
                this.resetDisjointSet();
                
                this.graph.edges.forEach(edge => {
                    edge.inMST = false;
                    edge.considered = false;
                });
                
                this.renderGraph();
                this.updateControls();
                document.getElementById('progressText').textContent = 'Ready to start';
                this.stopAutoRun();
            }
            
            updateControls() {
                document.getElementById('prevStep').disabled = this.currentStep === 0;
                document.getElementById('nextStep').disabled