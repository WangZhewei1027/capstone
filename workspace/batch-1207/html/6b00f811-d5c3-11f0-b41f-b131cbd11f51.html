<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            max-width: 1000px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .description {
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto 20px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1000px;
        }
        
        .controls {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-weight: 600;
        }
        
        select, input, button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
        }
        
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .visualization {
            flex: 1;
            min-width: 600px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            position: relative;
            height: 500px;
        }
        
        #graph {
            width: 100%;
            height: 100%;
        }
        
        .queue-display {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            width: 100%;
            max-width: 1000px;
            margin-top: 20px;
            min-height: 70px;
        }
        
        .queue-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        #queue-elements {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .queue-element {
            background: #2196F3;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .queue-element.current {
            background: #FF9800;
            transform: scale(1.1);
        }
        
        .queue-element.visited {
            background: #4CAF50;
        }
        
        .status {
            margin-top: 10px;
            font-style: italic;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .unvisited { background: #2196F3; }
        .visited { background: #4CAF50; }
        .current { background: #FF9800; }
        
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .visualization {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Breadth-First Search (BFS) Visualization</h1>
        <div class="description">
            <p>Breadth-First Search (BFS) is a graph traversal algorithm that explores all the neighbor nodes at the present depth before moving on to nodes at the next depth level. It uses a queue data structure to keep track of nodes to visit.</p>
            <p>Use the controls below to select a graph and start node, then visualize the BFS algorithm step by step.</p>
        </div>
    </header>
    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="graph-select">Graph Structure:</label>
                <select id="graph-select">
                    <option value="simple">Simple Graph</option>
                    <option value="tree">Tree Structure</option>
                    <option value="complex">Complex Graph</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="start-node">Start Node:</label>
                <select id="start-node">
                    <option value="0">Node 0</option>
                    <option value="1">Node 1</option>
                    <option value="2">Node 2</option>
                    <option value="3">Node 3</option>
                    <option value="4">Node 4</option>
                    <option value="5">Node 5</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="speed">Animation Speed:</label>
                <input type="range" id="speed" min="100" max="2000" value="800">
            </div>
            
            <button id="start-btn">Start BFS</button>
            <button id="step-btn" disabled>Next Step</button>
            <button id="reset-btn">Reset</button>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color unvisited"></div>
                    <span>Unvisited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color current"></div>
                    <span>Current</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color visited"></div>
                    <span>Visited</span>
                </div>
            </div>
        </div>
        
        <div class="visualization">
            <canvas id="graph"></canvas>
        </div>
    </div>
    
    <div class="queue-display">
        <div class="queue-title">BFS Queue:</div>
        <div id="queue-elements"></div>
        <div class="status" id="status">Click "Start BFS" to begin visualization</div>
    </div>

    <script>
        // Graph data structures
        const graphs = {
            simple: {
                nodes: [
                    { id: 0, x: 150, y: 250 },
                    { id: 1, x: 300, y: 150 },
                    { id: 2, x: 300, y: 350 },
                    { id: 3, x: 450, y: 250 }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 1, to: 3 },
                    { from: 2, to: 3 }
                ]
            },
            tree: {
                nodes: [
                    { id: 0, x: 300, y: 100 },
                    { id: 1, x: 200, y: 200 },
                    { id: 2, x: 400, y: 200 },
                    { id: 3, x: 150, y: 300 },
                    { id: 4, x: 250, y: 300 },
                    { id: 5, x: 350, y: 300 },
                    { id: 6, x: 450, y: 300 }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 1, to: 3 },
                    { from: 1, to: 4 },
                    { from: 2, to: 5 },
                    { from: 2, to: 6 }
                ]
            },
            complex: {
                nodes: [
                    { id: 0, x: 150, y: 150 },
                    { id: 1, x: 300, y: 100 },
                    { id: 2, x: 450, y: 150 },
                    { id: 3, x: 150, y: 300 },
                    { id: 4, x: 300, y: 350 },
                    { id: 5, x: 450, y: 300 }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 0, to: 3 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 },
                    { from: 2, to: 5 },
                    { from: 3, to: 4 },
                    { from: 4, to: 5 },
                    { from: 1, to: 4 }
                ]
            }
        };

        // Canvas setup
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawGraph();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // BFS Algorithm State
        let bfsState = {
            queue: [],
            visited: new Set(),
            currentNode: null,
            animationId: null,
            speed: 800,
            isRunning: false
        };
        
        // DOM Elements
        const graphSelect = document.getElementById('graph-select');
        const startNodeSelect = document.getElementById('start-node');
        const speedSlider = document.getElementById('speed');
        const startBtn = document.getElementById('start-btn');
        const stepBtn = document.getElementById('step-btn');
        const resetBtn = document.getElementById('reset-btn');
        const queueElements = document.getElementById('queue-elements');
        const status = document.getElementById('status');
        
        // Initialize
        let currentGraph = graphs[graphSelect.value];
        updateStartNodeOptions();
        
        // Event Listeners
        graphSelect.addEventListener('change', function() {
            currentGraph = graphs[this.value];
            updateStartNodeOptions();
            resetBFS();
            drawGraph();
        });
        
        startNodeSelect.addEventListener('change', resetBFS);
        
        speedSlider.addEventListener('input', function() {
            bfsState.speed = 2100 - this.value; // Invert so faster means smaller number
        });
        
        startBtn.addEventListener('click', startBFS);
        stepBtn.addEventListener('click', nextStep);
        resetBtn.addEventListener('click', resetBFS);
        
        function updateStartNodeOptions() {
            // Clear existing options
            startNodeSelect.innerHTML = '';
            
            // Add options based on current graph
            currentGraph.nodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `Node ${node.id}`;
                startNodeSelect.appendChild(option);
            });
        }
        
        function drawGraph() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            
            currentGraph.edges.forEach(edge => {
                const fromNode = currentGraph.nodes[edge.from];
                const toNode = currentGraph.nodes[edge.to];
                
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.stroke();
            });
            
            // Draw nodes
            currentGraph.nodes.forEach(node => {
                let color = '#2196F3'; // Default unvisited
                
                if (bfsState.visited.has(node.id)) {
                    color = '#4CAF50'; // Visited
                } else if (node.id === bfsState.currentNode) {
                    color = '#FF9800'; // Current
                }
                
                // Node circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Node border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Node label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.x, node.y);
            });
        }
        
        function updateQueueDisplay() {
            queueElements.innerHTML = '';
            
            bfsState.queue.forEach(nodeId => {
                const element = document.createElement('div');
                element.className = 'queue-element';
                if (nodeId === bfsState.currentNode) {
                    element.classList.add('current');
                } else if (bfsState.visited.has(nodeId)) {
                    element.classList.add('visited');
                }
                element.textContent = nodeId;
                queueElements.appendChild(element);
            });
        }
        
        function startBFS() {
            if (bfsState.isRunning) return;
            
            resetBFS();
            bfsState.isRunning = true;
            startBtn.disabled = true;
            stepBtn.disabled = true;
            
            const startNode = parseInt(startNodeSelect.value);
            bfsState.queue.push(startNode);
            bfsState.visited.add(startNode);
            
            updateQueueDisplay();
            drawGraph();
            status.textContent = `BFS started from node ${startNode}`;
            
            // Start animation
            bfsState.animationId = setInterval(performBFSStep, bfsState.speed);
        }
        
        function nextStep() {
            if (bfsState.isRunning) return;
            
            if (bfsState.queue.length === 0) {
                status.textContent = 'BFS completed!';
                stepBtn.disabled = true;
                return;
            }
            
            performBFSStep();
        }
        
        function performBFSStep() {
            if (bfsState.queue.length === 0) {
                // BFS completed
                clearInterval(bfsState.animationId);
                bfsState.isRunning = false;
                startBtn.disabled = false;
                status.textContent = 'BFS completed! All nodes have been visited.';
                return;
            }
            
            // Dequeue the front node
            const currentNode = bfsState.queue.shift();
            bfsState.currentNode = currentNode;
            
            status.textContent = `Visiting node ${currentNode}`;
            
            // Find all neighbors of the current node
            const neighbors = [];
            currentGraph.edges.forEach(edge => {
                if (edge.from === currentNode && !bfsState.visited.has(edge.to)) {
                    neighbors.push(edge.to);
                } else if (edge.to === currentNode && !bfsState.visited.has(edge.from)) {
                    neighbors.push(edge.from);
                }
            });
            
            // Add unvisited neighbors to the queue
            neighbors.forEach(neighbor => {
                if (!bfsState.visited.has(neighbor)) {
                    bfsState.visited.add(neighbor);
                    bfsState.queue.push(neighbor);
                }
            });
            
            updateQueueDisplay();
            drawGraph();
            
            // If we're in step mode and the queue is empty, disable step button
            if (!bfsState.isRunning && bfsState.queue.length === 0) {
                stepBtn.disabled = true;
                status.textContent = 'BFS completed!';
            }
        }
        
        function resetBFS() {
            // Clear any running animation
            clearInterval(bfsState.animationId);
            
            // Reset BFS state
            bfsState.queue = [];
            bfsState.visited = new Set();
            bfsState.currentNode = null;
            bfsState.isRunning = false;
            
            // Reset UI
            startBtn.disabled = false;
            stepBtn.disabled = false;
            status.textContent = 'Graph ready. Click "Start BFS" to begin visualization';
            
            // Redraw graph and update queue display
            updateQueueDisplay();
            drawGraph();
        }
        
        // Enable step-by-step mode
        startBtn.addEventListener('click', function() {
            if (this.textContent === 'Start BFS') {
                this.textContent = 'Pause BFS';
                startBFS();
            } else {
                this.textContent = 'Resume BFS';
                clearInterval(bfsState.animationId);
                bfsState.isRunning = false;
                stepBtn.disabled = false;
            }
        });
        
        // Initial draw
        drawGraph();
    </script>
</body>
</html>