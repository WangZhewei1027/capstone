<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjacency List Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }
        .input-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .visualization-section {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .node {
            fill: #4CAF50;
            stroke: #333;
            stroke-width: 2px;
        }
        .edge {
            stroke: #666;
            stroke-width: 2px;
            fill: none;
        }
        .edge-label {
            font-size: 12px;
            fill: #333;
        }
        .node-label {
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
        }
        .adjacency-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .adjacency-table th, .adjacency-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .adjacency-table th {
            background-color: #f2f2f2;
        }
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4fd;
            border-radius: 4px;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Adjacency List Visualization</h1>
    
    <div class="container">
        <div class="input-section">
            <h3>Input Graph Data</h3>
            <textarea id="graphInput" placeholder="Enter graph data in adjacency list format:
Example:
A: B, C
B: A, D
C: A, D
D: B, C, E
E: D

Or use weighted format:
A: B(2), C(3)
B: A(2), D(1)
C: A(3), D(4)
D: B(1), C(4), E(5)
E: D(5)">A: B, C
B: A, D
C: A, D
D: B, C, E
E: D</textarea>
            <button onclick="visualizeGraph()">Visualize Graph</button>
            <button onclick="clearGraph()">Clear</button>
            <button onclick="loadExample()">Load Example</button>
            
            <div class="info-panel">
                <h4>What is an Adjacency List?</h4>
                <p>An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph.</p>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>Space-efficient for sparse graphs</li>
                    <li>Fast to iterate over all edges</li>
                    <li>Easy to add/remove vertices</li>
                </ul>
                <p><strong>Complexity:</strong> O(V + E) space, O(degree(v)) time to check adjacency</p>
            </div>
        </div>
        
        <div class="visualization-section">
            <h3>Graph Visualization</h3>
            <svg id="graphSVG" width="100%" height="400"></svg>
            <div id="adjacencyTable"></div>
            <div id="error" class="error"></div>
        </div>
    </div>

    <script>
        class Graph {
            constructor() {
                this.vertices = new Map();
            }
            
            addVertex(vertex) {
                if (!this.vertices.has(vertex)) {
                    this.vertices.set(vertex, []);
                }
            }
            
            addEdge(from, to, weight = 1) {
                this.addVertex(from);
                this.addVertex(to);
                this.vertices.get(from).push({ node: to, weight });
            }
            
            parseAdjacencyList(input) {
                this.vertices.clear();
                const lines = input.split('\n').filter(line => line.trim() !== '');
                
                for (const line of lines) {
                    const [vertexPart, neighborsPart] = line.split(':').map(part => part.trim());
                    const vertex = vertexPart.trim();
                    
                    if (!vertex) continue;
                    
                    this.addVertex(vertex);
                    
                    if (neighborsPart) {
                        const neighbors = neighborsPart.split(',').map(n => n.trim());
                        for (const neighbor of neighbors) {
                            if (neighbor) {
                                const weightMatch = neighbor.match(/(\w+)\((\d+)\)/);
                                if (weightMatch) {
                                    this.addEdge(vertex, weightMatch[1], parseInt(weightMatch[2]));
                                } else {
                                    this.addEdge(vertex, neighbor);
                                }
                            }
                        }
                    }
                }
            }
            
            getAdjacencyMatrix() {
                const vertices = Array.from(this.vertices.keys()).sort();
                const matrix = [];
                
                // Initialize matrix with zeros
                for (let i = 0; i < vertices.length; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < vertices.length; j++) {
                        matrix[i][j] = 0;
                    }
                }
                
                // Fill matrix with weights
                for (let i = 0; i < vertices.length; i++) {
                    const vertex = vertices[i];
                    const neighbors = this.vertices.get(vertex);
                    
                    for (const neighbor of neighbors) {
                        const j = vertices.indexOf(neighbor.node);
                        matrix[i][j] = neighbor.weight;
                    }
                }
                
                return { matrix, vertices };
            }
        }

        function visualizeGraph() {
            const input = document.getElementById('graphInput').value;
            const errorDiv = document.getElementById('error');
            const svg = document.getElementById('graphSVG');
            const tableDiv = document.getElementById('adjacencyTable');
            
            errorDiv.textContent = '';
            svg.innerHTML = '';
            tableDiv.innerHTML = '';
            
            if (!input.trim()) {
                errorDiv.textContent = 'Please enter graph data.';
                return;
            }
            
            try {
                const graph = new Graph();
                graph.parseAdjacencyList(input);
                
                if (graph.vertices.size === 0) {
                    errorDiv.textContent = 'No valid graph data found.';
                    return;
                }
                
                drawGraph(svg, graph);
                displayAdjacencyTable(tableDiv, graph);
                
            } catch (error) {
                errorDiv.textContent = 'Error parsing graph data: ' + error.message;
            }
        }
        
        function drawGraph(svg, graph) {
            const vertices = Array.from(graph.vertices.keys());
            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            
            // Calculate node positions in a circle
            const positions = {};
            const angleStep = (2 * Math.PI) / vertices.length;
            
            vertices.forEach((vertex, index) => {
                const angle = index * angleStep;
                positions[vertex] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            // Draw edges
            let edgeId = 0;
            for (const [fromVertex, neighbors] of graph.vertices) {
                for (const neighbor of neighbors) {
                    const fromPos = positions[fromVertex];
                    const toPos = positions[neighbor.node];
                    
                    // Check if reverse edge already drawn to avoid duplicates
                    if (fromVertex < neighbor.node || 
                        !graph.vertices.get(neighbor.node).some(n => n.node === fromVertex)) {
                        
                        drawEdge(svg, fromPos, toPos, neighbor.weight, edgeId++);
                    }
                }
            }
            
            // Draw nodes
            for (const vertex of vertices) {
                const pos = positions[vertex];
                drawNode(svg, pos.x, pos.y, vertex);
            }
        }
        
        function drawEdge(svg, from, to, weight, id) {
            const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            edge.setAttribute('class', 'edge');
            edge.setAttribute('x1', from.x);
            edge.setAttribute('y1', from.y);
            edge.setAttribute('x2', to.x);
            edge.setAttribute('y2', to.y);
            edge.setAttribute('id', 'edge-' + id);
            svg.appendChild(edge);
            
            // Add weight label for weighted edges
            if (weight !== 1) {
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'edge-label');
                label.setAttribute('x', (from.x + to.x) / 2);
                label.setAttribute('y', (from.y + to.y) / 2 - 5);
                label.textContent = weight;
                svg.appendChild(label);
            }
            
            // Add arrowhead for directed edges (optional enhancement)
            // This could be added to show directionality
        }
        
        function drawNode(svg, x, y, label) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('class', 'node');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', 20);
            group.appendChild(circle);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('class', 'node-label');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.textContent = label;
            group.appendChild(text);
            
            svg.appendChild(group);
        }
        
        function displayAdjacencyTable(container, graph) {
            const { matrix, vertices } = graph.getAdjacencyMatrix();
            
            let html = '<h3>Adjacency List Representation</h3>';
            html += '<table class="adjacency-table"><thead><tr><th>Vertex</th><th>Adjacent Vertices</th></tr></thead><tbody>';
            
            for (const [vertex, neighbors] of graph.vertices) {
                const neighborList = neighbors.map(n => 
                    n.weight !== 1 ? `${n.node}(${n.weight})` : n.node
                ).join(', ');
                html += `<tr><td><strong>${vertex}</strong></td><td>${neighborList}</td></tr>`;
            }
            
            html += '</tbody></table>';
            
            // Add adjacency matrix
            html += '<h3>Adjacency Matrix</h3>';
            html += '<table class="adjacency-table"><thead><tr><th></th>';
            
            for (const vertex of vertices) {
                html += `<th>${vertex}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            for (let i = 0; i < vertices.length; i++) {
                html += `<tr><td><strong>${vertices[i]}</strong></td>`;
                for (let j = 0; j < vertices.length; j++) {
                    html += `<td>${matrix[i][j]}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }
        
        function clearGraph() {
            document.getElementById('graphInput').value = '';
            document.getElementById('graphSVG').innerHTML = '';
            document.getElementById('adjacencyTable').innerHTML = '';
            document.getElementById('error').textContent = '';
        }
        
        function loadExample() {
            document.getElementById('graphInput').value = `A: B(2), C(3)
B: A(2), D(1)
C: A(3), D(4)
D: B(1), C(4), E(5)
E: D(5)`;
            visualizeGraph();
        }
        
        // Initialize with example graph
        window.onload = visualizeGraph;
    </script>
</body>
</html>