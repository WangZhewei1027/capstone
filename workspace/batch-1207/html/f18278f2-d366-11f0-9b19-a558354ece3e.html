<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering Visualization</title>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        canvas {
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background: white;
        }
        .cluster-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .cluster-card {
            padding: 10px;
            border-radius: 5px;
            flex: 1;
            min-height: 60px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        label {
            margin-right: 10px;
        }
        .status {
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>K-Means Clustering Visualization</h1>
        
        <div class="controls">
            <div>
                <label for="kValue">Number of Clusters (K):</label>
                <input type="range" id="kValue" min="2" max="8" value="3">
                <span id="kDisplay">3</span>
            </div>
            <div>
                <label for="pointCount">Number of Points:</label>
                <input type="range" id="pointCount" min="50" max="300" value="150">
                <span id="pointCountDisplay">150</span>
            </div>
            <div>
                <button id="generatePoints">Generate Random Points</button>
                <button id="runKMeans">Run K-Means</button>
                <button id="stepKMeans">Step Through</button>
                <button id="reset">Reset</button>
            </div>
            <div class="status" id="status">Ready - Click "Generate Random Points" to start</div>
        </div>

        <div class="cluster-info" id="clusterInfo"></div>
        
        <canvas id="canvas" width="1000" height="600"></canvas>
        
        <div>
            <h3>How K-Means Clustering Works:</h3>
            <ol>
                <li><strong>Initialization:</strong> Randomly select K points as initial cluster centroids</li>
                <li><strong>Assignment:</strong> Assign each data point to the nearest centroid</li>
                <li><strong>Update:</strong> Recalculate centroids as the mean of all points in the cluster</li>
                <li><strong>Repeat:</strong> Continue steps 2-3 until convergence (no more changes)</li>
            </ol>
        </div>
    </div>

    <script>
        class KMeans {
            constructor(k, points) {
                this.k = k;
                this.points = points;
                this.centroids = [];
                this.clusters = [];
                this.iterations = 0;
                this.converged = false;
            }

            initializeCentroids() {
                this.centroids = [];
                const indices = new Set();
                while (indices.size < this.k) {
                    indices.add(Math.floor(Math.random() * this.points.length));
                }
                indices.forEach(idx => {
                    this.centroids.push({...this.points[idx]});
                });
            }

            assignPointsToClusters() {
                this.clusters = Array(this.k).fill().map(() => []);
                
                this.points.forEach(point => {
                    let minDistance = Infinity;
                    let closestCentroid = 0;
                    
                    this.centroids.forEach((centroid, index) => {
                        const distance = this.calculateDistance(point, centroid);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCentroid = index;
                        }
                    });
                    
                    this.clusters[closestCentroid].push(point);
                });
            }

            updateCentroids() {
                let changed = false;
                
                this.centroids.forEach((centroid, index) => {
                    if (this.clusters[index].length === 0) return;
                    
                    const newX = this.clusters[index].reduce((sum, p) => sum + p.x, 0) / this.clusters[index].length;
                    const newY = this.clusters[index].reduce((sum, p) => sum + p.y, 0) / this.clusters[index].length;
                    
                    if (Math.abs(newX - centroid.x) > 0.01 || Math.abs(newY - centroid.y) > 0.01) {
                        changed = true;
                    }
                    
                    centroid.x = newX;
                    centroid.y = newY;
                });
                
                return changed;
            }

            calculateDistance(point1, point2) {
                return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
            }

            step() {
                if (this.iterations === 0) {
                    this.initializeCentroids();
                } else {
                    const changed = this.updateCentroids();
                    if (!changed) {
                        this.converged = true;
                        return false;
                    }
                }
                
                this.assignPointsToClusters();
                this.iterations++;
                return !this.converged;
            }

            run(maxIterations = 100) {
                this.initializeCentroids();
                
                for (let i = 0; i < maxIterations; i++) {
                    this.assignPointsToClusters();
                    const changed = this.updateCentroids();
                    
                    if (!changed) {
                        this.converged = true;
                        break;
                    }
                }
                
                this.iterations = maxIterations;
            }
        }

        class KMeansVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.kMeans = null;
                this.colors = [
                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
                    '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43'
                ];
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('kValue').addEventListener('input', (e) => {
                    document.getElementById('kDisplay').textContent = e.target.value;
                });

                document.getElementById('pointCount').addEventListener('input', (e) => {
                    document.getElementById('pointCountDisplay').textContent = e.target.value;
                });

                document.getElementById('generatePoints').addEventListener('click', () => {
                    this.generateRandomPoints();
                });

                document.getElementById('runKMeans').addEventListener('click', () => {
                    this.runKMeans();
                });

                document.getElementById('stepKMeans').addEventListener('click', () => {
                    this.stepKMeans();
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.reset();
                });
            }

            generateRandomPoints() {
                const pointCount = parseInt(document.getElementById('pointCount').value);
                const k = parseInt(document.getElementById('kValue').value);
                
                const points = [];
                const padding = 50;
                
                // Generate points in different regions to create natural clusters
                const regions = [];
                for (let i = 0; i < k; i++) {
                    regions.push({
                        x: padding + Math.random() * (this.canvas.width - 2 * padding),
                        y: padding + Math.random() * (this.canvas.height - 2 * padding)
                    });
                }
                
                for (let i = 0; i < pointCount; i++) {
                    const region = regions[i % regions.length];
                    const spread = 80 + Math.random() * 50;
                    
                    points.push({
                        x: region.x + (Math.random() - 0.5) * spread,
                        y: region.y + (Math.random() - 0.5) * spread
                    });
                }
                
                this.kMeans = new KMeans(k, points);
                this.draw();
                document.getElementById('status').textContent = `Generated ${pointCount} points. Ready to run K-Means.`;
            }

            runKMeans() {
                if (!this.kMeans) {
                    document.getElementById('status').textContent = 'Please generate points first.';
                    return;
                }
                
                this.kMeans.run();
                this.draw();
                this.updateClusterInfo();
                document.getElementById('status').textContent = 
                    `K-Means completed in ${this.kMeans.iterations} iterations. ${this.kMeans.converged ? 'Converged!' : 'Reached max iterations.'}`;
            }

            stepKMeans() {
                if (!this.kMeans) {
                    document.getElementById('status').textContent = 'Please generate points first.';
                    return;
                }
                
                const canContinue = this.kMeans.step();
                this.draw();
                this.updateClusterInfo();
                
                if (this.kMeans.converged) {
                    document.getElementById('status').textContent = 
                        `K-Means converged after ${this.kMeans.iterations} iterations.`;
                } else {
                    document.getElementById('status').textContent = 
                        `Iteration ${this.kMeans.iterations}. Click "Step Through" to continue.`;
                }
            }

            reset() {
                this.kMeans = null;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                document.getElementById('clusterInfo').innerHTML = '';
                document.getElementById('status').textContent = 'Reset. Click "Generate Random Points" to start.';
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.kMeans) return;
                
                // Draw points
                this.kMeans.points.forEach(point => {
                    let clusterIndex = -1;
                    
                    this.kMeans.clusters.forEach((cluster, index) => {
                        if (cluster.includes(point)) {
                            clusterIndex = index;
                        }
                    });
                    
                    if (clusterIndex !== -1) {
                        this.ctx.fillStyle = this.colors[clusterIndex % this.colors.length];
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });
                
                // Draw centroids
                this.kMeans.centroids.forEach((centroid, index) => {
                    this.ctx.fillStyle = this.colors[index % this.colors.length];
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(centroid.x, centroid.y, 8, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Draw centroid label
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(`C${index + 1}`, centroid.x + 10, centroid.y - 10);
                });
            }

            updateClusterInfo() {
                if (!this.kMeans) return;
                
                const clusterInfo = document.getElementById('clusterInfo');
                clusterInfo.innerHTML = '';
                
                this.kMeans.clusters.forEach((cluster, index) => {
                    const card = document.createElement('div');
                    card.className = 'cluster-card';
                    card.style.backgroundColor = this.colors[index % this.colors.length] + '40'; // Add transparency
                    card.style.border = `2px solid ${this.colors[index % this.colors.length]}`;
                    
                    const centroid = this.kMeans.centroids[index];
                    card.innerHTML = `
                        <strong>Cluster ${index + 1}</strong><br>
                        Points: ${cluster.length}<br>
                        Centroid: (${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})
                    `;
                    
                    clusterInfo.appendChild(card);
                });
            }
        }

        // Initialize the visualizer when the page loads
        window.addEventListener('load', () => {
            new KMeansVisualizer('canvas');
        });
    </script>
</body>
</html>