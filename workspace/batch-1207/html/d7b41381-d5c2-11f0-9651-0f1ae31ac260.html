<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kruskal's Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
    background: #f0f2f5;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  #graph-container {
    display: flex;
    justify-content: center;
    margin: 1rem auto;
    max-width: 800px;
    position: relative;
  }
  svg {
    border: 1px solid #ccc;
    background: white;
    border-radius: 8px;
  }
  .edge {
    stroke: #999;
    stroke-width: 2px;
    cursor: pointer;
  }
  .edge.in-forest {
    stroke: #27ae60;
    stroke-width: 4px;
  }
  .edge.checked {
    stroke-dasharray: 6 4;
  }
  .edge-text {
    font-size: 14px;
    fill: #222;
    pointer-events: none;
    user-select: none;
  }
  .node {
    fill: #3498db;
    stroke: #2980b9;
    stroke-width: 2px;
    cursor: default;
  }
  .node-text {
    fill: white;
    font-weight: bold;
    user-select: none;
    pointer-events: none;
  }
  #controls {
    text-align: center;
    margin: 1rem 0;
  }
  button {
    background: #2980b9;
    color: white;
    border: none;
    padding: 0.6rem 1rem;
    margin: 0 0.5rem;
    font-size: 1rem;
    border-radius: 4px;
    cursor: pointer;
  }
  button:disabled {
    background: #bbb;
    cursor: default;
  }
  #log {
    max-width: 800px;
    margin: 1rem auto;
    background: #fff;
    border: 1px solid #ccc;
    padding: 0.8rem;
    height: 150px;
    overflow-y: auto;
    font-family: monospace;
    white-space: pre-wrap;
    border-radius: 6px;
  }
</style>
</head>
<body>
<h1>Kruskal's Algorithm Visualization</h1>
<div id="graph-container">
  <svg id="graph" width="700" height="500"></svg>
</div>
<div id="controls">
  <button id="step-btn">Next Step</button>
  <button id="reset-btn">Reset</button>
</div>
<div id="log" aria-live="polite" aria-atomic="true"></div>

<script>
  /*
    We will visualize Kruskal's Algorithm step-by-step on a fixed weighted undirected graph.
    Nodes placed in static positions.
    Edges sorted by weight, each step tries to add next edge without creating cycle.
  */

  const svg = document.getElementById('graph');
  const stepBtn = document.getElementById('step-btn');
  const resetBtn = document.getElementById('reset-btn');
  const log = document.getElementById('log');

  // Graph data: nodes with x,y positions; edges with weights
  // This is an example graph with 7 nodes.
  const nodes = [
    {id: 'A', x: 100, y: 100},
    {id: 'B', x: 300, y: 80},
    {id: 'C', x: 500, y: 100},
    {id: 'D', x: 600, y: 300},
    {id: 'E', x: 400, y: 350},
    {id: 'F', x: 200, y: 300},
    {id: 'G', x: 350, y: 200}
  ];

  const edges = [
    {id: 'AB', from: 'A', to: 'B', weight: 7},
    {id: 'AC', from: 'A', to: 'C', weight: 9},
    {id: 'AF', from: 'A', to: 'F', weight: 14},
    {id: 'BC', from: 'B', to: 'C', weight: 10},
    {id: 'BG', from: 'B', to: 'G', weight: 15},
    {id: 'CG', from: 'C', to: 'G', weight: 11},
    {id: 'CF', from: 'C', to: 'F', weight: 2},
    {id: 'GF', from: 'G', to: 'F', weight: 9},
    {id: 'ED', from: 'E', to: 'D', weight: 6},
    {id: 'FE', from: 'F', to: 'E', weight: 9},
    {id: 'GD', from: 'G', to: 'D', weight: 7}
  ];

  // Sort edges by ascending weight for Kruskal
  const edgesSorted = [...edges].sort((a,b) => a.weight - b.weight);

  // Disjoint Set (Union-Find) to detect cycles
  class DisjointSet {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      elements.forEach(el => {
        this.parent[el] = el;
        this.rank[el] = 0;
      });
    }
    find(x) {
      if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]);
      }
      return this.parent[x];
    }
    union(x, y) {
      const rootX = this.find(x);
      const rootY = this.find(y);
      if(rootX === rootY) return false;
      if(this.rank[rootX] < this.rank[rootY]) {
        this.parent[rootX] = rootY;
      } else if(this.rank[rootX] > this.rank[rootY]) {
        this.parent[rootY] = rootX;
      } else {
        this.parent[rootY] = rootX;
        this.rank[rootX]++;
      }
      return true;
    }
  }

  // State for algorithm
  let ds;
  let stepIndex = 0;
  let mstEdges = [];

  // Keep track of SVG elements for interaction
  let edgeElements = new Map();

  // Drawing functions
  function createEdgeLine(edge) {
    const fromNode = nodes.find(n=>n.id === edge.from);
    const toNode = nodes.find(n=>n.id === edge.to);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', fromNode.x);
    line.setAttribute('y1', fromNode.y);
    line.setAttribute('x2', toNode.x);
    line.setAttribute('y2', toNode.y);
    line.setAttribute('class', 'edge');
    line.setAttribute('id', edge.id);
    line.setAttribute('tabindex', '0');
    line.setAttribute('aria-label', `Edge ${edge.from} to ${edge.to}, weight ${edge.weight}`);
    return line;
  }
  function createEdgeLabel(edge) {
    const fromNode = nodes.find(n=>n.id === edge.from);
    const toNode = nodes.find(n=>n.id === edge.to);
    const midX = (fromNode.x + toNode.x)/2;
    const midY = (fromNode.y + toNode.y)/2;
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', midX);
    text.setAttribute('y', midY - 5);
    text.setAttribute('class', 'edge-text');
    text.textContent = edge.weight;
    return text;
  }
  function createNodeCircle(node) {
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', 20);
    circle.setAttribute('class', 'node');
    circle.setAttribute('id', 'node-' + node.id);
    circle.setAttribute('aria-label', `Node ${node.id}`);
    return circle;
  }
  function createNodeLabel(node) {
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', node.x);
    text.setAttribute('y', node.y + 6);
    text.setAttribute('class', 'node-text');
    text.setAttribute('text-anchor', 'middle');
    text.textContent = node.id;
    return text;
  }

  function clearGraph() {
    while(svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    edgeElements.clear();
  }

  function drawGraph() {
    clearGraph();

    // Draw edges first (under nodes)
    edges.forEach(edge => {
      const line = createEdgeLine(edge);
      svg.appendChild(line);
      const label = createEdgeLabel(edge);
      svg.appendChild(label);
      edgeElements.set(edge.id, line);
    });

    // Draw nodes on top
    nodes.forEach(node => {
      const circle = createNodeCircle(node);
      svg.appendChild(circle);
      const label = createNodeLabel(node);
      svg.appendChild(label);
    });
  }

  function logMessage(msg) {
    log.textContent += msg + "\n";
    log.scrollTop = log.scrollHeight;
  }

  function reset() {
    ds = new DisjointSet(nodes.map(n=>n.id));
    stepIndex = 0;
    mstEdges = [];
    drawGraph();
    log.textContent = '';
    stepBtn.disabled = false;
    logMessage("Algorithm reset. Ready to run Kruskal's Algorithm.");
  }

  function step() {
    if(stepIndex >= edgesSorted.length) {
      logMessage("All edges processed. Algorithm complete.");
      stepBtn.disabled = true;
      return;
    }

    const edge = edgesSorted[stepIndex];
    stepIndex++;

    const line = edgeElements.get(edge.id);
    // Mark this edge as checked: dashed line
    line.classList.add('checked');

    logMessage(`Considering edge (${edge.from} - ${edge.to}) with weight ${edge.weight}.`);

    if(ds.union(edge.from, edge.to)){
      // Edge added to MST
      mstEdges.push(edge);
      line.classList.add('in-forest');
      logMessage(`Edge added to MST.`);
    } else {
      logMessage(`Edge creates a cycle and is skipped.`);
    }

    // After processing last edge or when MST has n-1 edges, disable step
    if(mstEdges.length === nodes.length - 1) {
      logMessage("Minimum Spanning Tree completed!");
      stepBtn.disabled = true;
    }
  }

  stepBtn.addEventListener('click', ()=> {
    step();
  });

  resetBtn.addEventListener('click', () => {
    reset();
  });

  // Initial draw
  reset();

</script>
</body>
</html>