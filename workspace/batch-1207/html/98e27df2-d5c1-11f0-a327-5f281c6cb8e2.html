<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fibonacci Sequence Explorer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color: #111; }
    body { margin: 0; padding: 20px; background: #f7f9fc; }
    h1 { margin: 0 0 8px 0; font-size: 20px; }
    p.lead { margin: 6px 0 16px 0; color: #444; max-width: 900px; }
    .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:12px; }
    .controls > * { background:white; border:1px solid #d6dde6; padding:8px; border-radius:6px; }
    label { font-size:13px; color:#333; display:flex; gap:8px; align-items:center; }
    input[type=range] { width:240px; }
    button { cursor:pointer; border:1px solid #2b76d2; background: linear-gradient(#2f88ff,#1f6ad7); color:white; padding:8px 12px; border-radius:6px; font-weight:600; }
    button.secondary { border:1px solid #999; background: #fff; color:#111; box-shadow:none; }
    .methods { display:flex; gap:8px; flex-wrap:wrap; }
    .grid { display:grid; grid-template-columns: 1fr 420px; gap:16px; align-items:start; }
    .panel { background:white; border:1px solid #e1e8f0; border-radius:8px; padding:12px; }
    .panel h2 { margin:0 0 8px 0; font-size:16px; }
    #sequence { display:flex; gap:6px; flex-wrap:wrap; }
    .term { background:#f1f6ff; border:1px solid #d9e8ff; padding:6px 8px; border-radius:6px; font-family: monospace; font-size:13px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .term.big { background:#fff7e6; border-color:#ffe4b5; }
    .meta { font-size:13px; color:#555; margin-top:8px; }
    canvas { width:100%; height:220px; background: linear-gradient(180deg,#ffffff,#f6fbff); border-radius:6px; display:block; }
    .small { font-size:12px; color:#666; }
    .row { display:flex; gap:8px; align-items:center; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .chip { background:#eef6ff; border:1px solid #d9edff; padding:6px 8px; border-radius:999px; font-size:12px; }
    footer { margin-top:18px; font-size:12px; color:#666; }
    .warning { color:#9b2c2c; background:#fff1f1; border:1px solid #ffdede; padding:8px; border-radius:6px; }
    .ratio { margin-top:8px; font-family:monospace; font-size:13px; }
    .controls-column { display:flex; flex-direction:column; gap:8px; }
    @media (max-width:900px){ .grid { grid-template-columns: 1fr; } canvas { height:200px; } }
  </style>
</head>
<body>
  <h1>Fibonacci Sequence Explorer</h1>
  <p class="lead">Generate and visualize Fibonacci numbers. Try different algorithms (iterative, naive recursion, memoized, Binet's formula), animate the construction step-by-step, and watch the ratios converge to the golden ratio φ ≈ 1.618...</p>

  <div class="controls">
    <label>Count:
      <input id="count" type="range" min="0" max="200" value="20">
      <input id="countNumber" type="number" min="0" max="200" value="20" style="width:72px;">
    </label>

    <div class="methods">
      <button id="iterBtn">Iterative</button>
      <button id="recurBtn" class="secondary">Naive Recursion</button>
      <button id="memoBtn">Recursion + Memo</button>
      <button id="binetBtn" class="secondary">Binet (float)</button>
    </div>

    <div class="controls-column" style="margin-left:auto;">
      <label><input id="animateCheckbox" type="checkbox"> Animate construction</label>
      <label class="small">Step speed:
        <input id="speed" type="range" min="10" max="1000" value="120">
      </label>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <h2>Sequence</h2>
      <div id="sequence" aria-live="polite"></div>
      <div class="meta">
        <div id="time" class="small"></div>
        <div id="notes" class="small"></div>
      </div>

      <div class="ratio" id="ratios"></div>
    </div>

    <div class="panel">
      <h2>Visualization</h2>
      <canvas id="canvas" width="600" height="220"></canvas>
      <div class="legend">
        <div class="chip">bars: magnitude</div>
        <div class="chip">hover to see full value</div>
        <div class="chip" id="phiChip">φ ≈ 1.6180339887</div>
      </div>
      <div style="margin-top:8px;">
        <button id="animateBars" class="secondary">Animate Bars</button>
        <button id="downloadBtn" class="secondary">Download as PNG</button>
      </div>
      <div id="canvasHint" class="small" style="margin-top:8px;"></div>
    </div>
  </div>

  <footer>
    Tips: Naive recursion is exponential — it will be slow for n &gt; ~40. Iterative and memoized recursion are fast and can use BigInt to produce exact integers for large n.
  </footer>

  <script>
    // Utilities and Fibonacci implementations (using BigInt for exactness)
    const $ = id => document.getElementById(id);

    function fibIterative(n){
      // returns array of BigInt from F0..Fn
      const out = [];
      if (n >= 0) out.push(0n);
      if (n >= 1) out.push(1n);
      let a = 0n, b = 1n;
      for (let i = 2; i <= n; i++){
        const c = a + b;
        out.push(c);
        a = b; b = c;
      }
      return out;
    }

    function fibNaive(n){
      // naive recursive, returns BigInt
      if (n === 0) return 0n;
      if (n === 1) return 1n;
      return fibNaive(n-1) + fibNaive(n-2);
    }

    function fibMemo(n, memo = {}){
      if (n === 0) return 0n;
      if (n === 1) return 1n;
      if (memo[n] !== undefined) return memo[n];
      memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
      return memo[n];
    }

    function fibMemoArray(n){
      // returns array F0..Fn using memoization
      const arr = [];
      function f(k){
        if (k === 0) return 0n;
        if (k === 1) return 1n;
        if (arr[k] !== undefined) return arr[k];
        arr[k] = f(k-1) + f(k-2);
        return arr[k];
      }
      for (let i = 0; i <= n; i++) f(i);
      return arr;
    }

    function fibBinetArray(n){
      // Uses floating point Binet formula - accurate for small n (n ≲ 70)
      // returns array of Numbers (may lose precision for large n)
      const phi = (1 + Math.sqrt(5)) / 2;
      const psi = (1 - Math.sqrt(5)) / 2;
      const out = [];
      for (let i = 0; i <= n; i++){
        const val = Math.round((Math.pow(phi,i) - Math.pow(psi,i)) / Math.sqrt(5));
        out.push(val);
      }
      return out;
    }

    // DOM and drawing
    const countRange = $('count');
    const countNumber = $('countNumber');
    const sequenceEl = $('sequence');
    const timeEl = $('time');
    const notesEl = $('notes');
    const ratiosEl = $('ratios');
    const animateCheckbox = $('animateCheckbox');
    const speedRange = $('speed');

    // Canvas
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    let currentValues = [];
    let hoverIndex = -1;

    function formatBigInt(n){
      // show as string, but shorten with ellipsis for display element width
      return n.toString();
    }

    function renderSequence(values, highlightIndex = -1){
      currentValues = values.map(v => (typeof v === 'bigint') ? v : BigInt(v));
      sequenceEl.innerHTML = '';
      values.forEach((val, i) => {
        const div = document.createElement('div');
        div.className = 'term' + ((String(val).length > 18) ? ' big' : '');
        div.tabIndex = 0;
        div.title = String(val);
        if (i === highlightIndex) div.style.boxShadow = 'inset 0 0 0 2px rgba(90,140,255,0.18)';
        div.textContent = i + ': ' + (typeof val === 'bigint' ? formatBigInt(val) : String(val));
        sequenceEl.appendChild(div);
      });
      renderRatios(values);
      drawBars(values);
    }

    function renderRatios(values){
      if (values.length < 2){
        ratiosEl.textContent = '';
        return;
      }
      const parts = [];
      for (let i = 1; i < values.length; i++){
        // compute ratio F_i / F_{i-1} using Number for display;
        let a = values[i];
        let b = values[i-1];
        // convert to Number safely when possible:
        let ratio;
        try {
          ratio = (typeof a === 'bigint' || typeof b === 'bigint') ? Number(a) / Number(b) : a / b;
        } catch(e) { ratio = NaN; }
        parts.push((i) + ':' + (isFinite(ratio) ? ratio.toFixed(6) : '—'));
        if (i >= 15) break; // avoid too many
      }
      ratiosEl.textContent = 'Ratios (Fi/Fi-1): ' + parts.join('  ');
    }

    function drawBars(values){
      const w = canvas.width = canvas.clientWidth * devicePixelRatio;
      const h = canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);
      if (!values || values.length === 0) return;
      // convert to numbers by normalizing to last value; use logarithmic scale for very large numbers
      const last = values[values.length-1];
      const useLog = true; // helps scale across many magnitudes
      // convert to numeric magnitude by length of decimal digits if BigInt
      const magnitudes = values.map(v => {
        const s = typeof v === 'bigint' ? v.toString() : String(Math.abs(v));
        // remove sign
        const digits = s.replace(/^-/, '').length;
        // approximate numeric magnitude for plotting by digits and first few digits
        const leading = Number(s.slice(0,6));
        return {digits, leading, raw: v};
      });
      const maxDigits = Math.max(...magnitudes.map(m => m.digits));
      // horizontal layout
      const pad = 10 * devicePixelRatio;
      const areaW = w - 2*pad;
      const barGap = Math.max(4 * devicePixelRatio, Math.floor(areaW / (magnitudes.length * 15)));
      const barWidth = Math.max(6 * devicePixelRatio, (areaW - barGap*(magnitudes.length+1)) / magnitudes.length);
      let x = pad + barGap;
      for (let i=0;i<magnitudes.length;i++){
        const m = magnitudes[i];
        // height proportional to digits and leading digits
        const frac = (m.digits - 1) + (m.leading / Math.pow(10, Math.min(6,m.digits)));
        const norm = frac / (maxDigits); // 0..1
        const barH = Math.max(4*devicePixelRatio, norm * (h - 40*devicePixelRatio));
        // style
        const grd = ctx.createLinearGradient(0, h-barH, 0, h);
        grd.addColorStop(0, i%2? '#d6ecff' : '#eaf6ff');
        grd.addColorStop(1, '#b8e1ff');
        ctx.fillStyle = grd;
        ctx.strokeStyle = '#a6d4ff';
        ctx.lineWidth = Math.max(1, devicePixelRatio);
        ctx.fillRect(x, h - barH, barWidth, barH);
        ctx.strokeRect(x, h - barH, barWidth, barH);
        // index label
        ctx.fillStyle = '#2c3e50';
        ctx.font = `${12*devicePixelRatio}px system-ui, monospace`;
        ctx.textAlign = 'center';
        ctx.fillText(i, x + barWidth/2, h - barH - 6*devicePixelRatio);
        // maybe mark hovered
        if (i === hoverIndex){
          ctx.strokeStyle = 'rgba(80,120,255,0.9)';
          ctx.lineWidth = 2 * devicePixelRatio;
          ctx.strokeRect(x-2*devicePixelRatio, h - barH-2*devicePixelRatio, barWidth+4*devicePixelRatio, barH+4*devicePixelRatio);
        }
        x += barWidth + barGap;
      }
      // bottom axis
      ctx.fillStyle = '#444';
      ctx.font = `${11*devicePixelRatio}px system-ui, monospace`;
      ctx.textAlign = 'left';
      ctx.fillText('F0..F' + (values.length - 1), pad, 14*devicePixelRatio);
    }

    // Canvas interactivity: show tooltip-like full value on hover
    canvas.addEventListener('mousemove', (ev) => {
      if (!currentValues || currentValues.length === 0) return;
      const rect = canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * devicePixelRatio;
      const w = canvas.width;
      const pad = 10 * devicePixelRatio;
      const areaW = w - 2*pad;
      const barGap = Math.max(4 * devicePixelRatio, Math.floor(areaW / (currentValues.length * 15)));
      const barWidth = Math.max(6 * devicePixelRatio, (areaW - barGap*(currentValues.length+1)) / currentValues.length);
      let mx = pad + barGap;
      let found = -1;
      for (let i=0;i<currentValues.length;i++){
        if (x >= mx && x <= mx + barWidth) { found = i; break; }
        mx += barWidth + barGap;
      }
      hoverIndex = found;
      drawBars(currentValues);
      if (found >= 0){
        const hint = $('canvasHint');
        hint.textContent = 'Index ' + found + ': ' + String(currentValues[found]);
      } else {
        $('canvasHint').textContent = '';
      }
    });

    canvas.addEventListener('mouseleave', () => { hoverIndex = -1; drawBars(currentValues); $('canvasHint').textContent = ''; });

    // Buttons and behavior
    countRange.addEventListener('input', e => { countNumber.value = countRange.value; });
    countNumber.addEventListener('change', e => {
      let v = Number(countNumber.value);
      if (isNaN(v) || v < 0) v = 0;
      if (v > 200) v = 200;
      countNumber.value = v;
      countRange.value = v;
    });

    function measure(fn){
      const t0 = performance.now();
      const res = fn();
      const t1 = performance.now();
      return {res, time: t1 - t0};
    }

    async function showIterative(){
      const n = Number(countRange.value);
      timeEl.textContent = 'Computing (iterative)...';
      notesEl.textContent = '';
      if (animateCheckbox.checked){
        await animateIterative(n);
      } else {
        const {res, time} = measure(() => fibIterative(n));
        renderSequence(res);
        timeEl.textContent = `Iterative: computed F0..F${n} in ${time.toFixed(3)} ms (exact, BigInt)`;
      }
    }

    async function animateIterative(n){
      sequenceEl.innerHTML = '';
      let a = 0n, b = 1n;
      const arr = [];
      const speed = Math.max(10, Number(speedRange.value));
      function pushTerm(i, val){
        const div = document.createElement('div');
        div.className = 'term' + ((String(val).length > 18) ? ' big' : '');
        div.title = String(val);
        div.textContent = i + ': ' + formatBigInt(val);
        sequenceEl.appendChild(div);
      }
      const t0 = performance.now();
      if (n >= 0){ arr.push(0n); pushTerm(0, 0n); await sleep(speed); }
      if (n >= 1){ arr.push(1n); pushTerm(1, 1n); await sleep(speed); }
      for (let i = 2; i <= n; i++){
        const c = a + b;
        // note: we must keep a and b updated; initial a=0,b=1 corresponds to F0,F1; but we haven't set a,b accordingly
        // adjust: after first two pushes, set a=0,b=1
        if (i===2) { a=0n; b=1n; }
        const next = a + b;
        arr.push(next);
        pushTerm(i, next);
        a = b; b = next;
        await sleep(speed);
      }
      const t1 = performance.now();
      timeEl.textContent = `Iterative (animated): computed F0..F${n} in ${(t1-t0).toFixed(1)} ms (rendering took extra time)`;
      renderRatios(arr);
      drawBars(arr);
      currentValues = arr;
    }

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    async function showNaive(){
      const n = Number(countRange.value);
      timeEl.textContent = 'Computing (naive recursion)...';
      notesEl.textContent = '';
      if (n > 45){
        notesEl.innerHTML = '<span class="warning">Naive recursion is exponential and will be very slow for n > ~45. Please choose a smaller n or use memoization/iterative method.</span>';
        return;
      }
      // compute each term to render sequence as F0..Fn
      const arr = [];
      const t0 = performance.now();
      for (let i = 0; i <= n; i++){
        arr.push(fibNaive(i));
      }
      const t1 = performance.now();
      renderSequence(arr);
      timeEl.textContent = `Naive recursion: computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (exponential complexity)`;
    }

    async function showMemo(){
      const n = Number(countRange.value);
      timeEl.textContent = 'Computing (memoized recursion)...';
      notesEl.textContent = '';
      const t0 = performance.now();
      const arr = fibMemoArray(n);
      const t1 = performance.now();
      renderSequence(arr);
      timeEl.textContent = `Memoized recursion: computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (exact, BigInt)`;
    }

    async function showBinet(){
      const n = Number(countRange.value);
      timeEl.textContent = 'Computing (Binet)...';
      notesEl.textContent = '';
      if (n > 70){
        notesEl.innerHTML = '<span class="warning">Binet uses floating-point arithmetic and will lose precision for n &gt; ~70. Prefer iterative or memoized BigInt methods for exact results.</span>';
      }
      const t0 = performance.now();
      const arr = fibBinetArray(n);
      const t1 = performance.now();
      renderSequence(arr);
      timeEl.textContent = `Binet (float): computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (floating approximation)`;
    }

    $('iterBtn').addEventListener('click', showIterative);
    $('recurBtn').addEventListener('click', showNaive);
    $('memoBtn').addEventListener('click', showMemo);
    $('binetBtn').addEventListener('click', showBinet);

    // initial render
    showIterative();

    // animate bars: visually expand each bar
    $('animateBars').addEventListener('click', async () => {
      const values = currentValues.slice();
      if (!values || values.length === 0) return;
      const steps = values.length;
      const orig = canvas.cloneNode();
      // simple grow animation: gradually reveal bars
      for (let k = 1; k <= values.length; k++){
        drawBars(values.slice(0,k));
        await sleep(80);
      }
      drawBars(values);
    });

    // download canvas
    $('downloadBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fibonacci_visualization.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // convenience: pressing Enter in number input triggers iterative
    countNumber.addEventListener('keydown', (e) => { if (e.key === 'Enter') showIterative(); });

    // responsiveness: redraw on resize
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => drawBars(currentValues), 100);
    });

    // Extra: show golden ratio chip computed
    (function computePhi(){ const phi = (1 + Math.sqrt(5)) / 2; $('phiChip').textContent = 'φ ≈ ' + phi.toFixed(10); })();
  </script>
</body>
</html>