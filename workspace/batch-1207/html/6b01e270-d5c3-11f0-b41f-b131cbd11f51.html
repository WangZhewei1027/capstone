<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        canvas {
            max-width: 100%;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        input[type="range"] {
            width: 100%;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 5px;
        }
        .point-info {
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>K-Nearest Neighbors (KNN) Algorithm Visualization</h1>
    
    <div class="container">
        <div class="panel">
            <h3>KNN Classification</h3>
            <canvas id="knnChart"></canvas>
            <div class="controls">
                <label for="kValue">K Value: <span id="kValueDisplay">3</span></label>
                <input type="range" id="kValue" min="1" max="15" value="3">
                
                <label for="testX">Test Point X: <span id="testXDisplay">0.5</span></label>
                <input type="range" id="testX" min="0" max="1" step="0.01" value="0.5">
                
                <label for="testY">Test Point Y: <span id="testYDisplay">0.5</span></label>
                <input type="range" id="testY" min="0" max="1" step="0.01" value="0.5">
            </div>
            <button onclick="addRandomPoint()">Add Random Training Point</button>
            <button onclick="resetData()">Reset Data</button>
        </div>
        
        <div class="panel">
            <h3>Algorithm Explanation</h3>
            <div id="explanation">
                <p><strong>K-Nearest Neighbors (KNN)</strong> is a simple, instance-based learning algorithm used for classification and regression.</p>
                <p><strong>How it works:</strong></p>
                <ol>
                    <li>Store all training data points</li>
                    <li>For a new test point, calculate distances to all training points</li>
                    <li>Select the K nearest neighbors (smallest distances)</li>
                    <li>For classification: take majority vote of neighbors' classes</li>
                    <li>For regression: take average of neighbors' values</li>
                </ol>
                <div class="results" id="predictionResult">
                    <!-- Prediction results will appear here -->
                </div>
                <div class="point-info" id="neighborsInfo">
                    <!-- Neighbors information will appear here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sample training data - points with class labels
        let trainingData = [
            {x: 0.2, y: 0.3, class: 'A'},
            {x: 0.3, y: 0.7, class: 'A'},
            {x: 0.4, y: 0.2, class: 'A'},
            {x: 0.6, y: 0.8, class: 'A'},
            {x: 0.7, y: 0.3, class: 'B'},
            {x: 0.8, y: 0.6, class: 'B'},
            {x: 0.9, y: 0.4, class: 'B'},
            {x: 0.85, y: 0.7, class: 'B'}
        ];

        let testPoint = {x: 0.5, y: 0.5};
        let kValue = 3;
        let chart;

        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('knnChart').getContext('2d');
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Class A',
                            data: trainingData.filter(p => p.class === 'A').map(p => ({x: p.x, y: p.y})),
                            backgroundColor: 'rgba(255, 99, 132, 0.8)',
                            pointRadius: 8
                        },
                        {
                            label: 'Class B',
                            data: trainingData.filter(p => p.class === 'B').map(p => ({x: p.x, y: p.y})),
                            backgroundColor: 'rgba(54, 162, 235, 0.8)',
                            pointRadius: 8
                        },
                        {
                            label: 'Test Point',
                            data: [{x: testPoint.x, y: testPoint.y}],
                            backgroundColor: 'rgba(255, 206, 86, 1)',
                            pointRadius: 10,
                            pointStyle: 'triangle'
                        },
                        {
                            label: 'Nearest Neighbors',
                            data: [],
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            pointRadius: 8,
                            pointStyle: 'rect'
                        }
                    ]
                },
                options: {
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: 0,
                            max: 1
                        },
                        y: {
                            min: 0,
                            max: 1
                        }
                    },
                    onClick: (e) => {
                        const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);
                        
                        testPoint.x = Math.max(0, Math.min(1, dataX));
                        testPoint.y = Math.max(0, Math.min(1, dataY));
                        
                        document.getElementById('testX').value = testPoint.x;
                        document.getElementById('testY').value = testPoint.y;
                        document.getElementById('testXDisplay').textContent = testPoint.x.toFixed(2);
                        document.getElementById('testYDisplay').textContent = testPoint.y.toFixed(2);
                        
                        updateChart();
                    }
                }
            });
        }

        // Calculate Euclidean distance between two points
        function calculateDistance(point1, point2) {
            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
        }

        // Find K nearest neighbors
        function findKNearestNeighbors() {
            // Calculate distances to all training points
            const distances = trainingData.map(point => ({
                ...point,
                distance: calculateDistance(point, testPoint)
            }));
            
            // Sort by distance and take K nearest
            return distances.sort((a, b) => a.distance - b.distance).slice(0, kValue);
        }

        // Make prediction based on KNN
        function predict() {
            const neighbors = findKNearestNeighbors();
            const classCount = {};
            
            neighbors.forEach(neighbor => {
                classCount[neighbor.class] = (classCount[neighbor.class] || 0) + 1;
            });
            
            // Return class with highest count
            return Object.keys(classCount).reduce((a, b) => 
                classCount[a] > classCount[b] ? a : b
            );
        }

        // Update chart with current data
        function updateChart() {
            const neighbors = findKNearestNeighbors();
            const prediction = predict();
            
            // Update neighbors dataset
            chart.data.datasets[3].data = neighbors.map(p => ({x: p.x, y: p.y}));
            
            // Update test point
            chart.data.datasets[2].data = [{x: testPoint.x, y: testPoint.y}];
            
            chart.update();
            
            // Update results display
            document.getElementById('predictionResult').innerHTML = `
                <strong>Prediction:</strong> Class ${prediction}<br>
                <strong>K value:</strong> ${kValue}<br>
                <strong>Test point:</strong> (${testPoint.x.toFixed(2)}, ${testPoint.y.toFixed(2)})
            `;
            
            // Update neighbors information
            let neighborsHtml = '<strong>Nearest Neighbors:</strong><br>';
            neighbors.forEach((neighbor, index) => {
                neighborsHtml += `${index + 1}. Class ${neighbor.class} - Distance: ${neighbor.distance.toFixed(3)}<br>`;
            });
            document.getElementById('neighborsInfo').innerHTML = neighborsHtml;
        }

        // Add random training point
        function addRandomPoint() {
            const newClass = Math.random() > 0.5 ? 'A' : 'B';
            const newPoint = {
                x: Math.random(),
                y: Math.random(),
                class: newClass
            };
            
            trainingData.push(newPoint);
            updateChartData();
        }

        // Reset data to initial state
        function resetData() {
            trainingData = [
                {x: 0.2, y: 0.3, class: 'A'},
                {x: 0.3, y: 0.7, class: 'A'},
                {x: 0.4, y: 0.2, class: 'A'},
                {x: 0.6, y: 0.8, class: 'A'},
                {x: 0.7, y: 0.3, class: 'B'},
                {x: 0.8, y: 0.6, class: 'B'},
                {x: 0.9, y: 0.4, class: 'B'},
                {x: 0.85, y: 0.7, class: 'B'}
            ];
            testPoint = {x: 0.5, y: 0.5};
            kValue = 3;
            
            document.getElementById('kValue').value = kValue;
            document.getElementById('testX').value = testPoint.x;
            document.getElementById('testY').value = testPoint.y;
            document.getElementById('kValueDisplay').textContent = kValue;
            document.getElementById('testXDisplay').textContent = testPoint.x.toFixed(2);
            document.getElementById('testYDisplay').textContent = testPoint.y.toFixed(2);
            
            updateChartData();
        }

        // Update chart datasets
        function updateChartData() {
            chart.data.datasets[0].data = trainingData.filter(p => p.class === 'A').map(p => ({x: p.x, y: p.y}));
            chart.data.datasets[1].data = trainingData.filter(p => p.class === 'B').map(p => ({x: p.x, y: p.y}));
            updateChart();
        }

        // Initialize event listeners
        document.getElementById('kValue').addEventListener('input', function() {
            kValue = parseInt(this.value);
            document.getElementById('kValueDisplay').textContent = kValue;
            updateChart();
        });

        document.getElementById('testX').addEventListener('input', function() {
            testPoint.x = parseFloat(this.value);
            document.getElementById('testXDisplay').textContent = testPoint.x.toFixed(2);
            updateChart();
        });

        document.getElementById('testY').addEventListener('input', function() {
            testPoint.y = parseFloat(this.value);
            document.getElementById('testYDisplay').textContent = testPoint.y.toFixed(2);
            updateChart();
        });

        // Initialize application
        window.onload = function() {
            initChart();
            updateChart();
        };
    </script>
</body>
</html>