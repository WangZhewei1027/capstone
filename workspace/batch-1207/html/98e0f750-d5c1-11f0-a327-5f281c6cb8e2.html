<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hash Map Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#39a0ed;
      --good:#28c76f; --warn:#ffb020; --danger:#ff6b6b; --panel:#071023;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg,#071021 0%, #071226 60%); color:#e6eef6;
      padding:20px; min-height:100vh;
    }
    header{display:flex; gap:16px; align-items:center; margin-bottom:16px;}
    h1{font-size:20px; margin:0}
    .layout{display:grid; grid-template-columns:360px 1fr 320px; gap:16px; align-items:start;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:14px; border-radius:10px;}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input[type="text"], select{width:100%; padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.05); background:transparent; color:inherit; margin-bottom:10px;}
    .row{display:flex; gap:8px;}
    button{appearance:none; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; background:var(--accent); color:#042034; font-weight:600;}
    button.secondary{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); font-weight:600;}
    button.danger{background:var(--danger); color:white;}
    .controls{margin-bottom:12px;}
    .buckets{display:grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap:10px;}
    .bucket{background:var(--panel); padding:8px; border-radius:8px; min-height:60px; position:relative; border:1px solid rgba(255,255,255,0.02);}
    .bucketIndex{position:absolute; top:6px; right:8px; font-size:11px; color:var(--muted);}
    .entry{background:rgba(255,255,255,0.03); margin:6px 0; padding:6px 8px; border-radius:6px; font-size:13px; display:flex; justify-content:space-between; gap:6px; align-items:center; border-left:4px solid transparent;}
    .entry .k{font-weight:700; color:#dff1ff;}
    .entry .v{color:var(--muted); font-size:12px;}
    .hashSmall{font-size:11px; color:var(--muted); margin-left:8px;}
    .stats{font-size:13px; color:var(--muted); display:flex; flex-direction:column; gap:6px;}
    .log{height:240px; overflow:auto; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); font-family:monospace; font-size:13px; color:#cfefff;}
    .highlight{box-shadow:0 0 0 3px rgba(57,160,237,0.12); border-color:rgba(57,160,237,0.25)!important;}
    .collision{border-left-color:var(--warn)!important;}
    .success{border-left-color:var(--good)!important;}
    .info{border-left-color:var(--accent)!important;}
    .small{font-size:12px; color:var(--muted);}
    footer{margin-top:14px; font-size:12px; color:var(--muted);}
    .titleBar{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;}
    .explain{font-size:13px; color:var(--muted); line-height:1.35; margin-bottom:10px;}
    .controls-grid{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
    .btnGroup{display:flex; gap:8px; flex-wrap:wrap;}
    .tiny{padding:6px 8px; font-size:13px;}
    .badge{display:inline-block; padding:3px 6px; border-radius:6px; background:rgba(255,255,255,0.03); color:var(--muted); font-size:12px;}
    @media (max-width:1000px){
      .layout{grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Hash Map Interactive Demo</h1>
    <div class="small">Separate chaining • automatic resize • selectable hash</div>
  </header>

  <div class="layout">
    <!-- LEFT: Controls -->
    <div class="card">
      <div class="titleBar">
        <strong>Controls</strong>
        <span class="badge" id="statusBadge">Ready</span>
      </div>

      <div class="explain">
        A hash map stores key → value pairs. Keys are hashed to numeric values and placed into bucket indices (hash mod capacity). Collisions occur when multiple keys map to the same bucket — this demo uses separate chaining (arrays in buckets).
      </div>

      <div>
        <label>Hash function</label>
        <select id="hashSelect">
          <option value="djb2">djb2 (common)</option>
          <option value="sum">Simple char code sum</option>
          <option value="constant">Constant (force collisions)</option>
        </select>
      </div>

      <div style="margin-top:8px;">
        <label>Key</label>
        <input id="keyInput" type="text" placeholder='e.g. "apple" or 42'>
        <label>Value</label>
        <input id="valueInput" type="text" placeholder='e.g. "red"'>
      </div>

      <div class="controls" style="margin-top:6px;">
        <div class="btnGroup">
          <button id="putBtn">Put</button>
          <button id="getBtn" class="secondary">Get</button>
          <button id="delBtn" class="secondary">Delete</button>
          <button id="clearBtn" class="danger">Clear</button>
        </div>
      </div>

      <div style="margin-top:8px;">
        <div class="controls-grid">
          <button id="randBtn" class="tiny secondary">Random key/value</button>
          <button id="bulkBtn" class="tiny secondary">Insert sample set</button>
        </div>
      </div>

      <hr style="border:none; height:1px; background:rgba(255,255,255,0.02); margin:12px 0;">

      <div class="stats">
        <div>Capacity: <strong id="capDisplay">--</strong></div>
        <div>Size (entries): <strong id="sizeDisplay">--</strong></div>
        <div>Load factor: <strong id="loadDisplay">--</strong></div>
        <div>Collisions (buckets with >1): <strong id="collisionsDisplay">--</strong></div>
        <div>Resize threshold: <strong id="thresholdDisplay">--</strong></div>
      </div>

    </div>

    <!-- CENTER: Buckets Visualization -->
    <div class="card">
      <div class="titleBar">
        <strong>Buckets</strong>
        <div class="small">Click an entry to remove it; hover to see its hash</div>
      </div>

      <div id="bucketsContainer" class="buckets" aria-live="polite"></div>

      <footer class="small">
        Hash shown is a 32-bit integer. Index = (hash mod capacity + capacity) % capacity.
      </footer>
    </div>

    <!-- RIGHT: Logs & Info -->
    <div class="card">
      <div class="titleBar">
        <strong>Activity Log</strong>
        <button id="clearLog" class="tiny secondary">Clear</button>
      </div>

      <div id="log" class="log" aria-live="polite"></div>

      <hr style="border:none; height:1px; background:rgba(255,255,255,0.02); margin:12px 0;">

      <div><strong>Selected Entry</strong></div>
      <div id="selectedInfo" class="small" style="margin-top:8px;">None</div>
    </div>
  </div>

  <script>
    (function(){
      // Utility functions
      function hashDjb2(str){
        // djb2 algorithm -> 32-bit signed
        let h = 5381;
        for(let i=0;i<str.length;i++){
          h = ((h << 5) + h) + str.charCodeAt(i);
          h |= 0;
        }
        return h | 0;
      }
      function hashSum(str){
        let s = 0;
        for(let i=0;i<str.length;i++) s = (s + str.charCodeAt(i)) | 0;
        return s | 0;
      }
      function hashConst(str){ return 42; }

      function normalizeKey(k){
        if(k === null) return "null";
        if(k === undefined) return "undefined";
        if(typeof k === "object") {
          try { return JSON.stringify(k); } catch(e) { return String(k); }
        }
        return String(k);
      }

      // HashMap implementation (separate chaining)
      class HashMap {
        constructor({capacity=8, loadFactor=0.75, hashFn=hashDjb2, onResize=null} = {}){
          this._capacity = capacity;
          this._buckets = Array.from({length:capacity}, () => []);
          this._size = 0;
          this._threshold = loadFactor;
          this._hashFn = hashFn;
          this._onResize = onResize;
        }
        _hash(keyStr){
          // produce unsigned 32-bit integer
          let raw = this._hashFn(keyStr) | 0;
          // convert to unsigned 32-bit
          return raw >>> 0;
        }
        _index(hash){
          return hash % this._capacity;
        }
        get size(){ return this._size; }
        capacity(){ return this._capacity; }
        threshold(){ return this._threshold; }
        setHashFn(fn){ this._hashFn = fn; }
        entries(){
          const arr = [];
          for(let i=0;i<this._buckets.length;i++){
            for(const e of this._buckets[i]) arr.push({index:i, key:e[0], value:e[1], hash:e[2]});
          }
          return arr;
        }
        put(key, value, animate=false){
          const keyStr = normalizeKey(key);
          const hash = this._hash(keyStr);
          const idx = this._index(hash);
          const bucket = this._buckets[idx];

          // Check if key exists -> replace
          for(let i=0;i<bucket.length;i++){
            if(bucket[i][0] === keyStr){
              bucket[i][1] = value;
              return {action:'replace', index:idx, hash, key:keyStr, value};
            }
          }
          // Insert
          bucket.push([keyStr, value, hash]);
          this._size++;
          // Resize if necessary
          if(this._size / this._capacity > this._threshold){
            this._resize(this._capacity * 2);
            return {action:'insert-resize', index:idx, hash, key:keyStr, value};
          }
          return {action:'insert', index:idx, hash, key:keyStr, value};
        }
        get(key){
          const keyStr = normalizeKey(key);
          const hash = this._hash(keyStr);
          const idx = this._index(hash);
          const bucket = this._buckets[idx];
          for(const e of bucket){
            if(e[0] === keyStr) return {found:true, value:e[1], index:idx, hash};
          }
          return {found:false, index:idx, hash};
        }
        delete(key){
          const keyStr = normalizeKey(key);
          const hash = this._hash(keyStr);
          const idx = this._index(hash);
          const bucket = this._buckets[idx];
          for(let i=0;i<bucket.length;i++){
            if(bucket[i][0] === keyStr){
              bucket.splice(i,1);
              this._size--;
              return {deleted:true, index:idx, hash, key:keyStr};
            }
          }
          return {deleted:false, index:idx, hash, key:keyStr};
        }
        clear(){
          this._buckets = Array.from({length:this._capacity}, () => []);
          this._size = 0;
        }
        _resize(newCap){
          if(typeof this._onResize === 'function'){
            this._onResize(this._capacity, newCap);
          }
          const oldEntries = this.entries();
          this._capacity = newCap;
          this._buckets = Array.from({length:newCap}, () => []);
          this._size = 0;
          // Reinsert all
          for(const e of oldEntries){
            const bucket = this._buckets[e.index % newCap]; // not accurate for new hash; recalc
            // recompute proper index using hash
            const idx = this._index(e.hash);
            this._buckets[idx].push([e.key, e.value, e.hash]);
            this._size++;
          }
        }
        bucketInfo(){
          let collisions=0, maxChain=0;
          for(const b of this._buckets){
            if(b.length > 1) collisions++;
            maxChain = Math.max(maxChain, b.length);
          }
          return {collisions, maxChain, buckets:this._buckets.length};
        }
      }

      // DOM references
      const bucketsContainer = document.getElementById('bucketsContainer');
      const logEl = document.getElementById('log');
      const capDisplay = document.getElementById('capDisplay');
      const sizeDisplay = document.getElementById('sizeDisplay');
      const loadDisplay = document.getElementById('loadDisplay');
      const collisionsDisplay = document.getElementById('collisionsDisplay');
      const thresholdDisplay = document.getElementById('thresholdDisplay');
      const statusBadge = document.getElementById('statusBadge');
      const selectedInfo = document.getElementById('selectedInfo');

      const keyInput = document.getElementById('keyInput');
      const valueInput = document.getElementById('valueInput');
      const putBtn = document.getElementById('putBtn');
      const getBtn = document.getElementById('getBtn');
      const delBtn = document.getElementById('delBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randBtn = document.getElementById('randBtn');
      const bulkBtn = document.getElementById('bulkBtn');
      const clearLogBtn = document.getElementById('clearLog');
      const hashSelect = document.getElementById('hashSelect');

      // Initialize map
      let currentHashFn = hashDjb2;
      const map = new HashMap({capacity:8, loadFactor:0.75, hashFn:currentHashFn, onResize:handleResize});

      function handleResize(oldCap, newCap){
        log(`Resizing from ${oldCap} -> ${newCap}`);
        flashStatus(`Resized to ${newCap}`, 'info');
      }

      // Render buckets
      function renderBuckets(highlights = {}){ // highlights: {idx, keyHash}
        bucketsContainer.innerHTML = '';
        const buckets = map._buckets;
        for(let i=0;i<buckets.length;i++){
          const b = buckets[i];
          const bucketEl = document.createElement('div');
          bucketEl.className = 'bucket';
          if(highlights.index === i) bucketEl.classList.add('highlight');

          const idxEl = document.createElement('div');
          idxEl.className = 'bucketIndex';
          idxEl.textContent = '#' + i;
          bucketEl.appendChild(idxEl);

          if(b.length === 0){
            const empty = document.createElement('div');
            empty.className = 'small';
            empty.style.opacity = 0.6;
            empty.style.marginTop = '10px';
            empty.textContent = '(empty)';
            bucketEl.appendChild(empty);
          } else {
            for(const [k,v,h] of b){
              const e = document.createElement('div');
              e.className = 'entry';
              // mark collision if >1 in bucket
              if(b.length > 1) e.classList.add('collision');
              const left = document.createElement('div');
              const keySpan = document.createElement('div');
              keySpan.className = 'k';
              keySpan.textContent = k;
              const valSpan = document.createElement('div');
              valSpan.className = 'v';
              valSpan.textContent = String(v);
              left.appendChild(keySpan);
              left.appendChild(valSpan);

              const right = document.createElement('div');
              right.style.display='flex';
              right.style.flexDirection='column';
              right.style.alignItems='flex-end';
              const hashSmall = document.createElement('div');
              hashSmall.className='hashSmall';
              hashSmall.textContent = 'h:' + (h >>> 0);
              const idxSmall = document.createElement('div');
              idxSmall.className='hashSmall';
              idxSmall.textContent = 'i:' + (h % map._capacity);
              right.appendChild(hashSmall);
              right.appendChild(idxSmall);

              e.appendChild(left);
              e.appendChild(right);

              // click to delete single entry
              e.addEventListener('click', (ev)=>{
                ev.stopPropagation();
                const res = map.delete(k);
                if(res.deleted){
                  renderBuckets();
                  log(`Deleted key="${k}" from index ${res.index}`);
                  flashStatus('Deleted', 'danger');
                  updateStats();
                }
              });
              // hover to show selected info
              e.addEventListener('mouseenter', ()=>{
                selectedInfo.textContent = `key="${k}", value="${v}", hash=${h >>> 0}, index=${h % map._capacity}`;
              });
              e.addEventListener('mouseleave', ()=>{
                selectedInfo.textContent = 'None';
              });

              bucketEl.appendChild(e);
            }
          }
          bucketsContainer.appendChild(bucketEl);
        }
        updateStats();
      }

      function updateStats(){
        capDisplay.textContent = map.capacity();
        sizeDisplay.textContent = map.size();
        const lf = (map.size() / map.capacity()).toFixed(3);
        loadDisplay.textContent = lf;
        thresholdDisplay.textContent = map.threshold();
        const info = map.bucketInfo();
        collisionsDisplay.textContent = info.collisions + ' (max chain ' + info.maxChain + ')';
      }

      function log(msg){
        const line = document.createElement('div');
        const now = new Date().toLocaleTimeString();
        line.textContent = `[${now}] ${msg}`;
        logEl.appendChild(line);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function flashStatus(text, kind='info'){
        statusBadge.textContent = text;
        if(kind === 'info') statusBadge.style.background = 'linear-gradient(90deg, rgba(57,160,237,0.12), rgba(57,160,237,0.06))';
        if(kind === 'good') statusBadge.style.background = 'linear-gradient(90deg, rgba(40,199,111,0.08), rgba(40,199,111,0.04))';
        if(kind === 'danger') statusBadge.style.background = 'linear-gradient(90deg, rgba(255,107,107,0.08), rgba(255,107,107,0.04))';
        setTimeout(()=>{ statusBadge.textContent = 'Ready'; statusBadge.style.background = ''; }, 1400);
      }

      // Controls
      putBtn.addEventListener('click', ()=>{
        const k = keyInput.value.trim();
        if(k === '') { flashStatus('Enter a key', 'danger'); return; }
        const v = valueInput.value;
        const res = map.put(k, v);
        if(res.action === 'replace'){
          log(`Replaced key="${res.key}" at index ${res.index}`);
          flashStatus('Replaced', 'info');
        } else if(res.action === 'insert-resize'){
          log(`Inserted key="${res.key}" at index ${res.index} (triggered resize)`);
          flashStatus('Inserted + resized', 'info');
        } else {
          log(`Inserted key="${res.key}" at index ${res.index}`);
          flashStatus('Inserted', 'good');
        }
        renderBuckets({index:res.index});
      });

      getBtn.addEventListener('click', ()=>{
        const k = keyInput.value.trim();
        if(k === '') { flashStatus('Enter a key', 'danger'); return; }
        const res = map.get(k);
        if(res.found){
          log(`Get key="${k}" -> "${res.value}" (index ${res.index})`);
          flashStatus('Found', 'good');
        } else {
          log(`Get key="${k}" -> not found (would go to index ${res.index})`);
          flashStatus('Not found', 'danger');
        }
        // highlight target bucket briefly
        renderBuckets({index:res.index});
        setTimeout(()=> renderBuckets(), 650);
      });

      delBtn.addEventListener('click', ()=>{
        const k = keyInput.value.trim();
        if(k === '') { flashStatus('Enter a key', 'danger'); return; }
        const res = map.delete(k);
        if(res.deleted){
          log(`Deleted key="${k}" from index ${res.index}`);
          flashStatus('Deleted', 'danger');
        } else {
          log(`Delete key="${k}" -> not found (would go to index ${res.index})`);
          flashStatus('Not found', 'info');
        }
        renderBuckets();
      });

      clearBtn.addEventListener('click', ()=>{
        map.clear();
        log('Cleared map');
        flashStatus('Cleared', 'danger');
        renderBuckets();
      });

      randBtn.addEventListener('click', ()=>{
        const sampleKeys = ['alpha','beta','gamma','delta','epsilon','apple','banana','carrot','42','100','same','same2'];
        const k = sampleKeys[Math.floor(Math.random()*sampleKeys.length)] + '-' + Math.floor(Math.random()*999);
        const v = 'v' + Math.floor(Math.random()*9999);
        keyInput.value = k;
        valueInput.value = v;
      });

      bulkBtn.addEventListener('click', ()=>{
        const demo = ["apple","banana","orange","pear","grape","cherry","mango","lemon","lime","kiwi","melon","berry","apricot"];
        for(const s of demo){
          map.put(s, 'color-'+Math.floor(Math.random()*100));
        }
        log('Inserted sample set ('+demo.length+' items)');
        renderBuckets();
        flashStatus('Bulk inserted', 'info');
      });

      clearLogBtn.addEventListener('click', ()=>{
        logEl.innerHTML = '';
      });

      hashSelect.addEventListener('change', ()=>{
        const v = hashSelect.value;
        if(v === 'djb2') currentHashFn = hashDjb2;
        if(v === 'sum') currentHashFn = hashSum;
        if(v === 'constant') currentHashFn = hashConst;
        map.setHashFn(currentHashFn);
        // Rebuild underlying buckets with new hash function by re-inserting existing entries:
        const existing = map.entries().map(e => ({key:e.key, value:e.value}));
        map._buckets = Array.from({length:map._capacity}, () => []);
        map._size = 0;
        for(const e of existing){
          map.put(e.key, e.value);
        }
        log('Hash function changed to: ' + v + ' and rehashed entries');
        renderBuckets();
        flashStatus('Hash changed', 'info');
      });

      // Initial render
      renderBuckets();
      updateStats();
      log('Demo ready. Try inserting keys and toggling hash function.');

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') putBtn.click();
        if(e.key === 'g' && e.ctrlKey) { e.preventDefault(); getBtn.click(); }
      });

      // Accessibility: click empty container to deselect
      bucketsContainer.addEventListener('click', ()=>{ selectedInfo.textContent='None'; });

    })();
  </script>
</body>
</html>