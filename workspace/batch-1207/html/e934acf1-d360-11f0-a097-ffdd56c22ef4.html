<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Recursion Explorer — Interactive Demonstrations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #6dd3ff;
      --muted: #97a0b8;
      --success: #8be28b;
      --danger: #ff8b8b;
      --glass: rgba(255,255,255,0.03);
    }
    html,body { height:100%; margin:0; font-family: Inter, Roboto, -apple-system, "Segoe UI", "Helvetica Neue", Arial; background: linear-gradient(180deg,#071226 0%, #061826 60%, #081322 100%); color: #e6eef6; }
    .wrap { max-width:1100px; margin:28px auto; padding:24px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 10px 30px rgba(2,6,23,0.7); }
    h1 { margin:0 0 8px 0; font-weight:600; color:var(--accent); }
    p.lead { margin:0 0 18px 0; color:var(--muted); }
    .grid { display:grid; grid-template-columns: 1fr; gap:18px; }
    @media(min-width:980px){ .grid { grid-template-columns: 420px 1fr; } }
    .card { background:var(--panel); border-radius:10px; padding:12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
    input[type="number"], input[type="range"], select { background:var(--glass); border:1px solid rgba(255,255,255,0.03); color: #e6eef6; padding:8px 10px; border-radius:8px; outline:none; }
    button { background: linear-gradient(180deg,#2b6b8a,#1d4b63); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    button.secondary { background: linear-gradient(180deg,#2b2f3b,#13141a); color:var(--muted); }
    .small { font-size:13px; padding:6px 8px; }
    .stack-area { min-height:120px; display:flex; align-items:flex-end; justify-content:center; gap:10px; padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent); border-radius:8px; overflow:auto; }
    .frame { min-width:120px; max-width:220px; padding:8px 10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); box-shadow: 0 8px 16px rgba(0,0,0,0.5); font-size:13px; }
    .frame .fn { color:var(--accent); font-weight:600; }
    .frame .args { color:var(--muted); font-size:12px; margin-top:6px; }
    .frame .ret { margin-top:8px; font-weight:700; color:var(--success); font-size:13px; }
    .events { max-height:240px; overflow:auto; padding:8px; border-radius:8px; background:rgba(255,255,255,0.01); font-family:monospace; font-size:13px; color:var(--muted); }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .split { display:flex; gap:12px; align-items:flex-start; }
    .col { flex:1; }
    canvas { width:100%; height:420px; display:block; background: linear-gradient(180deg,#021018,#06202b); border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    .footer { margin-top:12px; color:var(--muted); font-size:13px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px; }
    .legend { display:flex; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; flex-wrap:wrap;}
    .legend .dot { width:10px;height:10px;border-radius:50%; display:inline-block; }
    .dot.call { background:#6dd3ff; } .dot.return { background:#8be28b; } .dot.work { background:#ffb86b; }
    pre.code { background: rgba(255,255,255,0.02); padding:10px; border-radius:8px; overflow:auto; font-size:13px; color:#dff7ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Recursion Explorer</h1>
    <p class="lead">Interactive demonstrations to explain recursion: see how recursive calls are stacked and returned, compare naive vs memoized recursion, and visualize a recursive fractal tree. Use small inputs to keep traces readable.</p>

    <div class="grid">
      <!-- Left Column: Controls -->
      <div class="col">
        <div class="card">
          <h3 style="margin:0 0 8px 0;">Factorial — Call Stack Trace</h3>
          <div class="controls">
            <label>n <input id="factN" type="number" min="0" max="12" value="6" style="width:80px;"></label>
            <label>Speed <input id="speed" type="range" min="50" max="1200" value="400"></label>
            <button id="runFact" class="small">Run Trace</button>
            <button id="runFactInstant" class="small secondary">Compute Only</button>
          </div>
          <div class="stack-area card" id="stackArea" style="min-height:140px;"></div>
          <div class="row">
            <div style="flex:1"><div class="events" id="factEvents">Call/return events will appear here.</div></div>
          </div>
          <div class="legend">
            <span class="dot call"></span> enter / push
            <span class="dot return"></span> return / pop
            <span class="dot work"></span> work / multiplication
          </div>
        </div>

        <div style="height:14px;"></div>

        <div class="card">
          <h3 style="margin:0 0 8px 0;">Fibonacci — Naive vs Memoized</h3>
          <div class="controls">
            <label>n <input id="fibN" type="number" min="0" max="35" value="10" style="width:90px;"></label>
            <button id="runFib" class="small">Compare</button>
          </div>
          <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
            <div style="flex:1;">
              <div class="card">
                <div style="font-size:13px; color:var(--muted)">Naive recursion</div>
                <div id="fibNaive" style="font-size:18px; font-weight:700; margin-top:6px;">—</div>
                <div style="color:var(--muted); font-size:13px; margin-top:6px;" id="fibNaiveCalls">Calls: —</div>
              </div>
            </div>
            <div style="flex:1;">
              <div class="card">
                <div style="font-size:13px; color:var(--muted)">Memoized recursion</div>
                <div id="fibMemo" style="font-size:18px; font-weight:700; margin-top:6px;">—</div>
                <div style="color:var(--muted); font-size:13px; margin-top:6px;" id="fibMemoCalls">Calls: —</div>
              </div>
            </div>
          </div>
          <div style="margin-top:8px;">
            <div class="small" style="color:var(--muted)">Tip: naive recursion calls grow exponentially; memoization caches results to avoid repeated work.</div>
          </div>
        </div>

        <div style="height:14px;"></div>

        <div class="card">
          <h3 style="margin:0 0 8px 0;">Short explanation</h3>
          <p style="margin:0; color:var(--muted); font-size:14px;">Recursion is when a function calls itself. Every recursive call creates a new stack frame (its own parameters and local variables). To stop infinite recursion you need a base case. Trace helps illustrate pushes (enter) and pops (return).</p>
        </div>
      </div>

      <!-- Right Column: Visualization -->
      <div class="col">
        <div class="card">
          <h3 style="margin:0 0 8px 0;">Fractal Tree — Visual recursive drawing</h3>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
            <label>Depth <input id="treeDepth" type="range" min="0" max="12" value="9" style="width:180px;"></label>
            <span class="badge" id="treeDepthLabel">9</span>
            <label style="margin-left:auto">Angle <input id="angle" type="range" min="10" max="60" value="22" style="width:150px;"></label>
            <span class="badge" id="angleLabel">22°</span>
            <button id="drawTree" class="small">Redraw</button>
          </div>
          <canvas id="treeCanvas" width="800" height="420"></canvas>
          <div class="footer">Recursive drawing: the function draws a trunk then calls itself for branches until depth reaches zero (base case).</div>
        </div>

        <div style="height:14px;"></div>

        <div class="card">
          <h3 style="margin:0 0 8px 0;">Factorial Code (recursive)</h3>
          <pre class="code" id="codeSample">
function factorial(n) {
  if (n <= 1) return 1;   // base case
  return n * factorial(n - 1); // recursive case
}
          </pre>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utilities & DOM
    const byId = id => document.getElementById(id);
    const stackArea = byId('stackArea');
    const factEvents = byId('factEvents');
    const runFact = byId('runFact');
    const runFactInstant = byId('runFactInstant');
    const factN = byId('factN');
    const speedRange = byId('speed');

    // Tracer collects enter/return events during actual recursion.
    function makeTracer() {
      let events = [];
      let stackSize = 0;
      return {
        enter(fn, args) {
          events.push({type:'enter', fn, args: JSON.parse(JSON.stringify(args)), stackSize});
          stackSize++;
        },
        exit(fn, args, ret) {
          stackSize = Math.max(0, stackSize - 1);
          events.push({type:'return', fn, args: JSON.parse(JSON.stringify(args)), ret, stackSize});
        },
        getEvents() { return events; },
        clear() { events = []; stackSize = 0; }
      };
    }

    // Recursive factorial that uses tracer
    function tracedFactorial(n, tracer) {
      tracer.enter('factorial', {n});
      if (n <= 1) {
        tracer.exit('factorial', {n}, 1);
        return 1;
      }
      const sub = tracedFactorial(n - 1, tracer);
      const res = n * sub;
      tracer.exit('factorial', {n}, res);
      return res;
    }

    // Animation: play events with visual stack frames
    async function animateEvents(events, speedMs) {
      // Clear UI
      stackArea.innerHTML = '';
      factEvents.innerHTML = '';
      const frames = []; // maps to DOM elements representing stack frames, index is depth
      for (let i = 0; i < events.length; i++) {
        const ev = events[i];
        const line = document.createElement('div');
        line.textContent = (ev.type === 'enter' ? '→ enter ' : '← return ') + ev.fn + '(' + (ev.args && ev.args.n !== undefined ? ev.args.n : '') + ')' + (ev.type === 'return' ? ' = ' + ev.ret : '');
        line.style.opacity = '0.95';
        factEvents.appendChild(line);
        factEvents.scrollTop = factEvents.scrollHeight;

        if (ev.type === 'enter') {
          // create frame at ev.stackSize index
          const frame = document.createElement('div');
          frame.className = 'frame';
          frame.dataset.depth = ev.stackSize;
          frame.innerHTML = '<div class="fn">' + ev.fn + '</div>' +
                            '<div class="args">n = ' + ev.args.n + '</div>' +
                            '<div class="ret" style="visibility:hidden;">ret</div>';
          // append to stackArea (we place frames left-to-right as stack bottom->top)
          stackArea.appendChild(frame);
          frames.push(frame);
          await sleep(speedMs);
        } else if (ev.type === 'return') {
          // annotate the top frame then remove it shortly after
          // find the last frame with matching depth
          const topFrame = frames[frames.length - 1];
          if (topFrame) {
            const retDiv = topFrame.querySelector('.ret');
            retDiv.textContent = 'return = ' + ev.ret;
            retDiv.style.visibility = 'visible';
            // highlight quickly
            topFrame.style.boxShadow = '0 12px 20px rgba(139,226,139,0.12)';
            await sleep(speedMs * 0.9);
            // pop
            stackArea.removeChild(topFrame);
            frames.pop();
            await sleep(speedMs * 0.1);
          } else {
            // fallback small pause
            await sleep(speedMs);
          }
        }
      }
      // final note
      const done = document.createElement('div');
      done.style.color = 'var(--muted)';
      done.style.padding = '8px';
      done.textContent = 'Trace finished. Final result shown above on last return event.';
      factEvents.appendChild(done);
      factEvents.scrollTop = factEvents.scrollHeight;
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    runFact.addEventListener('click', async () => {
      const n = Math.max(0, Math.min(12, parseInt(factN.value || 0)));
      const tracer = makeTracer();
      try {
        // Build trace synchronously
        tracedFactorial(n, tracer);
      } catch (e) {
        alert('Error during recursion: ' + e);
        return;
      }
      const events = tracer.getEvents();
      // Clear display
      factEvents.innerHTML = '';
      stackArea.innerHTML = '';
      const sp = Math.max(40, parseInt(speedRange.value || 400));
      await animateEvents(events, sp);
    });

    runFactInstant.addEventListener('click', () => {
      const n = Math.max(0, Math.min(100000, parseInt(factN.value || 0)));
      // compute without tracer, fast
      try {
        const res = (function f(x){ if (x<=1) return 1; return x * f(x-1); })(n);
        factEvents.innerHTML = 'factorial(' + n + ') = ' + res;
        stackArea.innerHTML = '<div class="frame"><div class="fn">result</div><div class="args">n = '+n+'</div><div class="ret" style="visibility:visible;">'+res+'</div></div>';
      } catch (e) {
        factEvents.innerHTML = 'Error: recursion might be too deep';
      }
    });

    // Fibonacci comparison: count calls & compute value
    byId('runFib').addEventListener('click', () => {
      const n = Math.max(0, Math.min(35, parseInt(byId('fibN').value || 0)));
      // naive recursion with call counting
      let callsNaive = 0;
      function fibNaive(k) {
        callsNaive++;
        if (k <= 1) return k;
        return fibNaive(k-1) + fibNaive(k-2);
      }
      // memoized
      let callsMemo = 0;
      const mem = {};
      function fibMemo(k) {
        callsMemo++;
        if (k <= 1) return k;
        if (mem[k] !== undefined) return mem[k];
        mem[k] = fibMemo(k-1) + fibMemo(k-2);
        return mem[k];
      }

      // run (naive might be slow for n > ~35; we clamp)
      const t0 = performance.now();
      const valNaive = fibNaive(n);
      const t1 = performance.now();
      const timeNaive = (t1 - t0).toFixed(2);

      const t2 = performance.now();
      const valMemo = fibMemo(n);
      const t3 = performance.now();
      const timeMemo = (t3 - t2).toFixed(2);

      byId('fibNaive').textContent = (valNaive === undefined ? '—' : valNaive) + '  (' + timeNaive + ' ms)';
      byId('fibNaiveCalls').textContent = 'Calls: ' + callsNaive;
      byId('fibMemo').textContent = valMemo + '  (' + timeMemo + ' ms)';
      byId('fibMemoCalls').textContent = 'Calls: ' + callsMemo + (mem ? '  (cache hits reduced work)' : '');
    });

    // Fractal tree drawing
    const canvas = byId('treeCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvasToDisplaySize(canvas) {
      const ratio = window.devicePixelRatio || 1;
      const w = canvas.clientWidth * ratio;
      const h = canvas.clientHeight * ratio;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }
    function drawTree(depth, angleDeg) {
      resizeCanvasToDisplaySize(canvas);
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.save();
      // Start in middle bottom
      ctx.translate(canvas.width / 2, canvas.height - 20);
      // Initial trunk
      const trunk = Math.min(canvas.height / 4, 220);
      // recursive draw
      function drawBranch(len, depthLeft) {
        // base case
        if (depthLeft <= 0 || len < 2) {
          // draw a leaf dot
          ctx.beginPath();
          ctx.fillStyle = '#8be28b';
          ctx.arc(0, 0, 2.2, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        // draw trunk segment
        ctx.lineWidth = Math.max(1, depthLeft * 0.9);
        ctx.strokeStyle = depthLeft > 2 ? '#f1c27d' : '#b4e6a8';
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0, -len);
        ctx.stroke();

        // move to end
        ctx.translate(0, -len);

        // right branch
        ctx.save();
        ctx.rotate((angleDeg * Math.PI / 180) * (0.9 + Math.sin(depthLeft) * 0.03));
        drawBranch(len * (0.68 - (depthLeft*0.006)), depthLeft - 1);
        ctx.restore();

        // left branch
        ctx.save();
        ctx.rotate((-angleDeg * Math.PI / 180) * (0.9 + Math.cos(depthLeft) * 0.03));
        drawBranch(len * (0.68 - (depthLeft*0.006)), depthLeft - 1);
        ctx.restore();

        // occasionally draw a middle branch
        if (depthLeft % 3 === 0) {
          ctx.save();
          ctx.rotate((Math.random() - 0.5) * 0.2);
          drawBranch(len * 0.5, depthLeft - 2);
          ctx.restore();
        }

        // move back
        ctx.translate(0, len);
      }

      drawBranch(trunk, depth);
      ctx.restore();
    }

    // initial draw
    function updateTreeLabels() {
      byId('treeDepthLabel').textContent = byId('treeDepth').value;
      byId('angleLabel').textContent = byId('angle').value + '°';
    }
    byId('treeDepth').addEventListener('input', updateTreeLabels);
    byId('angle').addEventListener('input', updateTreeLabels);

    byId('drawTree').addEventListener('click', () => {
      const d = Math.max(0, Math.min(14, parseInt(byId('treeDepth').value || 0)));
      const a = Math.max(0, Math.min(90, parseInt(byId('angle').value || 20)));
      updateTreeLabels();
      drawTree(d, a);
    });

    window.addEventListener('load', () => {
      updateTreeLabels();
      drawTree(parseInt(byId('treeDepth').value || 9), parseInt(byId('angle').value || 22));
    });

    window.addEventListener('resize', () => {
      // redraw on resize
      drawTree(parseInt(byId('treeDepth').value || 9), parseInt(byId('angle').value || 22));
    });

    // Helpful: show small demo by default (run factorial trace once)
    (function initialDemo(){
      // slight delay so UI shows
      setTimeout(() => {
        runFact.click();
      }, 350);
    })();
  </script>
</body>
</html>