<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Radix Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --ok:#10b981;
      --danger:#ef4444;
      --card:#0b1220;
      --glass: rgba(255,255,255,0.03);
      --text:#e6eef8;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#061020);font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--text);}
    .wrap{max-width:1100px;margin:20px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 6px;font-size:20px;}
    p.lead{margin:0 0 14px;color:var(--muted);font-size:13px;}
    .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:14px;align-items:center;}
    .control-group{background:var(--card);padding:10px;border-radius:8px;display:flex;gap:8px;align-items:center;}
    label{font-size:12px;color:var(--muted);}
    input[type="text"]{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:var(--text);min-width:260px;}
    button{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);}
    .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);}
    .small{padding:6px 8px;font-size:13px;border-radius:6px;}
    .row{display:flex;gap:12px;align-items:center;}
    .area{display:flex;gap:12px;align-items:flex-start;}
    .visual{flex:1;background:var(--glass);padding:12px;border-radius:8px;}
    .info{width:340px;background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));padding:12px;border-radius:8px;}
    .array{display:flex;gap:6px;align-items:end;height:220px;padding:10px;border-radius:6px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);overflow:auto;}
    .bar{width:48px;height:60px;border-radius:6px;background:linear-gradient(180deg,#1f2937,#0b1220);display:flex;flex-direction:column;align-items:center;justify-content:flex-end;position:relative;transition:all 300ms ease;}
    .bar .val{font-size:12px;padding:4px 6px;color:var(--text);background:rgba(255,255,255,0.03);border-radius:4px;margin-bottom:8px;white-space:nowrap;}
    .bar .height{width:100%;background:linear-gradient(180deg,var(--accent),#1859b7);border-radius:4px 4px 0 0;transition:height 300ms ease;}
    .label{font-size:12px;color:var(--muted);margin-top:8px;}
    .buckets{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;}
    .bucket{min-width:48px;min-height:70px;background:rgba(255,255,255,0.02);border-radius:6px;padding:6px;display:flex;flex-direction:column;gap:6px;align-items:center;border:1px dashed rgba(255,255,255,0.02);}
    .bucket .bidx{font-size:12px;color:var(--muted);margin-bottom:4px;}
    .bucket .slot{display:flex;flex-direction:column;gap:6px;align-items:center;}
    .bucket .slot .mini{width:40px;height:28px;background:rgba(255,255,255,0.03);border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text);}
    .status{font-size:13px;color:var(--muted);margin-top:6px;}
    .pseudocode{font-family:monospace;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;margin-top:8px;font-size:13px;color:var(--muted);max-height:260px;overflow:auto;}
    .controls .spacer{width:10px;}
    .meta{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
    .badge{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);}
    .help{font-size:13px;color:var(--muted);margin-top:8px;}
    .note{font-size:12px;color:var(--muted);margin-top:8px;}
    .footer{margin-top:12px;font-size:13px;color:var(--muted);}
    /* animations */
    .moving{transform:scale(1.02);box-shadow:0 6px 18px rgba(59,130,246,0.12);z-index:20;}
    @media (max-width:880px){
      .area{flex-direction:column;}
      .info{width:100%;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Radix Sort — Visual Demonstration</h1>
    <p class="lead">Interactive step-by-step visualization of Least Significant Digit (LSD) Radix Sort. Works with negative integers by sorting negatives by absolute value and then reversing them.</p>

    <div class="controls">
      <div class="control-group">
        <label for="inputArr">Array (comma-separated):</label>
        <input id="inputArr" type="text" value="170,45,75,90,802,24,2,66,-15,-3,0,501">
      </div>

      <div class="control-group">
        <label>Base (radix):</label>
        <select id="baseSelect">
          <option value="2">2 (binary)</option>
          <option value="8">8 (octal)</option>
          <option value="10" selected>10 (decimal)</option>
          <option value="16">16 (hex)</option>
        </select>
      </div>

      <div class="control-group">
        <label>Order:</label>
        <select id="orderSelect">
          <option value="asc" selected>Ascending</option>
          <option value="desc">Descending</option>
        </select>
      </div>

      <div class="control-group">
        <label>Speed:</label>
        <input id="speed" type="range" min="50" max="1200" step="50" value="350">
      </div>

      <div class="control-group">
        <button id="randomBtn" class="ghost small">Random</button>
        <button id="resetBtn" class="secondary small">Reset</button>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px;">
        <button id="startBtn">Start</button>
        <button id="stepBtn" class="small ghost">Step</button>
        <button id="pauseBtn" class="small ghost">Pause</button>
      </div>
    </div>

    <div class="area">
      <div class="visual">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="label">Main Array</div>
          <div class="label" id="passLabel">Pass: 0</div>
        </div>

        <div id="arrayView" class="array" aria-live="polite"></div>

        <div id="bucketsArea" class="buckets" style="margin-top:8px;"></div>

        <div class="status" id="statusLine">Ready. Click Start or Step to run.</div>
      </div>

      <div class="info">
        <div class="label">Algorithm info</div>
        <div class="meta">
          <div class="badge">Stable: Yes</div>
          <div class="badge">Average / Worst: O(n · k)</div>
          <div class="badge">Aux space: O(n + b)</div>
        </div>

        <div class="pseudocode">
LSD Radix Sort (base b):
1. For each digit position d = 0 .. maxDigits-1:
   - Create b buckets for digit values 0..b-1
   - For each number x in array (left to right):
       place x into bucket[ digit(x, d) ]
   - Concatenate buckets (bucket 0,1,...,b-1) to form new array
2. When numbers include negatives:
   - Separate negatives and positives
   - Sort positives with LSD as above
   - Sort absolute values of negatives with LSD, then reverse them and make negative
   - Merge negatives (reversed) before positives for ascending order
3. For descending overall, reverse the final ascending result
        </div>

        <div class="help">
          Tips:
          <ul style="margin:6px 0 0 18px;color:var(--muted)">
            <li>Try different bases (binary, decimal, hex) to see bucket counts change.</li>
            <li>Negative numbers are handled by sorting their absolute values then reversing.</li>
            <li>Step mode advances one atomic action (moving one element or collecting buckets).</li>
          </ul>
        </div>

        <div class="note" id="explainLine"></div>
        <div class="footer">Demonstration — not optimized for massive arrays. Works best with ~3–30 elements.</div>
      </div>
    </div>
  </div>

  <script>
    // Radix Sort Visualizer (single-file)
    // Author: generated example
    // Key features:
    // - LSD Radix sort with base selection
    // - Negative handling by sorting absolute values then reversing
    // - Start/Step/Pause/Reset, speed control
    // - Simple DOM animation (move elements into bucket containers and collect)

    // ===== Utility helpers =====
    const $ = id => document.getElementById(id);
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // ===== DOM elements =====
    const inputArr = $('inputArr');
    const baseSelect = $('baseSelect');
    const orderSelect = $('orderSelect');
    const speedRange = $('speed');
    const randomBtn = $('randomBtn');
    const resetBtn = $('resetBtn');
    const startBtn = $('startBtn');
    const stepBtn = $('stepBtn');
    const pauseBtn = $('pauseBtn');
    const arrayView = $('arrayView');
    const bucketsArea = $('bucketsArea');
    const statusLine = $('statusLine');
    const passLabel = $('passLabel');
    const explainLine = $('explainLine');

    // ===== State =====
    let originalArray = [];
    let workingArray = []; // for visualization of current list being processed (either negatives abs or positives)
    let globalNegatives = []; // original negative values
    let globalPositives = []; // original non-negative values
    let base = Number(baseSelect.value);
    let order = orderSelect.value; // "asc" or "desc"
    let speed = Number(speedRange.value);
    let running = false;
    let paused = false;
    let stepMode = false;

    // The "manager" tracks phases and indices to permit stepping
    let manager = null;

    // ===== Helpers: parse input, generate random =====
    function parseInput(str) {
      if (!str.trim()) return [];
      return str.split(',').map(s => Number(s.trim())).filter(x => !Number.isNaN(x) && Number.isFinite(x));
    }
    function arrayToString(arr) {
      return arr.join(', ');
    }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function randomArray(size=12, min=-300, max=900) {
      const a = [];
      for (let i=0;i<size;i++){
        const val = Math.floor(Math.random()*(max-min+1))+min;
        a.push(val);
      }
      return a;
    }

    // ===== Visualization primitives =====
    function createBar(value, maxAbs=1) {
      // create a DOM element representing a number
      const bar = document.createElement('div');
      bar.className = 'bar';
      const val = document.createElement('div');
      val.className = 'val';
      val.textContent = String(value);
      const heightDiv = document.createElement('div');
      heightDiv.className = 'height';
      // height proportional to absolute magnitude (clamped)
      const hPercent = Math.max(8, Math.min(100, Math.round((Math.abs(value)/maxAbs) * 90)));
      heightDiv.style.height = `${hPercent}%`;
      bar.appendChild(val);
      bar.appendChild(heightDiv);
      bar.dataset.value = String(value);
      return bar;
    }

    function renderArray(arr) {
      arrayView.innerHTML = '';
      const maxAbs = Math.max(1, ...arr.map(x => Math.abs(x)));
      for (let v of arr) {
        const node = createBar(v, maxAbs);
        arrayView.appendChild(node);
      }
    }

    function renderBuckets(b) {
      bucketsArea.innerHTML = '';
      for (let i=0;i<b;i++){
        const bk = document.createElement('div');
        bk.className = 'bucket';
        const title = document.createElement('div');
        title.className = 'bidx';
        title.textContent = i;
        const slot = document.createElement('div');
        slot.className = 'slot';
        bk.appendChild(title);
        bk.appendChild(slot);
        bucketsArea.appendChild(bk);
      }
    }

    // move a bar element to a bucket index (by appending a clone)
    async function moveToBucket(barElem, bucketIndex, animate=true) {
      const buckets = bucketsArea.children;
      if (bucketIndex < 0 || bucketIndex >= buckets.length) return;
      const slot = buckets[bucketIndex].querySelector('.slot');
      // clone to allow original to remain for reflow
      const clone = barElem.cloneNode(true);
      clone.classList.add('moving');
      // make mini representation
      clone.style.width = '40px';
      clone.style.height = '40px';
      clone.querySelector('.height').style.height = '18px';
      clone.querySelector('.val').style.fontSize = '12px';
      clone.querySelector('.val').style.marginBottom = '0';
      const mini = document.createElement('div');
      mini.className = 'mini';
      mini.textContent = barElem.dataset.value;
      mini.title = barElem.dataset.value;
      // append mini instead of clone to keep layout compact
      const miniNode = document.createElement('div');
      miniNode.className = 'mini';
      miniNode.textContent = barElem.dataset.value;
      slot.appendChild(miniNode);
      if (animate) await sleep(speed * 0.12);
    }

    // collect buckets back into an array (flatten)
    async function collectBuckets() {
      const buckets = bucketsArea.children;
      const collected = [];
      for (let i=0;i<buckets.length;i++){
        const slot = buckets[i].querySelector('.slot');
        const items = Array.from(slot.children);
        for (let it of items){
          const text = it.textContent;
          const v = Number(text);
          collected.push(v);
        }
      }
      // animate a short pause
      await sleep(speed * 0.25);
      return collected;
    }

    // ===== Radix helpers =====
    function digitAt(x, d, b) {
      // LSD: digit at position d (0-based), using base b
      return Math.floor(Math.abs(x) / Math.pow(b, d)) % b;
    }

    function maxDigitsIn(arr, b) {
      if (!arr.length) return 0;
      const maxAbs = Math.max(...arr.map(x => Math.abs(x)));
      return Math.max(1, Math.floor(Math.log(maxAbs) / Math.log(b)) + 1);
    }

    // ===== Manager: drives the step-by-step animation =====
    function createManager(originalArr, baseVal, orderVal) {
      base = baseVal;
      order = orderVal;
      // split negatives and positives
      const negatives = originalArr.filter(x => x < 0);
      const pos = originalArr.filter(x => x >= 0);
      const negsAbs = negatives.map(x => Math.abs(x));

      // Each "job" will be either sort negAbs or sort pos. We'll animate them sequentially.
      // For each job we record: list (array of numbers), label.
      const jobs = [];
      if (negsAbs.length) jobs.push({name: 'negativesAbs', arr: negsAbs.slice(), originalSign:'neg'});
      if (pos.length) jobs.push({name: 'positives', arr: pos.slice(), originalSign:'pos'});

      let jobIndex = 0;
      let pass = 0;
      let overallPass = 0;

      // inside current job state:
      let currentArr = jobs.length ? jobs[0].arr.slice() : [];
      let d = 0; // digit position
      let maxD = currentArr.length ? maxDigitsIn(currentArr, base) : 0;
      let distributing = true; // distributing or collecting
      let elementIndex = 0;

      // action granularity:
      // - distribute: move one element (at elementIndex) into its bucket (one action)
      // - after distributing all: collect all buckets (one action)
      // - then increment d, set up next pass
      // Each call to nextAction performs one action and returns {done, message}
      async function nextAction() {
        // If all jobs processed, done
        if (jobIndex >= jobs.length) {
          return {done:true, message:'All jobs finished (before final merge).'};
        }

        // set current job parameters
        const job = jobs[jobIndex];
        if (!currentArr || typeof currentArr === 'undefined') currentArr = job.arr.slice();
        // on first pass, ensure buckets are shown for base
        if (distributing && elementIndex === 0 && d === 0) {
          statusLine.textContent = `Sorting ${job.name === 'negativesAbs' ? 'negatives (by abs)' : 'positives'} with base ${base}.`;
          renderBuckets(base);
          renderArray(currentArr.map((v)=> job.name==='negativesAbs' ? -v : v)); // show sign context
          passLabel.textContent = `Job ${jobIndex+1}/${jobs.length} — pass ${d}`;
          explainLine.textContent = '';
          await sleep(20);
        }

        // If we've done all passes for this job, move to next job
        if (d >= maxD) {
          // job finished
          if (job.name === 'negativesAbs') {
            // store sorted abs back (job.arr)
            job.arr = currentArr.slice();
          } else {
            job.arr = currentArr.slice();
          }
          jobIndex++;
          // prepare next job
          if (jobIndex < jobs.length) {
            currentArr = jobs[jobIndex].arr.slice();
            d = 0;
            maxD = currentArr.length ? maxDigitsIn(currentArr, base) : 0;
            distributing = true;
            elementIndex = 0;
            renderBuckets(base);
            renderArray(currentArr.map((v)=> jobs[jobIndex].name==='negativesAbs' ? -v : v));
            passLabel.textContent = `Job ${jobIndex+1}/${jobs.length} — pass ${d}`;
            statusLine.textContent = `Starting next job...`;
            await sleep(80);
            return {done:false, message:'Job switch.'};
          } else {
            // all jobs finished
            return {done:true, message:'Jobs complete.'};
          }
        }

        // Distribution phase: move one element into its bucket
        if (distributing) {
          if (elementIndex < currentArr.length) {
            // get the visual bar for currentArr[elementIndex]
            // We are rendering the "signed" view in the main array; to compute digit we use absolute value
            const value = currentArr[elementIndex];
            const digit = digitAt(value, d, base);
            // find the corresponding DOM bar: find first bar with matching dataset and not yet flagged as distributed (we mark distributed by data-dist=true)
            const bars = Array.from(arrayView.children);
            let barNode = bars.find(b => b.dataset.value === String(job.name==='negativesAbs' ? -value : value) && !b.dataset.dist);
            if (!barNode) {
              // fallback: pick by index
              barNode = bars[elementIndex] || bars[0];
            }
            if (barNode) barNode.dataset.dist = '1';
            // animate move
            await moveToBucket(barNode, digit, !stepMode);
            statusLine.textContent = `Placed ${job.name==='negativesAbs' ? -value : value} into bucket ${digit} (digit pos ${d}).`;
            elementIndex++;
            // in stepMode, return after single move
            return {done:false, message:'Distributed one element.'};
          } else {
            // distributed all elements, now collect
            distributing = false;
            // small pause
            await sleep(speed * 0.15);
            statusLine.textContent = `Collected all buckets for digit position ${d}.`;
            // collect step is considered one atomic action in stepMode
            const collected = await collectBuckets();
            // collected contains numbers as text; these map to the signed view
            // For negativesAbs job, collected are absolute values (we displayed negative), so convert back
            let collectedNums = collected.map(Number);
            if (job.name === 'negativesAbs') {
              // we displayed as negative to user, so collected contains negative values; convert to absolute
              collectedNums = collectedNums.map(x => Math.abs(x));
            } else {
              collectedNums = collectedNums.map(x => Number(x));
            }
            // update currentArr
            currentArr = collectedNums.slice();
            // clear 'dist' dataset from bars
            Array.from(arrayView.children).forEach(b => delete b.dataset.dist);
            // re-render main array to reflect collected order (with proper sign for visualization)
            renderArray(currentArr.map((v)=> job.name==='negativesAbs' ? -v : v));
            passLabel.textContent = `Job ${jobIndex+1}/${jobs.length} — completed pass ${d}`;
            // prepare for next pass
            d++;
            elementIndex = 0;
            distributing = true;
            // update maxD maybe (usually constant for job), but keep fixed for this job
            await sleep(80);
            return {done:false, message:'Collected buckets (pass end).'};
          }
        }
      }

      // helper to get final merged array once all jobs done
      function buildFinalResult() {
        // negatives job (if present) we need to reverse sorted abs and restore negative sign
        let negSorted = [];
        let posSorted = [];
        for (const j of jobs) {
          if (j.name === 'negativesAbs') {
            negSorted = j.arr.slice().reverse().map(x => -x);
          } else if (j.name === 'positives') {
            posSorted = j.arr.slice();
          }
        }
        let merged = negSorted.concat(posSorted);
        if (order === 'desc') merged = merged.slice().reverse();
        return merged;
      }

      return {
        nextAction,
        isComplete: () => jobIndex >= jobs.length,
        getStatus: () => ({jobIndex, totalJobs: jobs.length, currentJob: jobs[jobIndex], d, maxD}),
        finalize: () => buildFinalResult()
      };
    }

    // ===== High-level controls =====
    function setSpeedFromUI() { speed = Number(speedRange.value); }
    speedRange.addEventListener('input', () => { setSpeedFromUI(); });

    randomBtn.addEventListener('click', () => {
      const size = Math.floor(Math.random()*10)+6;
      const arr = randomArray(size, -200, 900);
      inputArr.value = arr.join(', ');
      originalArray = arr.slice();
      renderArray(originalArray);
      statusLine.textContent = `Random array generated (${arr.length} items).`;
    });

    resetBtn.addEventListener('click', () => {
      paused = false;
      running = false;
      stepMode = false;
      manager = null;
      originalArray = parseInput(inputArr.value);
      renderArray(originalArray);
      bucketsArea.innerHTML = '';
      passLabel.textContent = 'Pass: 0';
      statusLine.textContent = 'Reset. Ready.';
    });

    startBtn.addEventListener('click', async () => {
      if (running) { // if already running, ignore
        return;
      }
      setSpeedFromUI();
      originalArray = parseInput(inputArr.value);
      if (!originalArray.length) {
        statusLine.textContent = 'Please provide numbers (comma-separated).';
        return;
      }
      base = Number(baseSelect.value);
      order = orderSelect.value;
      running = true;
      paused = false;
      stepMode = false;
      manager = createManager(originalArray, base, order);
      statusLine.textContent = 'Sorting...';
      startBtn.disabled = true;
      stepBtn.disabled = true;
      pauseBtn.disabled = false;
      // loop until manager done or paused
      while (running) {
        if (paused) { await sleep(120); continue; }
        const res = await manager.nextAction();
        if (res.done) break;
        // small runtime pause
        await sleep(speed * 0.05);
      }
      // manager may finish earlier
      if (manager.isComplete()) {
        const final = manager.finalize();
        renderArray(final);
        bucketsArea.innerHTML = '';
        statusLine.textContent = `Done. Result: ${arrayToString(final)}`;
        passLabel.textContent = 'Finished';
      }
      running = false;
      startBtn.disabled = false;
      stepBtn.disabled = false;
      pauseBtn.disabled = true;
    });

    pauseBtn.addEventListener('click', () => {
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      statusLine.textContent = paused ? 'Paused.' : 'Resumed.';
    });

    stepBtn.addEventListener('click', async () => {
      // If not started yet, initialize manager
      if (!manager) {
        originalArray = parseInput(inputArr.value);
        if (!originalArray.length) {
          statusLine.textContent = 'Please provide numbers (comma-separated).';
          return;
        }
        base = Number(baseSelect.value);
        order = orderSelect.value;
        running = true;
        stepMode = true;
        paused = false;
        manager = createManager(originalArray, base, order);
        statusLine.textContent = 'Step mode: initialized.';
        renderArray(originalArray);
        renderBuckets(base);
      }
      // perform one action
      const res = await manager.nextAction();
      if (res.done) {
        // jobs complete; finalize result
        const final = manager.finalize();
        renderArray(final);
        bucketsArea.innerHTML = '';
        statusLine.textContent = `Done. Result: ${arrayToString(final)}`;
        manager = null;
        running = false;
        stepMode = false;
      } else {
        // still ongoing
        statusLine.textContent = res.message || 'Step executed.';
      }
    });

    // Initialize default rendering
    (function init(){
      originalArray = parseInput(inputArr.value);
      renderArray(originalArray);
      renderBuckets(Number(baseSelect.value));
      pauseBtn.disabled = true;
    })();

    // When base or input changes, update UI hints
    baseSelect.addEventListener('change', () => {
      renderBuckets(Number(baseSelect.value));
    });

    // Allow Enter to start
    inputArr.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') startBtn.click();
    });

  </script>
</body>
</html>