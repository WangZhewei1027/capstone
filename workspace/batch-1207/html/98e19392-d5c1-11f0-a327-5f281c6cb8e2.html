<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Union-Find (Disjoint Set) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --success: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
    }
    html,body { height:100%; margin:0; font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: linear-gradient(180deg,var(--bg), #071026); color: #e6eef8; }
    .app {
      display:flex;
      gap:18px;
      padding:18px;
      box-sizing:border-box;
      height:100vh;
    }
    .left {
      width:720px;
      background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.02));
      border-radius:12px;
      padding:14px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .controls {
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    }
    .controls button, .controls input[type="number"], .controls label {
      background:transparent; color:var(--accent); border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px;
    }
    .controls button:hover { background: rgba(255,255,255,0.02); }
    .controls input[type="number"] { width:80px; color:#dff6ff; }
    .canvas-wrap {
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:10px;
      padding:8px;
      display:flex; align-items:center; justify-content:center; position:relative;
    }
    svg { width:100%; height:100%; border-radius:6px; overflow:visible; }
    .right {
      width:360px;
      display:flex; flex-direction:column; gap:12px;
    }
    .panel {
      background:var(--panel); border-radius:12px; padding:12px; box-sizing:border-box;
    }
    .small {
      font-size:13px; color:var(--muted);
    }
    .arrays { display:flex; gap:10px; flex-direction:column; }
    .array-row { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .cell {
      background:var(--glass); padding:6px 8px; border-radius:8px; font-family:monospace; font-size:13px; color:#dff6ff;
    }
    .node {
      pointer-events:all;
    }
    .legend { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .legend .item { display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted); }
    .dot { width:12px; height:12px; border-radius:50%; }
    .footer { font-size:13px; color:var(--muted); }
    .selected { outline:2px solid rgba(255,255,255,0.12); box-shadow:0 4px 14px rgba(0,0,0,0.6); }
    .kbd { font-family:monospace; background:rgba(255,255,255,0.02); padding:2px 6px; border-radius:6px; font-size:12px; color:var(--muted); }
    .big {
      font-size:13px;
      color:#dff6ff;
    }
    .status { font-size:13px; color:var(--muted); }
    .btn-danger { border-color:rgba(255,120,120,0.18); color:var(--danger); }
    .btn-success { border-color:rgba(120,255,180,0.08); color:var(--success); }
    .toggle { display:inline-flex; gap:8px; align-items:center; }
    .notice { font-size:12px; color:var(--muted); margin-top:6px; }
    a { color:var(--accent); text-decoration:none; }
    /* arrow marker */
    marker {
      overflow:visible;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <div style="font-weight:700; font-size:18px;">Union-Find (Disjoint Set) Visualizer</div>
          <div class="small">Interactive demonstration of union by rank + path compression</div>
        </div>
        <div class="small">Nodes: <span id="nodeCount">0</span></div>
      </div>

      <div class="controls">
        <label title="Number of nodes to initialize">Initial nodes:
          <input id="initNum" type="number" min="1" max="40" value="8" />
        </label>
        <button id="initBtn" title="Create that many nodes (resets)">Initialize</button>
        <button id="addBtn" title="Add one node">Add Node</button>
        <button id="resetBtn" class="btn-danger" title="Reset everything">Reset</button>

        <div style="width:12px;"></div>

        <button id="autoBtn" title="Perform random unions continuously">Auto Random Unions</button>
        <button id="stepBtn" title="Perform one random union">One Random Union</button>

        <div style="flex:1"></div>

        <div class="toggle">
          <label class="small">Animate:</label>
          <input id="animateToggle" type="checkbox" checked />
        </div>
      </div>

      <div class="canvas-wrap panel">
        <svg id="svg" viewBox="0 0 800 520" preserveAspectRatio="xMidYMid meet">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,5 L0,10 z" fill="#cfeffd" opacity="0.9"></path>
            </marker>
          </defs>
          <!-- edges and nodes added by JS -->
        </svg>
        <div style="position:absolute; bottom:12px; left:12px; color:var(--muted); font-size:13px;">
          Click nodes to select: first selects A (blue), second selects B (orange). Use "Union Selected" or "Find Selected".
        </div>
      </div>

      <div style="display:flex; gap:10px;">
        <button id="unionBtn" class="btn-success">Union Selected</button>
        <button id="findBtn">Find Selected (show path)</button>
        <button id="compressBtn">Path Compress Selected</button>
        <button id="clearSelBtn">Clear Selection</button>

        <div style="flex:1"></div>

        <div class="status">
          Sets: <span id="setsCount">0</span>
        </div>
      </div>

    </div>

    <div class="right">
      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Arrays</div>
          <div class="small">Representation: parent[i] and rank[i]</div>
        </div>

        <div style="margin-top:8px;" class="arrays">
          <div><div class="small">parent</div>
            <div id="parentRow" class="array-row"></div>
          </div>
          <div><div class="small">rank</div>
            <div id="rankRow" class="array-row"></div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <div class="small">Click a node to inspect details:</div>
          <div class="big" id="info">No node selected</div>
        </div>
      </div>

      <div class="panel">
        <div style="font-weight:700;">Legend & Tips</div>
        <div class="notice">
          - Uses union by rank: attach lower-rank root under higher-rank root.<br/>
          - Path compression flattens trees during find: intermediate nodes are attached directly to root.<br/>
          - Try selecting nodes and using Find + Path Compress to see parent changes.
        </div>
        <div style="margin-top:10px;" class="legend">
          <div class="item"><div class="dot" id="exampleRoot" style="background:#9be7ff;"></div> set color = root</div>
          <div class="item"><svg width="36" height="16"><line x1="2" y1="8" x2="32" y2="8" stroke="#cfeffd" stroke-width="2" marker-end="url(#arrow)"></line></svg> parent pointer</div>
        </div>
      </div>

      <div class="panel" style="display:flex; flex-direction:column; gap:8px;">
        <div style="font-weight:700;">Code (core methods)</div>
        <pre style="margin:0; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; font-size:12px; color:#cfeffd;">
// Path compression
function find(x) {
  if (parent[x] === x) return x;
  return parent[x] = find(parent[x]);
}

// Union by rank
function union(a,b) {
  ra = find(a); rb = find(b);
  if (ra === rb) return;
  if (rank[ra] < rank[rb]) parent[ra] = rb;
  else if (rank[rb] < rank[ra]) parent[rb] = ra;
  else { parent[rb] = ra; rank[ra]++; }
}
        </pre>
      </div>

    </div>
  </div>

  <script>
    // Union-Find Visualizer
    (function(){
      const svg = document.getElementById('svg');
      const initBtn = document.getElementById('initBtn');
      const initNum = document.getElementById('initNum');
      const addBtn = document.getElementById('addBtn');
      const resetBtn = document.getElementById('resetBtn');
      const nodeCountEl = document.getElementById('nodeCount');
      const parentRow = document.getElementById('parentRow');
      const rankRow = document.getElementById('rankRow');
      const info = document.getElementById('info');
      const unionBtn = document.getElementById('unionBtn');
      const findBtn = document.getElementById('findBtn');
      const compressBtn = document.getElementById('compressBtn');
      const clearSelBtn = document.getElementById('clearSelBtn');
      const setsCountEl = document.getElementById('setsCount');
      const autoBtn = document.getElementById('autoBtn');
      const stepBtn = document.getElementById('stepBtn');
      const animateToggle = document.getElementById('animateToggle');

      let nodes = []; // {id, x,y, color}
      let parent = [];
      let rank = [];
      let selected = []; // selected node ids (max 2)
      let autoInterval = null;
      const width = 800, height = 520;
      const radius = 22;
      const colors = [
        '#9be7ff','#ffd99e','#c7f9cc','#f8c9ff','#ffd1d1','#c8d6ff','#ffd7a8','#b7ffd9',
        '#fab1ff','#d6ffd6','#f6ffb9','#c7e9ff'
      ];

      function randomColor(i){ return colors[i % colors.length]; }

      function init(n=8){
        stopAuto();
        clearSVG();
        nodes = [];
        parent = [];
        rank = [];
        selected = [];
        for(let i=0;i<n;i++){
          parent[i] = i;
          rank[i] = 0;
        }
        // place nodes around a circle for neatness
        const cx = width/2, cy = height/2, r = Math.min(width,height)/2 - 90;
        for(let i=0;i<n;i++){
          const angle = (i / n) * Math.PI*2;
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          nodes.push({id:i, x, y, color: randomColor(i)});
        }
        redraw();
        updateArrays();
      }

      function clearSVG(){ while(svg.lastChild) svg.removeChild(svg.lastChild); // recreate defs
        const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
        defs.innerHTML = '<marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L10,5 L0,10 z" fill="#cfeffd" opacity="0.9"></path></marker>';
        svg.appendChild(defs);
      }

      function redraw(){
        // Remove everything except defs
        const toRemove = [];
        for(const child of Array.from(svg.children)){
          if(child.tagName !== 'defs') toRemove.push(child);
        }
        toRemove.forEach(c=>svg.removeChild(c));

        // Draw edges (parent pointers) first
        for(const node of nodes){
          const p = parent[node.id];
          if(p !== node.id){
            const from = node; const to = nodes[p];
            drawArrow(from.x, from.y, to.x, to.y, node.id, p);
          }
        }

        // Draw nodes
        for(const node of nodes){
          drawNode(node);
        }

        nodeCountEl.textContent = nodes.length;
        setsCountEl.textContent = countSets();
      }

      function drawArrow(x1,y1,x2,y2, fromId, toId){
        // Draw a curved path for readability
        const dx = x2 - x1, dy = y2 - y1;
        const mx = (x1+x2)/2, my = (y1+y2)/2;
        const nx = -dy, ny = dx; // normal
        const len = Math.hypot(nx,ny) || 1;
        const norm = 20; // curvature
        const cx = mx + (nx/len)*norm;
        const cy = my + (ny/len)*norm;
        const path = document.createElementNS("http://www.w3.org/2000/svg","path");
        const d = `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
        path.setAttribute('d', d);
        path.setAttribute('stroke','#cfeffd');
        path.setAttribute('stroke-width','2');
        path.setAttribute('fill','none');
        path.setAttribute('marker-end','url(#arrow)');
        path.setAttribute('opacity','0.9');
        path.dataset.from = fromId;
        path.dataset.to = toId;
        svg.appendChild(path);
      }

      function drawNode(node){
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute('transform', `translate(${node.x},${node.y})`);
        g.classList.add('node');
        g.dataset.id = node.id;

        const circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', node.color);
        circle.setAttribute('stroke', '#071016');
        circle.setAttribute('stroke-width','3');
        circle.setAttribute('opacity','0.98');
        g.appendChild(circle);

        const labBg = document.createElementNS("http://www.w3.org/2000/svg","circle");
        labBg.setAttribute('r', 10);
        labBg.setAttribute('cx', 0);
        labBg.setAttribute('cy', 0);
        labBg.setAttribute('fill', 'rgba(0,0,0,0.25)');
        labBg.setAttribute('opacity','0.6');
        labBg.setAttribute('visibility','hidden'); // optional
        // g.appendChild(labBg);

        const text = document.createElementNS("http://www.w3.org/2000/svg","text");
        text.setAttribute('x', 0);
        text.setAttribute('y', 6);
        text.setAttribute('font-size', '14');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', '#041025');
        text.setAttribute('font-weight','700');
        text.textContent = node.id;
        g.appendChild(text);

        // small parent indicator
        const pText = document.createElementNS("http://www.w3.org/2000/svg","text");
        pText.setAttribute('x', 0);
        pText.setAttribute('y', 36);
        pText.setAttribute('font-size','11');
        pText.setAttribute('text-anchor','middle');
        pText.setAttribute('fill','#e1f7ff');
        pText.textContent = `p=${parent[node.id]}`;
        g.appendChild(pText);

        // event handlers
        g.style.cursor = 'pointer';
        g.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          onNodeClick(node.id);
        });

        svg.appendChild(g);

        // attach selection outline if selected
        if(selected.includes(node.id)){
          const sel = document.createElementNS("http://www.w3.org/2000/svg","circle");
          sel.setAttribute('r', radius+6);
          sel.setAttribute('fill','none');
          sel.setAttribute('stroke','#ffffff');
          sel.setAttribute('stroke-width','2');
          sel.setAttribute('opacity','0.12');
          g.insertBefore(sel, circle);
        }
      }

      function onNodeClick(id){
        if(selected.length === 0){
          selected.push(id);
        } else if(selected.length === 1){
          if(selected[0] === id){
            selected = [id]; // keep selection
          } else {
            selected.push(id);
          }
        } else {
          selected = [id];
        }
        updateInfo();
        redraw();
      }

      function updateInfo(){
        if(selected.length === 0){
          info.textContent = 'No node selected';
        } else if(selected.length === 1){
          const i = selected[0];
          info.innerHTML = `Selected: ${i} — parent: ${parent[i]} — rank: ${rank[i]} — root: ${findNoCompress(i)}`;
        } else {
          const a = selected[0], b = selected[1];
          info.innerHTML = `Selected A=${a} root=${findNoCompress(a)}, B=${b} root=${findNoCompress(b)}`;
        }
        redraw();
      }

      // Utility: count distinct roots
      function countSets(){
        const set = new Set();
        for(let i=0;i<parent.length;i++) set.add(findNoCompress(i));
        return set.size;
      }

      // Non-mutating find (no path compression), used for display
      function findNoCompress(x){
        while(parent[x] !== x) x = parent[x];
        return x;
      }

      // Animated find showing path
      async function animateFind(x){
        const path = [];
        let cur = x;
        while(parent[cur] !== cur){
          path.push(cur);
          cur = parent[cur];
        }
        path.push(cur); // include root
        // Highlight path
        highlightNodes(path, '#fff49a');
        await wait(600);
        // Clear highlight
        highlightNodes(path, null);
        updateInfo();
      }

      // Path compression for a selected node (animated)
      async function pathCompress(x){
        const path = [];
        let cur = x;
        while(parent[cur] !== cur){
          path.push(cur);
          cur = parent[cur];
        }
        const root = cur;
        if(path.length <= 1) return; // nothing to compress
        // animate reattaching each node in path directly to root
        for(const nodeId of path){
          // visually show change
          highlightNodes([nodeId], '#a6ffb3');
          await wait(350);
          parent[nodeId] = root;
          redraw();
          await wait(250);
          highlightNodes([nodeId], null);
        }
        redraw();
        updateArrays();
        updateInfo();
      }

      // Core find (with optional compression)
      function find(x){
        if(parent[x] === x) return x;
        return parent[x] = find(parent[x]);
      }

      async function unionSelected(){
        if(selected.length < 2){
          alert('Select two nodes first (click nodes).');
          return;
        }
        const a = selected[0], b = selected[1];
        await unionAnimate(a,b);
      }

      async function unionAnimate(a,b){
        const ra = findNoCompress(a), rb = findNoCompress(b);
        // highlight roots
        highlightNodes([ra, rb], '#ffd59e');
        await wait(600);
        if(ra === rb){
          // same set
          highlightNodes([ra], '#ff9b9b');
          await wait(500);
          highlightNodes([ra,rb], null);
          redraw();
          return;
        }
        // Show ranks
        // Perform union by rank
        let attach, root;
        if(rank[ra] < rank[rb]){
          attach = ra; root = rb;
        } else if(rank[rb] < rank[ra]){
          attach = rb; root = ra;
        } else {
          // tie: attach rb to ra and increment rank[ra]
          attach = rb; root = ra;
          rank[root] += 1;
        }
        // animate attaching: set parent[attach] = root
        parent[attach] = root;
        // small animation pause
        redraw();
        await wait(700);
        highlightNodes([root], '#a6ffb3');
        await wait(400);
        // update arrays
        updateArrays();
        highlightNodes([root, attach], null);
        redraw();
      }

      function highlightNodes(list, color){
        // recolor nodes temporarily by overriding node.color? Instead, draw overlays using SVG circles
        // Remove previous highlights
        for(const el of Array.from(svg.querySelectorAll('.hl'))) el.remove();
        if(!list || list.length===0) return;
        for(const id of list){
          const node = nodes[id];
          if(!node) continue;
          const g = document.createElementNS("http://www.w3.org/2000/svg","circle");
          g.classList.add('hl');
          g.setAttribute('cx', node.x);
          g.setAttribute('cy', node.y);
          g.setAttribute('r', radius+10);
          g.setAttribute('fill', color || '');
          g.setAttribute('opacity', color ? 0.25 : 0);
          svg.appendChild(g);
        }
      }

      function updateArrays(){
        parentRow.innerHTML = '';
        rankRow.innerHTML = '';
        for(let i=0;i<parent.length;i++){
          const c = document.createElement('div'); c.className='cell'; c.textContent = parent[i];
          parentRow.appendChild(c);
        }
        for(let i=0;i<rank.length;i++){
          const c = document.createElement('div'); c.className='cell'; c.textContent = rank[i];
          rankRow.appendChild(c);
        }
        setsCountEl.textContent = countSets();
      }

      function addNode(){
        stopAuto();
        const id = nodes.length;
        parent[id] = id; rank[id] = 0;
        // place new node at random around center with slight jitter
        const cx = width/2, cy = height/2, r = Math.min(width,height)/2 - 90;
        const angle = Math.random()*Math.PI*2;
        const x = cx + Math.cos(angle) * r * (0.9 + Math.random()*0.2);
        const y = cy + Math.sin(angle) * r * (0.9 + Math.random()*0.2);
        nodes.push({id, x, y, color: randomColor(id)});
        redraw();
        updateArrays();
      }

      function resetAll(){
        stopAuto();
        nodes = []; parent = []; rank = []; selected = [];
        updateArrays();
        redraw();
        info.textContent = 'No node selected';
      }

      function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }

      function findSelectedAnimate(){
        if(selected.length === 0){
          alert('Select a node first.');
          return;
        }
        const x = selected[0];
        animateFind(x);
      }

      function compressSelected(){
        if(selected.length === 0){
          alert('Select a node first.');
          return;
        }
        pathCompress(selected[0]);
      }

      // random union one pair (not already unioned)
      async function randomUnionOnce(){
        if(nodes.length < 2) return;
        const a = Math.floor(Math.random()*nodes.length);
        let b = Math.floor(Math.random()*nodes.length);
        while(b === a) b = Math.floor(Math.random()*nodes.length);
        await unionAnimate(a,b);
        updateArrays();
      }

      function startAuto(){
        if(autoInterval) { stopAuto(); return; }
        autoBtn.textContent = 'Stop Auto';
        autoInterval = setInterval(async ()=>{
          await randomUnionOnce();
        }, 900);
      }
      function stopAuto(){
        if(autoInterval){ clearInterval(autoInterval); autoInterval = null; autoBtn.textContent = 'Auto Random Unions'; }
      }

      // event wiring
      initBtn.addEventListener('click', ()=>init(Number(initNum.value) || 8));
      addBtn.addEventListener('click', addNode);
      resetBtn.addEventListener('click', resetAll);
      unionBtn.addEventListener('click', unionSelected);
      findBtn.addEventListener('click', findSelectedAnimate);
      compressBtn.addEventListener('click', compressSelected);
      clearSelBtn.addEventListener('click', ()=>{
        selected = []; updateInfo(); redraw();
      });
      autoBtn.addEventListener('click', ()=>{
        if(autoInterval) stopAuto(); else startAuto();
      });
      stepBtn.addEventListener('click', ()=>randomUnionOnce());

      // click empty space clears selection
      svg.addEventListener('click', (e)=>{ if(e.target === svg) { selected=[]; updateInfo(); redraw(); } });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === 'u') unionSelected();
        if(e.key === 'f') findSelectedAnimate();
        if(e.key === 'c') compressSelected();
        if(e.key === 'a') { if(autoInterval) stopAuto(); else startAuto(); }
      });

      // Initial
      init(Number(initNum.value) || 8);
      updateInfo();

      // Expose some functions for console debugging
      window.__ds = { parent, rank, nodes, findNoCompress, find, unionAnimate };

    })();
  </script>
</body>
</html>