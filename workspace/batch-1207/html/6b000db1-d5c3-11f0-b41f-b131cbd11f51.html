<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization - Directed & Undirected</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        h1 {
            margin-bottom: 10px;
        }
        .description {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #bdc3c7;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #3498db;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        button.active {
            background: #e74c3c;
        }
        .graph-types {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        .graph-type {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            padding: 20px;
        }
        canvas {
            border: 1px solid #bdc3c7;
            border-radius: 10px;
            background: #f8f9fa;
        }
        .info-panel {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #bdc3c7;
        }
        .details {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .details.active {
            display: block;
        }
        .graph-item {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .graph-item:hover {
            background: #e3f2fd;
        }
        footer {
            text-align: center;
            padding: 20px;
            background: #2c3e50;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Graph Visualization: Directed & Undirected</h1>
            <p class="description">A visualization tool to understand the differences between directed and undirected graphs.</p>
        </header>
        
        <div class="controls">
            <button id="directedBtn">Directed Graph</button>
            <button id="undirectedBtn">Undirected Graph</button>
            <button id="generateBtn">Generate New Graph</button>
            <button id="clearBtn">Clear Graph</button>
        </div>
        
        <div class="graph-types">
            <div class="graph-type">
                <h2>Directed Graph</h2>
                <p>A directed graph (or digraph) is a set of vertices connected by edges, where the edges have a direction associated with them.</p>
                <ul>
                    <li>Edges have direction (from one vertex to another)</li>
                    <li>Represented by arrows</li>
                    <li>Relationships are asymmetric</li>
                    <li>Examples: Web pages with hyperlinks, social media followers</li>
                </ul>
            </div>
            
            <div class="graph-type">
                <h2>Undirected Graph</h2>
                <p>An undirected graph is a set of vertices connected by edges, where the edges have no direction.</p>
                <ul>
                    <li>Edges have no direction (bidirectional)</li>
                    <li>Represented by simple lines</li>
                    <li>Relationships are symmetric</li>
                    <li>Examples: Facebook friends, road networks</li>
                </ul>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="graphCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="info-panel">
            <h3>Graph Information</h3>
            <p id="graphInfo">Select a graph type to see information.</p>
            <div id="vertexDetails" class="details"></div>
            <div id="edgeDetails" class="details"></div>
        </div>
        
        <footer>
            <p>Graph Theory Visualization | Directed & Undirected Graphs</p>
        </footer>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // Graph state variables
        let vertices = [];
        let edges = [];
        let isDirected = true;
        let selectedVertex = null;
        
        // Initialize the graph
        function init() {
            // Set default graph type
            document.getElementById('directedBtn').classList.add('active');
            
            // Generate initial graph
            generateRandomGraph();
            
            // Add event listeners
            document.getElementById('directedBtn').addEventListener('click', () => {
                setGraphType(true);
                document.getElementById('directedBtn').classList.add('active');
                document.getElementById('undirectedBtn').classList.remove('active');
            });
            
            document.getElementById('undirectedBtn').addEventListener('click', () => {
                setGraphType(false);
                document.getElementById('undirectedBtn').classList.add('active');
                document.getElementById('directedBtn').classList.remove('active');
            });
            
            document.getElementById('generateBtn').addEventListener('click', generateRandomGraph);
            document.getElementById('clearBtn').addEventListener('click', clearGraph);
            
            canvas.addEventListener('click', handleCanvasClick);
            
            // Display initial information
            updateGraphInfo();
        }
        
        // Set graph type (directed or undirected)
        function setGraphType(directed) {
            isDirected = directed;
            redrawGraph();
            updateGraphInfo();
        }
        
        // Generate a random graph
        function generateRandomGraph() {
            vertices = [];
            edges = [];
            
            // Create vertices
            const vertexCount = Math.floor(Math.random() * 8) + 3; // 3 to 10 vertices
            for (let i = 0; i < vertexCount; i++) {
                const x = 50 + Math.random() * (canvas.width - 100);
                const y = 50 + Math.random() * (canvas.height - 100);
                vertices.push({ id: i, x: x, y: y, label: String.fromCharCode(65 + i) });
            }
            
            // Create edges
            const edgeCount = Math.floor(Math.random() * (vertexCount * 2)) + vertexCount;
            for (let i = 0; i < edgeCount; i++) {
                const from = Math.floor(Math.random() * vertexCount);
                let to = Math.floor(Math.random() * vertexCount);
                
                // Ensure we don't have self-loops for this example
                while (to === from) {
                    to = Math.floor(Math.random() * vertexCount);
                }
                
                // Check if edge already exists
                const edgeExists = edges.some(edge => 
                    (edge.from === from && edge.to === to) || 
                    (!isDirected && edge.from === to && edge.to === from)
                );
                
                if (!edgeExists) {
                    edges.push({ from: from, to: to, weight: Math.floor(Math.random() * 10) + 1 });
                }
            }
            
            redrawGraph();
            updateGraphInfo();
        }
        
        // Clear the graph
        function clearGraph() {
            vertices = [];
            edges = [];
            redrawGraph();
            updateGraphInfo();
        }
        
        // Handle canvas click
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if a vertex was clicked
            for (let i = 0; i < vertices.length; i++) {
                const vertex = vertices[i];
                const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);
                
                if (distance <= 20) { // Vertex radius is 20
                    selectedVertex = vertex;
                    showVertexDetails(vertex);
                    redrawGraph();
                    return;
                }
            }
            
            // If no vertex was clicked, clear selection
            selectedVertex = null;
            document.getElementById('vertexDetails').classList.remove('active');
            document.getElementById('edgeDetails').classList.remove('active');
            redrawGraph();
        }
        
        // Show vertex details
        function showVertexDetails(vertex) {
            const vertexDetails = document.getElementById('vertexDetails');
            const edgeDetails = document.getElementById('edgeDetails');
            
            // Find edges connected to this vertex
            const connectedEdges = edges.filter(edge => 
                edge.from === vertex.id || edge.to === vertex.id
            );
            
            vertexDetails.innerHTML = `
                <h4>Vertex ${vertex.label}</h4>
                <p>ID: ${vertex.id}</p>
                <p>Position: (${Math.round(vertex.x)}, ${Math.round(vertex.y)})</p>
                <p>Degree: ${connectedEdges.length}</p>
            `;
            
            edgeDetails.innerHTML = `
                <h4>Connected Edges</h4>
                <ul>
                    ${connectedEdges.map(edge => {
                        const fromVertex = vertices[edge.from];
                        const toVertex = vertices[edge.to];
                        return `<li>${fromVertex.label} ${isDirected ? '→' : '—'} ${toVertex.label} (Weight: ${edge.weight})</li>`;
                    }).join('')}
                </ul>
            `;
            
            vertexDetails.classList.add('active');
            edgeDetails.classList.add('active');
        }
        
        // Update graph information display
        function updateGraphInfo() {
            const graphInfo = document.getElementById('graphInfo');
            graphInfo.textContent = `
                Graph Type: ${isDirected ? 'Directed' : 'Undirected'} | 
                Vertices: ${vertices.length} | 
                Edges: ${edges.length} |
                Density: ${calculateDensity().toFixed(2)}
            `;
        }
        
        // Calculate graph density
        function calculateDensity() {
            const n = vertices.length;
            if (n <= 1) return 0;
            
            const maxEdges = isDirected ? n * (n - 1) : n * (n - 1) / 2;
            return edges.length / maxEdges;
        }
        
        // Draw the graph
        function redrawGraph() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            edges.forEach(edge => {
                const fromVertex = vertices[edge.from];
                const toVertex = vertices[edge.to];
                
                drawEdge(fromVertex, toVertex, edge.weight, isDirected);
            });
            
            // Draw vertices
            vertices.forEach(vertex => {
                drawVertex(vertex, vertex === selectedVertex);
            });
        }
        
        // Draw a vertex
        function drawVertex(vertex, isSelected) {
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = isSelected ? '#e74c3c' : '#3498db';
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw label
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(vertex.label, vertex.x, vertex.y);
        }
        
        // Draw an edge
        function drawEdge(fromVertex, toVertex, weight, isDirected) {
            // Calculate angle between vertices
            const angle = Math.atan2(toVertex.y - fromVertex.y, toVertex.x - fromVertex.x);
            const startX = fromVertex.x + 20 * Math.cos(angle);
            const startY = fromVertex.y + 20 * Math.sin(angle);
            const endX = toVertex.x - 20 * Math.cos(angle);
            const endY = toVertex.y - 20 * Math.sin(angle);
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw arrow for directed graphs
            if (isDirected) {
                const arrowLength = 10;
                const arrowAngle = Math.PI / 6;
                
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - arrowAngle),
                    endY - arrowLength * Math.sin(angle - arrowAngle)
                );
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + arrowAngle),
                    endY - arrowLength * Math.sin(angle + arrowAngle)
                );
                ctx.closePath();
                ctx.fillStyle = '#2c3e50';
                ctx.fill();
            }
            
            // Draw weight
            const midX = (fromVertex.x + toVertex.x) / 2;
            const midY = (fromVertex.y + toVertex.y) / 2;
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#e74c3c';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(weight, midX, midY);
        }
        
        // Initialize the application
        window.onload = init;
    </script>
</body>
</html>