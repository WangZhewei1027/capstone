<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Tree (BST) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#38bdf8;
      --accent-2:#60a5fa;
      --muted:#94a3b8;
      --node:#0ea5a4;
      --node-fill:#06b6d4;
      --node-highlight:#fde047;
      --text:#e6eef8;
      --danger:#fb7185;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071028, #08122b);color:var(--text);}
    .app{
      display:flex;height:100vh;gap:16px;padding:16px;
      box-sizing:border-box;
    }
    .left{
      width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:10px;box-shadow:0 6px 24px rgba(2,6,23,0.6);
      display:flex;flex-direction:column;gap:12px;
    }
    h1{font-size:18px;margin:0 0 6px 0;}
    p.help{margin:0;color:var(--muted);font-size:13px;}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
    input[type="number"], input[type="text"]{
      padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:var(--text);outline:none;
    }
    button{
      padding:10px;border-radius:8px;border:0;background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#04263b;font-weight:600;cursor:pointer;
      box-shadow: 0 6px 18px rgba(3,105,161,0.12);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text);box-shadow:none;}
    button.danger{background:linear-gradient(180deg,var(--danger),#ff7b8a);color:#2b0216;}
    .small{padding:8px;font-size:13px;}
    .actions{display:flex;gap:8px;flex-wrap:wrap;}
    .panel{
      background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);
    }
    .traversal-output{min-height:48px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);color:var(--muted);font-size:14px;display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px;}
    .footer{margin-top:auto;font-size:12px;color:var(--muted);}
    .canvas-wrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03);position:relative;overflow:hidden;}
    .svg-canvas{width:100%;height:100%;display:block;}
    .node{cursor:pointer;transition:transform 200ms ease;}
    .node circle{transition:fill 200ms, r 200ms, stroke 200ms;}
    .node text{fill:#021422;font-weight:700;font-size:12px;pointer-events:none;}
    .node .value{dominant-baseline:middle;text-anchor:middle;}
    .node.normal circle{fill:var(--node-fill);stroke:rgba(0,0,0,0.25);stroke-width:2;}
    .node.searching circle{fill:var(--accent);stroke:rgba(0,0,0,0.35);stroke-width:3; r:20;}
    .node.found circle{fill:var(--node-highlight);stroke:#c084fc;stroke-width:3;}
    .node.deleted circle{fill:#fca5a5;stroke:#b91c1c;}
    .edge{stroke:rgba(255,255,255,0.07);stroke-width:2}
    .controls-row{display:flex;gap:8px;}
    .info{font-size:13px;color:var(--muted);line-height:1.4}
    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .legend .key{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    .smalltext{font-size:12px;color:var(--muted)}
    @media (max-width:900px){
      .app{flex-direction:column;padding:12px;}
      .left{width:100%;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left panel">
      <h1>Binary Search Tree (BST) — Interactive Demo</h1>
      <p class="help">Insert, find, delete keys and watch how the BST structure changes. Use traversals to see visiting order.</p>

      <div class="panel">
        <div class="label">Insert / Delete / Search</div>
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <input id="valueInput" type="number" placeholder="Enter integer key" />
          <button id="insertBtn">Insert</button>
          <button id="deleteBtn" class="danger">Delete</button>
        </div>
        <div style="display:flex;gap:8px;">
          <input id="searchInput" type="number" placeholder="Search key" />
          <button id="searchBtn" class="ghost small">Search</button>
          <button id="clearBtn" class="ghost small">Clear Tree</button>
        </div>
        <div class="smalltext" style="margin-top:8px;">Tip: Click a node in the visualization to delete it quickly.</div>
      </div>

      <div class="panel">
        <div class="label">Traversals (animated)</div>
        <div class="actions">
          <button id="inorderBtn" class="small">In-order</button>
          <button id="preorderBtn" class="small">Pre-order</button>
          <button id="postorderBtn" class="small">Post-order</button>
          <button id="levelBtn" class="small">Level-order</button>
          <button id="stopAnim" class="ghost small">Stop</button>
        </div>
        <div style="margin-top:8px" class="traversal-output" id="traversalOutput">Sequence will appear here...</div>
      </div>

      <div class="panel">
        <div class="label">Quick actions</div>
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <button id="randomBtn" class="small">Random Tree</button>
          <button id="balancedBtn" class="small ghost">Balanced (7 nodes)</button>
          <button id="sampleBtn" class="small ghost">Sample Walkthrough</button>
        </div>
        <div class="legend" style="margin-top:6px;">
          <div class="key"><span style="display:inline-block;width:14px;height:14px;background:var(--node-fill);border-radius:3px"></span> Node</div>
          <div class="key"><span style="display:inline-block;width:14px;height:14px;background:var(--node-highlight);border-radius:3px"></span> Found</div>
        </div>
      </div>

      <div class="footer">
        <div class="info">BST rules: left < right for each node. Duplicate keys are ignored.</div>
      </div>
    </div>

    <div class="canvas-wrap panel" id="canvasWrap">
      <svg id="svg" class="svg-canvas" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>

  <script>
  /*****************************************************************************
   * Binary Search Tree interactive demo
   * - Supports insert, search, delete
   * - Traversals: inorder, preorder, postorder, level-order (animated)
   * - Visualized with SVG; click nodes to delete
   *
   * Implementation notes:
   * - Keys are integer values.
   * - Layout: assign x positions using inorder indexing, y by depth.
   * - Deletion handles 3 cases (leaf, one child, two children using successor replacement).
   *****************************************************************************/

  // Basic BST node class
  class Node {
    constructor(key){
      this.key = key;
      this.left = null;
      this.right = null;
      this.parent = null;
      this.x = 0; // layout position
      this.y = 0;
    }
  }

  class BST {
    constructor(){
      this.root = null;
    }

    insert(key){
      const node = new Node(key);
      if (!this.root){
        this.root = node;
        return true;
      }
      let cur = this.root;
      while (true){
        if (key === cur.key) return false; // ignore duplicates
        if (key < cur.key){
          if (!cur.left){
            cur.left = node;
            node.parent = cur;
            return true;
          }
          cur = cur.left;
        } else {
          if (!cur.right){
            cur.right = node;
            node.parent = cur;
            return true;
          }
          cur = cur.right;
        }
      }
    }

    find(key){
      let cur = this.root;
      while (cur){
        if (key === cur.key) return cur;
        cur = (key < cur.key) ? cur.left : cur.right;
      }
      return null;
    }

    // Transplant subtree u with v (v may be null)
    transplant(u, v){
      if (!u.parent){
        this.root = v;
      } else if (u === u.parent.left){
        u.parent.left = v;
      } else {
        u.parent.right = v;
      }
      if (v) v.parent = u.parent;
    }

    minNode(node){
      let cur = node;
      while (cur && cur.left) cur = cur.left;
      return cur;
    }

    delete(key){
      const z = this.find(key);
      if (!z) return false;
      // Standard BST deletion
      if (!z.left){
        this.transplant(z, z.right);
      } else if (!z.right){
        this.transplant(z, z.left);
      } else {
        const y = this.minNode(z.right);
        if (y.parent !== z){
          this.transplant(y, y.right);
          y.right = z.right;
          if (y.right) y.right.parent = y;
        }
        this.transplant(z, y);
        y.left = z.left;
        if (y.left) y.left.parent = y;
      }
      return true;
    }

    // Traversals that return arrays of nodes
    inorder(node=this.root, arr=[]){
      if (!node) return arr;
      this.inorder(node.left, arr);
      arr.push(node);
      this.inorder(node.right, arr);
      return arr;
    }
    preorder(node=this.root, arr=[]){
      if (!node) return arr;
      arr.push(node);
      this.preorder(node.left, arr);
      this.preorder(node.right, arr);
      return arr;
    }
    postorder(node=this.root, arr=[]){
      if (!node) return arr;
      this.postorder(node.left, arr);
      this.postorder(node.right, arr);
      arr.push(node);
      return arr;
    }
    levelOrder(){
      const arr=[];
      if (!this.root) return arr;
      const q=[this.root];
      while(q.length){
        const n=q.shift();
        arr.push(n);
        if(n.left) q.push(n.left);
        if(n.right) q.push(n.right);
      }
      return arr;
    }

    // utility: get all keys (sorted)
    keys(){
      return this.inorder().map(n=>n.key);
    }
  }

  // UI + Visualization
  const svg = document.getElementById('svg');
  const valueInput = document.getElementById('valueInput');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const searchInput = document.getElementById('searchInput');
  const searchBtn = document.getElementById('searchBtn');
  const clearBtn = document.getElementById('clearBtn');
  const randomBtn = document.getElementById('randomBtn');
  const balancedBtn = document.getElementById('balancedBtn');
  const sampleBtn = document.getElementById('sampleBtn');
  const inorderBtn = document.getElementById('inorderBtn');
  const preorderBtn = document.getElementById('preorderBtn');
  const postorderBtn = document.getElementById('postorderBtn');
  const levelBtn = document.getElementById('levelBtn');
  const traversalOutput = document.getElementById('traversalOutput');
  const stopAnim = document.getElementById('stopAnim');
  const canvasWrap = document.getElementById('canvasWrap');

  let bst = new BST();

  // Animation controls
  let animTimer = null;
  let stopRequested = false;

  function clearAnim(){
    stopRequested = true;
    if (animTimer){ clearTimeout(animTimer); animTimer = null;}
  }

  stopAnim.addEventListener('click', () => {
    clearAnim();
    resetHighlights();
  });

  // Layout parameters
  const width = 1200;
  const height = 800;
  const levelHeight = 110;
  const nodeR = 20;

  // Compute positions: inorder-based x coordinate, y = depth * levelHeight
  function computePositions(){
    // assign x by inorder index
    let index = 0;
    (function dfs(node, depth){
      if (!node) return;
      dfs(node.left, depth+1);
      node.x = ++index; // temporary index
      node.y = depth;
      dfs(node.right, depth+1);
    })(bst.root, 0);

    // Determine max index
    const maxIndex = index || 1;
    // Map to SVG coordinates
    const marginX = 60;
    const usableW = width - marginX*2;
    const spacing = usableW / maxIndex;
    (function dfs2(node){
      if (!node) return;
      node.cx = marginX + (node.x - 0.5)*spacing; // center x
      node.cy = 60 + node.y * levelHeight;
      dfs2(node.left);
      dfs2(node.right);
    })(bst.root);
  }

  // Render tree into SVG
  function render(){
    // Clear animation highlights when re-rendering (but not if in traversal)
    // We'll fully rebuild SVG for simplicity
    svg.innerHTML = '';
    computePositions();
    // Add edges first
    (function drawEdges(node){
      if (!node) return;
      if (node.left){
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', node.cx);
        line.setAttribute('y1', node.cy);
        line.setAttribute('x2', node.left.cx);
        line.setAttribute('y2', node.left.cy);
        line.setAttribute('class','edge');
        svg.appendChild(line);
      }
      if (node.right){
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', node.cx);
        line.setAttribute('y1', node.cy);
        line.setAttribute('x2', node.right.cx);
        line.setAttribute('y2', node.right.cy);
        line.setAttribute('class','edge');
        svg.appendChild(line);
      }
      drawEdges(node.left);
      drawEdges(node.right);
    })(bst.root);

    // Add nodes
    (function drawNode(node){
      if (!node) return;
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('transform', `translate(${node.cx},${node.cy})`);
      g.setAttribute('data-key', node.key);
      g.setAttribute('class','node normal');

      // group components
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r', nodeR);
      circle.setAttribute('cx', 0);
      circle.setAttribute('cy', 0);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','value');
      text.setAttribute('x', 0);
      text.setAttribute('y', 4); // adjust baseline
      text.textContent = node.key;

      // click to delete quickly
      g.addEventListener('click', (e)=>{
        e.stopPropagation();
        // confirm
        if (!confirm('Delete node ' + node.key + ' ?')) return;
        clearAnim();
        bst.delete(node.key);
        render();
      });

      g.appendChild(circle);
      g.appendChild(text);
      svg.appendChild(g);
      drawNode(node.left);
      drawNode(node.right);
    })(bst.root);

    // Fit viewBox to content gracefully
    // We keep static viewBox width/height for simplicity (1200x800) to keep layout stable
    // Reset traversal output if tree empty
    if (!bst.root){
      traversalOutput.textContent = 'Tree is empty';
    }
  }

  function resetHighlights(){
    const nodes = svg.querySelectorAll('.node');
    nodes.forEach(n=> {
      n.classList.remove('searching','found','deleted');
      n.classList.add('normal');
    });
  }

  // Helper to highlight a node by key
  function highlightKey(key, cls){
    const g = svg.querySelector('.node[data-key="'+key+'"]');
    if (!g) return;
    g.classList.remove('normal');
    g.classList.add(cls);
  }

  // Insertion handler
  insertBtn.addEventListener('click', ()=>{
    const val = Number(valueInput.value);
    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer value.'); return; }
    clearAnim();
    const ok = bst.insert(val);
    if (!ok){
      alert('Duplicate key ignored.');
    }
    render();
    valueInput.value = '';
  });

  // Delete handler using input
  deleteBtn.addEventListener('click', ()=>{
    const val = Number(valueInput.value);
    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer key to delete.'); return; }
    clearAnim();
    const ok = bst.delete(val);
    if (!ok){
      alert('Key not found.');
    }
    render();
    valueInput.value = '';
  });

  // Search handler: animate search path
  searchBtn.addEventListener('click', ()=>{
    const val = Number(searchInput.value);
    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer key to search.'); return; }
    clearAnim();
    resetHighlights();
    let cur = bst.root;
    const path = [];
    while (cur){
      path.push(cur);
      if (val === cur.key) break;
      cur = (val < cur.key) ? cur.left : cur.right;
    }
    animatePath(path, cur && cur.key===val ? 'found' : 'deleted', ()=> {
      if (!cur) traversalOutput.textContent = `Key ${val} not found. Path visited: ` + path.map(n=>n.key).join(', ');
      else traversalOutput.textContent = `Found ${val}. Path: ` + path.map(n=>n.key).join(' → ');
    });
    searchInput.value = '';
  });

  // Click on blank area clears selected highlights
  svg.addEventListener('click', (e)=>{
    resetHighlights();
  });

  // Traversal animations
  function animateSequence(nodes, labelPrefix='Visited', speed=500){
    clearAnim();
    traversalOutput.textContent = labelPrefix + ': ';
    const arr = nodes.slice(); // nodes are Node objects
    let i = 0;
    stopRequested = false;
    function step(){
      if (stopRequested) { resetHighlights(); traversalOutput.textContent += ' (stopped)'; return; }
      if (i>0){
        // un-highlight previous
        const prev = arr[i-1];
        const pg = svg.querySelector('.node[data-key="'+prev.key+'"]');
        if (pg) pg.classList.remove('searching');
      }
      if (i >= arr.length){
        // all done
        traversalOutput.textContent = labelPrefix + ': ' + arr.map(n=>n.key).join(', ');
        if (arr.length>0){
          const last = arr[arr.length-1];
          const lg = svg.querySelector('.node[data-key="'+last.key+'"]');
          if (lg){
            lg.classList.add('found');
            lg.classList.remove('searching');
          }
        }
        animTimer = null;
        return;
      }
      const node = arr[i];
      const g = svg.querySelector('.node[data-key="'+node.key+'"]');
      if (g){
        g.classList.add('searching');
        g.classList.remove('normal');
      }
      traversalOutput.textContent = labelPrefix + ': ' + arr.slice(0,i+1).map(n=>n.key).join(', ');
      i++;
      animTimer = setTimeout(step, speed);
    }
    step();
  }

  function animatePath(pathNodes, finalClass, callback){
    clearAnim();
    let i = 0;
    stopRequested = false;
    traversalOutput.textContent = 'Searching: ';
    function step(){
      if (stopRequested) { resetHighlights(); traversalOutput.textContent += ' (stopped)'; return; }
      if (i>0){
        const prev = pathNodes[i-1];
        const pg = svg.querySelector('.node[data-key="'+prev.key+'"]');
        if (pg) pg.classList.remove('searching');
      }
      if (i >= pathNodes.length){
        // done; highlight final status
        if (pathNodes.length>0){
          const last = pathNodes[pathNodes.length-1];
          const lg = svg.querySelector('.node[data-key="'+last.key+'"]');
          if (lg){
            if (finalClass === 'found'){
              lg.classList.remove('searching'); lg.classList.add('found');
            } else {
              lg.classList.remove('searching'); lg.classList.add('deleted');
            }
          }
        }
        animTimer = null;
        if (callback) callback();
        return;
      }
      const node = pathNodes[i];
      const g = svg.querySelector('.node[data-key="'+node.key+'"]');
      if (g){
        g.classList.add('searching');
        g.classList.remove('normal');
      }
      traversalOutput.textContent = 'Searching: ' + pathNodes.slice(0,i+1).map(n=>n.key).join(' → ');
      i++;
      animTimer = setTimeout(step, 450);
    }
    step();
  }

  inorderBtn.addEventListener('click', ()=>{
    const nodes = bst.inorder();
    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }
    animateSequence(nodes, 'In-order', 450);
  });
  preorderBtn.addEventListener('click', ()=>{
    const nodes = bst.preorder();
    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }
    animateSequence(nodes, 'Pre-order', 450);
  });
  postorderBtn.addEventListener('click', ()=>{
    const nodes = bst.postorder();
    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }
    animateSequence(nodes, 'Post-order', 450);
  });
  levelBtn.addEventListener('click', ()=>{
    const nodes = bst.levelOrder();
    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }
    animateSequence(nodes, 'Level-order', 450);
  });

  // Utility: random tree
  randomBtn.addEventListener('click', ()=>{
    clearAnim();
    bst = new BST();
    const n = Math.floor(Math.random()*8)+3; // 3..10 nodes
    const keys = new Set();
    while (keys.size < n){
      keys.add(Math.floor(Math.random()*90)-45); // allow negatives
    }
    [...keys].forEach(k => bst.insert(k));
    render();
    traversalOutput.textContent = 'Random tree with '+n+' nodes: ' + bst.keys().join(', ');
  });

  balancedBtn.addEventListener('click', ()=>{
    clearAnim();
    // create a balanced-ish BST by inserting middle-first for 7 nodes
    bst = new BST();
    const arr = [1,2,3,4,5,6,7];
    function build(a){
      if (!a.length) return;
      const mid = Math.floor(a.length/2);
      bst.insert(a[mid]);
      build(a.slice(0,mid));
      build(a.slice(mid+1));
    }
    build(arr);
    render();
    traversalOutput.textContent = 'Balanced sample created (1..7)';
  });

  sampleBtn.addEventListener('click', ()=>{
    clearAnim();
    bst = new BST();
    [50,30,70,20,40,60,80,10,25,35,45,55,65].forEach(x=>bst.insert(x));
    render();
    traversalOutput.textContent = 'Sample walkthrough tree populated.';
  });

  clearBtn.addEventListener('click', ()=>{
    if (!confirm('Clear the entire tree?')) return;
    clearAnim();
    bst = new BST();
    render();
    traversalOutput.textContent = 'Tree cleared.';
  });

  // initialize with some sample nodes
  (function init(){
    bst.insert(50);
    bst.insert(30);
    bst.insert(70);
    bst.insert(20);
    bst.insert(40);
    bst.insert(60);
    bst.insert(80);
    render();
    traversalOutput.textContent = 'Sample tree loaded. Try insert/search/delete or traversals.';
  })();

  // Make the SVG responsive to container size
  function resizeViewBox(){
    // Keep as fixed viewBox (1200x800) but scale the SVG to fit container using preserveAspectRatio.
    // Optionally could adjust on small screens; leaving as-is for simplicity.
  }
  window.addEventListener('resize', resizeViewBox);
  </script>
</body>
</html>