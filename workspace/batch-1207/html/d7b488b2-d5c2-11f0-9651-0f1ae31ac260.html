<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linear Regression Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f9f9f9;
  }
  h1 {
    text-align: center;
  }
  #container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    padding: 15px 30px 40px 30px;
    box-shadow: 0 0 15px rgba(0,0,0,0.1);
    border-radius: 10px;
  }
  #plot {
    border: 1px solid #ddd;
    margin-top: 20px;
    background: #fff;
  }
  .controls {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    flex-wrap: wrap;
  }
  .control-group {
    margin: 10px 0;
    flex: 1 1 250px;
    max-width: 300px;
  }
  label {
    display: block;
    margin-bottom: 6px;
    font-weight: 600;
  }
  input[type=number], input[type=text] {
    width: 100%;
    padding: 6px 8px;
    font-size: 16px;
    box-sizing: border-box;
  }
  button {
    background-color: #0078d7;
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 4px;
    margin-top: 10px;
  }
  button:hover {
    background-color: #005fa3;
  }
  #info {
    margin-top: 20px;
    font-size: 18px;
  }
  #info span {
    font-weight: bold;
  }
  #instructions {
    font-size: 14px;
    color: #555;
    margin-top: 15px;
  }
</style>
</head>
<body>
  <div id="container">
    <h1>Linear Regression Demo</h1>
    <p>
      Add points by clicking on the plot area. The linear regression line fit to the points will update live.
    </p>
    <canvas id="plot" width="800" height="400"></canvas>
    <div class="controls">
      <div class="control-group">
        <button id="clearBtn">Clear Points</button>
      </div>
      <div class="control-group">
        <label for="predictX">Predict y at x = </label>
        <input type="number" id="predictX" step="any" value="0" />
        <button id="predictBtn">Predict</button>
        <div id="predictionResult"></div>
      </div>
    </div>
    <div id="info">
      <div>Slope (m): <span id="slope">-</span></div>
      <div>Intercept (b): <span id="intercept">-</span></div>
      <div>R² (Coefficient of Determination): <span id="r2">-</span></div>
    </div>
    <div id="instructions">
      <p><strong>Instructions:</strong></p>
      <ul>
        <li>Click inside the plot area to add data points.</li>
        <li>The regression line updates as you add points.</li>
        <li>Use the prediction box to find y for any x using the fitted line.</li>
        <li>Click "Clear Points" to start over.</li>
      </ul>
    </div>
  </div>

<script>
// Linear Regression Functions
function linearRegression(points) {
  const n = points.length;
  if (n === 0) return null;
  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY=0;
  for (const p of points) {
    sumX += p.x;
    sumY += p.y;
    sumXY += p.x*p.y;
    sumXX += p.x*p.x;
    sumYY += p.y*p.y;
  }
  const meanX = sumX / n;
  const meanY = sumY / n;
  const denominator = (sumXX - sumX*meanX);
  if (denominator === 0) {
    // vertical line or all points same X
    return null;
  }
  const m = (sumXY - sumX*meanY) / denominator;
  const b = meanY - m*meanX;

  // R squared:
  // R² = 1 - SS_res / SS_tot
  let SS_res = 0, SS_tot = 0;
  for (const p of points) {
    const y_pred = m*p.x + b;
    SS_res += (p.y - y_pred)**2;
    SS_tot += (p.y - meanY)**2;
  }
  const r2 = SS_tot === 0 ? 1 : 1 - SS_res/SS_tot;
  return {m,b,r2};
}

function drawPlot(ctx, points, regression, width, height, padding) {
  ctx.clearRect(0, 0, width, height);

  // Determine plotting boundaries (with margin)
  let xs = points.map(p => p.x);
  let ys = points.map(p => p.y);
  let minX = Math.min(...xs);
  let maxX = Math.max(...xs);
  let minY = Math.min(...ys);
  let maxY = Math.max(...ys);
  if (points.length === 0) {
    minX = 0; maxX = 10;
    minY = 0; maxY = 10;
  } else if (maxX === minX) {
    maxX = minX + 1;
  } 
  if (maxY === minY) {
    maxY = minY + 1;
  }
  // Add 10% margin
  const xMargin = (maxX - minX)*0.1;
  const yMargin = (maxY - minY)*0.1;
  minX -= xMargin;
  maxX += xMargin;
  minY -= yMargin;
  maxY += yMargin;

  // Functions to transform data <-> canvas coords
  function xToCanvas(x) {
    return padding + (x - minX) / (maxX - minX) * (width - 2*padding);
  }
  function yToCanvas(y) {
    return height - padding - (y - minY) / (maxY - minY) * (height - 2*padding);
  }
  function canvasToX(cx) {
    return minX + (cx - padding) / (width - 2*padding) * (maxX - minX);
  }
  function canvasToY(cy) {
    return minY + (height - padding - cy) / (height - 2*padding) * (maxY - minY);
  }

  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1.5;
  ctx.fillStyle = '#333';
  ctx.font = '13px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // X axis line
  ctx.beginPath();
  ctx.moveTo(padding, height - padding);
  ctx.lineTo(width - padding, height - padding);
  ctx.stroke();

  // Y axis line
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, height - padding);
  ctx.stroke();

  // Draw ticks and labels
  const xTicks = 7;
  for (let i=0; i<=xTicks; i++) {
    const xVal = minX + i*(maxX-minX)/xTicks;
    const cx = xToCanvas(xVal);
    ctx.beginPath();
    ctx.moveTo(cx, height - padding);
    ctx.lineTo(cx, height - padding + 6);
    ctx.stroke();
    ctx.fillText(xVal.toFixed(2), cx, height - padding + 18);
  }
  const yTicks = 7;
  ctx.textAlign = 'right';
  for (let i=0; i<=yTicks; i++) {
    const yVal = minY + i*(maxY-minY)/yTicks;
    const cy = yToCanvas(yVal);
    ctx.beginPath();
    ctx.moveTo(padding-6, cy);
    ctx.lineTo(padding, cy);
    ctx.stroke();
    ctx.fillText(yVal.toFixed(2), padding-8, cy);
  }

  // Draw points
  ctx.fillStyle = '#0078d7';
  for (const p of points) {
    const cx = xToCanvas(p.x);
    const cy = yToCanvas(p.y);
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, 2*Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#004a8f';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Draw regression line if any
  if (regression) {
    ctx.strokeStyle = 'crimson';
    ctx.lineWidth = 3;
    const x1 = minX;
    const y1 = regression.m*x1 + regression.b;
    const x2 = maxX;
    const y2 = regression.m*x2 + regression.b;
    const cx1 = xToCanvas(x1);
    const cy1 = yToCanvas(y1);
    const cx2 = xToCanvas(x2);
    const cy2 = yToCanvas(y2);

    ctx.beginPath();
    ctx.moveTo(cx1, cy1);
    ctx.lineTo(cx2, cy2);
    ctx.stroke();

    // Draw equation text near line end
    ctx.fillStyle = 'crimson';
    ctx.font = '16px Arial';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    let mFixed = regression.m.toFixed(3);
    let bFixed = regression.b.toFixed(3);
    let eqText = `y = ${mFixed}x + ${bFixed}`;
    ctx.fillText(eqText, cx2 - 5, cy2 + 5);
  }

  return {canvasToX, canvasToY};
}

// Main
(function() {
  const canvas = document.getElementById('plot');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const padding = 50;

  let points = [];

  let coordConverters = null;

  function updateRegressionInfo(regr) {
    const slopeSpan = document.getElementById('slope');
    const interceptSpan = document.getElementById('intercept');
    const r2Span = document.getElementById('r2');

    if (!regr) {
      slopeSpan.textContent = '-';
      interceptSpan.textContent = '-';
      r2Span.textContent = '-';
      return;
    }
    slopeSpan.textContent = regr.m.toFixed(5);
    interceptSpan.textContent = regr.b.toFixed(5);
    r2Span.textContent = regr.r2.toFixed(5);
  }

  function redraw() {
    const regression = linearRegression(points);
    coordConverters = drawPlot(ctx, points, regression, width, height, padding);
    updateRegressionInfo(regression);
  }

  canvas.addEventListener('click', function(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    if (!coordConverters) {
      redraw();
    }
    const x = coordConverters.canvasToX(cx);
    const y = coordConverters.canvasToY(cy);
    points.push({x,y});
    redraw();
    document.getElementById('predictionResult').textContent = '';
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    points = [];
    redraw();
    document.getElementById('predictionResult').textContent = '';
  });

  document.getElementById('predictBtn').addEventListener('click', () => {
    const val = document.getElementById('predictX').value;
    const xValue = parseFloat(val);
    if (isNaN(xValue)) {
      alert('Please enter a valid number for x.');
      return;
    }
    const regression = linearRegression(points);
    const resultDiv = document.getElementById('predictionResult');
    if (!regression) {
      resultDiv.textContent = 'Add at least two points with varying x to perform prediction.';
      return;
    }
    const yPred = regression.m*xValue + regression.b;
    resultDiv.textContent = `Predicted y = ${yPred.toFixed(5)}`;
  });

  redraw();
})();
</script>
</body>
</html>