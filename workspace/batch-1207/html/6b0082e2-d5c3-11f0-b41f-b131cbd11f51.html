<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Sort Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            text-align: center;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        h1 {
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .array-container {
            margin: 30px auto;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 320px;
            position: relative;
        }
        
        .array-bar {
            width: 20px;
            margin: 0 2px;
            background: linear-gradient(to top, #00c6ff, #0072ff);
            border-radius: 5px 5px 0 0;
            transition: height 0.3s, background 0.3s;
        }
        
        .array-bar.split {
            background: linear-gradient(to top, #ff9966, #ff5e62);
        }
        
        .array-bar.merge {
            background: linear-gradient(to top, #56ab2f, #a8e063);
        }
        
        .array-bar.active {
            border: 2px solid white;
            box-sizing: border-box;
        }
        
        .array-bar.sorted {
            background: linear-gradient(to top, #f46b45, #eea849);
        }
        
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 3px;
        }
        
        .details {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: left;
        }
        
        .status {
            margin: 20px 0;
            font-size: 1.2rem;
            min-height: 30px;
        }
        
        .complexity {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .complexity-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 5px;
            flex: 1;
            min-width: 150px;
        }
        
        @media (max-width: 768px) {
            .array-container {
                height: 250px;
            }
            
            .array-bar {
                width: 15px;
                margin: 0 1px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Merge Sort Visualizer</h1>
        <p>Watch how the merge sort algorithm works step by step</p>
        
        <div class="controls">
            <button id="generate">Generate New Array</button>
            <button id="sort">Start Sorting</button>
            <button id="pause">Pause</button>
            <button id="reset">Reset</button>
            <button id="step">Step Forward</button>
        </div>
        
        <div class="slider-container">
            <label for="size">Array Size: <span id="size-value">25</span></label>
            <input type="range" id="size" min="5" max="50" value="25">
            
            <label for="speed">Animation Speed: <span id="speed-value">50</span></label>
            <input type="range" id="speed" min="1" max="100" value="50">
        </div>
        
        <div class="status" id="status">Ready to sort!</div>
        
        <div class="array-container" id="array-container"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(to top, #00c6ff, #0072ff);"></div>
                <span>Unsorted</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(to top, #ff9966, #ff5e62);"></div>
                <span>Split/Division</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(to top, #56ab2f, #a8e063);"></div>
                <span>Merge Operation</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(to top, #f46b45, #eea849);"></div>
                <span>Sorted</span>
            </div>
        </div>
        
        <div class="complexity">
            <div class="complexity-item">
                <h3>Time Complexity</h3>
                <p>Best: O(n log n)</p>
                <p>Average: O(n log n)</p>
                <p>Worst: O(n log n)</p>
            </div>
            <div class="complexity-item">
                <h3>Space Complexity</h3>
                <p>Worst: O(n)</p>
            </div>
            <div class="complexity-item">
                <h3>Stable</h3>
                <p>Yes</p>
            </div>
        </div>
        
        <div class="details">
            <h2>About Merge Sort</h2>
            <p>Merge Sort is a divide-and-conquer algorithm that works by recursively splitting the array into smaller subarrays until each subarray contains a single element, then merging those subarrays in a sorted manner.</p>
            <p><strong>Steps:</strong></p>
            <ol>
                <li>Divide the unsorted array into two halves</li>
                <li>Recursively sort both halves</li>
                <li>Merge the two sorted halves to produce the final sorted array</li>
            </ol>
            <p>Merge Sort guarantees O(n log n) time complexity in all cases, making it more efficient than simpler algorithms like Bubble Sort or Insertion Sort for large datasets.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const arrayContainer = document.getElementById('array-container');
            const generateBtn = document.getElementById('generate');
            const sortBtn = document.getElementById('sort');
            const pauseBtn = document.getElementById('pause');
            const resetBtn = document.getElementById('reset');
            const stepBtn = document.getElementById('step');
            const sizeSlider = document.getElementById('size');
            const speedSlider = document.getElementById('speed');
            const sizeValue = document.getElementById('size-value');
            const speedValue = document.getElementById('speed-value');
            const status = document.getElementById('status');
            
            // Variables
            let array = [];
            let animationSpeed = 101 - speedSlider.value; // Reverse the value so higher = faster
            let arraySize = parseInt(sizeSlider.value);
            let isSorting = false;
            let isPaused = false;
            let animations = [];
            let animationIndex = 0;
            let animationInterval;
            
            // Initialize
            generateNewArray();
            
            // Event listeners
            generateBtn.addEventListener('click', generateNewArray);
            sortBtn.addEventListener('click', startSorting);
            pauseBtn.addEventListener('click', togglePause);
            resetBtn.addEventListener('click', resetVisualization);
            stepBtn.addEventListener('click', stepForward);
            sizeSlider.addEventListener('input', updateSize);
            speedSlider.addEventListener('input', updateSpeed);
            
            // Functions
            function generateNewArray() {
                resetVisualization();
                array = [];
                const containerWidth = arrayContainer.clientWidth;
                const barWidth = Math.max(5, Math.min(30, containerWidth / arraySize - 4));
                
                for (let i = 0; i < arraySize; i++) {
                    array.push(Math.floor(Math.random() * 280) + 20); // Values between 20 and 300
                }
                
                renderArray();
                status.textContent = "New array generated. Ready to sort!";
            }
            
            function renderArray(highlightIndices = []) {
                arrayContainer.innerHTML = '';
                const maxValue = Math.max(...array);
                const containerHeight = arrayContainer.clientHeight;
                
                for (let i = 0; i < array.length; i++) {
                    const bar = document.createElement('div');
                    bar.classList.add('array-bar');
                    bar.style.height = `${(array[i] / maxValue) * containerHeight * 0.9}px`;
                    
                    if (highlightIndices.includes(i)) {
                        bar.classList.add('active');
                    }
                    
                    arrayContainer.appendChild(bar);
                }
            }
            
            function updateSize() {
                arraySize = parseInt(sizeSlider.value);
                sizeValue.textContent = arraySize;
                if (!isSorting) {
                    generateNewArray();
                }
            }
            
            function updateSpeed() {
                animationSpeed = 101 - parseInt(speedSlider.value);
                speedValue.textContent = speedSlider.value;
                
                if (isSorting && !isPaused) {
                    clearInterval(animationInterval);
                    startAnimation();
                }
            }
            
            function startSorting() {
                if (isSorting) return;
                
                isSorting = true;
                isPaused = false;
                animations = [];
                animationIndex = 0;
                
                // Generate merge sort animations
                const arrayCopy = [...array];
                mergeSort(arrayCopy, 0, arrayCopy.length - 1, []);
                
                status.textContent = "Sorting in progress...";
                disableControls(true);
                
                startAnimation();
            }
            
            function mergeSort(arr, left, right, indices) {
                if (left >= right) return;
                
                const mid = Math.floor((left + right) / 2);
                
                // Record division
                animations.push({
                    type: 'split',
                    indices: [...indices, left, right]
                });
                
                // Sort left half
                mergeSort(arr, left, mid, [...indices, left, mid]);
                
                // Sort right half
                mergeSort(arr, mid + 1, right, [...indices, mid + 1, right]);
                
                // Merge halves
                merge(arr, left, mid, right, indices);
            }
            
            function merge(arr, left, mid, right, indices) {
                const leftArr = arr.slice(left, mid + 1);
                const rightArr = arr.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    // Record comparison
                    animations.push({
                        type: 'compare',
                        indices: [left + i, mid + 1 + j]
                    });
                    
                    if (leftArr[i] <= rightArr[j]) {
                        arr[k] = leftArr[i];
                        // Record assignment
                        animations.push({
                            type: 'assign',
                            index: k,
                            value: leftArr[i],
                            indices: [...indices, left, right]
                        });
                        i++;
                    } else {
                        arr[k] = rightArr[j];
                        // Record assignment
                        animations.push({
                            type: 'assign',
                            index: k,
                            value: rightArr[j],
                            indices: [...indices, left, right]
                        });
                        j++;
                    }
                    k++;
                }
                
                while (i < leftArr.length) {
                    arr[k] = leftArr[i];
                    // Record assignment
                    animations.push({
                        type: 'assign',
                        index: k,
                        value: leftArr[i],
                        indices: [...indices, left, right]
                    });
                    i++;
                    k++;
                }
                
                while (j < rightArr.length) {
                    arr[k] = rightArr[j];
                    // Record assignment
                    animations.push({
                        type: 'assign',
                        index: k,
                        value: rightArr[j],
                        indices: [...indices, left, right]
                    });
                    j++;
                    k++;
                }
            }
            
            function startAnimation() {
                animationInterval = setInterval(() => {
                    if (animationIndex < animations.length) {
                        performAnimationStep();
                        animationIndex++;
                    } else {
                        finishSorting();
                    }
                }, animationSpeed);
            }
            
            function performAnimationStep() {
                const animation = animations[animationIndex];
                
                if (animation.type === 'split') {
                    status.textContent = `Splitting array from index ${animation.indices[0]} to ${animation.indices[1]}`;
                    highlightRange(animation.indices, 'split');
                } else if (animation.type === 'compare') {
                    status.textContent = `Comparing elements at indices ${animation.indices[0]} and ${animation.indices[1]}`;
                    highlightIndices(animation.indices);
                } else if (animation.type === 'assign') {
                    status.textContent = `Placing value ${animation.value} at index ${animation.index}`;
                    array[animation.index] = animation.value;
                    highlightRange(animation.indices, 'merge');
                    renderArray([animation.index]);
                }
            }
            
            function highlightRange(indices, className) {
                renderArray();
                
                const bars = arrayContainer.querySelectorAll('.array-bar');
                for (let i = indices[0]; i <= indices[1]; i++) {
                    if (i < bars.length) {
                        bars[i].classList.add(className);
                    }
                }
            }
            
            function highlightIndices(indices) {
                renderArray(indices);
            }
            
            function finishSorting() {
                clearInterval(animationInterval);
                isSorting = false;
                disableControls(false);
                status.textContent = "Array sorted successfully!";
                
                // Highlight all bars as sorted
                const bars = arrayContainer.querySelectorAll('.array-bar');
                bars.forEach(bar => {
                    bar.classList.remove('split', 'merge', 'active');
                    bar.classList.add('sorted');
                });
            }
            
            function togglePause() {
                if (!isSorting) return;
                
                if (isPaused) {
                    isPaused = false;
                    pauseBtn.textContent = "Pause";
                    startAnimation();
                    status.textContent = "Resuming sort...";
                } else {
                    isPaused = true;
                    pauseBtn.textContent = "Resume";
                    clearInterval(animationInterval);
                    status.textContent = "Sorting paused";
                }
            }
            
            function resetVisualization() {
                clearInterval(animationInterval);
                isSorting = false;
                isPaused = false;
                animations = [];
                animationIndex = 0;
                disableControls(false);
                pauseBtn.textContent = "Pause";
                status.textContent = "Visualization reset";
                
                // Reset to original unsorted array if needed
                if (array.length > 0) {
                    renderArray();
                }
            }
            
            function stepForward() {
                if (!isSorting || isPaused) {
                    if (!isSorting) {
                        animations = [];
                        animationIndex = 0;
                        const arrayCopy = [...array];
                        mergeSort(arrayCopy, 0, arrayCopy.length - 1, []);
                        isSorting = true;
                        disableControls(true);
                    }
                    
                    if (animationIndex < animations.length) {
                        performAnimationStep();
                        animationIndex++;
                    } else {
                        finishSorting();
                    }
                }
            }
            
            function disableControls(disable) {
                generateBtn.disabled = disable;
                sortBtn.disabled = disable;
                resetBtn.disabled = disable && !isPaused;
                stepBtn.disabled = !disable || isPaused;
                sizeSlider.disabled = disable;
                
                if (disable) {
                    pauseBtn.disabled = false;
                } else {
                    pauseBtn.disabled = true;
                }
            }
        });
    </script>
</body>
</html>