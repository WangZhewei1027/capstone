<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Huffman Coding Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 30px;
    max-width: 900px;
  }
  h1 {
    text-align: center;
  }
  textarea {
    width: 100%;
    height: 80px;
    font-family: monospace;
    font-size: 16px;
  }
  button {
    margin-top: 10px;
    font-size: 16px;
    padding: 8px 15px;
    cursor: pointer;
  }
  .section {
    margin-top: 25px;
    border: 1px solid #ddd;
    padding: 15px;
    border-radius: 6px;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    max-width: 400px;
  }
  th, td {
    border: 1px solid #aaa;
    padding: 6px 8px;
    text-align: center;
  }
  th {
    background-color: #f0f0f0;
  }
  .tree-node {
    border: 1px solid #666;
    border-radius: 6px;
    padding: 6px 10px;
    display: inline-block;
    margin: 6px;
    position: relative;
    background: #eef6fc;
    font-weight: bold;
  }
  .tree-children {
    display: flex;
    justify-content: center;
    margin-top: 20px;
  }
  .tree-children > div {
    flex: 1;
  }
  .line-down {
    position: absolute;
    left: 50%;
    bottom: -20px;
    width: 2px;
    height: 20px;
    background: #666;
  }
  .line-right {
    position: absolute;
    top: 20px;
    left: 50%;
    height: 2px;
    width: 50%;
    background: #666;
  }
  .line-left {
    position: absolute;
    top: 20px;
    left: 0;
    height: 2px;
    width: 50%;
    background: #666;
  }
  .code-text {
    font-family: monospace;
    background: #f8f8f8;
    padding: 6px 10px;
    border-radius: 4px;
    white-space: nowrap;
    margin-top: 6px;
    display: inline-block;
  }
  .highlight {
    background-color: #ffffcc;
  }
  .error {
    color: red;
    font-weight: bold;
    margin-top: 5px;
  }
  .footer {
    margin-top: 40px;
    font-size: 0.9em;
    color: #666;
    text-align: center;
  }
</style>
</head>
<body>
<h1>Huffman Coding Demonstration</h1>
<p>Enter text below to see Huffman coding compression steps including frequency, tree, codes, encoded string, and decoded result.</p>

<textarea id="inputText" placeholder="Type your text here... (e.g. hello huffman)"></textarea>
<br />
<button id="compressBtn">Encode and Decode</button>
<div id="errorMsg" class="error" role="alert" aria-live="assertive"></div>

<div id="output" class="section" aria-live="polite" aria-atomic="true" style="display:none;">
  <h2>Frequencies</h2>
  <table aria-describedby="freqDesc">
    <caption id="freqDesc">Frequency of each character in the input.</caption>
    <thead><tr><th>Character</th><th>Frequency</th></tr></thead>
    <tbody id="freqTableBody"></tbody>
  </table>

  <h2>Huffman Tree Visualization</h2>
  <div id="treeContainer" aria-label="Huffman Tree visualization"></div>

  <h2>Huffman Codes</h2>
  <table aria-describedby="codeDesc">
    <caption id="codeDesc">Codeword assigned to each character</caption>
    <thead><tr><th>Character</th><th>Code</th></tr></thead>
    <tbody id="codesTableBody"></tbody>
  </table>

  <h2>Encoded Binary String</h2>
  <pre id="encodedString" style="max-height: 160px; overflow-x: auto; background:#f0f0f0; padding:10px; border-radius:4px;"></pre>

  <h2>Decoded Text</h2>
  <pre id="decodedString" style="background:#f0f0f0; padding:10px; border-radius:4px;"></pre>
</div>

<script>
(() => {
  const inputTextElem = document.getElementById('inputText');
  const compressBtn = document.getElementById('compressBtn');
  const freqTableBody = document.getElementById('freqTableBody');
  const codesTableBody = document.getElementById('codesTableBody');
  const encodedStringElem = document.getElementById('encodedString');
  const decodedStringElem = document.getElementById('decodedString');
  const treeContainer = document.getElementById('treeContainer');
  const outputSection = document.getElementById('output');
  const errorMsg = document.getElementById('errorMsg');

  /**
   * Build frequency map from input string.
   * @param {string} str 
   * @returns {Map<string, number>}
   */
  function buildFrequency(str) {
    const freq = new Map();
    for (const char of str) {
      freq.set(char, (freq.get(char) || 0) + 1);
    }
    return freq;
  }

  /**
   * Huffman Tree Node class
   */
  class Node {
    constructor(char, freq, left = null, right = null) {
      this.char = char;
      this.freq = freq;
      this.left = left;
      this.right = right;
    }
  }

  /**
   * Build Huffman tree given frequency map
   * @param {Map<string, number>} freqMap
   * @returns {Node} root of Huffman tree
   */
  function buildHuffmanTree(freqMap) {
    const nodes = [];
    for (const [char, freq] of freqMap) {
      nodes.push(new Node(char, freq));
    }

    // Edge case: if only one character, create a dummy node
    if (nodes.length === 1) {
      const onlyNode = nodes[0];
      return new Node(null, onlyNode.freq, onlyNode, null);
    }

    // Build the tree by always merging two smallest nodes
    while (nodes.length > 1) {
      nodes.sort((a,b) => a.freq - b.freq);
      const left = nodes.shift();
      const right = nodes.shift();
      const merged = new Node(null, left.freq + right.freq, left, right);
      nodes.push(merged);
    }
    return nodes[0];
  }

  /**
   * Traverse tree to generate code map char=>code
   * @param {Node} root 
   * @returns {Map<string,string>}
   */
  function generateCodes(root) {
    const codes = new Map();
    function traverse(node, prefix) {
      if (!node) return;
      if (node.char !== null) {
        codes.set(node.char, prefix || '0'); // if only one char, assign '0'
        return;
      }
      traverse(node.left, prefix + '0');
      traverse(node.right, prefix + '1');
    }
    traverse(root, '');
    return codes;
  }

  /**
   * Encode input string using codes map
   * @param {string} input 
   * @param {Map<string,string>} codes 
   * @returns {string}
   */
  function encode(input, codes) {
    let result = '';
    for (const ch of input) {
      result += codes.get(ch);
    }
    return result;
  }

  /**
   * Decode bit string using Huffman tree
   * @param {string} bitStr 
   * @param {Node} root 
   * @returns {string}
   */
  function decode(bitStr, root) {
    let result = '';
    let curr = root;
    for (const bit of bitStr) {
      curr = bit === '0' ? curr.left : curr.right;
      if (!curr.left && !curr.right) { // leaf node
        result += curr.char;
        curr = root;
      }
    }
    return result;
  }

  /**
   * Utility to escape special HTML characters for table display
   * @param {string} s 
   * @returns {string}
   */
  function escapeHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\s/g, c => {
      if(c === ' ') return '&nbsp;';
      if(c === '\n') return '<br>';
      return c;
    });
  }

  /**
   * Render frequency table
   * @param {Map<string, number>} freqMap 
   */
  function renderFrequencies(freqMap) {
    freqTableBody.innerHTML = '';
    // Sort by frequency descending, then char ascending
    const entries = Array.from(freqMap.entries()).sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]));
    for (const [char, freq] of entries) {
      const tr = document.createElement('tr');
      const charTd = document.createElement('td');
      charTd.innerHTML = char === ' ' ? '<i>space</i>': escapeHtml(char);
      const freqTd = document.createElement('td');
      freqTd.textContent = freq;
      tr.appendChild(charTd);
      tr.appendChild(freqTd);
      freqTableBody.appendChild(tr);
    }
  }

  /**
   * Render codes table
   * @param {Map<string,string>} codes 
   */
  function renderCodes(codes) {
    codesTableBody.innerHTML = '';
    // Sort by char utf16 code for consistency
    const entries = Array.from(codes.entries()).sort((a,b) => a[0].localeCompare(b[0]));
    for (const [char, code] of entries) {
      const tr = document.createElement('tr');
      const charTd = document.createElement('td');
      charTd.innerHTML = char === ' ' ? '<i>space</i>' : escapeHtml(char);
      const codeTd = document.createElement('td');
      codeTd.textContent = code;
      tr.appendChild(charTd);
      tr.appendChild(codeTd);
      codesTableBody.appendChild(tr);
    }
  }

  /**
   * Visualize the Huffman tree in the container
   * @param {Node} root
   */
  function renderTree(root) {
    treeContainer.innerHTML = '';

    /**
     * Recursive function to create node elements
     * @param {Node} node 
     * @returns {HTMLElement}
     */
    function createNodeElement(node) {
      const nodeDiv = document.createElement('div');
      nodeDiv.classList.add('tree-node');
      let label;
      if (node.char === null) {
        label = `* (${node.freq})`;
      } else {
        const displayChar = node.char === ' ' ? 'space' : node.char;
        label = `'${displayChar}' (${node.freq})`;
      }
      nodeDiv.textContent = label;

      // If leaf, no children
      if (!node.left && !node.right) return nodeDiv;

      const childrenCont = document.createElement('div');
      childrenCont.classList.add('tree-children');

      if (node.left) {
        const leftChild = createNodeElement(node.left);
        // Line connectors
        leftChild.style.position = 'relative';
        const lineDownLeft = document.createElement('div');
        lineDownLeft.classList.add('line-down');
        leftChild.appendChild(lineDownLeft);
        childrenCont.appendChild(leftChild);
      } else {
        const emptyDiv = document.createElement('div');
        childrenCont.appendChild(emptyDiv);
      }
      if (node.right) {
        const rightChild = createNodeElement(node.right);
        rightChild.style.position = 'relative';
        const lineDownRight = document.createElement('div');
        lineDownRight.classList.add('line-down');
        rightChild.appendChild(lineDownRight);
        childrenCont.appendChild(rightChild);
      } else {
        const emptyDiv = document.createElement('div');
        childrenCont.appendChild(emptyDiv);
      }

      nodeDiv.appendChild(childrenCont);

      return nodeDiv;
    }

    treeContainer.appendChild(createNodeElement(root));
  }

  compressBtn.addEventListener('click', () => {
    errorMsg.textContent = '';
    outputSection.style.display = 'none';

    const input = inputTextElem.value;
    if (!input) {
      errorMsg.textContent = 'Please input some text to encode.';
      return;
    }

    const freqMap = buildFrequency(input);
    if (freqMap.size === 0) {
      errorMsg.textContent = 'Input text does not contain valid characters.';
      return;
    }

    // Build tree
    const treeRoot = buildHuffmanTree(freqMap);
    // Generate codes
    const codeMap = generateCodes(treeRoot);

    // Encode
    const encoded = encode(input, codeMap);

    // Decode
    const decoded = decode(encoded, treeRoot);

    // Show frequencies
    renderFrequencies(freqMap);

    // Show codes
    renderCodes(codeMap);

    // Show tree
    renderTree(treeRoot);

    // Show encoded string (break lines for easier reading)
    // Group bits in blocks of 8 for readability
    let presentedEncoded = '';
    for(let i=0; i<encoded.length; i++) {
      presentedEncoded += encoded[i];
      if ((i+1) % 8 === 0) presentedEncoded += ' ';
      if ((i+1) % 64 === 0) presentedEncoded += '\n';
    }
    encodedStringElem.textContent = presentedEncoded.trim();

    // Show decoded string
    decodedStringElem.textContent = decoded;

    outputSection.style.display = 'block';
  });
})();
</script>
</body>
</html>