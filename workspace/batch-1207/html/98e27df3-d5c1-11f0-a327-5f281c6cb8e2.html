<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Knapsack Problem — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#3b82f6; --muted:#94a3b8; --text:#e6eef8;
      --good:#16a34a; --bad:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Arial;background:linear-gradient(180deg,#061029 0%,#071526 100%);color:var(--text);}
    .container{max-width:1100px;margin:28px auto;padding:22px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;border:1px solid rgba(255,255,255,0.03);}
    header{display:flex;gap:16px;align-items:center;margin-bottom:14px}
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .layout{display:flex;gap:18px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    .left{width:320px;min-width:260px}
    .right{flex:1;overflow:auto}
    label{display:block;font-size:12px;margin-bottom:6px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
    input[type="number"], input[type="text"], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    button{padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:white;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
    .small{padding:6px 8px;font-size:13px}
    ul.items{list-style:none;padding:0;margin:8px 0 0 0}
    li.item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;margin-bottom:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)}
    .meta{font-size:13px;color:var(--muted)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .visual{padding:12px}
    .table-wrap{overflow:auto;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:rgba(255,255,255,0.01);padding:8px}
    table.dp{border-collapse:collapse}
    table.dp td, table.dp th{border:1px solid rgba(255,255,255,0.03);padding:6px;font-family:monospace;text-align:center;min-width:34px}
    table.dp th{background:rgba(255,255,255,0.02);font-weight:600}
    .cell-current{background:linear-gradient(90deg, rgba(59,130,246,0.18), rgba(59,130,246,0.06));}
    .cell-update{background:linear-gradient(90deg, rgba(34,197,94,0.14), rgba(34,197,94,0.04));}
    .chosen{background:linear-gradient(90deg, rgba(99,102,241,0.12), rgba(99,102,241,0.03));}
    .legend{display:flex;gap:12px;align-items:center;margin-top:8px;color:var(--muted);font-size:13px}
    .badge{display:inline-block;padding:4px 8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px}
    .result{margin-top:12px;padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border:1px solid rgba(255,255,255,0.02)}
    .item-pill{display:inline-block;padding:4px 8px;border-radius:8px;margin-right:6px;background:rgba(255,255,255,0.02)}
    .speed{width:120px}
    footer{margin-top:14px;color:var(--muted);font-size:12px}
    .flex-between{display:flex;justify-content:space-between;align-items:center}
    .fraction-bar{height:18px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;display:flex}
    .fraction-seg{height:100%;display:flex;align-items:center;justify-content:center;font-size:12px;color:white}
    .fraction-label{font-size:13px;color:var(--muted);margin-top:6px}
    .warning{color:var(--bad);font-size:13px}
    .ok{color:var(--good);font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    /* responsive */
    @media (max-width:900px){.layout{flex-direction:column}.left{width:100%}}
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <div>
        <h1>Knapsack Problem — Interactive Demo</h1>
        <p class="lead">Explore 0/1 knapsack (dynamic programming) and fractional knapsack (greedy). Add items, set capacity, animate the DP table and see the optimal selection.</p>
      </div>
    </header>

    <div class="layout">
      <div class="panel left">
        <div class="flex-between">
          <div>
            <label>Capacity (integer)</label>
            <input id="capacityInput" type="number" min="1" max="200" value="20">
            <div class="muted" style="margin-top:6px">For DP table, keep capacity ≤ 60 for readability.</div>
          </div>
          <div style="width:10px"></div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02);margin:12px 0">

        <label>Items</label>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <input id="nameInput" type="text" placeholder="name" style="width:28%">
          <input id="weightInput" type="number" placeholder="weight" min="1" value="5" style="width:34%">
          <input id="valueInput" type="number" placeholder="value" min="0" value="10" style="width:34%">
        </div>
        <div class="controls" style="margin-bottom:10px">
          <button id="addItemBtn" class="small">Add item</button>
          <button id="randomBtn" class="ghost small">Random items</button>
          <button id="clearBtn" class="ghost small">Clear</button>
        </div>

        <ul id="itemsList" class="items" aria-live="polite"></ul>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.02);margin:12px 0">

        <label>Algorithm</label>
        <select id="algoSelect">
          <option value="dp">0/1 Knapsack — Dynamic Programming (exact)</option>
          <option value="fractional">Fractional Knapsack — Greedy (by value/weight)</option>
        </select>

        <div style="margin-top:10px">
          <label>Animation speed</label>
          <input id="speed" class="speed" type="range" min="10" max="1000" value="200">
          <div class="muted" id="speedLabel">delay: 200 ms per cell</div>
        </div>

        <div style="margin-top:10px" class="controls">
          <button id="runBtn">Run</button>
          <button id="stepBtn" class="ghost">Step</button>
          <button id="resetBtn" class="ghost">Reset</button>
        </div>

        <div style="margin-top:12px">
          <label>Options</label>
          <div style="display:flex;gap:8px;margin-top:8px">
            <label style="font-size:13px"><input type="checkbox" id="showTable" checked> Show DP table</label>
            <label style="font-size:13px"><input type="checkbox" id="animate" checked> Animate</label>
          </div>
        </div>

        <footer>
          Tip: Add several items, set capacity, choose DP, then "Run" to animate filling the table. Use "Fractional" to see greedy filling with partial items.
        </footer>
      </div>

      <div class="panel right">
        <div class="visual">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div>
              <div class="muted">Items (weight, value, value/weight)</div>
            </div>
            <div>
              <span class="badge">Capacity: <strong id="capBadge">20</strong></span>
              <span class="badge">Algorithm: <strong id="algBadge">DP</strong></span>
            </div>
          </div>

          <div id="itemsPreview" style="margin-bottom:12px"></div>

          <div id="visualArea">
            <div id="dpArea">
              <div class="legend">
                <div class="muted">DP Table:</div>
                <div class="badge"><span style="display:inline-block;width:10px;height:10px;background:linear-gradient(90deg, rgba(59,130,246,0.18), rgba(59,130,246,0.06));border-radius:2px;margin-right:6px"></span> current cell</div>
                <div class="badge"><span style="display:inline-block;width:10px;height:10px;background:linear-gradient(90deg, rgba(34,197,94,0.14), rgba(34,197,94,0.04));border-radius:2px;margin-right:6px"></span> updated when taking item</div>
                <div class="badge"><span style="display:inline-block;width:10px;height:10px;background:linear-gradient(90deg, rgba(99,102,241,0.12), rgba(99,102,241,0.03));border-radius:2px;margin-right:6px"></span> chosen in final solution</div>
              </div>

              <div id="tableWrap" class="table-wrap" style="margin-top:12px"></div>

              <div id="fracArea" style="margin-top:12px;display:none">
                <div class="muted">Fractional knapsack visualization</div>
                <div style="margin-top:8px" id="fractionBar" class="fraction-bar"></div>
                <div id="fractionInfo" style="margin-top:8px"></div>
              </div>

              <div id="result" class="result" style="display:none">
                <div><strong>Result</strong></div>
                <div style="margin-top:8px">
                  <div>Total value: <strong id="totalValue">0</strong></div>
                  <div>Total weight: <strong id="totalWeight">0</strong></div>
                  <div style="margin-top:8px">Items chosen:</div>
                  <div id="chosenItems" style="margin-top:6px"></div>
                </div>
              </div>

            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
/*
  Interactive Knapsack demo
  - Manage items (name, weight, value)
  - Choose algorithm: 0/1 DP or Fractional Greedy
  - Animate DP table fill and reconstruct chosen items
*/

(() => {
  // State
  let items = [
    {name:'A', w:6, v:30},
    {name:'B', w:3, v:14},
    {name:'C', w:4, v:16},
    {name:'D', w:2, v:9}
  ];
  let capacity = 20;
  let algo = 'dp';
  let animating = false;
  let dpTable = [];
  let currentAnimation = null;
  let animateEnabled = true;
  let showTable = true;

  // Elements
  const itemsListEl = document.getElementById('itemsList');
  const itemsPreview = document.getElementById('itemsPreview');
  const capInput = document.getElementById('capacityInput');
  const capBadge = document.getElementById('capBadge');
  const nameInput = document.getElementById('nameInput');
  const weightInput = document.getElementById('weightInput');
  const valueInput = document.getElementById('valueInput');
  const addItemBtn = document.getElementById('addItemBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const algoSelect = document.getElementById('algoSelect');
  const algBadge = document.getElementById('algBadge');
  const runBtn = document.getElementById('runBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const tableWrap = document.getElementById('tableWrap');
  const dpArea = document.getElementById('dpArea');
  const resultEl = document.getElementById('result');
  const totalValueEl = document.getElementById('totalValue');
  const totalWeightEl = document.getElementById('totalWeight');
  const chosenItemsEl = document.getElementById('chosenItems');
  const fractionBar = document.getElementById('fractionBar');
  const fractionInfo = document.getElementById('fractionInfo');
  const fracArea = document.getElementById('fracArea');
  const speedInput = document.getElementById('speed');
  const speedLabel = document.getElementById('speedLabel');
  const showTableCheck = document.getElementById('showTable');
  const animateCheck = document.getElementById('animate');

  // Utility
  function renderItemsList(){
    itemsListEl.innerHTML = '';
    items.forEach((it, idx) => {
      const li = document.createElement('li');
      li.className = 'item';
      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.flexDirection = 'column';
      left.innerHTML = `<strong style="font-size:14px">${it.name}</strong><span class="meta">w:${it.w}  v:${it.v}  ${ (it.v/it.w).toFixed(2)} value/w</span>`;
      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.gap = '8px';
      const del = document.createElement('button');
      del.className = 'ghost small';
      del.textContent = 'Remove';
      del.onclick = () => { items.splice(idx,1); updateAll(); };
      right.appendChild(del);
      li.appendChild(left);
      li.appendChild(right);
      itemsListEl.appendChild(li);
    });
    renderItemsPreview();
  }

  function renderItemsPreview(){
    itemsPreview.innerHTML = '';
    if(items.length===0){
      itemsPreview.innerHTML = '<div class="muted">No items yet. Add items or generate random ones.</div>';
      algBadge.textContent = algo === 'dp' ? 'DP' : 'Fractional';
      capBadge.textContent = capacity;
      return;
    }
    itemsPreview.appendChild(document.createElement('div'));
    const container = document.createElement('div');
    items.forEach((it,idx)=>{
      const pill = document.createElement('span');
      pill.className = 'item-pill';
      pill.textContent = `${it.name}: w=${it.w}, v=${it.v}, r=${(it.v/it.w).toFixed(2)}`;
      container.appendChild(pill);
    });
    itemsPreview.appendChild(container);
    algBadge.textContent = algo === 'dp' ? 'DP' : 'Fractional';
    capBadge.textContent = capacity;
  }

  function updateAll(){
    capacity = Math.max(1, Math.floor(Number(capInput.value) || 0));
    capInput.value = capacity;
    capBadge.textContent = capacity;
    algo = algoSelect.value;
    algBadge.textContent = algo === 'dp' ? 'DP' : 'Fractional';
    animateEnabled = animateCheck.checked;
    showTable = showTableCheck.checked;
    renderItemsList();
    clearVisualization();
    if(algo === 'fractional'){
      fracArea.style.display = 'block';
    } else {
      fracArea.style.display = 'none';
    }
  }

  // Handlers
  addItemBtn.addEventListener('click', ()=>{
    const name = nameInput.value.trim() || `I${items.length+1}`;
    const w = Math.max(1, Math.floor(Number(weightInput.value) || 0));
    const v = Math.max(0, Number(valueInput.value) || 0);
    items.push({name,w,v});
    nameInput.value=''; weightInput.value='1'; valueInput.value='0';
    updateAll();
  });

  randomBtn.addEventListener('click', ()=>{
    items = [];
    const n = Math.floor(Math.random()*6)+3;
    for(let i=0;i<n;i++){
      const w = Math.floor(Math.random()*9)+1;
      const v = Math.floor(Math.random()*(w*8))+5;
      items.push({name: String.fromCharCode(65+i), w, v});
    }
    updateAll();
  });

  clearBtn.addEventListener('click', ()=>{
    items = [];
    updateAll();
  });

  capInput.addEventListener('change', updateAll);
  algoSelect.addEventListener('change', updateAll);
  animateCheck.addEventListener('change', updateAll);
  showTableCheck.addEventListener('change', updateAll);

  speedInput.addEventListener('input', ()=>{
    speedLabel.textContent = `delay: ${speedInput.value} ms per cell`;
  });

  resetBtn.addEventListener('click', ()=>{
    if(currentAnimation){ clearTimeout(currentAnimation); currentAnimation = null; }
    animating = false;
    clearVisualization();
  });

  stepBtn.addEventListener('click', async ()=>{
    if(algo === 'dp'){
      if(!dpTable || dpTable.length===0){
        prepareDP();
      }
      // Step one cell
      await dpStep();
    } else {
      runFractional(true);
    }
  });

  runBtn.addEventListener('click', async ()=>{
    if(algo === 'dp'){
      runDP();
    } else {
      runFractional();
    }
  });

  // Visualization helpers
  function clearVisualization(){
    tableWrap.innerHTML = '';
    fractionBar.innerHTML = '';
    fractionInfo.innerHTML = '';
    resultEl.style.display='none';
    totalValueEl.textContent = '0';
    totalWeightEl.textContent = '0';
    chosenItemsEl.innerHTML = '';
    dpTable = [];
    if(currentAnimation){ clearTimeout(currentAnimation); currentAnimation = null; }
    animating = false;
  }

  // DP Implementation with animation/step support
  // We'll maintain state machine for stepping: i index and w index
  let dpState = {i:0, w:0, dp:[], parent:[]}; // parent for reconstruction when taking
  function prepareDP(){
    clearVisualization();
    const n = items.length;
    const C = capacity;
    // initialize dp matrix (n+1) x (C+1) filled with 0
    const dp = Array.from({length:n+1}, ()=> new Array(C+1).fill(0));
    // parent: boolean take or not (for reconstruction) at each cell when filled
    const take = Array.from({length:n+1}, ()=> new Array(C+1).fill(false));
    dpState = {i:1, w:0, dp, take};
    // Render table skeleton
    renderDPTable(dp);
  }

  function renderDPTable(dp){
    tableWrap.innerHTML = '';
    if(!showTable){
      tableWrap.innerHTML = '<div class="muted">DP table hidden (toggle "Show DP table")</div>';
      return;
    }
    const n = dp.length-1;
    const C = dp[0].length-1;
    const table = document.createElement('table');
    table.className = 'dp';
    const thead = document.createElement('thead');
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th')); // corner
    for(let w=0;w<=C;w++){
      const th = document.createElement('th'); th.textContent = w; headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for(let i=0;i<=n;i++){
      const tr = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = i===0 ? 'i=0' : `${items[i-1].name} (w${items[i-1].w})`;
      tr.appendChild(th);
      for(let w=0;w<=C;w++){
        const td = document.createElement('td');
        td.id = `cell_${i}_${w}`;
        td.textContent = dp[i][w];
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    tableWrap.appendChild(table);
  }

  async function dpStep(){
    // Performs a single cell step (or completes reconstruction once done)
    if(!dpState.dp){ prepareDP(); return; }
    const {dp, take} = dpState;
    const n = dp.length-1;
    const C = dp[0].length-1;
    let {i,w} = dpState;

    // if finished with all items: reconstruct and show result
    if(i > n){
      reconstructDP(dp, take);
      return;
    }

    // find next w target cell (we iterate w from 0..C then increment i)
    if(w > C){
      dpState.i++; dpState.w = 0; animating = false;
      await dpStep(); // continue with next row
      return;
    }

    // highlight current cell
    highlightCell(i,w,'current');

    // compute value
    await sleep( animateEnabled ? Number(speedInput.value) : 0 );

    const it = items[i-1];
    const without = dp[i-1][w];
    let withVal = -Infinity;
    if(it.w <= w) withVal = dp[i-1][w - it.w] + it.v;

    const targetCell = document.getElementById(`cell_${i}_${w}`);
    // update dp and optionally highlight if taking improves
    if(withVal > without){
      dp[i][w] = withVal;
      take[i][w] = true;
      if(targetCell){
        targetCell.textContent = withVal;
        addClass(targetCell,'cell-update');
      }
    } else {
      dp[i][w] = without;
      take[i][w] = false;
      if(targetCell){
        targetCell.textContent = without;
      }
    }

    // small delay to show update
    await sleep( animateEnabled ? Math.max(50, Number(speedInput.value)/2) : 0 );

    // remove highlight classes for this cell
    unhighlightCell(i,w);

    // advance
    dpState.w++;
    // if we've reached end of row, move to next row in next step
    if(dpState.w > C) dpState.i++;

    // if running full animation, schedule next step
    if(animating){
      currentAnimation = setTimeout(()=> dpStep(), animateEnabled ? Number(speedInput.value) : 0);
    }
  }

  function highlightCell(i,w,cls='current'){
    const el = document.getElementById(`cell_${i}_${w}`);
    if(el){
      if(cls==='current') addClass(el,'cell-current');
      else if(cls==='update') addClass(el,'cell-update');
    }
  }
  function unhighlightCell(i,w){
    const el = document.getElementById(`cell_${i}_${w}`);
    if(el){
      removeClass(el,'cell-current');
      removeClass(el,'cell-update');
    }
  }

  function addClass(el,cls){
    if(!el) return;
    if(!el.classList.contains(cls)) el.classList.add(cls);
  }
  function removeClass(el,cls){
    if(!el) return;
    el.classList.remove(cls);
  }

  async function runDP(){
    if(items.length===0){
      alert('Add some items first.');
      return;
    }
    prepareDP();
    animating = true;
    // start stepping automatically
    if(currentAnimation){ clearTimeout(currentAnimation); currentAnimation = null; }
    currentAnimation = setTimeout(()=> dpStep(), 10);
  }

  function reconstructDP(dp, take){
    // reconstruct selected items from take[][] table
    const n = dp.length-1; const C = dp[0].length-1;
    let w = C;
    const chosen = [];
    for(let i=n;i>=1;i--){
      if(take[i][w]){
        chosen.push(items[i-1]);
        // mark chosen cells visually in first column (we'll mark the entire row cells where used)
        w -= items[i-1].w;
      }
    }
    showResultDP(dp[n][C], chosen);
    // highlight chosen cells in table for better visualization: we'll mark top row index for items
    chosen.forEach(it => {
      // mark item name cell in table header row
      // find item index
      const idx = items.indexOf(it);
      if(idx>=0){
        const row = idx+1;
        for(let col=0;col<=C;col++){
          const cell = document.getElementById(`cell_${row}_${col}`);
          if(cell) addClass(cell,'chosen');
        }
      }
    });
    animating = false;
    if(currentAnimation){ clearTimeout(currentAnimation); currentAnimation = null; }
  }

  function showResultDP(value, chosen){
    resultEl.style.display = 'block';
    totalValueEl.textContent = String(value);
    const totalW = chosen.reduce((s,it)=>s+it.w,0);
    totalWeightEl.textContent = String(totalW);
    chosenItemsEl.innerHTML = '';
    if(chosen.length===0){
      chosenItemsEl.innerHTML = '<div class="muted">No items chosen (capacity too small or values zero).</div>';
      return;
    }
    chosen.slice().reverse().forEach(it=>{
      const span = document.createElement('span');
      span.className = 'item-pill';
      span.textContent = `${it.name} (w:${it.w}, v:${it.v})`;
      chosenItemsEl.appendChild(span);
    });
  }

  // Fractional knapsack (greedy) visualization
  function runFractional(stepOnly=false){
    if(items.length===0){ alert('Add some items first.'); return; }
    clearVisualization();
    // sort items by value/weight ratio
    const list = items.map(it => ({...it, ratio: it.v/it.w})).sort((a,b)=>b.ratio - a.ratio);
    // visualize filling
    let remaining = capacity;
    let totalV = 0;
    let totalW = 0;
    fractionBar.innerHTML = '';
    fractionInfo.innerHTML = '';
    const segments = [];
    for(const it of list){
      if(remaining<=0) break;
      if(it.w <= remaining){
        // take whole
        segments.push({it, frac:1});
        remaining -= it.w;
        totalV += it.v;
        totalW += it.w;
      } else {
        // take fraction
        const frac = remaining / it.w;
        segments.push({it, frac});
        totalV += it.v * frac;
        totalW += it.w * frac;
        remaining = 0;
      }
    }
    // build visual bar
    const usedCapacity = capacity - remaining;
    segments.forEach(s=>{
      const seg = document.createElement('div');
      const width = (s.it.w * s.frac) / capacity * 100;
      seg.style.width = width+'%';
      seg.className = 'fraction-seg';
      seg.style.background = `linear-gradient(90deg, rgba(59,130,246,0.8), rgba(96,165,250,0.8))`;
      seg.textContent = `${s.it.name}${s.frac<1 ? ('×'+s.frac.toFixed(2)) : ''}`;
      fractionBar.appendChild(seg);
    });
    if(usedCapacity < capacity){
      const rem = document.createElement('div');
      rem.style.width = ((capacity-usedCapacity)/capacity*100)+'%';
      rem.className = 'fraction-seg';
      rem.style.background = 'rgba(255,255,255,0.03)';
      rem.style.color = 'var(--muted)';
      rem.textContent = 'free';
      fractionBar.appendChild(rem);
    }
    // show info
    fractionInfo.innerHTML = `<div>Total value ≈ <strong>${totalV.toFixed(3)}</strong></div>
                              <div>Total weight = <strong>${totalW.toFixed(3)}</strong> / ${capacity}</div>`;
    // detailed list
    const listHtml = segments.map(s => {
      const frac = s.frac;
      const val = s.it.v * frac;
      return `<div style="margin-top:6px"><strong>${s.it.name}</strong>: taken ${ (frac*100).toFixed(1)}% — weight ${ (s.it.w*frac).toFixed(3) }, value ${ val.toFixed(3) } (ratio ${s.it.ratio.toFixed(3)})</div>`;
    }).join('');
    fractionInfo.innerHTML += listHtml;
    // show final result area
    resultEl.style.display = 'block';
    totalValueEl.textContent = totalV.toFixed(3);
    totalWeightEl.textContent = totalW.toFixed(3);
    chosenItemsEl.innerHTML = segments.map(s => `<span class="item-pill">${s.it.name}${s.frac<1 ? ('×'+s.frac.toFixed(2)) : ''}</span>`).join(' ');
  }

  // helper sleep
  function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

  // small helper to run step when user pressed Step repeatedly
  async function dpStepOnce(){
    if(!dpState.dp) prepareDP();
    await dpStep();
  }

  // Expose dpStep used by stepBtn
  async function dpStepWrapper(){
    if(!dpState.dp) prepareDP();
    animating = false;
    await dpStep();
  }

  // attach step button to dpStepWrapper or fractional step
  stepBtn.addEventListener('click', () => {
    if(algo === 'dp'){
      dpStepWrapper();
    } else {
      runFractional(true);
    }
  });

  // initialization
  updateAll();

  // ensure initial DP table renders if user runs
  window.addEventListener('resize', ()=> { /* could reflow if needed */ });

  // Provide keyboard shortcuts for convenience
  window.addEventListener('keydown', (e) => {
    if(e.key === 'r' && e.ctrlKey){ e.preventDefault(); runBtn.click(); }
  });

  // Small UX: cap capacity for table visualization, warn
  capInput.addEventListener('input', ()=>{
    const v = Number(capInput.value) || 0;
    if(v > 60){
      capInput.style.borderColor = 'rgba(239,68,68,0.6)';
    } else {
      capInput.style.borderColor = '';
    }
  });

})();
</script>
</body>
</html>