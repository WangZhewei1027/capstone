<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bubble Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --good:#10b981;
      --warn:#f59e0b;
      --bad:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071022 0%, #0b1220 60%); color:#e6eef8; }
    .app { max-width:1100px; margin:18px auto; padding:18px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }
    header { display:flex; gap:16px; align-items:center; margin-bottom:12px; }
    h1 { font-size:20px; margin:0; letter-spacing:0.2px; }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    .control { background:var(--glass); padding:8px 10px; border-radius:10px; display:flex; gap:8px; align-items:center; }
    label { font-size:13px; color:var(--muted); display:flex; gap:8px; align-items:center; }
    input[type=range] { accent-color: var(--accent); }
    button { background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:8px 10px; border-radius:8px; cursor:pointer; }
    button.primary { background:linear-gradient(90deg,var(--accent),#6ee7b7); color:#032; font-weight:600; border:none; }
    button:disabled { opacity:0.45; cursor:not-allowed; }
    .layout { display:grid; grid-template-columns: 1fr 360px; gap:14px; align-items:start; }
    .visual { background:rgba(255,255,255,0.02); border-radius:10px; padding:14px; min-height:320px; position:relative; overflow:hidden; }
    .bars { position:relative; height:320px; width:100%; display:block; background:linear-gradient(180deg, transparent, rgba(255,255,255,0.01)); border-radius:8px; }
    .bar { position:absolute; bottom:8px; background:linear-gradient(180deg, var(--accent), rgba(59,130,246,0.6)); border-radius:6px 6px 4px 4px; transition: left 250ms ease, height 250ms ease, background-color 150ms; display:flex; align-items:flex-end; justify-content:center; color:rgba(255,255,255,0.9); font-size:12px; box-shadow: 0 4px 18px rgba(3,7,18,0.6); }
    .bar.small { font-size:11px; }
    .bar .val { padding:6px 4px 4px 4px; background:rgba(0,0,0,0.18); border-radius:4px; transform:translateY(6px); }
    .bar.compare { background:linear-gradient(180deg,var(--warn), rgba(245,158,11,0.5)); }
    .bar.swap { background:linear-gradient(180deg,var(--bad), rgba(239,68,68,0.45)); }
    .bar.sorted { background:linear-gradient(180deg,var(--good), rgba(16,185,129,0.45)); }
    .sidebar { background:rgba(255,255,255,0.02); border-radius:10px; padding:12px; min-height:320px; display:flex; flex-direction:column; gap:12px; }
    .stats { display:flex; gap:8px; flex-wrap:wrap; }
    .stat { background:rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; min-width:110px; text-align:center; }
    .stat .num { font-size:18px; font-weight:700; }
    pre { background:#061025; padding:10px; border-radius:8px; overflow:auto; font-size:13px; color:#9fb4d8; margin:0; line-height:1.5; }
    .code-line { padding:4px 6px; border-radius:6px; }
    .code-line.active { background:rgba(99,102,241,0.12); color:#e7f0ff; }
    .footer { display:flex; justify-content:space-between; gap:12px; align-items:center; margin-top:10px; color:var(--muted); font-size:13px; }
    .small { font-size:13px; color:var(--muted); }
    .row { display:flex; gap:8px; align-items:center; }
    .mode-toggle { display:flex; gap:6px; }
    .mode-toggle button { padding:6px 8px; font-size:13px; }
    .label-compact { font-size:13px; color:var(--muted); }
    @media (max-width:900px){
      .layout { grid-template-columns: 1fr; }
      .sidebar { order:2; }
      .visual { order:1; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Bubble Sort Visualizer">
    <header>
      <div>
        <h1>Bubble Sort Visualizer</h1>
        <div class="small">Interactive demonstration of the Bubble Sort algorithm (step-by-step & animated)</div>
      </div>
    </header>

    <div class="controls">
      <div class="control">
        <label><span class="label-compact">Array size</span>
          <input id="sizeRange" type="range" min="5" max="80" value="30" />
        </label>
      </div>

      <div class="control">
        <label><span class="label-compact">Speed</span>
          <input id="speedRange" type="range" min="10" max="1000" step="10" value="200" />
        </label>
      </div>

      <div class="control">
        <label><span class="label-compact">Order</span>
          <select id="orderSelect" style="background:transparent; color:inherit; border:none; outline:none;">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </label>
      </div>

      <div class="control">
        <button id="randomBtn">Randomize</button>
        <button id="sortedBtn">Nearly Sorted</button>
      </div>

      <div class="control">
        <button id="startBtn" class="primary">Run</button>
        <button id="stepBtn">Step</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="layout">
      <div class="visual" aria-hidden="false">
        <div class="bars" id="barsContainer" aria-label="Array bars"></div>
      </div>

      <aside class="sidebar" aria-label="Details and controls">
        <div class="stats">
          <div class="stat">
            <div class="small">Comparisons</div>
            <div id="compCount" class="num">0</div>
          </div>
          <div class="stat">
            <div class="small">Swaps</div>
            <div id="swapCount" class="num">0</div>
          </div>
          <div class="stat">
            <div class="small">Steps</div>
            <div id="stepCount" class="num">0</div>
          </div>
        </div>

        <div>
          <div class="small" style="margin-bottom:6px;">Pseudocode</div>
          <pre id="codeBlock" style="height:210px;">
<div class="code-line" data-line="1">1. for end = n - 1 down to 1:</div>
<div class="code-line" data-line="2">2. &nbsp;&nbsp; for i = 0 to end - 1:</div>
<div class="code-line" data-line="3">3. &nbsp;&nbsp;&nbsp;&nbsp; if arr[i] > arr[i+1]:</div>
<div class="code-line" data-line="4">4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swap(arr[i], arr[i+1])</div>
<div class="code-line" data-line="5">5. &nbsp;&nbsp; mark arr[end] as sorted</div>
<div class="code-line" data-line="6">6. end</div>
</pre>
        </div>

        <div style="margin-top:auto;">
          <div class="small" style="margin-bottom:6px;">Notes</div>
          <div class="small" style="color:var(--muted)">Bubble sort repeatedly compares adjacent items and swaps them if they are in the wrong order. This visualization highlights comparisons (orange), swaps (red), and elements that are already sorted (green).</div>
        </div>
      </aside>
    </div>

    <div class="footer">
      <div class="small">Array elements are visualized as vertical bars (height ∝ value). Use Step to advance one compare/swap; Run to animate continuously.</div>
      <div class="small">Made with plain JavaScript — educational demo</div>
    </div>
  </div>

  <script>
    // Bubble Sort Visualizer - Single-file implementation
    (function(){
      // DOM refs
      const barsContainer = document.getElementById('barsContainer');
      const sizeRange = document.getElementById('sizeRange');
      const speedRange = document.getElementById('speedRange');
      const orderSelect = document.getElementById('orderSelect');
      const randomBtn = document.getElementById('randomBtn');
      const sortedBtn = document.getElementById('sortedBtn');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const compCountEl = document.getElementById('compCount');
      const swapCountEl = document.getElementById('swapCount');
      const stepCountEl = document.getElementById('stepCount');
      const codeLines = Array.from(document.querySelectorAll('.code-line'));

      let array = [];
      let elements = []; // objects {value, id}
      let domMap = new Map(); // id -> element DOM
      let running = false;
      let paused = false;
      let generator = null;
      let animationPromise = null;
      let compCount = 0, swapCount = 0, stepCount = 0;
      let initialElements = null;

      // utility id generator
      let nextId = 1;
      function genId(){ return nextId++; }

      // Create initial random array
      function createRandomArray(n){
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(Math.floor(Math.random()*100)+1);
        }
        return arr;
      }
      function createNearlySorted(n){
        const arr = [];
        for(let i=0;i<n;i++) arr.push(Math.floor((i+1)/n*100)+1);
        // perform a few random swaps
        for(let k=0;k<Math.max(1, Math.floor(n*0.06)); k++){
          const i = Math.floor(Math.random()*n);
          const j = Math.floor(Math.random()*n);
          const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;
        }
        return arr;
      }

      // Build DOM bars for given values
      function buildBarsFromValues(values){
        nextId = 1;
        elements = values.map(v => ({ value: v, id: genId() }));
        initialElements = elements.map(e => ({...e}));
        renderBars();
        resetStats();
      }

      function resetStats(){
        compCount = 0;
        swapCount = 0;
        stepCount = 0;
        updateStats();
      }

      function updateStats(){
        compCountEl.textContent = compCount;
        swapCountEl.textContent = swapCount;
        stepCountEl.textContent = stepCount;
      }

      function renderBars(){
        // Clear
        barsContainer.innerHTML = '';
        domMap.clear();
        const n = elements.length;
        if(n === 0) return;
        // compute layout
        const containerWidth = barsContainer.clientWidth || barsContainer.offsetWidth || 800;
        const gap = Math.max(2, Math.floor(containerWidth / (n*40)));
        const barWidth = Math.max(6, Math.floor((containerWidth - (n+1)*gap) / n));
        const maxVal = Math.max(...elements.map(e=>e.value));
        // create bar DOMs
        elements.forEach((el, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          if (elements.length > 40) bar.classList.add('small');
          bar.style.width = barWidth + 'px';
          const heightPercent = Math.max(6, Math.round(el.value / maxVal * 100));
          const maxHeight = barsContainer.clientHeight - 12;
          bar.style.height = Math.max(16, Math.round(maxHeight * heightPercent / 100)) + 'px';
          bar.style.left = (gap + idx*(barWidth+gap)) + 'px';
          bar.setAttribute('data-id', String(el.id));
          bar.setAttribute('role','img');
          bar.setAttribute('aria-label', 'Value '+el.value);
          const valEl = document.createElement('div');
          valEl.className = 'val';
          valEl.textContent = el.value;
          bar.appendChild(valEl);
          barsContainer.appendChild(bar);
          domMap.set(el.id, bar);
        });
      }

      // helper to set bar state (compare, swap, sorted)
      function resetBarStyles(){
        domMap.forEach(bar => {
          bar.classList.remove('compare','swap','sorted');
        });
      }
      function setCompare(i,j){
        resetBarStyles();
        const bi = domMap.get(elements[i].id);
        const bj = domMap.get(elements[j].id);
        if(bi) bi.classList.add('compare');
        if(bj) bj.classList.add('compare');
      }
      function setSwap(i,j){
        resetBarStyles();
        const bi = domMap.get(elements[i].id);
        const bj = domMap.get(elements[j].id);
        if(bi) bi.classList.add('swap');
        if(bj) bj.classList.add('swap');
      }
      function markSorted(index){
        const b = domMap.get(elements[index].id);
        if(b){
          b.classList.remove('compare','swap');
          b.classList.add('sorted');
        }
      }

      // swap DOM elements visually by updating left positions and swapping elements array
      function animateSwap(i,j, duration){
        return new Promise(resolve => {
          const e1 = elements[i], e2 = elements[j];
          const b1 = domMap.get(e1.id), b2 = domMap.get(e2.id);
          if(!b1 || !b2){
            // fallback: swap values & rerender
            const tmp = elements[i]; elements[i] = elements[j]; elements[j] = tmp;
            renderBars();
            setTimeout(resolve, duration);
            return;
          }
          // swap positions in elements array
          elements[i] = e2; elements[j] = e1;
          // compute new lefts
          const left1 = b1.style.left, left2 = b2.style.left;
          // temporarily disable pointer events for smoother visuals
          b1.style.transition = `left ${duration}ms ease, height ${Math.max(120,duration)}ms ease`;
          b2.style.transition = `left ${duration}ms ease, height ${Math.max(120,duration)}ms ease`;
          // swap DOM left values
          b1.style.left = left2;
          b2.style.left = left1;
          // after animation, update domMap mapping (ids unchanged)
          setTimeout(()=>{
            // ensure bars are still mapped correctly (ids remain)
            resolve();
          }, duration + 20);
        });
      }

      // Pseudocode highlighting
      function highlightLine(lineNum){
        codeLines.forEach(cl => {
          if(Number(cl.getAttribute('data-line')) === lineNum) cl.classList.add('active');
          else cl.classList.remove('active');
        });
      }

      // Bubble sort generator: yields actions one-by-one
      // Actions: {type:'compare', i, j}, {type:'swap', i, j}, {type:'markSorted', index}, {type:'done'}
      function* bubbleSortGenerator(values, ascending=true){
        const n = values.length;
        // We'll operate on indices and yield control frequently so UI can animate each step.
        // We'll simulate in terms of indices referencing the current elements array.
        for(let end = n-1; end >= 1; end--){
          for(let i=0;i<=end-1;i++){
            yield { type:'line', line:2 };
            yield { type:'compare', i:i, j:i+1 };
            const a = values[i], b = values[i+1];
            const shouldSwap = ascending ? (a > b) : (a < b);
            if(shouldSwap){
              yield { type:'line', line:4 };
              yield { type:'swap', i:i, j:i+1 };
              // perform swap in our local array so subsequent decisions reflect the change
              const tmp = values[i]; values[i] = values[i+1]; values[i+1] = tmp;
            }
          }
          yield { type:'markSorted', index: end };
        }
        yield { type:'markSorted', index: 0 };
        yield { type:'done' };
      }

      // Controller for stepping through generator actions
      async function handleAction(action, delay){
        stepCount++;
        updateStats();
        if(action.type === 'line'){
          highlightLine(action.line);
          return;
        }
        if(action.type === 'compare'){
          compCount++;
          updateStats();
          highlightLine(3);
          setCompare(action.i, action.j);
          // small visual delay to observe comparison
          if(delay>0) await sleep(delay);
        } else if(action.type === 'swap'){
          swapCount++;
          updateStats();
          setSwap(action.i, action.j);
          // animate swap visually using animateSwap(duration)
          await animateSwap(action.i, action.j, Math.max(60, delay));
          // small pause after swap
          await sleep(Math.max(20, Math.floor(delay*0.15)));
        } else if(action.type === 'markSorted'){
          markSorted(action.index);
          // tiny delay
          if(delay>0) await sleep(Math.min(120, delay));
        } else if(action.type === 'done'){
          resetBarStyles();
          highlightLine(6);
        }
      }

      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

      // Controller: run auto mode
      async function runAuto(){
        if(running) return;
        running = true;
        paused = false;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stepBtn.disabled = true;
        sizeRange.disabled = true;
        randomBtn.disabled = true;
        sortedBtn.disabled = true;
        orderSelect.disabled = true;
        resetBtn.disabled = true;
        // create a working copy of values for generator so it can compute swaps
        const workingValues = elements.map(e=>e.value);
        generator = bubbleSortGenerator(workingValues, orderSelect.value === 'asc');
        let next = generator.next();
        while(!next.done && running){
          if(paused){
            // wait until resumed or stopped
            await new Promise(resolve => {
              const check = setInterval(()=>{
                if(!paused || !running) { clearInterval(check); resolve(); }
              }, 50);
            });
          }
          if(!running) break;
          const action = next.value;
          await handleAction(action, Number(speedRange.value));
          next = generator.next();
        }
        running = false;
        pauseBtn.disabled = true;
        startBtn.disabled = false;
        stepBtn.disabled = false;
        sizeRange.disabled = false;
        randomBtn.disabled = false;
        sortedBtn.disabled = false;
        orderSelect.disabled = false;
        resetBtn.disabled = false;
        if(generator){ // finalize
          // ensure all marked sorted
          elements.forEach((_, idx) => markSorted(idx));
          highlightLine(6);
        }
      }

      // Step-single action
      async function stepOnce(){
        if(running) return; // avoid stepping while auto-run
        if(!generator){
          // create generator from current elements values
          const workingValues = elements.map(e=>e.value);
          generator = bubbleSortGenerator(workingValues, orderSelect.value === 'asc');
        }
        const next = generator.next();
        if(next.done) {
          generator = null;
          highlightLine(6);
          elements.forEach((_, idx) => markSorted(idx));
          return;
        }
        await handleAction(next.value, Number(speedRange.value));
      }

      // Pause/resume auto-run
      function togglePause(){
        if(!running) return;
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      }

      // Reset to initial unsorted array
      function resetToInitial(){
        running = false;
        paused = false;
        generator = null;
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        pauseBtn.textContent = 'Pause';
        stepBtn.disabled = false;
        sizeRange.disabled = false;
        randomBtn.disabled = false;
        sortedBtn.disabled = false;
        orderSelect.disabled = false;
        resetBtn.disabled = false;
        if(initialElements) {
          elements = initialElements.map(e=>({...e}));
          renderBars();
        }
        resetStats();
        highlightLine(1);
      }

      // UI event wiring
      sizeRange.addEventListener('input', ()=>{
        const n = Number(sizeRange.value);
        buildBarsFromValues(createRandomArray(n));
      });
      randomBtn.addEventListener('click', ()=>{
        const n = Number(sizeRange.value);
        buildBarsFromValues(createRandomArray(n));
      });
      sortedBtn.addEventListener('click', ()=>{
        const n = Number(sizeRange.value);
        buildBarsFromValues(createNearlySorted(n));
      });
      startBtn.addEventListener('click', async ()=>{
        if(running) return;
        runAuto();
      });
      pauseBtn.addEventListener('click', ()=>{
        togglePause();
      });
      stepBtn.addEventListener('click', async ()=>{
        await stepOnce();
      });
      resetBtn.addEventListener('click', ()=>{
        resetToInitial();
      });

      // initialize
      (function init(){
        const n = Number(sizeRange.value);
        buildBarsFromValues(createRandomArray(n));
        highlightLine(1);
      })();

      // Resize handler: recompute bar positions and sizes on window resize
      let resizeTimer = null;
      window.addEventListener('resize', ()=> {
        if(resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          renderBars();
        }, 120);
      });

      // Accessibility: keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === ' '){ e.preventDefault(); if(!running) startBtn.click(); else pauseBtn.click(); }
        if(e.key === 'ArrowRight'){ e.preventDefault(); stepBtn.click(); }
      });
    })();
  </script>
</body>
</html>