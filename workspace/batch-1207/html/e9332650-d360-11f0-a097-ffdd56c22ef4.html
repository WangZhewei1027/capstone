<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Interactive Graph (Directed / Undirected)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#f7f9fc;--panel:#fff;--accent:#0b74de;--muted:#6b7280}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,#eef5ff 0%,#fbfdff 100%);display:flex;flex-direction:column}
  header{padding:12px 18px;border-bottom:1px solid rgba(15,23,42,0.06);display:flex;gap:12px;align-items:center;background:var(--panel)}
  h1{font-size:16px;margin:0;color:#07203a}
  .toolbar{display:flex;gap:8px;align-items:center;margin-left:8px;flex-wrap:wrap}
  button,select,input[type="text"]{background:white;border:1px solid #e2e8f0;padding:6px 8px;border-radius:6px;font-size:13px}
  button.primary{background:var(--accent);color:white;border-color:transparent}
  .main{display:flex;flex:1;gap:12px;padding:12px;align-items:stretch}
  .canvas-wrap{flex:1;background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 2px 8px rgba(16,24,40,0.04);display:flex;flex-direction:column;min-height:420px}
  #svgcanvas{flex:1;background:linear-gradient(180deg,#fff 0%,#fbfdff 100%);border-radius:6px;border:1px solid #e6eef8}
  .side{width:320px;min-width:240px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 2px 8px rgba(16,24,40,0.04);font-size:13px}
  .status{padding:8px;border-radius:8px;background:#f1f8ff;color:#083d77;margin-top:8px}
  label{display:flex;gap:8px;align-items:center;font-weight:600}
  .controls{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  textarea{width:100%;height:160px;font-family:monospace;padding:8px;border-radius:8px;border:1px solid #e6eef8}
  .list{max-height:220px;overflow:auto;margin-top:8px;padding:6px;border-radius:8px;border:1px dashed #e6eef8;background:linear-gradient(180deg,#fff,#fbfdff)}
  .small{font-size:12px;color:var(--muted)}
  .node-label{font-weight:700;fill:#05263b}
  .muted{color:#667085}
  .hint{font-size:12px;color:#94a3b8;margin-top:8px}
</style>
</head>
<body>
<header>
  <h1>Interactive Graph — Directed / Undirected</h1>
  <div class="toolbar">
    <label class="small">Mode:
      <select id="modeSelect" title="Switch between directed and undirected">
        <option value="directed">Directed</option>
        <option value="undirected">Undirected</option>
      </select>
    </label>
    <div class="controls">
      <button id="addNodeBtn">Add Node</button>
      <button id="addEdgeBtn">Add Edge</button>
      <button id="delBtn">Delete</button>
      <button id="clearBtn">Clear</button>
      <button id="randomBtn">Random</button>
      <button id="exportBtn">Export</button>
      <button id="importBtn">Import</button>
    </div>
  </div>
</header>

<div class="main">
  <div class="canvas-wrap">
    <svg id="svgcanvas" viewBox="0 0 1200 720"></svg>
    <div class="hint small">Usage: Click "Add Node" then click canvas to place nodes. Click "Add Edge", then click source and target nodes. Drag nodes to reposition. Toggle mode to change drawing (directed shows arrows). Delete mode: click node/edge to remove.</div>
  </div>

  <aside class="side">
    <div><strong>Selected:</strong> <span id="selectedInfo">None</span></div>
    <div class="status" id="modeStatus">Mode: Directed</div>

    <div style="margin-top:10px">
      <label class="small">Edge weight on creation:
        <input type="text" id="weightInput" placeholder="default 1" style="width:80px"/>
      </label>
    </div>

    <div style="margin-top:10px">
      <button id="toggleLabelsBtn">Toggle Labels</button>
      <button id="toggleWeightsBtn">Toggle Weights</button>
      <button id="shortestBtn">Shortest Path</button>
    </div>

    <div style="margin-top:10px">
      <label class="small">Path: source
        <input id="sourceInput" style="width:60px" placeholder="A"/>
      </label>
      <label class="small">target
        <input id="targetInput" style="width:60px" placeholder="B"/>
      </label>
    </div>

    <div style="margin-top:12px">
      <strong>Adjacency List</strong>
      <div class="list" id="adjList"></div>
    </div>

    <div style="margin-top:12px">
      <strong>Adjacency Matrix</strong>
      <div class="list" id="adjMatrix"></div>
    </div>

    <div style="margin-top:12px">
      <strong>Import / Export</strong>
      <textarea id="jsonArea" placeholder='Paste exported graph JSON here'></textarea>
    </div>
  </aside>
</div>

<script>
/*
Interactive graph viewer/editor supporting directed and undirected graphs.
Single-file demo without external libs.
Author: AI-generated
*/

const svg = document.getElementById('svgcanvas');
const modeSelect = document.getElementById('modeSelect');
const addNodeBtn = document.getElementById('addNodeBtn');
const addEdgeBtn = document.getElementById('addEdgeBtn');
const delBtn = document.getElementById('delBtn');
const clearBtn = document.getElementById('clearBtn');
const randomBtn = document.getElementById('randomBtn');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const jsonArea = document.getElementById('jsonArea');
const selectedInfo = document.getElementById('selectedInfo');
const modeStatus = document.getElementById('modeStatus');
const weightInput = document.getElementById('weightInput');
const toggleLabelsBtn = document.getElementById('toggleLabelsBtn');
const toggleWeightsBtn = document.getElementById('toggleWeightsBtn');
const shortestBtn = document.getElementById('shortestBtn');
const sourceInput = document.getElementById('sourceInput');
const targetInput = document.getElementById('targetInput');
const adjListDiv = document.getElementById('adjList');
const adjMatrixDiv = document.getElementById('adjMatrix');

let state = {
  nodes: [], // {id,label,x,y}
  edges: [], // {id,from,to,weight}
  directed: true,
  showLabels: true,
  showWeights: true,
};

let idCounters = {node: 0, edge: 0};

let mode = 'idle'; // 'idle', 'addNode', 'addEdge', 'delete'
let edgePending = null; // nodeId when adding edge
let selected = null; // {type:'node'|'edge', id}
let dragging = null; // {id, offsetX, offsetY}
let highlightedPath = [];

const NS = "http://www.w3.org/2000/svg";

// create defs for arrow marker
function ensureDefs() {
  let d = svg.querySelector('defs');
  if (!d) {
    d = document.createElementNS(NS,'defs');
    svg.appendChild(d);
  }
  if (!document.getElementById('arrow')) {
    const marker = document.createElementNS(NS,'marker');
    marker.setAttribute('id','arrow');
    marker.setAttribute('markerWidth','10');
    marker.setAttribute('markerHeight','10');
    marker.setAttribute('refX','10');
    marker.setAttribute('refY','5');
    marker.setAttribute('orient','auto');
    marker.setAttribute('markerUnits','strokeWidth');
    const path = document.createElementNS(NS,'path');
    path.setAttribute('d','M0,0 L10,5 L0,10 z');
    path.setAttribute('fill','#0b74de');
    marker.appendChild(path);
    d.appendChild(marker);
  }
}
ensureDefs();

function setMode(newMode) {
  mode = newMode;
  addNodeBtn.classList.toggle('primary', mode==='addNode');
  addEdgeBtn.classList.toggle('primary', mode==='addEdge');
  delBtn.classList.toggle('primary', mode==='delete');
  if (mode !== 'addEdge') {
    edgePending = null;
  }
  updateStatus();
}

function updateStatus() {
  modeStatus.textContent = `Mode: ${state.directed ? 'Directed' : 'Undirected'} — UI: ${mode}`;
  if (mode === 'addEdge' && edgePending) {
    selectedInfo.textContent = `Edge source: ${edgePending}`;
  } else if (selected) {
    selectedInfo.textContent = `${selected.type} ${selected.id}`;
  } else {
    selectedInfo.textContent = 'None';
  }
}

modeSelect.addEventListener('change', (e) => {
  state.directed = e.target.value === 'directed';
  // Keep edges as-is; drawing/adjacency will interpret based on directed flag
  render();
});

addNodeBtn.addEventListener('click', () => setMode(mode==='addNode' ? 'idle' : 'addNode'));
addEdgeBtn.addEventListener('click', () => setMode(mode==='addEdge' ? 'idle' : 'addEdge'));
delBtn.addEventListener('click', () => setMode(mode==='delete' ? 'idle' : 'delete'));
clearBtn.addEventListener('click', () => {
  if (!confirm('Clear entire graph?')) return;
  state.nodes = []; state.edges = []; idCounters.node=0; idCounters.edge=0;
  selected = null; edgePending=null;
  render();
});
randomBtn.addEventListener('click', () => {
  const n = Math.floor(Math.random()*6)+4;
  makeRandomGraph(n, Math.min(1, Math.random()*0.6+0.2));
});
exportBtn.addEventListener('click', () => {
  const obj = {nodes: state.nodes, edges: state.edges, directed: state.directed};
  jsonArea.value = JSON.stringify(obj, null, 2);
});
importBtn.addEventListener('click', () => {
  try {
    const obj = JSON.parse(jsonArea.value);
    if (!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error('Invalid format');
    state.nodes = obj.nodes.map(n=>({id:n.id,label:n.label,x:n.x,y:n.y}));
    state.edges = obj.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight||1}));
    state.directed = !!obj.directed;
    // reset counters
    idCounters.node = (state.nodes.reduce((m,n)=>Math.max(m, parseInt(n.id.replace(/[^\d]/g,'' )||0)),0))+1;
    idCounters.edge = (state.edges.reduce((m,e)=>Math.max(m, parseInt(e.id.replace(/[^\d]/g,'' )||0)),0))+1;
    modeSelect.value = state.directed ? 'directed':'undirected';
    render();
    alert('Imported successfully');
  } catch (err) {
    alert('Import failed: ' + err.message);
  }
});

toggleLabelsBtn.addEventListener('click', () => {
  state.showLabels = !state.showLabels;
  render();
});
toggleWeightsBtn.addEventListener('click', () => {
  state.showWeights = !state.showWeights;
  render();
});

shortestBtn.addEventListener('click', () => {
  const src = sourceInput.value.trim();
  const dst = targetInput.value.trim();
  if (!src || !dst) { alert('Enter source and target node labels (case-sensitive).'); return; }
  const nodeByLabel = {};
  state.nodes.forEach(n=> nodeByLabel[n.label]=n);
  const s = nodeByLabel[src], t = nodeByLabel[dst];
  if (!s || !t) { alert('Source or target node not found'); return; }
  const path = shortestPath(s.id, t.id);
  highlightedPath = path ? pathToEdgeIds(path) : [];
  render();
  if (!path) alert('No path found');
});

// canvas interactions
svg.addEventListener('mousedown', (e) => {
  const pt = screenToSvg(e);
  if (mode === 'addNode') {
    const label = nextNodeLabel();
    const id = 'n'+(++idCounters.node);
    state.nodes.push({id,label,x:pt.x,y:pt.y});
    render();
    setMode('idle');
  }
});

function nextNodeLabel() {
  // label nodes as A,B,C,...,AA,...
  const n = state.nodes.length;
  let s = '';
  let i = n;
  do {
    s = String.fromCharCode(65 + (i % 26)) + s;
    i = Math.floor(i/26)-1;
  } while (i>=0);
  return s || 'A';
}

function screenToSvg(e) {
  const rect = svg.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);
  const y = (e.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);
  return {x,y};
}

// Rendering
function render() {
  while (svg.lastChild) svg.removeChild(svg.lastChild);
  ensureDefs();
  // background rect to capture clicks
  const bg = document.createElementNS(NS,'rect');
  bg.setAttribute('x',0); bg.setAttribute('y',0);
  bg.setAttribute('width', svg.viewBox.baseVal.width);
  bg.setAttribute('height', svg.viewBox.baseVal.height);
  bg.setAttribute('fill','transparent');
  svg.appendChild(bg);

  // edges first
  state.edges.forEach(e => {
    const from = findNode(e.from), to = findNode(e.to);
    if (!from || !to) return;
    const opposite = findEdge(to.id, from.id);
    const isOpposite = !!opposite && state.directed;
    if (from.id === to.id) {
      // self-loop: circular arc
      const group = document.createElementNS(NS,'g');
      const cx = from.x, cy = from.y;
      const r = 26;
      const path = document.createElementNS(NS,'path');
      const d = `M ${cx} ${cy-r} C ${cx-48} ${cy-80} ${cx+48} ${cy-80} ${cx} ${cy-r}`;
      path.setAttribute('d',d);
      path.setAttribute('fill','none');
      path.setAttribute('stroke','#88a8ff');
      path.setAttribute('stroke-width',4);
      if (state.directed) path.setAttribute('marker-end','url(#arrow)');
      path.style.cursor='pointer';
      path.addEventListener('click', (ev)=>{ ev.stopPropagation(); onEdgeClick(e.id); });
      group.appendChild(path);
      if (state.showWeights) {
        const w = document.createElementNS(NS,'text');
        w.setAttribute('x',cx);
        w.setAttribute('y',cy-r-10);
        w.setAttribute('text-anchor','middle');
        w.setAttribute('font-size','12');
        w.setAttribute('fill','#023047');
        w.textContent = e.weight || '';
        group.appendChild(w);
      }
      svg.appendChild(group);
    } else {
      // check if opposite exists and offset if both present
      const x1 = from.x, y1 = from.y, x2 = to.x, y2 = to.y;
      let dx = x2 - x1, dy = y2 - y1;
      const len = Math.hypot(dx,dy) || 1;
      dx/=len; dy/=len;
      let offset = 0;
      if (isOpposite) offset = 18;
      const ox = -dy * offset, oy = dx * offset;
      // compute endpoints offset by node radius
      const r = 22;
      const sx = x1 + dx*r + ox, sy = y1 + dy*r + oy;
      const tx = x2 - dx*r + ox, ty = y2 - dy*r + oy;

      const path = document.createElementNS(NS, isOpposite ? 'path' : 'line');
      if (isOpposite) {
        const mx = (sx+tx)/2, my = (sy+ty)/2;
        // simple quadratic curve for offset
        const cx_ctrl = mx + ox*0.6, cy_ctrl = my + oy*0.6;
        const d = `M ${sx} ${sy} Q ${cx_ctrl} ${cy_ctrl} ${tx} ${ty}`;
        path.setAttribute('d',d);
      } else {
        path.setAttribute('x1',sx); path.setAttribute('y1',sy);
        path.setAttribute('x2',tx); path.setAttribute('y2',ty);
      }
      path.setAttribute('stroke','#0b74de');
      path.setAttribute('stroke-width', state.showWeights ? 4 : 3);
      path.setAttribute('fill','none');
      path.style.cursor='pointer';
      if (state.directed) path.setAttribute('marker-end','url(#arrow)');
      if (highlightedPath.includes(e.id)) {
        path.setAttribute('stroke','#ff7043');
        path.setAttribute('stroke-width',6);
      }
      path.addEventListener('click', (ev)=>{ ev.stopPropagation(); onEdgeClick(e.id); });
      svg.appendChild(path);

      // weight label
      if (state.showWeights) {
        const txmid = (sx+tx)/2 + ox*0.2, tymid = (sy+ty)/2 + oy*0.2;
        const tw = document.createElementNS(NS,'text');
        tw.setAttribute('x', txmid);
        tw.setAttribute('y', tymid);
        tw.setAttribute('text-anchor','middle');
        tw.setAttribute('font-size','12');
        tw.setAttribute('fill','#023047');
        tw.textContent = e.weight || '';
        svg.appendChild(tw);
      }
    }
  });

  // nodes on top
  state.nodes.forEach(n => {
    const g = document.createElementNS(NS,'g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.style.cursor = 'pointer';

    // circle
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('r',22);
    c.setAttribute('fill','#fff');
    c.setAttribute('stroke','#0b74de');
    c.setAttribute('stroke-width',2);
    g.appendChild(c);

    // label
    if (state.showLabels) {
      const t = document.createElementNS(NS,'text');
      t.setAttribute('x',0); t.setAttribute('y',6);
      t.setAttribute('text-anchor','middle');
      t.setAttribute('font-size','14');
      t.setAttribute('fill','#05263b');
      t.textContent = n.label;
      g.appendChild(t);
    }

    g.addEventListener('mousedown', (ev) => {
      ev.stopPropagation();
      const pt = screenToSvg(ev);
      if (mode === 'addEdge') {
        if (!edgePending) {
          edgePending = n.id;
        } else {
          const fromId = edgePending, toId = n.id;
          createEdge(fromId,toId);
          edgePending = null;
          setMode('idle');
        }
        render();
        return;
      }
      if (mode === 'delete') {
        // delete node and connected edges
        state.edges = state.edges.filter(e=> e.from !== n.id && e.to !== n.id);
        state.nodes = state.nodes.filter(nn=> nn.id !== n.id);
        render();
        return;
      }
      // start dragging
      dragging = {id:n.id, offsetX: pt.x - n.x, offsetY: pt.y - n.y};
      selected = {type:'node', id:n.id};
      updateStatus();
    });

    g.addEventListener('click', (ev)=>{ ev.stopPropagation(); /* handled above */ });

    svg.appendChild(g);
  });

  // update side panels
  updateAdjacencies();
  updateStatus();
}

function onEdgeClick(edgeId) {
  if (mode === 'delete') {
    state.edges = state.edges.filter(e=> e.id !== edgeId);
    render(); return;
  }
  selected = {type:'edge', id:edgeId};
  updateStatus();
}

function findNode(id) { return state.nodes.find(n=>n.id===id); }
function findEdge(from,to) { return state.edges.find(e=> e.from===from && e.to===to); }

function createEdge(fromId,toId) {
  if (!state.directed) {
    // in undirected mode, avoid duplicate undirected edge
    const exists = state.edges.find(e=>{
      return (e.from===fromId && e.to===toId) || (e.from===toId && e.to===fromId);
    });
    if (exists) { alert('Edge already exists (undirected)'); return; }
  } else {
    const exists = state.edges.find(e=> e.from===fromId && e.to===toId);
    if (exists) { alert('Edge already exists (directed)'); return; }
  }
  const w = parseFloat(weightInput.value);
  const id = 'e'+(++idCounters.edge);
  state.edges.push({id,from:fromId,to:toId,weight: isNaN(w) ? 1 : w});
  render();
}

function makeRandomGraph(n, density=0.4) {
  state.nodes = []; state.edges = []; idCounters.node=0; idCounters.edge=0;
  const margin = 60;
  for (let i=0;i<n;i++){
    const id = 'n'+(++idCounters.node);
    const label = nextNodeLabel();
    const x = margin + Math.random()*(svg.viewBox.baseVal.width-2*margin);
    const y = margin + Math.random()*(svg.viewBox.baseVal.height-2*margin);
    state.nodes.push({id,label,x,y});
  }
  for (let i=0;i<n;i++){
    for (let j=0;j<n;j++){
      if (i===j) continue;
      if (Math.random() < density) {
        if (!state.directed && j<i) continue; // avoid duplicates in undirected
        const id = 'e'+(++idCounters.edge);
        state.edges.push({id,from:state.nodes[i].id,to:state.nodes[j].id,weight:Math.floor(Math.random()*9)+1});
      }
    }
  }
  render();
}

// dragging handling on mousemove/up
window.addEventListener('mousemove',(e)=>{
  if (!dragging) return;
  const pt = screenToSvg(e);
  const node = findNode(dragging.id);
  node.x = pt.x - dragging.offsetX;
  node.y = pt.y - dragging.offsetY;
  render(); // re-render while dragging
});
window.addEventListener('mouseup',(e)=>{
  dragging = null;
});

// keyboard shortcuts for convenience
window.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') { setMode('idle'); edgePending=null; render();}
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selected && selected.type==='node') {
      state.nodes = state.nodes.filter(n=> n.id !== selected.id);
      state.edges = state.edges.filter(ed=> ed.from !== selected.id && ed.to !== selected.id);
      selected = null; render();
    } else if (selected && selected.type==='edge') {
      state.edges = state.edges.filter(ed=> ed.id !== selected.id);
      selected = null; render();
    }
  }
});

// adjacency list/matrix display
function updateAdjacencies() {
  // adjacency list
  const nodes = state.nodes;
  const edges = state.edges;
  const directed = state.directed;
  const map = {};
  nodes.forEach(n=> map[n.id]=[]);
  edges.forEach(e=>{
    map[e.from].push({to:e.to,weight:e.weight,edgeId:e.id});
    if (!directed) {
      map[e.to].push({to:e.from,weight:e.weight,edgeId:e.id});
    }
  });
  adjListDiv.innerHTML = '';
  nodes.forEach(n=>{
    const div = document.createElement('div');
    div.innerHTML = `<strong>${n.label}</strong> (${n.id}): ` + (map[n.id].length ? map[n.id].map(x=>`${labelOf(x.to)}${state.showWeights ? `(${x.weight})` : ''}`).join(', ') : '<span class="muted">—</span>');
    adjListDiv.appendChild(div);
  });

  // adjacency matrix
  const header = [''].concat(nodes.map(n=>n.label));
  const tbl = document.createElement('table');
  tbl.setAttribute('cellspacing','6');
  tbl.style.borderSpacing='6px';
  const makeCell = (txt, bold=false) => {
    const td = document.createElement('td');
    td.textContent = txt;
    if (bold) td.style.fontWeight='700';
    td.style.fontSize='13px';
    td.style.textAlign='center';
    td.style.minWidth='28px';
    return td;
  };
  // header row
  const trh = document.createElement('tr');
  header.forEach((h,idx)=> trh.appendChild(makeCell(h, idx===0?false:true)));
  tbl.appendChild(trh);
  nodes.forEach((rnode)=>{
    const tr = document.createElement('tr');
    tr.appendChild(makeCell(rnode.label,true));
    nodes.forEach(cnode=>{
      let val = 0;
      const e = state.edges.find(ed => ed.from===rnode.id && ed.to===cnode.id);
      if (e) val = state.showWeights ? e.weight : 1;
      if (!state.directed && rnode.id!==cnode.id) {
        const e2 = state.edges.find(ed => (ed.from===rnode.id && ed.to===cnode.id) || (ed.from===cnode.id && ed.to===rnode.id));
        if (e2) val = state.showWeights ? e2.weight : 1;
      }
      tr.appendChild(makeCell(val || '0'));
    });
    tbl.appendChild(tr);
  });
  adjMatrixDiv.innerHTML=''; adjMatrixDiv.appendChild(tbl);
}

function labelOf(nodeId) {
  const n = findNode(nodeId);
  return n ? n.label : nodeId;
}

// helpers for shortest path (Dijkstra)
function shortestPath(fromId, toId) {
  // build adjacency with weights
  const nodes = state.nodes.map(n=>n.id);
  const adj = {};
  nodes.forEach(id=> adj[id]=[]);
  state.edges.forEach(e=>{
    adj[e.from].push({to:e.to, w: Number(e.weight||1)});
    if (!state.directed) adj[e.to].push({to:e.from, w: Number(e.weight||1)});
  });
  // Dijkstra
  const dist = {}, prev = {};
  const Q = new Set(nodes);
  nodes.forEach(v=> { dist[v]=Infinity; prev[v]=null; });
  dist[fromId]=0;
  while (Q.size) {
    let u = null; let best=Infinity;
    Q.forEach(v=> { if (dist[v] < best) { best = dist[v]; u=v; }});
    if (u === null || dist[u]===Infinity) break;
    Q.delete(u);
    if (u === toId) break;
    for (const {to,w} of adj[u]) {
      const alt = dist[u] + w;
      if (alt < dist[to]) { dist[to]=alt; prev[to]=u; }
    }
  }
  if (dist[toId] === Infinity) return null;
  const path = [];
  let cur = toId;
  while (cur) { path.unshift(cur); cur = prev[cur]; }
  return path;
}
function pathToEdgeIds(path) {
  const ids = [];
  for (let i=0;i<path.length-1;i++){
    const u=path[i], v=path[i+1];
    // find edge that connects u->v abiding directed/undirected
    let e = state.edges.find(ed=> ed.from===u && ed.to===v);
    if (!e && !state.directed) e = state.edges.find(ed=> (ed.from===u && ed.to===v) || (ed.from===v && ed.to===u));
    if (e) ids.push(e.id);
  }
  return ids;
}

// small utilities
svg.addEventListener('click', (e)=> {
  if (mode === 'addEdge' && edgePending) { edgePending=null; render(); return; }
  // clicking background clears selection
  selected = null; updateStatus();
});

// helpful: clicking on node label in adj list sets selection
adjListDiv.addEventListener('click', (e)=> {
  const txt = e.target.textContent || '';
  const m = txt.match(/^([A-Z]+)/);
  // ignore
});

// initialize with two nodes and an edge
(function initDemo(){
  state.directed = true;
  modeSelect.value = 'directed';
  const n1='n1', n2='n2', n3='n3';
  state.nodes = [
    {id:n1,label:'A',x:200,y:200},
    {id:n2,label:'B',x:420,y:260},
    {id:n3,label:'C',x:320,y:420}
  ];
  idCounters.node = 3;
  state.edges = [{id:'e1',from:n1,to:n2,weight:2},{id:'e2',from:n2,to:n3,weight:3}];
  idCounters.edge = 2;
  render();
})();

</script>
</body>
</html>