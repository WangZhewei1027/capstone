<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Graph (Directed / Undirected) Demo</title>
<style>
  :root{
    --panel-width: 320px;
    --bg: #0f1724;
    --panel: #0b1220;
    --accent: #06b6d4;
    --muted: #94a3b8;
    --card: #0b1220;
    color-scheme: dark;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:linear-gradient(180deg,#071026 0%, #07122a 100%);
    color:#e6eef6;
  }
  .app{
    display:flex;
    height:100vh;
    gap:12px;
    padding:12px;
    box-sizing:border-box;
  }
  .panel{
    width:var(--panel-width);
    background:linear-gradient(180deg,#07121a 0%, #071725 100%);
    border-radius:10px;
    padding:12px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    overflow:auto;
  }
  .canvasWrap{
    flex:1;
    min-width:0;
    border-radius:10px;
    overflow:hidden;
    position:relative;
  }
  header{
    display:flex;
    gap:8px;
    align-items:center;
    margin-bottom:8px;
  }
  h1{font-size:16px;margin:0;}
  .muted{color:var(--muted);font-size:13px;}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0;}
  button, select, input[type="checkbox"]{
    background:transparent;
    border:1px solid rgba(200,220,240,0.06);
    color:var(--muted);
    padding:8px;
    border-radius:6px;
    cursor:pointer;
    font-size:13px;
  }
  button.primary{
    background:linear-gradient(90deg,var(--accent),#60a5fa);
    color:#04202a;
    border:none;
    font-weight:600;
  }
  label{font-size:13px;color:var(--muted);display:flex;gap:6px;align-items:center;}
  .small{font-size:12px;color:var(--muted);}
  svg{width:100%;height:100%;display:block;background:
    radial-gradient(ellipse at 10% 10%, rgba(8,20,30,0.6), transparent 10%),
    linear-gradient(180deg, rgba(9,16,26,0.5), rgba(6,8,15,0.8));
    }
  .infoBox{
    margin-top:8px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:8px;
    padding:8px;
    font-size:13px;
    color:var(--muted);
  }
  .list{
    max-height:200px; overflow:auto; margin-top:6px;
    border-radius:6px;padding:6px;background:rgba(255,255,255,0.01);
  }
  .nodeBadge{
    display:inline-block;padding:4px 6px;margin:3px;border-radius:6px;background:rgba(255,255,255,0.03);
    color:var(--muted);font-size:12px;
  }
  table{width:100%;font-size:12px;border-collapse:collapse;}
  td,th{padding:4px 6px;border-bottom:1px dashed rgba(255,255,255,0.02);text-align:left;color:var(--muted)}
  .footer{
    margin-top:12px;font-size:12px;color:var(--muted);
  }
  .controlsRow{display:flex;gap:8px;flex-wrap:wrap;}
  .hint{font-size:12px;color:var(--muted);margin-top:6px;}
  .smallBtn{padding:6px;border-radius:6px;font-size:12px;}
  .selectedInfo{background:rgba(6,11,20,0.6);padding:6px;border-radius:6px;margin-top:6px;}
  .metric{display:flex;justify-content:space-between;gap:8px}
</style>
</head>
<body>
<div class="app">
  <div class="panel">
    <header>
      <h1>Graph Playground</h1>
      <div style="flex:1"></div>
      <div class="muted">Interactive | JS SVG</div>
    </header>

    <div class="row controlsRow">
      <label title="Toggle whether edges are directed">
        <input id="directedToggle" type="checkbox" checked /> Directed
      </label>
      <label title="Treat edges as weighted">
        <input id="weightedToggle" type="checkbox" /> Weighted
      </label>
      <button id="forceBtn" class="smallBtn">Start Force</button>
      <button id="clearBtn" class="smallBtn">Clear</button>
    </div>

    <div class="row">
      <button id="addNodeBtn" class="smallBtn">Add Node (Click canvas)</button>
      <button id="edgeModeBtn" class="smallBtn">Edge Mode: Drag</button>
    </div>

    <div class="hint">
      Instructions:
      <ul style="margin:6px 0 0 18px;padding:0;color:var(--muted)">
        <li>Click blank canvas to add nodes (or press "Add Node" then click).</li>
        <li>Drag from a node to another to create an edge (or click nodes when "Edge Mode: Click").</li>
        <li>Click a node to select. Shift+click adds to selection. Press Delete to remove selection.</li>
        <li>Drag nodes to move them. Toggle Directed/Weighted with controls.</li>
      </ul>
    </div>

    <div class="infoBox">
      <div class="small">Selected: <span id="selInfo">none</span></div>
      <div style="margin-top:6px" class="metric">
        <div>Nodes: <strong id="nodeCount">0</strong></div>
        <div>Edges: <strong id="edgeCount">0</strong></div>
      </div>
      <div class="muted" style="margin-top:6px;font-size:12px">
        Click an edge label to edit its weight.
      </div>
    </div>

    <div style="margin-top:8px;" class="row">
      <button id="bfsBtn" class="smallBtn">Run BFS</button>
      <button id="dfsBtn" class="smallBtn">Run DFS</button>
      <button id="shortestBtn" class="smallBtn">Shortest Path</button>
      <select id="algSelect" style="padding:6px;border-radius:6px">
        <option value="auto">Auto (BFS if unweighted)</option>
        <option value="dijkstra">Dijkstra</option>
        <option value="bfs">BFS</option>
      </select>
    </div>

    <div style="margin-top:8px;">
      <div style="display:flex;gap:6px">
        <select id="startSelect"></select>
        <select id="endSelect"></select>
        <button id="pathClearBtn" class="smallBtn">Clear Highlights</button>
      </div>
    </div>

    <div style="margin-top:10px;">
      <strong>Adjacency List</strong>
      <div class="list" id="adjList"></div>
      <strong style="margin-top:8px;display:block">Adjacency Matrix</strong>
      <div style="overflow:auto;max-height:160px;background:rgba(255,255,255,0.01);border-radius:6px;padding:6px;margin-top:6px">
        <table id="adjMatrix"></table>
      </div>
    </div>

    <div class="footer">
      <div style="display:flex;gap:6px;margin-top:8px">
        <button id="exportBtn" class="smallBtn">Export JSON</button>
        <button id="importBtn" class="smallBtn">Import JSON</button>
        <input id="fileInput" type="file" accept="application/json" style="display:none"/>
      </div>
    </div>
  </div>

  <div class="canvasWrap" id="canvasWrap">
    <svg id="svgCanvas" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,5 L0,10 z" fill="#76E4F7"></path>
        </marker>
        <marker id="arrowDark" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,5 L0,10 z" fill="#bdeaf6"></path>
        </marker>
      </defs>
      <g id="edgesLayer"></g>
      <g id="nodesLayer"></g>
      <g id="labelsLayer"></g>
    </svg>
  </div>
</div>

<script>
/*
Interactive Graph (Directed/Undirected) Demo
- Click blank area to add nodes.
- Drag from node to node to add edges.
- Toggle Directed / Weighted.
- Drag nodes to reposition.
- BFS / DFS / Shortest path with animations.
- Adjacency list and matrix display, degrees computed.
- Export/Import JSON of graph.
*/

// Basic state
let nodes = []; // {id,x,y,label}
let edges = []; // {id,source,target,weight}
let svg = document.getElementById('svgCanvas');
let nodesLayer = document.getElementById('nodesLayer');
let edgesLayer = document.getElementById('edgesLayer');
let labelsLayer = document.getElementById('labelsLayer');
let directedToggle = document.getElementById('directedToggle');
let weightedToggle = document.getElementById('weightedToggle');
let nodeCountEl = document.getElementById('nodeCount');
let edgeCountEl = document.getElementById('edgeCount');
let selInfo = document.getElementById('selInfo');
let adjListEl = document.getElementById('adjList');
let adjMatrixEl = document.getElementById('adjMatrix');
let startSelect = document.getElementById('startSelect');
let endSelect = document.getElementById('endSelect');
let algSelect = document.getElementById('algSelect');

let idCounter = 1;
let edgeCounter = 1;
let selectedNodes = new Set();
let selectedEdges = new Set();

let mode = { addNode: false, edgeMode: 'drag' }; // edgeMode: 'drag' or 'click'
let draggingNode = null;
let dragOffset = {x:0,y:0};
let creatingEdge = null; // {fromId, previewLineElement}

let forceRunning = false;
let forceAnimation = null;
let width=1200,height=800;

// utilities
function ptToSVG(evt){
  let pt = svg.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  let ctm = svg.getScreenCTM().inverse();
  let p = pt.matrixTransform(ctm);
  return {x:p.x,y:p.y};
}

function findNodeAt(p, radius=18){
  for(let i=nodes.length-1;i>=0;i--){
    let n = nodes[i];
    let dx = p.x - n.x, dy = p.y - n.y;
    if (Math.hypot(dx,dy) <= radius) return n;
  }
  return null;
}

function updateCounts(){
  nodeCountEl.textContent = nodes.length;
  edgeCountEl.textContent = edges.length;
  selInfo.textContent = selectedNodes.size + ' node(s), ' + selectedEdges.size + ' edge(s)';
  rebuildSelects();
}

function rebuildSelects(){
  [startSelect,endSelect].forEach(sel=>{
    let cur = sel.value;
    sel.innerHTML = '';
    let nothing = document.createElement('option'); nothing.value=''; nothing.textContent='(none)';
    sel.appendChild(nothing);
    nodes.forEach(n=>{
      let o = document.createElement('option'); o.value = n.id; o.textContent = n.label;
      sel.appendChild(o);
    });
    sel.value = cur || '';
  });
  renderAdj();
  renderMatrix();
  renderNodesEdges();
}

// Render adjacency list
function renderAdj(){
  let directed = directedToggle.checked;
  let map = new Map();
  nodes.forEach(n=> map.set(n.id, []));
  edges.forEach(e=>{
    map.get(e.source).push({to:e.target, weight:e.weight});
    if (!directed){
      map.get(e.target).push({to:e.source, weight:e.weight});
    }
  });
  adjListEl.innerHTML = '';
  map.forEach((arr,k)=>{
    let n = nodes.find(x=>x.id==k);
    let div = document.createElement('div');
    div.style.marginBottom='6px';
    let title = document.createElement('div'); title.style.fontWeight='600'; title.style.color='#dff7fb';
    title.textContent = n ? n.label : k;
    div.appendChild(title);
    let txt = arr.map(a=>{
      let nm = nodes.find(x=>x.id==a.to);
      return (nm?nm.label:a.to) + (weightedToggle.checked ? (' ('+a.weight+')') : '');
    }).join(', ');
    let list = document.createElement('div'); list.style.color='var(--muted)'; list.textContent = txt || '(no neighbors)';
    div.appendChild(list);
    adjListEl.appendChild(div);
  });
}

// Render adjacency matrix
function renderMatrix(){
  let directed = directedToggle.checked;
  let ids = nodes.map(n=>n.id);
  adjMatrixEl.innerHTML = '';
  let tr = document.createElement('tr');
  tr.appendChild(document.createElement('th'));
  nodes.forEach(n=>{ let th=document.createElement('th'); th.textContent = n.label; tr.appendChild(th);});
  adjMatrixEl.appendChild(tr);
  let map = {};
  edges.forEach(e=>{
    map[e.source+'-'+e.target] = e.weight;
    if(!directed) map[e.target+'-'+e.source] = e.weight;
  });
  nodes.forEach(r=>{
    let tr = document.createElement('tr');
    let th = document.createElement('th'); th.textContent = r.label; tr.appendChild(th);
    nodes.forEach(c=>{
      let td = document.createElement('td');
      let val = map[r.id+'-'+c.id];
      td.textContent = val===undefined? '0': (weightedToggle.checked?val:'1');
      tr.appendChild(td);
    });
    adjMatrixEl.appendChild(tr);
  });
}

// Creation helpers
function addNodeAt(x,y,label){
  let id = 'n'+(idCounter++);
  let n = {id, x, y, label: label || id};
  nodes.push(n);
  updateCounts();
  renderNodesEdges();
}

function addEdge(s,t,w){
  if (s==t) return;
  // prevent duplicate identical edge for undirected: check both directions
  let directed = directedToggle.checked;
  if (!directed){
    if (edges.some(e => (e.source==s && e.target==t) || (e.source==t && e.target==s))) return;
  } else {
    if (edges.some(e => (e.source==s && e.target==t))) return;
  }
  let id = 'e'+(edgeCounter++);
  edges.push({id,source:s,target:t,weight: (weightedToggle.checked? (w===undefined?1:w) : 1)});
  updateCounts();
  renderNodesEdges();
}

// Render everything: edges then nodes and labels
function renderNodesEdges(){
  // clear layers
  while(edgesLayer.firstChild) edgesLayer.removeChild(edgesLayer.firstChild);
  while(nodesLayer.firstChild) nodesLayer.removeChild(nodesLayer.firstChild);
  while(labelsLayer.firstChild) labelsLayer.removeChild(labelsLayer.firstChild);

  // edges
  let directed = directedToggle.checked;
  edges.forEach(e=>{
    let s = nodes.find(n=>n.id==e.source);
    let t = nodes.find(n=>n.id==e.target);
    if (!s || !t) return;
    // compute line endpoints offset from circle radius
    let dx = t.x - s.x, dy = t.y - s.y;
    let dist = Math.hypot(dx,dy);
    let r = 18;
    let sx = s.x + (dx/dist)*r;
    let sy = s.y + (dy/dist)*r;
    let tx = t.x - (dx/dist)*r;
    let ty = t.y - (dy/dist)*r;

    let line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', sx); line.setAttribute('y1', sy);
    line.setAttribute('x2', tx); line.setAttribute('y2', ty);
    line.setAttribute('stroke', 'rgba(150,200,220,0.6)');
    line.setAttribute('stroke-width', selectedEdges.has(e.id) ? 4 : 2);
    line.setAttribute('stroke-linecap','round');
    if (directed) line.setAttribute('marker-end','url(#arrow)');
    line.style.cursor='pointer';
    line.dataset.id=e.id;
    line.addEventListener('click', (ev)=>{ ev.stopPropagation(); toggleEdgeSelect(e.id); });
    edgesLayer.appendChild(line);

    // edge label
    let midx = (sx+tx)/2, midy = (sy+ty)/2;
    let textBg = document.createElementNS('http://www.w3.org/2000/svg','rect');
    let txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', midx); txt.setAttribute('y', midy - 6);
    txt.setAttribute('fill', '#bdeaf6');
    txt.setAttribute('font-size','12');
    txt.setAttribute('text-anchor','middle');
    txt.style.cursor='pointer';
    txt.dataset.id = e.id;
    txt.textContent = (weightedToggle.checked? e.weight : '');
    txt.addEventListener('click', (ev)=>{ ev.stopPropagation(); editEdgeWeight(e.id); });
    labelsLayer.appendChild(txt);
  });

  // nodes
  nodes.forEach(n=>{
    let g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.style.cursor='grab';
    g.dataset.id = n.id;

    let circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 18);
    circle.setAttribute('fill', selectedNodes.has(n.id)? '#06303b' : '#04202a');
    circle.setAttribute('stroke', selectedNodes.has(n.id)? '#7eeaf2' : '#2b6b71');
    circle.setAttribute('stroke-width', selectedNodes.has(n.id)? 3 : 2);
    circle.addEventListener('mousedown', (ev)=>{ ev.stopPropagation(); nodeMouseDown(ev,n); });
    circle.addEventListener('click', (ev)=>{ ev.stopPropagation(); nodeClick(ev,n); });
    g.appendChild(circle);

    let text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('y',5);
    text.setAttribute('text-anchor','middle');
    text.setAttribute('font-size','12');
    text.setAttribute('fill','#cdeff7');
    text.textContent = n.label;
    text.style.pointerEvents='none';
    g.appendChild(text);

    nodesLayer.appendChild(g);
  });

  updateCounts();
}

// selection helpers
function clearSelection(){
  selectedNodes.clear(); selectedEdges.clear();
  updateCounts();
  renderNodesEdges();
}

function toggleNodeSelect(id, additive=false){
  if (!additive) selectedNodes.clear();
  if (selectedNodes.has(id)) selectedNodes.delete(id);
  else selectedNodes.add(id);
  selectedEdges.clear();
  updateCounts();
  renderNodesEdges();
}

function toggleEdgeSelect(id){
  selectedEdges.clear();
  selectedNodes.clear();
  if (selectedEdges.has(id)) selectedEdges.delete(id);
  else selectedEdges.add(id);
  updateCounts();
  renderNodesEdges();
}

// Node interactions
function nodeMouseDown(evt,node){
  draggingNode = node;
  let p = ptToSVG(evt);
  dragOffset.x = node.x - p.x;
  dragOffset.y = node.y - p.y;
  document.addEventListener('mousemove', nodeMouseMove);
  document.addEventListener('mouseup', nodeMouseUp);
  // if edge creation via drag:
  if (mode.edgeMode === 'drag'){
    // start preview line
    creatingEdge = {fromId: node.id, line: document.createElementNS('http://www.w3.org/2000/svg','line')};
    let l = creatingEdge.line;
    l.setAttribute('x1', node.x);
    l.setAttribute('y1', node.y);
    l.setAttribute('x2', node.x);
    l.setAttribute('y2', node.y);
    l.setAttribute('stroke', 'rgba(150,200,220,0.4)');
    l.setAttribute('stroke-width',2);
    l.setAttribute('stroke-dasharray','6 4');
    edgesLayer.appendChild(l);
  }
}

function nodeMouseMove(ev){
  let p = ptToSVG(ev);
  if (draggingNode){
    // drag node
    draggingNode.x = p.x + dragOffset.x;
    draggingNode.y = p.y + dragOffset.y;
    renderNodesEdges();
  }
  if (creatingEdge){
    creatingEdge.line.setAttribute('x2', p.x);
    creatingEdge.line.setAttribute('y2', p.y);
  }
}

function nodeMouseUp(ev){
  document.removeEventListener('mousemove', nodeMouseMove);
  document.removeEventListener('mouseup', nodeMouseUp);
  let p = ptToSVG(ev);
  // drop edge if creating
  if (creatingEdge){
    let target = findNodeAt(p);
    if (target && target.id !== creatingEdge.fromId){
      let weight = 1;
      if (weightedToggle.checked){
        weight = parseFloat(prompt('Edge weight (number):', '1')) || 1;
      }
      addEdge(creatingEdge.fromId, target.id, weight);
    }
    if (creatingEdge.line && creatingEdge.line.parentNode) creatingEdge.line.parentNode.removeChild(creatingEdge.line);
    creatingEdge = null;
  }
  draggingNode = null;
}

// clicking nodes
function nodeClick(ev,node){
  if (ev.shiftKey){
    toggleNodeSelect(node.id, true);
  } else if (mode.edgeMode === 'click' && selectedNodes.size === 1 && !selectedNodes.has(node.id)){
    // create edge between previously selected node and this one
    let from = Array.from(selectedNodes)[0];
    let weight = 1;
    if (weightedToggle.checked){
      weight = parseFloat(prompt('Edge weight (number):', '1')) || 1;
    }
    addEdge(from, node.id, weight);
  } else {
    toggleNodeSelect(node.id, ev.shiftKey);
  }
}

// canvas click to add node or clear selection
svg.addEventListener('click', (ev)=>{
  let p = ptToSVG(ev);
  let hit = findNodeAt(p);
  if (mode.addNode || !hit){
    if (mode.addNode || !hit){
      // add node
      if (mode.addNode || (!hit && !ev.shiftKey)){
        addNodeAt(p.x,p.y,'v'+(idCounter));
        mode.addNode=false;
        document.getElementById('addNodeBtn').textContent = 'Add Node (Click canvas)';
      }
    }
    if (!hit) clearSelection();
  } else {
    // clicked on a node (handled on the node)
  }
});

// delete key to remove selected items
document.addEventListener('keydown', (ev)=>{
  if (ev.key === 'Delete' || ev.key === 'Backspace'){
    // remove selected nodes and incident edges
    if (selectedNodes.size>0){
      nodes = nodes.filter(n=>!selectedNodes.has(n.id));
      edges = edges.filter(e=> !selectedNodes.has(e.source) && !selectedNodes.has(e.target));
      selectedNodes.clear();
    } else if (selectedEdges.size>0){
      edges = edges.filter(e=> !selectedEdges.has(e.id));
      selectedEdges.clear();
    }
    renderNodesEdges();
  }
});

// UI bindings
document.getElementById('addNodeBtn').addEventListener('click', ()=>{
  mode.addNode = !mode.addNode;
  document.getElementById('addNodeBtn').textContent = mode.addNode? 'Click canvas to place' : 'Add Node (Click canvas)';
});
document.getElementById('edgeModeBtn').addEventListener('click', ()=>{
  mode.edgeMode = (mode.edgeMode === 'drag') ? 'click' : 'drag';
  document.getElementById('edgeModeBtn').textContent = 'Edge Mode: ' + (mode.edgeMode==='drag' ? 'Drag' : 'Click');
});
directedToggle.addEventListener('change', ()=>{ renderNodesEdges(); });
weightedToggle.addEventListener('change', ()=>{ renderNodesEdges(); renderAdj(); renderMatrix(); });

// simple editing of edge weights
function editEdgeWeight(eid){
  let e = edges.find(x=>x.id===eid); if(!e) return;
  let w = prompt('Set edge weight (number):', e.weight);
  if (w === null) return;
  let num = parseFloat(w);
  if (!isNaN(num)) e.weight = num;
  renderNodesEdges(); renderAdj(); renderMatrix();
}

// BFS / DFS / Shortest path algorithms
function bfs(startId){
  let q = [startId];
  let visited = new Set([startId]);
  let order = [];
  let parent = {};
  while(q.length){
    let u = q.shift();
    order.push(u);
    // neighbors
    let nb = edges.filter(e=> e.source==u).map(e=>e.target);
    if (!directedToggle.checked){
      // undirected: include edges where u is target too
      edges.forEach(e=>{
        if (e.target==u && !nb.includes(e.source)) nb.push(e.source);
      });
    }
    for(let v of nb){
      if (!visited.has(v)){
        visited.add(v);
        parent[v]=u;
        q.push(v);
      }
    }
  }
  return {order,parent};
}

function dfs(startId){
  let visited = new Set();
  let order = [];
  let parent = {};
  function visit(u){
    visited.add(u); order.push(u);
    let nb = edges.filter(e=> e.source==u).map(e=>e.target);
    if (!directedToggle.checked){
      edges.forEach(e=>{ if (e.target==u && !nb.includes(e.source)) nb.push(e.source); });
    }
    for(let v of nb){
      if (!visited.has(v)){
        parent[v]=u;
        visit(v);
      }
    }
  }
  visit(startId);
  return {order,parent};
}

// Dijkstra for weighted graphs
function dijkstra(startId){
  let dist = {}; let prev = {};
  nodes.forEach(n=> dist[n.id]=Infinity);
  dist[startId]=0;
  let Q = new Set(nodes.map(n=>n.id));
  while(Q.size){
    let u = Array.from(Q).reduce((a,b)=> dist[a]<dist[b]?a:b);
    Q.delete(u);
    // neighbors
    let nb = edges.filter(e=> e.source==u).map(e=>({to:e.target,w:e.weight}));
    if (!directedToggle.checked){
      edges.forEach(e=>{ if (e.target==u) nb.push({to:e.source,w:e.weight}); });
    }
    for(let {to,w} of nb){
      if (!Q.has(to)) continue;
      let alt = dist[u] + w;
      if (alt < dist[to]){ dist[to]=alt; prev[to]=u; }
    }
  }
  return {dist,prev};
}

// animate visitation order
async function animateOrder(order){
  // highlight nodes in order briefly
  for(let id of order){
    selectedNodes.clear();
    selectedNodes.add(id);
    renderNodesEdges();
    await new Promise(res=>setTimeout(res,400));
  }
  selectedNodes.clear(); renderNodesEdges();
}

// BFS button
document.getElementById('bfsBtn').addEventListener('click', async ()=>{
  let start = startSelect.value;
  if (!start){ alert('Select a start node'); return; }
  let res = bfs(start);
  await animateOrder(res.order);
});

// DFS button
document.getElementById('dfsBtn').addEventListener('click', async ()=>{
  let start = startSelect.value;
  if (!start){ alert('Select a start node'); return; }
  let res = dfs(start);
  await animateOrder(res.order);
});

// Shortest Path button
document.getElementById('shortestBtn').addEventListener('click', async ()=>{
  let start = startSelect.value, end = endSelect.value;
  if (!start || !end){ alert('Pick both start and end nodes'); return; }
  let method = algSelect.value;
  if (method === 'auto'){
    method = weightedToggle.checked ? 'dijkstra' : 'bfs';
  }
  let path = [];
  if (method === 'bfs'){
    let res = bfs(start);
    // reconstruct path
    if (!res.parent[end] && start!==end){ if (start!==end && !res.order.includes(end)){ alert('No path'); return; } }
    let cur = end; path.push(cur);
    while(cur !== start){
      cur = res.parent[cur];
      if (!cur) break;
      path.push(cur);
    }
    path = path.reverse();
  } else {
    // dijkstra
    let res = dijkstra(start);
    if (!isFinite(res.dist[end])){ alert('No path'); return; }
    let cur = end; path.push(cur);
    while(cur !== start){
      cur = res.prev[cur];
      if (!cur) break;
      path.push(cur);
    }
    path = path.reverse();
  }
  // highlight path (nodes + edges)
  selectedNodes.clear(); selectedEdges.clear();
  for(let i=0;i<path.length;i++){
    selectedNodes.add(path[i]);
    if (i<path.length-1){
      let e = edges.find(e=> (e.source==path[i] && e.target==path[i+1]) || (!directedToggle.checked && e.source==path[i+1] && e.target==path[i]));
      if (e) selectedEdges.add(e.id);
    }
  }
  renderNodesEdges();
});

// Clear highlights
document.getElementById('pathClearBtn').addEventListener('click', ()=>{
  selectedNodes.clear(); selectedEdges.clear();
  renderNodesEdges();
});

// Force-directed layout (simple)
document.getElementById('forceBtn').addEventListener('click', ()=>{
  forceRunning = !forceRunning;
  document.getElementById('forceBtn').textContent = forceRunning? 'Stop Force':'Start Force';
  if (forceRunning) startForce(); else stopForce();
});

function startForce(){
  let k = 80; // ideal distance
  let damp = 0.85;
  if (forceAnimation) cancelAnimationFrame(forceAnimation);
  function step(){
    let disp = {};
    nodes.forEach(n=> disp[n.id] = {x:0,y:0});
    // repulsive
    for(let i=0;i<nodes.length;i++){
      for(let j=i+1;j<nodes.length;j++){
        let a = nodes[i], b = nodes[j];
        let dx = a.x - b.x, dy = a.y - b.y;
        let dist = Math.max(1, Math.hypot(dx,dy));
        let force = (k*k)/dist;
        disp[a.id].x += (dx/dist)*force;
        disp[a.id].y += (dy/dist)*force;
        disp[b.id].x -= (dx/dist)*force;
        disp[b.id].y -= (dy/dist)*force;
      }
    }
    // attractive along edges
    edges.forEach(e=>{
      let a = nodes.find(n=>n.id==e.source);
      let b = nodes.find(n=>n.id==e.target);
      if (!a||!b) return;
      let dx = a.x - b.x, dy = a.y - b.y;
      let dist = Math.max(1, Math.hypot(dx,dy));
      let force = (dist*dist)/k;
      let fx = (dx/dist)*force, fy = (dy/dist)*force;
      disp[a.id].x -= fx; disp[a.id].y -= fy;
      disp[b.id].x += fx; disp[b.id].y += fy;
    });
    // apply
    nodes.forEach(n=>{
      n.x += Math.max(-10, Math.min(10, disp[n.id].x)) * 0.02;
      n.y += Math.max(-10, Math.min(10, disp[n.id].y)) * 0.02;
      // bounds
      n.x = Math.max(40, Math.min(width-40, n.x));
      n.y = Math.max(40, Math.min(height-40, n.y));
    });
    renderNodesEdges();
    if (forceRunning) forceAnimation = requestAnimationFrame(step);
  }
  forceAnimation = requestAnimationFrame(step);
}
function stopForce(){
  if (forceAnimation) cancelAnimationFrame(forceAnimation);
  forceAnimation = null;
  forceRunning = false;
  document.getElementById('forceBtn').textContent = 'Start Force';
}

// Export / Import
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const data = {nodes,edges,directed:directedToggle.checked,weighted:weightedToggle.checked};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'graph.json';
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', (ev)=>{
  let f = ev.target.files[0];
  if (!f) return;
  let reader = new FileReader();
  reader.onload = () => {
    try{
      let data = JSON.parse(reader.result);
      if (!data.nodes || !data.edges) throw new Error('Invalid');
      nodes = data.nodes;
      edges = data.edges;
      idCounter = nodes.reduce((a,b)=> Math.max(a, parseInt(b.id.replace(/\D/g,'')) ),0)+1;
      edgeCounter = edges.reduce((a,b)=> Math.max(a, parseInt(b.id.replace(/\D/g,'')) ),0)+1;
      directedToggle.checked = !!data.directed;
      weightedToggle.checked = !!data.weighted;
      renderNodesEdges();
      renderAdj(); renderMatrix();
    }catch(e){ alert('Failed to import: ' + e.message); }
  };
  reader.readAsText(f);
});

// when clicking the background, clear selection
document.getElementById('canvasWrap').addEventListener('click', (ev)=>{
  // handled earlier by svg click
});

// initial demo graph
function demo(){
  nodes = [
    {id:'n1',x:200,y:150,label:'A'},
    {id:'n2',x:360,y:120,label:'B'},
    {id:'n3',x:520,y:180,label:'C'},
    {id:'n4',x:360,y:300,label:'D'},
    {id:'n5',x:200,y:300,label:'E'}
  ];
  edges = [
    {id:'e1',source:'n1',target:'n2',weight:1},
    {id:'e2',source:'n2',target:'n3',weight:2},
    {id:'e3',source:'n3',target:'n4',weight:1},
    {id:'e4',source:'n4',target:'n5',weight:3},
    {id:'e5',source:'n5',target:'n1',weight:4},
    {id:'e6',source:'n2',target:'n4',weight:1}
  ];
  idCounter = 6;
  edgeCounter = 7;
  renderNodesEdges();
  renderAdj();
  renderMatrix();
}

// window resize mapping
function updateSVGSize(){
  // keep viewbox as default; users can resize
}

demo();
updateCounts();

</script>
</body>
</html>