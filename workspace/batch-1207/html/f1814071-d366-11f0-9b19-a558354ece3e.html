<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .input-section {
            margin-bottom: 20px;
        }
        input, button {
            padding: 8px 12px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        .array-container {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        .array-element {
            width: 50px;
            height: 50px;
            background-color: #e0e0e0;
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s;
        }
        .heap-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        .heap-level {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        .heap-node {
            width: 40px;
            height: 40px;
            background-color: #e0e0e0;
            margin: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 50%;
            transition: all 0.3s;
        }
        .controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .step-info {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            height: 24px;
        }
        .active {
            background-color: #ff9800 !important;
            color: white;
        }
        .swapping {
            background-color: #f44336 !important;
            color: white;
        }
        .sorted {
            background-color: #4CAF50 !important;
            color: white;
        }
        .comparison {
            background-color: #2196F3 !important;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Heap Sort Visualization</h1>
        
        <div class="input-section">
            <label for="arrayInput">Enter numbers (comma separated):</label>
            <input type="text" id="arrayInput" value="64,34,25,12,22,11,90">
            <button id="generateRandom">Generate Random Array</button>
            <button id="startSort">Start Sorting</button>
            <button id="stepForward" disabled>Step Forward</button>
            <button id="reset">Reset</button>
        </div>
        
        <div class="step-info" id="stepInfo">Ready to sort!</div>
        
        <div class="visualization">
            <h3>Array:</h3>
            <div class="array-container" id="arrayContainer"></div>
        </div>
        
        <div class="heap-container">
            <h3>Heap Representation:</h3>
            <div id="heapRepresentation"></div>
        </div>
        
        <div class="explanation">
            <h3>Heap Sort Algorithm:</h3>
            <ol>
                <li><strong>Build a max heap</strong> from the input data</li>
                <li>The largest item is stored at the root of the heap</li>
                <li>Replace it with the last item of the heap, then reduce the heap size by 1</li>
                <li>Heapify the root of the tree</li>
                <li>Repeat steps 2-4 until the heap size is 1</li>
            </ol>
            <p><strong>Time Complexity:</strong> O(n log n) in all cases</p>
            <p><strong>Space Complexity:</strong> O(1) as it's an in-place sorting algorithm</p>
        </div>
    </div>

    <script>
        // Heap Sort implementation with visualization
        class HeapSortVisualizer {
            constructor() {
                this.array = [];
                this.steps = [];
                this.currentStep = 0;
                this.isSorting = false;
                
                this.initializeEventListeners();
                this.reset();
            }
            
            initializeEventListeners() {
                document.getElementById('generateRandom').addEventListener('click', () => this.generateRandomArray());
                document.getElementById('startSort').addEventListener('click', () => this.startSorting());
                document.getElementById('stepForward').addEventListener('click', () => this.stepForward());
                document.getElementById('reset').addEventListener('click', () => this.reset());
            }
            
            generateRandomArray() {
                const size = Math.floor(Math.random() * 10) + 5; // 5 to 14 elements
                this.array = Array.from({length: size}, () => Math.floor(Math.random() * 100) + 1);
                this.resetVisualization();
            }
            
            reset() {
                const input = document.getElementById('arrayInput').value;
                this.array = input.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
                if (this.array.length === 0) {
                    this.array = [64, 34, 25, 12, 22, 11, 90];
                }
                this.resetVisualization();
            }
            
            resetVisualization() {
                this.steps = [];
                this.currentStep = 0;
                this.isSorting = false;
                document.getElementById('stepForward').disabled = false;
                document.getElementById('stepInfo').textContent = 'Ready to sort!';
                this.renderArray();
                this.renderHeap();
            }
            
            startSorting() {
                this.resetVisualization();
                this.isSorting = true;
                this.heapSort([...this.array]);
                document.getElementById('stepInfo').textContent = 'Sorting started. Use Step Forward to see each step.';
            }
            
            stepForward() {
                if (this.currentStep < this.steps.length) {
                    const step = this.steps[this.currentStep];
                    this.visualizeStep(step);
                    this.currentStep++;
                    
                    if (this.currentStep === this.steps.length) {
                        document.getElementById('stepInfo').textContent = 'Sorting completed!';
                        document.getElementById('stepForward').disabled = true;
                    }
                }
            }
            
            heapSort(array) {
                const n = array.length;
                this.steps.push({type: 'start', array: [...array], message: 'Starting Heap Sort'});
                
                // Build a max heap
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    this.heapify(array, n, i);
                }
                
                // Extract elements from heap one by one
                for (let i = n - 1; i > 0; i--) {
                    // Move current root to end
                    [array[0], array[i]] = [array[i], array[0]];
                    this.steps.push({
                        type: 'swap',
                        array: [...array],
                        indices: [0, i],
                        message: `Swapped root (${array[i]}) with last element (${array[0]})`
                    });
                    
                    // Call heapify on the reduced heap
                    this.heapify(array, i, 0);
                }
                
                this.steps.push({type: 'end', array: [...array], message: 'Sorting completed!'});
            }
            
            heapify(array, n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                
                this.steps.push({
                    type: 'compare',
                    array: [...array],
                    indices: [i, left, right],
                    message: `Comparing node ${array[i]} at index ${i} with its children`
                });
                
                // If left child is larger than root
                if (left < n && array[left] > array[largest]) {
                    largest = left;
                }
                
                // If right child is larger than largest so far
                if (right < n && array[right] > array[largest]) {
                    largest = right;
                }
                
                // If largest is not root
                if (largest !== i) {
                    [array[i], array[largest]] = [array[largest], array[i]];
                    this.steps.push({
                        type: 'swap',
                        array: [...array],
                        indices: [i, largest],
                        message: `Swapped ${array[largest]} with ${array[i]} to maintain heap property`
                    });
                    
                    // Recursively heapify the affected sub-tree
                    this.heapify(array, n, largest);
                }
            }
            
            visualizeStep(step) {
                document.getElementById('stepInfo').textContent = step.message;
                this.array = step.array;
                this.renderArray(step);
                this.renderHeap(step);
            }
            
            renderArray(step = null) {
                const container = document.getElementById('arrayContainer');
                container.innerHTML = '';
                
                this.array.forEach((value, index) => {
                    const element = document.createElement('div');
                    element.className = 'array-element';
                    element.textContent = value;
                    
                    if (step) {
                        if (step.type === 'swap' && step.indices.includes(index)) {
                            element.classList.add('swapping');
                        } else if (step.type === 'compare' && step.indices.includes(index)) {
                            element.classList.add('comparison');
                        }
                    }
                    
                    container.appendChild(element);
                });
            }
            
            renderHeap(step = null) {
                const container = document.getElementById('heapRepresentation');
                container.innerHTML = '';
                
                if (this.array.length === 0) return;
                
                // Calculate heap levels
                const levels = [];
                let level = 0;
                let nodesInLevel = 0;
                const maxNodesInLevel = Math.pow(2, level);
                
                for (let i = 0; i < this.array.length; i++) {
                    if (nodesInLevel === 0) {
                        levels[level] = [];
                    }
                    
                    levels[level].push({value: this.array[i], index: i});
                    nodesInLevel++;
                    
                    if (nodesInLevel === maxNodesInLevel) {
                        level++;
                        nodesInLevel = 0;
                    }
                }
                
                // Render heap levels
                levels.forEach((levelNodes, levelIndex) => {
                    const levelDiv = document.createElement('div');
                    levelDiv.className = 'heap-level';
                    
                    levelNodes.forEach(node => {
                        const nodeDiv = document.createElement('div');
                        nodeDiv.className = 'heap-node';
                        nodeDiv.textContent = node.value;
                        
                        if (step) {
                            if (step.type === 'swap' && step.indices.includes(node.index)) {
                                nodeDiv.classList.add('swapping');
                            } else if (step.type === 'compare' && step.indices.includes(node.index)) {
                                nodeDiv.classList.add('comparison');
                            }
                        }
                        
                        levelDiv.appendChild(nodeDiv);
                    });
                    
                    container.appendChild(levelDiv);
                });
            }
        }
        
        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new HeapSortVisualizer();
        });
    </script>
</body>
</html>