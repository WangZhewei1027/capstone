<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Prim's Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; align-items: center;
    background: #f8f9fa;
  }
  h1 {
    margin-top: 1rem;
  }
  #graphCanvas {
    border: 1px solid #333;
    background: white;
    margin: 1rem 0;
    cursor: pointer;
  }
  #controls {
    margin-bottom: 1rem;
  }
  button {
    margin: 0 0.3rem;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
  }
  #info {
    max-width: 700px;
    background: #fff;
    border: 1px solid #ddd;
    padding: 1rem;
    border-radius: 5px;
    line-height: 1.4;
  }
  #weight-input {
    width: 50px;
  }
  #instructions {
    max-width: 700px;
    background: #e2f0d9;
    border: 1px solid #a3c293;
    margin-bottom: 1rem;
    padding: 0.8rem 1rem;
    border-radius: 6px;
    font-size: 0.95rem;
  }
  footer {
    margin: 2rem 0 1rem 0;
    font-size: 0.9rem;
    color: #666;
  }
  a {
    color: #0a66c2;
  }
</style>
</head>
<body>
<h1>Prim's Algorithm Visualization</h1>

<div id="instructions">
  <strong>Instructions:</strong>
  <ul>
    <li>Click on the canvas to add vertices (nodes).</li>
    <li>Click two nodes one after another to create an edge, then enter the edge weight.</li>
    <li>Repeat to build your undirected weighted graph.</li>
    <li>Click <em>Reset Graph</em> to start over.</li>
    <li>Once ready, select a starting node (green highlight) from dropdown and click <em>Run Prim's Algorithm</em>.</li>
    <li>The minimum spanning tree edges appear in red, with total cost displayed.</li>
  </ul>
</div>

<canvas id="graphCanvas" width="700" height="500" aria-label="Graph Canvas"></canvas>

<div id="controls">
  <label for="startNodeSelect">Start Node:</label>
  <select id="startNodeSelect" disabled aria-label="Select start node for Prim's algorithm"></select>
  <button id="runPrim" disabled>Run Prim's Algorithm</button>
  <button id="resetGraph">Reset Graph</button>
  <button id="clearMST" disabled>Clear MST</button>
</div>

<div id="info" aria-live="polite" aria-atomic="true" role="region">
  Build a graph by adding nodes and edges above.
</div>

<footer>
  &copy; 2024 &mdash; Prim's Algorithm Demo | <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" target="_blank" rel="noopener">Learn more</a>
</footer>

<script>
(() => {
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const info = document.getElementById('info');
  const startNodeSelect = document.getElementById('startNodeSelect');
  const runPrimBtn = document.getElementById('runPrim');
  const resetGraphBtn = document.getElementById('resetGraph');
  const clearMSTBtn = document.getElementById('clearMST');

  const NODE_RADIUS = 20;
  const EDGE_COLOR = '#555';
  const SELECTED_EDGE_COLOR = '#c0392b'; // red for MST edges
  const NODE_COLOR = '#2980b9';
  const NODE_HIGHLIGHT_COLOR = '#27ae60'; // green for start node
  const NODE_SELECTED_COLOR = '#f39c12';
  const EDGE_SELECTED_COLOR = '#f39c12';

  let nodes = [];
  let edges = [];
  /*
    nodes: {id: Number, x: Number, y: Number}
    edges: {id1: Number, id2: Number, weight: Number, inMST: Boolean}
  */

  let edgeCreationStep = 0; // 0: waiting for first node, 1: waiting for second node
  let edgeFirstNode = null;

  let mstEdges = [];

  function distance(x1,y1,x2,y2) {
    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);
  }

  function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // Draw all edges
    edges.forEach(edge => {
      const n1 = nodes.find(n => n.id === edge.id1);
      const n2 = nodes.find(n => n.id === edge.id2);
      if (!n1 || !n2) return;
      ctx.beginPath();
      ctx.moveTo(n1.x, n1.y);
      ctx.lineTo(n2.x, n2.y);
      ctx.strokeStyle = edge.inMST ? SELECTED_EDGE_COLOR : EDGE_COLOR;
      ctx.lineWidth = edge.inMST ? 4 : 2;
      ctx.stroke();

      // Draw weight label at midpoint
      const mx = (n1.x + n2.x) / 2;
      const my = (n1.y + n2.y) / 2;
      ctx.fillStyle = edge.inMST ? SELECTED_EDGE_COLOR : '#000';
      ctx.font = '14px Arial';
      ctx.fillText(edge.weight, mx + 5, my - 5);
    });

    // Draw nodes
    nodes.forEach(node => {
      ctx.beginPath();
      ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);
      let fillStyle = NODE_COLOR;
      // Highlight start node green
      if (node.id === +startNodeSelect.value) fillStyle = NODE_HIGHLIGHT_COLOR;
      // Highlight selected node for edge creation
      if (edgeFirstNode && node.id === edgeFirstNode.id) fillStyle = NODE_SELECTED_COLOR;
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw node id inside
      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.id, node.x, node.y);
    });

    // If waiting for second node, show helper line from first node to mouse position
    if(edgeCreationStep === 1 && edgeFirstNode && lastMousePos){
      ctx.beginPath();
      ctx.moveTo(edgeFirstNode.x, edgeFirstNode.y);
      ctx.lineTo(lastMousePos.x, lastMousePos.y);
      ctx.strokeStyle = EDGE_SELECTED_COLOR;
      ctx.lineWidth = 1;
      ctx.setLineDash([5,5]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // Detect node at mouse position
  function getNodeAt(x,y) {
    return nodes.find(n => distance(n.x, n.y, x, y) <= NODE_RADIUS);
  }

  // Add node at position, assign next id
  function addNode(x,y) {
    const newId = nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 1;
    nodes.push({id:newId, x, y});
    updateStartNodeSelect();
    info.textContent = `Node ${newId} added. Now add edges by clicking two nodes in succession.`;
    runPrimBtn.disabled = false;
    clearMSTBtn.disabled = true;
    draw();
  }

  // Add edge between two nodes
  function addEdge(id1, id2, weight) {
    // Check duplicate edge or self-loop
    if(id1 === id2) return false;
    if(edges.some(e => (e.id1 === id1 && e.id2 === id2) || (e.id1 === id2 && e.id2 === id1))) {
      return false;
    }
    edges.push({id1, id2, weight, inMST:false});
    info.textContent = `Edge added between node ${id1} and node ${id2} with weight ${weight}.`;
    clearMSTBtn.disabled = true;
    draw();
    return true;
  }

  // Prompt to enter weight for an edge
  function promptWeight() {
    let weight = null;
    while (true) {
      weight = prompt("Enter edge weight (positive integer):", "1");
      if (weight === null) return null;
      weight = parseInt(weight);
      if (!Number.isNaN(weight) && weight > 0) return weight;
      alert("Please enter a positive integer weight.");
    }
  }

  // Implement Prim's Algorithm
  function prim(startId) {
    // Reset MST flags first
    edges.forEach(e => e.inMST = false);
    mstEdges = [];

    const selected = new Set();
    selected.add(startId);

    // Create adjacency list for graph (undirected)
    const adjacency = {};
    nodes.forEach(n => adjacency[n.id] = []);
    edges.forEach(e => {
      adjacency[e.id1].push({node:e.id2, weight:e.weight});
      adjacency[e.id2].push({node:e.id1, weight:e.weight});
    });

    let totalCost = 0;

    while(selected.size < nodes.length) {
      let minEdge = null;
      let minWeight = Infinity;

      selected.forEach(u => {
        adjacency[u].forEach(({node:v, weight:w}) => {
          if (!selected.has(v) && w < minWeight) {
            minWeight = w;
            minEdge = {id1: u, id2: v, weight: w};
          }
        });
      });

      if (!minEdge) break; // Graph not connected

      selected.add(minEdge.id2);
      totalCost += minEdge.weight;

      // Mark edge in the edges array inMST = true
      const edge = edges.find(e => 
        (e.id1 === minEdge.id1 && e.id2 === minEdge.id2) || (e.id1 === minEdge.id2 && e.id2 === minEdge.id1));
      if (edge) edge.inMST = true;
      mstEdges.push(minEdge);
    }

    draw();

    // Check if MST includes all nodes
    if(selected.size === nodes.length) {
      info.textContent = `Prim's algorithm completed. Total cost of MST: ${totalCost}.`;
      clearMSTBtn.disabled = false;
    } else {
      info.textContent = 'Graph is not connected. MST cannot be formed covering all nodes.';
      clearMSTBtn.disabled = false;
    }
  }

  // Update start node dropdown for Prim's
  function updateStartNodeSelect() {
    startNodeSelect.innerHTML = '';
    nodes.forEach(n => {
      const option = document.createElement('option');
      option.value = n.id;
      option.textContent = `Node ${n.id}`;
      startNodeSelect.appendChild(option);
    });
    startNodeSelect.disabled = nodes.length === 0;
    runPrimBtn.disabled = nodes.length === 0;
  }

  // Clear MST edges shown (reset inMST)
  function clearMST() {
    edges.forEach(e => e.inMST = false);
    mstEdges = [];
    clearMSTBtn.disabled = true;
    info.textContent = 'MST cleared. You can run Prim\'s algorithm again.';
    draw();
  }

  // Reset entire graph
  function resetGraph() {
    nodes = [];
    edges = [];
    mstEdges = [];
    edgeCreationStep = 0;
    edgeFirstNode = null;
    startNodeSelect.innerHTML = '';
    startNodeSelect.disabled = true;
    runPrimBtn.disabled = true;
    clearMSTBtn.disabled = true;
    info.textContent = 'Graph reset. Add new nodes by clicking on the canvas.';
    draw();
  }

  // Variables for mouse move helper line
  let lastMousePos = null;

  // Event listeners
  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const clickedNode = getNodeAt(x,y);

    if(edgeCreationStep === 0) {
      if(clickedNode) {
        // First node for edge creation selected
        edgeFirstNode = clickedNode;
        edgeCreationStep = 1;
        info.textContent = `Selected Node ${edgeFirstNode.id} as first node for edge. Click second node to connect.`;
        draw();
      } else {
        // Add a new node
        addNode(x,y);
      }
    } else if(edgeCreationStep === 1) {
      if(clickedNode && clickedNode.id !== edgeFirstNode.id) {
        // Add edge from edgeFirstNode to clickedNode
        // Prompt weight input
        let weight = promptWeight();
        if(weight !== null) {
          const added = addEdge(edgeFirstNode.id, clickedNode.id, weight);
          if(!added) {
            alert('Edge already exists or invalid. Try a different node.');
          }
          edgeCreationStep = 0;
          edgeFirstNode = null;
          info.textContent += ` Ready to add new edges or nodes.`;
          draw();
        } else {
          info.textContent = 'Edge creation cancelled. Select first node again or add nodes.';
          edgeCreationStep = 0;
          edgeFirstNode = null;
          draw();
        }
      } else {
        info.textContent = 'You must select a different second node to create edge. Operation cancelled.';
        edgeCreationStep = 0;
        edgeFirstNode = null;
        draw();
      }
    }
  });

  canvas.addEventListener('mousemove', e => {
    if(edgeCreationStep === 1 && edgeFirstNode) {
      const rect = canvas.getBoundingClientRect();
      lastMousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
      draw();
    }
  });

  runPrimBtn.addEventListener('click', () => {
    if(nodes.length === 0) {
      alert('No nodes to run algorithm on.');
      return;
    }
    prim(+startNodeSelect.value);
  });

  resetGraphBtn.addEventListener('click', () => {
    if(confirm('Are you sure you want to reset the entire graph?')) {
      resetGraph();
    }
  });

  clearMSTBtn.addEventListener('click', () => {
    clearMST();
  });

  // On load init
  resetGraph();

  // Accessibility: keyboard support to add nodes and edges could be added,
  // but for simplicity this demo uses mouse interaction.

})();
</script>

</body>
</html>