<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Union-Find (Disjoint Set) Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    margin-bottom: 5px;
  }
  #union-find {
    margin: 20px 0;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }
  .node {
    width: 50px;
    height: 50px;
    border: 2px solid #333;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #eee;
    cursor: pointer;
    position: relative;
    user-select: none;
    font-weight: bold;
  }
  .node.header {
    border-color: #666;
    background: #fafafa;
    cursor: default;
  }
  .node .parent-arrow {
    position: absolute;
    top: 60px;
    left: 50%;
    width: 2px;
    height: 20px;
    background: #666;
    transform-origin: top center;
  }
  #controls {
    margin: 20px 0;
  }
  label {
    margin-right: 5px;
  }
  select, button {
    margin-right: 10px;
    padding: 5px 10px;
    font-size: 1rem;
  }
  #log {
    margin-top: 20px;
    max-height: 150px;
    overflow-y: auto;
    background: #f4f4f4;
    border: 1px solid #ccc;
    padding: 10px;
    font-family: monospace;
    white-space: pre-wrap;
  }
  #info {
    max-width: 600px;
    margin-bottom: 15px;
    line-height: 1.3;
  }
</style>
</head>
<body>
<h1>Union-Find (Disjoint Set) Data Structure</h1>
<p id="info">
  Click on elements to select them, then perform "Union" or "Find" operations.<br />
  This structure keeps track of elements partitioned into disjoint sets.<br />
  Each set is represented by a "root" element (parent pointer points to itself).<br />
  This visualization shows parents by arrows and colors groups in distinct colors.
</p>

<div id="union-find"></div>

<div id="controls">
  <label for="operation">Operation:</label>
  <select id="operation">
    <option value="union">Union</option>
    <option value="find">Find</option>
  </select>

  <label for="element1">Element 1:</label>
  <select id="element1"></select>

  <label for="element2" id="element2-label">Element 2:</label>
  <select id="element2"></select>

  <button id="perform-btn">Perform</button>
  <button id="reset-btn">Reset</button>
</div>

<div id="log" aria-live="polite" aria-atomic="true"></div>

<script>
  // Union-Find class with path compression and union by rank
  class UnionFind {
    constructor(n) {
      this.n = n;
      this.parent = new Array(n);
      this.rank = new Array(n);
      for (let i = 0; i < n; i++) {
        this.parent[i] = i;
        this.rank[i] = 0;
      }
    }
    find(x) {
      if (this.parent[x] !== x) {
        this.parent[x] = this.find(this.parent[x]); // Path compression
      }
      return this.parent[x];
    }
    union(x, y) {
      let rootX = this.find(x);
      let rootY = this.find(y);
      if (rootX === rootY) return false; // already connected
      // Union by rank
      if (this.rank[rootX] < this.rank[rootY]) {
        this.parent[rootX] = rootY;
      } else if (this.rank[rootX] > this.rank[rootY]) {
        this.parent[rootY] = rootX;
      } else {
        this.parent[rootY] = rootX;
        this.rank[rootX]++;
      }
      return true;
    }
  }

  // Visualization and UI elements
  const size = 10; // number of elements

  const container = document.getElementById('union-find');
  const element1Select = document.getElementById('element1');
  const element2Select = document.getElementById('element2');
  const operationSelect = document.getElementById('operation');
  const performBtn = document.getElementById('perform-btn');
  const resetBtn = document.getElementById('reset-btn');
  const logDiv = document.getElementById('log');
  const element2Label = document.getElementById('element2-label');

  // Colors for groups, up to 20.
  const groupColors = [
    '#f28b82','#fbbc04','#fff475','#ccff90','#a7ffeb','#cbf0f8','#aecbfa','#d7aefb','#fdcfe8','#e6c9a8',
    '#e8eaed', '#d7ccc8','#90a4ae','#ffab91','#f48fb1','#ce93d8','#b39ddb','#9fa8da','#80cbc4','#81d4fa'
  ];

  let uf;
  let nodes = [];

  // Initialize the UI selects
  function initSelects() {
    element1Select.innerHTML = '';
    element2Select.innerHTML = '';
    for (let i = 0; i < size; i++) {
      const opt1 = document.createElement('option');
      opt1.value = i;
      opt1.textContent = i;
      element1Select.appendChild(opt1);

      const opt2 = document.createElement('option');
      opt2.value = i;
      opt2.textContent = i;
      element2Select.appendChild(opt2);
    }
  }

  // Initialize the nodes in the container
  function initNodes() {
    container.innerHTML = '';
    nodes = [];
    for (let i = 0; i < size; i++) {
      const node = document.createElement('div');
      node.className = 'node';
      node.textContent = i;
      node.dataset.index = i;
      container.appendChild(node);
      nodes.push(node);
    }
  }

  // Draw arrows to parents (using SVG paths)
  const svgNS = "http://www.w3.org/2000/svg";
  // Create an SVG overlay
  let svgOverlay = document.createElementNS(svgNS, "svg");
  svgOverlay.style.position = "absolute";
  svgOverlay.style.top = "0";
  svgOverlay.style.left = "0";
  svgOverlay.style.width = "100%";
  svgOverlay.style.height = "100%";
  svgOverlay.style.pointerEvents = "none";
  svgOverlay.style.zIndex = "0";
  document.body.appendChild(svgOverlay);

  // We will update svg size on resize and re-render arrows
  function resizeSVG() {
    svgOverlay.style.width = window.innerWidth + "px";
    svgOverlay.style.height = window.innerHeight + "px";
  }
  window.addEventListener('resize', () => {
    resizeSVG();
    renderArrows();
  });
  resizeSVG();

  // For better visualization, we'll color groups differently and show parent arrows
  function render() {
    // Assign group roots and set colors accordingly
    let groupMap = new Map();
    let groupIndex = 0;

    function getGroupColor(root) {
      if (!groupMap.has(root)) {
        groupMap.set(root, groupColors[groupIndex % groupColors.length]);
        groupIndex++;
      }
      return groupMap.get(root);
    }

    for (let i = 0; i < size; i++) {
      let root = uf.find(i);
      let color = getGroupColor(root);
      nodes[i].style.backgroundColor = color;
      nodes[i].style.borderColor = shadeColor(color, -50);
      nodes[i].title = `Element ${i}\nParent: ${uf.parent[i]}\nRoot: ${root}`;
    }

    renderArrows();
  }

  // Utility: shade color for border
  function shadeColor(color, percent) {
    // Assumes color in hex form #rrggbb
    let f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent;
    let R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
    return "#" + (0x1000000 +
      (Math.round((t-R)*p/100)+R)*0x10000 +
      (Math.round((t-G)*p/100)+G)*0x100 +
      (Math.round((t-B)*p/100)+B)).toString(16).slice(1);
  }

  // Draw arrows between child and parent nodes
  // We clear and redraw each time
  function renderArrows() {
    while (svgOverlay.firstChild) {
      svgOverlay.removeChild(svgOverlay.firstChild);
    }

    for (let i = 0; i < size; i++) {
      const p = uf.parent[i];
      if (p !== i) {
        const fromNode = nodes[i];
        const toNode = nodes[p];
        const fromRect = fromNode.getBoundingClientRect();
        const toRect = toNode.getBoundingClientRect();

        // Coordinates: center bottom of fromNode to center top of toNode
        const startX = fromRect.left + fromRect.width / 2;
        const startY = fromRect.top + fromRect.height;
        const endX = toRect.left + toRect.width / 2;
        const endY = toRect.top;

        // Create an arrow path with a curve
        let path = document.createElementNS(svgNS, 'path');
        path.setAttribute('stroke', '#333');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('marker-end', 'url(#arrowhead)');
        // Simple quadratic bezier curve
        const midX = (startX + endX) / 2;
        const controlY = startY + 30;
        const d = `M ${startX} ${startY} Q ${midX} ${controlY} ${endX} ${endY}`;
        path.setAttribute('d', d);
        svgOverlay.appendChild(path);
      }
    }
  }

  // Add marker definition for arrowhead to SVG
  function addArrowMarker() {
    const defs = document.createElementNS(svgNS, 'defs');
    const marker = document.createElementNS(svgNS, 'marker');
    marker.setAttribute('id', 'arrowhead');
    marker.setAttribute('markerWidth', 10);
    marker.setAttribute('markerHeight', 7);
    marker.setAttribute('refX', 5);
    marker.setAttribute('refY', 3.5);
    marker.setAttribute('orient', 'auto');
    marker.setAttribute('fill', '#333');

    const polygon = document.createElementNS(svgNS, 'polygon');
    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
    marker.appendChild(polygon);

    defs.appendChild(marker);
    svgOverlay.appendChild(defs);
  }
  addArrowMarker();

  // Log operations
  function log(msg) {
    const timestamp = new Date().toLocaleTimeString();
    logDiv.textContent += `[${timestamp}] ${msg}\n`;
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // Handle operation change: Find only needs one element, Union needs two
  operationSelect.addEventListener('change', () => {
    if (operationSelect.value === 'find') {
      element2Select.style.display = 'none';
      element2Label.style.display = 'none';
    } else {
      element2Select.style.display = '';
      element2Label.style.display = '';
    }
  });

  performBtn.addEventListener('click', () => {
    const op = operationSelect.value;
    const e1 = parseInt(element1Select.value);
    const e2 = parseInt(element2Select.value);

    if (isNaN(e1) || e1 < 0 || e1 >= size) {
      alert('Invalid element 1');
      return;
    }

    if (op === 'union') {
      if (isNaN(e2) || e2 < 0 || e2 >= size) {
        alert('Invalid element 2');
        return;
      }
      if (e1 === e2) {
        alert('Cannot union the same element.');
        return;
      }
      let didUnion = uf.union(e1, e2);
      if (didUnion) {
        log(`Union(${e1}, ${e2}): Sets merged.`);
      } else {
        log(`Union(${e1}, ${e2}): Already in the same set.`);
      }
    } else if (op === 'find') {
      let root = uf.find(e1);
      log(`Find(${e1}): Root = ${root}`);
      alert(`Root of element ${e1} is ${root}`);
    }

    render();
  });

  resetBtn.addEventListener('click', () => {
    uf = new UnionFind(size);
    logDiv.textContent = '';
    render();
  });

  // Initialization
  function init() {
    uf = new UnionFind(size);
    initSelects();
    initNodes();
    operationSelect.dispatchEvent(new Event('change'));
    render();
  }
  init();

</script>
</body>
</html>