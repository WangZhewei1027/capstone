<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            opacity: 0.8;
            font-size: 1.1em;
        }
        
        .controls {
            padding: 20px;
            background: #ecf0f1;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #3498db;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        input {
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .visualization {
            padding: 40px 20px;
            min-height: 500px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        .tree-container {
            position: relative;
        }
        
        .node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #e74c3c;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            position: absolute;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .node.highlight {
            background: #f39c12;
            transform: scale(1.2);
        }
        
        .line {
            position: absolute;
            background: #34495e;
            height: 2px;
            transform-origin: 0 0;
        }
        
        .info-panel {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }
        
        .traversal-result {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            min-height: 40px;
            border: 1px solid #dee2e6;
        }
        
        .node-value {
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Binary Tree Visualization</h1>
            <div class="subtitle">Interactive demonstration of binary tree operations</div>
        </header>
        
        <div class="controls">
            <input type="number" id="nodeValue" placeholder="Enter value" min="0" max="999">
            <button onclick="insertNode()">Insert Node</button>
            <button onclick="deleteNode()">Delete Node</button>
            <button onclick="searchNode()">Search Node</button>
            <button onclick="traverseInOrder()">In-Order Traversal</button>
            <button onclick="traversePreOrder()">Pre-Order Traversal</button>
            <button onclick="traversePostOrder()">Post-Order Traversal</button>
            <button onclick="clearTree()">Clear Tree</button>
            <button onclick="generateRandomTree()">Random Tree</button>
        </div>
        
        <div class="visualization">
            <div id="treeContainer" class="tree-container"></div>
        </div>
        
        <div class="info-panel">
            <h3>Tree Information</h3>
            <div>Height: <span id="treeHeight">0</span></div>
            <div>Number of Nodes: <span id="nodeCount">0</span></div>
            <div>Traversal Result: <div id="traversalResult" class="traversal-result"></div></div>
        </div>
    </div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
            }
        }

        class BinaryTree {
            constructor() {
                this.root = null;
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                    return true;
                }
                
                return this._insertNode(this.root, newNode);
            }

            _insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (!node.left) {
                        node.left = newNode;
                        return true;
                    }
                    return this._insertNode(node.left, newNode);
                } else if (newNode.value > node.value) {
                    if (!node.right) {
                        node.right = newNode;
                        return true;
                    }
                    return this._insertNode(node.right, newNode);
                }
                return false; // Duplicate value
            }

            search(value) {
                return this._searchNode(this.root, value);
            }

            _searchNode(node, value) {
                if (!node) return false;
                if (value === node.value) return true;
                if (value < node.value) return this._searchNode(node.left, value);
                return this._searchNode(node.right, value);
            }

            delete(value) {
                this.root = this._deleteNode(this.root, value);
            }

            _deleteNode(node, value) {
                if (!node) return null;

                if (value < node.value) {
                    node.left = this._deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this._deleteNode(node.right, value);
                } else {
                    if (!node.left && !node.right) return null;
                    if (!node.left) return node.right;
                    if (!node.right) return node.left;

                    const minNode = this._findMin(node.right);
                    node.value = minNode.value;
                    node.right = this._deleteNode(node.right, minNode.value);
                }
                return node;
            }

            _findMin(node) {
                while (node.left) node = node.left;
                return node;
            }

            getHeight(node = this.root) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            getNodeCount(node = this.root) {
                if (!node) return 0;
                return 1 + this.getNodeCount(node.left) + this.getNodeCount(node.right);
            }

            inOrder(node = this.root, result = []) {
                if (node) {
                    this.inOrder(node.left, result);
                    result.push(node.value);
                    this.inOrder(node.right, result);
                }
                return result;
            }

            preOrder(node = this.root, result = []) {
                if (node) {
                    result.push(node.value);
                    this.preOrder(node.left, result);
                    this.preOrder(node.right, result);
                }
                return result;
            }

            postOrder(node = this.root, result = []) {
                if (node) {
                    this.postOrder(node.left, result);
                    this.postOrder(node.right, result);
                    result.push(node.value);
                }
                return result;
            }
        }

        // Global tree instance
        const tree = new BinaryTree();
        let highlightedNode = null;

        function insertNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            
            if (tree.insert(value)) {
                updateVisualization();
                updateInfo();
            } else {
                alert('Value already exists in the tree');
            }
        }

        function deleteNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            
            tree.delete(value);
            updateVisualization();
            updateInfo();
        }

        function searchNode() {
            const value = parseInt(document.getElementById('nodeValue').value);
            if (isNaN(value)) {
                alert('Please enter a valid number');
                return;
            }
            
            if (tree.search(value)) {
                alert(`Value ${value} found in the tree!`);
                highlightNode(value);
            } else {
                alert(`Value ${value} not found in the tree.`);
            }
        }

        function highlightNode(value) {
            // Remove previous highlight
            if (highlightedNode) {
                highlightedNode.classList.remove('highlight');
            }
            
            // Find and highlight the node
            const nodes = document.querySelectorAll('.node');
            nodes.forEach(node => {
                if (parseInt(node.textContent) === value) {
                    node.classList.add('highlight');
                    highlightedNode = node;
                }
            });
        }

        function traverseInOrder() {
            const result = tree.inOrder();
            document.getElementById('traversalResult').textContent = result.join(' → ');
        }

        function traversePreOrder() {
            const result = tree.preOrder();
            document.getElementById('traversalResult').textContent = result.join(' → ');
        }

        function traversePostOrder() {
            const result = tree.postOrder();
            document.getElementById('traversalResult').textContent = result.join(' → ');
        }

        function clearTree() {
            tree.root = null;
            updateVisualization();
            updateInfo();
            document.getElementById('traversalResult').textContent = '';
        }

        function generateRandomTree() {
            clearTree();
            const nodeCount = Math.floor(Math.random() * 10) + 5; // 5-14 nodes
            for (let i = 0; i < nodeCount; i++) {
                const value = Math.floor(Math.random() * 100);
                tree.insert(value);
            }
            updateVisualization();
            updateInfo();
        }

        function updateInfo() {
            document.getElementById('treeHeight').textContent = tree.getHeight();
            document.getElementById('nodeCount').textContent = tree.getNodeCount();
        }

        function updateVisualization() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = '';
            
            if (!tree.root) return;

            // Calculate positions
            const positions = new Map();
            const calculatePositions = (node, x, y, level, offset) => {
                if (!node) return;

                positions.set(node, { x, y });
                
                if (node.left) {
                    calculatePositions(node.left, x - offset, y + 100, level + 1, offset / 2);
                }
                if (node.right) {
                    calculatePositions(node.right, x + offset, y + 100, level + 1, offset / 2);
                }
            };

            calculatePositions(tree.root, 400, 50, 0, 200);

            // Draw lines first (so they appear behind nodes)
            positions.forEach((pos, node) => {
                if (node.left) {
                    const leftPos = positions.get(node.left);
                    drawLine(pos.x + 25, pos.y + 25, leftPos.x + 25, leftPos.y + 25);
                }
                if (node.right) {
                    const rightPos = positions.get(node.right);
                    drawLine(pos.x + 25, pos.y + 25, rightPos.x + 25, rightPos.y + 25);
                }
            });

            // Draw nodes
            positions.forEach((pos, node) => {
                drawNode(pos.x, pos.y, node.value);
            });
        }

        function drawNode(x, y, value) {
            const node = document.createElement('div');
            node.className = 'node';
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            node.innerHTML = `<span class="node-value">${value}</span>`;
            document.getElementById('treeContainer').appendChild(node);
        }

        function drawLine(x1, y1, x2, y2) {
            const line = document.createElement('div');
            line.className = 'line';
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            document.getElementById('treeContainer').appendChild(line);
        }

        // Initialize with a sample tree
        window.onload = function() {
            [50, 30, 70, 20, 40, 60, 80].forEach(value => tree.insert(value));
            updateVisualization();
            updateInfo();
        };
    </script>
</body>
</html>