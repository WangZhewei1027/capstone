{
  "id": "98e14570-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:56.486Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree (BST) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#38bdf8;\n      --accent-2:#60a5fa;\n      --muted:#94a3b8;\n      --node:#0ea5a4;\n      --node-fill:#06b6d4;\n      --node-highlight:#fde047;\n      --text:#e6eef8;\n      --danger:#fb7185;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071028, #08122b);color:var(--text);}\n    .app{\n      display:flex;height:100vh;gap:16px;padding:16px;\n      box-sizing:border-box;\n    }\n    .left{\n      width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:10px;box-shadow:0 6px 24px rgba(2,6,23,0.6);\n      display:flex;flex-direction:column;gap:12px;\n    }\n    h1{font-size:18px;margin:0 0 6px 0;}\n    p.help{margin:0;color:var(--muted);font-size:13px;}\n    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;}\n    input[type=\"number\"], input[type=\"text\"]{\n      padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:var(--text);outline:none;\n    }\n    button{\n      padding:10px;border-radius:8px;border:0;background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#04263b;font-weight:600;cursor:pointer;\n      box-shadow: 0 6px 18px rgba(3,105,161,0.12);\n    }\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text);box-shadow:none;}\n    button.danger{background:linear-gradient(180deg,var(--danger),#ff7b8a);color:#2b0216;}\n    .small{padding:8px;font-size:13px;}\n    .actions{display:flex;gap:8px;flex-wrap:wrap;}\n    .panel{\n      background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);\n      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);\n    }\n    .traversal-output{min-height:48px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);color:var(--muted);font-size:14px;display:flex;align-items:center;gap:6px;flex-wrap:wrap;}\n    .label{font-size:12px;color:var(--muted);margin-bottom:6px;}\n    .footer{margin-top:auto;font-size:12px;color:var(--muted);}\n    .canvas-wrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03);position:relative;overflow:hidden;}\n    .svg-canvas{width:100%;height:100%;display:block;}\n    .node{cursor:pointer;transition:transform 200ms ease;}\n    .node circle{transition:fill 200ms, r 200ms, stroke 200ms;}\n    .node text{fill:#021422;font-weight:700;font-size:12px;pointer-events:none;}\n    .node .value{dominant-baseline:middle;text-anchor:middle;}\n    .node.normal circle{fill:var(--node-fill);stroke:rgba(0,0,0,0.25);stroke-width:2;}\n    .node.searching circle{fill:var(--accent);stroke:rgba(0,0,0,0.35);stroke-width:3; r:20;}\n    .node.found circle{fill:var(--node-highlight);stroke:#c084fc;stroke-width:3;}\n    .node.deleted circle{fill:#fca5a5;stroke:#b91c1c;}\n    .edge{stroke:rgba(255,255,255,0.07);stroke-width:2}\n    .controls-row{display:flex;gap:8px;}\n    .info{font-size:13px;color:var(--muted);line-height:1.4}\n    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .legend .key{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}\n    .smalltext{font-size:12px;color:var(--muted)}\n    @media (max-width:900px){\n      .app{flex-direction:column;padding:12px;}\n      .left{width:100%;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left panel\">\n      <h1>Binary Search Tree (BST) — Interactive Demo</h1>\n      <p class=\"help\">Insert, find, delete keys and watch how the BST structure changes. Use traversals to see visiting order.</p>\n\n      <div class=\"panel\">\n        <div class=\"label\">Insert / Delete / Search</div>\n        <div style=\"display:flex;gap:8px;margin-bottom:8px;\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"Enter integer key\" />\n          <button id=\"insertBtn\">Insert</button>\n          <button id=\"deleteBtn\" class=\"danger\">Delete</button>\n        </div>\n        <div style=\"display:flex;gap:8px;\">\n          <input id=\"searchInput\" type=\"number\" placeholder=\"Search key\" />\n          <button id=\"searchBtn\" class=\"ghost small\">Search</button>\n          <button id=\"clearBtn\" class=\"ghost small\">Clear Tree</button>\n        </div>\n        <div class=\"smalltext\" style=\"margin-top:8px;\">Tip: Click a node in the visualization to delete it quickly.</div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"label\">Traversals (animated)</div>\n        <div class=\"actions\">\n          <button id=\"inorderBtn\" class=\"small\">In-order</button>\n          <button id=\"preorderBtn\" class=\"small\">Pre-order</button>\n          <button id=\"postorderBtn\" class=\"small\">Post-order</button>\n          <button id=\"levelBtn\" class=\"small\">Level-order</button>\n          <button id=\"stopAnim\" class=\"ghost small\">Stop</button>\n        </div>\n        <div style=\"margin-top:8px\" class=\"traversal-output\" id=\"traversalOutput\">Sequence will appear here...</div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"label\">Quick actions</div>\n        <div style=\"display:flex;gap:8px;margin-bottom:8px;\">\n          <button id=\"randomBtn\" class=\"small\">Random Tree</button>\n          <button id=\"balancedBtn\" class=\"small ghost\">Balanced (7 nodes)</button>\n          <button id=\"sampleBtn\" class=\"small ghost\">Sample Walkthrough</button>\n        </div>\n        <div class=\"legend\" style=\"margin-top:6px;\">\n          <div class=\"key\"><span style=\"display:inline-block;width:14px;height:14px;background:var(--node-fill);border-radius:3px\"></span> Node</div>\n          <div class=\"key\"><span style=\"display:inline-block;width:14px;height:14px;background:var(--node-highlight);border-radius:3px\"></span> Found</div>\n        </div>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"info\">BST rules: left < right for each node. Duplicate keys are ignored.</div>\n      </div>\n    </div>\n\n    <div class=\"canvas-wrap panel\" id=\"canvasWrap\">\n      <svg id=\"svg\" class=\"svg-canvas\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n  </div>\n\n  <script>\n  /*****************************************************************************\n   * Binary Search Tree interactive demo\n   * - Supports insert, search, delete\n   * - Traversals: inorder, preorder, postorder, level-order (animated)\n   * - Visualized with SVG; click nodes to delete\n   *\n   * Implementation notes:\n   * - Keys are integer values.\n   * - Layout: assign x positions using inorder indexing, y by depth.\n   * - Deletion handles 3 cases (leaf, one child, two children using successor replacement).\n   *****************************************************************************/\n\n  // Basic BST node class\n  class Node {\n    constructor(key){\n      this.key = key;\n      this.left = null;\n      this.right = null;\n      this.parent = null;\n      this.x = 0; // layout position\n      this.y = 0;\n    }\n  }\n\n  class BST {\n    constructor(){\n      this.root = null;\n    }\n\n    insert(key){\n      const node = new Node(key);\n      if (!this.root){\n        this.root = node;\n        return true;\n      }\n      let cur = this.root;\n      while (true){\n        if (key === cur.key) return false; // ignore duplicates\n        if (key < cur.key){\n          if (!cur.left){\n            cur.left = node;\n            node.parent = cur;\n            return true;\n          }\n          cur = cur.left;\n        } else {\n          if (!cur.right){\n            cur.right = node;\n            node.parent = cur;\n            return true;\n          }\n          cur = cur.right;\n        }\n      }\n    }\n\n    find(key){\n      let cur = this.root;\n      while (cur){\n        if (key === cur.key) return cur;\n        cur = (key < cur.key) ? cur.left : cur.right;\n      }\n      return null;\n    }\n\n    // Transplant subtree u with v (v may be null)\n    transplant(u, v){\n      if (!u.parent){\n        this.root = v;\n      } else if (u === u.parent.left){\n        u.parent.left = v;\n      } else {\n        u.parent.right = v;\n      }\n      if (v) v.parent = u.parent;\n    }\n\n    minNode(node){\n      let cur = node;\n      while (cur && cur.left) cur = cur.left;\n      return cur;\n    }\n\n    delete(key){\n      const z = this.find(key);\n      if (!z) return false;\n      // Standard BST deletion\n      if (!z.left){\n        this.transplant(z, z.right);\n      } else if (!z.right){\n        this.transplant(z, z.left);\n      } else {\n        const y = this.minNode(z.right);\n        if (y.parent !== z){\n          this.transplant(y, y.right);\n          y.right = z.right;\n          if (y.right) y.right.parent = y;\n        }\n        this.transplant(z, y);\n        y.left = z.left;\n        if (y.left) y.left.parent = y;\n      }\n      return true;\n    }\n\n    // Traversals that return arrays of nodes\n    inorder(node=this.root, arr=[]){\n      if (!node) return arr;\n      this.inorder(node.left, arr);\n      arr.push(node);\n      this.inorder(node.right, arr);\n      return arr;\n    }\n    preorder(node=this.root, arr=[]){\n      if (!node) return arr;\n      arr.push(node);\n      this.preorder(node.left, arr);\n      this.preorder(node.right, arr);\n      return arr;\n    }\n    postorder(node=this.root, arr=[]){\n      if (!node) return arr;\n      this.postorder(node.left, arr);\n      this.postorder(node.right, arr);\n      arr.push(node);\n      return arr;\n    }\n    levelOrder(){\n      const arr=[];\n      if (!this.root) return arr;\n      const q=[this.root];\n      while(q.length){\n        const n=q.shift();\n        arr.push(n);\n        if(n.left) q.push(n.left);\n        if(n.right) q.push(n.right);\n      }\n      return arr;\n    }\n\n    // utility: get all keys (sorted)\n    keys(){\n      return this.inorder().map(n=>n.key);\n    }\n  }\n\n  // UI + Visualization\n  const svg = document.getElementById('svg');\n  const valueInput = document.getElementById('valueInput');\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const searchInput = document.getElementById('searchInput');\n  const searchBtn = document.getElementById('searchBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const balancedBtn = document.getElementById('balancedBtn');\n  const sampleBtn = document.getElementById('sampleBtn');\n  const inorderBtn = document.getElementById('inorderBtn');\n  const preorderBtn = document.getElementById('preorderBtn');\n  const postorderBtn = document.getElementById('postorderBtn');\n  const levelBtn = document.getElementById('levelBtn');\n  const traversalOutput = document.getElementById('traversalOutput');\n  const stopAnim = document.getElementById('stopAnim');\n  const canvasWrap = document.getElementById('canvasWrap');\n\n  let bst = new BST();\n\n  // Animation controls\n  let animTimer = null;\n  let stopRequested = false;\n\n  function clearAnim(){\n    stopRequested = true;\n    if (animTimer){ clearTimeout(animTimer); animTimer = null;}\n  }\n\n  stopAnim.addEventListener('click', () => {\n    clearAnim();\n    resetHighlights();\n  });\n\n  // Layout parameters\n  const width = 1200;\n  const height = 800;\n  const levelHeight = 110;\n  const nodeR = 20;\n\n  // Compute positions: inorder-based x coordinate, y = depth * levelHeight\n  function computePositions(){\n    // assign x by inorder index\n    let index = 0;\n    (function dfs(node, depth){\n      if (!node) return;\n      dfs(node.left, depth+1);\n      node.x = ++index; // temporary index\n      node.y = depth;\n      dfs(node.right, depth+1);\n    })(bst.root, 0);\n\n    // Determine max index\n    const maxIndex = index || 1;\n    // Map to SVG coordinates\n    const marginX = 60;\n    const usableW = width - marginX*2;\n    const spacing = usableW / maxIndex;\n    (function dfs2(node){\n      if (!node) return;\n      node.cx = marginX + (node.x - 0.5)*spacing; // center x\n      node.cy = 60 + node.y * levelHeight;\n      dfs2(node.left);\n      dfs2(node.right);\n    })(bst.root);\n  }\n\n  // Render tree into SVG\n  function render(){\n    // Clear animation highlights when re-rendering (but not if in traversal)\n    // We'll fully rebuild SVG for simplicity\n    svg.innerHTML = '';\n    computePositions();\n    // Add edges first\n    (function drawEdges(node){\n      if (!node) return;\n      if (node.left){\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1', node.cx);\n        line.setAttribute('y1', node.cy);\n        line.setAttribute('x2', node.left.cx);\n        line.setAttribute('y2', node.left.cy);\n        line.setAttribute('class','edge');\n        svg.appendChild(line);\n      }\n      if (node.right){\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1', node.cx);\n        line.setAttribute('y1', node.cy);\n        line.setAttribute('x2', node.right.cx);\n        line.setAttribute('y2', node.right.cy);\n        line.setAttribute('class','edge');\n        svg.appendChild(line);\n      }\n      drawEdges(node.left);\n      drawEdges(node.right);\n    })(bst.root);\n\n    // Add nodes\n    (function drawNode(node){\n      if (!node) return;\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${node.cx},${node.cy})`);\n      g.setAttribute('data-key', node.key);\n      g.setAttribute('class','node normal');\n\n      // group components\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', nodeR);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('class','value');\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 4); // adjust baseline\n      text.textContent = node.key;\n\n      // click to delete quickly\n      g.addEventListener('click', (e)=>{\n        e.stopPropagation();\n        // confirm\n        if (!confirm('Delete node ' + node.key + ' ?')) return;\n        clearAnim();\n        bst.delete(node.key);\n        render();\n      });\n\n      g.appendChild(circle);\n      g.appendChild(text);\n      svg.appendChild(g);\n      drawNode(node.left);\n      drawNode(node.right);\n    })(bst.root);\n\n    // Fit viewBox to content gracefully\n    // We keep static viewBox width/height for simplicity (1200x800) to keep layout stable\n    // Reset traversal output if tree empty\n    if (!bst.root){\n      traversalOutput.textContent = 'Tree is empty';\n    }\n  }\n\n  function resetHighlights(){\n    const nodes = svg.querySelectorAll('.node');\n    nodes.forEach(n=> {\n      n.classList.remove('searching','found','deleted');\n      n.classList.add('normal');\n    });\n  }\n\n  // Helper to highlight a node by key\n  function highlightKey(key, cls){\n    const g = svg.querySelector('.node[data-key=\"'+key+'\"]');\n    if (!g) return;\n    g.classList.remove('normal');\n    g.classList.add(cls);\n  }\n\n  // Insertion handler\n  insertBtn.addEventListener('click', ()=>{\n    const val = Number(valueInput.value);\n    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer value.'); return; }\n    clearAnim();\n    const ok = bst.insert(val);\n    if (!ok){\n      alert('Duplicate key ignored.');\n    }\n    render();\n    valueInput.value = '';\n  });\n\n  // Delete handler using input\n  deleteBtn.addEventListener('click', ()=>{\n    const val = Number(valueInput.value);\n    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer key to delete.'); return; }\n    clearAnim();\n    const ok = bst.delete(val);\n    if (!ok){\n      alert('Key not found.');\n    }\n    render();\n    valueInput.value = '';\n  });\n\n  // Search handler: animate search path\n  searchBtn.addEventListener('click', ()=>{\n    const val = Number(searchInput.value);\n    if (!Number.isFinite(val) || Number.isNaN(val)) { alert('Enter a valid integer key to search.'); return; }\n    clearAnim();\n    resetHighlights();\n    let cur = bst.root;\n    const path = [];\n    while (cur){\n      path.push(cur);\n      if (val === cur.key) break;\n      cur = (val < cur.key) ? cur.left : cur.right;\n    }\n    animatePath(path, cur && cur.key===val ? 'found' : 'deleted', ()=> {\n      if (!cur) traversalOutput.textContent = `Key ${val} not found. Path visited: ` + path.map(n=>n.key).join(', ');\n      else traversalOutput.textContent = `Found ${val}. Path: ` + path.map(n=>n.key).join(' → ');\n    });\n    searchInput.value = '';\n  });\n\n  // Click on blank area clears selected highlights\n  svg.addEventListener('click', (e)=>{\n    resetHighlights();\n  });\n\n  // Traversal animations\n  function animateSequence(nodes, labelPrefix='Visited', speed=500){\n    clearAnim();\n    traversalOutput.textContent = labelPrefix + ': ';\n    const arr = nodes.slice(); // nodes are Node objects\n    let i = 0;\n    stopRequested = false;\n    function step(){\n      if (stopRequested) { resetHighlights(); traversalOutput.textContent += ' (stopped)'; return; }\n      if (i>0){\n        // un-highlight previous\n        const prev = arr[i-1];\n        const pg = svg.querySelector('.node[data-key=\"'+prev.key+'\"]');\n        if (pg) pg.classList.remove('searching');\n      }\n      if (i >= arr.length){\n        // all done\n        traversalOutput.textContent = labelPrefix + ': ' + arr.map(n=>n.key).join(', ');\n        if (arr.length>0){\n          const last = arr[arr.length-1];\n          const lg = svg.querySelector('.node[data-key=\"'+last.key+'\"]');\n          if (lg){\n            lg.classList.add('found');\n            lg.classList.remove('searching');\n          }\n        }\n        animTimer = null;\n        return;\n      }\n      const node = arr[i];\n      const g = svg.querySelector('.node[data-key=\"'+node.key+'\"]');\n      if (g){\n        g.classList.add('searching');\n        g.classList.remove('normal');\n      }\n      traversalOutput.textContent = labelPrefix + ': ' + arr.slice(0,i+1).map(n=>n.key).join(', ');\n      i++;\n      animTimer = setTimeout(step, speed);\n    }\n    step();\n  }\n\n  function animatePath(pathNodes, finalClass, callback){\n    clearAnim();\n    let i = 0;\n    stopRequested = false;\n    traversalOutput.textContent = 'Searching: ';\n    function step(){\n      if (stopRequested) { resetHighlights(); traversalOutput.textContent += ' (stopped)'; return; }\n      if (i>0){\n        const prev = pathNodes[i-1];\n        const pg = svg.querySelector('.node[data-key=\"'+prev.key+'\"]');\n        if (pg) pg.classList.remove('searching');\n      }\n      if (i >= pathNodes.length){\n        // done; highlight final status\n        if (pathNodes.length>0){\n          const last = pathNodes[pathNodes.length-1];\n          const lg = svg.querySelector('.node[data-key=\"'+last.key+'\"]');\n          if (lg){\n            if (finalClass === 'found'){\n              lg.classList.remove('searching'); lg.classList.add('found');\n            } else {\n              lg.classList.remove('searching'); lg.classList.add('deleted');\n            }\n          }\n        }\n        animTimer = null;\n        if (callback) callback();\n        return;\n      }\n      const node = pathNodes[i];\n      const g = svg.querySelector('.node[data-key=\"'+node.key+'\"]');\n      if (g){\n        g.classList.add('searching');\n        g.classList.remove('normal');\n      }\n      traversalOutput.textContent = 'Searching: ' + pathNodes.slice(0,i+1).map(n=>n.key).join(' → ');\n      i++;\n      animTimer = setTimeout(step, 450);\n    }\n    step();\n  }\n\n  inorderBtn.addEventListener('click', ()=>{\n    const nodes = bst.inorder();\n    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }\n    animateSequence(nodes, 'In-order', 450);\n  });\n  preorderBtn.addEventListener('click', ()=>{\n    const nodes = bst.preorder();\n    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }\n    animateSequence(nodes, 'Pre-order', 450);\n  });\n  postorderBtn.addEventListener('click', ()=>{\n    const nodes = bst.postorder();\n    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }\n    animateSequence(nodes, 'Post-order', 450);\n  });\n  levelBtn.addEventListener('click', ()=>{\n    const nodes = bst.levelOrder();\n    if (!nodes.length){ traversalOutput.textContent='Tree empty'; return; }\n    animateSequence(nodes, 'Level-order', 450);\n  });\n\n  // Utility: random tree\n  randomBtn.addEventListener('click', ()=>{\n    clearAnim();\n    bst = new BST();\n    const n = Math.floor(Math.random()*8)+3; // 3..10 nodes\n    const keys = new Set();\n    while (keys.size < n){\n      keys.add(Math.floor(Math.random()*90)-45); // allow negatives\n    }\n    [...keys].forEach(k => bst.insert(k));\n    render();\n    traversalOutput.textContent = 'Random tree with '+n+' nodes: ' + bst.keys().join(', ');\n  });\n\n  balancedBtn.addEventListener('click', ()=>{\n    clearAnim();\n    // create a balanced-ish BST by inserting middle-first for 7 nodes\n    bst = new BST();\n    const arr = [1,2,3,4,5,6,7];\n    function build(a){\n      if (!a.length) return;\n      const mid = Math.floor(a.length/2);\n      bst.insert(a[mid]);\n      build(a.slice(0,mid));\n      build(a.slice(mid+1));\n    }\n    build(arr);\n    render();\n    traversalOutput.textContent = 'Balanced sample created (1..7)';\n  });\n\n  sampleBtn.addEventListener('click', ()=>{\n    clearAnim();\n    bst = new BST();\n    [50,30,70,20,40,60,80,10,25,35,45,55,65].forEach(x=>bst.insert(x));\n    render();\n    traversalOutput.textContent = 'Sample walkthrough tree populated.';\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    if (!confirm('Clear the entire tree?')) return;\n    clearAnim();\n    bst = new BST();\n    render();\n    traversalOutput.textContent = 'Tree cleared.';\n  });\n\n  // initialize with some sample nodes\n  (function init(){\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(40);\n    bst.insert(60);\n    bst.insert(80);\n    render();\n    traversalOutput.textContent = 'Sample tree loaded. Try insert/search/delete or traversals.';\n  })();\n\n  // Make the SVG responsive to container size\n  function resizeViewBox(){\n    // Keep as fixed viewBox (1200x800) but scale the SVG to fit container using preserveAspectRatio.\n    // Optionally could adjust on small screens; leaving as-is for simplicity.\n  }\n  window.addEventListener('resize', resizeViewBox);\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}