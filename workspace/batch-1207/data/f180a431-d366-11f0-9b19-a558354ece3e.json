{
  "id": "f180a431-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:20.470Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Weighted Graph Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        button {\n            padding: 8px 16px;\n            background: #007bff;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background: #0056b3;\n        }\n        button:disabled {\n            background: #6c757d;\n            cursor: not-allowed;\n        }\n        #graph-canvas {\n            border: 1px solid #ddd;\n            background: #f8f9fa;\n        }\n        .info-panel {\n            margin-top: 20px;\n            padding: 15px;\n            background: #e9ecef;\n            border-radius: 4px;\n        }\n        .node {\n            cursor: pointer;\n        }\n        .weight-label {\n            font-size: 12px;\n            font-weight: bold;\n            fill: #dc3545;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Weighted Graph Visualization</h1>\n        \n        <div class=\"controls\">\n            <button onclick=\"addNode()\">Add Node</button>\n            <button onclick=\"addEdge()\">Add Edge</button>\n            <button onclick=\"findShortestPath()\">Find Shortest Path</button>\n            <button onclick=\"clearGraph()\">Clear Graph</button>\n            <button onclick=\"generateRandomGraph()\">Generate Random Graph</button>\n        </div>\n\n        <div>\n            <svg id=\"graph-canvas\" width=\"1000\" height=\"600\"></svg>\n        </div>\n\n        <div class=\"info-panel\">\n            <h3>Graph Information</h3>\n            <p id=\"graph-info\">Nodes: 0, Edges: 0</p>\n            <p id=\"shortest-path\">Shortest path will appear here</p>\n            <p><strong>Instructions:</strong> Click \"Add Node\" to add nodes, then \"Add Edge\" to connect them with weights</p>\n        </div>\n    </div>\n\n    <script>\n        class WeightedGraph {\n            constructor() {\n                this.nodes = new Map();\n                this.edges = [];\n            }\n\n            addNode(id, x, y) {\n                this.nodes.set(id, { id, x, y, edges: [] });\n            }\n\n            addEdge(from, to, weight) {\n                if (this.nodes.has(from) && this.nodes.has(to)) {\n                    const edge = { from, to, weight };\n                    this.edges.push(edge);\n                    this.nodes.get(from).edges.push(edge);\n                    this.nodes.get(to).edges.push({ from: to, to: from, weight });\n                }\n            }\n\n            dijkstra(start, end) {\n                const distances = new Map();\n                const previous = new Map();\n                const unvisited = new Set();\n\n                // Initialize distances\n                for (const nodeId of this.nodes.keys()) {\n                    distances.set(nodeId, nodeId === start ? 0 : Infinity);\n                    previous.set(nodeId, null);\n                    unvisited.add(nodeId);\n                }\n\n                while (unvisited.size > 0) {\n                    // Get node with smallest distance\n                    let current = null;\n                    for (const nodeId of unvisited) {\n                        if (current === null || distances.get(nodeId) < distances.get(current)) {\n                            current = nodeId;\n                        }\n                    }\n\n                    if (current === end || distances.get(current) === Infinity) break;\n\n                    unvisited.delete(current);\n\n                    // Update distances to neighbors\n                    const currentNode = this.nodes.get(current);\n                    for (const edge of currentNode.edges) {\n                        if (unvisited.has(edge.to)) {\n                            const alt = distances.get(current) + edge.weight;\n                            if (alt < distances.get(edge.to)) {\n                                distances.set(edge.to, alt);\n                                previous.set(edge.to, current);\n                            }\n                        }\n                    }\n                }\n\n                // Reconstruct path\n                const path = [];\n                let current = end;\n                while (previous.get(current) !== null) {\n                    path.unshift(current);\n                    current = previous.get(current);\n                }\n                if (path.length > 0) path.unshift(start);\n\n                return {\n                    path: distances.get(end) !== Infinity ? path : [],\n                    distance: distances.get(end)\n                };\n            }\n        }\n\n        class GraphRenderer {\n            constructor(svgElement) {\n                this.svg = svvgElement;\n                this.graph = new WeightedGraph();\n                this.nodeCounter = 0;\n                this.isAddingEdge = false;\n                this.edgeStartNode = null;\n                this.selectedNodes = new Set();\n                this.init();\n            }\n\n            init() {\n                this.svg.innerHTML = '';\n                this.updateInfo();\n            }\n\n            addNode(x, y) {\n                const nodeId = `N${++this.nodeCounter}`;\n                this.graph.addNode(nodeId, x, y);\n                this.render();\n                return nodeId;\n            }\n\n            addEdgeWithWeight(from, to, weight) {\n                this.graph.addEdge(from, to, weight);\n                this.render();\n            }\n\n            render() {\n                this.svg.innerHTML = '';\n\n                // Render edges\n                this.graph.edges.forEach(edge => {\n                    const fromNode = this.graph.nodes.get(edge.from);\n                    const toNode = this.graph.nodes.get(edge.to);\n                    \n                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                    line.setAttribute('x1', fromNode.x);\n                    line.setAttribute('y1', fromNode.y);\n                    line.setAttribute('x2', toNode.x);\n                    line.setAttribute('y2', toNode.y);\n                    line.setAttribute('stroke', this.selectedNodes.has(edge.from) && \n                                              this.selectedNodes.has(edge.to) ? '#28a745' : '#007bff');\n                    line.setAttribute('stroke-width', '2');\n                    this.svg.appendChild(line);\n\n                    // Weight label\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    text.setAttribute('x', midX);\n                    text.setAttribute('y', midY - 5);\n                    text.setAttribute('class', 'weight-label');\n                    text.textContent = edge.weight;\n                    this.svg.appendChild(text);\n                });\n\n                // Render nodes\n                for (const [id, node] of this.graph.nodes) {\n                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                    circle.setAttribute('cx', node.x);\n                    circle.setAttribute('cy', node.y);\n                    circle.setAttribute('r', '20');\n                    circle.setAttribute('fill', this.selectedNodes.has(id) ? '#28a745' : '#007bff');\n                    circle.setAttribute('class', 'node');\n                    circle.setAttribute('data-nodeid', id);\n                    \n                    circle.addEventListener('click', (e) => this.handleNodeClick(id, e));\n                    this.svg.appendChild(circle);\n\n                    // Node label\n                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    text.setAttribute('x', node.x);\n                    text.setAttribute('y', node.y + 5);\n                    text.setAttribute('text-anchor', 'middle');\n                    text.setAttribute('fill', 'white');\n                    text.setAttribute('font-weight', 'bold');\n                    text.textContent = id;\n                    this.svg.appendChild(text);\n                }\n\n                this.updateInfo();\n            }\n\n            handleNodeClick(nodeId, event) {\n                if (this.isAddingEdge) {\n                    if (this.edgeStartNode === null) {\n                        this.edgeStartNode = nodeId;\n                        this.selectedNodes.add(nodeId);\n                    } else {\n                        const weight = prompt(`Enter weight for edge between ${this.edgeStartNode} and ${nodeId}:`, '1');\n                        if (weight && !isNaN(parseFloat(weight))) {\n                            this.addEdgeWithWeight(this.edgeStartNode, nodeId, parseFloat(weight));\n                        }\n                        this.isAddingEdge = false;\n                        this.edgeStartNode = null;\n                        this.selectedNodes.clear();\n                    }\n                    this.render();\n                } else {\n                    // Select/deselect node for path finding\n                    if (this.selectedNodes.has(nodeId)) {\n                        this.selectedNodes.delete(nodeId);\n                    } else {\n                        this.selectedNodes.add(nodeId);\n                    }\n                    this.render();\n                }\n                event.stopPropagation();\n            }\n\n            findShortestPath() {\n                const selected = Array.from(this.selectedNodes);\n                if (selected.length !== 2) {\n                    alert('Please select exactly 2 nodes for path finding');\n                    return;\n                }\n\n                const result = this.graph.dijkstra(selected[0], selected[1]);\n                const pathInfo = document.getElementById('shortest-path');\n                \n                if (result.path.length > 0) {\n                    pathInfo.textContent = `Shortest path from ${selected[0]} to ${selected[1]}: ${result.path.join(' â†’ ')} (Distance: ${result.distance})`;\n                    this.highlightPath(result.path);\n                } else {\n                    pathInfo.textContent = `No path found between ${selected[0]} and ${selected[1]}`;\n                }\n            }\n\n            highlightPath(path) {\n                this.selectedNodes.clear();\n                path.forEach(node => this.selectedNodes.add(node));\n                this.render();\n            }\n\n            clear() {\n                this.graph = new WeightedGraph();\n                this.nodeCounter = 0;\n                this.selectedNodes.clear();\n                this.isAddingEdge = false;\n                this.edgeStartNode = null;\n                this.init();\n            }\n\n            updateInfo() {\n                const info = document.getElementById('graph-info');\n                info.textContent = `Nodes: ${this.graph.nodes.size}, Edges: ${this.graph.edges.length}`;\n            }\n\n            generateRandomGraph() {\n                this.clear();\n                \n                // Add 6-8 random nodes\n                const nodeCount = Math.floor(Math.random() * 3) + 6;\n                const nodes = [];\n                \n                for (let i = 0; i < nodeCount; i++) {\n                    const x = 100 + Math.random() * 800;\n                    const y = 100 + Math.random() * 400;\n                    nodes.push(this.addNode(x, y));\n                }\n\n                // Add random edges\n                for (let i = 0; i < nodeCount * 1.5; i++) {\n                    const from = nodes[Math.floor(Math.random() * nodes.length)];\n                    const to = nodes[Math.floor(Math.random() * nodes.length)];\n                    if (from !== to) {\n                        const weight = Math.floor(Math.random() * 20) + 1;\n                        this.addEdgeWithWeight(from, to, weight);\n                    }\n                }\n            }\n        }\n\n        // Initialize the application\n        const svg = document.getElementById('graph-canvas');\n        const renderer = new GraphRenderer(svg);\n\n        // Add node on canvas click\n        svg.addEventListener('click', (event) => {\n            if (!renderer.isAddingEdge) {\n                const rect = svg.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = event.clientY - rect.top;\n                renderer.addNode(x, y);\n            }\n        });\n\n        // Global functions for button controls\n        function addNode() {\n            renderer.isAddingEdge = false;\n            renderer.edgeStartNode = null;\n            renderer.selectedNodes.clear();\n        }\n\n        function addEdge() {\n            renderer.isAddingEdge = true;\n            renderer.edgeStartNode = null;\n            renderer.selectedNodes.clear();\n            alert('Click on two nodes to create an edge. Enter weight when prompted.');\n        }\n\n        function findShortestPath() {\n            renderer.findShortestPath();\n        }\n\n        function clearGraph() {\n            renderer.clear();\n            document.getElementById('shortest-path').textContent = 'Shortest path will appear here';\n        }\n\n        function generateRandomGraph() {\n            renderer.generateRandomGraph();\n        }\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}