{
  "id": "e93410b1-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:43.063Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Depth-First Search (DFS) Visualizer</title>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n  #left { width: 720px; padding: 12px; box-sizing: border-box; border-right: 1px solid #ddd; display: flex; flex-direction: column; gap: 10px; }\n  #canvasWrap { flex: 1; display: flex; align-items: center; justify-content: center; }\n  canvas { background: #f8f8f8; box-shadow: 0 2px 6px rgba(0,0,0,0.08); cursor: pointer; }\n  #controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }\n  button { padding: 6px 10px; border-radius: 6px; border: 1px solid #bbb; background: white; cursor: pointer; }\n  button:active { transform: translateY(1px); }\n  select, input[type=\"range\"], input[type=\"number\"] { padding: 6px; border-radius: 6px; border: 1px solid #bbb; }\n  label { font-size: 13px; color: #333; }\n  #right { width: 360px; padding: 12px; box-sizing: border-box; overflow: auto; }\n  h2 { margin: 6px 0; font-size: 16px; }\n  .info { font-size: 13px; color: #333; margin-bottom: 8px; }\n  .legend { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }\n  .legendItem { display:flex; align-items:center; gap:6px; font-size:13px; }\n  .swatch { width:18px; height:18px; border-radius:4px; border:1px solid #aaa; }\n  #stackView { font-family: monospace; font-size: 13px; background: #f7f7ff; padding:8px; border-radius:6px; border:1px solid #e2e2ff; max-height: 260px; overflow:auto; }\n  #stats { font-size: 13px; color: #333; margin-top:6px; }\n  small { color:#666; }\n  footer { margin-top:8px; font-size:12px; color:#666; }\n  .controlsCol { display:flex; gap:8px; align-items:center; }\n  .muted { color:#555; font-size:13px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n      <h1 style=\"font-size:18px;margin:0\">DFS Visualizer</h1>\n      <div class=\"muted\">Depth-First Search (stack / recursion)</div>\n    </div>\n\n    <div id=\"canvasWrap\">\n      <canvas id=\"grid\" width=\"640\" height=\"480\"></canvas>\n    </div>\n\n    <div id=\"controls\">\n      <div class=\"controlsCol\">\n        <label for=\"mode\">Mode</label>\n        <select id=\"mode\">\n          <option value=\"toggle\">Toggle Wall</option>\n          <option value=\"start\">Set Start</option>\n          <option value=\"goal\">Set Goal</option>\n        </select>\n      </div>\n\n      <div class=\"controlsCol\">\n        <label for=\"algo\">Algorithm</label>\n        <select id=\"algo\">\n          <option value=\"iter\">Iterative (stack)</option>\n          <option value=\"rec\">Recursive</option>\n        </select>\n      </div>\n\n      <button id=\"runBtn\">Run</button>\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"pauseBtn\" disabled>Pause</button>\n      <button id=\"resetBtn\">Reset</button>\n\n      <div class=\"controlsCol\">\n        <label for=\"speed\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"10\" max=\"1000\" value=\"120\">\n      </div>\n\n      <div class=\"controlsCol\">\n        <label for=\"rows\">Rows</label>\n        <input id=\"rows\" type=\"number\" min=\"6\" max=\"60\" value=\"12\" style=\"width:64px\">\n        <label for=\"cols\">Cols</label>\n        <input id=\"cols\" type=\"number\" min=\"6\" max=\"80\" value=\"16\" style=\"width:64px\">\n        <button id=\"resizeBtn\">Resize</button>\n      </div>\n\n      <button id=\"randomBtn\">Random Walls</button>\n      <button id=\"clearWallsBtn\">Clear Walls</button>\n    </div>\n\n    <div style=\"display:flex;gap:12px;align-items:center;flex-wrap:wrap;\">\n      <div class=\"legend\">\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#8ad2ff\"></div>Visited</div>\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#ffb86b\"></div>Current</div>\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#ffe58a\"></div>Path</div>\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#6ce36c\"></div>Start</div>\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#ff6b6b\"></div>Goal</div>\n        <div class=\"legendItem\"><div class=\"swatch\" style=\"background:#333\"></div>Wall</div>\n      </div>\n      <div class=\"muted\">Click canvas to edit. Use \"Step\" to run one operation at a time.</div>\n    </div>\n    <footer><small>This demo shows both iterative (explicit stack) and recursive DFS exploring a grid. The algorithm backtracks until it finds the goal or exhausts reachable cells.</small></footer>\n  </div>\n\n  <div id=\"right\">\n    <h2>Stack / Call View</h2>\n    <div id=\"stackView\">(stack / recursion frames will appear here during execution)</div>\n\n    <h2>Statistics</h2>\n    <div id=\"stats\">\n      <div>Visited: <span id=\"visitedCount\">0</span></div>\n      <div>Path length: <span id=\"pathLen\">0</span></div>\n      <div>Status: <span id=\"status\">Idle</span></div>\n    </div>\n\n    <h2>Notes</h2>\n    <div class=\"info\">\n      - DFS explores as deep as possible along a branch before backtracking.<br>\n      - Iterative uses an explicit stack; recursive uses the call stack.<br>\n      - Grid neighbors are 4-directional (up/down/left/right).<br>\n      - Walls block movement.\n    </div>\n  </div>\n\n<script>\n// DFS Visualizer - Single File\n(function(){\n  const canvas = document.getElementById('grid');\n  const ctx = canvas.getContext('2d');\n  const rowsInput = document.getElementById('rows');\n  const colsInput = document.getElementById('cols');\n  const resizeBtn = document.getElementById('resizeBtn');\n  const modeSelect = document.getElementById('mode');\n  const algoSelect = document.getElementById('algo');\n  const runBtn = document.getElementById('runBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const speedSlider = document.getElementById('speed');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearWallsBtn = document.getElementById('clearWallsBtn');\n  const stackView = document.getElementById('stackView');\n  const visitedCountEl = document.getElementById('visitedCount');\n  const pathLenEl = document.getElementById('pathLen');\n  const statusEl = document.getElementById('status');\n\n  let rows = parseInt(rowsInput.value,10);\n  let cols = parseInt(colsInput.value,10);\n  let cellSize = 40;\n  const margin = 8;\n\n  function resizeCanvas(){\n    // compute cellSize to fit canvas area\n    const maxW = 640 - margin*2;\n    const maxH = 480 - margin*2;\n    cellSize = Math.min(Math.floor(maxW/cols), Math.floor(maxH/rows));\n    canvas.width = cols*cellSize + margin*2;\n    canvas.height = rows*cellSize + margin*2;\n    draw();\n  }\n\n  rowsInput.addEventListener('change', ()=> rows = Math.max(6, Math.min(60, parseInt(rowsInput.value)||12)), false);\n  colsInput.addEventListener('change', ()=> cols = Math.max(6, Math.min(80, parseInt(colsInput.value)||16)), false);\n  resizeBtn.addEventListener('click', ()=> { initGrid(); resizeCanvas(); });\n\n  // Grid state\n  let grid = [];\n  let start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};\n  let goal = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n  let visited = new Set();\n  let parent = new Map();\n  let running = false;\n  let paused = false;\n  let iterator = null;\n  let highlightCell = null; // current cell in visualization\n  let found = false;\n  let visitedOrder = new Map(); let orderCounter = 0;\n\n  function idx(r,c){ return r + ',' + c; }\n  function inBounds(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }\n\n  function initGrid(random=false){\n    grid = new Array(rows);\n    for(let r=0;r<rows;r++){\n      grid[r] = new Array(cols).fill(0);\n    }\n    // place some random walls if requested\n    if(random){\n      for(let r=0;r<rows;r++){\n        for(let c=0;c<cols;c++){\n          if(Math.random() < 0.28 && !(r===start.r && c===start.c) && !(r===goal.r && c===goal.c)){\n            grid[r][c] = 1;\n          }\n        }\n      }\n    }\n    visited.clear();\n    parent.clear();\n    visitedOrder.clear();\n    orderCounter = 0;\n    highlightCell = null;\n    found = false;\n    running = false;\n    paused = false;\n    iterator = null;\n    updateStats();\n  }\n\n  function draw(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n\n    // draw cells\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        const x = margin + c*cellSize;\n        const y = margin + r*cellSize;\n        // base\n        ctx.fillStyle = \"#fff\";\n        ctx.fillRect(x, y, cellSize-1, cellSize-1);\n        if(grid[r][c] === 1){\n          ctx.fillStyle = \"#333\";\n          ctx.fillRect(x, y, cellSize-1, cellSize-1);\n        }\n        // visited\n        if(visited.has(idx(r,c))){\n          ctx.fillStyle = \"#8ad2ff\";\n          ctx.fillRect(x+1, y+1, cellSize-3, cellSize-3);\n        }\n      }\n    }\n\n    // draw path if found or when parent map exists\n    if(parent.size > 0 && (found || running === false)){\n      let curIdx = idx(goal.r, goal.c);\n      if(parent.has(curIdx) || visited.has(curIdx)){\n        // backtrack from goal to start\n        ctx.fillStyle = \"#ffe58a\";\n        let steps = 0;\n        while(parent.has(curIdx)){\n          const [r,c] = curIdx.split(',').map(Number);\n          const x = margin + c*cellSize;\n          const y = margin + r*cellSize;\n          ctx.fillRect(x+2, y+2, cellSize-5, cellSize-5);\n          curIdx = parent.get(curIdx);\n          steps++;\n          if(curIdx === idx(start.r,start.c)){ // draw start cell path color too\n            const [sr,sc] = curIdx.split(',').map(Number);\n            const xs = margin + sc*cellSize;\n            const ys = margin + sr*cellSize;\n            ctx.fillRect(xs+2, ys+2, cellSize-5, cellSize-5);\n            break;\n          }\n        }\n        pathLenEl.textContent = steps;\n      } else {\n        pathLenEl.textContent = 0;\n      }\n    } else {\n      pathLenEl.textContent = 0;\n    }\n\n    // draw current highlight\n    if(highlightCell){\n      const [r,c] = highlightCell;\n      const x = margin + c*cellSize;\n      const y = margin + r*cellSize;\n      ctx.fillStyle = \"#ffb86b\";\n      ctx.fillRect(x+1, y+1, cellSize-3, cellSize-3);\n    }\n\n    // draw start & goal\n    const sx = margin + start.c*cellSize;\n    const sy = margin + start.r*cellSize;\n    ctx.fillStyle = \"#6ce36c\";\n    ctx.fillRect(sx+2, sy+2, cellSize-5, cellSize-5);\n    const gx = margin + goal.c*cellSize;\n    const gy = margin + goal.r*cellSize;\n    ctx.fillStyle = \"#ff6b6b\";\n    ctx.fillRect(gx+2, gy+2, cellSize-5, cellSize-5);\n\n    // optionally draw numbers for visited order\n    ctx.fillStyle = \"#003\";\n    ctx.font = Math.max(10, cellSize/3) + \"px monospace\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    for(let [key, ord] of visitedOrder.entries()){\n      const [r,c] = key.split(',').map(Number);\n      const x = margin + c*cellSize + cellSize/2 - 1;\n      const y = margin + r*cellSize + cellSize/2 - 1;\n      ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n      ctx.fillText(String(ord), x, y);\n    }\n  }\n\n  canvas.addEventListener('click', (e)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left - margin;\n    const y = e.clientY - rect.top - margin;\n    const c = Math.floor(x / cellSize);\n    const r = Math.floor(y / cellSize);\n    if(!inBounds(r,c)) return;\n    const mode = modeSelect.value;\n    if(mode === 'toggle'){\n      if(!(r===start.r && c===start.c) && !(r===goal.r && c===goal.c)){\n        grid[r][c] = grid[r][c] ? 0 : 1;\n      }\n    } else if(mode === 'start'){\n      if(!(r===goal.r && c===goal.c) && grid[r][c]===0){\n        start = {r,c};\n      }\n    } else if(mode === 'goal'){\n      if(!(r===start.r && c===start.c) && grid[r][c]===0){\n        goal = {r,c};\n      }\n    }\n    draw();\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    initGrid(true);\n    draw();\n  });\n\n  clearWallsBtn.addEventListener('click', ()=>{\n    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) grid[r][c]=0;\n    draw();\n  });\n\n  // Helpers for animation and stepping\n  function sleep(ms){\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  function updateStats(){\n    visitedCountEl.textContent = visited.size;\n    statusEl.textContent = running ? (paused ? 'Paused' : 'Running') : (found ? 'Found' : 'Idle');\n  }\n\n  // DFS generator for iterative step execution\n  function* dfsIterGenerator(){\n    const startKey = idx(start.r,start.c);\n    const goalKey = idx(goal.r,goal.c);\n    const stack = [ startKey ];\n    const visitedLocal = new Set();\n    const parentLocal = new Map();\n    // push initial frame\n    yield {type:'stack', stack:[...stack]};\n    while(stack.length){\n      const cur = stack.pop();\n      yield {type:'stack', stack:[...stack], current:cur};\n      if(visitedLocal.has(cur)) continue;\n      visitedLocal.add(cur);\n      yield {type:'visit', node:cur};\n      if(cur === goalKey){\n        yield {type:'found', node:cur, parent:parentLocal};\n        return;\n      }\n      const [r,c] = cur.split(',').map(Number);\n      // neighbors in a fixed order (to make DFS deterministic)\n      const neighbors = [[r-1,c],[r,c+1],[r+1,c],[r,c-1]]; // up, right, down, left\n      for(let nb of neighbors){\n        const [nr,nc] = nb;\n        if(!inBounds(nr,nc)) continue;\n        if(grid[nr][nc] === 1) continue;\n        const nbKey = idx(nr,nc);\n        if(visitedLocal.has(nbKey)) continue;\n        if(!stack.includes(nbKey)){ // avoid pushing duplicates in stack\n          parentLocal.set(nbKey, cur);\n          stack.push(nbKey);\n          yield {type:'push', node:nbKey, stack:[...stack]};\n        }\n      }\n    }\n    yield {type:'exhausted'};\n  }\n\n  // Recursive DFS with async pauses to show animation\n  async function dfsRecursive(r,c, visitedLocal, parentLocal){\n    const key = idx(r,c);\n    if(paused) { await waitWhilePaused(); }\n    // mark current\n    highlightCell = [r,c];\n    visitedLocal.add(key);\n    visited.add(key);\n    visitedOrder.set(key, ++orderCounter);\n    updateStats();\n    draw();\n    await sleep(speed());\n    if(key === idx(goal.r,goal.c)){\n      parent = new Map(parentLocal);\n      found = true;\n      highlightCell = null;\n      updateStats();\n      draw();\n      return true;\n    }\n    // neighbors: up,right,down,left\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\n    for(let d of dir){\n      const nr = r + d[0], nc = c + d[1];\n      if(!inBounds(nr,nc)) continue;\n      if(grid[nr][nc] === 1) continue;\n      const nkey = idx(nr,nc);\n      if(visitedLocal.has(nkey)) continue;\n      parentLocal.set(nkey, key);\n      // show stack/call view\n      updateStackViewRecursive(parentLocal, nkey);\n      if(paused) { await waitWhilePaused(); }\n      const res = await dfsRecursive(nr,nc, visitedLocal, parentLocal);\n      if(res) return true;\n    }\n\n    // backtracking visualization step\n    highlightCell = [r,c];\n    draw();\n    await sleep(speed()/2);\n    return false;\n  }\n\n  function updateStackViewRecursive(parentLocal, nextKey){\n    // reconstruct call stack approximation: follow parentLocal from nextKey back to start\n    let arr = [];\n    let cur = nextKey;\n    while(cur && parentLocal.has(cur)){\n      arr.push(cur);\n      cur = parentLocal.get(cur);\n      if(arr.length > rows*cols) break;\n    }\n    if(cur) arr.push(cur);\n    stackView.innerText = arr.reverse().join(' -> ');\n  }\n\n  function speed(){\n    // return ms delay\n    return Math.max(5, 1000 - parseInt(speedSlider.value));\n  }\n\n  // wait until unpaused\n  function waitWhilePaused(){\n    return new Promise(resolve=>{\n      const i = setInterval(()=>{\n        if(!paused) {\n          clearInterval(i);\n          resolve();\n        }\n      }, 50);\n    });\n  }\n\n  // control execution\n  runBtn.addEventListener('click', async ()=>{\n    if(running){ return; }\n    // prepare\n    visited.clear();\n    parent.clear();\n    visitedOrder.clear(); orderCounter = 0;\n    highlightCell = null;\n    found = false;\n    running = true;\n    paused = false;\n    iterator = null;\n    stackView.innerText = \"(stack view will update)\";\n    updateStats();\n    draw();\n\n    const algo = algoSelect.value;\n    if(algo === 'iter'){\n      // iterative generator-driven execution with animation\n      iterator = dfsIterGenerator();\n      runBtn.disabled = true;\n      pauseBtn.disabled = false;\n      stepBtn.disabled = true;\n      while(true){\n        if(paused){\n          await waitWhilePaused();\n        }\n        const {value, done} = iterator.next();\n        if(done) break;\n        const ev = value;\n        if(ev.type === 'stack'){\n          // update stack view\n          stackView.innerText = ev.stack.join(' -> ');\n          highlightCell = ev.current ? ev.current.split(',').map(Number) : null;\n          draw();\n          await sleep(speed()/2);\n        } else if(ev.type === 'current'){\n          // not used, but kept\n        } else if(ev.type === 'visit'){\n          visited.add(ev.node);\n          visitedOrder.set(ev.node, ++orderCounter);\n          visitedCountEl.textContent = visited.size;\n          highlightCell = ev.node.split(',').map(Number);\n          draw();\n          await sleep(speed());\n        } else if(ev.type === 'push'){\n          // show push in stack view\n          stackView.innerText = ev.stack.join(' -> ');\n          draw();\n          await sleep(speed()/3);\n        } else if(ev.type === 'found'){\n          parent = new Map(ev.parent);\n          parent.set(ev.node, parent.get(ev.node) || parent.get(ev.node)); // no-op to ensure presence\n          found = true;\n          visited.add(ev.node);\n          visitedOrder.set(ev.node, ++orderCounter);\n          highlightCell = ev.node.split(',').map(Number);\n          draw();\n          break;\n        } else if(ev.type === 'exhausted'){\n          // done, no path\n          break;\n        }\n        updateStats();\n      }\n      running = false;\n      runBtn.disabled = false;\n      pauseBtn.disabled = true;\n      stepBtn.disabled = false;\n      updateStats();\n      draw();\n      // if found, build parent map already provided; ensure pathLen updated\n      if(found){\n        // already set parent\n        // ensure pathLen shown via draw/backtracking\n        draw();\n      } else {\n        stackView.innerText = \"(exhausted - no path found)\";\n      }\n    } else {\n      // recursive DFS\n      pauseBtn.disabled = false;\n      runBtn.disabled = true;\n      stepBtn.disabled = true;\n      const visitedLocal = new Set();\n      const parentLocal = new Map();\n      // start\n      updateStackViewRecursive(parentLocal, idx(start.r,start.c));\n      const res = await dfsRecursive(start.r, start.c, visitedLocal, parentLocal);\n      if(res){\n        parent = new Map(parentLocal);\n        found = true;\n        stackView.innerText = \"(found) \" + Array.from(parent.keys()).slice(0,20).join(', ');\n      } else {\n        stackView.innerText = \"(exhausted - no path found)\";\n      }\n      running = false;\n      paused = false;\n      runBtn.disabled = false;\n      pauseBtn.disabled = true;\n      stepBtn.disabled = false;\n      highlightCell = null;\n      updateStats();\n      draw();\n    }\n  });\n\n  pauseBtn.addEventListener('click', ()=>{\n    if(!running) return;\n    paused = !paused;\n    pauseBtn.textContent = paused ? 'Resume' : 'Pause';\n    updateStats();\n  });\n\n  // Step mode: perform one operation at a time (only works for iterative generator)\n  stepBtn.addEventListener('click', async ()=>{\n    if(running && iterator){ // if running iterative, advance single step\n      // Not used; disabled while running\n      return;\n    }\n    if(!iterator){\n      // initialize iterative generator for stepping only\n      visited.clear();\n      parent.clear();\n      visitedOrder.clear(); orderCounter = 0;\n      highlightCell = null;\n      found = false;\n      iterator = dfsIterGenerator();\n      stackView.innerText = \"(initialized step mode)\";\n      running = false;\n    }\n    const res = iterator.next();\n    if(res.done){\n      stackView.innerText = \"(done)\";\n      iterator = null;\n      return;\n    }\n    const ev = res.value;\n    if(ev.type === 'stack'){\n      stackView.innerText = ev.stack.join(' -> ');\n      highlightCell = ev.current ? ev.current.split(',').map(Number) : null;\n      draw();\n    } else if(ev.type === 'visit'){\n      visited.add(ev.node);\n      visitedOrder.set(ev.node, ++orderCounter);\n      highlightCell = ev.node.split(',').map(Number);\n      draw();\n      updateStats();\n    } else if(ev.type === 'push'){\n      stackView.innerText = ev.stack.join(' -> ');\n      draw();\n    } else if(ev.type === 'found'){\n      parent = new Map(ev.parent);\n      found = true;\n      visited.add(ev.node);\n      visitedOrder.set(ev.node, ++orderCounter);\n      highlightCell = ev.node.split(',').map(Number);\n      draw();\n      stackView.innerText = \"(found goal)\";\n      iterator = null;\n    } else if(ev.type === 'exhausted'){\n      stackView.innerText = \"(exhausted - no path)\";\n      iterator = null;\n    }\n    updateStats();\n  });\n\n  // Reset states but keep walls & size\n  document.getElementById('resetBtn').addEventListener('click', ()=>{\n    visited.clear();\n    parent.clear();\n    visitedOrder.clear(); orderCounter = 0;\n    highlightCell = null;\n    found = false;\n    running = false;\n    paused = false;\n    iterator = null;\n    stackView.innerText = \"(stack / recursion frames will appear here during execution)\";\n    updateStats();\n    draw();\n  });\n\n  // Initialize\n  function randomStartGoal(){\n    start = {r: Math.floor(rows/2), c: Math.max(0,Math.floor(cols/4))};\n    goal = {r: Math.floor(rows/2), c: Math.min(cols-1,Math.floor(cols*3/4))};\n  }\n\n  initGrid(false);\n  randomStartGoal();\n  resizeCanvas();\n\n  // handle window resize for nicer display\n  window.addEventListener('resize', ()=> {\n    // nothing needed; fixed canvas size here\n  });\n\n  // add keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      if(running) {\n        paused = !paused;\n        pauseBtn.textContent = paused ? 'Resume' : 'Pause';\n      } else {\n        runBtn.click();\n      }\n    }\n    if(e.key === 's'){\n      stepBtn.click();\n    }\n  });\n\n  // initial draw\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}