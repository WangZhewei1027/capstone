{
  "id": "98e19390-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:42.594Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Adjacency Matrix Interactive Demo</title>\n<style>\n  html,body {height:100%; margin:0; font-family: Arial, sans-serif; background:#f7f9fb; color:#111;}\n  .container {display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box;}\n  .left, .right {background:#fff; border:1px solid #e1e6ea; border-radius:8px; padding:12px; box-sizing:border-box;}\n  .left {flex:1; display:flex; flex-direction:column; min-width:480px;}\n  .canvas-wrap {flex:1; border:1px dashed #d7dee6; border-radius:6px; background:linear-gradient(180deg,#fff,#fbfdff); position:relative; overflow:hidden;}\n  canvas {width:100%; height:100%;}\n  .toolbar {display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}\n  button, input[type=\"checkbox\"], label {font-size:13px;}\n  button {background:#1f77b4;color:#fff;border:none;padding:8px 10px;border-radius:6px;cursor:pointer;}\n  button.secondary {background:#f0f4f7;color:#0b2533;border:1px solid #d6e1ea;}\n  button.danger {background:#e74c3c;}\n  .right {width:420px; display:flex; flex-direction:column; gap:8px;}\n  .panel {background:#fff; border-radius:6px; padding:8px; border:1px solid #eef3f6;}\n  table {border-collapse:collapse; width:100%; overflow:auto;}\n  td,th {border:1px solid #e2e8ee; padding:6px 8px; text-align:center; font-size:13px;}\n  th {background:#f3f7fb; font-weight:600;}\n  .instructions {font-size:13px; color:#445;}\n  .small {font-size:12px; color:#556; margin-top:6px;}\n  .node-label-input {width:60px;}\n  .matrix-scroll {max-height:320px; overflow:auto; border-radius:4px;}\n  .footer {font-size:12px; color:#556; text-align:center; margin-top:6px;}\n  .hint {font-size:12px; color:#666;}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"left\">\n    <div class=\"toolbar\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button class=\"secondary\" id=\"clearBtn\">Clear Graph</button>\n      <button class=\"secondary\" id=\"exportBtn\">Export CSV</button>\n      <button class=\"secondary\" id=\"importBtn\">Import CSV</button>\n      <label style=\"display:flex;align-items:center;gap:6px;margin-left:auto;\">\n        <input type=\"checkbox\" id=\"directedChk\"> Directed\n      </label>\n      <label style=\"display:flex;align-items:center;gap:6px;\">\n        <input type=\"checkbox\" id=\"weightedChk\"> Weighted\n      </label>\n      <label style=\"display:flex;align-items:center;gap:6px;\">\n        <input type=\"checkbox\" id=\"allowLoopsChk\"> Allow loops\n      </label>\n    </div>\n\n    <div class=\"canvas-wrap\" id=\"canvasWrap\">\n      <canvas id=\"graphCanvas\"></canvas>\n      <div style=\"position:absolute;left:8px;bottom:8px;background:rgba(255,255,255,0.9);padding:6px;border-radius:6px;border:1px solid rgba(0,0,0,0.04);font-size:12px;\">\n        Click empty space to add node • Click node then node to toggle edge • Drag to move\n      </div>\n    </div>\n    <div class=\"footer\">Nodes: <span id=\"nodeCount\">0</span> — Edges: <span id=\"edgeCount\">0</span></div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"panel\">\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <strong>Adjacency Matrix</strong>\n        <span class=\"hint\" style=\"margin-left:auto;\">Unweighted: entries 0/1 — Weighted: numeric</span>\n      </div>\n      <div class=\"matrix-scroll\" id=\"matrixScroll\" style=\"margin-top:8px;\">\n        <table id=\"matrixTable\"><!-- filled by JS --></table>\n      </div>\n      <div style=\"display:flex;gap:8px;margin-top:8px;\">\n        <button id=\"copyBtn\" class=\"secondary\">Copy CSV</button>\n        <button id=\"downloadBtn\" class=\"secondary\">Download CSV</button>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Controls & Tips</strong>\n      <div class=\"small\">\n        - Add nodes by button or click canvas. <br>\n        - Click a node then another to create or remove an edge. When weighted mode is on you'll be prompted for a weight.<br>\n        - Right-click a node to delete it.<br>\n        - Toggle Directed to switch between directed and undirected graphs. In undirected graphs edges are symmetric.<br>\n        - Import a CSV adjacency matrix (square). Rows/cols can have an optional header line with labels.\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Selected Node</strong>\n      <div style=\"display:flex;gap:8px;align-items:center;margin-top:8px;\">\n        <label>Label: <input id=\"selectedLabel\" class=\"node-label-input\" /></label>\n        <button id=\"renameBtn\" class=\"secondary\">Rename</button>\n        <button id=\"deleteNodeBtn\" class=\"danger\">Delete</button>\n      </div>\n      <div class=\"small\" style=\"margin-top:8px;\">Click a node on the canvas to select it. Selection persists until you click empty space.</div>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Canvas and graph state\n  const canvas = document.getElementById('graphCanvas');\n  const wrap = document.getElementById('canvasWrap');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n\n  function resizeCanvas(){\n    const rect = wrap.getBoundingClientRect();\n    canvas.width = Math.floor(rect.width * DPR);\n    canvas.height = Math.floor(rect.height * DPR);\n    canvas.style.width = rect.width + 'px';\n    canvas.style.height = rect.height + 'px';\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    render();\n  }\n  window.addEventListener('resize', resizeCanvas);\n  resizeCanvas();\n\n  let nodes = []; // {id,label,x,y}\n  let adj = [];   // adjacency matrix: numbers (0 means no edge)\n  let nextId = 0;\n  const NODE_RADIUS = 20;\n  const ARROW_SIZE = 10;\n\n  // UI Elements\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const exportBtn = document.getElementById('exportBtn');\n  const importBtn = document.getElementById('importBtn');\n  const directedChk = document.getElementById('directedChk');\n  const weightedChk = document.getElementById('weightedChk');\n  const allowLoopsChk = document.getElementById('allowLoopsChk');\n  const matrixTable = document.getElementById('matrixTable');\n  const nodeCountSpan = document.getElementById('nodeCount');\n  const edgeCountSpan = document.getElementById('edgeCount');\n  const copyBtn = document.getElementById('copyBtn');\n  const downloadBtn = document.getElementById('downloadBtn');\n  const selectedLabelInput = document.getElementById('selectedLabel');\n  const renameBtn = document.getElementById('renameBtn');\n  const deleteNodeBtn = document.getElementById('deleteNodeBtn');\n\n  // Selection & interactions\n  let selectedNodeId = null;\n  let clickFromNode = null;\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n\n  // Helper functions\n  function addNode(x,y,label){\n    label = label || String.fromCharCode(65 + (nextId % 26)) + (Math.floor(nextId/26) || '');\n    const node = {id: nextId++, label, x, y};\n    nodes.push(node);\n    adj.forEach(row => row.push(0));\n    adj.push(Array(nodes.length).fill(0));\n    render();\n    updateUI();\n    return node;\n  }\n\n  function removeNodeById(id){\n    const idx = nodes.findIndex(n => n.id === id);\n    if(idx === -1) return;\n    nodes.splice(idx,1);\n    adj.splice(idx,1);\n    adj.forEach(row => row.splice(idx,1));\n    selectedNodeId = null;\n    clickFromNode = null;\n    render();\n    updateUI();\n  }\n\n  function toggleEdge(i,j){\n    if(i<0 || j<0 || i>=nodes.length || j>=nodes.length) return;\n    if(i===j && !allowLoopsChk.checked) return;\n    if(weightedChk.checked){\n      let current = adj[i][j];\n      let promptVal = prompt(\"Enter weight (leave empty to cancel). Current: \" + (current || 0), current || \"\");\n      if(promptVal === null) return;\n      const w = parseFloat(promptVal);\n      if(isNaN(w)) { alert(\"Invalid number\"); return; }\n      adj[i][j] = w;\n      if(!directedChk.checked) adj[j][i] = w;\n    } else {\n      if(adj[i][j]) {\n        adj[i][j] = 0;\n        if(!directedChk.checked) adj[j][i] = 0;\n      } else {\n        adj[i][j] = 1;\n        if(!directedChk.checked) adj[j][i] = 1;\n      }\n    }\n    render();\n    updateUI();\n  }\n\n  function setEdge(i,j,val){\n    adj[i][j] = val;\n    if(!directedChk.checked) adj[j][i] = val;\n  }\n\n  function nodeAtPos(px,py){\n    for(let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      const dx = n.x - px;\n      const dy = n.y - py;\n      if(Math.hypot(dx,dy) <= NODE_RADIUS + 4) return n;\n    }\n    return null;\n  }\n\n  function countEdges(){\n    let c = 0;\n    for(let i=0;i<nodes.length;i++){\n      for(let j=0;j<nodes.length;j++){\n        if(adj[i][j] && adj[i][j] !== 0) c++;\n      }\n    }\n    if(!directedChk.checked) c = Math.floor(c/2);\n    return c;\n  }\n\n  // Drawing functions\n  function render(){\n    ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);\n    // edges\n    for(let i=0;i<nodes.length;i++){\n      for(let j=0;j<nodes.length;j++){\n        if(!adj[i] || !adj[i][j]) continue;\n        if(!directedChk.checked && j < i) continue; // draw undirected once\n        drawEdge(nodes[i], nodes[j], adj[i][j], directedChk.checked);\n      }\n    }\n    // nodes\n    for(const n of nodes) drawNode(n, n.id === selectedNodeId);\n  }\n\n  function drawNode(n, selected){\n    ctx.beginPath();\n    ctx.fillStyle = selected ? '#fffbdb' : '#ffffff';\n    ctx.strokeStyle = selected ? '#f1b24a' : '#3a5666';\n    ctx.lineWidth = selected ? 2.5 : 1.5;\n    ctx.fillRect(n.x-NODE_RADIUS-2, n.y-NODE_RADIUS-2, NODE_RADIUS*2+4, NODE_RADIUS*2+4); // subtle box for crispness\n    ctx.beginPath();\n    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);\n    ctx.fillStyle = selected ? '#ffeaa6' : '#e9f2f7';\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = '#062a36';\n    ctx.font = 'bold 13px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.label, n.x, n.y);\n  }\n\n  function drawEdge(a,b,value,directed){\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const angle = Math.atan2(dy,dx);\n    const dist = Math.hypot(dx,dy);\n    const fromX = a.x + Math.cos(angle) * (NODE_RADIUS + 2);\n    const fromY = a.y + Math.sin(angle) * (NODE_RADIUS + 2);\n    const toX = b.x - Math.cos(angle) * (NODE_RADIUS + 2);\n    const toY = b.y - Math.sin(angle) * (NODE_RADIUS + 2);\n\n    ctx.beginPath();\n    ctx.strokeStyle = '#2b6f8f';\n    ctx.lineWidth = 2;\n    ctx.moveTo(fromX, fromY);\n\n    if(a === b){\n      // self-loop: draw a small loop\n      const loopRadius = 24;\n      ctx.arc(a.x, a.y - NODE_RADIUS - loopRadius/2, loopRadius, 0.3, 2.6);\n      ctx.stroke();\n      // weight near loop\n      if(weightedChk.checked) {\n        ctx.fillStyle = '#124';\n        ctx.font = '12px Arial';\n        ctx.fillText(String(value), a.x + loopRadius, a.y - NODE_RADIUS - loopRadius/2);\n      } else {\n        // nothing\n      }\n      if(directed){\n        // arrowhead at end of loop (approx)\n        drawArrowHead(a.x + loopRadius * Math.cos(2.6), a.y - NODE_RADIUS - loopRadius/2 + loopRadius * Math.sin(2.6), angle + Math.PI/2);\n      }\n      return;\n    }\n\n    // For parallel edges (bidirectional in directed graphs) we offset slightly.\n    let offset = 0;\n    if(directed && adj[indexOfNode(b.id)][indexOfNode(a.id)]) {\n      // If opposite direction exists we offset perpendicular\n      offset = 10;\n      // Determine sign to make curves distinguishable\n      const sign = (indexOfNode(a.id) < indexOfNode(b.id)) ? 1 : -1;\n      offset *= sign;\n    }\n\n    if(offset === 0){\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n    } else {\n      // Quadratic curve with small perpendicular offset\n      const mx = (fromX + toX)/2;\n      const my = (fromY + toY)/2;\n      const perpAngle = angle + Math.PI/2;\n      const cx = mx + Math.cos(perpAngle) * offset;\n      const cy = my + Math.sin(perpAngle) * offset;\n      ctx.quadraticCurveTo(cx, cy, toX, toY);\n      ctx.stroke();\n    }\n\n    // arrowhead for directed\n    if(directed){\n      drawArrowHead(toX, toY, angle);\n    }\n\n    // draw weight or marker at midpoint\n    const midX = (fromX + toX)/2;\n    const midY = (fromY + toY)/2;\n    if(offset !== 0){\n      const mx = (fromX + toX)/2;\n      const my = (fromY + toY)/2;\n      const perpAngle = angle + Math.PI/2;\n      const cx = mx + Math.cos(perpAngle) * offset;\n      const cy = my + Math.sin(perpAngle) * offset;\n      ctx.fillStyle = '#06323f';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(weightedChk.checked ? String(value) : String(1), cx, cy - 6);\n    } else {\n      ctx.fillStyle = '#06323f';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(weightedChk.checked ? String(value) : String(1), midX, midY - 6);\n    }\n  }\n\n  function drawArrowHead(x,y,angle){\n    ctx.save();\n    ctx.translate(x,y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0,0);\n    ctx.lineTo(-ARROW_SIZE, ARROW_SIZE/2);\n    ctx.lineTo(-ARROW_SIZE, -ARROW_SIZE/2);\n    ctx.closePath();\n    ctx.fillStyle = '#2b6f8f';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Indexing helpers\n  function indexOfNode(id){ return nodes.findIndex(n=>n.id===id); }\n\n  // UI updates\n  function updateUI(){\n    nodeCountSpan.textContent = nodes.length;\n    edgeCountSpan.textContent = countEdges();\n\n    // matrix table\n    while(matrixTable.firstChild) matrixTable.removeChild(matrixTable.firstChild);\n    const n = nodes.length;\n    const header = document.createElement('tr');\n    const corner = document.createElement('th'); corner.textContent = ''; header.appendChild(corner);\n    nodes.forEach(nd => {\n      const th = document.createElement('th'); th.textContent = nd.label; header.appendChild(th);\n    });\n    matrixTable.appendChild(header);\n\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const rowLabel = document.createElement('th'); rowLabel.textContent = nodes[i].label; tr.appendChild(rowLabel);\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        td.textContent = adj[i] && adj[i][j] ? String(adj[i][j]) : '0';\n        td.style.cursor = 'pointer';\n        td.title = 'Click to toggle/edit';\n        (function(ii,jj,cell){\n          cell.addEventListener('click', e=>{\n            // toggle using the same behavior as clicking nodes\n            if(weightedChk.checked){\n              let cur = adj[ii][jj] || 0;\n              let v = prompt(\"Enter numeric weight (empty to cancel). Current: \" + cur, cur === 0 ? \"\" : cur);\n              if(v === null) return;\n              const w = parseFloat(v);\n              if(isNaN(w)){ alert('Invalid number'); return; }\n              setEdge(ii,jj,w);\n            } else {\n              toggleEdge(ii,jj);\n            }\n            updateUI();\n            render();\n          });\n        })(i,j,td);\n        tr.appendChild(td);\n      }\n      matrixTable.appendChild(tr);\n    }\n\n    // selected info\n    const sel = nodes.find(n=>n.id===selectedNodeId);\n    selectedLabelInput.value = sel ? sel.label : '';\n    selectedLabelInput.disabled = !sel;\n    renameBtn.disabled = !sel;\n    deleteNodeBtn.disabled = !sel;\n  }\n\n  // Event handlers\n  wrap.addEventListener('pointerdown', e=>{\n    e.preventDefault();\n    const rect = wrap.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    const node = nodeAtPos(x,y);\n    if(e.button === 2){\n      // right click: delete node if on node\n      if(node){\n        if(confirm('Delete node \"'+node.label+'\"?')) removeNodeById(node.id);\n      }\n      return;\n    }\n\n    if(node){\n      // select node, begin drag\n      selectedNodeId = node.id;\n      clickFromNode = node;\n      dragging = node;\n      dragOffset.x = x - node.x;\n      dragOffset.y = y - node.y;\n    } else {\n      // clicking empty space: add node\n      selectedNodeId = null;\n      clickFromNode = null;\n      addNode(x, y);\n    }\n    updateUI();\n    render();\n  });\n\n  wrap.addEventListener('pointermove', e=>{\n    if(!dragging) return;\n    const rect = wrap.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    dragging.x = x - dragOffset.x;\n    dragging.y = y - dragOffset.y;\n    render();\n  });\n\n  wrap.addEventListener('pointerup', e=>{\n    if(dragging){\n      dragging = null;\n      return;\n    }\n    const rect = wrap.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    const node = nodeAtPos(x,y);\n    if(clickFromNode && node){\n      // create or toggle edge from clickFromNode to node\n      const i = indexOfNode(clickFromNode.id);\n      const j = indexOfNode(node.id);\n      if(i === -1 || j === -1) { clickFromNode = null; return; }\n      if(i === j && !allowLoopsChk.checked){\n        // do nothing\n      } else {\n        toggleEdge(i,j);\n      }\n    }\n    clickFromNode = null;\n  });\n\n  // disable context menu on canvas to allow right-click deletion\n  wrap.addEventListener('contextmenu', e=>e.preventDefault());\n\n  // Buttons & toggles\n  addNodeBtn.addEventListener('click', ()=>{\n    const rect = wrap.getBoundingClientRect();\n    const x = rect.width/2;\n    const y = rect.height/2;\n    addNode(x,y);\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    if(!confirm('Clear entire graph?')) return;\n    nodes = []; adj = []; nextId = 0; selectedNodeId = null; clickFromNode = null;\n    render(); updateUI();\n  });\n\n  directedChk.addEventListener('change', ()=>{\n    // when switching to undirected, symmetrize\n    if(!directedChk.checked){\n      for(let i=0;i<nodes.length;i++){\n        for(let j=0;j<nodes.length;j++){\n          if(adj[i][j] && !adj[j][i]) adj[j][i] = adj[i][j];\n          if(adj[j][i] && !adj[i][j]) adj[i][j] = adj[j][i];\n        }\n      }\n    }\n    render(); updateUI();\n  });\n\n  weightedChk.addEventListener('change', ()=>{\n    // if turning off weights, make all nonzero entries 1\n    if(!weightedChk.checked){\n      for(let i=0;i<nodes.length;i++) for(let j=0;j<nodes.length;j++) adj[i][j] = adj[i][j] ? 1 : 0;\n    }\n    render(); updateUI();\n  });\n\n  allowLoopsChk.addEventListener('change', ()=>{ render(); updateUI(); });\n\n  // matrix copy / export / import\n  function adjacencyToCSV(includeLabels=true){\n    const n = nodes.length;\n    let rows = [];\n    if(includeLabels){\n      const header = [''].concat(nodes.map(n=>n.label)).join(',');\n      rows.push(header);\n    }\n    for(let i=0;i<n;i++){\n      const row = [nodes[i].label].concat(adj[i].map(v => v === 0 ? 0 : v)).join(',');\n      rows.push(row);\n    }\n    return rows.join('\\n');\n  }\n\n  copyBtn.addEventListener('click', async ()=>{\n    const csv = adjacencyToCSV(true);\n    try{\n      await navigator.clipboard.writeText(csv);\n      alert('CSV copied to clipboard.');\n    }catch(e){\n      prompt('Copy this CSV:', csv);\n    }\n  });\n\n  downloadBtn.addEventListener('click', ()=>{\n    const csv = adjacencyToCSV(true);\n    const blob = new Blob([csv], {type:'text/csv'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url; a.download = 'adjacency_matrix.csv';\n    document.body.appendChild(a); a.click(); a.remove();\n    URL.revokeObjectURL(url);\n  });\n\n  exportBtn.addEventListener('click', ()=>{\n    const csv = adjacencyToCSV(true);\n    alert('CSV export:\\n\\n' + csv.slice(0,800) + (csv.length>800 ? '\\n\\n...truncated' : ''));\n  });\n\n  importBtn.addEventListener('click', ()=>{\n    const text = prompt('Paste CSV adjacency matrix. Can include header row of labels (optional).');\n    if(!text) return;\n    try{\n      const rows = text.trim().split(/\\r?\\n/).map(r => r.trim()).filter(r=>r.length>0);\n      if(rows.length === 0) throw new Error('No data');\n      const parsed = rows.map(r => r.split(',').map(s => s.trim()));\n      let hasHeader = parsed[0].length === parsed.length+1 || parsed[0][0] === '';\n      // Determine header existence: if first row has non-numeric in first col or length mismatch\n      if(parsed[0].length === parsed.length + 1) hasHeader = true;\n      if(parsed[0][0] === '') hasHeader = true;\n      // Also check second row's first cell; if it's non-numeric, treat as label\n      if(!hasHeader){\n        // detect if first column of second row is non-numeric\n        if(parsed[1] && isNaN(parseFloat(parsed[1][0]))) hasHeader = true;\n      }\n      let labels = [];\n      let matrix = [];\n      if(hasHeader){\n        labels = parsed[0].slice(1);\n        for(let i=1;i<parsed.length;i++){\n          const row = parsed[i].slice(1).map(v => parseFloat(v || 0));\n          matrix.push(row);\n        }\n      } else {\n        // no header: expect square matrix\n        for(let i=0;i<parsed.length;i++){\n          const row = parsed[i].map(v=>parseFloat(v || 0));\n          matrix.push(row);\n        }\n        labels = matrix.map((_,i)=>String.fromCharCode(65 + (i%26)) + (Math.floor(i/26) || ''));\n      }\n      // Validate square\n      const n = matrix.length;\n      if(matrix.some(r => r.length !== n)) throw new Error('Matrix is not square');\n      // Build graph\n      nodes = [];\n      adj = [];\n      nextId = 0;\n      // place nodes in a circle\n      const rect = wrap.getBoundingClientRect();\n      const cx = rect.width/2, cy = rect.height/2;\n      const R = Math.min(rect.width, rect.height)/2 - 60;\n      for(let i=0;i<n;i++){\n        const ang = (i / n) * Math.PI * 2;\n        const x = cx + Math.cos(ang) * R;\n        const y = cy + Math.sin(ang) * R;\n        addNode(x,y, labels[i] || ('N'+i));\n      }\n      // set adjacency\n      for(let i=0;i<n;i++){\n        for(let j=0;j<n;j++){\n          adj[i][j] = matrix[i][j] || 0;\n        }\n      }\n      // If any entries are non-integer or not 0/1 enable weighted\n      const anyNonBinary = adj.some(row => row.some(v => v !== 0 && v !== 1));\n      weightedChk.checked = anyNonBinary;\n      directedChk.checked = true; // keep as directed unless symmetric\n      // if symmetric, set undirected\n      let symmetric = true;\n      for(let i=0;i<n;i++) for(let j=0;j<n;j++) if(adj[i][j] !== adj[j][i]) symmetric = false;\n      if(symmetric) directedChk.checked = false;\n      render(); updateUI();\n    }catch(err){\n      alert('Failed to import CSV: ' + err.message);\n    }\n  });\n\n  // selection rename & delete\n  renameBtn.addEventListener('click', ()=>{\n    const sel = nodes.find(n=>n.id === selectedNodeId);\n    if(!sel) return;\n    const v = selectedLabelInput.value.trim();\n    if(!v) { alert('Label cannot be empty'); return; }\n    sel.label = v;\n    render(); updateUI();\n  });\n  deleteNodeBtn.addEventListener('click', ()=>{\n    if(!selectedNodeId) return;\n    if(confirm('Delete selected node?')) removeNodeById(selectedNodeId);\n  });\n\n  // click on table cell will also be handled above\n  // initial demo graph\n  (function seedDemo(){\n    const rect = wrap.getBoundingClientRect();\n    addNode(rect.width*0.25, rect.height*0.35, 'A');\n    addNode(rect.width*0.5, rect.height*0.2, 'B');\n    addNode(rect.width*0.75, rect.height*0.35, 'C');\n    addNode(rect.width*0.35, rect.height*0.7, 'D');\n    addNode(rect.width*0.65, rect.height*0.7, 'E');\n    // simple undirected edges\n    setEdge(0,1,1);\n    setEdge(1,2,1);\n    setEdge(0,3,1);\n    setEdge(3,4,1);\n    setEdge(4,2,1);\n    // one directed example\n    directedChk.checked = false;\n    render(); updateUI();\n  })();\n\n  // Keep canvas pixel-perfect\n  const resizeObserver = new ResizeObserver(resizeCanvas);\n  resizeObserver.observe(wrap);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}