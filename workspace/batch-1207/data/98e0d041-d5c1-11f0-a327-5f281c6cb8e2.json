{
  "id": "98e0d041-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:44.799Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Hash Table Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#4fd1c5;\n      --muted:#94a3b8;\n      --good:#16a34a;\n      --bad:#ef4444;\n      --slot:#071226;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial}\n    body{background:linear-gradient(180deg,#071024 0%, #071833 60%);color:#e6eef8;padding:18px;box-sizing:border-box}\n    .wrap{max-width:1100px;margin:0 auto;}\n    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:18px}\n    h1{font-size:20px;margin:0;color:var(--accent)}\n    .desc{color:var(--muted);font-size:13px}\n    .controls{display:flex;flex-wrap:wrap;gap:10px;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px}\n    label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}\n    input[type=\"text\"],select{background:#021524;border:1px solid rgba(255,255,255,0.04);color:#dbeafe;padding:8px;border-radius:6px;min-width:200px}\n    input[type=\"range\"]{width:180px}\n    button{background:linear-gradient(180deg,#0ea5a4,#0a7f7e);border:none;padding:8px 12px;color:#022;border-radius:8px;cursor:pointer;font-weight:600}\n    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}\n    main{display:flex;gap:16px;margin-top:14px}\n    .left{flex:0 0 420px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:10px}\n    .right{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:10px;min-height:320px}\n    .table-visual{display:flex;flex-wrap:wrap;gap:8px;padding:8px}\n    .bucket{background:var(--slot);border-radius:8px;padding:8px;min-width:80px;min-height:56px;color:#bfeedd;border:1px solid rgba(255,255,255,0.03);position:relative}\n    .bucket h3{margin:0;font-size:12px;color:var(--muted);font-weight:700}\n    .chain{margin-top:8px;display:flex;flex-direction:column;gap:6px}\n    .node{background:linear-gradient(180deg,#0b2b3a,#07202a);padding:6px;border-radius:6px;color:#dff3f0;font-weight:700;border:1px solid rgba(255,255,255,0.02);display:flex;align-items:center;gap:6px;justify-content:space-between}\n    .index-badge{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.02);padding:4px 6px;border-radius:6px;font-size:12px;color:var(--muted)}\n    .array-slot{width:110px;height:64px;background:var(--slot);border-radius:8px;display:flex;flex-direction:column;justify-content:center;align-items:center;border:1px solid rgba(255,255,255,0.03);position:relative}\n    .slot-key{font-weight:800;color:#dbeafe}\n    .slot-val{font-size:12px;color:var(--muted)}\n    .slot.empty{opacity:0.45}\n    .slot.deleted{opacity:0.5;color:var(--muted);border-style:dashed}\n    .status{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px;min-height:42px}\n    .controls-row{display:flex;gap:8px;flex-wrap:wrap}\n    footer{margin-top:12px;color:var(--muted);font-size:13px}\n    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n    .legend .item{display:flex;align-items:center;gap:8px}\n    .swatch{width:14px;height:14px;border-radius:4px}\n    .sw-ok{background:var(--good)}\n    .sw-empty{background:transparent;border:1px solid rgba(255,255,255,0.04)}\n    .sw-del{background:transparent;border:2px dashed rgba(255,255,255,0.06)}\n    .explain{font-size:13px;color:var(--muted);line-height:1.4;margin-top:12px}\n    .hashbar{display:flex;gap:8px;align-items:center;margin-top:8px}\n    .pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;font-weight:700;color:var(--muted);font-size:13px}\n    .highlight{outline:3px solid rgba(79,209,197,0.14);box-shadow:0 6px 18px rgba(11,30,40,0.6)}\n    .small{font-size:12px}\n    code{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;color:#c1e8e3;font-family:monospace;font-size:12px}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <div>\n        <h1>Interactive Hash Table Demo</h1>\n        <div class=\"desc\">Explore hashing with separate chaining and open addressing (linear/quadratic). Insert, search, delete and watch collisions/probes.</div>\n      </div>\n      <div style=\"text-align:right\">\n        <div class=\"small\" style=\"color:var(--muted)\">Simple polynomial hash for strings, modulo table size.</div>\n      </div>\n    </header>\n\n    <div class=\"controls\">\n      <label>\n        Table size: <span id=\"sizeLabel\">11</span>\n        <input id=\"sizeRange\" type=\"range\" min=\"5\" max=\"41\" step=\"1\" value=\"11\">\n      </label>\n\n      <label>\n        Collision strategy:\n        <select id=\"strategy\">\n          <option value=\"chaining\">Separate Chaining</option>\n          <option value=\"linear\">Open Addressing — Linear Probing</option>\n          <option value=\"quadratic\">Open Addressing — Quadratic Probing</option>\n        </select>\n      </label>\n\n      <label>\n        Key (string or number)\n        <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. apple or 42\">\n      </label>\n\n      <label>\n        Value (optional)\n        <input id=\"valueInput\" type=\"text\" placeholder=\"any data\">\n      </label>\n\n      <div style=\"display:flex;align-items:center;gap:8px\">\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"searchBtn\" class=\"secondary\">Search</button>\n        <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n      </div>\n\n      <div style=\"display:flex;align-items:center;gap:8px;margin-left:auto\">\n        <button id=\"fillBtn\" class=\"secondary\">Fill Randomly</button>\n        <button id=\"clearBtn\" class=\"secondary\">Reset</button>\n      </div>\n    </div>\n\n    <main>\n      <div class=\"left\">\n        <div class=\"hashbar\">\n          <div class=\"pill\">Hash function: h(k) = (Σ charCode * p^i) mod M</div>\n          <div class=\"pill\" id=\"hashOutput\">Index: —</div>\n        </div>\n\n        <div class=\"explain\">\n          This demo uses a simple polynomial rolling hash for strings (p=31). Numbers are used directly (mod table size). Collisions are handled using the selected strategy. Open addressing supports linear and quadratic probing.\n          <div style=\"margin-top:8px\">\n            Example: Insert \"cat\" — compute numeric hash → index = hash % M. If occupied, probes continue.\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\">\n          <div style=\"display:flex;gap:8px;align-items:center\">\n            <button id=\"stepToggle\" class=\"secondary\">Step Mode: Off</button>\n            <label style=\"font-size:13px;color:var(--muted);margin-left:6px\">If on, each probe shows a highlight you advance manually.</label>\n          </div>\n          <div class=\"legend\">\n            <div class=\"item\"><div class=\"swatch sw-ok\"></div><div class=\"small\">Occupied</div></div>\n            <div class=\"item\"><div class=\"swatch sw-empty\" style=\"border:1px solid rgba(255,255,255,0.04)\"></div><div class=\"small\">Empty</div></div>\n            <div class=\"item\"><div class=\"swatch sw-del\" style=\"border-color:rgba(255,255,255,0.06)\"></div><div class=\"small\">Deleted (tombstone)</div></div>\n          </div>\n        </div>\n\n        <div class=\"status\" id=\"status\">Ready.</div>\n      </div>\n\n      <div class=\"right\">\n        <div id=\"visualArea\" class=\"table-visual\" aria-live=\"polite\"></div>\n        <div style=\"margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center\">\n          <button id=\"prevStep\" class=\"secondary\">◀ Prev Probe</button>\n          <button id=\"nextStep\" class=\"secondary\">Next Probe ▶</button>\n          <div style=\"margin-left:auto;color:var(--muted);font-size:13px\">\n            Probes: <span id=\"probeCount\">0</span>\n          </div>\n        </div>\n\n        <footer>\n          Quick hints: Try inserting keys that collide (e.g., \"a\", \"k\", \"u\" in a small table) to observe chaining vs probing. Deleted slots in open addressing are marked as tombstones.\n        </footer>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    // Hash Table demo script\n    (function(){\n      // Utilities\n      function isNumberString(s){\n        return /^-?\\d+(\\.\\d+)?$/.test(s);\n      }\n\n      function makeKey(k){\n        // store keys as strings internally to keep consistent behavior\n        return String(k);\n      }\n\n      // Simple polynomial rolling hash for strings\n      function stringHash(s, M){\n        let hash = 0;\n        const p = 31;\n        let pow = 1;\n        for (let i = 0; i < s.length; i++){\n          const code = s.charCodeAt(i);\n          hash = (hash + (code + 1) * pow) % M;\n          pow = (pow * p) % M;\n        }\n        return hash;\n      }\n\n      function computeHash(key, M){\n        if (isNumberString(key)) {\n          // numeric-like: use numeric value\n          let n = Number(key);\n          // handle negative numbers\n          n = Math.floor(Math.abs(n));\n          return n % M;\n        } else {\n          return stringHash(String(key), M);\n        }\n      }\n\n      // Data structures\n      class HashTableChaining {\n        constructor(M){\n          this.M = M;\n          this.buckets = Array.from({length:M}, ()=>[]);\n        }\n        insert(key, value){\n          const k = makeKey(key);\n          const idx = computeHash(k, this.M);\n          const bucket = this.buckets[idx];\n          // if key exists, update\n          for (let node of bucket){\n            if (node.key === k){\n              node.value = value;\n              return {index:idx, updated:true};\n            }\n          }\n          bucket.push({key:k, value:value});\n          return {index:idx, updated:false};\n        }\n        search(key){\n          const k = makeKey(key);\n          const idx = computeHash(k, this.M);\n          const bucket = this.buckets[idx];\n          for (let i=0;i<bucket.length;i++){\n            if (bucket[i].key === k) return {found:true,index:idx,chainIndex:i,node:bucket[i]};\n          }\n          return {found:false,index:idx};\n        }\n        delete(key){\n          const k = makeKey(key);\n          const idx = computeHash(k, this.M);\n          const bucket = this.buckets[idx];\n          for (let i=0;i<bucket.length;i++){\n            if (bucket[i].key === k){\n              const removed = bucket.splice(i,1)[0];\n              return {removed:true,index:idx,removedNode:removed};\n            }\n          }\n          return {removed:false,index:idx};\n        }\n        clear(){\n          this.buckets = Array.from({length:this.M}, ()=>[]);\n        }\n      }\n\n      class HashTableOpen {\n        constructor(M, probeStrategy='linear'){\n          this.M = M;\n          this.probeStrategy = probeStrategy; // 'linear' or 'quadratic'\n          this.slots = Array.from({length:M}, ()=>({state:'empty', key:null, value:null}));\n        }\n        _probeSequence(hash){\n          const M = this.M;\n          if (this.probeStrategy === 'linear'){\n            return function*(key){\n              for (let i=0;i<M;i++){\n                yield (hash + i) % M;\n              }\n            };\n          } else {\n            // quadratic probing: (hash + i^2) % M\n            return function*(key){\n              for (let i=0;i<M;i++){\n                yield (hash + i*i) % M;\n              }\n            };\n          }\n        }\n        insert(key, value){\n          const k = makeKey(key);\n          const hash = computeHash(k, this.M);\n          const generatorFn = this._probeSequence(hash);\n          const gen = generatorFn();\n          let idx;\n          let firstTombstone = null;\n          for (let step=0; step<this.M; step++){\n            const next = gen.next();\n            if (next.done) break;\n            idx = next.value;\n            const slot = this.slots[idx];\n            if (slot.state === 'empty'){\n              const placeIdx = firstTombstone !== null ? firstTombstone : idx;\n              this.slots[placeIdx] = {state:'occupied', key:k, value:value};\n              return {placed:true,index:placeIdx,probes:step+1,usedTombstone:firstTombstone!==null};\n            } else if (slot.state === 'deleted'){\n              if (firstTombstone === null) firstTombstone = idx;\n            } else if (slot.state === 'occupied'){\n              if (slot.key === k){\n                slot.value = value;\n                return {placed:true,index:idx,updated:true,probes:step+1};\n              }\n            }\n          }\n          // table full but maybe we have a tombstone recorded\n          if (firstTombstone !== null){\n            this.slots[firstTombstone] = {state:'occupied', key:k, value:value};\n            return {placed:true,index:firstTombstone,probes:this.M,usedTombstone:true};\n          }\n          return {placed:false,probes:this.M}; // full\n        }\n        search(key){\n          const k = makeKey(key);\n          const hash = computeHash(k, this.M);\n          const generatorFn = this._probeSequence(hash);\n          const gen = generatorFn();\n          for (let step=0; step<this.M; step++){\n            const next = gen.next();\n            if (next.done) break;\n            const idx = next.value;\n            const slot = this.slots[idx];\n            if (slot.state === 'empty'){\n              return {found:false,index:idx,probes:step+1};\n            } else if (slot.state === 'occupied'){\n              if (slot.key === k) return {found:true,index:idx,probes:step+1,node:slot};\n            } // if deleted, continue probing\n          }\n          return {found:false,probes:this.M};\n        }\n        delete(key){\n          const k = makeKey(key);\n          const h = computeHash(k, this.M);\n          const generatorFn = this._probeSequence(h);\n          const gen = generatorFn();\n          for (let step=0; step<this.M; step++){\n            const next = gen.next();\n            if (next.done) break;\n            const idx = next.value;\n            const slot = this.slots[idx];\n            if (slot.state === 'empty') return {deleted:false,probes:step+1};\n            if (slot.state === 'occupied' && slot.key === k){\n              const removed = slot;\n              this.slots[idx] = {state:'deleted', key:null, value:null};\n              return {deleted:true,index:idx,removed,probes:step+1};\n            }\n          }\n          return {deleted:false,probes:this.M};\n        }\n        clear(){\n          this.slots = Array.from({length:this.M}, ()=>({state:'empty', key:null, value:null}));\n        }\n      }\n\n      // UI wiring\n      const sizeRange = document.getElementById('sizeRange');\n      const sizeLabel = document.getElementById('sizeLabel');\n      const strategyEl = document.getElementById('strategy');\n      const keyInput = document.getElementById('keyInput');\n      const valueInput = document.getElementById('valueInput');\n      const insertBtn = document.getElementById('insertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const fillBtn = document.getElementById('fillBtn');\n      const visualArea = document.getElementById('visualArea');\n      const status = document.getElementById('status');\n      const hashOutput = document.getElementById('hashOutput');\n      const stepToggle = document.getElementById('stepToggle');\n      const prevStep = document.getElementById('prevStep');\n      const nextStep = document.getElementById('nextStep');\n      const probeCount = document.getElementById('probeCount');\n\n      let tableSize = Number(sizeRange.value);\n      sizeLabel.textContent = tableSize;\n\n      let mode = strategyEl.value; // 'chaining' or 'linear' or 'quadratic'\n      let stepMode = false;\n      let probeIndex = -1;\n      let currentProbes = [];\n\n      let table = createTable();\n\n      function createTable(){\n        if (mode === 'chaining') return new HashTableChaining(tableSize);\n        else return new HashTableOpen(tableSize, mode === 'linear' ? 'linear' : 'quadratic');\n      }\n\n      function resetProbes(){\n        probeIndex = -1;\n        currentProbes = [];\n        renderProbeCount();\n      }\n\n      function renderProbeCount(){\n        probeCount.textContent = currentProbes.length>0 ? (probeIndex+1) + \" / \" + currentProbes.length : \"0\";\n      }\n\n      function render(){\n        visualArea.innerHTML = '';\n        hashOutput.textContent = 'Index: —';\n        resetProbes();\n\n        if (mode === 'chaining'){\n          for (let i=0;i<table.M;i++){\n            const bucketEl = document.createElement('div');\n            bucketEl.className = 'bucket';\n            const h3 = document.createElement('h3');\n            h3.textContent = 'Bucket';\n            bucketEl.appendChild(h3);\n\n            const idxBadge = document.createElement('div');\n            idxBadge.className = 'index-badge';\n            idxBadge.textContent = i;\n            bucketEl.appendChild(idxBadge);\n\n            const chain = document.createElement('div');\n            chain.className = 'chain';\n            const nodes = table.buckets[i];\n            if (nodes.length === 0){\n              const empty = document.createElement('div');\n              empty.className = 'node slot empty';\n              empty.textContent = '(empty)';\n              chain.appendChild(empty);\n            } else {\n              for (let node of nodes){\n                const n = document.createElement('div');\n                n.className = 'node';\n                const left = document.createElement('div');\n                left.textContent = node.key;\n                const right = document.createElement('div');\n                right.style.fontSize='12px';\n                right.style.color='var(--muted)';\n                right.textContent = node.value !== null && node.value !== undefined && node.value !== '' ? node.value : '—';\n                n.appendChild(left);\n                n.appendChild(right);\n                chain.appendChild(n);\n              }\n            }\n            bucketEl.appendChild(chain);\n            visualArea.appendChild(bucketEl);\n          }\n        } else {\n          // open addressing - render array slots\n          for (let i=0;i<table.M;i++){\n            const slot = table.slots[i];\n            const slotEl = document.createElement('div');\n            slotEl.className = 'array-slot slot';\n            if (slot.state === 'empty') slotEl.classList.add('empty');\n            if (slot.state === 'deleted') slotEl.classList.add('deleted');\n            const idxBadge = document.createElement('div');\n            idxBadge.className = 'index-badge';\n            idxBadge.textContent = i;\n            slotEl.appendChild(idxBadge);\n\n            const keyEl = document.createElement('div');\n            keyEl.className = 'slot-key';\n            keyEl.textContent = slot.state === 'occupied' ? slot.key : (slot.state === 'deleted' ? '— (deleted)' : '(empty)');\n            const valEl = document.createElement('div');\n            valEl.className = 'slot-val';\n            valEl.textContent = slot.state === 'occupied' ? (slot.value !== undefined && slot.value !== null && slot.value !== '' ? slot.value : '—') : '';\n\n            slotEl.appendChild(keyEl);\n            slotEl.appendChild(valEl);\n\n            visualArea.appendChild(slotEl);\n          }\n        }\n      }\n\n      // Actions\n      insertBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        if (!key){\n          status.innerHTML = '<span style=\"color:var(--bad)\">Please enter a key to insert.</span>';\n          return;\n        }\n        const value = valueInput.value;\n        if (mode === 'chaining'){\n          const idx = computeHash(key, table.M);\n          hashOutput.textContent = 'Index: ' + idx;\n          const res = table.insert(key, value);\n          if (res.updated){\n            status.innerHTML = '<span style=\"color:var(--good)\">Updated key \"'+key+'\" at bucket '+res.index+'.</span>';\n          } else {\n            status.innerHTML = '<span style=\"color:var(--good)\">Inserted \"'+key+'\" → bucket '+res.index+'.</span>';\n          }\n          render();\n        } else {\n          const hash = computeHash(key, table.M);\n          hashOutput.textContent = 'Index: ' + hash;\n          const seq = probeSequenceForUI(hash, table);\n          currentProbes = seq;\n          probeIndex = -1;\n          renderProbeCount();\n          if (!stepMode){\n            const res = table.insert(key, value);\n            if (res.placed){\n              status.innerHTML = '<span style=\"color:var(--good)\">Inserted \"'+key+'\" at index '+res.index+' after '+res.probes+' probes.</span>';\n            } else {\n              status.innerHTML = '<span style=\"color:var(--bad)\">Table full — could not insert.</span>';\n            }\n            render();\n          } else {\n            // Step mode: set up probes and highlight first probe\n            status.innerHTML = '<span style=\"color:var(--muted)\">Step mode: advance through probes to insert.</span>';\n            probeIndex = -1;\n            stepInsertState = {key, value, hash, done:false};\n            nextStepAction = ()=>{\n              // perform one probe step visually; if we find spot, commit\n              if (!stepInsertState || stepInsertState.done) return;\n              probeIndex++;\n              renderProbes(currentProbes, probeIndex);\n              if (probeIndex >= currentProbes.length) {\n                status.innerHTML = '<span style=\"color:var(--bad)\">No free slot found (table full).</span>';\n                stepInsertState.done = true;\n                render();\n                return;\n              }\n              const idx = currentProbes[probeIndex];\n              const slot = table.slots[idx];\n              if (slot.state === 'empty' || slot.state === 'deleted'){\n                // commit insertion\n                table.slots[idx] = {state:'occupied', key:makeKey(key), value:value};\n                status.innerHTML = '<span style=\"color:var(--good)\">Inserted \"'+key+'\" at index '+idx+' (probe '+(probeIndex+1)+').</span>';\n                stepInsertState.done = true;\n                render(); // final render clears highlights\n                resetProbes();\n              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){\n                slot.value = value;\n                status.innerHTML = '<span style=\"color:var(--good)\">Updated existing key at index '+idx+' (probe '+(probeIndex+1)+').</span>';\n                stepInsertState.done = true;\n                render();\n                resetProbes();\n              } else {\n                status.innerHTML = '<span style=\"color:var(--muted)\">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+slot.key+').</span>';\n              }\n            };\n            // show first probe (do not auto-advance)\n            nextStepAction();\n          }\n        }\n      });\n\n      let nextStepAction = null;\n      let prevStepAction = null;\n      let stepInsertState = null;\n      let stepSearchState = null;\n      let stepDeleteState = null;\n\n      searchBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        if (!key){\n          status.innerHTML = '<span style=\"color:var(--bad)\">Please enter a key to search.</span>';\n          return;\n        }\n        if (mode === 'chaining'){\n          const res = table.search(key);\n          hashOutput.textContent = 'Index: ' + res.index;\n          if (res.found){\n            status.innerHTML = '<span style=\"color:var(--good)\">Found \"'+key+'\" in bucket '+res.index+' (chain index '+res.chainIndex+'). Value: '+res.node.value+'</span>';\n          } else {\n            status.innerHTML = '<span style=\"color:var(--muted)\">Not found in bucket '+res.index+'.</span>';\n          }\n        } else {\n          const hash = computeHash(key, table.M);\n          hashOutput.textContent = 'Index: ' + hash;\n          const seq = probeSequenceForUI(hash, table);\n          currentProbes = seq;\n          probeIndex = -1;\n          renderProbeCount();\n          if (!stepMode){\n            const res = table.search(key);\n            if (res.found){\n              status.innerHTML = '<span style=\"color:var(--good)\">Found \"'+key+'\" at index '+res.index+' after '+res.probes+' probes. Value: '+res.node.value+'</span>';\n            } else {\n              status.innerHTML = '<span style=\"color:var(--muted)\">Not found after '+res.probes+' probes.</span>';\n            }\n            render();\n          } else {\n            // step search\n            stepSearchState = {key, hash, done:false};\n            status.innerHTML = '<span style=\"color:var(--muted)\">Step search: advance probes.</span>';\n            nextStepAction = ()=>{\n              if (!stepSearchState || stepSearchState.done) return;\n              probeIndex++;\n              renderProbes(currentProbes, probeIndex);\n              if (probeIndex >= currentProbes.length){\n                status.innerHTML = '<span style=\"color:var(--muted)\">Not found — reached max probes.</span>';\n                stepSearchState.done = true;\n                resetProbes();\n                render();\n                return;\n              }\n              const idx = currentProbes[probeIndex];\n              const slot = table.slots[idx];\n              if (slot.state === 'empty'){\n                status.innerHTML = '<span style=\"color:var(--muted)\">Probe '+(probeIndex+1)+': index '+idx+' is empty → not found.</span>';\n                stepSearchState.done = true;\n                resetProbes();\n                render();\n                return;\n              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){\n                status.innerHTML = '<span style=\"color:var(--good)\">Found at index '+idx+' (probe '+(probeIndex+1)+'). Value: '+slot.value+'</span>';\n                stepSearchState.done = true;\n                resetProbes();\n                render();\n                return;\n              } else {\n                status.innerHTML = '<span style=\"color:var(--muted)\">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+(slot.key||'deleted')+')</span>';\n              }\n            };\n            nextStepAction();\n          }\n        }\n      });\n\n      deleteBtn.addEventListener('click', ()=>{\n        const key = keyInput.value.trim();\n        if (!key){\n          status.innerHTML = '<span style=\"color:var(--bad)\">Please enter a key to delete.</span>';\n          return;\n        }\n        if (mode === 'chaining'){\n          const res = table.delete(key);\n          hashOutput.textContent = 'Index: ' + res.index;\n          if (res.removed){\n            status.innerHTML = '<span style=\"color:var(--good)\">Deleted \"'+key+'\" from bucket '+res.index+'.</span>';\n          } else {\n            status.innerHTML = '<span style=\"color:var(--muted)\">Key not found in bucket '+res.index+'.</span>';\n          }\n          render();\n        } else {\n          const hash = computeHash(key, table.M);\n          hashOutput.textContent = 'Index: ' + hash;\n          const seq = probeSequenceForUI(hash, table);\n          currentProbes = seq;\n          probeIndex = -1;\n          renderProbeCount();\n          if (!stepMode){\n            const res = table.delete(key);\n            if (res.deleted){\n              status.innerHTML = '<span style=\"color:var(--good)\">Deleted \"'+key+'\" at index '+res.index+' after '+res.probes+' probes.</span>';\n            } else {\n              status.innerHTML = '<span style=\"color:var(--muted)\">Key not found after '+res.probes+' probes.</span>';\n            }\n            render();\n          } else {\n            stepDeleteState = {key, hash, done:false};\n            status.innerHTML = '<span style=\"color:var(--muted)\">Step delete: advance probes.</span>';\n            nextStepAction = ()=>{\n              if (!stepDeleteState || stepDeleteState.done) return;\n              probeIndex++;\n              renderProbes(currentProbes, probeIndex);\n              if (probeIndex >= currentProbes.length){\n                status.innerHTML = '<span style=\"color:var(--muted)\">Not found — reached max probes.</span>';\n                stepDeleteState.done = true;\n                render();\n                resetProbes();\n                return;\n              }\n              const idx = currentProbes[probeIndex];\n              const slot = table.slots[idx];\n              if (slot.state === 'empty'){\n                status.innerHTML = '<span style=\"color:var(--muted)\">Probe '+(probeIndex+1)+': index '+idx+' is empty → not found.</span>';\n                stepDeleteState.done = true;\n                render();\n                resetProbes();\n                return;\n              } else if (slot.state === 'occupied' && slot.key === makeKey(key)){\n                table.slots[idx] = {state:'deleted', key:null, value:null};\n                status.innerHTML = '<span style=\"color:var(--good)\">Deleted at index '+idx+' (probe '+(probeIndex+1)+').</span>';\n                stepDeleteState.done = true;\n                render();\n                resetProbes();\n                return;\n              } else {\n                status.innerHTML = '<span style=\"color:var(--muted)\">Probe '+(probeIndex+1)+': index '+idx+' occupied ('+(slot.key||'deleted')+')</span>';\n              }\n            };\n            nextStepAction();\n          }\n        }\n      });\n\n      // Step buttons\n      nextStep.addEventListener('click', ()=>{\n        if (nextStepAction) nextStepAction();\n      });\n      prevStep.addEventListener('click', ()=>{\n        if (!currentProbes || currentProbes.length===0) return;\n        if (probeIndex > 0) probeIndex--;\n        renderProbes(currentProbes, probeIndex);\n        renderProbeCount();\n      });\n\n      stepToggle.addEventListener('click', ()=>{\n        stepMode = !stepMode;\n        stepToggle.textContent = 'Step Mode: ' + (stepMode ? 'On' : 'Off');\n        if (!stepMode){\n          // cancel any pending step state\n          nextStepAction = null;\n          stepInsertState = null;\n          stepSearchState = null;\n          stepDeleteState = null;\n          resetProbes();\n          render();\n        }\n      });\n\n      fillBtn.addEventListener('click', ()=>{\n        const items = ['apple','banana','cherry','date','fig','grape','kiwi','lime','mango','nectarine','orange','pear','quince','raspberry','strawberry','tomato','ugli','vanilla','watermelon','yam','zucchini','alpha','beta','gamma'];\n        let added = 0;\n        if (mode === 'chaining'){\n          table.clear();\n          for (let i=0;i<table.M && added < table.M; i++){\n            const key = items[(Math.floor(Math.random()*items.length))];\n            table.insert(key, 'v:'+key);\n            added++;\n          }\n          status.innerHTML = '<span style=\"color:var(--good)\">Filled chaining table with sample items.</span>';\n        } else {\n          table.clear();\n          for (let i=0;i<table.M && added < table.M-2;i++){\n            const key = items[(Math.floor(Math.random()*items.length))];\n            const res = table.insert(key, 'v:'+key);\n            if (res.placed) added++;\n          }\n          status.innerHTML = '<span style=\"color:var(--good)\">Filled open addressing table with sample items.</span>';\n        }\n        render();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        table.clear();\n        status.innerHTML = '<span style=\"color:var(--muted)\">Table reset.</span>';\n        render();\n      });\n\n      sizeRange.addEventListener('input', ()=>{\n        tableSize = Number(sizeRange.value);\n        sizeLabel.textContent = tableSize;\n      });\n\n      sizeRange.addEventListener('change', ()=>{\n        tableSize = Number(sizeRange.value);\n        sizeLabel.textContent = tableSize;\n        // recreate table with new size\n        tableSize = Number(sizeRange.value);\n        table = createTableSize(tableSize);\n        render();\n        status.innerHTML = '<span style=\"color:var(--muted)\">Table size changed to '+tableSize+'.</span>';\n      });\n\n      strategyEl.addEventListener('change', ()=>{\n        mode = strategyEl.value;\n        table = createTable(); // new table with current size & mode\n        render();\n        status.innerHTML = '<span style=\"color:var(--muted)\">Switched strategy to '+(mode==='chaining'?'Separate Chaining':(mode==='linear'?'Linear Probing':'Quadratic Probing'))+'</span>';\n      });\n\n      function createTableSize(sz){\n        if (mode === 'chaining') return new HashTableChaining(sz);\n        else return new HashTableOpen(sz, mode === 'linear' ? 'linear' : 'quadratic');\n      }\n\n      function probeSequenceForUI(hash, table){\n        const seq = [];\n        const M = table.M;\n        if (table instanceof HashTableOpen){\n          if (table.probeStrategy === 'linear'){\n            for (let i=0;i<M;i++) seq.push((hash+i)%M);\n          } else {\n            for (let i=0;i<M;i++) seq.push((hash + i*i)%M);\n          }\n        }\n        return seq;\n      }\n\n      function clearHighlights(){\n        const slotEls = visualArea.querySelectorAll('.array-slot, .bucket');\n        slotEls.forEach(el=>el.classList.remove('highlight'));\n      }\n\n      function renderProbes(seq, index){\n        clearHighlights();\n        const slotEls = visualArea.querySelectorAll('.array-slot');\n        seq.forEach((idx,i)=>{\n          if (slotEls[idx]){\n            if (i === index) slotEls[idx].classList.add('highlight');\n            else slotEls[idx].classList.remove('highlight');\n          }\n        });\n        renderProbeCount();\n      }\n\n      // initial render\n      function init(){\n        table = createTable();\n        render();\n        status.innerHTML = '<span style=\"color:var(--muted)\">Ready. Try inserting keys like \"a\", \"k\", \"u\" to create collisions on small tables.</span>';\n      }\n\n      init();\n\n      // small helper: update hash display as user types\n      keyInput.addEventListener('input', ()=>{\n        const k = keyInput.value.trim();\n        if (!k){ hashOutput.textContent = 'Index: —'; return; }\n        hashOutput.textContent = 'Index: ' + computeHash(k, table.M);\n      });\n\n      // Expose some debug shortcuts:\n      window.htDemo = {table, computeHash};\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}