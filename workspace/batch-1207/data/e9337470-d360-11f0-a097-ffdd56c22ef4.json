{
  "id": "e9337470-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:03.446Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Union-Find (Disjoint Set)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Union-Find (Disjoint Set) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#22c1c3;\n      --muted:#94a3b8;\n      --card:#071327;\n      --white:#e6eef8;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{\n      background:linear-gradient(180deg,#071428 0%, #041022 60%);\n      color:var(--white);\n      display:flex;\n      gap:12px;\n      padding:12px;\n      box-sizing:border-box;\n      align-items:flex-start;\n      justify-content:center;\n    }\n    .container{\n      width:1200px;\n      max-width:calc(100vw - 24px);\n      display:grid;\n      grid-template-columns: 1fr 360px;\n      gap:12px;\n      align-items:start;\n    }\n    .canvas-card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(8,16,28,0.1));\n      border-radius:10px;\n      padding:12px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n    }\n    canvas{background:transparent;display:block;border-radius:8px;touch-action:none;}\n    .controls{\n      display:flex;flex-direction:column;gap:10px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(8,12,20,0.06));\n      padding:12px;border-radius:10px;\n    }\n    .row{display:flex;gap:8px;align-items:center;}\n    label{font-size:13px;color:var(--muted);min-width:110px;}\n    input[type=number], select, button{\n      background:#0b1725;border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:6px 8px;border-radius:6px;font-size:13px;\n    }\n    button{cursor:pointer}\n    .small{font-size:12px;color:var(--muted)}\n    .info{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;color:var(--muted);\n      overflow:auto;max-height:320px;\n    }\n    .arrays{\n      display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;\n    }\n    .array{\n      background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);\n      min-width:160px;\n    }\n    .legend{display:flex;gap:8px;flex-wrap:wrap}\n    .legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}\n    .dot{width:18px;height:12px;border-radius:4px;}\n    .btn-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}\n    .oplog{background:#02121b;padding:8px;border-radius:6px;color:var(--muted);font-size:13px;max-height:160px;overflow:auto;}\n    .hint{font-size:12px;color:var(--muted)}\n    .selected{outline:2px solid rgba(34,193,195,0.25);box-shadow:0 6px 18px rgba(34,193,195,0.06)}\n    .footer-note{font-size:12px;color:var(--muted);margin-top:6px;}\n    .big{\n      font-size:15px;color:var(--white);font-weight:600;\n    }\n    .toggle{display:flex;gap:6px;align-items:center}\n    input[type=checkbox]{width:16px;height:16px}\n    .controls hr{border:0;border-top:1px solid rgba(255,255,255,0.04);margin:6px 0}\n    .link{color:var(--accent);text-decoration:none}\n    .button-primary{background:linear-gradient(90deg,#22c1c3,#4ecdc4);color:#022; border:none}\n    .button-danger{background:linear-gradient(90deg,#ff6b6b,#ff8a8a);color:#060;border:none}\n    .muted-box{background:rgba(255,255,255,0.01);padding:6px;border-radius:6px}\n  </style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"canvas-card\">\n    <div style=\"display:flex;gap:12px;align-items:center;margin-bottom:6px\">\n      <div style=\"flex:1\">\n        <div class=\"big\">Union-Find (Disjoint Set) Visualizer</div>\n        <div class=\"hint\">Click two nodes to perform union. Click a node to highlight its find path. Use options to toggle union-by-rank/size and animated path compression.</div>\n      </div>\n      <div style=\"text-align:right\">\n        <div class=\"small\">Sets: <span id=\"compCount\">-</span></div>\n        <div class=\"small\">Nodes: <span id=\"nodeCount\">-</span></div>\n      </div>\n    </div>\n    <canvas id=\"canvas\" width=\"820\" height=\"620\"></canvas>\n    <div style=\"margin-top:8px;display:flex;gap:8px;align-items:center;justify-content:space-between\">\n      <div class=\"hint\">Tip: use \"Random unions\" to create merges quickly. Check \"Animate compression\" to see path compression.</div>\n      <div><button id=\"helpBtn\">Show Pseudocode</button></div>\n    </div>\n    <div id=\"pseudocode\" class=\"muted-box\" style=\"margin-top:8px;display:none\">\n      <pre style=\"margin:0;font-size:13px;color:var(--muted)\">\nClassic DSU (Union-Find):\n\nmake_set(n):\n  for i in 0..n-1:\n    parent[i] = i\n    rank[i] = 0\n\nfind(x):\n  if parent[x] != x:\n    parent[x] = find(parent[x])   // path compression\n  return parent[x]\n\nunion(a,b):\n  ra = find(a); rb = find(b)\n  if ra == rb: return\n  if rank[ra] < rank[rb]: swap(ra,rb)\n  parent[rb] = ra\n  if rank[ra] == rank[rb]: rank[ra]++\n      </pre>\n    </div>\n  </div>\n\n  <div class=\"controls\">\n    <div class=\"row\">\n      <label>Nodes (n)</label>\n      <input id=\"nInput\" type=\"number\" min=\"2\" max=\"40\" value=\"10\" />\n      <button id=\"resetBtn\" class=\"button-primary\">New</button>\n      <button id=\"clearBtn\">Reset</button>\n    </div>\n\n    <div class=\"row\">\n      <label>Mode</label>\n      <select id=\"modeSelect\">\n        <option value=\"union\">Union (click two nodes)</option>\n        <option value=\"find\">Find (click node)</option>\n      </select>\n      <label style=\"min-width:70px\">Auto</label>\n      <input id=\"autoCheck\" type=\"checkbox\" title=\"Auto-run unions\" />\n    </div>\n\n    <div class=\"row\">\n      <label>Union rule</label>\n      <select id=\"unionRule\">\n        <option value=\"rank\">Union-by-rank</option>\n        <option value=\"size\">Union-by-size</option>\n        <option value=\"none\">No heuristic</option>\n      </select>\n      <label style=\"min-width:70px\">Animate compression</label>\n      <input id=\"compressAnim\" type=\"checkbox\" checked />\n    </div>\n\n    <div class=\"row\">\n      <label>Random unions</label>\n      <input id=\"randCount\" type=\"number\" min=\"1\" max=\"100\" value=\"5\" style=\"width:80px\" />\n      <button id=\"randBtn\">Random unions</button>\n    </div>\n\n    <div style=\"display:flex;gap:8px\">\n      <button id=\"undoBtn\">Undo last union</button>\n      <button id=\"historyClear\">Clear log</button>\n    </div>\n\n    <hr />\n\n    <div style=\"display:flex;gap:8px;align-items:center;justify-content:space-between\">\n      <div class=\"small\">Parent / Rank / Size arrays</div>\n      <div class=\"small\">Click a node visual => highlight its path</div>\n    </div>\n\n    <div class=\"arrays\">\n      <div class=\"array\">\n        <div style=\"font-weight:600\">Parent</div>\n        <div id=\"parentArray\" class=\"small\"></div>\n      </div>\n      <div class=\"array\">\n        <div style=\"font-weight:600\">Rank</div>\n        <div id=\"rankArray\" class=\"small\"></div>\n      </div>\n      <div class=\"array\">\n        <div style=\"font-weight:600\">Size</div>\n        <div id=\"sizeArray\" class=\"small\"></div>\n      </div>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <div style=\"font-weight:600;margin-bottom:6px\">Operation Log</div>\n      <div class=\"oplog\" id=\"oplog\"></div>\n    </div>\n\n    <div style=\"display:flex;gap:8px;margin-top:8px\">\n      <button id=\"stepUnions\">Step unions (auto-generated)</button>\n      <button id=\"stopAuto\" class=\"button-danger\">Stop</button>\n    </div>\n\n    <div class=\"footer-note\">\n      Built to teach how union-by-rank/size and path compression affect trees. Colors show connected components.\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  // Helpers\n  function $(id){return document.getElementById(id);}\n  function sleep(ms){return new Promise(res=>setTimeout(res,ms));}\n\n  // Color palette\n  const COLORS = [\n    '#ef476f','#ffd166','#06d6a0','#118ab2','#ff6b6b','#9b5de5','#00b4d8','#8ecae6',\n    '#f94144','#f8961e','#43aa8b','#577590','#7209b7','#f72585','#4cc9f0','#a8dadc'\n  ];\n\n  // Canvas & drawing\n  const canvas = $('canvas');\n  const ctx = canvas.getContext('2d');\n  let width = canvas.width, height = canvas.height;\n  function resizeCanvas(w,h){width=w;height=h;canvas.width=w;canvas.height=h;draw();}\n  window.addEventListener('resize', ()=> {\n    // No auto resize; keep static for predictability\n  });\n\n  // DSU Implementation with history for undo\n  class DSU {\n    constructor(n){\n      this.n = n;\n      this.parent = new Array(n);\n      this.rank = new Array(n);\n      this.size = new Array(n);\n      this.init();\n      this.history = []; // stack of operations for undo\n    }\n    init(){\n      for(let i=0;i<this.n;i++){ this.parent[i]=i; this.rank[i]=0; this.size[i]=1; }\n      this.history = [];\n    }\n    find(x){\n      // non-animated find (recursive)\n      if(this.parent[x] === x) return x;\n      this.parent[x] = this.find(this.parent[x]);\n      return this.parent[x];\n    }\n    // find path (non-compress) return path up to root\n    pathToRoot(x){\n      const p = [];\n      let cur = x;\n      while(true){\n        p.push(cur);\n        if(this.parent[cur] === cur) break;\n        cur = this.parent[cur];\n      }\n      return p;\n    }\n    union(a,b,rule='rank'){\n      const ra = this.find(a);\n      const rb = this.find(b);\n      if(ra === rb){\n        this.history.push({type:'noop', a,b});\n        return {merged:false, ra, rb};\n      }\n      // save snapshot for undo\n      const snapshot = {type:'union', parent: this.parent.slice(), rank:this.rank.slice(), size:this.size.slice(), a,b};\n      this.history.push(snapshot);\n\n      if(rule === 'size'){\n        if(this.size[ra] < this.size[rb]) [ra,rb] = [rb,ra];\n        this.parent[rb] = ra;\n        this.size[ra] += this.size[rb];\n      } else if(rule === 'rank'){\n        if(this.rank[ra] < this.rank[rb]) [ra,rb] = [rb,ra];\n        this.parent[rb] = ra;\n        if(this.rank[ra] === this.rank[rb]) this.rank[ra]++;\n        this.size[ra] = this.size[ra] + this.size[rb];\n      } else {\n        // no heuristic: attach rb to ra\n        this.parent[rb] = ra;\n        this.size[ra] += this.size[rb];\n      }\n      return {merged:true, ra, rb};\n    }\n    undo(){\n      if(this.history.length === 0) return false;\n      const last = this.history.pop();\n      if(last.type === 'union'){\n        this.parent = last.parent;\n        this.rank = last.rank;\n        this.size = last.size;\n        return true;\n      } else {\n        // noop\n        return true;\n      }\n    }\n    components(){\n      const comps = new Map();\n      for(let i=0;i<this.n;i++){\n        const r = this.find(i);\n        if(!comps.has(r)) comps.set(r, []);\n        comps.get(r).push(i);\n      }\n      return comps;\n    }\n  }\n\n  // Visualization state\n  let n = parseInt($('nInput').value,10) || 10;\n  let dsu = new DSU(n);\n  let positions = []; // {x,y}\n  let selected = []; // selected nodes for union\n  let animating = false;\n  let autoRunning = false;\n  let stepRunning = false;\n\n  function generatePositions(n){\n    positions = [];\n    const cx = width/2, cy = height/2;\n    const r = Math.min(width, height) * 0.36;\n    for(let i=0;i<n;i++){\n      const ang = (i / n) * Math.PI * 2 - Math.PI/2;\n      const radius = r * (0.7 + 0.3 * Math.sin(i*1.3)); // small variance\n      const x = cx + radius * Math.cos(ang);\n      const y = cy + radius * Math.sin(ang);\n      positions.push({x,y});\n    }\n  }\n\n  function componentColorMap(){\n    const comps = dsu.components();\n    const map = new Map();\n    let idx = 0;\n    for(const root of comps.keys()){\n      map.set(root, COLORS[idx % COLORS.length]);\n      idx++;\n    }\n    return map;\n  }\n\n  function draw(){\n    ctx.clearRect(0,0,width,height);\n    // background subtle circle\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.01)';\n    ctx.beginPath();\n    ctx.ellipse(width/2, height/2, width*0.46, height*0.46, 0, 0, Math.PI*2);\n    ctx.fill();\n    ctx.restore();\n\n    const cmap = componentColorMap();\n\n    // Draw parent arrows first (lines from node -> parent)\n    ctx.lineWidth = 2;\n    for(let i=0;i<n;i++){\n      const p = positions[i];\n      const par = dsu.parent[i];\n      if(par === i) continue;\n      const q = positions[par];\n\n      const color = cmap.get(dsu.find(i)) || '#888';\n      // Draw curved arrow\n      const midx = (p.x + q.x)/2;\n      const midy = (p.y + q.y)/2;\n      const dx = q.x - p.x, dy = q.y - p.y;\n      const len = Math.hypot(dx,dy);\n      const ux = dx / len, uy = dy / len;\n      // offset for curvature\n      const curve = Math.min(60, Math.max(12, len * 0.18));\n      const nx = -uy, ny = ux; // normal\n      const cx1 = midx + nx * curve;\n      const cy1 = midy + ny * curve;\n\n      ctx.beginPath();\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      ctx.moveTo(p.x, p.y);\n      // quadratic curve to parent\n      ctx.quadraticCurveTo(cx1, cy1, q.x, q.y);\n      ctx.stroke();\n      // arrowhead at parent\n      const arrowLen = 10;\n      const t = 0.98;\n      // compute point near end and derivative\n      const ex = (1-t) * ((1-t) * p.x + t * cx1) + t * ((1-t) * cx1 + t * q.x);\n      const ey = (1-t) * ((1-t) * p.y + t * cy1) + t * ((1-t) * cy1 + t * q.y);\n      // derivative approximation\n      const dxdyx = q.x - p.x + 0; // rough\n      const dxdyy = q.y - p.y + 0;\n      // But better: tangent of quadratic at t\n      const tx = 2*(1-t)*(cx1 - p.x) + 2*t*(q.x - cx1);\n      const ty = 2*(1-t)*(cy1 - p.y) + 2*t*(q.y - cy1);\n      const ang = Math.atan2(ty, tx);\n      ctx.save();\n      ctx.translate(ex, ey);\n      ctx.rotate(ang);\n      ctx.beginPath();\n      ctx.moveTo(0,0);\n      ctx.lineTo(-arrowLen, arrowLen/3);\n      ctx.lineTo(-arrowLen, -arrowLen/3);\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // Draw nodes\n    for(let i=0;i<n;i++){\n      const p = positions[i];\n      const root = dsu.find(i);\n      const color = cmap.get(root) || '#888';\n      const isRoot = (dsu.parent[i] === i);\n      const size = isRoot ? 22 : 18;\n      ctx.beginPath();\n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.14;\n      ctx.ellipse(p.x, p.y, size+8, size+8, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.globalAlpha = 1.0;\n      ctx.beginPath();\n      ctx.fillStyle = '#06202b';\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.ellipse(p.x, p.y, size, size, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // highlight if selected\n      if(selected.includes(i)){\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(34,193,195,0.9)';\n        ctx.lineWidth = 3;\n        ctx.ellipse(p.x, p.y, size+6, size+6, 0, 0, Math.PI*2);\n        ctx.stroke();\n      }\n\n      // text\n      ctx.fillStyle = '#cfe9f2';\n      ctx.font = 'bold 12px Inter, Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(i.toString(), p.x, p.y);\n      // small parent index\n      ctx.font = '11px Inter, Arial';\n      ctx.fillStyle = '#9fb6c4';\n      ctx.fillText('p:'+dsu.parent[i], p.x, p.y+16);\n    }\n  }\n\n  // UI updates\n  function updateArrays(){\n    $('parentArray').textContent = dsu.parent.map((v,i)=>`${i}:${v}`).join('  ');\n    $('rankArray').textContent = dsu.rank.map((v,i)=>`${i}:${v}`).join('  ');\n    $('sizeArray').textContent = dsu.size.map((v,i)=>`${i}:${v}`).join('  ');\n    $('compCount').textContent = dsu.components().size;\n    $('nodeCount').textContent = dsu.n;\n  }\n\n  function logOp(msg){\n    const el = $('oplog');\n    const p = document.createElement('div');\n    p.textContent = msg;\n    el.prepend(p);\n  }\n\n  // Interaction handlers\n  function canvasPos(evt){\n    const rect = canvas.getBoundingClientRect();\n    const x = evt.clientX - rect.left;\n    const y = evt.clientY - rect.top;\n    return {x,y};\n  }\n\n  function findNodeAt(x,y){\n    for(let i=0;i<n;i++){\n      const p = positions[i];\n      const dx = x - p.x, dy = y - p.y;\n      const dist = Math.hypot(dx,dy);\n      const size = (dsu.parent[i]===i) ? 22 : 18;\n      if(dist <= size+10) return i;\n    }\n    return -1;\n  }\n\n  canvas.addEventListener('pointerdown', async (evt) => {\n    if(animating) return;\n    const pos = canvasPos(evt);\n    const node = findNodeAt(pos.x,pos.y);\n    if(node === -1) return;\n\n    const mode = $('modeSelect').value;\n    if(mode === 'union'){\n      if(!selected.includes(node)){\n        selected.push(node);\n        if(selected.length > 2) selected.shift();\n      } else {\n        // deselect if clicked again\n        selected = selected.filter(x => x!==node);\n      }\n      draw();\n      if(selected.length === 2){\n        // perform union\n        const a = selected[0], b = selected[1];\n        const rule = $('unionRule').value;\n        animating = true;\n        await animateUnion(a,b,rule);\n        animating = false;\n        selected = [];\n        updateArrays();\n      }\n    } else {\n      // find mode: highlight path, then optionally animate compression\n      const xnode = node;\n      const path = dsu.pathToRoot(xnode);\n      await highlightPath(path);\n      const compressAnim = $('compressAnim').checked;\n      if(compressAnim){\n        animating = true;\n        await animateCompression(path);\n        animating = false;\n        updateArrays();\n      }\n    }\n  });\n\n  async function animateUnion(a,b,rule){\n    logOp(`Union request: ${a} ⨯ ${b} (rule=${rule})`);\n    // show temporary highlighting and animate path to roots\n    const pa = dsu.pathToRoot(a);\n    const pb = dsu.pathToRoot(b);\n    await highlightPath(pa, 'a');\n    await highlightPath(pb, 'b');\n    // wait a bit\n    await sleep(300);\n    // perform union in DSU\n    const res = dsu.union(a,b,rule);\n    if(!res.merged){\n      logOp(`Already connected (root ${res.ra}).`);\n      await sleep(300);\n      draw();\n      return;\n    }\n    logOp(`Merged root ${res.rb} -> ${res.ra}`);\n    // animate attachment: move small pulse along arrow\n    await animateAttach(res.rb, res.ra);\n    draw();\n  }\n\n  async function animateAttach(child, parent){\n    // draw a moving dot along quadratic curve from child -> parent\n    const p = positions[child], q = positions[parent];\n    const midx = (p.x + q.x)/2;\n    const midy = (p.y + q.y)/2;\n    const dx = q.x - p.x, dy = q.y - p.y;\n    const len = Math.hypot(dx,dy);\n    const ux = dx / len, uy = dy / len;\n    const curve = Math.min(60, Math.max(12, len * 0.18));\n    const nx = -uy, ny = ux;\n    const cx1 = midx + nx * curve;\n    const cy1 = midy + ny * curve;\n    const steps = 30;\n    for(let t=0;t<=steps;t++){\n      const tt = t/steps;\n      // point on quadratic Bézier\n      const x = (1-tt)*(1-tt)*p.x + 2*(1-tt)*tt*cx1 + tt*tt*q.x;\n      const y = (1-tt)*(1-tt)*p.y + 2*(1-tt)*tt*cy1 + tt*tt*q.y;\n      draw();\n      // draw moving circle\n      ctx.beginPath();\n      ctx.fillStyle = '#ffffff';\n      ctx.globalAlpha = 0.95;\n      ctx.ellipse(x,y,6,6,0,0,Math.PI*2);\n      ctx.fill();\n      ctx.globalAlpha = 1.0;\n      await sleep(10);\n    }\n    await sleep(120);\n  }\n\n  async function highlightPath(path, tag){\n    // animate highlighting nodes in path\n    for(let i=0;i<path.length;i++){\n      const node = path[i];\n      selected = [node];\n      draw();\n      // overlay highlight circle\n      const p = positions[node];\n      ctx.beginPath();\n      ctx.strokeStyle = (tag==='a') ? '#ffd166' : (tag==='b' ? '#06d6a0' : '#4ecdc4');\n      ctx.lineWidth = 3;\n      ctx.ellipse(p.x, p.y, 28, 28, 0, 0, Math.PI*2);\n      ctx.stroke();\n      await sleep(160);\n    }\n    selected = [];\n    draw();\n  }\n\n  async function animateCompression(path){\n    // Path is from node up to root: we will compress by setting each parent to root step-by-step\n    if(path.length <= 1) return;\n    const root = path[path.length-1];\n    logOp(`Path compression towards root ${root}`);\n    for(let i=0;i<path.length-1;i++){\n      const node = path[i];\n      // animate re-parenting to root\n      await animateAttach(node, root);\n      dsu.parent[node] = root;\n      dsu.size[root] += dsu.size[node];\n      draw();\n      await sleep(120);\n    }\n  }\n\n  // Buttons & controls\n  $('resetBtn').addEventListener('click', () => {\n    if(animating) return;\n    const val = parseInt($('nInput').value,10);\n    if(isNaN(val) || val < 2 || val > 40) { alert('n must be 2..40'); return; }\n    n = val;\n    dsu = new DSU(n);\n    generatePositions(n);\n    updateArrays();\n    $('oplog').textContent = '';\n    draw();\n  });\n\n  $('clearBtn').addEventListener('click', () => {\n    if(animating) return;\n    dsu = new DSU(n);\n    selected = [];\n    $('oplog').textContent = '';\n    updateArrays();\n    draw();\n  });\n\n  $('randBtn').addEventListener('click', async () => {\n    if(animating) return;\n    const count = parseInt($('randCount').value,10) || 5;\n    if(count <= 0) return;\n    animating = true;\n    for(let i=0;i<count;i++){\n      const a = Math.floor(Math.random()*n);\n      const b = Math.floor(Math.random()*n);\n      await animateUnion(a,b,$('unionRule').value);\n      updateArrays();\n      await sleep(200);\n    }\n    animating = false;\n  });\n\n  $('undoBtn').addEventListener('click', () => {\n    if(animating) return;\n    const ok = dsu.undo();\n    if(ok){\n      logOp('Undo last union');\n      updateArrays();\n      draw();\n    } else {\n      logOp('Nothing to undo');\n    }\n  });\n\n  $('historyClear').addEventListener('click', ()=> $('oplog').textContent='');\n\n  $('helpBtn').addEventListener('click', ()=>{\n    const el = $('pseudocode');\n    el.style.display = (el.style.display === 'none') ? 'block' : 'none';\n  });\n\n  // Step unions auto-run generator\n  $('stepUnions').addEventListener('click', async () => {\n    if(stepRunning) return;\n    stepRunning = true;\n    logOp('Starting step-run: will attempt N-1 unions to connect graph.');\n    const needed = n - dsu.components().size;\n    // We'll try random pairs until components unify or until limit\n    let attempts = 0, maxAttempts = n*8;\n    while(stepRunning && dsu.components().size > 1 && attempts < maxAttempts){\n      const a = Math.floor(Math.random()*n);\n      const b = Math.floor(Math.random()*n);\n      if(dsu.find(a) === dsu.find(b)){ attempts++; continue; }\n      animating = true;\n      await animateUnion(a,b,$('unionRule').value);\n      animating = false;\n      updateArrays();\n      attempts++;\n      await sleep(200);\n    }\n    logOp('Step-run ended.');\n    stepRunning = false;\n  });\n\n  $('stopAuto').addEventListener('click', ()=>{\n    stepRunning = false;\n    autoRunning = false;\n    animating = false;\n  });\n\n  // Initial setup\n  function init(){\n    width = canvas.width;\n    height = canvas.height;\n    n = parseInt($('nInput').value,10) || 10;\n    dsu = new DSU(n);\n    generatePositions(n);\n    updateArrays();\n    draw();\n  }\n\n  init();\n\n  // small animation loop to redraw occasionally for crispness\n  setInterval(()=>{ draw(); }, 600);\n\n  // Also update arrays periodically (to reflect any quicker changes)\n  setInterval(()=>{ updateArrays(); }, 400);\n\n  // Keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === 'u'){ $('modeSelect').value='union'; }\n    if(e.key === 'f'){ $('modeSelect').value='find'; }\n  });\n\n  // Expose for debugging (console)\n  window._dsu_visual = {dsu, draw, positions};\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Union-Find (Disjoint Set)"
    }
  ],
  "topic": "Union-Find (Disjoint Set)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}