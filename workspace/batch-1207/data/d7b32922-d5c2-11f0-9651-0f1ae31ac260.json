{
  "id": "d7b32922-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:29.219Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Union-Find (Disjoint Set)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Union-Find (Disjoint Set) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    margin-bottom: 5px;\n  }\n  #union-find {\n    margin: 20px 0;\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n  }\n  .node {\n    width: 50px;\n    height: 50px;\n    border: 2px solid #333;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #eee;\n    cursor: pointer;\n    position: relative;\n    user-select: none;\n    font-weight: bold;\n  }\n  .node.header {\n    border-color: #666;\n    background: #fafafa;\n    cursor: default;\n  }\n  .node .parent-arrow {\n    position: absolute;\n    top: 60px;\n    left: 50%;\n    width: 2px;\n    height: 20px;\n    background: #666;\n    transform-origin: top center;\n  }\n  #controls {\n    margin: 20px 0;\n  }\n  label {\n    margin-right: 5px;\n  }\n  select, button {\n    margin-right: 10px;\n    padding: 5px 10px;\n    font-size: 1rem;\n  }\n  #log {\n    margin-top: 20px;\n    max-height: 150px;\n    overflow-y: auto;\n    background: #f4f4f4;\n    border: 1px solid #ccc;\n    padding: 10px;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n  #info {\n    max-width: 600px;\n    margin-bottom: 15px;\n    line-height: 1.3;\n  }\n</style>\n</head>\n<body>\n<h1>Union-Find (Disjoint Set) Data Structure</h1>\n<p id=\"info\">\n  Click on elements to select them, then perform \"Union\" or \"Find\" operations.<br />\n  This structure keeps track of elements partitioned into disjoint sets.<br />\n  Each set is represented by a \"root\" element (parent pointer points to itself).<br />\n  This visualization shows parents by arrows and colors groups in distinct colors.\n</p>\n\n<div id=\"union-find\"></div>\n\n<div id=\"controls\">\n  <label for=\"operation\">Operation:</label>\n  <select id=\"operation\">\n    <option value=\"union\">Union</option>\n    <option value=\"find\">Find</option>\n  </select>\n\n  <label for=\"element1\">Element 1:</label>\n  <select id=\"element1\"></select>\n\n  <label for=\"element2\" id=\"element2-label\">Element 2:</label>\n  <select id=\"element2\"></select>\n\n  <button id=\"perform-btn\">Perform</button>\n  <button id=\"reset-btn\">Reset</button>\n</div>\n\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n  // Union-Find class with path compression and union by rank\n  class UnionFind {\n    constructor(n) {\n      this.n = n;\n      this.parent = new Array(n);\n      this.rank = new Array(n);\n      for (let i = 0; i < n; i++) {\n        this.parent[i] = i;\n        this.rank[i] = 0;\n      }\n    }\n    find(x) {\n      if (this.parent[x] !== x) {\n        this.parent[x] = this.find(this.parent[x]); // Path compression\n      }\n      return this.parent[x];\n    }\n    union(x, y) {\n      let rootX = this.find(x);\n      let rootY = this.find(y);\n      if (rootX === rootY) return false; // already connected\n      // Union by rank\n      if (this.rank[rootX] < this.rank[rootY]) {\n        this.parent[rootX] = rootY;\n      } else if (this.rank[rootX] > this.rank[rootY]) {\n        this.parent[rootY] = rootX;\n      } else {\n        this.parent[rootY] = rootX;\n        this.rank[rootX]++;\n      }\n      return true;\n    }\n  }\n\n  // Visualization and UI elements\n  const size = 10; // number of elements\n\n  const container = document.getElementById('union-find');\n  const element1Select = document.getElementById('element1');\n  const element2Select = document.getElementById('element2');\n  const operationSelect = document.getElementById('operation');\n  const performBtn = document.getElementById('perform-btn');\n  const resetBtn = document.getElementById('reset-btn');\n  const logDiv = document.getElementById('log');\n  const element2Label = document.getElementById('element2-label');\n\n  // Colors for groups, up to 20.\n  const groupColors = [\n    '#f28b82','#fbbc04','#fff475','#ccff90','#a7ffeb','#cbf0f8','#aecbfa','#d7aefb','#fdcfe8','#e6c9a8',\n    '#e8eaed', '#d7ccc8','#90a4ae','#ffab91','#f48fb1','#ce93d8','#b39ddb','#9fa8da','#80cbc4','#81d4fa'\n  ];\n\n  let uf;\n  let nodes = [];\n\n  // Initialize the UI selects\n  function initSelects() {\n    element1Select.innerHTML = '';\n    element2Select.innerHTML = '';\n    for (let i = 0; i < size; i++) {\n      const opt1 = document.createElement('option');\n      opt1.value = i;\n      opt1.textContent = i;\n      element1Select.appendChild(opt1);\n\n      const opt2 = document.createElement('option');\n      opt2.value = i;\n      opt2.textContent = i;\n      element2Select.appendChild(opt2);\n    }\n  }\n\n  // Initialize the nodes in the container\n  function initNodes() {\n    container.innerHTML = '';\n    nodes = [];\n    for (let i = 0; i < size; i++) {\n      const node = document.createElement('div');\n      node.className = 'node';\n      node.textContent = i;\n      node.dataset.index = i;\n      container.appendChild(node);\n      nodes.push(node);\n    }\n  }\n\n  // Draw arrows to parents (using SVG paths)\n  const svgNS = \"http://www.w3.org/2000/svg\";\n  // Create an SVG overlay\n  let svgOverlay = document.createElementNS(svgNS, \"svg\");\n  svgOverlay.style.position = \"absolute\";\n  svgOverlay.style.top = \"0\";\n  svgOverlay.style.left = \"0\";\n  svgOverlay.style.width = \"100%\";\n  svgOverlay.style.height = \"100%\";\n  svgOverlay.style.pointerEvents = \"none\";\n  svgOverlay.style.zIndex = \"0\";\n  document.body.appendChild(svgOverlay);\n\n  // We will update svg size on resize and re-render arrows\n  function resizeSVG() {\n    svgOverlay.style.width = window.innerWidth + \"px\";\n    svgOverlay.style.height = window.innerHeight + \"px\";\n  }\n  window.addEventListener('resize', () => {\n    resizeSVG();\n    renderArrows();\n  });\n  resizeSVG();\n\n  // For better visualization, we'll color groups differently and show parent arrows\n  function render() {\n    // Assign group roots and set colors accordingly\n    let groupMap = new Map();\n    let groupIndex = 0;\n\n    function getGroupColor(root) {\n      if (!groupMap.has(root)) {\n        groupMap.set(root, groupColors[groupIndex % groupColors.length]);\n        groupIndex++;\n      }\n      return groupMap.get(root);\n    }\n\n    for (let i = 0; i < size; i++) {\n      let root = uf.find(i);\n      let color = getGroupColor(root);\n      nodes[i].style.backgroundColor = color;\n      nodes[i].style.borderColor = shadeColor(color, -50);\n      nodes[i].title = `Element ${i}\\nParent: ${uf.parent[i]}\\nRoot: ${root}`;\n    }\n\n    renderArrows();\n  }\n\n  // Utility: shade color for border\n  function shadeColor(color, percent) {\n    // Assumes color in hex form #rrggbb\n    let f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent;\n    let R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;\n    return \"#\" + (0x1000000 +\n      (Math.round((t-R)*p/100)+R)*0x10000 +\n      (Math.round((t-G)*p/100)+G)*0x100 +\n      (Math.round((t-B)*p/100)+B)).toString(16).slice(1);\n  }\n\n  // Draw arrows between child and parent nodes\n  // We clear and redraw each time\n  function renderArrows() {\n    while (svgOverlay.firstChild) {\n      svgOverlay.removeChild(svgOverlay.firstChild);\n    }\n\n    for (let i = 0; i < size; i++) {\n      const p = uf.parent[i];\n      if (p !== i) {\n        const fromNode = nodes[i];\n        const toNode = nodes[p];\n        const fromRect = fromNode.getBoundingClientRect();\n        const toRect = toNode.getBoundingClientRect();\n\n        // Coordinates: center bottom of fromNode to center top of toNode\n        const startX = fromRect.left + fromRect.width / 2;\n        const startY = fromRect.top + fromRect.height;\n        const endX = toRect.left + toRect.width / 2;\n        const endY = toRect.top;\n\n        // Create an arrow path with a curve\n        let path = document.createElementNS(svgNS, 'path');\n        path.setAttribute('stroke', '#333');\n        path.setAttribute('fill', 'none');\n        path.setAttribute('stroke-width', '2');\n        path.setAttribute('marker-end', 'url(#arrowhead)');\n        // Simple quadratic bezier curve\n        const midX = (startX + endX) / 2;\n        const controlY = startY + 30;\n        const d = `M ${startX} ${startY} Q ${midX} ${controlY} ${endX} ${endY}`;\n        path.setAttribute('d', d);\n        svgOverlay.appendChild(path);\n      }\n    }\n  }\n\n  // Add marker definition for arrowhead to SVG\n  function addArrowMarker() {\n    const defs = document.createElementNS(svgNS, 'defs');\n    const marker = document.createElementNS(svgNS, 'marker');\n    marker.setAttribute('id', 'arrowhead');\n    marker.setAttribute('markerWidth', 10);\n    marker.setAttribute('markerHeight', 7);\n    marker.setAttribute('refX', 5);\n    marker.setAttribute('refY', 3.5);\n    marker.setAttribute('orient', 'auto');\n    marker.setAttribute('fill', '#333');\n\n    const polygon = document.createElementNS(svgNS, 'polygon');\n    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');\n    marker.appendChild(polygon);\n\n    defs.appendChild(marker);\n    svgOverlay.appendChild(defs);\n  }\n  addArrowMarker();\n\n  // Log operations\n  function log(msg) {\n    const timestamp = new Date().toLocaleTimeString();\n    logDiv.textContent += `[${timestamp}] ${msg}\\n`;\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Handle operation change: Find only needs one element, Union needs two\n  operationSelect.addEventListener('change', () => {\n    if (operationSelect.value === 'find') {\n      element2Select.style.display = 'none';\n      element2Label.style.display = 'none';\n    } else {\n      element2Select.style.display = '';\n      element2Label.style.display = '';\n    }\n  });\n\n  performBtn.addEventListener('click', () => {\n    const op = operationSelect.value;\n    const e1 = parseInt(element1Select.value);\n    const e2 = parseInt(element2Select.value);\n\n    if (isNaN(e1) || e1 < 0 || e1 >= size) {\n      alert('Invalid element 1');\n      return;\n    }\n\n    if (op === 'union') {\n      if (isNaN(e2) || e2 < 0 || e2 >= size) {\n        alert('Invalid element 2');\n        return;\n      }\n      if (e1 === e2) {\n        alert('Cannot union the same element.');\n        return;\n      }\n      let didUnion = uf.union(e1, e2);\n      if (didUnion) {\n        log(`Union(${e1}, ${e2}): Sets merged.`);\n      } else {\n        log(`Union(${e1}, ${e2}): Already in the same set.`);\n      }\n    } else if (op === 'find') {\n      let root = uf.find(e1);\n      log(`Find(${e1}): Root = ${root}`);\n      alert(`Root of element ${e1} is ${root}`);\n    }\n\n    render();\n  });\n\n  resetBtn.addEventListener('click', () => {\n    uf = new UnionFind(size);\n    logDiv.textContent = '';\n    render();\n  });\n\n  // Initialization\n  function init() {\n    uf = new UnionFind(size);\n    initSelects();\n    initNodes();\n    operationSelect.dispatchEvent(new Event('change'));\n    render();\n  }\n  init();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Union-Find (Disjoint Set)"
    }
  ],
  "topic": "Union-Find (Disjoint Set)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}