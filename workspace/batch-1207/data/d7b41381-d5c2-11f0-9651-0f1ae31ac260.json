{
  "id": "d7b41381-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:07.629Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Kruskal's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1rem;\n    background: #f0f2f5;\n  }\n  h1 {\n    text-align: center;\n    color: #333;\n  }\n  #graph-container {\n    display: flex;\n    justify-content: center;\n    margin: 1rem auto;\n    max-width: 800px;\n    position: relative;\n  }\n  svg {\n    border: 1px solid #ccc;\n    background: white;\n    border-radius: 8px;\n  }\n  .edge {\n    stroke: #999;\n    stroke-width: 2px;\n    cursor: pointer;\n  }\n  .edge.in-forest {\n    stroke: #27ae60;\n    stroke-width: 4px;\n  }\n  .edge.checked {\n    stroke-dasharray: 6 4;\n  }\n  .edge-text {\n    font-size: 14px;\n    fill: #222;\n    pointer-events: none;\n    user-select: none;\n  }\n  .node {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 2px;\n    cursor: default;\n  }\n  .node-text {\n    fill: white;\n    font-weight: bold;\n    user-select: none;\n    pointer-events: none;\n  }\n  #controls {\n    text-align: center;\n    margin: 1rem 0;\n  }\n  button {\n    background: #2980b9;\n    color: white;\n    border: none;\n    padding: 0.6rem 1rem;\n    margin: 0 0.5rem;\n    font-size: 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  button:disabled {\n    background: #bbb;\n    cursor: default;\n  }\n  #log {\n    max-width: 800px;\n    margin: 1rem auto;\n    background: #fff;\n    border: 1px solid #ccc;\n    padding: 0.8rem;\n    height: 150px;\n    overflow-y: auto;\n    font-family: monospace;\n    white-space: pre-wrap;\n    border-radius: 6px;\n  }\n</style>\n</head>\n<body>\n<h1>Kruskal's Algorithm Visualization</h1>\n<div id=\"graph-container\">\n  <svg id=\"graph\" width=\"700\" height=\"500\"></svg>\n</div>\n<div id=\"controls\">\n  <button id=\"step-btn\">Next Step</button>\n  <button id=\"reset-btn\">Reset</button>\n</div>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n  /*\n    We will visualize Kruskal's Algorithm step-by-step on a fixed weighted undirected graph.\n    Nodes placed in static positions.\n    Edges sorted by weight, each step tries to add next edge without creating cycle.\n  */\n\n  const svg = document.getElementById('graph');\n  const stepBtn = document.getElementById('step-btn');\n  const resetBtn = document.getElementById('reset-btn');\n  const log = document.getElementById('log');\n\n  // Graph data: nodes with x,y positions; edges with weights\n  // This is an example graph with 7 nodes.\n  const nodes = [\n    {id: 'A', x: 100, y: 100},\n    {id: 'B', x: 300, y: 80},\n    {id: 'C', x: 500, y: 100},\n    {id: 'D', x: 600, y: 300},\n    {id: 'E', x: 400, y: 350},\n    {id: 'F', x: 200, y: 300},\n    {id: 'G', x: 350, y: 200}\n  ];\n\n  const edges = [\n    {id: 'AB', from: 'A', to: 'B', weight: 7},\n    {id: 'AC', from: 'A', to: 'C', weight: 9},\n    {id: 'AF', from: 'A', to: 'F', weight: 14},\n    {id: 'BC', from: 'B', to: 'C', weight: 10},\n    {id: 'BG', from: 'B', to: 'G', weight: 15},\n    {id: 'CG', from: 'C', to: 'G', weight: 11},\n    {id: 'CF', from: 'C', to: 'F', weight: 2},\n    {id: 'GF', from: 'G', to: 'F', weight: 9},\n    {id: 'ED', from: 'E', to: 'D', weight: 6},\n    {id: 'FE', from: 'F', to: 'E', weight: 9},\n    {id: 'GD', from: 'G', to: 'D', weight: 7}\n  ];\n\n  // Sort edges by ascending weight for Kruskal\n  const edgesSorted = [...edges].sort((a,b) => a.weight - b.weight);\n\n  // Disjoint Set (Union-Find) to detect cycles\n  class DisjointSet {\n    constructor(elements) {\n      this.parent = {};\n      this.rank = {};\n      elements.forEach(el => {\n        this.parent[el] = el;\n        this.rank[el] = 0;\n      });\n    }\n    find(x) {\n      if (this.parent[x] !== x) {\n        this.parent[x] = this.find(this.parent[x]);\n      }\n      return this.parent[x];\n    }\n    union(x, y) {\n      const rootX = this.find(x);\n      const rootY = this.find(y);\n      if(rootX === rootY) return false;\n      if(this.rank[rootX] < this.rank[rootY]) {\n        this.parent[rootX] = rootY;\n      } else if(this.rank[rootX] > this.rank[rootY]) {\n        this.parent[rootY] = rootX;\n      } else {\n        this.parent[rootY] = rootX;\n        this.rank[rootX]++;\n      }\n      return true;\n    }\n  }\n\n  // State for algorithm\n  let ds;\n  let stepIndex = 0;\n  let mstEdges = [];\n\n  // Keep track of SVG elements for interaction\n  let edgeElements = new Map();\n\n  // Drawing functions\n  function createEdgeLine(edge) {\n    const fromNode = nodes.find(n=>n.id === edge.from);\n    const toNode = nodes.find(n=>n.id === edge.to);\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1', fromNode.x);\n    line.setAttribute('y1', fromNode.y);\n    line.setAttribute('x2', toNode.x);\n    line.setAttribute('y2', toNode.y);\n    line.setAttribute('class', 'edge');\n    line.setAttribute('id', edge.id);\n    line.setAttribute('tabindex', '0');\n    line.setAttribute('aria-label', `Edge ${edge.from} to ${edge.to}, weight ${edge.weight}`);\n    return line;\n  }\n  function createEdgeLabel(edge) {\n    const fromNode = nodes.find(n=>n.id === edge.from);\n    const toNode = nodes.find(n=>n.id === edge.to);\n    const midX = (fromNode.x + toNode.x)/2;\n    const midY = (fromNode.y + toNode.y)/2;\n    const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n    text.setAttribute('x', midX);\n    text.setAttribute('y', midY - 5);\n    text.setAttribute('class', 'edge-text');\n    text.textContent = edge.weight;\n    return text;\n  }\n  function createNodeCircle(node) {\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('cx', node.x);\n    circle.setAttribute('cy', node.y);\n    circle.setAttribute('r', 20);\n    circle.setAttribute('class', 'node');\n    circle.setAttribute('id', 'node-' + node.id);\n    circle.setAttribute('aria-label', `Node ${node.id}`);\n    return circle;\n  }\n  function createNodeLabel(node) {\n    const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n    text.setAttribute('x', node.x);\n    text.setAttribute('y', node.y + 6);\n    text.setAttribute('class', 'node-text');\n    text.setAttribute('text-anchor', 'middle');\n    text.textContent = node.id;\n    return text;\n  }\n\n  function clearGraph() {\n    while(svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    edgeElements.clear();\n  }\n\n  function drawGraph() {\n    clearGraph();\n\n    // Draw edges first (under nodes)\n    edges.forEach(edge => {\n      const line = createEdgeLine(edge);\n      svg.appendChild(line);\n      const label = createEdgeLabel(edge);\n      svg.appendChild(label);\n      edgeElements.set(edge.id, line);\n    });\n\n    // Draw nodes on top\n    nodes.forEach(node => {\n      const circle = createNodeCircle(node);\n      svg.appendChild(circle);\n      const label = createNodeLabel(node);\n      svg.appendChild(label);\n    });\n  }\n\n  function logMessage(msg) {\n    log.textContent += msg + \"\\n\";\n    log.scrollTop = log.scrollHeight;\n  }\n\n  function reset() {\n    ds = new DisjointSet(nodes.map(n=>n.id));\n    stepIndex = 0;\n    mstEdges = [];\n    drawGraph();\n    log.textContent = '';\n    stepBtn.disabled = false;\n    logMessage(\"Algorithm reset. Ready to run Kruskal's Algorithm.\");\n  }\n\n  function step() {\n    if(stepIndex >= edgesSorted.length) {\n      logMessage(\"All edges processed. Algorithm complete.\");\n      stepBtn.disabled = true;\n      return;\n    }\n\n    const edge = edgesSorted[stepIndex];\n    stepIndex++;\n\n    const line = edgeElements.get(edge.id);\n    // Mark this edge as checked: dashed line\n    line.classList.add('checked');\n\n    logMessage(`Considering edge (${edge.from} - ${edge.to}) with weight ${edge.weight}.`);\n\n    if(ds.union(edge.from, edge.to)){\n      // Edge added to MST\n      mstEdges.push(edge);\n      line.classList.add('in-forest');\n      logMessage(`Edge added to MST.`);\n    } else {\n      logMessage(`Edge creates a cycle and is skipped.`);\n    }\n\n    // After processing last edge or when MST has n-1 edges, disable step\n    if(mstEdges.length === nodes.length - 1) {\n      logMessage(\"Minimum Spanning Tree completed!\");\n      stepBtn.disabled = true;\n    }\n  }\n\n  stepBtn.addEventListener('click', ()=> {\n    step();\n  });\n\n  resetBtn.addEventListener('click', () => {\n    reset();\n  });\n\n  // Initial draw\n  reset();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}