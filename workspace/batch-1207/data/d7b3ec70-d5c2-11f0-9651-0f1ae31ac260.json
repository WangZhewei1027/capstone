{
  "id": "d7b3ec70-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:36.276Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    margin: 0;\n    font-family: Arial, sans-serif;\n    display: flex; flex-direction: column; align-items: center; background: #f0f0f0;\n    height: 100vh;\n  }\n  h1 {\n    margin: 20px;\n    color: #333;\n  }\n  #graphCanvas {\n    background: white;\n    border: 1px solid #ccc;\n    margin-bottom: 10px;\n    max-width: 90vw;\n    max-height: 70vh;\n  }\n  #controls {\n    margin-bottom: 20px;\n  }\n  button, select, input {\n    font-size: 1rem;\n    margin-right: 10px;\n    padding: 6px 12px;\n    border-radius: 4px;\n    border: 1px solid #bbb;\n    cursor: pointer;\n  }\n  button:disabled {\n    background: #ddd;\n    cursor: not-allowed;\n  }\n  #log {\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    padding: 10px;\n    width: 90vw;\n    max-width: 960px;\n    height: 150px;\n    overflow-y: auto;\n    border-radius: 6px;\n    box-sizing: border-box;\n  }\n  #info {\n    max-width: 90vw;\n    width: 960px;\n    color: #555;\n    margin-bottom: 10px;\n  }\n</style>\n</head>\n<body>\n<h1>Breadth-First Search (BFS) Visualization</h1>\n\n<div id=\"info\">\n  <p>Select start node and end node, then run BFS to see step-by-step traversal.</p>\n  <p>Blue nodes: Not visited; Green: Visited (discovered); Red border: Currently processing.</p>\n  <p>Edges highlight in orange when traversed.</p>\n</div>\n\n<canvas id=\"graphCanvas\" width=\"960\" height=\"540\"></canvas>\n\n<div id=\"controls\">\n  <label for=\"startNode\">Start Node:</label>\n  <select id=\"startNode\"></select>\n\n  <label for=\"endNode\">End Node (optional):</label>\n  <select id=\"endNode\">\n    <option value=\"\">- None -</option>\n  </select>\n\n  <button id=\"startBtn\">Start BFS</button>\n  <button id=\"resetBtn\" disabled>Reset</button>\n  <button id=\"stepBtn\" disabled>Step</button>\n  <button id=\"runBtn\" disabled>Run Automatically</button>\n</div>\n\n<div id=\"log\"></div>\n\n<script>\n(() => {\n\n  // Graph data structure\n  // Undirected graph example\n  const nodes = [\n    { id: 'A', x: 150, y: 100 },\n    { id: 'B', x: 350, y: 70 },\n    { id: 'C', x: 550, y: 100 },\n    { id: 'D', x: 700, y: 250 },\n    { id: 'E', x: 550, y: 400 },\n    { id: 'F', x: 350, y: 430 },\n    { id: 'G', x: 150, y: 400 },\n    { id: 'H', x: 50, y: 250 },\n    { id: 'I', x: 400, y: 250 },\n  ];\n\n  // adjacency list\n  const edges = {\n    A: ['B', 'H'],\n    B: ['A', 'C', 'I'],\n    C: ['B', 'D', 'E'],\n    D: ['C', 'E'],\n    E: ['C', 'D', 'F'],\n    F: ['E', 'G', 'I'],\n    G: ['F', 'H'],\n    H: ['A', 'G'],\n    I: ['B', 'F'],\n  };\n\n  // Canvas Setup\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const radius = 25;\n\n  // HTML Controls\n  const startNodeSelect = document.getElementById('startNode');\n  const endNodeSelect = document.getElementById('endNode');\n  const startBtn = document.getElementById('startBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const logDiv = document.getElementById('log');\n\n  // BFS state variables\n  let visited = {};\n  let queue = [];\n  let stepCount = 0;\n  let currentNode = null;\n  let parent = {};\n  let traversalEdges = []; // edges that were traversed during BFS\n  let bfsDone = false;\n  let findEndNode = false;\n  let pathToEnd = [];\n  let runInterval = null;\n\n  // Utility functions\n  function log(msg) {\n    logDiv.innerHTML += msg + '\\n';\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n  function clearLog() {\n    logDiv.textContent = '';\n  }\n\n  function drawNode(nodeId, options = {}) {\n    const node = nodes.find(n => n.id === nodeId);\n    if(!node) return;\n    const { x, y } = node;\n\n    const {\n      fillColor = '#337ab7', // default blue\n      strokeColor = '#222',\n      strokeWidth = 2,\n      textColor = 'white',\n      borderHighlight = false,\n      borderColor = '#d9534f',\n      borderWidth = 3,\n    } = options;\n\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    ctx.lineWidth = borderHighlight ? borderWidth : strokeWidth;\n    ctx.strokeStyle = borderHighlight ? borderColor : strokeColor;\n    ctx.stroke();\n\n    ctx.fillStyle = textColor;\n    ctx.font = 'bold 18px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(nodeId, x, y);\n  }\n\n  function edgeBetween(n1, n2) {\n    // normalize edge as string for easy matching and avoiding duplicates\n    return [n1, n2].sort().join('-');\n  }\n\n  function drawEdge(n1, n2, options = {}) {\n    const node1 = nodes.find(n => n.id === n1);\n    const node2 = nodes.find(n => n.id === n2);\n    if(!node1 || !node2) return;\n\n    const {\n      color = '#999',\n      width = 2,\n      highlight = false,\n      highlightColor = '#f0ad4e'\n    } = options;\n\n    ctx.beginPath();\n    ctx.moveTo(node1.x, node1.y);\n    ctx.lineTo(node2.x, node2.y);\n    ctx.strokeStyle = highlight ? highlightColor : color;\n    ctx.lineWidth = highlight ? 4 : width;\n    ctx.stroke();\n  }\n\n  // Redraw everything\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // draw edges first\n    for(const from in edges) {\n      for(const to of edges[from]) {\n        // To avoid drawing edges twice\n        if (from < to) {\n          const edgeKey = edgeBetween(from, to);\n          const traversed = traversalEdges.includes(edgeKey);\n          drawEdge(from, to, {highlight: traversed});\n        }\n      }\n    }\n\n    // draw nodes\n    for(const node of nodes) {\n      const id = node.id;\n      if (id === currentNode) {\n        // currently processing node - red border and green fill\n        drawNode(id, {fillColor: '#5cb85c', borderHighlight: true});\n      } else if (visited[id]) {\n        // visited = green fill\n        drawNode(id, {fillColor: '#5cb85c'});\n      } else {\n        // not visited = blue fill\n        drawNode(id);\n      }\n    }\n\n    // Highlight final path if found\n    if(pathToEnd.length > 1) {\n      for(let i = 0; i < pathToEnd.length - 1; i++) {\n        drawEdge(pathToEnd[i], pathToEnd[i+1], {color:'#d9534f', width: 5, highlight: true, highlightColor:'#d9534f'});\n      }\n      // Redraw nodes on top with a different color\n      for(const nodeId of pathToEnd) {\n        drawNode(nodeId, {fillColor:'#d9534f'});\n      }\n    }\n  }\n\n  // BFS step function\n  function bfsStep() {\n    if(queue.length === 0) {\n      log('Queue empty. BFS finished.');\n      bfsDone = true;\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n      return;\n    }\n\n    currentNode = queue.shift();\n    log(`Dequeued: ${currentNode}`);\n    drawGraph();\n    stepCount++;\n\n    // If looking for an end node\n    if(findEndNode && currentNode === endNodeSelect.value) {\n      log(`End node ${currentNode} found!`);\n      // Build path\n      pathToEnd = [];\n      let cur = currentNode;\n      while(cur) {\n        pathToEnd.push(cur);\n        cur = parent[cur];\n      }\n      pathToEnd.reverse();\n      bfsDone = true;\n      drawGraph();\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n      return;\n    }\n\n    for(const neighbor of edges[currentNode]) {\n      if(!visited[neighbor]) {\n        visited[neighbor] = true;\n        parent[neighbor] = currentNode;\n        queue.push(neighbor);\n        const edgeKey = edgeBetween(currentNode, neighbor);\n        traversalEdges.push(edgeKey);\n        log(`Visited ${neighbor}, added to queue.`);\n      }\n    }\n\n    drawGraph();\n\n    if(queue.length === 0) {\n      log('Queue empty. BFS finished.');\n      bfsDone = true;\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n    }\n  }\n\n  // Initialize selects and state\n  function init() {\n    for(const node of nodes) {\n      const option1 = document.createElement('option');\n      option1.value = node.id;\n      option1.textContent = node.id;\n      startNodeSelect.appendChild(option1);\n\n      const option2 = document.createElement('option');\n      option2.value = node.id;\n      option2.textContent = node.id;\n      endNodeSelect.appendChild(option2);\n    }\n    startNodeSelect.value = nodes[0].id;\n    endNodeSelect.value = \"\";\n\n    resetState();\n    drawGraph();\n  }\n\n  function resetState() {\n    visited = {};\n    queue = [];\n    stepCount = 0;\n    currentNode = null;\n    parent = {};\n    traversalEdges = [];\n    bfsDone = false;\n    pathToEnd = [];\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    resetBtn.disabled = true;\n    startBtn.disabled = false;\n    clearLog();\n    drawGraph();\n    if(runInterval) {\n      clearInterval(runInterval);\n      runInterval = null;\n    }\n  }\n\n  // Start BFS initialization\n  function startBFS() {\n    resetState();\n    const startNode = startNodeSelect.value;\n    const endNode = endNodeSelect.value;\n    findEndNode = endNode !== \"\";\n    visited[startNode] = true;\n    queue.push(startNode);\n    parent[startNode] = null;\n    log(`Start BFS at node ${startNode}${findEndNode ? `, searching for end node ${endNode}` : ''}.`);\n\n    stepBtn.disabled = false;\n    runBtn.disabled = false;\n    resetBtn.disabled = false;\n    startBtn.disabled = true;\n\n    drawGraph();\n  }\n\n  // Run BFS automatically steps\n  function runAutomatically() {\n    if(bfsDone) return;\n    runBtn.disabled = true;\n    stepBtn.disabled = true;\n    runInterval = setInterval(() => {\n      if(bfsDone) {\n        clearInterval(runInterval);\n        runInterval = null;\n        runBtn.disabled = true;\n        stepBtn.disabled = true;\n        return;\n      }\n      bfsStep();\n    }, 800);\n  }\n\n  startBtn.addEventListener('click', startBFS);\n  stepBtn.addEventListener('click', () => {\n    if(!bfsDone) bfsStep();\n    if(bfsDone) {\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n    }\n  });\n  resetBtn.addEventListener('click', () => {\n    resetState();\n  });\n  runBtn.addEventListener('click', () => {\n    runAutomatically();\n  });\n\n  // Draw initial graph on load\n  init();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}