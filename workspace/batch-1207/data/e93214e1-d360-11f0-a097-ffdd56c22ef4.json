{
  "id": "e93214e1-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:25.610Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Stack",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Stack Visualization & Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#3b82f6;\n      --accent-2:#06b6d4;\n      --muted:#94a3b8;\n      --success:#10b981;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{background:linear-gradient(180deg,#071025 0%, #07182a 60%); color:#e6eef8; display:flex; align-items:flex-start; justify-content:center; padding:28px;}\n    .container{width:1100px;max-width:96%; display:grid; grid-template-columns:360px 1fr; gap:22px;}\n    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; box-shadow: 0 6px 30px rgba(2,6,23,0.6);}\n    h1{margin:0 0 8px;font-size:18px;}\n    p.desc{margin:8px 0 12px;color:var(--muted);font-size:13px;line-height:1.3;}\n    .controls{display:flex;flex-direction:column;gap:10px;}\n    .row{display:flex;gap:8px;align-items:center;}\n    input[type=\"text\"], input[type=\"number\"], select{\n      background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:8px 10px; border-radius:8px; outline:none; width:100%;\n    }\n    button{\n      background:linear-gradient(180deg,var(--accent), #2563eb);\n      color:white; border:0; padding:9px 12px; border-radius:8px; cursor:pointer; font-weight:600;\n      box-shadow: 0 6px 18px rgba(59,130,246,0.12);\n    }\n    button.alt{background:linear-gradient(180deg,#111827,#0b1220); border:1px solid rgba(255,255,255,0.03);}\n    button.warn{background:linear-gradient(180deg,var(--danger), #dc2626);}\n    .muted{color:var(--muted); font-size:13px;}\n    .visual{\n      padding:18px; display:flex; gap:18px; align-items:flex-start; min-height:420px;\n    }\n    .stack-viewport{\n      width:180px; min-height:320px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015)); border-radius:10px; padding:12px; border:1px dashed rgba(255,255,255,0.03);\n      display:flex; flex-direction:column; align-items:center; position:relative;\n    }\n    .stack-title{font-size:13px;color:var(--muted); margin-bottom:6px;}\n    .stack-container{display:flex; flex-direction:column-reverse; gap:8px; width:100%; align-items:center; padding:6px;}\n    .slot{\n      width:100%; height:44px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03);\n      display:flex; align-items:center; justify-content:center; color:#dbeafe; font-weight:700; letter-spacing:0.6px; position:relative; overflow:hidden;\n      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .25s ease;\n    }\n    .slot.empty{color:var(--muted); font-weight:600; background:transparent; border:1px dashed rgba(255,255,255,0.02);}\n    .slot.top{box-shadow:inset 0 1px 0 rgba(255,255,255,0.03), 0 6px 18px rgba(59,130,246,0.08); border:1px solid rgba(59,130,246,0.18); background:linear-gradient(180deg, rgba(59,130,246,0.08), rgba(59,130,246,0.03));}\n    .label-top{position:absolute; top:8px; left:12px; font-size:12px; color:var(--muted);}\n    .array-view{\n      flex:1; min-height:320px; padding:12px; background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); border-radius:8px; border:1px solid rgba(255,255,255,0.02);\n      overflow:auto;\n    }\n    .array-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}\n    .cell{\n      width:72px; height:56px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03);\n      display:flex; flex-direction:column; align-items:center; justify-content:center; color:#bfe0ff; font-weight:700; position:relative;\n      transition:transform .25s ease, box-shadow .2s;\n    }\n    .cell.index{font-size:11px; color:var(--muted); position:absolute; top:6px; right:6px; font-weight:600;}\n    .cell.empty{color:var(--muted); font-weight:600; background:transparent; border:1px dashed rgba(255,255,255,0.02);}\n    .cell.top{box-shadow:0 10px 30px rgba(59,130,246,0.06); border:1px solid rgba(59,130,246,0.14);}\n    .log{margin-top:12px; max-height:120px; overflow:auto; font-size:13px; color:var(--muted); background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; border:1px dashed rgba(255,255,255,0.02);}\n    .status{display:flex; gap:8px; align-items:center; margin-top:8px;}\n    .pill{padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--muted); border:1px solid rgba(255,255,255,0.02); font-weight:600;}\n    .hint{font-size:12px;color:var(--muted); margin-top:10px;}\n    .small{font-size:13px;color:var(--muted);}\n    .controls .row > * {flex:1;}\n    .sequence-input{height:44px;}\n    footer{margin-top:12px;color:var(--muted);font-size:13px;}\n    .danger-text{color:var(--danger); font-weight:700;}\n    /* animation classes */\n    .anim-push{transform: translateY(-10px) scale(1.02); opacity:0; animation:pushIn .32s forwards;}\n    .anim-pop{transform:translateY(0) scale(1); animation:popOut .28s forwards;}\n    @keyframes pushIn{\n      0%{transform: translateY(-40px) scale(.95); opacity:0;}\n      100%{transform: translateY(0) scale(1); opacity:1;}\n    }\n    @keyframes popOut{\n      0%{transform: translateY(0) scale(1); opacity:1;}\n      100%{transform: translateY(-30px) scale(.95); opacity:0;}\n    }\n    .controls .small-note{font-size:12px;color:var(--muted); margin-left:6px;}\n    .grid-two{display:grid;grid-template-columns:1fr 1fr;gap:8px;}\n  </style>\n</head>\n<body>\n  <main class=\"container\">\n    <section class=\"card\">\n      <h1>Stack — push, pop, peek</h1>\n      <p class=\"desc\">This interactive demo shows a stack (LIFO — Last In First Out). Try pushing values, popping, peeking, and run sequences. The visualization shows the stack vertically and the underlying array with indices.</p>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <input id=\"valueInput\" type=\"text\" placeholder=\"Value to push (any text)\" />\n          <button id=\"pushBtn\">Push</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"popBtn\" class=\"alt\">Pop</button>\n          <button id=\"peekBtn\" class=\"alt\">Peek</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"clearBtn\" class=\"alt\">Clear</button>\n          <button id=\"isEmptyBtn\" class=\"alt\">Is Empty?</button>\n        </div>\n\n        <div class=\"row\">\n          <input id=\"capacityInput\" type=\"number\" min=\"0\" placeholder=\"Optional capacity (0 = unlimited)\" />\n          <button id=\"setCapBtn\" class=\"alt\">Set Capacity</button>\n        </div>\n\n        <div class=\"row\">\n          <input id=\"fillCount\" type=\"number\" min=\"1\" placeholder=\"Random fill count\" />\n          <button id=\"fillBtn\" class=\"alt\">Fill Random</button>\n        </div>\n\n        <div style=\"display:flex; gap:8px;\">\n          <button id=\"exampleSeqBtn\" class=\"alt\">Load Example Sequence</button>\n          <button id=\"runSeqBtn\">Run Sequence</button>\n        </div>\n\n        <textarea id=\"sequenceInput\" class=\"sequence-input\" placeholder=\"Sequence (one command per line). Commands: push <value>, pop, peek, clear, wait <ms>. Example:&#10;push apple&#10;push banana&#10;pop&#10;peek\" ></textarea>\n\n        <div class=\"status\">\n          <div class=\"pill\">Size: <span id=\"sizeLabel\">0</span></div>\n          <div class=\"pill\">Top index: <span id=\"topLabel\">-1</span></div>\n          <div class=\"pill\">Capacity: <span id=\"capLabel\">∞</span></div>\n        </div>\n\n        <div class=\"hint\">Tip: Use \"wait <ms>\" in a sequence to pause between operations (e.g., wait 500).</div>\n      </div>\n\n      <div class=\"log\" id=\"logArea\" aria-live=\"polite\"></div>\n      <footer>\n        Time complexity: push/pop O(1) average. This demo uses an array internally and supports optional fixed capacity to model overflow.\n      </footer>\n    </section>\n\n    <section class=\"card\">\n      <div class=\"visual\">\n        <div class=\"stack-viewport\" aria-hidden=\"false\">\n          <div class=\"stack-title\">Stack (Top at top)</div>\n          <div class=\"label-top\">Top</div>\n          <div class=\"stack-container\" id=\"stackContainer\" role=\"list\"></div>\n        </div>\n\n        <div class=\"array-view\">\n          <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n            <div style=\"font-weight:700;\">Underlying array (index -> value)</div>\n            <div class=\"small\">Empty cells are dashed</div>\n          </div>\n          <div id=\"arrayRow\" class=\"array-row\" style=\"margin-top:12px;\"></div>\n\n          <div class=\"small\" style=\"margin-top:12px;\">Operation log (most recent at bottom):</div>\n          <div id=\"opLog\" class=\"log\"></div>\n        </div>\n      </div>\n    </section>\n  </main>\n\n  <script>\n    // Stack implementation with visualization hooks.\n    class Stack {\n      constructor(capacity = 0) {\n        this._arr = [];       // underlying array\n        this._top = -1;       // top index\n        this.capacity = capacity || 0; // 0 means unlimited\n      }\n\n      push(value) {\n        if (this.capacity > 0 && this._arr.length >= this.capacity) {\n          throw new Error('Stack overflow: capacity reached');\n        }\n        this._arr.push(value);\n        this._top = this._arr.length - 1;\n        return this._top;\n      }\n\n      pop() {\n        if (this.isEmpty()) {\n          throw new Error('Stack underflow: stack is empty');\n        }\n        const val = this._arr.pop();\n        this._top = this._arr.length - 1;\n        return val;\n      }\n\n      peek() {\n        if (this.isEmpty()) {\n          throw new Error('Stack is empty');\n        }\n        return this._arr[this._top];\n      }\n\n      size() {\n        return this._arr.length;\n      }\n\n      isEmpty() {\n        return this._arr.length === 0;\n      }\n\n      clear() {\n        this._arr.length = 0;\n        this._top = -1;\n      }\n\n      elements() {\n        // return a shallow copy for safe rendering\n        return this._arr.slice();\n      }\n    }\n\n    // UI Elements\n    const valueInput = document.getElementById('valueInput');\n    const pushBtn = document.getElementById('pushBtn');\n    const popBtn = document.getElementById('popBtn');\n    const peekBtn = document.getElementById('peekBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const isEmptyBtn = document.getElementById('isEmptyBtn');\n    const capacityInput = document.getElementById('capacityInput');\n    const setCapBtn = document.getElementById('setCapBtn');\n    const fillCount = document.getElementById('fillCount');\n    const fillBtn = document.getElementById('fillBtn');\n    const stackContainer = document.getElementById('stackContainer');\n    const arrayRow = document.getElementById('arrayRow');\n    const sizeLabel = document.getElementById('sizeLabel');\n    const topLabel = document.getElementById('topLabel');\n    const capLabel = document.getElementById('capLabel');\n    const logArea = document.getElementById('logArea');\n    const opLog = document.getElementById('opLog');\n    const sequenceInput = document.getElementById('sequenceInput');\n    const exampleSeqBtn = document.getElementById('exampleSeqBtn');\n    const runSeqBtn = document.getElementById('runSeqBtn');\n\n    // Initialize stack\n    const stack = new Stack(0);\n    updateUI();\n\n    function log(message, isError = false) {\n      const time = new Date().toLocaleTimeString();\n      const el = document.createElement('div');\n      el.textContent = `[${time}] ${message}`;\n      if (isError) el.style.color = 'var(--danger)';\n      logArea.appendChild(el);\n      logArea.scrollTop = logArea.scrollHeight;\n\n      const op = document.createElement('div');\n      op.textContent = message;\n      opLog.appendChild(op);\n      opLog.scrollTop = opLog.scrollHeight;\n    }\n\n    function updateUI(animType) {\n      // Update labels\n      sizeLabel.textContent = stack.size();\n      topLabel.textContent = stack.size() - 1;\n      capLabel.textContent = stack.capacity > 0 ? stack.capacity : '∞';\n\n      // Render stack vertical slots (show max of current size or a minimum number)\n      const displayCount = Math.max(6, stack.size()); // always show at least 6 slots for context\n      stackContainer.innerHTML = '';\n      // Build slots bottom-up (we use column-reverse styling, so iterate low->high)\n      for (let i = 0; i < displayCount; i++) {\n        const slot = document.createElement('div');\n        slot.className = 'slot empty';\n        const realIndex = i; // 0 is bottom as we render reversed via CSS\n        // compute corresponding stack index from bottom: bottom index is 0; top index is size-1\n        const arrIndex = realIndex; // since container is column-reverse, the visual top corresponds to last element\n        const fromTopIndex = displayCount - 1 - i; // not used directly\n        // We want to show top at top — easier: render actual stack values into slots from top downward\n        // Instead, rebuild using stack elements directly:\n        stackContainer.innerHTML = ''; // we'll rebuild differently\n        break;\n      }\n\n      // Rebuild slots properly: top at top\n      const values = stack.elements();\n      const minSlots = 6;\n      const totalSlots = Math.max(minSlots, values.length);\n      // We want top at top; CSS uses column-reverse, so append from bottom to top\n      for (let i = 0; i < totalSlots; i++) {\n        const slot = document.createElement('div');\n        // index from bottom: 0..totalSlots-1\n        const fromBottom = i;\n        slot.className = 'slot';\n        // map to value index: top is values.length-1 -> should be first visually. Since column-reverse,\n        // we need to append from bottom to top: so bottom should be index 0 into values.\n        const valueIndex = fromBottom; // bottom corresponds to values[0]\n        if (valueIndex < values.length) {\n          slot.textContent = values[valueIndex];\n          if (valueIndex === values.length - 1) slot.classList.add('top');\n          else slot.classList.remove('empty');\n        } else {\n          slot.textContent = '';\n          slot.classList.add('empty');\n        }\n        // Add animation classes if provided\n        stackContainer.appendChild(slot);\n      }\n\n      // Add a \"Top\" label at the visual topmost slot\n      const topLabels = stackContainer.querySelectorAll('.label-top');\n      // ensure top visual marking\n      Array.from(stackContainer.children).forEach((el, idx) => {\n        el.style.order = ''; // reset\n      });\n\n      // Highlight the top slot visually (top value is last element). Top in DOM is last child because column-reverse\n      // Use CSS class .top already set.\n\n      // Render array view horizontally: indices and values\n      arrayRow.innerHTML = '';\n      const arrValues = stack.elements();\n      const arrDisplayCount = Math.max(8, arrValues.length); // show at least 8 cells for context\n      for (let i = 0; i < arrDisplayCount; i++) {\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        const idx = document.createElement('div');\n        idx.className = 'index';\n        idx.textContent = i;\n        const val = document.createElement('div');\n        if (i < arrValues.length) {\n          val.textContent = arrValues[i];\n          cell.classList.add('cell-filled');\n          if (i === arrValues.length - 1) cell.classList.add('top');\n        } else {\n          val.textContent = '';\n          cell.classList.add('empty');\n        }\n        cell.appendChild(idx);\n        cell.appendChild(val);\n        arrayRow.appendChild(cell);\n      }\n\n      // Brief visual feedback if animType set\n      if (animType === 'push') {\n        // animate the top slot with .anim-push\n        const slots = stackContainer.querySelectorAll('.slot');\n        // The top value is the last filled slot: find last non-empty\n        for (let i = slots.length - 1; i >= 0; i--) {\n          if (!slots[i].classList.contains('empty')) {\n            slots[i].classList.add('anim-push');\n            setTimeout(()=>slots[i].classList.remove('anim-push'), 700);\n            break;\n          }\n        }\n      } else if (animType === 'pop') {\n        // animate the slot that was removed: we can mark the first empty from top\n        const slots = stackContainer.querySelectorAll('.slot');\n        // find the first empty from top (last element visually)\n        for (let i = slots.length - 1; i >= 0; i--) {\n          if (slots[i].classList.contains('empty')) {\n            // animate the one below it (the one that was popped)\n            if (i - 1 >= 0) {\n              const popped = slots[i - 1];\n              popped.classList.add('anim-pop');\n              setTimeout(()=>popped.classList.remove('anim-pop'), 400);\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    // Hook up buttons\n    pushBtn.addEventListener('click', () => {\n      const v = valueInput.value.trim();\n      if (v === '') {\n        valueInput.focus();\n        return;\n      }\n      try {\n        stack.push(v);\n        log(`push(\"${v}\")`);\n        updateUI('push');\n        valueInput.value = '';\n        valueInput.focus();\n      } catch (e) {\n        log(e.message, true);\n        flashCapacity();\n      }\n    });\n\n    popBtn.addEventListener('click', () => {\n      try {\n        const v = stack.pop();\n        log(`pop() -> \"${v}\"`);\n        updateUI('pop');\n      } catch (e) {\n        log(e.message, true);\n      }\n    });\n\n    peekBtn.addEventListener('click', () => {\n      try {\n        const v = stack.peek();\n        log(`peek() -> \"${v}\"`);\n        // small visual highlight: briefly add class to top cell\n        const slots = stackContainer.querySelectorAll('.slot');\n        for (let i = slots.length - 1; i >= 0; i--) {\n          if (!slots[i].classList.contains('empty')) {\n            slots[i].style.boxShadow = '0 10px 30px rgba(8,145,178,0.12)';\n            setTimeout(()=>slots[i].style.boxShadow = '', 500);\n            break;\n          }\n        }\n      } catch (e) {\n        log(e.message, true);\n      }\n    });\n\n    clearBtn.addEventListener('click', () => {\n      stack.clear();\n      log('clear() -> stack emptied');\n      updateUI();\n    });\n\n    isEmptyBtn.addEventListener('click', () => {\n      const res = stack.isEmpty();\n      log(`isEmpty() -> ${res}`);\n    });\n\n    setCapBtn.addEventListener('click', () => {\n      const n = parseInt(capacityInput.value, 10);\n      if (isNaN(n) || n < 0) {\n        log('Capacity must be a non-negative integer', true);\n        return;\n      }\n      if (n > 0 && n < stack.size()) {\n        log('New capacity is smaller than current size. Elements will remain but pushes will overflow.', true);\n      }\n      stack.capacity = n;\n      log(`capacity set to ${n > 0 ? n : '∞'}`);\n      updateUI();\n    });\n\n    fillBtn.addEventListener('click', () => {\n      const n = parseInt(fillCount.value, 10);\n      if (isNaN(n) || n <= 0) {\n        log('Fill count must be a positive integer', true);\n        return;\n      }\n      const items = generateRandomArray(n);\n      try {\n        for (const it of items) {\n          stack.push(it);\n        }\n        log(`Filled ${n} random items`);\n        updateUI('push');\n      } catch (e) {\n        log(e.message, true);\n      }\n    });\n\n    exampleSeqBtn.addEventListener('click', () => {\n      sequenceInput.value = [\n        'push apple',\n        'push banana',\n        'push cherry',\n        'peek',\n        'pop',\n        'push date',\n        'push eggfruit',\n        'wait 600',\n        'pop',\n        'pop',\n        'peek'\n      ].join('\\n');\n    });\n\n    // Sequence runner: supports commands line by line\n    runSeqBtn.addEventListener('click', async () => {\n      const raw = sequenceInput.value.split('\\n').map(l=>l.trim()).filter(l=>l);\n      if (raw.length === 0) {\n        log('Sequence is empty', true);\n        return;\n      }\n      runSeqBtn.disabled = true;\n      exampleSeqBtn.disabled = true;\n      try {\n        for (const line of raw) {\n          const parts = line.split(/\\s+/);\n          const cmd = parts[0].toLowerCase();\n          if (cmd === 'push') {\n            const val = line.substring(5).trim();\n            if (!val) {\n              log('push requires a value', true);\n            } else {\n              try {\n                stack.push(val);\n                log(`push(\"${val}\")`);\n                updateUI('push');\n              } catch (e) {\n                log(e.message, true);\n              }\n            }\n            await sleep(180);\n          } else if (cmd === 'pop') {\n            try {\n              const v = stack.pop();\n              log(`pop() -> \"${v}\"`);\n              updateUI('pop');\n            } catch (e) {\n              log(e.message, true);\n            }\n            await sleep(300);\n          } else if (cmd === 'peek') {\n            try {\n              const v = stack.peek();\n              log(`peek() -> \"${v}\"`);\n              // visual peek highlight\n              const slots = stackContainer.querySelectorAll('.slot');\n              for (let i = slots.length - 1; i >= 0; i--) {\n                if (!slots[i].classList.contains('empty')) {\n                  slots[i].style.boxShadow = '0 10px 30px rgba(8,145,178,0.12)';\n                  setTimeout(()=>slots[i].style.boxShadow = '', 400);\n                  break;\n                }\n              }\n            } catch (e) {\n              log(e.message, true);\n            }\n            await sleep(260);\n          } else if (cmd === 'clear') {\n            stack.clear();\n            log('clear()');\n            updateUI();\n            await sleep(180);\n          } else if (cmd === 'wait') {\n            const ms = parseInt(parts[1]||'0',10) || 0;\n            log(`wait ${ms}ms`);\n            await sleep(ms);\n          } else {\n            log(`Unknown command: ${line}`, true);\n          }\n        }\n      } finally {\n        runSeqBtn.disabled = false;\n        exampleSeqBtn.disabled = false;\n      }\n    });\n\n    // Helpers\n    function generateRandomArray(n) {\n      const words = ['alpha','beta','gamma','delta','epsilon','one','two','three','four','apple','banana','cherry','date','kiwi','mango','zeta'];\n      const out = [];\n      for (let i=0;i<n;i++){\n        out.push(words[Math.floor(Math.random()*words.length)] + (Math.random()*100|0));\n      }\n      return out;\n    }\n\n    function sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }\n\n    function flashCapacity() {\n      // small visual flash on capacity label\n      const orig = capLabel.style.color;\n      capLabel.style.color = 'var(--danger)';\n      setTimeout(()=>capLabel.style.color = orig, 800);\n    }\n\n    // Add keyboard shortcuts: Enter in input pushes\n    valueInput.addEventListener('keydown', (ev) => {\n      if (ev.key === 'Enter') {\n        ev.preventDefault();\n        pushBtn.click();\n      }\n    });\n\n    // Initial helpful message\n    log('Demo ready — push values to the stack. Try the example sequence.');\n\n    // Accessibility: make stack container announce changes\n    const obs = new MutationObserver(()=> {\n      stackContainer.setAttribute('aria-label', `Stack with ${stack.size()} elements. Top index ${stack.size()-1}.`);\n    });\n    obs.observe(stackContainer, {childList:true, subtree:true});\n\n    // Ensure UI sync on load\n    updateUI();\n\n    // Extra: support clicking on array cell to mimic popping until that index (exploratory)\n    arrayRow.addEventListener('click', (e) => {\n      const cell = e.target.closest('.cell');\n      if (!cell) return;\n      const idxLabel = cell.querySelector('.index');\n      if (!idxLabel) return;\n      const idx = parseInt(idxLabel.textContent, 10);\n      // If clicked index is the top, pop once\n      if (idx === stack.size() - 1) {\n        popBtn.click();\n      } else if (idx < stack.size()) {\n        // pop repeatedly until that index becomes top (simulate multiple pops)\n        const toPop = stack.size() - 1 - idx;\n        if (toPop > 0 && confirm(`Pop ${toPop} item(s) to make index ${idx} the top?`)) {\n          for (let i=0;i<toPop;i++) {\n            try { stack.pop(); log('pop()'); } catch(e){ log(e.message,true); break; }\n          }\n          updateUI('pop');\n        }\n      }\n    });\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Stack"
    }
  ],
  "topic": "Stack",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}