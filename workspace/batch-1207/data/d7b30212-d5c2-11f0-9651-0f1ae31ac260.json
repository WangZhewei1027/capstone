{
  "id": "d7b30212-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:41.395Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Directed and Undirected Graph Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f7f9fc;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    margin-bottom: 10px;\n  }\n  #controls {\n    margin-bottom: 10px;\n    text-align: center;\n  }\n  label {\n    margin-right: 15px;\n    font-weight: bold;\n  }\n  canvas {\n    background: white;\n    display: block;\n    margin: 0 auto;\n    box-shadow: 0 0 8px rgba(0,0,0,0.15);\n    border-radius: 6px;\n  }\n  #instructions {\n    max-width: 600px;\n    margin: 15px auto;\n    font-size: 0.9em;\n    color: #555;\n    line-height: 1.4em;\n  }\n  button {\n    font-weight: bold;\n    padding: 6px 14px;\n    cursor: pointer;\n    border-radius: 4px;\n    border: none;\n    background-color: #0078d4;\n    color: white;\n    transition: background-color 0.3s ease;\n  }\n  button:hover {\n    background-color: #005a9e;\n  }\n</style>\n</head>\n<body>\n<h1>Graph Visualization: Directed & Undirected</h1>\n<div id=\"controls\">\n  <label>\n    <input type=\"radio\" name=\"graphType\" value=\"undirected\" checked />\n    Undirected Graph\n  </label>\n  <label>\n    <input type=\"radio\" name=\"graphType\" value=\"directed\" />\n    Directed Graph\n  </label>\n  <button id=\"resetBtn\" title=\"Clear all nodes and edges\">Reset Graph</button>\n</div>\n<canvas id=\"graphCanvas\" width=\"700\" height=\"500\" title=\"Click to add nodes, drag between nodes to create edges\"></canvas>\n<div id=\"instructions\">\n  <p><strong>Instructions:</strong></p>\n  <ul>\n    <li>Click anywhere on the canvas to add a node.</li>\n    <li>Drag from a node to another node to create an edge (arrow for directed graph, line for undirected).</li>\n    <li>Switch between Directed and Undirected graph modes using the radio buttons.</li>\n    <li>Reset button clears the graph.</li>\n  </ul>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const graphTypeInputs = document.querySelectorAll('input[name=\"graphType\"]');\n  const resetBtn = document.getElementById(\"resetBtn\");\n\n  const NODE_RADIUS = 20;\n  const ARROW_SIZE = 10;\n\n  // Graph data structure\n  // { id: number, x: number, y: number }\n  // edges: {from: nodeId, to: nodeId}\n  let nodes = [];\n  let edges = [];\n\n  let currentGraphType = 'undirected';\n\n  let dragNodeId = null;\n  let draggingEdge = false;\n  let dragPos = { x: 0, y: 0 };\n\n  // Track node IDs incrementally\n  let nextNodeId = 1;\n\n  /** Utility Functions */\n  function distance(p1, p2) {\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  function getNodeAtPos(pos) {\n    return nodes.find(node => distance(node, pos) <= NODE_RADIUS);\n  }\n\n  // Clear canvas\n  function clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  // Draw arrow between two points\n  function drawArrow(fromX, fromY, toX, toY, color = \"#333\") {\n    const headlen = ARROW_SIZE; // length of head in pixels\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const angle = Math.atan2(dy, dx);\n\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = 2;\n\n    // line from fromX,fromY to toX,toY but shrink endpoints by NODE_RADIUS to avoid overlap with nodes\n    // Calculate shortened line endpoints:\n    const length = Math.sqrt(dx*dx + dy*dy);\n    if(length === 0) return;\n\n    // Move start point forward by NODE_RADIUS\n    const startX = fromX + (dx / length) * NODE_RADIUS;\n    const startY = fromY + (dy / length) * NODE_RADIUS;\n\n    // Move end point backward by NODE_RADIUS + arrow head length\n    const endX = toX - (dx / length) * (NODE_RADIUS + headlen);\n    const endY = toY - (dy / length) * (NODE_RADIUS + headlen);\n\n    // draw line\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    // draw arrowhead\n    ctx.beginPath();\n    ctx.moveTo(endX, endY);\n    ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw line between two points (for undirected edges)\n  function drawLine(fromX, fromY, toX, toY, color = \"#333\") {\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const length = Math.sqrt(dx*dx + dy*dy);\n    if(length === 0) return;\n    const startX = fromX + (dx / length) * NODE_RADIUS;\n    const startY = fromY + (dy / length) * NODE_RADIUS;\n    const endX = toX - (dx / length) * NODE_RADIUS;\n    const endY = toY - (dy / length) * NODE_RADIUS;\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n  }\n\n  // Draw nodes\n  function drawNode(node, highlight = false) {\n    ctx.beginPath();\n    ctx.fillStyle = highlight ? \"#0078d4\" : \"#ffffff\";\n    ctx.strokeStyle = highlight ? \"#005a9e\" : \"#333\";\n    ctx.lineWidth = highlight ? 4 : 2;\n    ctx.shadowColor = \"rgba(0,0,0,0.1)\";\n    ctx.shadowBlur = 5;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n    ctx.shadowOffsetX = 0;\n    ctx.shadowOffsetY = 0;\n    ctx.stroke();\n\n    // Draw node label (id)\n    ctx.fillStyle = highlight ? \"#fff\" : \"#333\";\n    ctx.font = \"bold 16px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(node.id, node.x, node.y);\n  }\n\n  // Draw all\n  function drawGraph() {\n    clearCanvas();\n\n    // Draw edges first\n    edges.forEach(edge => {\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      if(currentGraphType === 'directed'){\n        drawArrow(fromNode.x, fromNode.y, toNode.x, toNode.y);\n        if(edge.from === edge.to){\n          // Draw a loop for self-edge:\n          drawSelfLoop(fromNode);\n        }\n      } else {\n        if(edge.from === edge.to){\n          drawSelfLoop(fromNode);\n        } else {\n          drawLine(fromNode.x, fromNode.y, toNode.x, toNode.y);\n        }\n      }\n    });\n\n    // If dragging an edge, draw temporary line\n    if(draggingEdge && dragNodeId !== null){\n      const fromNode = nodes.find(n => n.id === dragNodeId);\n      if(fromNode){\n        drawLine(fromNode.x, fromNode.y, dragPos.x, dragPos.y, '#aaa');\n      }\n    }\n\n    // Draw nodes on top\n    // Highlight nodes under mouse or selected during drag?\n    nodes.forEach(node => drawNode(node));\n  }\n\n  // Draw a self-loop on a node - a small circle on top-right side of the node\n  function drawSelfLoop(node) {\n    const loopRadius = 15;\n    const loopX = node.x + NODE_RADIUS;\n    const loopY = node.y - NODE_RADIUS;\n    ctx.beginPath();\n    ctx.strokeStyle = \"#333\";\n    ctx.lineWidth = 2;\n    ctx.arc(loopX, loopY, loopRadius, 0, Math.PI * 2);\n    ctx.stroke();\n\n    if(currentGraphType === 'directed') {\n      // Draw arrowhead on loop - approx at right-top side of loop arc (around 45 degrees)\n      const angle = -Math.PI / 4; // 45 degrees clockwise from +x axis\n      const arrowX = loopX + loopRadius * Math.cos(angle);\n      const arrowY = loopY + loopRadius * Math.sin(angle);\n      const arrowAngle = angle - Math.PI / 2; // perpendicular to loop edge direction\n\n      ctx.beginPath();\n      ctx.fillStyle = \"#333\";\n      ctx.moveTo(arrowX, arrowY);\n      ctx.lineTo(arrowX - ARROW_SIZE * Math.cos(arrowAngle - Math.PI / 6),\n                 arrowY - ARROW_SIZE * Math.sin(arrowAngle - Math.PI / 6));\n      ctx.lineTo(arrowX - ARROW_SIZE * Math.cos(arrowAngle + Math.PI / 6),\n                 arrowY - ARROW_SIZE * Math.sin(arrowAngle + Math.PI / 6));\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  // Add node at position\n  function addNode(x, y) {\n    // Prevent overlap within 2*NODE_RADIUS from existing node\n    if(nodes.some(n => distance(n, {x,y}) < NODE_RADIUS * 2)){\n      return null;\n    }\n    const node = {id: nextNodeId++, x, y};\n    nodes.push(node);\n    return node;\n  }\n\n  // Add edge if doesn't exist (allow multiedges? For simplicity, no duplicates)\n  function addEdge(fromId, toId) {\n    if(fromId === toId){\n      // Allow self-loops\n    } else if(currentGraphType === 'undirected'){\n      // For undirected, edge from->to same as to->from. Check both.\n      if(edges.some(e =>\n        (e.from === fromId && e.to === toId) ||\n        (e.from === toId && e.to === fromId)\n      )) return false;\n    } else {\n      // Directed: check exact match\n      if(edges.some(e => e.from === fromId && e.to === toId)) return false;\n    }\n\n    edges.push({from: fromId, to: toId});\n    return true;\n  }\n\n  // Event handlers\n  canvas.addEventListener(\"mousedown\", e => {\n    const rect = canvas.getBoundingClientRect();\n    const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n    const node = getNodeAtPos(mousePos);\n\n    if(node){\n      dragNodeId = node.id;\n      draggingEdge = true;\n      dragPos = mousePos;\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", e => {\n    if(draggingEdge && dragNodeId !== null){\n      const rect = canvas.getBoundingClientRect();\n      dragPos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", e => {\n    if(draggingEdge && dragNodeId !== null){\n      const rect = canvas.getBoundingClientRect();\n      const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n      const targetNode = getNodeAtPos(mousePos);\n\n      if(targetNode){\n        if(addEdge(dragNodeId, targetNode.id)){\n          // Edge added\n        }\n      }\n      dragNodeId = null;\n      draggingEdge = false;\n      drawGraph();\n    }\n  });\n\n  // Clicking on empty space adds node\n  canvas.addEventListener(\"click\", e => {\n    if(draggingEdge) return; // Ignore clicks during drag\n    const rect = canvas.getBoundingClientRect();\n    const mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n    if(!getNodeAtPos(mousePos)){\n      if(addNode(mousePos.x, mousePos.y)){\n        drawGraph();\n      }\n    }\n  });\n\n  // Change graph type\n  graphTypeInputs.forEach(input => {\n    input.addEventListener(\"change\", e => {\n      currentGraphType = e.target.value;\n      drawGraph();\n    });\n  });\n\n  // Reset graph\n  resetBtn.addEventListener(\"click\", () => {\n    nodes = [];\n    edges = [];\n    nextNodeId = 1;\n    drawGraph();\n  });\n\n  drawGraph();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}