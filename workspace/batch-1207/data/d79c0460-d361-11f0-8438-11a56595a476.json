{
  "id": "d79c0460-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:23.967Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #bstCanvas {\n    border: 1px solid #444;\n    background-color: #fafafa;\n    display: block;\n    margin-top: 20px;\n  }\n  input, button {\n    font-size: 16px;\n    padding: 6px 10px;\n    margin: 5px 0;\n  }\n  #traversals {\n    margin-top: 10px;\n  }\n  .output-label {\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Search Tree (BST) Demonstration</h1>\n\n<label for=\"nodeValue\">Enter Node Value (number): </label>\n<input type=\"number\" id=\"nodeValue\" />\n<button id=\"insertBtn\">Insert</button>\n<button id=\"deleteBtn\">Delete</button>\n<button id=\"searchBtn\">Search</button>\n<button id=\"clearBtn\">Clear Tree</button>\n\n<div id=\"message\" style=\"margin-top:10px; color: #b33;\"></div>\n\n<div id=\"traversals\">\n  <span class=\"output-label\">In-Order: </span><span id=\"inorder\"></span><br />\n  <span class=\"output-label\">Pre-Order: </span><span id=\"preorder\"></span><br />\n  <span class=\"output-label\">Post-Order: </span><span id=\"postorder\"></span><br />\n  <span class=\"output-label\">Level-Order: </span><span id=\"levelorder\"></span>\n</div>\n\n<canvas id=\"bstCanvas\" width=\"900\" height=\"400\"></canvas>\n\n<script>\n  /***** BST Node and Tree Classes *****/\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      const newNode = new Node(value);\n      if (this.root === null) {\n        this.root = newNode;\n        return true;\n      }\n      let current = this.root;\n      while (true) {\n        if (value === current.value) return false; // no duplicates\n        if (value < current.value) {\n          if (current.left === null) {\n            current.left = newNode;\n            return true;\n          }\n          current = current.left;\n        } else {\n          if (current.right === null) {\n            current.right = newNode;\n            return true;\n          }\n          current = current.right;\n        }\n      }\n    }\n\n    search(value) {\n      let current = this.root;\n      while (current) {\n        if (value === current.value) return true;\n        else if (value < current.value) current = current.left;\n        else current = current.right;\n      }\n      return false;\n    }\n\n    delete(value) {\n      this.root = this._deleteRec(this.root,value);\n    }\n\n    _deleteRec(root, value) {\n      if (!root) return root;\n      if (value < root.value) {\n        root.left = this._deleteRec(root.left, value);\n      } else if (value > root.value) {\n        root.right = this._deleteRec(root.right, value);\n      } else {\n        // node to be deleted found\n        if (!root.left) return root.right;\n        else if (!root.right) return root.left;\n\n        // node with two children: get inorder successor (smallest in right subtree)\n        root.value = this._minValue(root.right);\n        root.right = this._deleteRec(root.right, root.value);\n      }\n      return root;\n    }\n\n    _minValue(node) {\n      let current = node;\n      while (current.left != null) {\n        current = current.left;\n      }\n      return current.value;\n    }\n\n    inorder() {\n      const result = [];\n      this._inorderRec(this.root, result);\n      return result;\n    }\n    _inorderRec(node, arr) {\n      if (node) {\n        this._inorderRec(node.left, arr);\n        arr.push(node.value);\n        this._inorderRec(node.right, arr);\n      }\n    }\n    preorder() {\n      const result = [];\n      this._preorderRec(this.root, result);\n      return result;\n    }\n    _preorderRec(node, arr) {\n      if (node) {\n        arr.push(node.value);\n        this._preorderRec(node.left, arr);\n        this._preorderRec(node.right, arr);\n      }\n    }\n    postorder() {\n      const result = [];\n      this._postorderRec(this.root, result);\n      return result;\n    }\n    _postorderRec(node, arr) {\n      if (node) {\n        this._postorderRec(node.left, arr);\n        this._postorderRec(node.right, arr);\n        arr.push(node.value);\n      }\n    }\n    levelOrder() {\n      const result = [];\n      if (!this.root) return result;\n      const queue = [this.root];\n      while (queue.length > 0) {\n        const node = queue.shift();\n        result.push(node.value);\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n      }\n      return result;\n    }\n  }\n\n  /***** Visualization on Canvas *****/\n  const canvas = document.getElementById('bstCanvas');\n  const ctx = canvas.getContext('2d');\n  const radius = 20;\n  const levelHeight = 70;\n\n  function clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  // Compute positions of nodes before drawing\n  // We'll perform an inorder traversal assigning x positions to keep nodes spaced out\n  function computeNodePositions(root) {\n    const positions = new Map();\n    let xPos = 40; // horizontal start offset\n\n    function inorderAssign(node, depth) {\n      if (!node) return;\n      inorderAssign(node.left, depth + 1);\n      positions.set(node, { x: xPos, y: 40 + depth * levelHeight });\n      xPos += 70; // distance between nodes horizontally\n      inorderAssign(node.right, depth + 1);\n    }\n    inorderAssign(root, 0);\n    return positions;\n  }\n\n  // Draw line between two points with arrow-like end\n  function drawLine(fromX, fromY, toX, toY) {\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(fromX, fromY);\n    ctx.lineTo(toX, toY);\n    ctx.stroke();\n  }\n\n  // Draw a node circle with value text\n  function drawNode(x, y, value, highlight=false) {\n    ctx.beginPath();\n    ctx.fillStyle = highlight ? '#ff6666' : '#4a90e2';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.shadowColor = 'rgba(0,0,0,0.2)';\n    ctx.shadowBlur = 3;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n    ctx.shadowOffsetX = 0;\n    ctx.shadowOffsetY = 0;\n    ctx.stroke();\n\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(value, x, y);\n  }\n\n  // Draw BST recursively using the precomputed positions\n  function drawBST(tree, highlightValue=null) {\n    clearCanvas();\n    if (!tree.root) return;\n    const positions = computeNodePositions(tree.root);\n\n    // Draw edges\n    positions.forEach((pos, node) => {\n      if (node.left) {\n        let leftPos = positions.get(node.left);\n        drawLine(pos.x, pos.y + radius, leftPos.x, leftPos.y - radius);\n      }\n      if (node.right) {\n        let rightPos = positions.get(node.right);\n        drawLine(pos.x, pos.y + radius, rightPos.x, rightPos.y - radius);\n      }\n    });\n\n    // Draw nodes on top of edges\n    positions.forEach((pos, node) => {\n      const highlight = (node.value === highlightValue);\n      drawNode(pos.x, pos.y, node.value, highlight);\n    });\n  }\n\n  /***** UI and Interaction *****/\n  const bst = new BST();\n  const nodeInput = document.getElementById('nodeValue');\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const searchBtn = document.getElementById('searchBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const messageDiv = document.getElementById('message');\n\n  const inorderSpan = document.getElementById('inorder');\n  const preorderSpan = document.getElementById('preorder');\n  const postorderSpan = document.getElementById('postorder');\n  const levelorderSpan = document.getElementById('levelorder');\n\n  function updateTraversalDisplays() {\n    inorderSpan.textContent = bst.inorder().join(', ');\n    preorderSpan.textContent = bst.preorder().join(', ');\n    postorderSpan.textContent = bst.postorder().join(', ');\n    levelorderSpan.textContent = bst.levelOrder().join(', ');\n  }\n\n  function clearMessage() {\n    messageDiv.textContent = '';\n  }\n\n  insertBtn.addEventListener('click', () => {\n    clearMessage();\n    const value = parseInt(nodeInput.value);\n    if (Number.isNaN(value)) {\n      messageDiv.textContent = 'Please enter a valid number to insert.';\n      return;\n    }\n    const inserted = bst.insert(value);\n    if (inserted) {\n      messageDiv.style.color = 'green';\n      messageDiv.textContent = `Inserted ${value} into the BST.`;\n    } else {\n      messageDiv.style.color = '#b33';\n      messageDiv.textContent = `Value ${value} already exists in the BST.`;\n    }\n    updateTraversalDisplays();\n    drawBST(bst);\n  });\n\n  deleteBtn.addEventListener('click', () => {\n    clearMessage();\n    const value = parseInt(nodeInput.value);\n    if (Number.isNaN(value)) {\n      messageDiv.textContent = 'Please enter a valid number to delete.';\n      return;\n    }\n    if (!bst.search(value)) {\n      messageDiv.style.color = '#b33';\n      messageDiv.textContent = `Value ${value} not found in the BST.`;\n      return;\n    }\n    bst.delete(value);\n    messageDiv.style.color = 'green';\n    messageDiv.textContent = `Deleted ${value} from the BST.`;\n    updateTraversalDisplays();\n    drawBST(bst);\n  });\n\n  searchBtn.addEventListener('click', () => {\n    clearMessage();\n    const value = parseInt(nodeInput.value);\n    if (Number.isNaN(value)) {\n      messageDiv.textContent = 'Please enter a valid number to search.';\n      return;\n    }\n    const found = bst.search(value);\n    if (found) {\n      messageDiv.style.color = 'green';\n      messageDiv.textContent = `Value ${value} found in the BST. Highlighting node...`;\n      drawBST(bst, value);\n    } else {\n      messageDiv.style.color = '#b33';\n      messageDiv.textContent = `Value ${value} not found in the BST.`;\n      drawBST(bst);\n    }\n  });\n\n  clearBtn.addEventListener('click', () => {\n    clearMessage();\n    bst.root = null;\n    updateTraversalDisplays();\n    drawBST(bst);\n    messageDiv.style.color = 'black';\n    messageDiv.textContent = 'BST cleared.';\n  });\n\n  // Draw initial empty tree\n  updateTraversalDisplays();\n  drawBST(bst);\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}