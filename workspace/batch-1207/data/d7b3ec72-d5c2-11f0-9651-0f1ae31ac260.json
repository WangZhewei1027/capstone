{
  "id": "d7b3ec72-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:19.415Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Bellman-Ford Algorithm Visualization</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 0;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      background: #f7f9fc;\n      color: #333;\n    }\n    h1 {\n      margin-top: 20px;\n      margin-bottom: 5px;\n    }\n    #container {\n      display: flex;\n      max-width: 900px;\n      width: 100%;\n      margin: 10px;\n      gap: 20px;\n    }\n    #graphCanvas {\n      border: 1px solid #ccc;\n      background: white;\n      flex-grow: 1;\n      border-radius: 10px;\n    }\n    #controls {\n      width: 260px;\n      background: #fff;\n      box-shadow: 0 4px 10px rgb(0 0 0 / 0.1);\n      border-radius: 10px;\n      padding: 15px;\n      display: flex;\n      flex-direction: column;\n      gap: 15px;\n    }\n    label {\n      font-weight: bold;\n      margin-bottom: 5px;\n      display: block;\n    }\n    input, select, button, textarea {\n      width: 100%;\n      padding: 7px 8px;\n      box-sizing: border-box;\n      font-size: 14px;\n      border-radius: 5px;\n      border: 1px solid #bbb;\n      resize: vertical;\n    }\n    button {\n      background: #007bff;\n      color: white;\n      border: none;\n      cursor: pointer;\n      font-weight: bold;\n      transition: background 0.3s ease;\n    }\n    button:disabled {\n      background: #aaa;\n      cursor: not-allowed;\n    }\n    button:hover:not(:disabled) {\n      background: #0056b3;\n    }\n    #log {\n      height: 200px;\n      overflow-y: auto;\n      background: #eee;\n      padding: 8px;\n      font-family: monospace;\n      font-size: 13px;\n      border-radius: 5px;\n      white-space: pre-wrap;\n      user-select: text;\n    }\n    #distanceTable {\n      width: 100%;\n      border-collapse: collapse;\n      margin-top: 10px;\n    }\n    #distanceTable th, #distanceTable td {\n      border: 1px solid #ccc;\n      padding: 6px 8px;\n      text-align: center;\n    }\n    #distanceTable th {\n      background: #007bff;\n      color: white;\n    }\n    small {\n      color: #555;\n      font-style: italic;\n    }\n    a.github-link {\n      margin-top: 10px;\n      font-size: 0.75rem;\n      color: #007bff;\n      text-decoration: none;\n      align-self: flex-end;\n    }\n    a.github-link:hover {\n      text-decoration: underline;\n    }\n  </style>\n</head>\n<body>\n  <h1>Bellman-Ford Algorithm Visualization</h1>\n  <div id=\"container\">\n    <canvas id=\"graphCanvas\" width=\"600\" height=\"450\" aria-label=\"Graph visualization\"></canvas>\n    <div id=\"controls\">\n      <label for=\"graphInput\">Input Graph Edges (one per line):</label>\n      <textarea id=\"graphInput\" rows=\"8\" aria-describedby=\"inputHelp\" placeholder=\"Format: start end weight&#10;Example:&#10;A B 4&#10;B C -2&#10;C D 3\"></textarea>\n      <small id=\"inputHelp\">Enter edges in the format: <code>startNode endNode weight</code>. Nodes can be letters or numbers.</small>\n\n      <label for=\"sourceNode\">Source Node:</label>\n      <input type=\"text\" id=\"sourceNode\" maxlength=\"3\" placeholder=\"e.g. A\" aria-describedby=\"sourceHelp\" />\n\n      <button id=\"startBtn\">Start Bellman-Ford</button>\n      <button id=\"stepBtn\" disabled>Next Step</button>\n      <button id=\"resetBtn\" disabled>Reset</button>\n\n      <div>\n        <h3>Distances from Source</h3>\n        <table id=\"distanceTable\" aria-live=\"polite\" aria-label=\"Distance to nodes from source\">\n          <thead><tr><th>Node</th><th>Distance</th></tr></thead>\n          <tbody></tbody>\n        </table>\n      </div>\n\n      <div style=\"margin-top: 10px;\">\n        <h3>Log</h3>\n        <div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    /*\n      Bellman-Ford Algorithm Visualization\n\n      Features:\n      - User inputs edges in textual form: start end weight\n      - Visualization of nodes and edges on canvas\n      - Step-by-step relaxation of edges, highlighting changes\n      - Detects negative weight cycle and notifies user\n      - Shows updated distances in a table\n      - Log area displays each step and decision\n    */\n\n    const canvas = document.getElementById('graphCanvas');\n    const ctx = canvas.getContext('2d');\n    const startBtn = document.getElementById('startBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const graphInput = document.getElementById('graphInput');\n    const sourceInput = document.getElementById('sourceNode');\n    const logDiv = document.getElementById('log');\n    const distanceTableBody = document.querySelector('#distanceTable tbody');\n\n    // Graph data structures\n    let nodes = new Map(); // key: node label, value: {x, y}\n    let edges = [];        // edges: {from, to, weight}\n\n    // Algorithm state\n    let distances = {};\n    let predecessors = {};\n    let nodeList = [];\n    let currentIteration = 0;\n    let currentEdgeIndex = 0;\n    let sourceNode = null;\n    let running = false;\n    let negativeCycleDetected = false;\n\n    // Constants\n    const NODE_RADIUS = 20;\n\n    // Initialize with a default graph\n    graphInput.value = `A B 6\nA D 6\nB C 5\nB D 8\nB E -4\nC B -2\nD C -3\nD E 9\nE A 2\nE C 7`;\n\n    sourceInput.value = 'A';\n\n    function log(msg) {\n      logDiv.textContent += msg + \"\\n\";\n      logDiv.scrollTop = logDiv.scrollHeight;\n    }\n\n    function clearLog() {\n      logDiv.textContent = '';\n    }\n\n    function parseInputGraph() {\n      nodes.clear();\n      edges = [];\n      const lines = graphInput.value.trim().split('\\n').filter(line => line.trim());\n      const nodeSet = new Set();\n\n      for (let line of lines) {\n        const parts = line.trim().split(/\\s+/);\n        if (parts.length !== 3) {\n          throw new Error(`Line \"${line}\" is invalid. Expected format: start end weight`);\n        }\n        const [from, to, weightStr] = parts;\n        const weight = Number(weightStr);\n        if (Number.isNaN(weight)) {\n          throw new Error(`Invalid weight on line \"${line}\"`);\n        }\n        edges.push({ from, to, weight });\n        nodeSet.add(from);\n        nodeSet.add(to);\n      }\n\n      nodeList = Array.from(nodeSet).sort();\n\n      // Assign positions to nodes in a circle for visualization\n      const centerX = canvas.width / 2;\n      const centerY = canvas.height / 2;\n      const radius = Math.min(centerX, centerY) - 50;\n\n      nodeList.forEach((node, i) => {\n        const angle = (2 * Math.PI * i) / nodeList.length - Math.PI / 2;\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n        nodes.set(node, { x, y });\n      });\n    }\n\n    function initializeAlgorithm() {\n      distances = {};\n      predecessors = {};\n      nodeList.forEach(n => {\n        distances[n] = Infinity;\n        predecessors[n] = null;\n      });\n      distances[sourceNode] = 0;\n      currentIteration = 1;\n      currentEdgeIndex = 0;\n      negativeCycleDetected = false;\n    }\n\n    function drawGraph(highlightEdge = null, updatedNode = null) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw edges\n      edges.forEach((edge, i) => {\n        const fromPos = nodes.get(edge.from);\n        const toPos = nodes.get(edge.to);\n\n        // Compute line vector and arrow\n        const dx = toPos.x - fromPos.x;\n        const dy = toPos.y - fromPos.y;\n        const angle = Math.atan2(dy, dx);\n\n        // Line start and end adjusted for node radius\n        const startX = fromPos.x + NODE_RADIUS * Math.cos(angle);\n        const startY = fromPos.y + NODE_RADIUS * Math.sin(angle);\n        const endX = toPos.x - NODE_RADIUS * Math.cos(angle);\n        const endY = toPos.y - NODE_RADIUS * Math.sin(angle);\n\n        // Highlight if this is the current edge being relaxed\n        if (highlightEdge && highlightEdge.from === edge.from && highlightEdge.to === edge.to) {\n          ctx.strokeStyle = 'orange';\n          ctx.lineWidth = 4;\n        } else {\n          ctx.strokeStyle = '#999';\n          ctx.lineWidth = 2;\n        }\n\n        ctx.beginPath();\n        ctx.moveTo(startX, startY);\n        ctx.lineTo(endX, endY);\n        ctx.stroke();\n\n        // Draw arrowhead\n        const arrowSize = 10;\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.beginPath();\n        ctx.moveTo(endX, endY);\n        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));\n        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));\n        ctx.closePath();\n        ctx.fill();\n\n        // Draw weight label\n        const labelX = (startX + endX) / 2 + 12 * Math.cos(angle + Math.PI / 2);\n        const labelY = (startY + endY) / 2 + 12 * Math.sin(angle + Math.PI / 2);\n        ctx.fillStyle = '#222';\n        ctx.font = '14px Arial';\n        ctx.fillText(edge.weight, labelX - 6, labelY + 6);\n      });\n\n      // Draw nodes\n      nodeList.forEach(node => {\n        const pos = nodes.get(node);\n\n        // Fill color based on status\n        if (updatedNode === node) {\n          ctx.fillStyle = '#2ecc71'; // green highlight for updated distance\n        } else if (node === sourceNode) {\n          ctx.fillStyle = '#3498db'; // blue for source\n        } else {\n          ctx.fillStyle = '#e3e3e3';\n        }\n\n        ctx.beginPath();\n        ctx.arc(pos.x, pos.y, NODE_RADIUS, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.strokeStyle = '#666';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n\n        // Node label\n        ctx.fillStyle = '#222';\n        ctx.font = 'bold 16px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(node, pos.x, pos.y);\n      });\n    }\n\n    // Update distances table\n    function updateDistancesTable() {\n      distanceTableBody.innerHTML = '';\n      nodeList.forEach(node => {\n        const tr = document.createElement('tr');\n        const tdNode = document.createElement('td');\n        tdNode.textContent = node;\n        const tdDist = document.createElement('td');\n        tdDist.textContent = distances[node] === Infinity ? 'âˆž' : distances[node].toString();\n        tr.appendChild(tdNode);\n        tr.appendChild(tdDist);\n        distanceTableBody.appendChild(tr);\n      });\n    }\n\n    // Steps:\n    // Bellman-Ford runs V-1 iterations,\n    // each iteration relaxes all edges in sequence.\n    // After that, for iteration V, we check for negative cycle.\n\n    function relaxEdge(edge) {\n      const { from, to, weight } = edge;\n      const distFrom = distances[from];\n      const distTo = distances[to];\n      if (distFrom !== Infinity && distFrom + weight < distTo) {\n        distances[to] = distFrom + weight;\n        predecessors[to] = from;\n        return true; // updated\n      }\n      return false; // no update\n    }\n\n    function stepAlgorithm() {\n      if (negativeCycleDetected) {\n        log(\"Algorithm halted due to negative weight cycle detected.\");\n        stepBtn.disabled = true;\n        return;\n      }\n\n      if (currentIteration <= nodeList.length - 1) {\n        // Relax next edge\n        if (currentEdgeIndex < edges.length) {\n          const edge = edges[currentEdgeIndex];\n          log(`Iteration ${currentIteration}, relaxing edge ${edge.from} -> ${edge.to} (weight ${edge.weight})`);\n          const updated = relaxEdge(edge);\n          if (updated) {\n            log(`  Updated distance to node ${edge.to}: ${distances[edge.to]}`);\n            drawGraph(edge, edge.to);\n          } else {\n            log(`  No update needed for node ${edge.to}`);\n            drawGraph(edge, null);\n          }\n          updateDistancesTable();\n          currentEdgeIndex++;\n        }\n\n        if (currentEdgeIndex === edges.length) {\n          currentIteration++;\n          currentEdgeIndex = 0;\n          log(`Completed iteration ${currentIteration - 1}.\\n`);\n          if (currentIteration === nodeList.length) {\n            log(\"Performing negative cycle detection...\");\n          }\n        }\n      } else if (currentIteration === nodeList.length) {\n        // Negative cycle detection iteration\n        // If any edge can be relaxed further, negative cycle exists\n\n        let cycleDetectedInThisCheck = false;\n        for (let i = 0; i < edges.length; i++) {\n          const edge = edges[i];\n          const { from, to, weight } = edge;\n          if (distances[from] !== Infinity && distances[from] + weight < distances[to]) {\n            cycleDetectedInThisCheck = true;\n            drawGraph(edge, to);\n            log(`Negative weight cycle detected on edge ${from} -> ${to}! Algorithm stops.`);\n            negativeCycleDetected = true;\n            stepBtn.disabled = true;\n            return;\n          }\n        }\n        if (!cycleDetectedInThisCheck) {\n          log(\"No negative weight cycles detected. Algorithm finished.\");\n          stepBtn.disabled = true;\n        }\n      }\n    }\n\n    function startAlgorithm() {\n      clearLog();\n      try {\n        parseInputGraph();\n      } catch (e) {\n        alert(e.message);\n        return;\n      }\n\n      sourceNode = sourceInput.value.trim();\n      if (!nodes.has(sourceNode)) {\n        alert(`Source node \"${sourceNode}\" not found in graph nodes.`);\n        return;\n      }\n\n      initializeAlgorithm();\n\n      runInitialDraw();\n\n      log(`Starting Bellman-Ford algorithm with source node: \"${sourceNode}\"`);\n      updateDistancesTable();\n\n      running = true;\n      startBtn.disabled = true;\n      stepBtn.disabled = false;\n      resetBtn.disabled = false;\n      graphInput.disabled = true;\n      sourceInput.disabled = true;\n    }\n\n    function runInitialDraw() {\n      drawGraph();\n    }\n\n    function resetAlgorithm() {\n      running = false;\n      negativeCycleDetected = false;\n      currentIteration = 0;\n      currentEdgeIndex = 0;\n      distances = {};\n      predecessors = {};\n      nodeList = [];\n      nodes.clear();\n      edges = [];\n      clearLog();\n      distanceTableBody.innerHTML = '';\n      drawGraph();\n      startBtn.disabled = false;\n      stepBtn.disabled = true;\n      resetBtn.disabled = true;\n      graphInput.disabled = false;\n      sourceInput.disabled = false;\n    }\n\n    // Accessibility: Add keyboard support for buttons, link labels are descriptive by default\n\n    // Event Listeners\n    startBtn.addEventListener('click', startAlgorithm);\n    stepBtn.addEventListener('click', () => {\n      if (running) stepAlgorithm();\n    });\n    resetBtn.addEventListener('click', resetAlgorithm);\n\n    // Draw initial blank canvas with default graph so user can see something before start\n    try {\n      parseInputGraph();\n      drawGraph();\n      updateDistancesTable();\n    } catch {\n      // ignore parse errors at startup, user may edit input\n    }\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}