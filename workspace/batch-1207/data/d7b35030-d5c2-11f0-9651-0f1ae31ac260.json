{
  "id": "d7b35030-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:08.064Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Priority Queue Demo</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 2em;\n      max-width: 600px;\n    }\n    h1 {\n      text-align: center;\n      color: #2c3e50;\n    }\n    label {\n      display: block;\n      margin-top: 1em;\n      font-weight: bold;\n    }\n    input[type=\"text\"],\n    input[type=\"number\"] {\n      width: 100%;\n      padding: 0.5em;\n      margin-top: 0.2em;\n      box-sizing: border-box;\n      font-size: 1em;\n    }\n    button {\n      margin-top: 1em;\n      padding: 0.6em 1.2em;\n      font-size: 1em;\n      cursor: pointer;\n      background-color: #3498db;\n      color: white;\n      border: none;\n      border-radius: 3px;\n      transition: background-color 0.3s ease;\n    }\n    button:hover {\n      background-color: #2980b9;\n    }\n    .queue-container {\n      margin-top: 2em;\n      border: 1px solid #ccc;\n      padding: 1em;\n      border-radius: 5px;\n      background-color: #ecf0f1;\n    }\n    .queue-item {\n      padding: 0.5em;\n      margin: 0.3em 0;\n      border-radius: 3px;\n      background-color: #bdc3c7;\n      display: flex;\n      justify-content: space-between;\n    }\n    .queue-item.highest {\n      background-color: #2ecc71;\n      color: white;\n      font-weight: bold;\n    }\n    .actions {\n      margin-top: 1.5em;\n      text-align: center;\n    }\n    .result {\n      margin-top: 2em;\n      padding: 1em;\n      background-color: #dff0d8;\n      border-radius: 5px;\n      color: #3c763d;\n      font-weight: bold;\n      display: none;\n    }\n  </style>\n</head>\n<body>\n  <h1>Priority Queue Demonstration</h1>\n\n  <label for=\"itemInput\">Item (any text):</label>\n  <input type=\"text\" id=\"itemInput\" placeholder=\"Enter item value\" />\n\n  <label for=\"priorityInput\">Priority (integer, higher = higher priority):</label>\n  <input type=\"number\" id=\"priorityInput\" placeholder=\"Enter priority (e.g. 1, 2, 3)\" />\n\n  <button id=\"enqueueBtn\">Enqueue Item</button>\n\n  <div class=\"actions\">\n    <button id=\"dequeueBtn\">Dequeue Highest Priority</button>\n  </div>\n\n  <div class=\"queue-container\">\n    <h2>Current Queue (sorted by priority)</h2>\n    <div id=\"queueList\">\n      <!-- Queue items will appear here -->\n      <p><i>The queue is empty.</i></p>\n    </div>\n  </div>\n\n  <div class=\"result\" id=\"result\"></div>\n\n  <script>\n    // Priority Queue implemented as a class using a binary max-heap\n    class PriorityQueue {\n      constructor() {\n        this.heap = [];\n      }\n\n      // Get index of parent\n      parentIndex(i) {\n        return Math.floor((i - 1) / 2);\n      }\n      // Get index of left child\n      leftChildIndex(i) {\n        return 2 * i + 1;\n      }\n      // Get index of right child\n      rightChildIndex(i) {\n        return 2 * i + 2;\n      }\n\n      enqueue(item, priority) {\n        const node = {item, priority, count: this._count++};\n        this.heap.push(node);\n        this._bubbleUp(this.heap.length - 1);\n      }\n\n      // We use count to ensure stable ordering for same priorities\n      _count = 0;\n\n      _bubbleUp(index) {\n        let currentIndex = index;\n        while (currentIndex > 0) {\n          let parentIdx = this.parentIndex(currentIndex);\n          const current = this.heap[currentIndex];\n          const parent = this.heap[parentIdx];\n\n          // Higher priority first; if tie, earlier enqueued first (lower count)\n          if (\n            current.priority > parent.priority ||\n            (current.priority === parent.priority && current.count < parent.count)\n          ) {\n            // Swap\n            [this.heap[currentIndex], this.heap[parentIdx]] = [this.heap[parentIdx], this.heap[currentIndex]];\n            currentIndex = parentIdx;\n          } else {\n            break;\n          }\n        }\n      }\n\n      dequeue() {\n        if (this.heap.length === 0) return null;\n        const root = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n          this.heap[0] = end;\n          this._sinkDown(0);\n        }\n        return root;\n      }\n\n      _sinkDown(index) {\n        let currentIndex = index;\n        const length = this.heap.length;\n        while (true) {\n          let leftIdx = this.leftChildIndex(currentIndex);\n          let rightIdx = this.rightChildIndex(currentIndex);\n          let largest = currentIndex;\n\n          if (leftIdx < length) {\n            const left = this.heap[leftIdx];\n            const largestNode = this.heap[largest];\n            if (\n              left.priority > largestNode.priority ||\n              (left.priority === largestNode.priority && left.count < largestNode.count)\n            ) {\n              largest = leftIdx;\n            }\n          }\n          if (rightIdx < length) {\n            const right = this.heap[rightIdx];\n            const largestNode = this.heap[largest];\n            if (\n              right.priority > largestNode.priority ||\n              (right.priority === largestNode.priority && right.count < largestNode.count)\n            ) {\n              largest = rightIdx;\n            }\n          }\n\n          if (largest !== currentIndex) {\n            [this.heap[currentIndex], this.heap[largest]] = [this.heap[largest], this.heap[currentIndex]];\n            currentIndex = largest;\n          } else {\n            break;\n          }\n        }\n      }\n\n      size() {\n        return this.heap.length;\n      }\n\n      isEmpty() {\n        return this.size() === 0;\n      }\n\n      // Returns a sorted array (by priority descending, stable for ties)\n      toSortedArray() {\n        // We copy the heap array and sort it for display purpose\n        // Sort descending priority, ascending count for ties\n        return [...this.heap].sort((a, b) => {\n          if (b.priority !== a.priority) return b.priority - a.priority;\n          return a.count - b.count;\n        });\n      }\n    }\n\n    const pq = new PriorityQueue();\n\n    const itemInput = document.getElementById('itemInput');\n    const priorityInput = document.getElementById('priorityInput');\n    const enqueueBtn = document.getElementById('enqueueBtn');\n    const dequeueBtn = document.getElementById('dequeueBtn');\n    const queueList = document.getElementById('queueList');\n    const result = document.getElementById('result');\n\n    function renderQueue() {\n      const arr = pq.toSortedArray();\n      queueList.innerHTML = '';\n      if (arr.length === 0) {\n        queueList.innerHTML = '<p><i>The queue is empty.</i></p>';\n        return;\n      }\n\n      arr.forEach((node, idx) => {\n        const div = document.createElement('div');\n        div.className = 'queue-item';\n        if (idx === 0) div.classList.add('highest');\n        div.innerHTML = `<span>${node.item}</span><span>Priority: ${node.priority}</span>`;\n        queueList.appendChild(div);\n      });\n    }\n\n    enqueueBtn.addEventListener('click', () => {\n      const itemVal = itemInput.value.trim();\n      const priorityVal = priorityInput.value.trim();\n\n      result.style.display = 'none';\n      result.textContent = '';\n\n      if (itemVal === '') {\n        alert('Please enter an item.');\n        itemInput.focus();\n        return;\n      }\n      if (priorityVal === '' || isNaN(priorityVal)) {\n        alert('Please enter a valid priority number.');\n        priorityInput.focus();\n        return;\n      }\n      const priorityNum = parseInt(priorityVal, 10);\n      pq.enqueue(itemVal, priorityNum);\n\n      itemInput.value = '';\n      priorityInput.value = '';\n      itemInput.focus();\n\n      renderQueue();\n    });\n\n    dequeueBtn.addEventListener('click', () => {\n      if (pq.isEmpty()) {\n        alert('The queue is empty, no item to dequeue.');\n        return;\n      }\n      const dequeued = pq.dequeue();\n      renderQueue();\n      result.textContent = `Dequeued item: \"${dequeued.item}\" with priority ${dequeued.priority}`;\n      result.style.display = 'block';\n    });\n\n    // Initial render\n    renderQueue();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}