{
  "id": "98e256e2-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:05.334Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Kruskal's Algorithm Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    :root { --bg: #0f1724; --panel: #0b1220; --accent: #2dd4bf; --muted: #94a3b8; }\n    html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif; background: linear-gradient(180deg,#071122 0%, #071827 100%); color:#e6eef6; }\n    .wrap { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n    .left { width:360px; min-width:280px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border-radius:12px; padding:14px; box-sizing:border-box; }\n    .title { font-size:18px; font-weight:700; color:var(--accent); margin-bottom:6px; display:flex; align-items:center; gap:8px; }\n    .desc { font-size:13px; color:var(--muted); margin-bottom:12px; line-height:1.35; }\n    label { display:block; font-size:13px; margin-top:8px; color:#cfeff3; }\n    input[type=\"range\"] { width:100%; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }\n    button { background:transparent; border:1px solid rgba(255,255,255,0.08); color:var(--accent); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }\n    button.secondary { color:#9fb6d0; border-color: rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); }\n    .status { margin-top:12px; background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:13px; color:var(--muted); }\n    .lists { margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:8px; }\n    .box { background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:13px; color:var(--muted); max-height:220px; overflow:auto; }\n    .box h4 { margin:0 0 8px 0; font-size:13px; color:#cfeff3; }\n    .small { font-size:12px; color:#9fb6d0; }\n    .canvas-wrap { flex:1; background:linear-gradient(180deg,#08131c,#071226); border-radius:12px; display:flex; flex-direction:column; padding:10px; box-sizing:border-box; }\n    .svg-area { flex:1; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02)); position:relative; overflow:hidden; }\n    svg { width:100%; height:100%; display:block; }\n    .legend { margin-top:8px; display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; flex-wrap:wrap; }\n    .legend .item { display:flex; gap:6px; align-items:center; }\n    .swatch { width:14px; height:12px; border-radius:3px; display:inline-block; }\n    .sw-accepted { background:#34d399; }\n    .sw-rejected { background:#fb7185; }\n    .sw-active { background:#facc15; }\n    .sw-default { background:#94a3b8; }\n    .footer-note { font-size:12px; color:var(--muted); margin-top:8px; }\n    .edge-weight { font-family:monospace; font-size:12px; pointer-events:none; }\n    .node-label { font-size:13px; pointer-events:none; fill:#e6eef6; font-weight:700; text-anchor:middle; dominant-baseline:central; }\n    .node { cursor:grab; }\n    .node:active { cursor:grabbing; }\n    .small-btn { padding:6px 8px; font-size:12px; border-radius:6px; }\n    .compact { font-size:12px; padding:6px 8px; }\n    .input-inline { display:flex; gap:8px; align-items:center; margin-top:8px; }\n    .input-inline input[type=number] { width:64px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); }\n  </style>\n</head>\n<body>\n<div class=\"wrap\">\n  <div class=\"left\">\n    <div class=\"title\">Kruskal's Algorithm — Interactive Demo</div>\n    <div class=\"desc\">\n      Build a Minimum Spanning Tree (MST) using Kruskal's algorithm. Use the controls below to generate graphs, step through the algorithm, and see the union-find sets as edges are examined.\n      Drag nodes to reposition them. Edge colors: green = accepted, red = rejected (would form cycle), yellow = currently considered.\n    </div>\n\n    <label>Nodes: <span id=\"nodeCountLabel\">8</span></label>\n    <input id=\"nodeCount\" type=\"range\" min=\"2\" max=\"12\" value=\"8\">\n\n    <label>Edge density (probability): <span id=\"edgeProbLabel\">0.45</span></label>\n    <input id=\"edgeProb\" type=\"range\" min=\"0.05\" max=\"1\" step=\"0.05\" value=\"0.45\">\n\n    <div class=\"controls\">\n      <button id=\"randBtn\">Generate Random Graph</button>\n      <button id=\"sampleBtn\" class=\"secondary\">Load Sample Graph</button>\n      <button id=\"resetBtn\" class=\"secondary\">Reset Algorithm</button>\n      <button id=\"stepBtn\" class=\"small-btn\">Step</button>\n      <button id=\"playBtn\" class=\"small-btn\">Auto Play</button>\n      <button id=\"finishBtn\" class=\"small-btn secondary\">Run to Completion</button>\n    </div>\n\n    <div class=\"input-inline\">\n      <label style=\"margin:0;\">Speed:</label>\n      <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" step=\"100\" value=\"800\">\n      <span class=\"small\" id=\"speedLabel\">800 ms/step</span>\n    </div>\n\n    <div class=\"status\" id=\"statusBox\">\n      Current edge: <span id=\"currentEdge\">—</span><br>\n      Edges considered: <span id=\"edgesConsidered\">0</span> / <span id=\"totalEdges\">0</span><br>\n      Total MST weight so far: <strong id=\"mstWeight\">0</strong>\n    </div>\n\n    <div class=\"lists\">\n      <div class=\"box\">\n        <h4>Selected edges (MST)</h4>\n        <div id=\"selectedList\">—</div>\n      </div>\n      <div class=\"box\">\n        <h4>Union-Find sets (parents)</h4>\n        <div id=\"ufList\">—</div>\n      </div>\n    </div>\n\n    <div class=\"legend\">\n      <div class=\"item\"><span class=\"swatch sw-accepted\"></span>Accepted</div>\n      <div class=\"item\"><span class=\"swatch sw-rejected\"></span>Rejected</div>\n      <div class=\"item\"><span class=\"swatch sw-active\"></span>Current</div>\n      <div class=\"item\"><span class=\"swatch sw-default\"></span>Not yet checked</div>\n    </div>\n\n    <div class=\"footer-note\">\n      Tip: Click \"Load Sample Graph\" for a clear example. Use \"Run to Completion\" to quickly finish. You can drag nodes; edges update automatically.\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\">\n    <div class=\"svg-area\" id=\"svgArea\">\n      <svg id=\"svg\"></svg>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Utility\n  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n  function randFloat(min,max){ return Math.random()*(max-min)+min; }\n  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n\n  // DOM\n  const svg = document.getElementById('svg');\n  const nodeCountInput = document.getElementById('nodeCount');\n  const nodeCountLabel = document.getElementById('nodeCountLabel');\n  const edgeProbInput = document.getElementById('edgeProb');\n  const edgeProbLabel = document.getElementById('edgeProbLabel');\n  const randBtn = document.getElementById('randBtn');\n  const sampleBtn = document.getElementById('sampleBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const playBtn = document.getElementById('playBtn');\n  const finishBtn = document.getElementById('finishBtn');\n  const speedInput = document.getElementById('speed');\n  const speedLabel = document.getElementById('speedLabel');\n  const statusBox = document.getElementById('statusBox');\n  const currentEdgeSpan = document.getElementById('currentEdge');\n  const edgesConsideredSpan = document.getElementById('edgesConsidered');\n  const totalEdgesSpan = document.getElementById('totalEdges');\n  const mstWeightSpan = document.getElementById('mstWeight');\n  const selectedList = document.getElementById('selectedList');\n  const ufList = document.getElementById('ufList');\n  const svgArea = document.getElementById('svgArea');\n\n  let width, height;\n  function resizeSVG(){\n    const rect = svgArea.getBoundingClientRect();\n    width = rect.width; height = rect.height;\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    render();\n  }\n  window.addEventListener('resize', resizeSVG);\n\n  // Graph data\n  let nodes = [];\n  let edges = []; // {id,u,v,w}\n  let nodeElems = {}; // id -> svg group\n  let edgeElems = {}; // id -> svg group\n  let dragging = null;\n\n  // Kruskal state\n  let sortedEdges = [];\n  let edgeIndex = 0;\n  let uf = null;\n  let selectedEdges = [];\n  let considered = 0;\n  let playing = false;\n  let playTimer = null;\n\n  // Initialize\n  function init(){\n    nodeCountLabel.textContent = nodeCountInput.value;\n    edgeProbLabel.textContent = edgeProbInput.value;\n    speedLabel.textContent = speedInput.value + \" ms/step\";\n    createSampleGraph();\n    resizeSVG();\n    attachEvents();\n  }\n\n  function attachEvents(){\n    nodeCountInput.addEventListener('input', ()=>{\n      nodeCountLabel.textContent = nodeCountInput.value;\n    });\n    edgeProbInput.addEventListener('input', ()=>{\n      edgeProbLabel.textContent = edgeProbInput.value;\n    });\n    speedInput.addEventListener('input', ()=>{\n      speedLabel.textContent = speedInput.value + \" ms/step\";\n    });\n    randBtn.addEventListener('click', ()=> {\n      generateRandomGraph(parseInt(nodeCountInput.value), parseFloat(edgeProbInput.value));\n    });\n    sampleBtn.addEventListener('click', ()=> {\n      createSampleGraph();\n    });\n    resetBtn.addEventListener('click', ()=> {\n      resetAlgorithm();\n    });\n    stepBtn.addEventListener('click', ()=> {\n      step();\n    });\n    playBtn.addEventListener('click', togglePlay);\n    finishBtn.addEventListener('click', runToCompletion);\n    svg.addEventListener('mousedown', onSvgMouseDown);\n    document.addEventListener('mousemove', onDocMouseMove);\n    document.addEventListener('mouseup', onDocMouseUp);\n  }\n\n  // Graph creation\n  function createSampleGraph(){\n    // Small clear sample graph with 8 nodes\n    nodes = [];\n    const cX = 600/2, cY = 380/2;\n    const radius = Math.min(260, Math.min(window.innerWidth, window.innerHeight)*0.2);\n    const samplePositions = [\n      [100,80],[260,60],[460,60],[540,160],[480,300],[320,320],[160,260],[40,170]\n    ];\n    for(let i=0;i<8;i++){\n      nodes.push({id:i, x: samplePositions[i][0]+40, y: samplePositions[i][1]+20});\n    }\n    edges = [\n      {u:0,v:1,w:4},{u:0,v:7,w:8},{u:1,v:2,w:8},{u:1,v:7,w:11},\n      {u:2,v:3,w:7},{u:2,v:5,w:4},{u:2,v:8,w:2},{u:3,v:4,w:9},\n      {u:3,v:5,w:14},{u:4,v:5,w:10},{u:5,v:6,w:2},{u:6,v:7,w:1}\n    ].map((e,i)=>({id:i,u:e.u,v:e.v,w:e.w}));\n    // For sample we have 8 nodes (0..7); adjust edges to fit\n    edges = [\n      {id:0,u:0,v:1,w:3},{id:1,u:0,v:2,w:2},{id:2,u:1,v:2,w:1},\n      {id:3,u:1,v:3,w:4},{id:4,u:2,v:4,w:7},{id:5,u:3,v:4,w:2},\n      {id:6,u:3,v:5,w:3},{id:7,u:4,v:5,w:1},{id:8,u:0,v:5,w:8}\n    ];\n    // ensure nodes count matches max index\n    const maxNode = Math.max(...nodes.map(n=>n.id));\n    // place nodes in a circle to match positions\n    const pad = 60;\n    const cw = Math.max(520, width || 720);\n    for(let i=0;i<nodes.length;i++){\n      nodes[i].x = pad + (cw - 2*pad) * (0.15 + 0.7*(i/(nodes.length-1)));\n      nodes[i].y = 80 + (i%2?120:0);\n    }\n    buildGraph();\n  }\n\n  function generateRandomGraph(n, prob){\n    nodes = [];\n    edges = [];\n    const margin = 50;\n    for(let i=0;i<n;i++){\n      nodes.push({id:i,x:rand(margin, (width||800)-margin), y:rand(margin, (height||480)-margin)});\n    }\n    let id = 0;\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() <= prob){\n          edges.push({id:id++, u:i, v:j, w: rand(1,20)});\n        }\n      }\n    }\n    if(edges.length === 0){\n      // ensure at least a chain so graph is connected-ish\n      for(let i=0;i<n-1;i++) edges.push({id:id++, u:i, v:i+1, w: rand(1,9)});\n    }\n    buildGraph();\n  }\n\n  function buildGraph(){\n    // Clear previous\n    svg.innerHTML = '';\n    nodeElems = {}; edgeElems = {};\n    for(let e of edges){\n      createEdgeElem(e);\n    }\n    for(let v of nodes){\n      createNodeElem(v);\n    }\n    resetAlgorithm();\n    render();\n  }\n\n  // SVG element creation\n  function createNodeElem(node){\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n    g.setAttribute('class','node');\n    g.setAttribute('data-id', node.id);\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n    circle.setAttribute('r', 18);\n    circle.setAttribute('fill', '#0b1220');\n    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n    circle.setAttribute('stroke-width', 2);\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n    text.setAttribute('class','node-label');\n    text.textContent = node.id;\n    g.appendChild(circle);\n    g.appendChild(text);\n    svg.appendChild(g);\n    nodeElems[node.id] = {g: g, circle: circle, text: text};\n    updateNodePos(node);\n    // Events for dragging\n    g.addEventListener('mousedown', (ev)=> {\n      dragging = {id: node.id, offsetX: ev.offsetX - node.x, offsetY: ev.offsetY - node.y};\n      ev.stopPropagation();\n    });\n  }\n\n  function createEdgeElem(edge){\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n    g.setAttribute('data-id', edge.id);\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n    line.setAttribute('stroke', '#64748b');\n    line.setAttribute('stroke-width', 3);\n    line.setAttribute('stroke-linecap','round');\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n    text.setAttribute('class','edge-weight');\n    text.setAttribute('fill','#e6eef6');\n    text.setAttribute('text-anchor','middle');\n    text.setAttribute('dominant-baseline','central');\n    text.textContent = edge.w;\n    g.appendChild(line);\n    g.appendChild(text);\n    svg.appendChild(g);\n    edgeElems[edge.id] = {g:g, line:line, text:text};\n    // clicking an edge randomizes its weight (for exploration)\n    g.addEventListener('dblclick', ()=> {\n      edge.w = rand(1,20);\n      edgeElems[edge.id].text.textContent = edge.w;\n      resetAlgorithm();\n    });\n    updateEdgePos(edge);\n  }\n\n  function updateNodePos(node){\n    const e = nodeElems[node.id];\n    if(!e) return;\n    e.g.setAttribute('transform', `translate(${node.x},${node.y})`);\n    // highlight accepted nodes (in MST) by stroke color if connected\n    e.circle.setAttribute('stroke', 'rgba(255,255,255,0.08)');\n  }\n\n  function updateEdgePos(edge){\n    const a = nodes.find(n=>n.id===edge.u);\n    const b = nodes.find(n=>n.id===edge.v);\n    if(!a || !b) return;\n    const e = edgeElems[edge.id];\n    // set line endpoints\n    e.line.setAttribute('x1', a.x);\n    e.line.setAttribute('y1', a.y);\n    e.line.setAttribute('x2', b.x);\n    e.line.setAttribute('y2', b.y);\n    // position weight text at midpoint with slight offset\n    const mx = (a.x + b.x)/2;\n    const my = (a.y + b.y)/2;\n    e.text.setAttribute('x', mx);\n    e.text.setAttribute('y', my - 10);\n    e.text.textContent = edge.w;\n    // layer edges behind nodes\n    e.g.style.zIndex = 1;\n  }\n\n  // Rendering all\n  function render(){\n    // Update sizes if needed\n    for(let node of nodes) updateNodePos(node);\n    for(let edge of edges) updateEdgePos(edge);\n    // Update visual states based on kruskal state\n    // Colors: default '#64748b', current '#facc15', accepted '#34d399', rejected '#fb7185'\n    const acceptedSet = new Set(selectedEdges.map(e=>e.id));\n    for(let edge of edges){\n      const el = edgeElems[edge.id];\n      if(!el) continue;\n      if(acceptedSet.has(edge.id)){\n        el.line.setAttribute('stroke', '#34d399');\n        el.line.setAttribute('stroke-width', 4);\n        el.text.setAttribute('fill','#34d399');\n      } else if(edge._state === 'current'){\n        el.line.setAttribute('stroke', '#facc15');\n        el.line.setAttribute('stroke-width', 4);\n        el.text.setAttribute('fill','#facc15');\n      } else if(edge._state === 'rejected'){\n        el.line.setAttribute('stroke', '#fb7185');\n        el.line.setAttribute('stroke-width', 3);\n        el.text.setAttribute('fill','#fb7185');\n      } else {\n        el.line.setAttribute('stroke', '#64748b');\n        el.line.setAttribute('stroke-width', 3);\n        el.text.setAttribute('fill','#e6eef6');\n      }\n    }\n    // Update status UI\n    currentEdgeSpan.textContent = (sortedEdges[edgeIndex] ? `${sortedEdges[edgeIndex].u} - ${sortedEdges[edgeIndex].v} (w=${sortedEdges[edgeIndex].w})` : '—');\n    edgesConsideredSpan.textContent = considered;\n    totalEdgesSpan.textContent = sortedEdges.length;\n    let sum = selectedEdges.reduce((a,b)=>a+b.w,0);\n    mstWeightSpan.textContent = sum;\n    // selected edges list\n    if(selectedEdges.length===0) selectedList.textContent = '—';\n    else selectedList.innerHTML = selectedEdges.map(e=>`${e.u}—${e.v} (w=${e.w})`).join('<br>');\n    // union-find display\n    if(uf){\n      ufList.innerHTML = Array.from({length: nodes.length}, (_,i)=>`p[${i}] = ${uf.find(i)}`).join('<br>');\n    }else{\n      ufList.textContent = '—';\n    }\n  }\n\n  // Union-Find implementation with visible parent (no path compression on find to show structure clearly unless compress param)\n  class UnionFind {\n    constructor(n){\n      this.parent = Array.from({length:n}, (_,i)=>i);\n      this.rank = Array.from({length:n}, ()=>0);\n    }\n    find(x){\n      // iterative find with path compression disabled for clarity in display.\n      while(this.parent[x] !== x){\n        x = this.parent[x];\n      }\n      return x;\n    }\n    union(x,y){\n      let rx = this.find(x), ry = this.find(y);\n      if(rx === ry) return false;\n      if(this.rank[rx] < this.rank[ry]) this.parent[rx] = ry;\n      else if(this.rank[ry] < this.rank[rx]) this.parent[ry] = rx;\n      else { this.parent[ry] = rx; this.rank[rx]++; }\n      return true;\n    }\n  }\n\n  // Kruskal algorithm control\n  function resetAlgorithm(){\n    // reset states\n    for(let e of edges) e._state = null;\n    // Sort edges by weight asc, tie-break by ids\n    sortedEdges = edges.slice().sort((a,b)=> a.w - b.w || a.id - b.id);\n    edgeIndex = 0;\n    uf = new UnionFind(nodes.length);\n    selectedEdges = [];\n    considered = 0;\n    playing = false;\n    if(playTimer) { clearTimeout(playTimer); playTimer = null; playBtn.textContent = 'Auto Play'; }\n    render();\n  }\n\n  function step(){\n    if(edgeIndex >= sortedEdges.length){\n      // done\n      currentEdgeSpan.textContent = 'Done';\n      return;\n    }\n    // clear previous current markers\n    for(let e of edges) if(e._state === 'current') e._state = null;\n    const edge = sortedEdges[edgeIndex];\n    edge._state = 'current';\n    render();\n\n    // Consider this edge\n    considered++;\n    const ru = uf.find(edge.u), rv = uf.find(edge.v);\n    if(ru !== rv){\n      // accept\n      uf.union(edge.u, edge.v);\n      selectedEdges.push(edge);\n      edge._state = 'accepted';\n    } else {\n      // reject -> forms cycle\n      edge._state = 'rejected';\n    }\n    edgeIndex++;\n    // if MST has n-1 edges we can stop early\n    if(selectedEdges.length >= nodes.length - 1){\n      // mark rest as default (not checked)\n      for(let i=edgeIndex;i<sortedEdges.length;i++){\n        sortedEdges[i]._state = null;\n      }\n      edgeIndex = sortedEdges.length;\n    }\n    render();\n  }\n\n  function togglePlay(){\n    if(playing){\n      playing = false;\n      if(playTimer) clearTimeout(playTimer);\n      playTimer = null;\n      playBtn.textContent = 'Auto Play';\n    } else {\n      playing = true;\n      playBtn.textContent = 'Pause';\n      autoStep();\n    }\n  }\n\n  function autoStep(){\n    if(!playing) return;\n    step();\n    if(edgeIndex >= sortedEdges.length || selectedEdges.length >= nodes.length-1){\n      playing = false;\n      playBtn.textContent = 'Auto Play';\n      return;\n    }\n    playTimer = setTimeout(autoStep, parseInt(speedInput.value));\n  }\n\n  function runToCompletion(){\n    // Quickly finish without animation\n    while(edgeIndex < sortedEdges.length && selectedEdges.length < nodes.length - 1){\n      const edge = sortedEdges[edgeIndex];\n      const ru = uf.find(edge.u), rv = uf.find(edge.v);\n      if(ru !== rv){\n        uf.union(edge.u, edge.v);\n        selectedEdges.push(edge);\n        edge._state = 'accepted';\n      } else {\n        edge._state = 'rejected';\n      }\n      edgeIndex++;\n      considered++;\n    }\n    render();\n  }\n\n  // Interaction: dragging nodes updates edges live\n  function onSvgMouseDown(e){\n    // clicking blank area cancels dragging\n    dragging = null;\n  }\n  function onDocMouseMove(e){\n    if(!dragging) return;\n    // translate page coords to svg coordinates\n    const rect = svg.getBoundingClientRect();\n    const x = clamp(e.clientX - rect.left - dragging.offsetX, 20, rect.width-20);\n    const y = clamp(e.clientY - rect.top - dragging.offsetY, 20, rect.height-20);\n    const node = nodes.find(n=>n.id===dragging.id);\n    if(node){ node.x = x; node.y = y; updateNodePos(node); }\n    for(let edge of edges) updateEdgePos(edge);\n  }\n  function onDocMouseUp(e){\n    if(dragging){\n      dragging = null;\n      render();\n    }\n  }\n\n  // Initialize sample on load\n  init();\n\n  // Expose some helpful keyboard shortcuts (optional)\n  window.addEventListener('keydown', (ev)=>{\n    if(ev.key === ' '){ ev.preventDefault(); togglePlay(); }\n    if(ev.key === 'ArrowRight'){ step(); }\n    if(ev.key === 'r'){ generateRandomGraph(parseInt(nodeCountInput.value), parseFloat(edgeProbInput.value)); }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}