{
  "id": "e9334d60-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:37.913Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>Adjacency Matrix Interactive Demo</title>\n<style>\n  :root { --bg:#f7f8fb; --card:#ffffff; --accent:#1f6feb; --muted:#6b7280; --danger:#ef4444; }\n  body { margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background:var(--bg); color:#0f172a; }\n  .app { display:flex; gap:16px; padding:16px; box-sizing:border-box; height:100vh; }\n  .panel { background:var(--card); border-radius:8px; box-shadow:0 2px 8px rgba(2,6,23,0.08); padding:12px; display:flex; flex-direction:column; }\n  .left { flex:1 1 60%; min-width:320px; overflow:hidden; }\n  .right { width:420px; min-width:300px; max-width:520px; overflow:auto; }\n  .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }\n  .controls button, .controls label { background:#fff; border:1px solid #e6e9ef; padding:6px 8px; border-radius:6px; cursor:pointer; }\n  .controls input[type=\"checkbox\"] { margin-right:6px; }\n  .controls .active { background:linear-gradient(90deg,var(--accent),#60a5fa); color:#fff; border-color:transparent; }\n  .svgwrap { border-radius:8px; background:linear-gradient(180deg,#fbfdff,#f6f9ff); padding:8px; height:calc(100% - 120px); display:flex; flex-direction:column; }\n  svg { width:100%; height:100%; touch-action:none; cursor:default; user-select:none; }\n  .info { font-size:13px; color:var(--muted); margin-top:8px; }\n  table { border-collapse:collapse; width:100%; }\n  .matrix-wrap { overflow:auto; max-height:72vh; border-radius:6px; border:1px solid #e6e9ef; }\n  table.matrix { border-collapse:collapse; width:100%; min-width:320px; }\n  table.matrix th, table.matrix td { border:1px solid #eef2f7; padding:6px; text-align:center; min-width:36px; font-family:monospace; font-size:13px; }\n  table.matrix th { background:#fbfdff; position:sticky; top:0; z-index:2; }\n  table.matrix th.col-head { position:sticky; left:0; z-index:3; background:#fbfdff; }\n  td.cell { cursor:pointer; }\n  td.cell:hover { background:rgba(31,111,235,0.06); }\n  td.cell.active, td.cell.highlight { background:rgba(31,111,235,0.14); }\n  .node { stroke:#0f172a; stroke-width:1px; fill:#fff; cursor:pointer; }\n  .node.highlight { stroke:var(--accent); stroke-width:2px; }\n  .edge { stroke:#94a3b8; stroke-width:2px; fill:none; }\n  .edge.highlight { stroke:var(--accent); stroke-width:3px; }\n  .weight-label { font-family:monospace; font-size:12px; fill:#0f172a; background:#fff; }\n  .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n  .small { font-size:13px; padding:6px 8px; }\n  .muted { color:var(--muted); font-size:13px; }\n  .textarea { width:100%; height:90px; box-sizing:border-box; border:1px solid #e6e9ef; border-radius:6px; padding:8px; font-family:monospace; }\n  .footer { margin-top:8px; font-size:13px; color:var(--muted); }\n  .topbar { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }\n  .kbd { background:#fff; border:1px solid #e6e9ef; padding:2px 6px; border-radius:4px; font-family:monospace; font-size:12px; }\n  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n  .btn-danger { background:var(--danger); color:#fff; border:none; }\n  .btn-ghost { background:transparent; border:1px dashed #e6e9ef; }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"panel left\">\n    <div class=\"topbar\">\n      <div class=\"row\">\n        <div class=\"controls\">\n          <button id=\"addNodeBtn\" class=\"small\">Add Node</button>\n          <button id=\"addEdgeBtn\" class=\"small\">Add Edge</button>\n          <button id=\"deleteModeBtn\" class=\"small\">Delete</button>\n          <label class=\"small\"><input type=\"checkbox\" id=\"directedChk\"> Directed</label>\n          <label class=\"small\"><input type=\"checkbox\" id=\"weightedChk\"> Weighted</label>\n          <label class=\"small\"><input type=\"checkbox\" id=\"selfLoopChk\"> Self-loops</label>\n          <button id=\"randomBtn\" class=\"small\">Random</button>\n          <button id=\"clearBtn\" class=\"small btn-danger\">Clear</button>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"muted\">Click nodes to add edges. Drag to move. Click matrix cells to toggle edges.</div>\n      </div>\n    </div>\n\n    <div class=\"svgwrap\">\n      <svg id=\"canvas\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid slice\">\n        <defs>\n          <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#94a3b8\"></path>\n          </marker>\n          <marker id=\"arrow-highlight\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"var(--accent)\"></path>\n          </marker>\n        </defs>\n        <g id=\"edges\"></g>\n        <g id=\"nodes\"></g>\n        <g id=\"labels\"></g>\n      </svg>\n    </div>\n\n    <div class=\"info\">\n      Controls: Add Node (click on canvas), Add Edge (click source then target), Delete mode (click node or edge), Directed/Weighted toggles. Click matrix cells to toggle edges; double-click to edit weight.\n    </div>\n  </div>\n\n  <div class=\"panel right\">\n    <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n      <button id=\"exportBtn\" class=\"small\">Copy Matrix</button>\n      <button id=\"importBtn\" class=\"small\">Import Matrix</button>\n      <button id=\"fromAdjListBtn\" class=\"small btn-ghost\">Example</button>\n    </div>\n\n    <div class=\"matrix-wrap\" id=\"matrixWrap\" tabindex=\"0\">\n      <!-- adjacency matrix table injected here -->\n    </div>\n\n    <div style=\"margin-top:8px;\">\n      <textarea id=\"matrixText\" class=\"textarea\" placeholder=\"Paste numeric adjacency matrix here (rows separated by newlines, numbers separated by spaces or commas)\"></textarea>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <button id=\"loadMatrixBtn\" class=\"small\">Build Graph from Matrix</button>\n        <button id=\"clearTextBtn\" class=\"small\">Clear</button>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      This demo keeps a list of nodes and edges and synchronizes a visual graph with its adjacency matrix. It supports directed/undirected graphs and optional edge weights.\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Adjacency Matrix Interactive Demo\n  - Click \"Add Node\" then click on SVG to add a node (or click Add Node repeatedly to create at random positions).\n  - Toggle \"Add Edge\" then click two nodes to add an edge from first to second (or undirected if not directed).\n  - Drag nodes to reposition.\n  - Click matrix cells to toggle edges; double-click to edit weight.\n  - Import/paste a numeric matrix to build graph.\n*/\n\n(() => {\n  const svg = document.getElementById('canvas');\n  const edgesGroup = document.getElementById('edges');\n  const nodesGroup = document.getElementById('nodes');\n  const labelsGroup = document.getElementById('labels');\n  const matrixWrap = document.getElementById('matrixWrap');\n  const matrixText = document.getElementById('matrixText');\n\n  // Controls\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const deleteModeBtn = document.getElementById('deleteModeBtn');\n  const directedChk = document.getElementById('directedChk');\n  const weightedChk = document.getElementById('weightedChk');\n  const selfLoopChk = document.getElementById('selfLoopChk');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const exportBtn = document.getElementById('exportBtn');\n  const importBtn = document.getElementById('importBtn');\n  const loadMatrixBtn = document.getElementById('loadMatrixBtn');\n  const fromAdjListBtn = document.getElementById('fromAdjListBtn');\n  const clearTextBtn = document.getElementById('clearTextBtn');\n\n  let mode = null; // 'addNode', 'addEdge', 'delete'\n  let nodes = []; // {id, x, y}\n  let edges = new Map(); // key -> {from, to, weight}\n  let nextId = 0;\n  let edgeSource = null;\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n\n  // Utility\n  function nodeKey(id) { return String(id); }\n  function edgeKey(u,v, directed) {\n    if (!directed) {\n      // canonical order for undirected\n      return u <= v ? `${u}|${v}` : `${v}|${u}`;\n    }\n    return `${u}|${v}`;\n  }\n\n  // Initial sample graph\n  function initSample() {\n    clearAll();\n    addNodeAt(150,120);\n    addNodeAt(420,80);\n    addNodeAt(300,280);\n    addNodeAt(650,210);\n    addEdgeInternal(0,1,1);\n    addEdgeInternal(1,2,2);\n    addEdgeInternal(2,0,0.5);\n    addEdgeInternal(2,3,3);\n    directedChk.checked = false;\n    weightedChk.checked = true;\n    render();\n  }\n\n  // Add / remove nodes & edges\n  function addNodeAt(x,y) {\n    const id = nextId++;\n    nodes.push({id,x,y});\n    render();\n    return id;\n  }\n\n  function removeNode(id) {\n    nodes = nodes.filter(n => n.id !== id);\n    // remove edges touching node\n    for (const k of Array.from(edges.keys())) {\n      const e = edges.get(k);\n      if (e.from === id || e.to === id) edges.delete(k);\n    }\n    render();\n  }\n\n  function addEdgeInternal(u,v,weight=1) {\n    if (!selfLoopChk.checked && u===v) return;\n    const key = edgeKey(u,v, directedChk.checked);\n    if (!edges.has(key)) {\n      edges.set(key, {from:u, to:v, weight: weight});\n    } else {\n      // update weight\n      edges.get(key).weight = weight;\n    }\n    render();\n  }\n\n  function removeEdgeInternal(u,v) {\n    const key = edgeKey(u,v, directedChk.checked);\n    edges.delete(key);\n    render();\n  }\n\n  function toggleEdge(u,v) {\n    const key = edgeKey(u,v, directedChk.checked);\n    if (edges.has(key)) edges.delete(key);\n    else addEdgeInternal(u,v, weightedChk.checked ? 1 : 1);\n    render();\n  }\n\n  // Rendering\n  function clearSVGGroup(g) { while (g.firstChild) g.removeChild(g.firstChild); }\n\n  function render() {\n    // Clear\n    clearSVGGroup(edgesGroup);\n    clearSVGGroup(nodesGroup);\n    clearSVGGroup(labelsGroup);\n\n    // Draw edges\n    const directed = directedChk.checked;\n    const used = new Set(); // for undirected, draw each pair once\n    for (const e of edges.values()) {\n      const key = edgeKey(e.from,e.to, directed);\n      if (!directed) {\n        // determine canonical key to avoid duplicate lines\n        const canon = edgeKey(e.from,e.to, false);\n        if (used.has(canon)) continue;\n        used.add(canon);\n      }\n      const a = nodes.find(n=>n.id===e.from);\n      const b = nodes.find(n=>n.id===e.to);\n      if (!a || !b) continue;\n      drawEdge(a,b,e, directed);\n    }\n\n    // Draw nodes\n    for (const n of nodes) drawNode(n);\n\n    // Draw labels (node ids)\n    for (const n of nodes) {\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x',n.x);\n      text.setAttribute('y',n.y+4);\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('font-size','12');\n      text.setAttribute('fill','#0f172a');\n      text.setAttribute('pointer-events','none');\n      text.textContent = String(n.id);\n      labelsGroup.appendChild(text);\n    }\n\n    buildMatrix();\n  }\n\n  function drawNode(n) {\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('class','node-g');\n    g.dataset.id = n.id;\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('cx', n.x);\n    circle.setAttribute('cy', n.y);\n    circle.setAttribute('r', 20);\n    circle.setAttribute('class','node');\n    circle.style.fill = '#fff';\n    circle.style.stroke = '#0f172a';\n    g.appendChild(circle);\n    nodesGroup.appendChild(g);\n\n    // Events\n    g.addEventListener('pointerdown', (ev) => {\n      ev.preventDefault();\n      if (mode === 'addEdge') {\n        if (edgeSource === null) {\n          edgeSource = n.id;\n          highlightNode(n.id,true);\n        } else {\n          // add edge from edgeSource -> n.id\n          addEdgeInternal(edgeSource, n.id, weightedChk.checked ? 1 : 1);\n          highlightNode(edgeSource,false);\n          edgeSource = null;\n        }\n        return;\n      }\n      if (mode === 'delete') {\n        // remove node\n        removeNode(n.id);\n        return;\n      }\n      // start dragging\n      dragging = n.id;\n      const pt = svg.createSVGPoint();\n      pt.x = ev.clientX; pt.y = ev.clientY;\n      const ctm = svg.getScreenCTM();\n      const svgP = pt.matrixTransform(ctm.inverse());\n      dragOffset.x = n.x - svgP.x;\n      dragOffset.y = n.y - svgP.y;\n      g.setPointerCapture(ev.pointerId);\n    });\n\n    g.addEventListener('pointerenter', () => {\n      highlightNode(n.id,true);\n      highlightMatrixCellsForNode(n.id,true);\n    });\n    g.addEventListener('pointerleave', () => {\n      highlightNode(n.id,false);\n      highlightMatrixCellsForNode(n.id,false);\n    });\n  }\n\n  function highlightNode(id, on) {\n    const circles = nodesGroup.querySelectorAll('g.node-g');\n    for (const g of circles) {\n      if (Number(g.dataset.id) === id) {\n        const c = g.querySelector('circle.node');\n        if (c) {\n          if (on) c.classList.add('highlight'); else c.classList.remove('highlight');\n        }\n      }\n    }\n    // highlight edges adjacent\n    for (const el of edgesGroup.querySelectorAll('path.edge')) {\n      const f = el.dataset.from|0, t = el.dataset.to|0;\n      if (f===id || t===id) {\n        if (on) el.classList.add('highlight'); else el.classList.remove('highlight');\n      }\n    }\n  }\n\n  function highlightMatrixCellsForNode(id, on) {\n    const tbl = matrixWrap.querySelector('table.matrix');\n    if (!tbl) return;\n    for (let r=0;r<nodes.length;r++){\n      for (let c=0;c<nodes.length;c++){\n        const cell = tbl.rows[r+1].cells[c+1]; // header offset\n        if (!cell) continue;\n        if (Number(tbl.rows[r+1].dataset.row)===id || Number(tbl.rows[0].cells[c+1].dataset.col)===id) {\n          if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');\n        }\n      }\n    }\n  }\n\n  function drawEdge(a,b,e, directed) {\n    // compute line endpoints with offsets from node circle radius\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const dist = Math.hypot(dx,dy) || 1;\n    const r = 22;\n    const sx = a.x + (dx/dist)*r;\n    const sy = a.y + (dy/dist)*r;\n    const ex = b.x - (dx/dist)*r;\n    const ey = b.y - (dy/dist)*r;\n\n    const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n    const d = `M ${sx} ${sy} L ${ex} ${ey}`;\n    path.setAttribute('d',d);\n    path.setAttribute('class','edge');\n    path.dataset.from = e.from;\n    path.dataset.to = e.to;\n    if (directed) {\n      path.setAttribute('marker-end','url(#arrow)');\n    }\n    // For highlighting arrow marker color update manually via class and marker; but we'll swap marker on hover by switching attribute\n    path.addEventListener('pointerenter', () => {\n      path.classList.add('highlight');\n      if (directed) path.setAttribute('marker-end','url(#arrow-highlight)');\n      highlightMatrixCellsForEdge(e, true);\n    });\n    path.addEventListener('pointerleave', () => {\n      path.classList.remove('highlight');\n      if (directed) path.setAttribute('marker-end','url(#arrow)');\n      highlightMatrixCellsForEdge(e, false);\n    });\n    path.addEventListener('click', (ev) => {\n      ev.stopPropagation();\n      if (mode === 'delete') {\n        // delete this edge\n        const key = edgeKey(e.from,e.to,directed);\n        edges.delete(key);\n        render();\n      } else if (mode === 'addEdge') {\n        // pick this edge as source?\n        edgeSource = e.from;\n      }\n    });\n    edgesGroup.appendChild(path);\n\n    // weight label\n    if (weightedChk.checked) {\n      const tx = (sx+ex)/2;\n      const ty = (sy+ey)/2;\n      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n      txt.setAttribute('x',tx);\n      txt.setAttribute('y',ty-6);\n      txt.setAttribute('class','weight-label');\n      txt.setAttribute('text-anchor','middle');\n      txt.textContent = String(e.weight);\n      labelsGroup.appendChild(txt);\n    }\n  }\n\n  function highlightMatrixCellsForEdge(e,on) {\n    const tbl = matrixWrap.querySelector('table.matrix');\n    if (!tbl) return;\n    const rows = nodes.map(n=>n.id);\n    for (let r=0;r<nodes.length;r++){\n      for (let c=0;c<nodes.length;c++){\n        if (nodes[r].id === e.from && nodes[c].id === e.to) {\n          const cell = tbl.rows[r+1].cells[c+1];\n          if (cell) {\n            if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');\n          }\n        }\n        if (!directedChk.checked) {\n          if (nodes[r].id === e.to && nodes[c].id === e.from) {\n            const cell = tbl.rows[r+1].cells[c+1];\n            if (cell) {\n              if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Matrix building & interactions\n  function buildMatrix() {\n    // Create matrix NxN table\n    const n = nodes.length;\n    const tbl = document.createElement('table');\n    tbl.className = 'matrix';\n    const thead = document.createElement('thead');\n    const headRow = document.createElement('tr');\n    const empty = document.createElement('th'); headRow.appendChild(empty);\n    // columns header (node ids)\n    for (const c of nodes) {\n      const th = document.createElement('th');\n      th.textContent = c.id;\n      th.dataset.col = c.id;\n      headRow.appendChild(th);\n    }\n    thead.appendChild(headRow);\n    tbl.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    // Fill rows\n    for (let i=0;i<n;i++) {\n      const row = document.createElement('tr');\n      row.dataset.row = nodes[i].id;\n      const th = document.createElement('th');\n      th.className = 'col-head';\n      th.textContent = nodes[i].id;\n      row.appendChild(th);\n      for (let j=0;j<n;j++) {\n        const td = document.createElement('td');\n        td.className = 'cell';\n        const u = nodes[i].id;\n        const v = nodes[j].id;\n        let val = 0;\n        if (directedChk.checked) {\n          const key = edgeKey(u,v,true);\n          if (edges.has(key)) val = edges.get(key).weight ?? 1;\n        } else {\n          const key = edgeKey(u,v,false);\n          if (edges.has(key)) {\n            const e = edges.get(key);\n            // for undirected, present the same weight both places\n            val = e.weight ?? 1;\n          }\n        }\n        td.textContent = String(val);\n        td.dataset.u = u; td.dataset.v = v;\n        td.addEventListener('click', (ev) => {\n          ev.stopPropagation();\n          // toggle edge (use directed mode setting at the time)\n          if (mode === 'delete') {\n            // delete if present\n            const key = edgeKey(u,v,directedChk.checked);\n            if (edges.has(key)) edges.delete(key);\n          } else {\n            // toggle\n            const key = edgeKey(u,v,directedChk.checked);\n            if (edges.has(key)) edges.delete(key);\n            else {\n              // if weighted, default weight 1\n              addEdgeInternal(u,v, weightedChk.checked ? 1 : 1);\n            }\n          }\n          render();\n        });\n        td.addEventListener('dblclick', (ev) => {\n          ev.stopPropagation();\n          // edit weight if weighted\n          const newW = prompt(`Enter weight for edge ${u} -> ${v} (empty to remove)`, td.textContent);\n          if (newW === null) return;\n          const trimmed = newW.trim();\n          if (trimmed === '') {\n            // remove edge\n            const key = edgeKey(u,v,directedChk.checked);\n            edges.delete(key);\n          } else {\n            const num = Number(trimmed);\n            if (Number.isNaN(num)) { alert('Invalid number'); return; }\n            addEdgeInternal(u,v,num);\n          }\n          render();\n        });\n        td.addEventListener('mouseenter', () => {\n          // highlight corresponding nodes/edges\n          highlightCell(u,v,true);\n        });\n        td.addEventListener('mouseleave', () => {\n          highlightCell(u,v,false);\n        });\n\n        row.appendChild(td);\n      }\n      tbody.appendChild(row);\n    }\n    tbl.appendChild(tbody);\n\n    // replace matrixWrap content\n    matrixWrap.innerHTML = '';\n    matrixWrap.appendChild(tbl);\n  }\n\n  function highlightCell(u,v,on) {\n    // highlight nodes u and v and the edge (u->v)\n    highlightNode(u,on);\n    highlightNode(v,on);\n    // edges\n    for (const el of edgesGroup.querySelectorAll('path.edge')) {\n      const f = Number(el.dataset.from), t = Number(el.dataset.to);\n      if (directedChk.checked) {\n        if (f===u && t===v) {\n          if (on) { el.classList.add('highlight'); el.setAttribute('marker-end','url(#arrow-highlight)'); }\n          else { el.classList.remove('highlight'); el.setAttribute('marker-end','url(#arrow)'); }\n        }\n      } else {\n        // undirected: match either orientation\n        if ((f===u && t===v) || (f===v && t===u) || (f===u && t===v)) {\n          if (on) el.classList.add('highlight'); else el.classList.remove('highlight');\n        }\n      }\n    }\n  }\n\n  // Events: svg click to add node\n  svg.addEventListener('pointerdown', (ev) => {\n    if (mode === 'addNode') {\n      // add at mouse pos\n      const pt = svg.createSVGPoint();\n      pt.x = ev.clientX; pt.y = ev.clientY;\n      const ctm = svg.getScreenCTM();\n      const p = pt.matrixTransform(ctm.inverse());\n      addNodeAt(p.x, p.y);\n    }\n  });\n\n  // pointermove for dragging\n  svg.addEventListener('pointermove', (ev) => {\n    if (dragging !== null) {\n      const pt = svg.createSVGPoint();\n      pt.x = ev.clientX; pt.y = ev.clientY;\n      const ctm = svg.getScreenCTM();\n      const p = pt.matrixTransform(ctm.inverse());\n      const n = nodes.find(x=>x.id===dragging);\n      if (n) {\n        n.x = p.x + dragOffset.x;\n        n.y = p.y + dragOffset.y;\n        render();\n      }\n    }\n  });\n  // pointerup stop dragging\n  svg.addEventListener('pointerup', (ev) => {\n    if (dragging !== null) {\n      // release pointer capture on node if any\n      const g = nodesGroup.querySelector(`g.node-g[data-id=\"${dragging}\"]`);\n      if (g) {\n        try { g.releasePointerCapture(ev.pointerId); } catch(e){}\n      }\n      dragging = null;\n    }\n  });\n\n  // Control actions\n  addNodeBtn.addEventListener('click', () => {\n    setMode('addNode');\n    addNodeBtn.classList.toggle('active', mode==='addNode');\n  });\n  addEdgeBtn.addEventListener('click', () => {\n    setMode('addEdge');\n    addEdgeBtn.classList.toggle('active', mode==='addEdge');\n    edgeSource = null;\n  });\n  deleteModeBtn.addEventListener('click', () => {\n    setMode('delete');\n    deleteModeBtn.classList.toggle('active', mode==='delete');\n  });\n\n  directedChk.addEventListener('change', () => {\n    // When switching between directed and undirected, we need to possibly consolidate or separate edges.\n    if (!directedChk.checked) {\n      // undirected: convert any pair u->v and v->u into single canonical edge with weight of first found\n      const newEdges = new Map();\n      for (const e of edges.values()) {\n        const k = edgeKey(e.from,e.to,false);\n        if (!newEdges.has(k)) newEdges.set(k, {from: e.from, to: e.to, weight: e.weight});\n      }\n      edges = newEdges;\n    } else {\n      // directed: keep as is; undirected entries remain as single key; when viewing as directed, interpret each as inserted edge in canonical orientation\n      // expand undirected edges into one directed edge (keep the stored from,to)\n      const newEdges = new Map();\n      for (const e of edges.values()) {\n        const k = edgeKey(e.from,e.to,true);\n        newEdges.set(k, {from:e.from, to:e.to, weight:e.weight});\n      }\n      edges = newEdges;\n    }\n    render();\n  });\n\n  weightedChk.addEventListener('change', () => {\n    // If weights disabled, remove numeric weights display but keep numbers internally\n    render();\n  });\n\n  randomBtn.addEventListener('click', () => {\n    // generate random graph with current directed/weighted settings\n    clearAll();\n    const count = Math.floor(Math.random()*5)+4;\n    for (let i=0;i<count;i++) addNodeAt(120 + Math.random()*760, 80 + Math.random()*520);\n    const density = 0.25 + Math.random()*0.45;\n    for (let i=0;i<nodes.length;i++){\n      for (let j=0;j<nodes.length;j++){\n        if (i===j && !selfLoopChk.checked) continue;\n        if (Math.random() < density) {\n          const w = weightedChk.checked ? (Math.round((Math.random()*9+0.1)*10)/10) : 1;\n          addEdgeInternal(nodes[i].id, nodes[j].id, w);\n        }\n      }\n    }\n    render();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if (!confirm('Clear all nodes and edges?')) return;\n    clearAll();\n    render();\n  });\n\n  exportBtn.addEventListener('click', () => {\n    const text = adjacencyMatrixToText();\n    navigator.clipboard?.writeText(text).then(()=> {\n      alert('Matrix copied to clipboard');\n    }).catch(()=>{\n      // fallback: select textarea\n      matrixText.value = text;\n      matrixText.select();\n    });\n  });\n\n  importBtn.addEventListener('click', () => {\n    alert('Paste a numeric adjacency matrix into the textarea on the right, then click \"Build Graph from Matrix\".');\n  });\n\n  loadMatrixBtn.addEventListener('click', () => {\n    const txt = matrixText.value.trim();\n    if (!txt) { alert('Paste matrix first'); return; }\n    const matrix = parseMatrixText(txt);\n    if (!matrix) { alert('Could not parse matrix. Ensure rows of numbers separated by spaces, commas, or tabs.'); return; }\n    buildFromMatrix(matrix);\n  });\n\n  fromAdjListBtn.addEventListener('click', ()=> {\n    // Example adjacency matrix\n    matrixText.value = \"0 1 0 1\\n1 0 1 0\\n0 1 0 1\\n1 0 1 0\";\n  });\n\n  clearTextBtn.addEventListener('click', ()=> { matrixText.value=''; });\n\n  // Helpers\n  function setMode(m) {\n    mode = (mode === m) ? null : m;\n    // update button visuals\n    addNodeBtn.classList.toggle('active', mode==='addNode');\n    addEdgeBtn.classList.toggle('active', mode==='addEdge');\n    deleteModeBtn.classList.toggle('active', mode==='delete');\n    edgeSource = null;\n  }\n\n  function clearAll() {\n    nodes = [];\n    edges = new Map();\n    nextId = 0;\n    edgeSource = null;\n    dragging = null;\n  }\n\n  function adjacencyMatrixToText() {\n    // rows of numbers separated by spaces\n    const ids = nodes.map(n=>n.id);\n    const n = nodes.length;\n    const lines = [];\n    for (let i=0;i<n;i++){\n      const row = [];\n      for (let j=0;j<n;j++){\n        const u = nodes[i].id;\n        const v = nodes[j].id;\n        let val = 0;\n        if (directedChk.checked) {\n          const key = edgeKey(u,v,true);\n          if (edges.has(key)) val = edges.get(key).weight ?? 1;\n        } else {\n          const key = edgeKey(u,v,false);\n          if (edges.has(key)) val = edges.get(key).weight ?? 1;\n        }\n        row.push(String(val));\n      }\n      lines.push(row.join(' '));\n    }\n    return lines.join('\\n');\n  }\n\n  function parseMatrixText(txt) {\n    const rows = txt.trim().split(/\\r?\\n/).map(r=>r.trim()).filter(Boolean);\n    const matrix = [];\n    for (const r of rows) {\n      const parts = r.split(/[\\s,]+/).map(s=>s.trim()).filter(Boolean);\n      const nums = parts.map(p=>Number(p));\n      if (nums.some(x=>Number.isNaN(x))) return null;\n      matrix.push(nums);\n    }\n    // ensure square: if not square, return null\n    const m = matrix.length;\n    if (matrix.some(row => row.length !== m)) return null;\n    return matrix;\n  }\n\n  function buildFromMatrix(mat) {\n    clearAll();\n    const n = mat.length;\n    for (let i=0;i<n;i++) {\n      addNodeAt(100 + (i%5)*140 + Math.random()*20, 100 + Math.floor(i/5)*160 + Math.random()*20);\n    }\n    // By default treat as directed if any asymmetry found; else as undirected\n    let directed = false;\n    for (let i=0;i<n;i++){\n      for (let j=0;j<n;j++){\n        if (mat[i][j] !== mat[j][i]) directed = true;\n      }\n    }\n    directedChk.checked = directed;\n    // add edges\n    for (let i=0;i<n;i++){\n      for (let j=0;j<n;j++){\n        const val = mat[i][j];\n        if (!val) continue;\n        const u = nodes[i].id, v = nodes[j].id;\n        if (!directed) {\n          if (i<=j) addEdgeInternal(u,v,val);\n        } else {\n          addEdgeInternal(u,v,val);\n        }\n      }\n    }\n    render();\n  }\n\n  // init\n  initSample();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}