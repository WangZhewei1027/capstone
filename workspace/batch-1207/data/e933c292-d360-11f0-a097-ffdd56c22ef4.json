{
  "id": "e933c292-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:48.926Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Heap Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#2dd4bf;\n      --muted:#94a3b8;\n      --bar:#60a5fa;\n      --compare:#f59e0b;\n      --swap:#ef4444;\n      --heap:#34d399;\n      --sorted:#64748b;\n      --text:#e6eef8;\n      --glass: rgba(255,255,255,0.03);\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071028);color:var(--text)}\n    .wrap{max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg,var(--panel),rgba(11,18,32,0.8));box-shadow:0 6px 30px rgba(2,6,23,0.6);}\n    h1{margin:0 0 6px;font-size:20px;color:var(--accent)}\n    p.lead{margin:0 0 18px;color:var(--muted);font-size:13px}\n    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}\n    .controls > *{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--text);font-size:13px}\n    button.btn{cursor:pointer;border:0;padding:10px 12px;background:linear-gradient(180deg,#0b1220,rgba(255,255,255,0.02));color:var(--text);border-radius:8px}\n    button.btn.primary{background:linear-gradient(180deg,#0369a1,#164e63);color:white}\n    .controls .row{display:flex;gap:8px;align-items:center}\n    label{font-size:13px;color:var(--muted);margin-right:6px}\n    input[type=range]{width:140px}\n    .board{display:flex;gap:12px;align-items:end;height:360px;padding:18px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.02)}\n    .bars{flex:1;height:100%;display:flex;align-items:end;gap:2px}\n    .bar{flex:1 0 8px;height:40px;background:var(--bar);border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:rgba(255,255,255,0.9);font-size:11px;position:relative;transition:height 180ms linear, background-color 120ms linear, transform 120ms linear}\n    .bar.hidden-label{font-size:0}\n    .bar .val{position:absolute;top:6px;left:6px;font-size:11px;color:rgba(255,255,255,0.9)}\n    .info{display:flex;gap:14px;align-items:center;margin-top:12px;flex-wrap:wrap}\n    .chip{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px;border:1px solid rgba(255,255,255,0.02)}\n    .legend{display:flex;gap:8px;align-items:center}\n    .legend .key{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}\n    .swatch{width:14px;height:14px;border-radius:4px;box-shadow:inset 0 -2px rgba(0,0,0,0.2)}\n    .footer{margin-top:18px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}\n    .codebox{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;font-size:12px;color:var(--muted);max-height:140px;overflow:auto}\n    .small{font-size:12px;color:var(--muted)}\n    @media (max-width:720px){\n      .board{height:320px;padding:12px}\n      .controls{gap:8px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\" role=\"application\" aria-label=\"Heap Sort Visualizer\">\n    <h1>Heap Sort Visualizer</h1>\n    <p class=\"lead\">Interactive demonstration of Heap Sort. Build a heap, then repeatedly extract the root to sort the array. Use the controls to step through or animate the algorithm.</p>\n\n    <div class=\"controls\" aria-hidden=\"false\">\n      <div class=\"row\">\n        <button class=\"btn primary\" id=\"playBtn\" title=\"Play / Pause\">Play</button>\n        <button class=\"btn\" id=\"stepBtn\" title=\"Step one action\">Step</button>\n        <button class=\"btn\" id=\"resetBtn\" title=\"Reset array\">Reset</button>\n        <button class=\"btn\" id=\"shuffleBtn\" title=\"Shuffle array\">Shuffle</button>\n      </div>\n\n      <div class=\"row\">\n        <label for=\"size\">Size</label>\n        <input type=\"range\" id=\"size\" min=\"8\" max=\"80\" value=\"36\">\n        <span id=\"sizeVal\" class=\"small\">36</span>\n      </div>\n\n      <div class=\"row\">\n        <label for=\"speed\">Speed</label>\n        <input type=\"range\" id=\"speed\" min=\"10\" max=\"1000\" value=\"220\">\n        <span id=\"speedVal\" class=\"small\">220ms</span>\n      </div>\n\n      <div class=\"row\">\n        <label for=\"order\">Order</label>\n        <select id=\"order\" title=\"Sort order\">\n          <option value=\"asc\" selected>Ascending</option>\n          <option value=\"desc\">Descending</option>\n        </select>\n      </div>\n\n      <div class=\"row\">\n        <button class=\"btn\" id=\"randomizeBtn\">Randomize Values</button>\n      </div>\n    </div>\n\n    <div class=\"board\" aria-live=\"polite\">\n      <div class=\"bars\" id=\"bars\" role=\"list\"></div>\n    </div>\n\n    <div class=\"info\" aria-hidden=\"false\">\n      <div class=\"chip\">Comparisons: <strong id=\"comp\">0</strong></div>\n      <div class=\"chip\">Swaps: <strong id=\"swaps\">0</strong></div>\n      <div class=\"chip\">Steps: <strong id=\"steps\">0</strong></div>\n      <div class=\"chip\">Phase: <strong id=\"phase\">idle</strong></div>\n      <div class=\"chip\">Heap size (current): <strong id=\"heapSize\">-</strong></div>\n\n      <div style=\"margin-left:auto\" class=\"legend\">\n        <div class=\"key\"><div class=\"swatch\" style=\"background:var(--compare)\"></div> Compare</div>\n        <div class=\"key\"><div class=\"swatch\" style=\"background:var(--swap)\"></div> Swap</div>\n        <div class=\"key\"><div class=\"swatch\" style=\"background:var(--heap)\"></div> Heap area</div>\n        <div class=\"key\"><div class=\"swatch\" style=\"background:var(--sorted)\"></div> Sorted</div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <div style=\"flex:1 1 60%\">\n        <div class=\"small\">How it works: For ascending sort, Heap Sort builds a max-heap; then the largest element (root) is swapped to the end and removed from the heap. The heap is re-heapified and the process repeats.</div>\n      </div>\n      <div style=\"max-width:360px\">\n        <div class=\"codebox\" id=\"pseudocode\">\nheapify(n, i):\n  largest = i\n  left = 2*i + 1\n  right = 2*i + 2\n  if left < n and arr[left] > arr[largest]: largest = left\n  if right < n and arr[right] > arr[largest]: largest = right\n  if largest != i:\n    swap(arr[i], arr[largest])\n    heapify(n, largest)\n\nheapSort(arr):\n  build heap: for i from floor(n/2)-1 downto 0: heapify(n, i)\n  for end from n-1 downto 1:\n    swap(arr[0], arr[end])\n    heapify(end, 0)\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Elements\n  const barsEl = document.getElementById('bars');\n  const playBtn = document.getElementById('playBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const randomizeBtn = document.getElementById('randomizeBtn');\n  const sizeInput = document.getElementById('size');\n  const sizeVal = document.getElementById('sizeVal');\n  const speedInput = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n  const orderSel = document.getElementById('order');\n  const compEl = document.getElementById('comp');\n  const swapsEl = document.getElementById('swaps');\n  const stepsEl = document.getElementById('steps');\n  const phaseEl = document.getElementById('phase');\n  const heapSizeEl = document.getElementById('heapSize');\n\n  // State\n  let arr = [];\n  let bars = [];\n  let n = parseInt(sizeInput.value,10);\n  let generator = null;\n  let running = false;\n  let timer = null;\n  let delay = parseInt(speedInput.value,10);\n  let stats = {comparisons:0, swaps:0, steps:0};\n  let lastAction = null;\n  let highlight = {}; // indices coloring\n  let order = orderSel.value; // 'asc' or 'desc'\n  let heapActiveSize = -1;\n\n  // Init\n  sizeVal.textContent = n;\n  speedVal.textContent = delay + 'ms';\n\n  function createArray(len, min=5, max=100){\n    const a = [];\n    for(let i=0;i<len;i++){\n      a.push(Math.floor(Math.random()*(max-min+1))+min);\n    }\n    return a;\n  }\n\n  function render(){\n    barsEl.innerHTML = '';\n    bars = [];\n    const maxv = Math.max(...arr);\n    const showLabels = arr.length <= 40;\n    for(let i=0;i<arr.length;i++){\n      const el = document.createElement('div');\n      el.className = 'bar' + (showLabels ? '' : ' hidden-label');\n      el.setAttribute('role','listitem');\n      el.style.height = Math.max(6, (arr[i] / maxv) * 100) + '%';\n      el.style.backgroundColor = 'var(--bar)';\n      el.dataset.index = i;\n      const val = document.createElement('div');\n      val.className = 'val';\n      val.textContent = arr[i];\n      el.appendChild(val);\n      barsEl.appendChild(el);\n      bars.push(el);\n    }\n    updateHighlights();\n  }\n\n  function updateHighlights(){\n    for(let i=0;i<bars.length;i++){\n      const el = bars[i];\n      el.style.backgroundColor = 'var(--bar)';\n      el.style.transform = '';\n      // If sorted (index >= heapActiveSize)\n      if(heapActiveSize >= 0 && i > heapActiveSize){\n        el.style.backgroundColor = 'var(--sorted)';\n      } else if(heapActiveSize >= 0 && i <= heapActiveSize){\n        // heap area\n        el.style.backgroundColor = 'var(--heap)';\n      }\n    }\n    if(highlight.compare){\n      highlight.compare.forEach(idx => {\n        if(bars[idx]) bars[idx].style.backgroundColor = 'var(--compare)';\n      });\n    }\n    if(highlight.swap){\n      highlight.swap.forEach(idx => {\n        if(bars[idx]) bars[idx].style.backgroundColor = 'var(--swap)';\n        if(bars[idx]) bars[idx].style.transform = 'scale(1.02)';\n      });\n    }\n  }\n\n  function setPhase(text){\n    phaseEl.textContent = text;\n  }\n\n  function resetStats(){\n    stats = {comparisons:0, swaps:0, steps:0};\n    compEl.textContent = 0;\n    swapsEl.textContent = 0;\n    stepsEl.textContent = 0;\n  }\n\n  // Utility: comparator used by heap (true if a should be chosen over b)\n  function comparator(a,b){\n    if(order === 'asc'){ // want max-heap: choose larger\n      return a > b;\n    } else { // desc -> min-heap\n      return a < b;\n    }\n  }\n\n  // Heapify generator: yields action objects\n  function* heapifyGen(nLocal, i){\n    // nLocal: heap size\n    let root = i;\n    while(true){\n      let selected = root;\n      const left = 2*root + 1;\n      const right = 2*root + 2;\n      if(left < nLocal){\n        yield {type:'compare', i:left, j:selected, heapSize:nLocal};\n        if(comparator(arr[left], arr[selected])) selected = left;\n      }\n      if(right < nLocal){\n        yield {type:'compare', i:right, j:selected, heapSize:nLocal};\n        if(comparator(arr[right], arr[selected])) selected = right;\n      }\n      if(selected !== root){\n        yield {type:'swap', i:root, j:selected, heapSize:nLocal};\n        // perform swap\n        const tmp = arr[root]; arr[root] = arr[selected]; arr[selected] = tmp;\n        root = selected;\n        // continue loop to ensure subtree is a heap\n      } else {\n        // finished heapifying this subtree\n        return;\n      }\n    }\n  }\n\n  // Main heap sort generator\n  function* heapSortGen(){\n    const N = arr.length;\n    // Build heap\n    setPhase('building heap');\n    for(let start=Math.floor(N/2)-1; start>=0; start--){\n      yield {type:'heapifyStart', index:start, heapSize:N};\n      yield* heapifyGen(N, start);\n    }\n    yield {type:'heapBuilt', heapSize:N};\n    // Extraction phase\n    setPhase('extracting');\n    for(let end=N-1; end>0; end--){\n      // swap root with end\n      yield {type:'swap', i:0, j:end, heapSize:end};\n      const tmp = arr[0]; arr[0] = arr[end]; arr[end] = tmp;\n      // mark end as sorted\n      yield {type:'markedSorted', index:end, heapSize:end-1};\n      yield* heapifyGen(end, 0);\n    }\n    yield {type:'markedSorted', index:0, heapSize:0};\n    setPhase('done');\n    return;\n  }\n\n  // Visual action handler\n  function handleAction(action){\n    stats.steps += 1;\n    stepsEl.textContent = stats.steps;\n    highlight = {};\n    lastAction = action;\n    heapActiveSize = (typeof action.heapSize === 'number') ? (action.heapSize - 1) : heapActiveSize;\n    heapSizeEl.textContent = (heapActiveSize >= 0) ? (heapActiveSize + 1) : '-';\n\n    if(action.type === 'compare'){\n      stats.comparisons += 1;\n      compEl.textContent = stats.comparisons;\n      setPhase('comparing');\n      highlight.compare = [action.i, action.j];\n      updateHighlights();\n    } else if(action.type === 'swap'){\n      stats.swaps += 1;\n      swapsEl.textContent = stats.swaps;\n      setPhase('swap');\n      highlight.swap = [action.i, action.j];\n      // update visual heights & labels\n      const iEl = bars[action.i];\n      const jEl = bars[action.j];\n      if(iEl && jEl){\n        // swap heights + labels\n        const hi = iEl.style.height;\n        const hj = jEl.style.height;\n        iEl.style.height = hj;\n        jEl.style.height = hi;\n        const vi = iEl.querySelector('.val').textContent;\n        const vj = jEl.querySelector('.val').textContent;\n        iEl.querySelector('.val').textContent = vj;\n        jEl.querySelector('.val').textContent = vi;\n      }\n      updateHighlights();\n    } else if(action.type === 'heapifyStart'){\n      setPhase('heapify: start at ' + action.index);\n      highlight = {compare:[], swap:[]};\n      updateHighlights();\n    } else if(action.type === 'heapBuilt'){\n      setPhase('heap built');\n      heapActiveSize = action.heapSize - 1;\n      heapSizeEl.textContent = action.heapSize;\n      updateHighlights();\n    } else if(action.type === 'markedSorted'){\n      setPhase('marked sorted index ' + action.index);\n      heapActiveSize = action.heapSize - 1;\n      updateHighlights();\n      // color sorted element\n      if(bars[action.index]) bars[action.index].style.backgroundColor = 'var(--sorted)';\n    } else {\n      setPhase(action.type || 'idle');\n      updateHighlights();\n    }\n  }\n\n  // Step executor: advance one action\n  function step(){\n    if(!generator) generator = heapSortGen();\n    const res = generator.next();\n    if(res.done){\n      running = false;\n      playBtn.textContent = 'Play';\n      setPhase('finished');\n      return false;\n    } else {\n      handleAction(res.value);\n      return true;\n    }\n  }\n\n  function start(){\n    if(running) return;\n    running = true;\n    playBtn.textContent = 'Pause';\n    if(!generator) generator = heapSortGen();\n    loop();\n  }\n\n  function pause(){\n    running = false;\n    playBtn.textContent = 'Play';\n    if(timer){ clearTimeout(timer); timer=null; }\n  }\n\n  function togglePlay(){\n    if(running) pause();\n    else start();\n  }\n\n  function loop(){\n    if(!running) return;\n    const nextOk = step();\n    if(!nextOk){\n      running = false;\n      playBtn.textContent = 'Play';\n      return;\n    }\n    timer = setTimeout(loop, delay);\n  }\n\n  // Controls handlers\n  playBtn.addEventListener('click', ()=>{\n    togglePlay();\n  });\n  stepBtn.addEventListener('click', ()=>{\n    pause();\n    step();\n  });\n  resetBtn.addEventListener('click', ()=>{\n    pause();\n    arr = createArray(n,5,200);\n    resetStats();\n    generator = null;\n    heapActiveSize = -1;\n    setPhase('idle');\n    render();\n  });\n  shuffleBtn.addEventListener('click', ()=>{\n    pause();\n    // shuffle arr in place\n    for(let i=arr.length-1;i>0;i--){\n      const j = Math.floor(Math.random()*(i+1));\n      const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;\n    }\n    resetStats();\n    generator = null;\n    heapActiveSize = -1;\n    setPhase('idle');\n    render();\n  });\n  randomizeBtn.addEventListener('click', ()=>{\n    pause();\n    arr = createArray(n,5,200);\n    resetStats();\n    generator = null;\n    heapActiveSize = -1;\n    setPhase('idle');\n    render();\n  });\n\n  sizeInput.addEventListener('input', (e)=>{\n    n = parseInt(e.target.value,10);\n    sizeVal.textContent = n;\n    pause();\n    arr = createArray(n,5,200);\n    resetStats();\n    generator = null;\n    heapActiveSize = -1;\n    render();\n  });\n\n  speedInput.addEventListener('input', (e)=>{\n    delay = parseInt(e.target.value,10);\n    speedVal.textContent = delay + 'ms';\n  });\n\n  orderSel.addEventListener('change', (e)=>{\n    order = e.target.value;\n    pause();\n    // keep array but restart algorithm\n    resetStats();\n    generator = null;\n    heapActiveSize = -1;\n    setPhase('idle');\n    render();\n  });\n\n  // Initialize array and render\n  arr = createArray(n,5,200);\n  render();\n\n  // Keyboard: space to play/pause, right arrow step\n  window.addEventListener('keydown', (e)=>{\n    if(e.code === 'Space'){\n      e.preventDefault();\n      togglePlay();\n    } else if(e.code === 'ArrowRight'){\n      e.preventDefault();\n      pause();\n      step();\n    }\n  });\n\n  // Accessibility: announce phases (light)\n  const live = document.createElement('div');\n  live.setAttribute('aria-live','polite');\n  live.style.position='absolute';\n  live.style.left='-9999px';\n  document.body.appendChild(live);\n  const obsPhase = new MutationObserver(()=>{ live.textContent = phaseEl.textContent; });\n  obsPhase.observe(phaseEl, {childList:true});\n\n  // Helpful: auto-size bars widths based on length\n  const resizeObserver = new ResizeObserver(()=>{ /* no-op placeholder */ });\n  resizeObserver.observe(barsEl);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}