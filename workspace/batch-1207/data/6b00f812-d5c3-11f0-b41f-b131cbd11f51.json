{
  "id": "6b00f812-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:30:45.373Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            padding: 20px;\n            color: #333;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n            overflow: hidden;\n        }\n        \n        header {\n            background: #2c3e50;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }\n        \n        h1 {\n            font-size: 2.2rem;\n            margin-bottom: 10px;\n        }\n        \n        .subtitle {\n            font-size: 1.1rem;\n            opacity: 0.8;\n        }\n        \n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            padding: 20px;\n        }\n        \n        .controls {\n            flex: 1;\n            min-width: 300px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n            margin-right: 20px;\n        }\n        \n        .visualization {\n            flex: 2;\n            min-width: 400px;\n            position: relative;\n            height: 500px;\n            border: 2px solid #ddd;\n            border-radius: 10px;\n            background: #f0f2f5;\n            overflow: hidden;\n        }\n        \n        canvas {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n        }\n        \n        .form-group {\n            margin-bottom: 20px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 8px;\n            font-weight: 600;\n        }\n        \n        select, input, button {\n            width: 100%;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            font-size: 1rem;\n        }\n        \n        button {\n            background: #3498db;\n            color: white;\n            border: none;\n            cursor: pointer;\n            transition: background 0.3s;\n            font-weight: 600;\n        }\n        \n        button:hover {\n            background: #2980b9;\n        }\n        \n        .results {\n            margin-top: 20px;\n            padding: 15px;\n            background: #e8f4fc;\n            border-radius: 5px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background: #3498db;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);\n            transition: all 0.3s;\n            z-index: 10;\n        }\n        \n        .node.start {\n            background: #2ecc71;\n        }\n        \n        .node.end {\n            background: #e74c3c;\n        }\n        \n        .node.visited {\n            background: #9b59b6;\n        }\n        \n        .node.path {\n            background: #f1c40f;\n        }\n        \n        .edge {\n            position: absolute;\n            height: 4px;\n            background: #7f8c8d;\n            transform-origin: 0 0;\n            z-index: 5;\n        }\n        \n        .edge.weight {\n            position: absolute;\n            background: white;\n            padding: 2px 5px;\n            border-radius: 3px;\n            font-size: 0.8rem;\n            z-index: 6;\n        }\n        \n        .explanation {\n            margin-top: 30px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 10px;\n        }\n        \n        .steps {\n            margin-top: 15px;\n        }\n        \n        .step {\n            margin-bottom: 10px;\n            padding: 10px;\n            background: white;\n            border-radius: 5px;\n            border-left: 3px solid #3498db;\n        }\n        \n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n            \n            .controls {\n                margin-right: 0;\n                margin-bottom: 20px;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Dijkstra's Algorithm</h1>\n            <p class=\"subtitle\">Find the shortest path between nodes in a weighted graph</p>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"controls\">\n                <div class=\"form-group\">\n                    <label for=\"graphType\">Graph Type</label>\n                    <select id=\"graphType\">\n                        <option value=\"predefined\">Predefined Graph</option>\n                        <option value=\"custom\">Custom Graph</option>\n                    </select>\n                </div>\n                \n                <div class=\"form-group\">\n                    <label for=\"startNode\">Start Node</label>\n                    <select id=\"startNode\">\n                        <option value=\"A\">A</option>\n                        <option value=\"B\">B</option>\n                        <option value=\"C\">C</option>\n                        <option value=\"D\">D</option>\n                        <option value=\"E\">E</option>\n                        <option value=\"F\">F</option>\n                    </select>\n                </div>\n                \n                <div class=\"form-group\">\n                    <label for=\"endNode\">End Node</label>\n                    <select id=\"endNode\">\n                        <option value=\"A\">A</option>\n                        <option value=\"B\">B</option>\n                        <option value=\"C\">C</option>\n                        <option value=\"D\">D</option>\n                        <option value=\"E\">E</option>\n                        <option value=\"F\">F</option>\n                    </select>\n                </div>\n                \n                <button id=\"runAlgorithm\">Run Dijkstra's Algorithm</button>\n                <button id=\"resetGraph\" style=\"background: #e74c3c; margin-top: 10px;\">Reset Graph</button>\n                \n                <div class=\"results\">\n                    <h3>Shortest Path Result</h3>\n                    <p id=\"pathResult\">Click \"Run Algorithm\" to find the shortest path</p>\n                    <p id=\"distanceResult\">Total distance: -</p>\n                </div>\n            </div>\n            \n            <div class=\"visualization\" id=\"graphContainer\">\n                <canvas id=\"graphCanvas\"></canvas>\n                <!-- Nodes will be dynamically added here -->\n            </div>\n        </div>\n        \n        <div class=\"explanation\">\n            <h2>How Dijkstra's Algorithm Works</h2>\n            <p>Dijkstra's algorithm is a greedy algorithm that finds the shortest path between nodes in a graph. It works by:</p>\n            \n            <div class=\"steps\">\n                <div class=\"step\">\n                    <strong>Step 1:</strong> Assign a tentative distance value to every node: zero for the starting node and infinity for all others.\n                </div>\n                <div class=\"step\">\n                    <strong>Step 2:</strong> Set the starting node as current. Mark all other nodes unvisited.\n                </div>\n                <div class=\"step\">\n                    <strong>Step 3:</strong> For the current node, consider all of its unvisited neighbors and calculate their tentative distances.\n                </div>\n                <div class=\"step\">\n                    <strong>Step 4:</strong> When we're done considering all neighbors of the current node, mark it as visited.\n                </div>\n                <div class=\"step\">\n                    <strong>Step 5:</strong> Select the unvisited node with the smallest tentative distance and set it as the new current node.\n                </div>\n                <div class=\"step\">\n                    <strong>Step 6:</strong> Repeat steps 3-5 until the destination node has been visited or the smallest tentative distance is infinity.\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure definition\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = {};\n            }\n            \n            addNode(node) {\n                this.nodes.push(node);\n                this.edges[node] = [];\n            }\n            \n            addEdge(node1, node2, weight) {\n                this.edges[node1].push({ node: node2, weight: weight });\n                this.edges[node2].push({ node: node1, weight: weight });\n            }\n            \n            dijkstra(startNode, endNode) {\n                // Initialize distances and previous nodes\n                let distances = {};\n                let previous = {};\n                let visited = [];\n                let unvisited = [...this.nodes];\n                \n                // Set initial distances\n                this.nodes.forEach(node => {\n                    distances[node] = node === startNode ? 0 : Infinity;\n                    previous[node] = null;\n                });\n                \n                // Dijkstra's algorithm\n                while (unvisited.length > 0) {\n                    // Find unvisited node with smallest distance\n                    let current = null;\n                    for (let node of unvisited) {\n                        if (current === null || distances[node] < distances[current]) {\n                            current = node;\n                        }\n                    }\n                    \n                    // If smallest distance is Infinity, we're done\n                    if (distances[current] === Infinity) break;\n                    \n                    // Mark current node as visited\n                    visited.push(current);\n                    unvisited = unvisited.filter(node => node !== current);\n                    \n                    // Update distances to neighbors\n                    for (let neighbor of this.edges[current]) {\n                        let newDistance = distances[current] + neighbor.weight;\n                        if (newDistance < distances[neighbor.node]) {\n                            distances[neighbor.node] = newDistance;\n                            previous[neighbor.node] = current;\n                        }\n                    }\n                    \n                    // If we reached the end node, we can stop\n                    if (current === endNode) break;\n                }\n                \n                // Reconstruct the path\n                let path = [];\n                let current = endNode;\n                while (current !== null) {\n                    path.unshift(current);\n                    current = previous[current];\n                }\n                \n                return {\n                    path: path,\n                    distance: distances[endNode]\n                };\n            }\n        }\n        \n        // Visualization setup\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Set canvas dimensions\n        function resizeCanvas() {\n            canvas.width = canvas.offsetWidth;\n            canvas.height = canvas.offsetHeight;\n        }\n        \n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n        \n        // Graph setup\n        const graph = new Graph();\n        \n        // Add nodes\n        ['A', 'B', 'C', 'D', 'E', 'F'].forEach(node => {\n            graph.addNode(node);\n        });\n        \n        // Add edges with weights\n        graph.addEdge('A', 'B', 4);\n        graph.addEdge('A', 'C', 2);\n        graph.addEdge('B', 'C', 1);\n        graph.addEdge('B', 'D', 5);\n        graph.addEdge('C', 'D', 8);\n        graph.addEdge('C', 'E', 10);\n        graph.addEdge('D', 'E', 2);\n        graph.addEdge('D', 'F', 6);\n        graph.addEdge('E', 'F', 3);\n        \n        // Node positions for visualization\n        const nodePositions = {\n            'A': { x: 100, y: 250 },\n            'B': { x: 250, y: 150 },\n            'C': { x: 250, y: 350 },\n            'D': { x: 400, y: 150 },\n            'E': { x: 400, y: 350 },\n            'F': { x: 550, y: 250 }\n        };\n        \n        // Draw the graph\n        function drawGraph() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            for (let node in graph.edges) {\n                for (let edge of graph.edges[node]) {\n                    const startPos = nodePositions[node];\n                    const endPos = nodePositions[edge.node];\n                    \n                    // Draw line\n                    ctx.beginPath();\n                    ctx.moveTo(startPos.x, startPos.y);\n                    ctx.lineTo(endPos.x, endPos.y);\n                    ctx.strokeStyle = '#7f8c8d';\n                    ctx.lineWidth = 3;\n                    ctx.stroke();\n                    \n                    // Draw weight\n                    const midX = (startPos.x + endPos.x) / 2;\n                    const midY = (startPos.y + endPos.y) / 2;\n                    \n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                    \n                    ctx.fillStyle = 'black';\n                    ctx.font = '12px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(edge.weight, midX, midY);\n                }\n            }\n            \n            // Draw nodes\n            for (let node in nodePositions) {\n                const pos = nodePositions[node];\n                \n                ctx.beginPath();\n                ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);\n                ctx.fillStyle = '#3498db';\n                ctx.fill();\n                ctx.strokeStyle = '#2980b9';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(node, pos.x, pos.y);\n            }\n        }\n        \n        // Highlight path\n        function highlightPath(path) {\n            // Reset all nodes to default color\n            drawGraph();\n            \n            // Highlight path edges\n            for (let i = 0; i < path.length - 1; i++) {\n                const startNode = path[i];\n                const endNode = path[i+1];\n                \n                const startPos = nodePositions[startNode];\n                const endPos = nodePositions[endNode];\n                \n                // Draw highlighted edge\n                ctx.beginPath();\n                ctx.moveTo(startPos.x, startPos.y);\n                ctx.lineTo(endPos.x, endPos.y);\n                ctx.strokeStyle = '#f1c40f';\n                ctx.lineWidth = 5;\n                ctx.stroke();\n                \n                // Draw highlighted nodes\n                [startNode, endNode].forEach(node => {\n                    const pos = nodePositions[node];\n                    \n                    ctx.beginPath();\n                    ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);\n                    ctx.fillStyle = '#f1c40f';\n                    ctx.fill();\n                    ctx.strokeStyle = '#f39c12';\n                    ctx.lineWidth = 2;\n                    ctx.stroke();\n                    \n                    ctx.fillStyle = 'white';\n                    ctx.font = 'bold 16px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(node, pos.x, pos.y);\n                });\n            }\n        }\n        \n        // Event listeners\n        document.getElementById('runAlgorithm').addEventListener('click', function() {\n            const startNode = document.getElementById('startNode').value;\n            const endNode = document.getElementById('endNode').value;\n            \n            if (startNode === endNode) {\n                alert('Start and end nodes must be different');\n                return;\n            }\n            \n            const result = graph.dijkstra(startNode, endNode);\n            \n            if (result.distance === Infinity) {\n                document.getElementById('pathResult').textContent = 'No path exists between the selected nodes';\n                document.getElementById('distanceResult').textContent = 'Total distance: Infinity';\n            } else {\n                document.getElementById('pathResult').textContent = `Path: ${result.path.join(' → ')}`;\n                document.getElementById('distanceResult').textContent = `Total distance: ${result.distance}`;\n                highlightPath(result.path);\n            }\n        });\n        \n        document.getElementById('resetGraph').addEventListener('click', function() {\n            document.getElementById('pathResult').textContent = 'Click \"Run Algorithm\" to find the shortest path';\n            document.getElementById('distanceResult').textContent = 'Total distance: -';\n            drawGraph();\n        });\n        \n        // Initialize the graph visualization\n        drawGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}