{
  "id": "6b00f810-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:31:30.114Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Depth-First Search (DFS) Visualization</title>\n    <style>\n        body {\n            font-family: 'Arial', sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            margin-bottom: 10px;\n        }\n        \n        .description {\n            margin-bottom: 20px;\n            text-align: center;\n            max-width: 800px;\n            line-height: 1.5;\n        }\n        \n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n            justify-content: center;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 8px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #95a5a6;\n            cursor: not-allowed;\n        }\n        \n        .container {\n            display: flex;\n            width: 100%;\n            max-width: 1200px;\n            gap: 20px;\n            justify-content: center;\n            flex-wrap: wrap;\n        }\n        \n        .graph-container {\n            flex: 1;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            padding: 15px;\n        }\n        \n        .visualization-container {\n            flex: 1;\n            min-width: 300px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            padding: 15px;\n            overflow: auto;\n        }\n        \n        #graph-canvas {\n            width: 100%;\n            height: 400px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #3498db;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            transition: background-color 0.3s;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n        }\n        \n        .node.visited {\n            background-color: #e74c3c;\n        }\n        \n        .node.current {\n            background-color: #f39c12;\n        }\n        \n        .node.start {\n            background-color: #2ecc71;\n        }\n        \n        .edge {\n            position: absolute;\n            height: 3px;\n            background-color: #7f8c8d;\n            transform-origin: 0 0;\n            z-index: -1;\n        }\n        \n        .log {\n            height: 400px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            padding: 10px;\n            font-family: monospace;\n            background-color: #f8f9fa;\n            border-radius: 4px;\n        }\n        \n        .log-entry {\n            margin-bottom: 5px;\n            padding: 5px;\n            border-radius: 3px;\n        }\n        \n        .log-entry.visited {\n            background-color: #ffebee;\n            color: #c62828;\n        }\n        \n        .log-entry.current {\n            background-color: #fff3e0;\n            color: #ef6c00;\n        }\n        \n        .log-entry.start {\n            background-color: #e8f5e9;\n            color: #2e7d32;\n        }\n        \n        table {\n            width: 100%;\n            border-collapse: collapse;\n            margin-top: 15px;\n        }\n        \n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: left;\n        }\n        \n        th {\n            background-color: #f2f2f2;\n        }\n        \n        .stack-visualization {\n            margin-top: 15px;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            background-color: #f8f9fa;\n            min-height: 100px;\n        }\n        \n        .stack-item {\n            padding: 5px 10px;\n            margin: 2px 0;\n            background-color: #e3f2fd;\n            border-radius: 3px;\n            display: inline-block;\n            margin-right: 5px;\n        }\n        \n        .stack-item.current {\n            background-color: #fff3e0;\n            font-weight: bold;\n        }\n        \n        .algorithm-explanation {\n            margin-top: 20px;\n            max-width: 800px;\n            line-height: 1.6;\n        }\n        \n        code {\n            background-color: #f1f1f1;\n            padding: 2px 4px;\n            border-radius: 3px;\n            font-family: monospace;\n        }\n    </style>\n</head>\n<body>\n    <h1>Depth-First Search (DFS) Visualization</h1>\n    \n    <div class=\"description\">\n        <p>Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. \n        The algorithm starts at the root node and explores as far as possible along each branch before backtracking.</p>\n    </div>\n    \n    <div class=\"controls\">\n        <button id=\"start-btn\">Start DFS</button>\n        <button id=\"pause-btn\" disabled>Pause</button>\n        <button id=\"reset-btn\">Reset</button>\n        <button id=\"step-btn\" disabled>Step Forward</button>\n        <select id=\"speed-select\">\n            <option value=\"1000\">Slow</option>\n            <option value=\"500\" selected>Medium</option>\n            <option value=\"200\">Fast</option>\n        </select>\n    </div>\n    \n    <div class=\"container\">\n        <div class=\"graph-container\">\n            <h2>Graph Visualization</h2>\n            <div id=\"graph-canvas\"></div>\n        </div>\n        \n        <div class=\"visualization-container\">\n            <h2>DFS Process</h2>\n            <div class=\"log\" id=\"log\"></div>\n            \n            <h3>Stack Visualization</h3>\n            <div class=\"stack-visualization\" id=\"stack\"></div>\n            \n            <h3>Visited Nodes</h3>\n            <table id=\"visited-table\">\n                <thead>\n                    <tr>\n                        <th>Node</th>\n                        <th>Visited Order</th>\n                    </tr>\n                </thead>\n                <tbody id=\"visited-body\">\n                </tbody>\n            </table>\n        </div>\n    </div>\n    \n    <div class=\"algorithm-explanation\">\n        <h2>DFS Algorithm Explanation</h2>\n        <p>The Depth-First Search algorithm follows these steps:</p>\n        <ol>\n            <li>Start by putting any one of the graph's vertices on top of a stack.</li>\n            <li>Take the top item of the stack and add it to the visited list.</li>\n            <li>Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.</li>\n            <li>Keep repeating steps 2 and 3 until the stack is empty.</li>\n        </ol>\n        \n        <p>DFS can be implemented recursively or iteratively. This visualization demonstrates the iterative approach using a stack.</p>\n        \n        <h3>Pseudocode</h3>\n        <pre><code>\nDFS(G, start):\n  stack = new Stack()\n  visited = new Set()\n  \n  stack.push(start)\n  \n  while stack is not empty:\n    current = stack.pop()\n    \n    if current is not in visited:\n      mark current as visited\n      \n      for each neighbor of current:\n        if neighbor is not visited:\n          stack.push(neighbor)\n        </code></pre>\n        \n        <h3>Time Complexity</h3>\n        <p>The time complexity of DFS is O(V + E) where V is the number of vertices and E is the number of edges in the graph.</p>\n    </div>\n\n    <script>\n        // Graph representation\n        const graph = {\n            'A': ['B', 'C'],\n            'B': ['A', 'D', 'E'],\n            'C': ['A', 'F'],\n            'D': ['B'],\n            'E': ['B', 'F'],\n            'F': ['C', 'E']\n        };\n\n        // Node positions for visualization\n        const nodePositions = {\n            'A': { x: 200, y: 100 },\n            'B': { x: 100, y: 200 },\n            'C': { x: 300, y: 200 },\n            'D': { x: 50, y: 300 },\n            'E': { x: 150, y: 300 },\n            'F': { x: 250, y: 300 }\n        };\n\n        // DFS Algorithm State\n        let visited = new Set();\n        let stack = [];\n        let currentNode = null;\n        let isRunning = false;\n        let animationSpeed = 500;\n        let stepTimeout = null;\n        let visitOrder = 0;\n        let visitedOrderMap = {};\n\n        // DOM Elements\n        const graphCanvas = document.getElementById('graph-canvas');\n        const logElement = document.getElementById('log');\n        const stackElement = document.getElementById('stack');\n        const visitedBody = document.getElementById('visited-body');\n        const startBtn = document.getElementById('start-btn');\n        const pauseBtn = document.getElementById('pause-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const stepBtn = document.getElementById('step-btn');\n        const speedSelect = document.getElementById('speed-select');\n\n        // Initialize the visualization\n        function init() {\n            renderGraph();\n            updateVisitedTable();\n            updateControls();\n        }\n\n        // Render the graph on the canvas\n        function renderGraph() {\n            graphCanvas.innerHTML = '';\n            \n            // Draw edges first (so they appear behind nodes)\n            for (const node in graph) {\n                if (nodePositions[node]) {\n                    const fromX = nodePositions[node].x;\n                    const fromY = nodePositions[node].y;\n                    \n                    for (const neighbor of graph[node]) {\n                        if (nodePositions[neighbor] && node < neighbor) { // Draw each edge only once\n                            const toX = nodePositions[neighbor].x;\n                            const toY = nodePositions[neighbor].y;\n                            \n                            const edge = document.createElement('div');\n                            edge.className = 'edge';\n                            \n                            // Calculate distance and angle\n                            const dx = toX - fromX;\n                            const dy = toY - fromY;\n                            const length = Math.sqrt(dx * dx + dy * dy);\n                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                            \n                            // Position and style the edge\n                            edge.style.width = `${length}px`;\n                            edge.style.left = `${fromX}px`;\n                            edge.style.top = `${fromY}px`;\n                            edge.style.transform = `rotate(${angle}deg)`;\n                            \n                            graphCanvas.appendChild(edge);\n                        }\n                    }\n                }\n            }\n            \n            // Draw nodes\n            for (const node in nodePositions) {\n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.id = `node-${node}`;\n                nodeElement.textContent = node;\n                nodeElement.style.left = `${nodePositions[node].x - 20}px`;\n                nodeElement.style.top = `${nodePositions[node].y - 20}px`;\n                \n                // Set node color based on state\n                if (node === currentNode) {\n                    nodeElement.classList.add('current');\n                } else if (visited.has(node)) {\n                    nodeElement.classList.add('visited');\n                }\n                \n                graphCanvas.appendChild(nodeElement);\n            }\n        }\n\n        // Update the visited nodes table\n        function updateVisitedTable() {\n            visitedBody.innerHTML = '';\n            \n            // Sort nodes by visit order\n            const sortedNodes = Object.keys(visitedOrderMap).sort((a, b) => \n                visitedOrderMap[a] - visitedOrderMap[b]\n            );\n            \n            for (const node of sortedNodes) {\n                const row = document.createElement('tr');\n                \n                const nodeCell = document.createElement('td');\n                nodeCell.textContent = node;\n                row.appendChild(nodeCell);\n                \n                const orderCell = document.createElement('td');\n                orderCell.textContent = visitedOrderMap[node];\n                row.appendChild(orderCell);\n                \n                visitedBody.appendChild(row);\n            }\n        }\n\n        // Update the stack visualization\n        function updateStackVisualization() {\n            stackElement.innerHTML = '';\n            \n            // Display the stack from top to bottom\n            for (let i = stack.length - 1; i >= 0; i--) {\n                const stackItem = document.createElement('div');\n                stackItem.className = 'stack-item';\n                stackItem.textContent = stack[i];\n                \n                if (i === stack.length - 1) {\n                    stackItem.classList.add('current');\n                }\n                \n                stackElement.appendChild(stackItem);\n            }\n        }\n\n        // Add a log entry\n        function addLogEntry(message, type = '') {\n            const logEntry = document.createElement('div');\n            logEntry.className = `log-entry ${type}`;\n            logEntry.textContent = message;\n            logElement.appendChild(logEntry);\n            logElement.scrollTop = logElement.scrollHeight;\n        }\n\n        // DFS Algorithm Step\n        function dfsStep() {\n            if (stack.length === 0) {\n                // DFS complete\n                addLogEntry('DFS traversal complete!', 'start');\n                stopDFS();\n                return;\n            }\n            \n            // Pop the top node from the stack\n            currentNode = stack.pop();\n            addLogEntry(`Popped ${currentNode} from stack`, 'current');\n            \n            // If we haven't visited this node yet\n            if (!visited.has(currentNode)) {\n                // Mark as visited\n                visited.add(currentNode);\n                visitedOrderMap[currentNode] = ++visitOrder;\n                addLogEntry(`Visited node ${currentNode} (order: ${visitOrder})`, 'visited');\n                \n                // Add unvisited neighbors to the stack\n                const neighbors = graph[currentNode] || [];\n                const unvisitedNeighbors = neighbors.filter(neighbor => !visited.has(neighbor));\n                \n                if (unvisitedNeighbors.length > 0) {\n                    addLogEntry(`Adding unvisited neighbors of ${currentNode} to stack: ${unvisitedNeighbors.join(', ')}`);\n                    stack.push(...unvisitedNeighbors.reverse()); // Reverse to maintain DFS order\n                } else {\n                    addLogEntry(`No unvisited neighbors for ${currentNode}`);\n                }\n            } else {\n                addLogEntry(`Node ${currentNode} already visited, skipping`);\n            }\n            \n            // Update visualizations\n            renderGraph();\n            updateVisitedTable();\n            updateStackVisualization();\n            \n            // Continue if running\n            if (isRunning) {\n                stepTimeout = setTimeout(dfsStep, animationSpeed);\n            }\n        }\n\n        // Start DFS\n        function startDFS() {\n            if (!isRunning) {\n                isRunning = true;\n                \n                // Initialize DFS if not already started\n                if (stack.length === 0 && visited.size === 0) {\n                    stack.push('A'); // Start from node A\n                    addLogEntry('Starting DFS from node A', 'start');\n                }\n                \n                updateControls();\n                dfsStep();\n            }\n        }\n\n        // Pause DFS\n        function pauseDFS() {\n            isRunning = false;\n            if (stepTimeout) {\n                clearTimeout(stepTimeout);\n                stepTimeout = null;\n            }\n            updateControls();\n        }\n\n        // Stop DFS\n        function stopDFS() {\n            isRunning = false;\n            if (stepTimeout) {\n                clearTimeout(stepTimeout);\n                stepTimeout = null;\n            }\n            updateControls();\n        }\n\n        // Reset DFS\n        function resetDFS() {\n            stopDFS();\n            visited = new Set();\n            stack = [];\n            currentNode = null;\n            visitOrder = 0;\n            visitedOrderMap = {};\n            logElement.innerHTML = '';\n            updateVisitedTable();\n            updateStackVisualization();\n            renderGraph();\n            updateControls();\n        }\n\n        // Step forward one step\n        function stepForward() {\n            if (!isRunning) {\n                // Initialize DFS if not already started\n                if (stack.length === 0 && visited.size === 0) {\n                    stack.push('A'); // Start from node A\n                    addLogEntry('Starting DFS from node A', 'start');\n                    updateVisitedTable();\n                    updateStackVisualization();\n                    renderGraph();\n                } else {\n                    dfsStep();\n                }\n            }\n        }\n\n        // Update control buttons state\n        function updateControls() {\n            startBtn.disabled = isRunning;\n            pauseBtn.disabled = !isRunning;\n            stepBtn.disabled = isRunning;\n        }\n\n        // Event Listeners\n        startBtn.addEventListener('click', startDFS);\n        pauseBtn.addEventListener('click', pauseDFS);\n        resetBtn.addEventListener('click', resetDFS);\n        stepBtn.addEventListener('click', stepForward);\n        \n        speedSelect.addEventListener('change', function() {\n            animationSpeed = parseInt(this.value);\n            if (isRunning) {\n                pauseDFS();\n                startDFS();\n            }\n        });\n\n        // Initialize the visualization\n        init();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}