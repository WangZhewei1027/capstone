{
  "id": "98e27df1-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:04.363Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Topological Sort — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{--bg:#0f1724;--panel:#071027;--muted:#9aa6bf;--accent:#60a5fa;--good:#10b981;--bad:#f87171}\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{display:flex;gap:12px;padding:12px;background:linear-gradient(180deg,#071428 0%,#02111b 100%);color:#e6eef8;}\n    .container{display:flex;flex:1;gap:12px;align-items:stretch}\n    .panel{width:360px;background:linear-gradient(180deg,var(--panel),#031627);border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,0.7);overflow:auto}\n    h1{font-size:18px;margin:6px 0 12px}\n    label{font-size:12px;color:var(--muted);display:block;margin-top:8px}\n    button, select, input[type=number], input[type=range] {background:#04324a;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:8px;margin-top:6px}\n    button{cursor:pointer}\n    .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}\n    .small{font-size:12px;padding:6px 8px}\n    .toggle{display:inline-flex;align-items:center;gap:8px}\n    #svgWrap{flex:1;border-radius:12px;background:linear-gradient(180deg,#062033,#041622);position:relative;overflow:hidden;display:flex;flex-direction:column}\n    #canvas{flex:1;width:100%;height:100%}\n    .info{font-size:13px;color:var(--muted);margin-top:8px}\n    .list{background:#021a28;padding:8px;border-radius:8px;margin-top:8px;max-height:160px;overflow:auto;font-family:monospace;font-size:13px}\n    .statusline{display:flex;gap:6px;flex-wrap:wrap;align-items:center;margin-top:8px}\n    .chip{background:#062b3f;padding:6px 8px;border-radius:999px;font-size:13px}\n    .nodeLabel{pointer-events:none;font-weight:600}\n    #controls-top{display:flex;gap:6px;align-items:center;flex-wrap:wrap}\n    .muted{color:var(--muted);font-size:13px}\n    .stepper{display:flex;gap:6px}\n    .algo-code{background:#021220;padding:8px;border-radius:8px;margin-top:8px;font-family:monospace;font-size:13px;white-space:pre-wrap;color:#cfe8ff}\n    .highlight{background:rgba(96,165,250,0.12);border-left:3px solid var(--accent);padding-left:6px}\n    .footer{font-size:12px;color:var(--muted);margin-top:12px}\n    .danger{color:var(--bad)}\n    .good{color:var(--good)}\n    svg{width:100%;height:100%}\n    /* node styles handled inline */\n    .labelSmall{font-size:11px;fill:#bfe0ff}\n    .inDegree{font-family:monospace;font-size:12px;fill:#ffd580}\n    .edgePath{stroke:#6fb8ff;stroke-width:2;fill:none;opacity:0.75}\n    .edgeHover{stroke:#aee3ff;stroke-width:3;opacity:1}\n    .markerArrow{fill:#6fb8ff}\n    .nodeCircle{stroke:#16384a;stroke-width:2;cursor:pointer}\n    .nodeText{font-size:14px;fill:#e6f7ff;text-anchor:middle;dominant-baseline:middle;font-weight:700;pointer-events:none}\n    .removed{opacity:0.25}\n    .selected{stroke:#ffd166;stroke-width:3}\n    .cycleEdge{stroke:#ff7b7b;stroke-width:3}\n    .queueBox{background:#012; border-radius:6px; padding:8px; display:flex; gap:6px; align-items:center}\n    .queueItem{background:#072f3d;padding:6px 8px;border-radius:6px;font-weight:700}\n    .orderItem{background:linear-gradient(90deg,#063a2e,#093a4d);padding:6px 8px;border-radius:6px}\n    .smallMuted{font-size:12px;color:var(--muted)}\n    .controls-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"panel\">\n      <h1>Topological Sort — Interactive Demo</h1>\n      <div id=\"controls-top\">\n        <button id=\"btnAddNode\" class=\"small\">Add Node</button>\n        <button id=\"btnAddEdge\" class=\"small\">Add Edge</button>\n        <button id=\"btnDelete\" class=\"small\">Delete Mode</button>\n        <button id=\"btnClear\" class=\"small\">Clear Graph</button>\n      </div>\n\n      <label>Random DAG</label>\n      <div style=\"display:flex;gap:8px;align-items:center\">\n        <input id=\"randN\" type=\"number\" value=\"6\" min=\"1\" style=\"width:72px\"/>\n        <input id=\"randP\" type=\"number\" value=\"30\" min=\"0\" max=\"100\" style=\"width:72px\"/> <span class=\"muted\">edge % (i->j, i&lt;j)</span>\n        <button id=\"btnRand\" class=\"small\">Generate</button>\n      </div>\n\n      <label>Kahn's Algorithm (step-by-step)</label>\n      <div class=\"stepper\">\n        <button id=\"kahnReset\" class=\"small\">Reset</button>\n        <button id=\"kahnStep\" class=\"small\">Step</button>\n        <button id=\"kahnPlay\" class=\"small\">Play</button>\n        <button id=\"kahnRun\" class=\"small\">Run to End</button>\n        <label class=\"smallMuted\">Speed</label><input id=\"playSpeed\" type=\"range\" min=\"100\" max=\"2000\" value=\"800\" />\n      </div>\n\n      <div class=\"controls-row\">\n        <button id=\"btnKahnFull\" class=\"small\">Full Kahn (instant)</button>\n        <button id=\"btnDFS\" class=\"small\">DFS Topo</button>\n        <button id=\"btnCompare\" class=\"small\">Compare</button>\n      </div>\n\n      <div class=\"statusline\">\n        <div class=\"chip\">Nodes: <span id=\"nodeCount\">0</span></div>\n        <div class=\"chip\">Edges: <span id=\"edgeCount\">0</span></div>\n        <div class=\"chip\">Status: <span id=\"algoStatus\">idle</span></div>\n      </div>\n\n      <div class=\"info\">\n        Click \"Add Node\" then click canvas to place nodes. Use \"Add Edge\" then click source then target to make directed edge. Drag nodes to reposition. \"Random DAG\" creates an acyclic graph. Use Kahn stepper to watch topology emerge.\n      </div>\n\n      <label>Current Queue (Kahn)</label>\n      <div id=\"queueView\" class=\"list\" style=\"min-height:40px\"></div>\n\n      <label>Topological Order (so far)</label>\n      <div id=\"orderView\" class=\"list\" style=\"min-height:40px\"></div>\n\n      <label>Adjacency / In-degrees</label>\n      <div id=\"adjView\" class=\"list\"></div>\n\n      <label>Algorithm (Kahn)</label>\n      <div id=\"algoCode\" class=\"algo-code\">\nkahn(G):\n  L = empty list\n  S = set of all nodes with no incoming edges\n  while S is non-empty:\n    remove a node n from S\n    add n to L\n    for each node m with an edge e from n to m:\n      remove edge e from the graph\n      if m has no other incoming edges:\n        insert m into S\n  if graph has edges:\n    graph has at least one cycle (no topo ordering)\n  else:\n    return L\n      </div>\n\n      <div class=\"footer\">Demonstration by interactive SVG. Try creating a cycle to see detection.</div>\n    </div>\n\n    <div id=\"svgWrap\">\n      <svg id=\"canvas\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n            <path d=\"M0,0 L10,5 L0,10 z\" class=\"markerArrow\"/>\n          </marker>\n        </defs>\n        <!-- edges and nodes drawn dynamically -->\n      </svg>\n    </div>\n  </div>\n\n  <script>\n    // Interactive Topological Sort demo\n    (function(){\n      // DOM\n      const svg = document.getElementById('canvas');\n      const btnAddNode = document.getElementById('btnAddNode');\n      const btnAddEdge = document.getElementById('btnAddEdge');\n      const btnDelete = document.getElementById('btnDelete');\n      const btnClear = document.getElementById('btnClear');\n      const btnRand = document.getElementById('btnRand');\n      const randN = document.getElementById('randN');\n      const randP = document.getElementById('randP');\n\n      const nodeCountEl = document.getElementById('nodeCount');\n      const edgeCountEl = document.getElementById('edgeCount');\n      const algoStatus = document.getElementById('algoStatus');\n\n      const queueView = document.getElementById('queueView');\n      const orderView = document.getElementById('orderView');\n      const adjView = document.getElementById('adjView');\n\n      const kahnReset = document.getElementById('kahnReset');\n      const kahnStep = document.getElementById('kahnStep');\n      const kahnPlay = document.getElementById('kahnPlay');\n      const kahnRun = document.getElementById('kahnRun');\n      const playSpeed = document.getElementById('playSpeed');\n\n      const btnKahnFull = document.getElementById('btnKahnFull');\n      const btnDFS = document.getElementById('btnDFS');\n      const btnCompare = document.getElementById('btnCompare');\n\n      // state\n      let nodes = []; // {id,label,x,y}\n      let edges = []; // {id,from,to}\n      let nextNodeId = 1;\n      let nextEdgeId = 1;\n\n      let mode = null; // 'addNode', 'addEdge', 'delete'\n      let pendingEdgeFrom = null;\n\n      // dragging\n      let drag = {node:null,offsetX:0,offsetY:0};\n\n      // Kahn algorithm state\n      let kahnState = null; // {inDeg:Map,idToOut:Map,queue:Array,order:Array,removed:Set}\n      let playInterval = null;\n\n      // helpers\n      function $(id){return document.getElementById(id);}\n      function setMode(m){\n        mode = m;\n        btnAddNode.style.background = (m==='addNode' ? '#074056' : '#04324a');\n        btnAddEdge.style.background = (m==='addEdge' ? '#074056' : '#04324a');\n        btnDelete.style.background = (m==='delete' ? '#701b1b' : '#04324a');\n        pendingEdgeFrom = null;\n        render();\n      }\n\n      function clearGraph(){\n        nodes=[];edges=[];nextNodeId=1;nextEdgeId=1;resetKahn();\n        render();\n      }\n\n      // create random acyclic graph by only allowing edges i->j for i<j\n      function randomDAG(n,percent){\n        nodes=[];edges=[];nextNodeId=1;nextEdgeId=1;\n        const w = svg.viewBox.baseVal.width || svg.clientWidth;\n        const h = svg.viewBox.baseVal.height || svg.clientHeight;\n        for(let i=0;i<n;i++){\n          nodes.push({id:nextNodeId,label:String.fromCharCode(65+i%26),x:120+(w-240)*(i/(n+1)),y:80+ (h-160)*(0.35 + 0.5*Math.sin(i*1.2)),});\n          nextNodeId++;\n        }\n        for(let i=0;i<n;i++){\n          for(let j=i+1;j<n;j++){\n            if(Math.random()*100 < percent){\n              edges.push({id:nextEdgeId++,from:nodes[i].id,to:nodes[j].id});\n            }\n          }\n        }\n        resetKahn();\n        render();\n      }\n\n      // compute adjacency and in-degree\n      function computeAdjAndInDeg(){\n        let adj = new Map(); // id -> [to,...]\n        let inDeg = new Map();\n        for(const node of nodes){\n          adj.set(node.id,[]);\n          inDeg.set(node.id,0);\n        }\n        for(const e of edges){\n          if(!adj.has(e.from) || !adj.has(e.to)) continue;\n          adj.get(e.from).push(e.to);\n          inDeg.set(e.to, inDeg.get(e.to)+1);\n        }\n        return {adj,inDeg};\n      }\n\n      function updateInfo(){\n        nodeCountEl.textContent = nodes.length;\n        edgeCountEl.textContent = edges.length;\n        // adjacency view\n        const {adj,inDeg} = computeAdjAndInDeg();\n        let lines = [];\n        for(const n of nodes){\n          lines.push(n.label + ' ('+n.id+') | in=' + (inDeg.get(n.id)||0) + ' -> [' + (adj.get(n.id)||[]).map(id=>labelOf(id)).join(',') + ']');\n        }\n        adjView.textContent = lines.join('\\n');\n      }\n\n      function labelOf(id){\n        const n = nodes.find(x=>x.id===id);\n        return n ? n.label : ('#'+id);\n      }\n\n      // rendering\n      function render(){\n        // clear svg\n        while(svg.lastChild) svg.removeChild(svg.lastChild);\n        // re-add defs\n        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n        defs.innerHTML = '<marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\"><path d=\"M0,0 L10,5 L0,10 z\" class=\"markerArrow\"/></marker>';\n        svg.appendChild(defs);\n\n        // prepare maps\n        const nodeById = new Map(nodes.map(n=>[n.id,n]));\n        // draw edges behind nodes\n        const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\n        svg.appendChild(edgeGroup);\n\n        // highlight cycle edges if present (kahnState may have cycleEdges)\n        const cycleEdges = kahnState && kahnState.cycleEdges ? new Set(kahnState.cycleEdges) : new Set();\n\n        for(const e of edges){\n          const from = nodeById.get(e.from);\n          const to = nodeById.get(e.to);\n          if(!from || !to) continue;\n          // compute line from edge of circle to edge of circle\n          const r = 24;\n          const dx = to.x - from.x, dy = to.y - from.y;\n          const dist = Math.hypot(dx,dy) || 1;\n          const ux = dx/dist, uy = dy/dist;\n          const startX = from.x + ux*r;\n          const startY = from.y + uy*r;\n          const endX = to.x - ux*r;\n          const endY = to.y - uy*r;\n\n          const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n          path.setAttribute('d',`M ${startX} ${startY} L ${endX} ${endY}`);\n          path.setAttribute('class','edgePath');\n          path.setAttribute('marker-end','url(#arrow)');\n          if(cycleEdges.has(e.id)){\n            path.classList.add('cycleEdge');\n            path.setAttribute('stroke','#ffb3b3');\n          }\n          edgeGroup.appendChild(path);\n\n          // attach event for delete\n          (function(e){\n            path.addEventListener('dblclick',ev=>{\n              // double-click to remove edge\n              edges = edges.filter(x=>x.id!==e.id);\n              resetKahn();\n              render();\n            });\n          })(e);\n        }\n\n        // nodes last (on top)\n        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\n        svg.appendChild(nodeGroup);\n\n        // show pending selection highlight\n        for(const n of nodes){\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class','nodeGroup');\n          g.setAttribute('data-id',n.id);\n\n          // circle\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('cx',n.x);\n          circle.setAttribute('cy',n.y);\n          circle.setAttribute('r',24);\n          circle.setAttribute('fill','#063a4f');\n          circle.setAttribute('class','nodeCircle');\n          circle.style.stroke = (pendingEdgeFrom===n.id ? '#ffd166' : '#16384a');\n          if(kahnState && kahnState.removed && kahnState.removed.has(n.id)) circle.classList.add('removed');\n          if(drag.node && drag.node.id===n.id) circle.classList.add('selected');\n          circle.addEventListener('mousedown',ev=>onNodeMouseDown(ev,n));\n          circle.addEventListener('mouseup',ev=>onNodeMouseUp(ev,n));\n          circle.addEventListener('click',ev=>onNodeClick(ev,n));\n          g.appendChild(circle);\n\n          // label\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.setAttribute('x',n.x);\n          text.setAttribute('y',n.y);\n          text.setAttribute('class','nodeText');\n          text.textContent = n.label;\n          g.appendChild(text);\n\n          // small id under label\n          const idText = document.createElementNS('http://www.w3.org/2000/svg','text');\n          idText.setAttribute('x', n.x);\n          idText.setAttribute('y', n.y + 18);\n          idText.setAttribute('class','labelSmall');\n          idText.setAttribute('text-anchor','middle');\n          idText.setAttribute('fill','#bfe0ff');\n          idText.textContent = '#'+n.id;\n          g.appendChild(idText);\n\n          // in-degree badge\n          const {inDeg} = computeAdjAndInDeg();\n          const deg = inDeg.get(n.id) || 0;\n          const degText = document.createElementNS('http://www.w3.org/2000/svg','text');\n          degText.setAttribute('x', n.x + 30);\n          degText.setAttribute('y', n.y - 20);\n          degText.setAttribute('class','inDegree');\n          degText.textContent = 'in:'+deg;\n          g.appendChild(degText);\n\n          // attach to group\n          nodeGroup.appendChild(g);\n        }\n\n        updateInfo();\n        updateKahnViews();\n      }\n\n      // mouse handling\n      function onCanvasClick(ev){\n        const pt = svg.createSVGPoint();\n        pt.x = ev.clientX; pt.y = ev.clientY;\n        const ctm = svg.getScreenCTM();\n        const loc = pt.matrixTransform(ctm.inverse());\n        if(mode==='addNode'){\n          // place node\n          const label = nextNodeId <= 26 ? String.fromCharCode(64 + nextNodeId) : 'N'+nextNodeId;\n          nodes.push({id:nextNodeId,label:label,x:loc.x,y:loc.y});\n          nextNodeId++;\n          resetKahn();\n          render();\n        } else {\n          // nothing\n        }\n      }\n\n      function onNodeMouseDown(ev,node){\n        ev.stopPropagation();\n        if(mode==='delete'){\n          // remove node and its edges\n          nodes = nodes.filter(n=>n.id!==node.id);\n          edges = edges.filter(e=>e.from!==node.id && e.to!==node.id);\n          resetKahn();\n          render();\n          return;\n        }\n        if(mode==='addEdge'){\n          if(!pendingEdgeFrom){\n            pendingEdgeFrom = node.id;\n            render();\n            return;\n          } else {\n            // create edge from pendingEdgeFrom to node.id\n            if(pendingEdgeFrom === node.id){\n              // self-loop\n            } else {\n              // if duplicate, skip\n              const exists = edges.some(e=>e.from===pendingEdgeFrom && e.to===node.id);\n              if(!exists) edges.push({id:nextEdgeId++,from:pendingEdgeFrom,to:node.id});\n            }\n            pendingEdgeFrom = null;\n            resetKahn();\n            render();\n            return;\n          }\n        }\n        if(mode==='addNode' || mode===null){\n          // start drag\n          drag.node = node;\n          const pt = svg.createSVGPoint();\n          pt.x = ev.clientX; pt.y = ev.clientY;\n          const loc = pt.matrixTransform(svg.getScreenCTM().inverse());\n          drag.offsetX = node.x - loc.x;\n          drag.offsetY = node.y - loc.y;\n          document.addEventListener('mousemove',onDocMouseMove);\n          document.addEventListener('mouseup',onDocMouseUp);\n        }\n      }\n      function onNodeMouseUp(ev,node){\n        // placeholder in case needed\n      }\n      function onNodeClick(ev,node){\n        ev.stopPropagation();\n        // allow selecting a node when not dragging to add edges\n        if(mode==='addEdge' && pendingEdgeFrom && pendingEdgeFrom!==node.id){\n          const exists = edges.some(e=>e.from===pendingEdgeFrom && e.to===node.id);\n          if(!exists) edges.push({id:nextEdgeId++,from:pendingEdgeFrom,to:node.id});\n          pendingEdgeFrom = null;\n          resetKahn();\n          render();\n          return;\n        }\n      }\n      function onDocMouseMove(ev){\n        if(!drag.node) return;\n        const pt = svg.createSVGPoint();\n        pt.x = ev.clientX; pt.y = ev.clientY;\n        const loc = pt.matrixTransform(svg.getScreenCTM().inverse());\n        drag.node.x = loc.x + drag.offsetX;\n        drag.node.y = loc.y + drag.offsetY;\n        render();\n      }\n      function onDocMouseUp(ev){\n        if(drag.node){\n          drag.node = null;\n          document.removeEventListener('mousemove',onDocMouseMove);\n          document.removeEventListener('mouseup',onDocMouseUp);\n          render();\n        }\n      }\n\n      // Kahn algorithm functions\n      function initKahn(){\n        const {adj,inDeg} = computeAdjAndInDeg();\n        const inDegCopy = new Map(inDeg);\n        const outMap = new Map();\n        for(const [k,v] of adj.entries()) outMap.set(k, v.slice());\n        const queue = [];\n        for(const n of nodes){\n          if((inDegCopy.get(n.id)||0)===0) queue.push(n.id);\n        }\n        kahnState = {inDeg:inDegCopy,idToOut:outMap,queue:queue,order:[],removed:new Set(),cycleEdges:null};\n        algoStatus.textContent = 'kahn initialized';\n        render();\n      }\n      function resetKahn(){\n        if(playInterval){ clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play'; }\n        kahnState = null;\n        algoStatus.textContent = 'idle';\n        updateKahnViews();\n      }\n\n      function kahnStepOnce(){\n        if(!kahnState) initKahn();\n        const state = kahnState;\n        if(state.queue.length===0){\n          // finished or cycle\n          if(state.order.length === nodes.length){\n            algoStatus.textContent = 'done — topological order complete';\n          } else {\n            // cycle exists: mark remaining edges as cycle edges for visualization\n            algoStatus.textContent = 'cycle detected — no topo ordering';\n            const remainingEdges = edges.filter(e=> !state.removed.has(e.from) || !state.removed.has(e.to));\n            state.cycleEdges = remainingEdges.map(e=>e.id);\n          }\n          render();\n          return;\n        }\n        // pop a node from queue\n        const n = state.queue.shift();\n        state.order.push(n);\n        state.removed.add(n);\n        // remove outgoing edges\n        const outs = state.idToOut.get(n) || [];\n        for(const to of outs){\n          // find edge objects and mark removed (we won't physically delete edges; we track in particular inDeg)\n          const current = state.inDeg.get(to) || 0;\n          state.inDeg.set(to, current-1);\n          if(state.inDeg.get(to)===0){\n            state.queue.push(to);\n          }\n        }\n        algoStatus.textContent = `removed ${labelOf(n)}`;\n        render();\n      }\n\n      function updateKahnViews(){\n        // queue view\n        while(queueView.firstChild) queueView.removeChild(queueView.lastChild);\n        while(orderView.firstChild) orderView.removeChild(orderView.lastChild);\n        if(!kahnState){\n          queueView.textContent = '(not initialized)';\n          orderView.textContent = '(none)';\n          return;\n        }\n        const q = document.createElement('div');\n        q.style.display='flex'; q.style.gap='6px'; q.style.flexWrap='wrap';\n        for(const id of kahnState.queue){\n          const d = document.createElement('div');\n          d.className='queueItem';\n          d.textContent = labelOf(id);\n          q.appendChild(d);\n        }\n        queueView.appendChild(q);\n\n        const ord = document.createElement('div');\n        ord.style.display='flex'; ord.style.gap='6px'; ord.style.flexWrap='wrap';\n        for(const id of kahnState.order){\n          const d = document.createElement('div');\n          d.className='orderItem';\n          d.textContent = labelOf(id);\n          ord.appendChild(d);\n        }\n        orderView.appendChild(ord);\n      }\n\n      // run to end with delays or instant\n      function kahnPlayToggle(){\n        if(playInterval){\n          clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play';\n          return;\n        }\n        if(!kahnState) initKahn();\n        kahnPlay.textContent='Pause';\n        const speed = parseInt(playSpeed.value);\n        playInterval = setInterval(()=>{\n          if(!kahnState) { clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play'; return;}\n          const prevOrderLen = kahnState.order.length;\n          kahnStepOnce();\n          if(kahnState.queue.length===0 || kahnState.order.length===nodes.length || kahnState.order.length===prevOrderLen){\n            clearInterval(playInterval); playInterval=null; kahnPlay.textContent='Play';\n          }\n        },speed);\n      }\n\n      function kahnRunToEnd(){\n        if(!kahnState) initKahn();\n        // run instantly\n        while(kahnState.queue.length>0){\n          kahnStepOnce();\n        }\n        // final check\n        if(kahnState.order.length !== nodes.length){\n          algoStatus.textContent = 'cycle detected';\n          kahnState.cycleEdges = edges.map(e=>e.id);\n        } else {\n          algoStatus.textContent = 'done';\n        }\n        render();\n      }\n\n      // full instant Kahn\n      function kahnFullInstant(){\n        resetKahn();\n        initKahn();\n        const state = kahnState;\n        while(state.queue.length>0){\n          const n = state.queue.shift();\n          state.order.push(n);\n          state.removed.add(n);\n          const outs = state.idToOut.get(n) || [];\n          for(const to of outs){\n            state.inDeg.set(to, state.inDeg.get(to)-1);\n            if(state.inDeg.get(to)===0) state.queue.push(to);\n          }\n        }\n        if(state.order.length !== nodes.length){\n          algoStatus.textContent = 'cycle detected';\n          state.cycleEdges = edges.map(e=>e.id);\n        } else {\n          algoStatus.textContent = 'complete';\n        }\n        render();\n      }\n\n      // DFS topological sort with cycle detection, returns {order,cycle:boolean}\n      function dfsTopo(){\n        const {adj} = computeAdjAndInDeg();\n        const visited = new Map(); // 0=un,1=visiting,2=done\n        const order = [];\n        let cycle = null;\n        function visit(u,stack){\n          if(cycle) return;\n          visited.set(u,1);\n          stack.push(u);\n          const outs = adj.get(u) || [];\n          for(const v of outs){\n            if(visited.get(v)===1){\n              // back edge -> cycle\n              cycle = stack.slice(stack.indexOf(v)).concat(v);\n              return;\n            } else if(!visited.get(v)){\n              visit(v,stack);\n              if(cycle) return;\n            }\n          }\n          stack.pop();\n          visited.set(u,2);\n          order.push(u);\n        }\n        for(const n of nodes){\n          if(!visited.get(n.id)) visit(n.id,[]);\n        }\n        return {order: order.reverse(), cycle};\n      }\n\n      // UI wiring\n      svg.addEventListener('click',onCanvasClick);\n      btnAddNode.addEventListener('click',()=> setMode(mode==='addNode'?null:'addNode'));\n      btnAddEdge.addEventListener('click',()=> setMode(mode==='addEdge'?null:'addEdge'));\n      btnDelete.addEventListener('click',()=> setMode(mode==='delete'?null:'delete'));\n      btnClear.addEventListener('click',()=> { if(confirm('Clear graph?')) clearGraph(); });\n\n      btnRand.addEventListener('click',()=>{\n        const n = Math.max(1,parseInt(randN.value)||6);\n        const p = Math.max(0,Math.min(100,parseInt(randP.value)||30));\n        randomDAG(n,p);\n      });\n\n      kahnReset.addEventListener('click',()=> resetKahn());\n      kahnStep.addEventListener('click',()=> kahnStepOnce());\n      kahnPlay.addEventListener('click',()=> kahnPlayToggle());\n      kahnRun.addEventListener('click',()=> kahnRunToEnd());\n      btnKahnFull.addEventListener('click',()=> kahnFullInstant());\n      btnDFS.addEventListener('click',()=>{\n        const res = dfsTopo();\n        if(res.cycle){\n          alert('Cycle detected (nodes): ' + res.cycle.map(id=>labelOf(id)).join(' -> '));\n          // highlight cycle edges\n          // mark edges participating in cycle (heuristic: edges between these nodes)\n          const setc = new Set(res.cycle);\n          resetKahn();\n          kahnState = {inDeg:new Map(), idToOut:new Map(), queue:[], order:[], removed:new Set(), cycleEdges:[]};\n          for(const e of edges){\n            if(setc.has(e.from) && setc.has(e.to)) kahnState.cycleEdges.push(e.id);\n          }\n          algoStatus.textContent = 'DFS: cycle';\n          render();\n        } else {\n          alert('Topological order (DFS): ' + res.order.map(id=>labelOf(id)).join(', '));\n          // show result visually\n          resetKahn();\n          kahnState = {inDeg:new Map(), idToOut:new Map(), queue:[], order:res.order.slice(), removed:new Set(), cycleEdges:null};\n          for(const id of res.order) kahnState.removed.add(id);\n          algoStatus.textContent = 'DFS: order computed';\n          render();\n        }\n      });\n\n      btnCompare.addEventListener('click',()=>{\n        // run both algorithms and compare\n        resetKahn();\n        kahnFullInstant();\n        const kahnOrder = kahnState && kahnState.order ? kahnState.order.slice() : [];\n        const dfsRes = dfsTopo();\n        if(dfsRes.cycle){\n          alert('DFS found a cycle, Kahn also reports: ' + (kahnState && kahnState.order.length !== nodes.length ? 'cycle' : 'inconsistent'));\n        } else {\n          const dfOrder = dfsRes.order;\n          const s1 = kahnOrder.map(labelOf).join(', ');\n          const s2 = dfOrder.map(labelOf).join(', ');\n          alert('Kahn: ' + s1 + '\\nDFS:  ' + s2 + '\\n(Orders may differ but are valid topological sorts)');\n        }\n      });\n\n      // double click on empty canvas to generate sample\n      svg.addEventListener('dblclick',ev=>{\n        // create a small example with a known DAG\n        nodes = [\n          {id:1,label:'A',x:200,y:160},\n          {id:2,label:'B',x:420,y:90},\n          {id:3,label:'C',x:420,y:240},\n          {id:4,label:'D',x:640,y:160},\n          {id:5,label:'E',x:860,y:160},\n        ];\n        edges = [\n          {id:1,from:1,to:2},\n          {id:2,from:1,to:3},\n          {id:3,from:2,to:4},\n          {id:4,from:3,to:4},\n          {id:5,from:4,to:5},\n        ];\n        nextEdgeId = 6; nextNodeId = 6;\n        resetKahn();\n        render();\n      });\n\n      // keyboard: Esc cancels mode\n      document.addEventListener('keydown',ev=>{\n        if(ev.key==='Escape'){ setMode(null); pendingEdgeFrom=null; render(); }\n      });\n\n      // init with a small graph\n      randomDAG(6,30);\n\n      // Expose a tiny help in status\n      algoStatus.textContent = 'idle — ready';\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}