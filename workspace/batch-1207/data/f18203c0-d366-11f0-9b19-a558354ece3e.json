{
  "id": "f18203c0-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:21:57.885Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .input-section, .result-section, .visualization {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        textarea {\n            width: 100%;\n            height: 120px;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-family: monospace;\n        }\n        button {\n            background-color: #4CAF50;\n            color: white;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        .result {\n            margin-top: 15px;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 4px;\n            min-height: 50px;\n        }\n        .graph-container {\n            position: relative;\n            height: 400px;\n            border: 1px solid #ddd;\n            background-color: #fafafa;\n        }\n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            background-color: #4CAF50;\n            color: white;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n        }\n        .edge {\n            position: absolute;\n            background-color: #666;\n            transform-origin: 0 0;\n        }\n        .arrow {\n            position: absolute;\n            width: 0;\n            height: 0;\n            border-left: 6px solid transparent;\n            border-right: 6px solid transparent;\n            border-top: 10px solid #666;\n        }\n        .step-active {\n            background-color: #2196F3 !important;\n            transform: scale(1.2);\n            transition: all 0.3s ease;\n        }\n        .completed {\n            background-color: #8BC34A !important;\n        }\n        .error {\n            color: #f44336;\n            font-weight: bold;\n        }\n        .step-info {\n            margin-top: 10px;\n            font-style: italic;\n            color: #666;\n        }\n        .controls {\n            display: flex;\n            gap: 10px;\n            margin-top: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Topological Sort Visualization</h1>\n        \n        <div class=\"input-section\">\n            <h2>Graph Input</h2>\n            <p>Enter edges in format \"A→B\" (one per line):</p>\n            <textarea id=\"graphInput\" placeholder=\"A→B\nB→C\nA→D\nD→C\">A→B\nB→C\nA→D\nD→C</textarea>\n            <div class=\"controls\">\n                <button onclick=\"performTopologicalSort()\">Perform Topological Sort</button>\n                <button onclick=\"resetVisualization()\">Reset</button>\n                <button onclick=\"stepThroughSort()\" id=\"stepBtn\">Step Through</button>\n            </div>\n        </div>\n\n        <div class=\"result-section\">\n            <h2>Result</h2>\n            <div id=\"result\" class=\"result\"></div>\n            <div id=\"stepInfo\" class=\"step-info\"></div>\n        </div>\n\n        <div class=\"visualization\">\n            <h2>Graph Visualization</h2>\n            <div id=\"graphContainer\" class=\"graph-container\"></div>\n        </div>\n    </div>\n\n    <script>\n        let graph = {};\n        let inDegree = {};\n        let nodes = new Set();\n        let steps = [];\n        let currentStep = 0;\n        let isStepping = false;\n\n        function parseInput() {\n            const input = document.getElementById('graphInput').value;\n            const lines = input.split('\\n').filter(line => line.trim());\n            \n            graph = {};\n            nodes = new Set();\n            \n            lines.forEach(line => {\n                const match = line.match(/(\\w+)\\s*→\\s*(\\w+)/);\n                if (match) {\n                    const [_, from, to] = match;\n                    nodes.add(from);\n                    nodes.add(to);\n                    \n                    if (!graph[from]) graph[from] = [];\n                    graph[from].push(to);\n                }\n            });\n            \n            // Initialize in-degree for all nodes\n            inDegree = {};\n            nodes.forEach(node => inDegree[node] = 0);\n            \n            // Calculate in-degree for each node\n            nodes.forEach(node => {\n                if (graph[node]) {\n                    graph[node].forEach(neighbor => {\n                        inDegree[neighbor]++;\n                    });\n                }\n            });\n        }\n\n        function topologicalSort() {\n            parseInput();\n            steps = [];\n            \n            const queue = [];\n            const result = [];\n            const localInDegree = {...inDegree};\n            \n            // Find all nodes with in-degree 0\n            nodes.forEach(node => {\n                if (localInDegree[node] === 0) {\n                    queue.push(node);\n                }\n            });\n            \n            steps.push({\n                action: 'initial',\n                queue: [...queue],\n                result: [],\n                current: null,\n                message: `Starting with nodes having in-degree 0: ${queue.join(', ')}`\n            });\n            \n            while (queue.length > 0) {\n                const node = queue.shift();\n                result.push(node);\n                \n                steps.push({\n                    action: 'process',\n                    queue: [...queue],\n                    result: [...result],\n                    current: node,\n                    message: `Processing node ${node}`\n                });\n                \n                if (graph[node]) {\n                    graph[node].forEach(neighbor => {\n                        localInDegree[neighbor]--;\n                        steps.push({\n                            action: 'decrement',\n                            queue: [...queue],\n                            result: [...result],\n                            current: neighbor,\n                            message: `Decreased in-degree of ${neighbor} to ${localInDegree[neighbor]}`\n                        });\n                        \n                        if (localInDegree[neighbor] === 0) {\n                            queue.push(neighbor);\n                            steps.push({\n                                action: 'enqueue',\n                                queue: [...queue],\n                                result: [...result],\n                                current: neighbor,\n                                message: `${neighbor} now has in-degree 0, adding to queue`\n                            });\n                        }\n                    });\n                }\n            }\n            \n            if (result.length !== nodes.size) {\n                steps.push({\n                    action: 'cycle',\n                    queue: [],\n                    result: [...result],\n                    current: null,\n                    message: 'Cycle detected! Graph is not a DAG (Directed Acyclic Graph)'\n                });\n                return {result: null, hasCycle: true};\n            }\n            \n            steps.push({\n                action: 'complete',\n                queue: [],\n                result: [...result],\n                current: null,\n                message: 'Topological sort completed successfully!'\n            });\n            \n            return {result, hasCycle: false};\n        }\n\n        function performTopologicalSort() {\n            resetVisualization();\n            const {result, hasCycle} = topologicalSort();\n            displayGraph();\n            \n            if (hasCycle) {\n                document.getElementById('result').innerHTML = \n                    '<span class=\"error\">Cycle detected! The graph contains a cycle and cannot be topologically sorted.</span>';\n            } else {\n                document.getElementById('result').innerHTML = \n                    `<strong>Topological Order:</strong> ${result.join(' → ')}`;\n            }\n            \n            // Auto-animate the steps\n            animateSteps();\n        }\n\n        function stepThroughSort() {\n            if (!isStepping) {\n                resetVisualization();\n                topologicalSort();\n                displayGraph();\n                currentStep = 0;\n                isStepping = true;\n                document.getElementById('stepBtn').textContent = 'Next Step';\n                updateStep();\n            } else {\n                currentStep++;\n                if (currentStep >= steps.length) {\n                    isStepping = false;\n                    document.getElementById('stepBtn').textContent = 'Step Through';\n                } else {\n                    updateStep();\n                }\n            }\n        }\n\n        function updateStep() {\n            if (currentStep >= steps.length) return;\n            \n            const step = steps[currentStep];\n            document.getElementById('stepInfo').textContent = step.message;\n            \n            // Highlight current node\n            document.querySelectorAll('.node').forEach(node => {\n                node.classList.remove('step-active', 'completed');\n            });\n            \n            if (step.current) {\n                const currentNode = document.querySelector(`.node[data-node=\"${step.current}\"]`);\n                if (currentNode) {\n                    currentNode.classList.add('step-active');\n                }\n            }\n            \n            // Mark completed nodes\n            step.result.forEach(node => {\n                const completedNode = document.querySelector(`.node[data-node=\"${node}\"]`);\n                if (completedNode) {\n                    completedNode.classList.add('completed');\n                }\n            });\n        }\n\n        function animateSteps() {\n            if (steps.length === 0) return;\n            \n            let stepIndex = 0;\n            const interval = setInterval(() => {\n                if (stepIndex >= steps.length) {\n                    clearInterval(interval);\n                    return;\n                }\n                \n                const step = steps[stepIndex];\n                document.getElementById('stepInfo').textContent = step.message;\n                \n                // Update visualization\n                document.querySelectorAll('.node').forEach(node => {\n                    node.classList.remove('step-active', 'completed');\n                });\n                \n                if (step.current) {\n                    const currentNode = document.querySelector(`.node[data-node=\"${step.current}\"]`);\n                    if (currentNode) currentNode.classList.add('step-active');\n                }\n                \n                step.result.forEach(node => {\n                    const completedNode = document.querySelector(`.node[data-node=\"${node}\"]`);\n                    if (completedNode) completedNode.classList.add('completed');\n                });\n                \n                stepIndex++;\n            }, 1500);\n        }\n\n        function displayGraph() {\n            const container = document.getElementById('graphContainer');\n            container.innerHTML = '';\n            \n            if (nodes.size === 0) return;\n            \n            const nodePositions = {};\n            const radius = 150;\n            const centerX = container.offsetWidth / 2;\n            const centerY = container.offsetHeight / 2;\n            const angleStep = (2 * Math.PI) / nodes.size;\n            \n            // Position nodes in a circle\n            let angle = 0;\n            Array.from(nodes).forEach((node, index) => {\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                \n                nodePositions[node] = {x, y};\n                \n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.textContent = node;\n                nodeElement.style.left = (x - 20) + 'px';\n                nodeElement.style.top = (y - 20) + 'px';\n                nodeElement.setAttribute('data-node', node);\n                container.appendChild(nodeElement);\n                \n                angle += angleStep;\n            });\n            \n            // Draw edges\n            Object.keys(graph).forEach(from => {\n                graph[from].forEach(to => {\n                    const fromPos = nodePositions[from];\n                    const toPos = nodePositions[to];\n                    \n                    // Calculate edge position and angle\n                    const dx = toPos.x - fromPos.x;\n                    const dy = toPos.y - fromPos.y;\n                    const length = Math.sqrt(dx * dx + dy * dy);\n                    const angle = Math.atan2(dy, dx);\n                    \n                    // Create edge line\n                    const edge = document.createElement('div');\n                    edge.className = 'edge';\n                    edge.style.left = (fromPos.x) + 'px';\n                    edge.style.top = (fromPos.y) + 'px';\n                    edge.style.width = length + 'px';\n                    edge.style.transform = `rotate(${angle}rad)`;\n                    edge.style.height = '2px';\n                    container.appendChild(edge);\n                    \n                    // Create arrowhead\n                    const arrow = document.createElement('div');\n                    arrow.className = 'arrow';\n                    arrow.style.left = (toPos.x - 6) + 'px';\n                    arrow.style.top = (toPos.y - 5) + 'px';\n                    arrow.style.transform = `rotate(${angle}rad)`;\n                    container.appendChild(arrow);\n                });\n            });\n        }\n\n        function resetVisualization() {\n            document.getElementById('result').innerHTML = '';\n            document.getElementById('stepInfo').textContent = '';\n            document.getElementById('graphContainer').innerHTML = '';\n            currentStep = 0;\n            isStepping = false;\n            document.getElementById('stepBtn').textContent = 'Step Through';\n        }\n\n        // Initialize with example graph\n        window.onload = function() {\n            displayGraph();\n        };\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}