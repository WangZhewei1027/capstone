{
  "id": "e9345ed0-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:56.583Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Kruskal's Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root {\n      --bg: #f7f9fb;\n      --panel: #ffffff;\n      --accent: #2b7cff;\n      --muted: #6b7280;\n      --good: #16a34a;\n      --bad: #ef4444;\n      --yellow: #f59e0b;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background:var(--bg); color:#0f172a; }\n    .container { display:flex; gap:16px; padding:16px; box-sizing:border-box; height:100%; }\n    .left, .right { background:var(--panel); border-radius:12px; padding:12px; box-shadow: 0 1px 3px rgba(2,6,23,0.06); }\n    .left { flex:1; display:flex; flex-direction:column; gap:12px; min-width:680px; }\n    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }\n    .controls label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }\n    .control-group { display:flex; flex-direction:column; min-width:120px; }\n    input[type=\"number\"], input[type=\"range\"], select { padding:8px 10px; border-radius:8px; border:1px solid #e6eef8; background:white; outline:none; font-size:13px; }\n    button { padding:8px 12px; border-radius:8px; border:0; background:var(--accent); color:white; cursor:pointer; font-weight:600; }\n    button.secondary { background:#eef2ff; color:var(--accent); border:1px solid rgba(43,124,255,0.12); }\n    button.warn { background:var(--bad); }\n    .svg-wrap { background:linear-gradient(180deg,#ffffff, #fbfdff); border-radius:8px; padding:8px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }\n    svg { width:100%; height:600px; border-radius:8px; display:block; }\n    .right { width:360px; display:flex; flex-direction:column; gap:12px; }\n    .panel { padding:8px; border-radius:8px; background:linear-gradient(180deg,#ffffff, #fbfdff); box-shadow: 0 1px 2px rgba(2,6,23,0.04); }\n    h2 { margin:6px 0 8px 0; font-size:18px; }\n    small { color:var(--muted); }\n    .edge-list { max-height:300px; overflow:auto; border-top:1px dashed #eef2ff; margin-top:8px; padding-top:8px; }\n    .edge-item { display:flex; justify-content:space-between; gap:8px; padding:6px 8px; border-radius:8px; align-items:center; }\n    .edge-item:hover { background:#fbfbff; }\n    .edge-weight { font-weight:700; background:#eef6ff; color:var(--accent); padding:4px 8px; border-radius:999px; font-size:13px; }\n    .edge-state { font-size:12px; color:var(--muted); }\n    .status { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .chip { background:#f1f5f9; padding:6px 10px; border-radius:999px; font-weight:600; color:#0f172a; }\n    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .legend .dot { display:inline-block; width:12px; height:12px; border-radius:3px; margin-right:6px; vertical-align:middle; }\n    .uf-box { display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:8px; border-radius:8px; background:#fbfdff; border:1px solid #eef2ff; }\n    .uf-item { padding:6px 10px; border-radius:8px; background:#fff; border:1px solid #eef2ff; font-weight:600; }\n    footer { margin-top:8px; font-size:12px; color:var(--muted); }\n    .controls-row { display:flex; gap:8px; align-items:center; }\n    .small { font-size:13px; color:var(--muted); }\n    .slider-label { display:flex; gap:8px; align-items:center; justify-content:space-between; }\n    .btn-icon { background:#eef6ff; color:var(--accent); border:0; padding:8px; border-radius:8px; cursor:pointer; }\n    .edge-highlighted { filter: drop-shadow(0 6px 10px rgba(43,124,255,0.06)); }\n    .input-inline { display:flex; gap:8px; align-items:center; }\n    .note { font-size:13px; color:var(--muted); }\n    /* small responsive */\n    @media (max-width:1100px) {\n      .container { flex-direction:column; }\n      .left { min-width:auto; }\n      .right { width:100%;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"left\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div>\n          <h2>Kruskal's Algorithm Visualizer</h2>\n          <small>Build a Minimum Spanning Tree by processing edges in increasing weight and using union-find to avoid cycles.</small>\n        </div>\n        <div class=\"legend\">\n          <div style=\"display:flex; flex-direction:column; gap:6px; align-items:flex-end;\">\n            <div><span class=\"dot\" style=\"background:var(--good);\"></span><small> Added to MST</small></div>\n            <div><span class=\"dot\" style=\"background:var(--bad);\"></span><small> Rejected (would cycle)</small></div>\n            <div><span class=\"dot\" style=\"background:var(--yellow);\"></span><small> Currently considered</small></div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"panel controls\">\n        <div class=\"control-group\">\n          <label>Nodes</label>\n          <div class=\"input-inline\">\n            <input id=\"nodesCount\" type=\"number\" min=\"2\" max=\"20\" value=\"8\" style=\"width:92px;\" />\n            <button id=\"genBtn\" class=\"secondary\">Generate</button>\n          </div>\n          <small class=\"note\">Click Generate to create a random graph with given node count.</small>\n        </div>\n\n        <div class=\"control-group\">\n          <label>Edge Probability</label>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <input id=\"edgeProb\" type=\"range\" min=\"0\" max=\"100\" value=\"45\" />\n            <div class=\"chip\" id=\"probLabel\">45%</div>\n          </div>\n          <small class=\"note\">Controls how dense the random graph is.</small>\n        </div>\n\n        <div style=\"display:flex; gap:8px; align-items:center;\">\n          <button id=\"resetBtn\" class=\"secondary\">Reset Colors</button>\n          <button id=\"clearBtn\" class=\"secondary\">Clear All</button>\n        </div>\n\n        <div style=\"display:flex; gap:8px; align-items:center; margin-top:6px;\">\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"playBtn\">Play</button>\n          <button id=\"fastBtn\" class=\"secondary\">Fast</button>\n          <button id=\"pauseBtn\" class=\"secondary\">Pause</button>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center; margin-top:6px;\">\n          <div class=\"control-group\" style=\"min-width:160px;\">\n            <label>Speed (ms per step)</label>\n            <input id=\"speed\" type=\"range\" min=\"50\" max=\"2000\" value=\"800\" />\n            <div class=\"small\" id=\"speedLabel\">800 ms</div>\n          </div>\n\n          <div style=\"min-width:140px;\">\n            <label>Graph Type</label>\n            <select id=\"graphType\">\n              <option value=\"random\">Random</option>\n              <option value=\"complete\">Complete</option>\n            </select>\n          </div>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:6px; align-items:center;\">\n          <div class=\"status\">\n            <div class=\"chip\">Step: <span id=\"curStep\">0</span>/<span id=\"totalEdges\">0</span></div>\n            <div class=\"chip\">MST Weight: <span id=\"mstWeight\">0</span></div>\n          </div>\n        </div>\n\n      </div>\n\n      <div class=\"panel svg-wrap\" id=\"canvasPanel\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div style=\"display:flex; gap:8px;\">\n        <div style=\"flex:1;\" class=\"panel\">\n          <small><strong>Instructions</strong></small>\n          <div class=\"note\" style=\"margin-top:6px;\">\n            - Generate a graph, then use Step to process one edge at a time. Play auto-steps through the remaining edges.<br>\n            - Kruskal sorts edges by weight and uses a union-find structure to prevent cycles: if two endpoints are in different sets, the edge is added to the MST.<br>\n            - The right panel shows the sorted edge list and the union-find parent/rank information.\n          </div>\n        </div>\n        <div style=\"width:320px;\" class=\"panel\">\n          <small><strong>Controls Tip</strong></small>\n          <div class=\"note\" style=\"margin-top:6px;\">\n            - Toggle Graph Type to Complete for a complete graph (dense).<br>\n            - Use Edge Probability (or Complete) to control density.<br>\n            - Reset Colors will clear highlights but keep the current state; Clear All generates an empty canvas.\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"right\">\n      <div class=\"panel\">\n        <h2>Sorted Edge List</h2>\n        <small>Edges are sorted by weight (ascending). The currently considered edge is highlighted.</small>\n        <div class=\"edge-list\" id=\"edgeList\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <h2>Union-Find State</h2>\n        <small>Displays parent and rank arrays plus sets colored by root.</small>\n        <div style=\"margin-top:8px;\">\n          <div style=\"display:flex; gap:6px; align-items:center; flex-wrap:wrap;\">\n            <div class=\"uf-box\" id=\"ufParents\"></div>\n          </div>\n          <div style=\"margin-top:8px;\" id=\"ufRanks\"></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <h2>Summary</h2>\n        <div style=\"display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap;\">\n          <div class=\"chip\">Edges considered: <span id=\"consideredCount\">0</span></div>\n          <div class=\"chip\">Edges in MST: <span id=\"mstCount\">0</span></div>\n          <div class=\"chip\">Nodes: <span id=\"nodesCountDisplay\">0</span></div>\n        </div>\n        <footer>\n          Kruskal's algorithm builds the minimum spanning tree by always picking the smallest edge that doesn't create a cycle. Union-Find (disjoint set) quickly answers whether two vertices belong to the same component.\n        </footer>\n      </div>\n\n    </div>\n  </div>\n\n  <script>\n    // Kruskal Visualizer - single-file\n    (() => {\n      const svg = document.getElementById('svgCanvas');\n      const genBtn = document.getElementById('genBtn');\n      const nodesCountIn = document.getElementById('nodesCount');\n      const edgeProbIn = document.getElementById('edgeProb');\n      const probLabel = document.getElementById('probLabel');\n      const graphType = document.getElementById('graphType');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const pauseBtn = document.getElementById('pauseBtn');\n      const fastBtn = document.getElementById('fastBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const edgeListEl = document.getElementById('edgeList');\n      const curStepEl = document.getElementById('curStep');\n      const totalEdgesEl = document.getElementById('totalEdges');\n      const mstWeightEl = document.getElementById('mstWeight');\n      const speedIn = document.getElementById('speed');\n      const speedLabel = document.getElementById('speedLabel');\n      const consideredCountEl = document.getElementById('consideredCount');\n      const mstCountEl = document.getElementById('mstCount');\n      const nodesCountDisplay = document.getElementById('nodesCountDisplay');\n      const ufParentsEl = document.getElementById('ufParents');\n      const ufRanksEl = document.getElementById('ufRanks');\n\n      let width = 1000, height = 700;\n      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n\n      let nodes = []; // {id, x, y, elem}\n      let edges = []; // {id, a, b, w, lineElem, labelElem}\n      let sortedEdges = []; // references to edges sorted\n      let uf = null; // union-find\n      let curIndex = 0;\n      let mstWeight = 0;\n      let consideredCount = 0;\n      let mstEdges = [];\n      let timer = null;\n      let playing = false;\n\n      function randInt(a, b) { return Math.floor(Math.random()*(b-a+1))+a; }\n      function clearSVG() {\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n      }\n\n      // Create a random layout of nodes on the canvas\n      function generateNodes(n) {\n        nodes = [];\n        const padding = 60;\n        const cols = Math.ceil(Math.sqrt(n));\n        const rows = Math.ceil(n/cols);\n        let i = 0;\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            if (i>=n) break;\n            const jitterX = randInt(-40,40);\n            const jitterY = randInt(-40,40);\n            const x = padding + (width-2*padding)*(c/(cols-1||1)) + jitterX;\n            const y = padding + (height-2*padding)*(r/(rows-1||1)) + jitterY;\n            nodes.push({ id:i, x, y });\n            i++;\n          }\n        }\n      }\n\n      // Build edges depending on graph type\n      function buildEdges(prob, type) {\n        edges = [];\n        let id = 0;\n        const n = nodes.length;\n        for (let i=0;i<n;i++){\n          for (let j=i+1;j<n;j++){\n            let include = false;\n            if (type === 'complete') include = true;\n            else include = Math.random()*100 < prob;\n            if (include) {\n              const w = randInt(1, 99);\n              edges.push({ id: id++, a: i, b: j, w });\n            }\n          }\n        }\n      }\n\n      // Draw nodes and edges to SVG\n      function drawGraph() {\n        clearSVG();\n        // Draw edges first (so nodes are on top)\n        edges.forEach(e => {\n          const na = nodes[e.a], nb = nodes[e.b];\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', na.x);\n          line.setAttribute('y1', na.y);\n          line.setAttribute('x2', nb.x);\n          line.setAttribute('y2', nb.y);\n          line.setAttribute('stroke', '#cbd5e1');\n          line.setAttribute('stroke-width', '2');\n          line.setAttribute('stroke-linecap', 'round');\n          line.setAttribute('data-edge-id', e.id);\n          svg.appendChild(line);\n          e.lineElem = line;\n\n          // weight label near midpoint\n          const mx = (na.x + nb.x)/2;\n          const my = (na.y + nb.y)/2;\n          const labelBg = document.createElementNS('http://www.w3.org/2000/svg','rect');\n          labelBg.setAttribute('x', mx-16);\n          labelBg.setAttribute('y', my-14);\n          labelBg.setAttribute('rx', 6);\n          labelBg.setAttribute('ry', 6);\n          labelBg.setAttribute('width', 32);\n          labelBg.setAttribute('height', 20);\n          labelBg.setAttribute('fill', '#ffffff');\n          labelBg.setAttribute('stroke', '#eef2ff');\n          labelBg.setAttribute('stroke-width', '1');\n          labelBg.setAttribute('pointer-events', 'none');\n          svg.appendChild(labelBg);\n\n          const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('x', mx);\n          label.setAttribute('y', my);\n          label.setAttribute('text-anchor', 'middle');\n          label.setAttribute('dominant-baseline', 'middle');\n          label.setAttribute('font-size', '12');\n          label.setAttribute('fill', '#0f172a');\n          label.setAttribute('font-weight', '700');\n          label.textContent = e.w;\n          svg.appendChild(label);\n          e.labelElem = label;\n          e.labelBg = labelBg;\n        });\n\n        // Draw nodes on top\n        nodes.forEach(n => {\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${n.x},${n.y})`);\n          g.setAttribute('data-node-id', n.id);\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', 18);\n          circle.setAttribute('fill', '#fff');\n          circle.setAttribute('stroke', '#c7d2fe');\n          circle.setAttribute('stroke-width', '2');\n          g.appendChild(circle);\n\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.setAttribute('x', 0);\n          text.setAttribute('y', 0);\n          text.setAttribute('text-anchor', 'middle');\n          text.setAttribute('dominant-baseline', 'middle');\n          text.setAttribute('font-size', '12');\n          text.setAttribute('font-weight', '700');\n          text.textContent = n.id;\n          g.appendChild(text);\n\n          svg.appendChild(g);\n          n.elem = g;\n        });\n      }\n\n      // Initialize union-find\n      function UF(n) {\n        this.parent = new Array(n);\n        this.rank = new Array(n);\n        for (let i=0;i<n;i++){ this.parent[i] = i; this.rank[i] = 0; }\n      }\n      UF.prototype.find = function(x){\n        if (this.parent[x] !== x) {\n          this.parent[x] = this.find(this.parent[x]); // path compression\n        }\n        return this.parent[x];\n      }\n      UF.prototype.union = function(a,b){\n        let ra = this.find(a), rb = this.find(b);\n        if (ra === rb) return false;\n        if (this.rank[ra] < this.rank[rb]) {\n          this.parent[ra] = rb;\n        } else if (this.rank[ra] > this.rank[rb]) {\n          this.parent[rb] = ra;\n        } else {\n          this.parent[rb] = ra;\n          this.rank[ra] += 1;\n        }\n        return true;\n      }\n\n      // Prepare Kruskal state\n      function prepareKruskal() {\n        sortedEdges = edges.slice().sort((a,b)=> a.w - b.w || a.a - b.a || a.b - b.b);\n        curIndex = 0;\n        uf = new UF(nodes.length);\n        mstWeight = 0;\n        consideredCount = 0;\n        mstEdges = [];\n        updateUI();\n        renderEdgeList();\n        colorAllDefaults();\n        highlightCounts();\n      }\n\n      function colorAllDefaults() {\n        edges.forEach(e => {\n          e.lineElem.setAttribute('stroke', '#cbd5e1');\n          e.lineElem.setAttribute('stroke-width', '2');\n          e.lineElem.setAttribute('stroke-dasharray', '');\n          e.labelElem.setAttribute('fill', '#0f172a');\n          e.labelBg.setAttribute('fill', '#ffffff');\n        });\n        nodes.forEach(n => {\n          const g = n.elem;\n          const circle = g.querySelector('circle');\n          circle.setAttribute('fill', '#fff');\n          circle.setAttribute('stroke', '#c7d2fe');\n        });\n      }\n\n      // Step through one edge\n      function step() {\n        if (!sortedEdges || curIndex >= sortedEdges.length) {\n          stopPlaying();\n          return;\n        }\n        const e = sortedEdges[curIndex];\n\n        // highlight considered\n        highlightConsidered(e);\n\n        // Wait briefly (visual) then decide (in play we rely on interval)\n        // Do the check and union\n        const a = e.a, b = e.b;\n        const ra = uf.find(a), rb = uf.find(b);\n        consideredCount++;\n        if (ra !== rb) {\n          // add to MST\n          uf.union(a,b);\n          mstEdges.push(e);\n          mstWeight += e.w;\n          colorEdgeAdded(e);\n        } else {\n          colorEdgeRejected(e);\n        }\n        curIndex++;\n        updateUI();\n        renderEdgeList();\n        highlightCounts();\n        recolorNodesBySet();\n        if (curIndex >= sortedEdges.length) {\n          stopPlaying();\n        }\n      }\n\n      // Visual helpers\n      function highlightConsidered(edge) {\n        // make previously considered remain same; current get yellow\n        edges.forEach(e => {\n          if (e === edge) {\n            e.lineElem.setAttribute('stroke', getCSSVar('--yellow') );\n            e.lineElem.setAttribute('stroke-width', '4');\n            e.lineElem.classList.add('edge-highlighted');\n            e.lineElem.setAttribute('stroke-dasharray', '');\n            e.labelBg.setAttribute('fill', '#fff7ed');\n          } else {\n            e.lineElem.classList.remove('edge-highlighted');\n          }\n        });\n        // highlight list item\n        const items = edgeListEl.querySelectorAll('.edge-item');\n        items.forEach(it => {\n          it.style.background = '';\n        });\n      }\n\n      function colorEdgeAdded(e) {\n        e.lineElem.setAttribute('stroke', getCSSVar('--good'));\n        e.lineElem.setAttribute('stroke-width', '5');\n        e.lineElem.setAttribute('stroke-dasharray', '');\n        e.labelBg.setAttribute('fill', '#ecfdf5');\n      }\n      function colorEdgeRejected(e) {\n        e.lineElem.setAttribute('stroke', getCSSVar('--bad'));\n        e.lineElem.setAttribute('stroke-width', '3');\n        e.lineElem.setAttribute('stroke-dasharray', '6 6');\n        e.labelBg.setAttribute('fill', '#fff1f2');\n      }\n\n      function recolorNodesBySet() {\n        const roots = {};\n        let colorIdx = 0;\n        const palette = [\n          '#f97316','#06b6d4','#7c3aed','#ef4444','#10b981','#f59e0b','#3b82f6','#ef6f6c','#9333ea','#0ea5a4'\n        ];\n        nodes.forEach(n => {\n          const r = uf.find(n.id);\n          if (!(r in roots)) roots[r] = palette[colorIdx++ % palette.length];\n        });\n        nodes.forEach(n => {\n          const g = n.elem;\n          const circle = g.querySelector('circle');\n          const color = roots[ uf.find(n.id) ] || '#fff';\n          circle.setAttribute('fill', color);\n          circle.setAttribute('stroke', '#ffffff');\n        });\n\n        // update UF display\n        renderUF();\n      }\n\n      function renderEdgeList() {\n        edgeListEl.innerHTML = '';\n        totalEdgesEl.textContent = sortedEdges.length;\n        sortedEdges.forEach((e, idx) => {\n          const el = document.createElement('div');\n          el.className = 'edge-item';\n          el.style.display = 'flex';\n          el.style.justifyContent = 'space-between';\n          el.style.alignItems = 'center';\n          el.style.padding = '6px';\n          const left = document.createElement('div');\n          left.innerHTML = `<strong>${e.a} ↔ ${e.b}</strong> <span class=\"small\" style=\"margin-left:6px;\">(${idx+1})</span>`;\n          const right = document.createElement('div');\n          const wspan = document.createElement('span');\n          wspan.className = 'edge-weight';\n          wspan.textContent = e.w;\n          right.appendChild(wspan);\n\n          const state = document.createElement('div');\n          state.className = 'edge-state';\n          if (mstEdges.indexOf(e) !== -1) state.textContent = 'in MST';\n          else if (idx < curIndex) state.textContent = 'rejected';\n          else if (idx === curIndex) state.textContent = 'considering';\n          else state.textContent = '';\n          right.appendChild(state);\n\n          el.appendChild(left);\n          el.appendChild(right);\n\n          // click to center/highlight\n          el.addEventListener('click', () => {\n            // scroll svg to show the edge (we just flash it)\n            flashEdge(e);\n          });\n\n          edgeListEl.appendChild(el);\n        });\n      }\n\n      function flashEdge(e) {\n        const orig = e.lineElem.getAttribute('stroke');\n        e.lineElem.setAttribute('stroke', getCSSVar('--accent'));\n        e.lineElem.setAttribute('stroke-width', '6');\n        setTimeout(()=> {\n          // restore based on state\n          if (mstEdges.indexOf(e) !== -1) colorEdgeAdded(e);\n          else if (sortedEdges.indexOf(e) < curIndex) colorEdgeRejected(e);\n          else {\n            e.lineElem.setAttribute('stroke', '#cbd5e1');\n            e.lineElem.setAttribute('stroke-width', '2');\n            e.labelBg.setAttribute('fill', '#ffffff');\n          }\n        }, 700);\n      }\n\n      function updateUI() {\n        curStepEl.textContent = curIndex;\n        mstWeightEl.textContent = mstWeight;\n        consideredCountEl.textContent = consideredCount;\n        mstCountEl.textContent = mstEdges.length;\n        nodesCountDisplay.textContent = nodes.length;\n      }\n\n      function renderUF() {\n        ufParentsEl.innerHTML = '';\n        ufRanksEl.innerHTML = '';\n        // parents\n        for (let i=0;i<nodes.length;i++){\n          const box = document.createElement('div');\n          box.className = 'uf-item';\n          box.style.background = '#fff';\n          box.style.border = '1px solid #eef2ff';\n          box.textContent = `p[${i}] = ${uf.parent[i]}`;\n          ufParentsEl.appendChild(box);\n        }\n        // ranks\n        const rankTitle = document.createElement('div');\n        rankTitle.style.fontSize = '13px';\n        rankTitle.style.color = '#475569';\n        rankTitle.style.marginTop = '6px';\n        rankTitle.textContent = 'Ranks:';\n        ufRanksEl.appendChild(rankTitle);\n        for (let i=0;i<nodes.length;i++){\n          const r = document.createElement('div');\n          r.className = 'uf-item';\n          r.style.background = '#fff';\n          r.style.border = '1px solid #eef2ff';\n          r.textContent = `r[${i}] = ${uf.rank[i]}`;\n          ufRanksEl.appendChild(r);\n        }\n      }\n\n      function highlightCounts() {\n        // highlight the current considered in list\n        const items = edgeListEl.querySelectorAll('.edge-item');\n        items.forEach((it, idx)=>{\n          it.style.background = (idx === curIndex) ? '#fff7ed' : '';\n        });\n      }\n\n      function getCSSVar(name) {\n        return getComputedStyle(document.documentElement).getPropertyValue(name) || '#000';\n      }\n\n      // Controls wiring\n      genBtn.addEventListener('click', ()=> {\n        const n = Math.max(2, Math.min(20, parseInt(nodesCountIn.value) || 8));\n        const prob = parseInt(edgeProbIn.value);\n        generateNodes(n);\n        buildEdges(prob, graphType.value);\n        drawGraph();\n        prepareKruskal();\n      });\n\n      edgeProbIn.addEventListener('input', ()=>{\n        probLabel.textContent = edgeProbIn.value + '%';\n      });\n\n      stepBtn.addEventListener('click', ()=> {\n        stopPlaying();\n        step();\n      });\n\n      playBtn.addEventListener('click', ()=> {\n        if (playing) return;\n        playing = true;\n        const ms = parseInt(speedIn.value);\n        timer = setInterval(()=> {\n          if (curIndex >= sortedEdges.length) { stopPlaying(); return; }\n          step();\n        }, ms);\n      });\n      pauseBtn.addEventListener('click', ()=> stopPlaying());\n      fastBtn.addEventListener('click', ()=> {\n        stopPlaying();\n        timer = setInterval(()=> {\n          if (!sortedEdges || curIndex >= sortedEdges.length) { stopPlaying(); return; }\n          step();\n        }, 80);\n        playing = true;\n      });\n\n      function stopPlaying() {\n        if (timer) { clearInterval(timer); timer = null; }\n        playing = false;\n      }\n\n      speedIn.addEventListener('input', ()=> {\n        speedLabel.textContent = speedIn.value + ' ms';\n        if (playing) {\n          stopPlaying();\n          // restart with new speed\n          timer = setInterval(()=> {\n            if (curIndex >= sortedEdges.length) { stopPlaying(); return; }\n            step();\n          }, parseInt(speedIn.value));\n          playing = true;\n        }\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        colorAllDefaults();\n        prepareKruskal(); // resets unions\n        // But keep progress? We'll just reset everything to initial state\n      });\n\n      clearBtn.addEventListener('click', ()=> {\n        stopPlaying();\n        nodes = [];\n        edges = [];\n        sortedEdges = [];\n        curIndex = 0;\n        consideredCount = 0;\n        mstWeight = 0;\n        mstEdges = [];\n        clearSVG();\n        updateUI();\n        edgeListEl.innerHTML = '';\n        ufParentsEl.innerHTML = '';\n        ufRanksEl.innerHTML = '';\n        totalEdgesEl.textContent = 0;\n      });\n\n      // init with default sample\n      function initDemo() {\n        const n = parseInt(nodesCountIn.value) || 8;\n        const prob = parseInt(edgeProbIn.value);\n        generateNodes(n);\n        buildEdges(prob, graphType.value);\n        drawGraph();\n        prepareKruskal();\n        updateUI();\n      }\n\n      initDemo();\n\n      // allow clicking an edge in the svg to flash it\n      svg.addEventListener('click', (ev) => {\n        if (!ev.target) return;\n        if (ev.target.tagName === 'line') {\n          const id = parseInt(ev.target.getAttribute('data-edge-id'));\n          const e = edges.find(x => x.id === id);\n          if (e) flashEdge(e);\n        }\n      });\n\n      // small keyboard shortcuts\n      document.addEventListener('keydown', (e) => {\n        if (e.key === ' ') { e.preventDefault(); stopPlaying(); step(); }\n        if (e.key === 'p') { playBtn.click(); }\n        if (e.key === 's') { stepBtn.click(); }\n        if (e.key === 'r') { resetBtn.click(); }\n      });\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}