{
  "id": "f18278f2-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:37.558Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Visualization</title>\n    <style>\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            font-family: Arial, sans-serif;\n        }\n        .controls {\n            margin-bottom: 20px;\n            padding: 15px;\n            background: #f5f5f5;\n            border-radius: 5px;\n        }\n        canvas {\n            border: 1px solid #ccc;\n            margin-bottom: 20px;\n            background: white;\n        }\n        .cluster-info {\n            display: flex;\n            gap: 20px;\n            margin-bottom: 20px;\n        }\n        .cluster-card {\n            padding: 10px;\n            border-radius: 5px;\n            flex: 1;\n            min-height: 60px;\n        }\n        button {\n            padding: 8px 16px;\n            margin: 5px;\n            background: #007bff;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background: #0056b3;\n        }\n        button:disabled {\n            background: #6c757d;\n            cursor: not-allowed;\n        }\n        input[type=\"range\"] {\n            width: 200px;\n            margin: 0 10px;\n        }\n        label {\n            margin-right: 10px;\n        }\n        .status {\n            margin-top: 10px;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>K-Means Clustering Visualization</h1>\n        \n        <div class=\"controls\">\n            <div>\n                <label for=\"kValue\">Number of Clusters (K):</label>\n                <input type=\"range\" id=\"kValue\" min=\"2\" max=\"8\" value=\"3\">\n                <span id=\"kDisplay\">3</span>\n            </div>\n            <div>\n                <label for=\"pointCount\">Number of Points:</label>\n                <input type=\"range\" id=\"pointCount\" min=\"50\" max=\"300\" value=\"150\">\n                <span id=\"pointCountDisplay\">150</span>\n            </div>\n            <div>\n                <button id=\"generatePoints\">Generate Random Points</button>\n                <button id=\"runKMeans\">Run K-Means</button>\n                <button id=\"stepKMeans\">Step Through</button>\n                <button id=\"reset\">Reset</button>\n            </div>\n            <div class=\"status\" id=\"status\">Ready - Click \"Generate Random Points\" to start</div>\n        </div>\n\n        <div class=\"cluster-info\" id=\"clusterInfo\"></div>\n        \n        <canvas id=\"canvas\" width=\"1000\" height=\"600\"></canvas>\n        \n        <div>\n            <h3>How K-Means Clustering Works:</h3>\n            <ol>\n                <li><strong>Initialization:</strong> Randomly select K points as initial cluster centroids</li>\n                <li><strong>Assignment:</strong> Assign each data point to the nearest centroid</li>\n                <li><strong>Update:</strong> Recalculate centroids as the mean of all points in the cluster</li>\n                <li><strong>Repeat:</strong> Continue steps 2-3 until convergence (no more changes)</li>\n            </ol>\n        </div>\n    </div>\n\n    <script>\n        class KMeans {\n            constructor(k, points) {\n                this.k = k;\n                this.points = points;\n                this.centroids = [];\n                this.clusters = [];\n                this.iterations = 0;\n                this.converged = false;\n            }\n\n            initializeCentroids() {\n                this.centroids = [];\n                const indices = new Set();\n                while (indices.size < this.k) {\n                    indices.add(Math.floor(Math.random() * this.points.length));\n                }\n                indices.forEach(idx => {\n                    this.centroids.push({...this.points[idx]});\n                });\n            }\n\n            assignPointsToClusters() {\n                this.clusters = Array(this.k).fill().map(() => []);\n                \n                this.points.forEach(point => {\n                    let minDistance = Infinity;\n                    let closestCentroid = 0;\n                    \n                    this.centroids.forEach((centroid, index) => {\n                        const distance = this.calculateDistance(point, centroid);\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            closestCentroid = index;\n                        }\n                    });\n                    \n                    this.clusters[closestCentroid].push(point);\n                });\n            }\n\n            updateCentroids() {\n                let changed = false;\n                \n                this.centroids.forEach((centroid, index) => {\n                    if (this.clusters[index].length === 0) return;\n                    \n                    const newX = this.clusters[index].reduce((sum, p) => sum + p.x, 0) / this.clusters[index].length;\n                    const newY = this.clusters[index].reduce((sum, p) => sum + p.y, 0) / this.clusters[index].length;\n                    \n                    if (Math.abs(newX - centroid.x) > 0.01 || Math.abs(newY - centroid.y) > 0.01) {\n                        changed = true;\n                    }\n                    \n                    centroid.x = newX;\n                    centroid.y = newY;\n                });\n                \n                return changed;\n            }\n\n            calculateDistance(point1, point2) {\n                return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n            }\n\n            step() {\n                if (this.iterations === 0) {\n                    this.initializeCentroids();\n                } else {\n                    const changed = this.updateCentroids();\n                    if (!changed) {\n                        this.converged = true;\n                        return false;\n                    }\n                }\n                \n                this.assignPointsToClusters();\n                this.iterations++;\n                return !this.converged;\n            }\n\n            run(maxIterations = 100) {\n                this.initializeCentroids();\n                \n                for (let i = 0; i < maxIterations; i++) {\n                    this.assignPointsToClusters();\n                    const changed = this.updateCentroids();\n                    \n                    if (!changed) {\n                        this.converged = true;\n                        break;\n                    }\n                }\n                \n                this.iterations = maxIterations;\n            }\n        }\n\n        class KMeansVisualizer {\n            constructor(canvasId) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.kMeans = null;\n                this.colors = [\n                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',\n                    '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43'\n                ];\n                \n                this.setupEventListeners();\n            }\n\n            setupEventListeners() {\n                document.getElementById('kValue').addEventListener('input', (e) => {\n                    document.getElementById('kDisplay').textContent = e.target.value;\n                });\n\n                document.getElementById('pointCount').addEventListener('input', (e) => {\n                    document.getElementById('pointCountDisplay').textContent = e.target.value;\n                });\n\n                document.getElementById('generatePoints').addEventListener('click', () => {\n                    this.generateRandomPoints();\n                });\n\n                document.getElementById('runKMeans').addEventListener('click', () => {\n                    this.runKMeans();\n                });\n\n                document.getElementById('stepKMeans').addEventListener('click', () => {\n                    this.stepKMeans();\n                });\n\n                document.getElementById('reset').addEventListener('click', () => {\n                    this.reset();\n                });\n            }\n\n            generateRandomPoints() {\n                const pointCount = parseInt(document.getElementById('pointCount').value);\n                const k = parseInt(document.getElementById('kValue').value);\n                \n                const points = [];\n                const padding = 50;\n                \n                // Generate points in different regions to create natural clusters\n                const regions = [];\n                for (let i = 0; i < k; i++) {\n                    regions.push({\n                        x: padding + Math.random() * (this.canvas.width - 2 * padding),\n                        y: padding + Math.random() * (this.canvas.height - 2 * padding)\n                    });\n                }\n                \n                for (let i = 0; i < pointCount; i++) {\n                    const region = regions[i % regions.length];\n                    const spread = 80 + Math.random() * 50;\n                    \n                    points.push({\n                        x: region.x + (Math.random() - 0.5) * spread,\n                        y: region.y + (Math.random() - 0.5) * spread\n                    });\n                }\n                \n                this.kMeans = new KMeans(k, points);\n                this.draw();\n                document.getElementById('status').textContent = `Generated ${pointCount} points. Ready to run K-Means.`;\n            }\n\n            runKMeans() {\n                if (!this.kMeans) {\n                    document.getElementById('status').textContent = 'Please generate points first.';\n                    return;\n                }\n                \n                this.kMeans.run();\n                this.draw();\n                this.updateClusterInfo();\n                document.getElementById('status').textContent = \n                    `K-Means completed in ${this.kMeans.iterations} iterations. ${this.kMeans.converged ? 'Converged!' : 'Reached max iterations.'}`;\n            }\n\n            stepKMeans() {\n                if (!this.kMeans) {\n                    document.getElementById('status').textContent = 'Please generate points first.';\n                    return;\n                }\n                \n                const canContinue = this.kMeans.step();\n                this.draw();\n                this.updateClusterInfo();\n                \n                if (this.kMeans.converged) {\n                    document.getElementById('status').textContent = \n                        `K-Means converged after ${this.kMeans.iterations} iterations.`;\n                } else {\n                    document.getElementById('status').textContent = \n                        `Iteration ${this.kMeans.iterations}. Click \"Step Through\" to continue.`;\n                }\n            }\n\n            reset() {\n                this.kMeans = null;\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                document.getElementById('clusterInfo').innerHTML = '';\n                document.getElementById('status').textContent = 'Reset. Click \"Generate Random Points\" to start.';\n            }\n\n            draw() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                if (!this.kMeans) return;\n                \n                // Draw points\n                this.kMeans.points.forEach(point => {\n                    let clusterIndex = -1;\n                    \n                    this.kMeans.clusters.forEach((cluster, index) => {\n                        if (cluster.includes(point)) {\n                            clusterIndex = index;\n                        }\n                    });\n                    \n                    if (clusterIndex !== -1) {\n                        this.ctx.fillStyle = this.colors[clusterIndex % this.colors.length];\n                        this.ctx.beginPath();\n                        this.ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);\n                        this.ctx.fill();\n                    }\n                });\n                \n                // Draw centroids\n                this.kMeans.centroids.forEach((centroid, index) => {\n                    this.ctx.fillStyle = this.colors[index % this.colors.length];\n                    this.ctx.strokeStyle = '#000';\n                    this.ctx.lineWidth = 2;\n                    \n                    this.ctx.beginPath();\n                    this.ctx.arc(centroid.x, centroid.y, 8, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    this.ctx.stroke();\n                    \n                    // Draw centroid label\n                    this.ctx.fillStyle = '#000';\n                    this.ctx.font = '12px Arial';\n                    this.ctx.fillText(`C${index + 1}`, centroid.x + 10, centroid.y - 10);\n                });\n            }\n\n            updateClusterInfo() {\n                if (!this.kMeans) return;\n                \n                const clusterInfo = document.getElementById('clusterInfo');\n                clusterInfo.innerHTML = '';\n                \n                this.kMeans.clusters.forEach((cluster, index) => {\n                    const card = document.createElement('div');\n                    card.className = 'cluster-card';\n                    card.style.backgroundColor = this.colors[index % this.colors.length] + '40'; // Add transparency\n                    card.style.border = `2px solid ${this.colors[index % this.colors.length]}`;\n                    \n                    const centroid = this.kMeans.centroids[index];\n                    card.innerHTML = `\n                        <strong>Cluster ${index + 1}</strong><br>\n                        Points: ${cluster.length}<br>\n                        Centroid: (${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})\n                    `;\n                    \n                    clusterInfo.appendChild(card);\n                });\n            }\n        }\n\n        // Initialize the visualizer when the page loads\n        window.addEventListener('load', () => {\n            new KMeansVisualizer('canvas');\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}