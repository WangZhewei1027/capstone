{
  "id": "98e16c81-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:55.675Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Weighted Graph Explorer — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<style>\n  :root { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; }\n  body { margin: 0; display: flex; height: 100vh; }\n  #left { width: 68%; border-right: 1px solid #ddd; position: relative; }\n  #canvas { width: 100%; height: 100%; display: block; background: linear-gradient(180deg,#fbfcfe,#f7f9fc); cursor: crosshair; }\n  #right { width: 32%; padding: 12px; box-sizing: border-box; overflow: auto; }\n  h2 { margin: 6px 0 12px; font-size: 18px; }\n  .controls { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }\n  button, select, input[type=\"number\"], label { font-size: 13px; }\n  button { padding: 6px 8px; }\n  .mode-btn.active { background: #0366d6; color: white; border: none; }\n  .panel { border: 1px solid #e6e6e6; padding: 8px; margin-bottom: 10px; background: #fff; border-radius: 6px; }\n  small.hint { color: #666; display:block; margin-top:6px; }\n  table { width: 100%; border-collapse: collapse; font-size: 13px; }\n  td, th { border: 1px solid #eee; padding: 6px; text-align: center; }\n  #log { height: 120px; overflow: auto; background: #fafafa; border: 1px solid #eee; padding: 6px; font-size: 13px; }\n  .key { font-weight: 600; }\n  .muted { color: #666; }\n  footer { font-size: 12px; color:#666; margin-top: 6px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <canvas id=\"canvas\"></canvas>\n    <div style=\"position:absolute; left:8px; top:8px; background:rgba(255,255,255,0.9); padding:6px; border-radius:6px; border:1px solid #eee;\">\n      <strong>Tools</strong><br/>\n      Click canvas to add node • Drag nodes to move\n    </div>\n  </div>\n  <div id=\"right\">\n    <h2>Weighted Graph Explorer</h2>\n\n    <div class=\"panel\">\n      <div class=\"controls\">\n        <button id=\"btnAddEdge\" class=\"mode-btn\">Add Edge</button>\n        <button id=\"btnEditEdge\" class=\"mode-btn\">Edit/Delete Edge</button>\n        <button id=\"btnClear\" title=\"Remove all nodes and edges\">Clear</button>\n        <button id=\"btnResetHighlights\" title=\"Clear algorithm highlights\">Reset highlights</button>\n      </div>\n      <small class=\"hint\">Add Edge: click first node then second node, enter weight. Edit/Delete Edge: click an edge to edit or remove it.</small>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Shortest Path (Dijkstra)</strong>\n      <div style=\"display:flex; gap:6px; margin-top:8px; margin-bottom:8px;\">\n        <select id=\"selectStart\"></select>\n        <select id=\"selectEnd\"></select>\n        <button id=\"btnDijkstra\">Compute</button>\n      </div>\n      <small class=\"hint\">Select source and target nodes then hit Compute to highlight shortest path and distances.</small>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Minimum Spanning Tree (Kruskal)</strong>\n      <div style=\"margin-top:8px;\">\n        <button id=\"btnMST\">Compute MST</button>\n      </div>\n      <small class=\"hint\">Computes a minimum spanning tree for the undirected graph. Highlights chosen edges.</small>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Graph Data</strong>\n      <div style=\"margin-top:8px;\">\n        <div><span class=\"key\">Nodes:</span> <span id=\"nodeCount\">0</span></div>\n        <div><span class=\"key\">Edges:</span> <span id=\"edgeCount\">0</span></div>\n      </div>\n      <details style=\"margin-top:8px;\">\n        <summary>Adjacency List</summary>\n        <pre id=\"adjList\" style=\"white-space:pre-wrap; margin-top:8px;\"></pre>\n      </details>\n      <details style=\"margin-top:8px;\">\n        <summary>Adjacency Matrix</summary>\n        <div id=\"adjMatrix\" style=\"margin-top:8px; overflow:auto;\"></div>\n      </details>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Console</strong>\n      <div id=\"log\"></div>\n    </div>\n\n    <footer>\n      Tips: You can rename nodes by editing their label in the code (labels are auto A,B,C...). Weighted undirected edges are supported. Click edges to edit weight or delete them when in Edit mode.\n    </footer>\n  </div>\n\n<script>\n/*\n  Weighted Graph Explorer\n  - Click canvas to add nodes\n  - Drag nodes to reposition\n  - Add Edge mode: click node A then node B, enter weight\n  - Edit/Delete Edge mode: click an edge to edit its weight or delete it\n  - Dijkstra for shortest path between two nodes (highlights path in red)\n  - Kruskal to compute MST (highlights MST edges in green)\n  - Adjacency list and matrix shown on sidebar\n*/\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nfunction resizeCanvas() {\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  draw();\n}\nwindow.addEventListener('resize', resizeCanvas);\n\n// Data\nlet nodes = []; // {id, label, x, y}\nlet edges = []; // {id, a: nodeId, b: nodeId, weight, state}\nlet nodeCounter = 0;\nlet edgeCounter = 0;\n\n// UI state\nlet addEdgeMode = false;\nlet editEdgeMode = false;\nlet addingEdgeFirstNode = null;\nlet draggingNode = null;\nlet dragOffset = {x:0,y:0};\nlet hoveredNode = null;\nlet hoveredEdge = null;\n\nconst R = 18; // node radius\n\n// DOM\nconst btnAddEdge = document.getElementById('btnAddEdge');\nconst btnEditEdge = document.getElementById('btnEditEdge');\nconst btnClear = document.getElementById('btnClear');\nconst btnResetHighlights = document.getElementById('btnResetHighlights');\nconst btnDijkstra = document.getElementById('btnDijkstra');\nconst btnMST = document.getElementById('btnMST');\nconst selectStart = document.getElementById('selectStart');\nconst selectEnd = document.getElementById('selectEnd');\nconst adjListEl = document.getElementById('adjList');\nconst adjMatrixEl = document.getElementById('adjMatrix');\nconst nodeCountEl = document.getElementById('nodeCount');\nconst edgeCountEl = document.getElementById('edgeCount');\nconst logEl = document.getElementById('log');\n\nfunction log(s) {\n  const line = document.createElement('div');\n  line.textContent = s;\n  logEl.appendChild(line);\n  logEl.scrollTop = logEl.scrollHeight;\n}\n\nfunction resetModes() {\n  addEdgeMode = false;\n  editEdgeMode = false;\n  addingEdgeFirstNode = null;\n  btnAddEdge.classList.remove('active');\n  btnEditEdge.classList.remove('active');\n}\n\nbtnAddEdge.addEventListener('click', () => {\n  addEdgeMode = !addEdgeMode;\n  if (addEdgeMode) { editEdgeMode = false; btnAddEdge.classList.add('active'); btnEditEdge.classList.remove('active'); log('Add Edge mode ON. Click two nodes.'); }\n  else { btnAddEdge.classList.remove('active'); addingEdgeFirstNode = null; log('Add Edge mode OFF.'); }\n});\n\nbtnEditEdge.addEventListener('click', () => {\n  editEdgeMode = !editEdgeMode;\n  if (editEdgeMode) { addEdgeMode = false; btnEditEdge.classList.add('active'); btnAddEdge.classList.remove('active'); log('Edit/Delete Edge mode ON. Click an edge to edit or remove.'); }\n  else { btnEditEdge.classList.remove('active'); log('Edit/Delete Edge mode OFF.'); }\n});\n\nbtnClear.addEventListener('click', () => {\n  if (!confirm('Clear entire graph?')) return;\n  nodes = []; edges = []; nodeCounter = 0; edgeCounter = 0;\n  updateUI();\n  draw();\n  log('Graph cleared.');\n});\n\nbtnResetHighlights.addEventListener('click', () => {\n  for (const e of edges) e.state = null;\n  draw();\n  log('Highlights cleared.');\n});\n\nbtnDijkstra.addEventListener('click', () => {\n  const sId = selectStart.value;\n  const tId = selectEnd.value;\n  if (!sId || !tId) { alert('Select start and end nodes.'); return; }\n  if (sId === tId) { alert('Start and end are the same.'); return; }\n  for (const e of edges) e.state = null;\n  const res = dijkstra(sId, tId);\n  if (!res.path) {\n    log('No path found between ' + getNodeLabel(sId) + ' and ' + getNodeLabel(tId));\n    alert('No path found between selected nodes.');\n    draw();\n    return;\n  }\n  for (let i=0;i<res.pathEdges.length;i++) {\n    const eid = res.pathEdges[i];\n    const e = edges.find(x => x.id === eid);\n    if (e) e.state = 'path';\n  }\n  draw();\n  log(`Dijkstra: shortest distance ${res.distance} from ${getNodeLabel(sId)} to ${getNodeLabel(tId)}. Path: ${res.nodePath.map(getNodeLabel).join(' -> ')}`);\n});\n\nbtnMST.addEventListener('click', () => {\n  for (const e of edges) e.state = null;\n  const {mstEdges, totalWeight} = kruskalMST();\n  if (mstEdges.length === 0) {\n    alert('MST could not be formed (graph might be disconnected or empty).');\n    return;\n  }\n  for (const eid of mstEdges) {\n    const e = edges.find(x => x.id === eid);\n    if (e) e.state = 'mst';\n  }\n  draw();\n  log(`Kruskal MST: total weight = ${totalWeight}. Edges: ${mstEdges.join(', ')}`);\n});\n\n// Canvas events\nfunction getMousePos(evt) {\n  const rect = canvas.getBoundingClientRect();\n  return { x: (evt.clientX - rect.left) * (canvas.width / rect.width), y: (evt.clientY - rect.top) * (canvas.height / rect.height) };\n}\n\ncanvas.addEventListener('mousedown', (e) => {\n  const pos = getMousePos(e);\n  const n = findNodeAt(pos.x, pos.y);\n  const edge = findEdgeAt(pos.x, pos.y);\n  if (addEdgeMode) {\n    if (n) {\n      if (!addingEdgeFirstNode) {\n        addingEdgeFirstNode = n.id;\n        log('Selected first node: ' + n.label + '. Now click second node.');\n      } else {\n        const a = addingEdgeFirstNode;\n        const b = n.id;\n        if (a === b) { alert('Cannot create self-loop in this demo.'); addingEdgeFirstNode = null; return; }\n        const existing = edges.find(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));\n        if (existing) { alert('Edge already exists between these nodes.'); addingEdgeFirstNode = null; return; }\n        const w = prompt('Enter weight (positive number):', '1');\n        if (w === null) { addingEdgeFirstNode = null; return; }\n        const weight = parseFloat(w);\n        if (isNaN(weight) || weight <= 0) { alert('Weight must be a positive number.'); addingEdgeFirstNode = null; return; }\n        addEdge(a,b,weight);\n        addingEdgeFirstNode = null;\n        draw();\n      }\n    }\n    return;\n  }\n  if (editEdgeMode) {\n    if (edge) {\n      // open edit/delete dialog\n      const choice = prompt(`Edge ${edge.id} between ${getNodeLabel(edge.a)} - ${getNodeLabel(edge.b)}. Enter new weight to update, or leave blank then type \"DEL\" to delete. Current weight: ${edge.weight}`, String(edge.weight));\n      if (choice === null) return;\n      if (choice.toUpperCase() === 'DEL') {\n        if (confirm('Delete this edge?')) {\n          edges = edges.filter(e => e.id !== edge.id);\n          updateUI();\n          draw();\n          log(`Edge ${edge.id} deleted.`);\n        }\n      } else {\n        const w = parseFloat(choice);\n        if (isNaN(w) || w <= 0) { alert('Invalid weight.'); return; }\n        edge.weight = w;\n        updateUI();\n        draw();\n        log(`Edge ${edge.id} weight set to ${w}.`);\n      }\n    }\n    return;\n  }\n\n  if (n) {\n    // start dragging\n    draggingNode = n;\n    const posn = posCanvasToClient(n);\n    dragOffset.x = pos.x - n.x;\n    dragOffset.y = pos.y - n.y;\n    canvas.style.cursor = 'grabbing';\n  } else if (edge) {\n    // maybe select edge? show info\n    log(`Edge clicked: ${edge.id} (${getNodeLabel(edge.a)} - ${getNodeLabel(edge.b)}), weight=${edge.weight}`);\n  } else {\n    // click empty space -> add node\n    const newId = addNode(pos.x, pos.y);\n    draw();\n    log('Added node ' + getNodeLabel(newId));\n  }\n});\n\ncanvas.addEventListener('mousemove', (e) => {\n  const pos = getMousePos(e);\n  hoveredNode = findNodeAt(pos.x, pos.y);\n  hoveredEdge = findEdgeAt(pos.x, pos.y);\n\n  if (draggingNode) {\n    draggingNode.x = pos.x - dragOffset.x;\n    draggingNode.y = pos.y - dragOffset.y;\n    draw();\n  } else {\n    draw();\n  }\n});\n\ncanvas.addEventListener('mouseup', (e) => {\n  draggingNode = null;\n  canvas.style.cursor = 'crosshair';\n});\n\n// Utilities\nfunction addNode(x,y) {\n  const id = 'n' + (++nodeCounter);\n  const label = String.fromCharCode(64 + nodeCounter) || ('N'+nodeCounter); // A, B, C...\n  nodes.push({ id, label, x, y });\n  updateUI();\n  return id;\n}\n\nfunction addEdge(a,b,weight) {\n  const id = 'e' + (++edgeCounter);\n  edges.push({ id, a, b, weight: +weight, state: null });\n  updateUI();\n  log(`Edge ${id} added between ${getNodeLabel(a)} - ${getNodeLabel(b)} (w=${weight})`);\n}\n\nfunction getNodeLabel(id) {\n  const n = nodes.find(x => x.id === id);\n  return n ? n.label : id;\n}\n\nfunction findNodeAt(x,y) {\n  for (let i=nodes.length-1;i>=0;i--) {\n    const n = nodes[i];\n    const dx = n.x - x, dy = n.y - y;\n    if (dx*dx + dy*dy <= R*R) return n;\n  }\n  return null;\n}\n\nfunction findEdgeAt(x,y) {\n  // find edge whose segment is within threshold distance\n  const threshold = 8;\n  for (let i=0;i<edges.length;i++) {\n    const e = edges[i];\n    const na = nodes.find(n => n.id === e.a);\n    const nb = nodes.find(n => n.id === e.b);\n    if (!na || !nb) continue;\n    const d = pointToSegmentDistance({x,y}, na, nb);\n    if (d <= threshold) return e;\n  }\n  return null;\n}\n\nfunction pointToSegmentDistance(p, a, b) {\n  // p, a, b have x,y\n  const vx = b.x - a.x, vy = b.y - a.y;\n  const wx = p.x - a.x, wy = p.y - a.y;\n  const c = vx*wx + vy*wy;\n  if (c <= 0) return Math.hypot(p.x - a.x, p.y - a.y);\n  const len2 = vx*vx + vy*vy;\n  if (c >= len2) return Math.hypot(p.x - b.x, p.y - b.y);\n  const t = c / len2;\n  const projx = a.x + t*vx, projy = a.y + t*vy;\n  return Math.hypot(p.x - projx, p.y - projy);\n}\n\nfunction draw() {\n  ctx.clearRect(0,0,canvas.width,canvas.height);\n\n  // Edges\n  for (const e of edges) {\n    const a = nodes.find(n => n.id === e.a);\n    const b = nodes.find(n => n.id === e.b);\n    if (!a || !b) continue;\n    // line style\n    let color = '#444';\n    let width = 2;\n    if (e.state === 'path') { color = '#d9534f'; width = 4; }\n    else if (e.state === 'mst') { color = '#2ca02c'; width = 3.5; }\n    // distance from hover highlight\n    if (hoveredEdge && hoveredEdge.id === e.id) { color = '#1f78b4'; width += 2; }\n    ctx.beginPath();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.stroke();\n\n    // weight label near midpoint offset a bit\n    const mx = (a.x + b.x) / 2;\n    const my = (a.y + b.y) / 2;\n    // offset perpendicular for readability\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const len = Math.hypot(dx,dy) || 1;\n    const nx = -dy / len, ny = dx / len;\n    const ox = nx * 12, oy = ny * 12;\n    ctx.fillStyle = '#fff';\n    ctx.strokeStyle = '#888';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.roundRect ? ctx.roundRect(mx-14+ox, my-11+oy, 28, 22, 6) \n                  : roundRect(ctx, mx-14+ox, my-11+oy, 28,22,6);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = '#222';\n    ctx.font = '12px system-ui, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(e.weight, mx+ox, my+oy);\n  }\n\n  // Nodes\n  for (const n of nodes) {\n    // circle\n    ctx.beginPath();\n    ctx.fillStyle = '#f1f5f9';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = (hoveredNode && hoveredNode.id === n.id) ? 3 : 1.8;\n    ctx.arc(n.x, n.y, R, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n\n    // label\n    ctx.fillStyle = '#111';\n    ctx.font = 'bold 14px system-ui, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.label, n.x, n.y);\n  }\n\n  // if adding edge and first selected node, draw temporary line to mouse\n  if (addEdgeMode && addingEdgeFirstNode) {\n    const n = nodes.find(x => x.id === addingEdgeFirstNode);\n    if (n && lastMousePos) {\n      ctx.beginPath();\n      ctx.setLineDash([6,6]);\n      ctx.strokeStyle = '#0366d6';\n      ctx.lineWidth = 2;\n      ctx.moveTo(n.x, n.y);\n      ctx.lineTo(lastMousePos.x, lastMousePos.y);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n  }\n}\n\nfunction roundRect(ctx, x, y, w, h, r) {\n  // fallback for older browsers to draw rounded rect\n  const min = Math.min(w,h)/2;\n  r = Math.min(r, min);\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.arcTo(x + w, y, x + w, y + h, r);\n  ctx.arcTo(x + w, y + h, x, y + h, r);\n  ctx.arcTo(x, y + h, x, y, r);\n  ctx.arcTo(x, y, x + w, y, r);\n  ctx.closePath();\n}\n\n// track mouse for drawing temporary edge\nlet lastMousePos = null;\ncanvas.addEventListener('mousemove', (e) => {\n  lastMousePos = getMousePos(e);\n});\ncanvas.addEventListener('mouseleave', () => { lastMousePos = null; hoveredNode=null; hoveredEdge=null; draw(); });\n\n// helper: convert node position to client (not used here but kept)\nfunction posCanvasToClient(node) {\n  return { x: node.x, y: node.y };\n}\n\n// Update sidebar and selects\nfunction updateUI() {\n  nodeCountEl.textContent = nodes.length;\n  edgeCountEl.textContent = edges.length;\n  // selects\n  selectStart.innerHTML = '';\n  selectEnd.innerHTML = '';\n  for (const n of nodes) {\n    const o1 = document.createElement('option'); o1.value = n.id; o1.textContent = n.label;\n    const o2 = document.createElement('option'); o2.value = n.id; o2.textContent = n.label;\n    selectStart.appendChild(o1); selectEnd.appendChild(o2);\n  }\n  // adjacency list\n  const map = {};\n  for (const n of nodes) map[n.id] = [];\n  for (const e of edges) {\n    if (map[e.a]) map[e.a].push({to:e.b,w:e.weight,id:e.id});\n    if (map[e.b]) map[e.b].push({to:e.a,w:e.weight,id:e.id});\n  }\n  let alText = '';\n  for (const n of nodes) {\n    alText += n.label + ' (' + n.id + '): ';\n    alText += map[n.id].map(x => `${getNodeLabel(x.to)}(${x.w})`).join(', ');\n    alText += '\\n';\n  }\n  adjListEl.textContent = alText.trim();\n\n  // adjacency matrix\n  if (nodes.length === 0) { adjMatrixEl.innerHTML = '<em class=\"muted\">No nodes</em>'; return; }\n  const header = [''].concat(nodes.map(n => n.label));\n  let html = '<table><thead><tr>' + header.map(h => `<th>${h}</th>`).join('') + '</tr></thead><tbody>';\n  for (let i=0;i<nodes.length;i++) {\n    const row = nodes[i];\n    html += `<tr><th>${row.label}</th>`;\n    for (let j=0;j<nodes.length;j++) {\n      if (i === j) html += `<td>0</td>`;\n      else {\n        const e = edges.find(ed => (ed.a===row.id && ed.b===nodes[j].id) || (ed.b===row.id && ed.a===nodes[j].id));\n        html += `<td>${e ? e.weight : '∞'}</td>`;\n      }\n    }\n    html += '</tr>';\n  }\n  html += '</tbody></table>';\n  adjMatrixEl.innerHTML = html;\n}\n\n// Algorithms\nfunction dijkstra(startId, targetId) {\n  // build adjacency\n  const adj = {};\n  for (const n of nodes) adj[n.id] = [];\n  for (const e of edges) {\n    if (!adj[e.a] || !adj[e.b]) continue;\n    adj[e.a].push({to:e.b,w:e.weight,id:e.id});\n    adj[e.b].push({to:e.a,w:e.weight,id:e.id});\n  }\n  // distances\n  const dist = {}; const prev = {}; const prevEdge = {};\n  for (const n of nodes) { dist[n.id]=Infinity; prev[n.id]=null; prevEdge[n.id]=null; }\n  dist[startId] = 0;\n  // simple priority queue via array (ok for small demo)\n  const Q = nodes.map(n=>n.id);\n  while (Q.length>0) {\n    Q.sort((a,b) => dist[a]-dist[b]);\n    const u = Q.shift();\n    if (dist[u] === Infinity) break;\n    if (u === targetId) break;\n    for (const nb of adj[u]) {\n      const alt = dist[u] + nb.w;\n      if (alt < dist[nb.to]) {\n        dist[nb.to] = alt;\n        prev[nb.to] = u;\n        prevEdge[nb.to] = nb.id;\n      }\n    }\n  }\n  if (dist[targetId] === Infinity) return { distance: Infinity, path: null };\n  // reconstruct\n  const path = [];\n  const pathEdges = [];\n  let cur = targetId;\n  while (cur !== null) {\n    path.push(cur);\n    if (prevEdge[cur]) pathEdges.push(prevEdge[cur]);\n    cur = prev[cur];\n  }\n  path.reverse();\n  pathEdges.reverse();\n  return { distance: dist[targetId], nodePath: path, pathEdges };\n}\n\nfunction kruskalMST() {\n  // edges sorted by weight\n  const sorted = edges.slice().sort((a,b) => a.weight - b.weight);\n  // union-find\n  const parent = {};\n  for (const n of nodes) parent[n.id] = n.id;\n  function find(x){ return parent[x]===x ? x : (parent[x]=find(parent[x])); }\n  function union(a,b){ const ra = find(a), rb = find(b); if (ra===rb) return false; parent[rb]=ra; return true; }\n\n  const mstEdges = [];\n  let total = 0;\n  for (const e of sorted) {\n    if (union(e.a, e.b)) {\n      mstEdges.push(e.id);\n      total += e.weight;\n    }\n  }\n  // check connectivity: after unions, all nodes should have same root\n  const roots = new Set(nodes.map(n => find(n.id)));\n  if (roots.size !== 1) {\n    return { mstEdges: [], totalWeight: null };\n  }\n  return { mstEdges, totalWeight: total };\n}\n\n// initialize\n(function initDemo() {\n  // set canvas size to parent size\n  canvas.style.width = '100%';\n  canvas.style.height = '100%';\n  resizeCanvas();\n  // add some sample nodes and edges\n  const padding = 80;\n  const w = canvas.width, h = canvas.height;\n  const samplePositions = [\n    {x: w*0.2, y: h*0.25},\n    {x: w*0.5, y: h*0.18},\n    {x: w*0.8, y: h*0.25},\n    {x: w*0.3, y: h*0.6},\n    {x: w*0.6, y: h*0.6}\n  ];\n  for (const p of samplePositions) addNode(p.x, p.y);\n  // Add edges sample\n  addEdge(nodes[0].id, nodes[1].id, 4);\n  addEdge(nodes[1].id, nodes[2].id, 3);\n  addEdge(nodes[0].id, nodes[3].id, 2.5);\n  addEdge(nodes[3].id, nodes[4].id, 5);\n  addEdge(nodes[1].id, nodes[4].id, 4.2);\n  addEdge(nodes[2].id, nodes[4].id, 6);\n  updateUI();\n  draw();\n  log('Demo graph created. Try dragging nodes, adding edges, running Dijkstra or Kruskal.');\n})();\n\n// polyfill for round rect detection if exists in some contexts\nif (!CanvasRenderingContext2D.prototype.roundRect) {\n  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){ roundRect(this,x,y,w,h,r); this.fill(); };\n}\n\n// Make sure initial resize is correct\nsetTimeout(resizeCanvas, 50);\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}