{
  "id": "d79e0031-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:09.720Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Linear Regression Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    max-width: 800px;\n    line-height: 1.5;\n  }\n  h1 {\n    text-align: center;\n  }\n  #canvasContainer {\n    text-align: center;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    margin-top: 20px;\n  }\n  #instructions {\n    margin-bottom: 20px;\n  }\n  #equation {\n    font-weight: bold;\n    margin-top: 20px;\n    text-align: center;\n  }\n  #resetBtn {\n    margin-top: 10px;\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n    font-size: 1rem;\n  }\n  #pointsCount {\n    margin-top: 10px;\n    text-align: center;\n  }\n  footer {\n    margin-top: 40px;\n    font-size: 0.9rem;\n    color: #555;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n<h1>Interactive Linear Regression Demo</h1>\n<div id=\"instructions\">\n  <p>Click on the canvas below to add data points. The line of best fit (linear regression) will update automatically.</p>\n  <p>The equation of the regression line (y = mx + b) is displayed below.</p>\n</div>\n<div id=\"canvasContainer\">\n  <canvas id=\"scatterplot\" width=\"600\" height=\"400\" aria-label=\"Scatter plot for linear regression\"></canvas>\n</div>\n<div id=\"pointsCount\"></div>\n<div id=\"equation\"></div>\n<button id=\"resetBtn\" aria-label=\"Reset all points and the regression line\">Reset</button>\n\n<script>\n// Setup canvas and drawing context\nconst canvas = document.getElementById(\"scatterplot\");\nconst ctx = canvas.getContext(\"2d\");\n\n// Data points array\nlet points = [];\n\n// Coordinate system margins and axis ranges\nconst margin = 40;\nconst width = canvas.width;\nconst height = canvas.height;\n\n// Axis ranges - we will scale points dynamically based on input\n// But for a cleaner look, let's use a fixed scale that auto-adjusts\n// We'll track min/max for X and Y from data points and add padding\nconst paddingRatio = 0.1;\n\n// Draw axes with ticks and labels\nfunction drawAxes(xMin, xMax, yMin, yMax) {\n  ctx.clearRect(0, 0, width, height);\n\n  ctx.strokeStyle = \"#000\";\n  ctx.lineWidth = 1;\n\n  // Draw X axis\n  ctx.beginPath();\n  ctx.moveTo(margin, height - margin);\n  ctx.lineTo(width - margin, height - margin);\n  ctx.stroke();\n\n  // Draw Y axis\n  ctx.beginPath();\n  ctx.moveTo(margin, height - margin);\n  ctx.lineTo(margin, margin);\n  ctx.stroke();\n\n  ctx.fillStyle = \"#000\";\n  ctx.font = \"12px Arial\";\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"top\";\n\n  // X axis ticks and labels: 5 intervals\n  const xTicks = 5;\n  for (let i = 0; i <= xTicks; i++) {\n    const x = margin + (i / xTicks) * (width - 2 * margin);\n    const val = (xMin + (i / xTicks) * (xMax - xMin)).toFixed(2);\n    ctx.beginPath();\n    ctx.moveTo(x, height - margin);\n    ctx.lineTo(x, height - margin + 6);\n    ctx.stroke();\n    ctx.fillText(val, x, height - margin + 8);\n  }\n\n  // Y axis ticks and labels: 5 intervals\n  const yTicks = 5;\n  ctx.textAlign = \"right\";\n  ctx.textBaseline = \"middle\";\n  for (let i = 0; i <= yTicks; i++) {\n    const y = height - margin - (i / yTicks) * (height - 2 * margin);\n    const val = (yMin + (i / yTicks) * (yMax - yMin)).toFixed(2);\n    ctx.beginPath();\n    ctx.moveTo(margin, y);\n    ctx.lineTo(margin - 6, y);\n    ctx.stroke();\n    ctx.fillText(val, margin - 8, y);\n  }\n\n  // Axis labels\n  ctx.textAlign = \"center\";\n  ctx.fillText(\"X\", width / 2, height - 5);\n  ctx.save();\n  ctx.translate(15, height / 2);\n  ctx.rotate(-Math.PI / 2);\n  ctx.fillText(\"Y\", 0, 0);\n  ctx.restore();\n}\n\n// Convert data point coordinates to canvas pixel coordinates\nfunction toCanvasCoords(xData, yData, xMin, xMax, yMin, yMax) {\n  const x = margin + ((xData - xMin) / (xMax - xMin)) * (width - 2 * margin);\n  const y = height - margin - ((yData - yMin) / (yMax - yMin)) * (height - 2 * margin);\n  return [x, y];\n}\n\n// Convert canvas pixel coordinates to data coordinates\nfunction toDataCoords(xCanvas, yCanvas, xMin, xMax, yMin, yMax) {\n  const xData = xMin + ((xCanvas - margin) / (width - 2 * margin)) * (xMax - xMin);\n  const yData = yMin + ((height - margin - yCanvas) / (height - 2 * margin)) * (yMax - yMin);\n  return [xData, yData];\n}\n\n// Draw points as circles on canvas\nfunction drawPoints(xMin, xMax, yMin, yMax) {\n  ctx.fillStyle = \"#007bff\";\n  points.forEach(p => {\n    const [x, y] = toCanvasCoords(p.x, p.y, xMin, xMax, yMin, yMax);\n    ctx.beginPath();\n    ctx.arc(x, y, 5, 0, 2 * Math.PI);\n    ctx.fill();\n  });\n}\n\n// Calculate linear regression coefficients (slope m and intercept b)\n// Using least squares method\nfunction linearRegression(points) {\n  const n = points.length;\n  if (n < 2) return null; // Need at least two points\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXX = 0;\n\n  points.forEach(p => {\n    sumX += p.x;\n    sumY += p.y;\n    sumXY += p.x * p.y;\n    sumXX += p.x * p.x;\n  });\n\n  const denominator = n * sumXX - sumX * sumX;\n  if (denominator === 0) return null; // Vertical line or all points same x\n\n  const m = (n * sumXY - sumX * sumY) / denominator;\n  const b = (sumY - m * sumX) / n;\n\n  return { m, b };\n}\n\n// Draw regression line on canvas\nfunction drawRegressionLine(m, b, xMin, xMax, yMin, yMax) {\n  if (m === null || b === null) return;\n\n  // For the regression line y = m * x + b\n  // Calculate y for min and max x\n  let y1 = m * xMin + b;\n  let y2 = m * xMax + b;\n\n  // Clip the line to the y axis range:\n  // If y1 or y2 are outside yMin,yMax, recalculate x accordingly\n  // y = m * x + b => x = (y - b) / m\n\n  // Adjust if y1 < yMin\n  if (y1 < yMin) {\n    y1 = yMin;\n    x1Clip = (y1 - b) / m;\n  } else if (y1 > yMax) {\n    y1 = yMax;\n    x1Clip = (y1 - b) / m;\n  } else {\n    x1Clip = xMin;\n  }\n\n  // Adjust if y2 < yMin\n  if (y2 < yMin) {\n    y2 = yMin;\n    x2Clip = (y2 - b) / m;\n  } else if (y2 > yMax) {\n    y2 = yMax;\n    x2Clip = (y2 - b) / m;\n  } else {\n    x2Clip = xMax;\n  }\n\n  // Convert to canvas coords\n  const [x1Canvas, y1Canvas] = toCanvasCoords(x1Clip, y1, xMin, xMax, yMin, yMax);\n  const [x2Canvas, y2Canvas] = toCanvasCoords(x2Clip, y2, xMin, xMax, yMin, yMax);\n\n  ctx.strokeStyle = \"red\";\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(x1Canvas, y1Canvas);\n  ctx.lineTo(x2Canvas, y2Canvas);\n  ctx.stroke();\n}\n\n// Get bounds for the Data Points with some padding\nfunction getBounds(points) {\n  if (points.length === 0) {\n    return {\n      xMin: 0,\n      xMax: 10,\n      yMin: 0,\n      yMax: 10,\n    };\n  }\n  let xMin = points[0].x;\n  let xMax = points[0].x;\n  let yMin = points[0].y;\n  let yMax = points[0].y;\n\n  points.forEach(p => {\n    if (p.x < xMin) xMin = p.x;\n    if (p.x > xMax) xMax = p.x;\n    if (p.y < yMin) yMin = p.y;\n    if (p.y > yMax) yMax = p.y;\n  });\n\n  // If range is too narrow, expand it slightly for better visualization\n  const xRange = xMax - xMin;\n  const yRange = yMax - yMin;\n\n  const xPad = xRange === 0 ? 1 : xRange * paddingRatio;\n  const yPad = yRange === 0 ? 1 : yRange * paddingRatio;\n\n  return {\n    xMin: xMin - xPad,\n    xMax: xMax + xPad,\n    yMin: yMin - yPad,\n    yMax: yMax + yPad,\n  };\n}\n\n// Update the entire plot\nfunction updatePlot() {\n  const { xMin, xMax, yMin, yMax } = getBounds(points);\n  drawAxes(xMin, xMax, yMin, yMax);\n  drawPoints(xMin, xMax, yMin, yMax);\n  const lr = linearRegression(points);\n  if (lr !== null) {\n    drawRegressionLine(lr.m, lr.b, xMin, xMax, yMin, yMax);\n    document.getElementById(\"equation\").textContent =\n      `Regression line: y = ${lr.m.toFixed(3)}x + ${lr.b.toFixed(3)}`;\n  } else {\n    document.getElementById(\"equation\").textContent =\n      \"Add at least two distinct points to compute linear regression.\";\n  }\n  document.getElementById(\"pointsCount\").textContent = `Points: ${points.length}`;\n}\n\n// Handle canvas click to add point\ncanvas.addEventListener(\"click\", e => {\n  const rect = canvas.getBoundingClientRect();\n  const xCanvas = e.clientX - rect.left;\n  const yCanvas = e.clientY - rect.top;\n\n  // Convert canvas coords to data coords\n  const { xMin, xMax, yMin, yMax } = getBounds(points);\n\n  let xData, yData;\n\n  // We want the coordinate system to update sensibly when adding points.\n  // To avoid confusion during adding points, we assume a default axis scale\n  // when there are fewer than two points.\n  if (points.length < 2) {\n    // Default axis range 0-10 for both axes\n    xData = 0 + ((xCanvas - margin) / (width - 2 * margin)) * 10;\n    yData = 0 + ((height - margin - yCanvas) / (height - 2 * margin)) * 10;\n  } else {\n    xData = xMin + ((xCanvas - margin) / (width - 2 * margin)) * (xMax - xMin);\n    yData = yMin + ((height - margin - yCanvas) / (height - 2 * margin)) * (yMax - yMin);\n  }\n\n  points.push({ x: xData, y: yData });\n  updatePlot();\n});\n\n// Reset button functionality\ndocument.getElementById(\"resetBtn\").addEventListener(\"click\", () => {\n  points = [];\n  document.getElementById(\"equation\").textContent =\n    \"Add at least two distinct points to compute linear regression.\";\n  document.getElementById(\"pointsCount\").textContent = \"\";\n  updatePlot();\n});\n\n// Initialize plot on load\nupdatePlot();\n</script>\n<footer>\n  Interactive Linear Regression visualization &mdash; Click to add points and see the best-fit \n  line update in real time.\n</footer>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}