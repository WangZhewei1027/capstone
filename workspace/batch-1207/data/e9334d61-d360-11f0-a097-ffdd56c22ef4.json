{
  "id": "e9334d61-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:16.684Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Adjacency List — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1720;\n      --panel:#0b1320;\n      --accent:#7dd3fc;\n      --muted:#94a3b8;\n      --card:#0b1220;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n      background:linear-gradient(180deg,#071023 0%, #06111a 100%);\n      color:#e6eef8;\n    }\n    .container{\n      display:grid;\n      grid-template-columns:360px 1fr;\n      gap:18px;\n      padding:18px;\n      height:100%;\n      box-sizing:border-box;\n    }\n    .panel{\n      background:linear-gradient(180deg,#061226 0%, #071429 100%);\n      border-radius:10px;\n      padding:14px;\n      box-shadow: 0 8px 30px rgba(6,11,18,0.6);\n      overflow:auto;\n      max-height:calc(100vh - 36px);\n    }\n    h1{\n      margin:6px 0 12px 0;\n      font-size:18px;\n      color:var(--accent);\n    }\n    label{font-size:13px;color:var(--muted);display:block;margin-top:10px}\n    input[type=\"text\"], select, input[type=\"number\"]{\n      width:100%;\n      padding:8px 10px;\n      margin-top:6px;\n      border-radius:6px;\n      border:1px solid rgba(255,255,255,0.06);\n      background: rgba(255,255,255,0.02);\n      color: #e6eef8;\n      box-sizing:border-box;\n    }\n    button{\n      background:linear-gradient(180deg,#0ea5a9 0%,#047481 100%);\n      border:0;\n      color:#022028;\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      margin-top:8px;\n      font-weight:600;\n    }\n    .mutebtn{\n      background:linear-gradient(180deg,#334155,#0f1724);\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.04);\n    }\n    .row{display:flex;gap:8px;align-items:center}\n    .small{font-size:12px;padding:6px 8px;border-radius:6px}\n    .graphPanel{\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      height:100%;\n    }\n    .canvasWrap{\n      background:linear-gradient(180deg,#031126,#031426);\n      border-radius:10px;\n      flex:1;\n      position:relative;\n      overflow:hidden;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    svg{width:100%;height:100%;display:block}\n    .adjList{\n      background:linear-gradient(180deg,#071426,#06101b);\n      border-radius:10px;\n      padding:10px;\n      margin-top:10px;\n      max-height:220px;\n      overflow:auto;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .item{\n      display:flex;\n      justify-content:space-between;\n      gap:8px;\n      align-items:center;\n      padding:6px 6px;\n      border-radius:6px;\n      transition:background .12s;\n    }\n    .item:hover{background:rgba(255,255,255,0.02)}\n    .nodeBadge{\n      background:linear-gradient(90deg,#083049,#055a6b);\n      padding:6px 8px;\n      border-radius:6px;\n      font-weight:700;\n      color:var(--accent);\n      min-width:36px;\n      text-align:center;\n    }\n    .edgeList{font-size:13px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}\n    .chip{\n      background:rgba(255,255,255,0.03);\n      padding:4px 8px;\n      border-radius:999px;\n      font-size:12px;\n      cursor:pointer;\n    }\n    .chip:hover{background:rgba(255,255,255,0.06)}\n    .controlsGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}\n    .footerNote{font-size:12px;color:var(--muted);margin-top:8px}\n    .topRow{display:flex;justify-content:space-between;align-items:center;gap:8px}\n    .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px}\n    .dot{width:12px;height:12px;border-radius:50%}\n    .directed{background:#f97316}\n    .undirected{background:#7dd3fc}\n    .highlight{outline:3px solid rgba(125,211,252,0.14);box-shadow:0 6px 20px rgba(2,6,23,0.6)}\n    .smallbtn{padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);cursor:pointer}\n    .selectWrap{display:flex;gap:8px}\n    .help{font-size:13px;color:var(--muted);margin-top:6px}\n    a.link{color:var(--accent);text-decoration:none}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"panel\" id=\"controls\">\n      <h1>Adjacency List — Interactive</h1>\n      <div class=\"topRow\">\n        <div style=\"font-size:14px;color:#cfeeff\">Graph Editor</div>\n        <div class=\"legend\">\n          <span class=\"dot undirected\" title=\"Undirected\"></span><span style=\"color:var(--muted)\">Undirected</span>\n          <span class=\"dot directed\" style=\"margin-left:6px\" title=\"Directed\"></span><span style=\"color:var(--muted)\">Directed</span>\n        </div>\n      </div>\n\n      <label>Mode</label>\n      <div style=\"display:flex;gap:8px;margin-top:8px\">\n        <button id=\"modeAddNode\" class=\"smallbtn\">Add Node</button>\n        <button id=\"modeAddEdge\" class=\"smallbtn\">Add Edge</button>\n        <button id=\"modeSelect\" class=\"smallbtn\">Select / Drag</button>\n      </div>\n\n      <label style=\"margin-top:12px\">Add node (label)</label>\n      <div class=\"row\">\n        <input id=\"nodeLabel\" type=\"text\" placeholder=\"e.g. A, 1, NodeX\" />\n        <button id=\"addNodeBtn\">Add</button>\n      </div>\n\n      <label style=\"margin-top:12px\">Add edge</label>\n      <div class=\"controlsGrid\">\n        <select id=\"fromSelect\"></select>\n        <select id=\"toSelect\"></select>\n      </div>\n      <div class=\"row\" style=\"margin-top:8px\">\n        <input id=\"weight\" type=\"number\" placeholder=\"weight (optional)\" />\n        <select id=\"edgeType\">\n          <option value=\"undirected\">Undirected</option>\n          <option value=\"directed\">Directed</option>\n        </select>\n      </div>\n      <div class=\"row\">\n        <button id=\"addEdgeBtn\">Add Edge</button>\n        <button id=\"removeEdgeBtn\" class=\"mutebtn\">Remove Selected</button>\n      </div>\n\n      <label style=\"margin-top:12px\">Actions</label>\n      <div class=\"row\">\n        <button id=\"randomizeBtn\" class=\"mutebtn\">Randomize Layout</button>\n        <button id=\"clearBtn\" class=\"mutebtn\">Clear Graph</button>\n      </div>\n      <div style=\"display:flex;gap:8px;margin-top:8px\">\n        <button id=\"sample1\" class=\"smallbtn\">Sample: Triangle</button>\n        <button id=\"sample2\" class=\"smallbtn\">Sample: Directed Chain</button>\n        <button id=\"sample3\" class=\"smallbtn\">Sample: Weighted</button>\n      </div>\n\n      <label style=\"margin-top:12px\">Import / Export</label>\n      <div class=\"row\">\n        <button id=\"exportBtn\">Export JSON</button>\n        <button id=\"importBtn\" class=\"mutebtn\">Import JSON</button>\n      </div>\n      <textarea id=\"ioArea\" style=\"width:100%;height:84px;margin-top:8px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:#e6eef8\"></textarea>\n\n      <div class=\"help\">\n        Tip: Switch to \"Add Edge\" then click two nodes in the canvas to create edges quickly. Click a node to highlight its adjacency list. Export to share or import JSON to load a graph.\n      </div>\n      <div class=\"footerNote\">Representation used: adjacency list — for each node we store its neighbors (and weights). This demo updates both the internal structure and visualization in real time.</div>\n    </div>\n\n    <div class=\"graphPanel\">\n      <div class=\"panel\" style=\"padding:10px;\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700;color:var(--accent)\">Graph Visualization</div>\n          <div style=\"display:flex;gap:8px\">\n            <div id=\"info\" style=\"color:var(--muted)\">Nodes: 0 — Edges: 0</div>\n            <button id=\"helpClear\" class=\"smallbtn mutebtn\">Reset View</button>\n          </div>\n        </div>\n        <div style=\"margin-top:8px;color:var(--muted);font-size:13px\">Click nodes to inspect. Drag nodes to reposition. Use modes to add nodes/edges.</div>\n      </div>\n\n      <div class=\"canvasWrap panel\" id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid slice\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#f97316\" />\n            </marker>\n            <marker id=\"arrowBlue\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#7dd3fc\" />\n            </marker>\n          </defs>\n          <g id=\"edges\"></g>\n          <g id=\"nodes\"></g>\n          <g id=\"labels\"></g>\n        </svg>\n      </div>\n\n      <div class=\"adjList panel\" id=\"adjList\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <div style=\"font-weight:700;color:var(--accent)\">Adjacency List</div>\n          <div style=\"color:var(--muted);font-size:13px\" id=\"adjCount\">0 entries</div>\n        </div>\n        <div id=\"listContent\" style=\"margin-top:8px\"></div>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  Interactive adjacency list demo\n  - Graph stored as adjacency list: Map of node -> array of {to, weight, directed, id}\n  - Visualization: SVG with draggable nodes, lines for edges, arrowheads for directed.\n  - UI: Add/remove nodes and edges, import/export JSON, sample graphs, highlight neighbors.\n*/\n\n// Utilities\nfunction uid(prefix='id'){ return prefix + Math.random().toString(36).substr(2,9); }\nfunction clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n\n// Graph data structure\nclass Graph {\n  constructor(){\n    // nodes: Map label -> {id,label,x,y,fx?,fy?}\n    this.nodes = new Map();\n    // adj: Map label -> Array of edges {id,to,weight,directed}\n    this.adj = new Map();\n  }\n  addNode(label,opts={}){\n    if(!label) return null;\n    if(this.nodes.has(label)) return this.nodes.get(label);\n    const node = {\n      id: uid('n_'),\n      label: String(label),\n      x: opts.x ?? (Math.random()*900 + 150),\n      y: opts.y ?? (Math.random()*400 + 150),\n      vx: 0, vy: 0\n    };\n    this.nodes.set(node.label, node);\n    this.adj.set(node.label, []);\n    return node;\n  }\n  removeNode(label){\n    if(!this.nodes.has(label)) return;\n    this.nodes.delete(label);\n    this.adj.delete(label);\n    // remove edges pointing to label\n    for(const [u,edges] of this.adj.entries()){\n      this.adj.set(u, edges.filter(e => e.to !== label));\n    }\n  }\n  addEdge(from,to,opts={}){\n    if(!this.nodes.has(from) || !this.nodes.has(to)) return null;\n    const directed = !!opts.directed;\n    const weight = (opts.weight==null || opts.weight== '') ? null : Number(opts.weight);\n    const id = uid('e_');\n    const e = {id, to, weight, directed};\n    this.adj.get(from).push(e);\n    if(!directed){\n      // store reverse as well; indicate undirected by having directed=false\n      const e2 = {id: uid('e_'), to: from, weight, directed:false, mirrorOf:id};\n      this.adj.get(to).push(e2);\n    }\n    return e;\n  }\n  removeEdgeById(edgeId){\n    for(const [u,edges] of this.adj.entries()){\n      const newEdges = edges.filter(e => e.id !== edgeId && e.mirrorOf !== edgeId);\n      this.adj.set(u,newEdges);\n    }\n  }\n  getEdgeCount(){\n    let c = 0;\n    for(const edges of this.adj.values()){\n      c += edges.length;\n    }\n    // if undirected edges are stored twice, we can approximate by halving identical mirror entries.\n    // but since we store undirected as two separate entries, we consider each logical undirected edge as 1.\n    // We'll count directed edges as-is and try to deduplicate undirected by checking mirrorOf relationships.\n    // Simpler: count unique ids (for directed edges id present once, undirected have two different ids for the two entries).\n    // We stored original id for one side; we can approximate by counting edges and dividing by 2 when both directions exist.\n    // For UI we display number of entries in adjacency list and also approximate unique edges:\n    return c;\n  }\n  toJSON(){\n    const nodes = [];\n    for(const n of this.nodes.values()){\n      nodes.push({label:n.label,x:n.x,y:n.y});\n    }\n    const edges = [];\n    // We'll export edges by iterating adj and exporting only edges where \"directed\" true OR where a matching reverse exists and include once.\n    const seenPairs = new Set();\n    for(const [u,edgesArr] of this.adj.entries()){\n      for(const e of edgesArr){\n        const a = u, b = e.to;\n        const key = e.directed ? (e.id) : [a,b].sort().join('|');\n        if(seenPairs.has(key)) continue;\n        seenPairs.add(key);\n        edges.push({from:a,to:b,weight:e.weight,directed:!!e.directed});\n      }\n    }\n    return {nodes,edges};\n  }\n  fromJSON(obj){\n    this.nodes.clear(); this.adj.clear();\n    if(!obj) return;\n    (obj.nodes||[]).forEach(n=>this.addNode(n.label,{x:n.x,y:n.y}));\n    (obj.edges||[]).forEach(e=>{\n      this.addEdge(e.from,e.to,{weight:e.weight,directed:!!e.directed});\n    });\n  }\n}\n\n// Instantiate\nconst graph = new Graph();\n\n// UI elements\nconst svg = document.getElementById('svgCanvas');\nconst nodesGroup = document.getElementById('nodes');\nconst edgesGroup = document.getElementById('edges');\nconst labelsGroup = document.getElementById('labels');\n\nconst fromSelect = document.getElementById('fromSelect');\nconst toSelect = document.getElementById('toSelect');\nconst nodeLabelInput = document.getElementById('nodeLabel');\nconst addNodeBtn = document.getElementById('addNodeBtn');\nconst addEdgeBtn = document.getElementById('addEdgeBtn');\nconst removeEdgeBtn = document.getElementById('removeEdgeBtn');\nconst weightInput = document.getElementById('weight');\nconst edgeTypeSel = document.getElementById('edgeType');\nconst listContent = document.getElementById('listContent');\nconst adjCount = document.getElementById('adjCount');\nconst info = document.getElementById('info');\nconst modeAddNode = document.getElementById('modeAddNode');\nconst modeAddEdge = document.getElementById('modeAddEdge');\nconst modeSelect = document.getElementById('modeSelect');\nconst randomizeBtn = document.getElementById('randomizeBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst sample1 = document.getElementById('sample1');\nconst sample2 = document.getElementById('sample2');\nconst sample3 = document.getElementById('sample3');\nconst exportBtn = document.getElementById('exportBtn');\nconst importBtn = document.getElementById('importBtn');\nconst ioArea = document.getElementById('ioArea');\n\n// Modes and selection\nlet mode = 'select'; // select, addNode, addEdge\nlet selectedNode = null;\nlet pendingEdgeFrom = null;\nlet selectedEdgeId = null;\n\n// Dragging\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\n\nfunction setMode(m){\n  mode = m;\n  [modeAddNode, modeAddEdge, modeSelect].forEach(btn => btn.classList.remove('highlight'));\n  if(m==='addNode') modeAddNode.classList.add('highlight');\n  if(m==='addEdge') modeAddEdge.classList.add('highlight');\n  if(m==='select') modeSelect.classList.add('highlight');\n  pendingEdgeFrom = null;\n  updateCursor();\n}\nfunction updateCursor(){\n  const wrap = document.getElementById('canvasWrap');\n  wrap.style.cursor = mode === 'select' ? 'default' : (mode === 'addNode' ? 'crosshair' : 'pointer');\n}\n\nmodeAddNode.addEventListener('click', ()=>setMode('addNode'));\nmodeAddEdge.addEventListener('click', ()=>setMode('addEdge'));\nmodeSelect.addEventListener('click', ()=>setMode('select'));\n\naddNodeBtn.addEventListener('click', ()=>{\n  const label = nodeLabelInput.value.trim() || null;\n  const newNode = graph.addNode(label ?? uid('v'));\n  if(newNode) {\n    nodeLabelInput.value = '';\n    render();\n  }\n});\naddEdgeBtn.addEventListener('click', ()=>{\n  const from = fromSelect.value;\n  const to = toSelect.value;\n  if(!from || !to) return;\n  const directed = edgeTypeSel.value === 'directed';\n  const weight = weightInput.value;\n  graph.addEdge(from,to,{directed,weight});\n  render();\n});\nremoveEdgeBtn.addEventListener('click', ()=>{\n  if(selectedEdgeId){\n    graph.removeEdgeById(selectedEdgeId);\n    selectedEdgeId = null;\n    render();\n  }\n});\n\nrandomizeBtn.addEventListener('click', ()=>{\n  for(const n of graph.nodes.values()){\n    n.x = Math.random()*1000 + 100;\n    n.y = Math.random()*500 + 50;\n  }\n  render();\n});\nclearBtn.addEventListener('click', ()=>{\n  graph.nodes.clear(); graph.adj.clear();\n  selectedNode = null; selectedEdgeId = null;\n  render();\n});\n\nsample1.addEventListener('click', ()=>{\n  graph.nodes.clear(); graph.adj.clear();\n  graph.addNode('A',{x:200,y:240});\n  graph.addNode('B',{x:500,y:120});\n  graph.addNode('C',{x:780,y:320});\n  graph.addEdge('A','B',{directed:false});\n  graph.addEdge('B','C',{directed:false});\n  graph.addEdge('C','A',{directed:false});\n  render();\n});\nsample2.addEventListener('click', ()=>{\n  graph.nodes.clear(); graph.adj.clear();\n  graph.addNode('1',{x:180,y:300});\n  graph.addNode('2',{x:360,y:300});\n  graph.addNode('3',{x:540,y:300});\n  graph.addNode('4',{x:720,y:300});\n  graph.addEdge('1','2',{directed:true});\n  graph.addEdge('2','3',{directed:true});\n  graph.addEdge('3','4',{directed:true});\n  render();\n});\nsample3.addEventListener('click', ()=>{\n  graph.nodes.clear(); graph.adj.clear();\n  graph.addNode('X',{x:200,y:200});\n  graph.addNode('Y',{x:500,y:240});\n  graph.addNode('Z',{x:820,y:200});\n  graph.addEdge('X','Y',{weight:5,directed:false});\n  graph.addEdge('Y','Z',{weight:2,directed:true});\n  render();\n});\n\nexportBtn.addEventListener('click', ()=>{\n  ioArea.value = JSON.stringify(graph.toJSON(),null,2);\n});\nimportBtn.addEventListener('click', ()=>{\n  try{\n    const obj = JSON.parse(ioArea.value);\n    graph.fromJSON(obj);\n    render();\n  }catch(e){\n    alert('Invalid JSON');\n  }\n});\n\ndocument.getElementById('helpClear').addEventListener('click', ()=>{\n  // reset view: randomize positions in center\n  for(const n of graph.nodes.values()){\n    n.x += (Math.random()-0.5)*200;\n    n.y += (Math.random()-0.5)*200;\n  }\n  render();\n});\n\n// SVG Interaction\nsvg.addEventListener('click', (ev)=>{\n  const pt = screenToSvg(ev.clientX, ev.clientY);\n  if(mode === 'addNode'){\n    const label = nodeLabelInput.value.trim() || uid('v');\n    graph.addNode(label,{x:pt.x,y:pt.y});\n    nodeLabelInput.value = '';\n    render();\n  }else if(mode === 'addEdge'){\n    // clicking on blank area resets pending\n    pendingEdgeFrom = null;\n    updateStatus(`Click nodes to create an edge`);\n  }\n});\n\nfunction screenToSvg(cx,cy){\n  const rect = svg.getBoundingClientRect();\n  const vb = svg.viewBox.baseVal;\n  const scaleX = vb.width / rect.width;\n  const scaleY = vb.height / rect.height;\n  return {x: (cx - rect.left) * scaleX + vb.x, y: (cy - rect.top) * scaleY + vb.y};\n}\n\nfunction updateSelectOptions(){\n  const vals = Array.from(graph.nodes.keys());\n  fromSelect.innerHTML = vals.map(v => `<option value=\"${escapeHtml(v)}\">${escapeHtml(v)}</option>`).join('');\n  toSelect.innerHTML = fromSelect.innerHTML;\n}\n\nfunction escapeHtml(s){\n  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;');\n}\n\nfunction updateInfo(){\n  const nodeCount = graph.nodes.size;\n  // We approximate unique edges for display by exporting JSON edges length\n  const uniqueEdges = graph.toJSON().edges.length;\n  info.textContent = `Nodes: ${nodeCount} — Edges: ${uniqueEdges}`;\n  adjCount.textContent = `${graph.nodes.size} entries`;\n}\n\nfunction render(){\n  // Clear groups\n  edgesGroup.innerHTML = '';\n  nodesGroup.innerHTML = '';\n  labelsGroup.innerHTML = '';\n\n  updateSelectOptions();\n  updateInfo();\n\n  // Draw edges\n  const edges = [];\n  for(const [u,arr] of graph.adj.entries()){\n    for(const e of arr){\n      // For undirected edges we stored two entries; only render one visual line in that case:\n      // We'll render edges when either directed OR when u <= e.to to avoid duplicates\n      if(!e.directed && u > e.to) continue;\n      edges.push({from:u,to:e.to,weight:e.weight,directed:e.directed,id:e.id});\n    }\n  }\n  edges.forEach(ed=>{\n    const a = graph.nodes.get(ed.from);\n    const b = graph.nodes.get(ed.to);\n    if(!a || !b) return;\n    // line\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1',a.x);\n    line.setAttribute('y1',a.y);\n    line.setAttribute('x2',b.x);\n    line.setAttribute('y2',b.y);\n    line.setAttribute('stroke', ed.directed ? '#f97316' : '#7dd3fc');\n    line.setAttribute('stroke-width','2.5');\n    if(ed.directed){\n      line.setAttribute('marker-end','url(#arrow)');\n    }else{\n      line.setAttribute('marker-end','url(#arrowBlue)');\n    }\n    line.dataset.edgeId = ed.id;\n    line.style.opacity = 0.85;\n    line.addEventListener('click', (ev)=>{\n      ev.stopPropagation();\n      selectEdge(ed.id);\n    });\n    edgesGroup.appendChild(line);\n\n    // weight label\n    if(ed.weight != null){\n      const midx = (a.x + b.x)/2, midy = (a.y + b.y)/2;\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x',midx);\n      text.setAttribute('y',midy - 8);\n      text.setAttribute('fill','#cbd5e1');\n      text.setAttribute('font-size','12');\n      text.setAttribute('text-anchor','middle');\n      text.textContent = String(ed.weight);\n      labelsGroup.appendChild(text);\n    }\n  });\n\n  // Draw nodes\n  for(const n of graph.nodes.values()){\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform',`translate(${n.x},${n.y})`);\n    g.style.cursor = 'grab';\n    g.dataset.label = n.label;\n\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r',22);\n    circle.setAttribute('fill','url(#grad)'); // not defined; fallback to style\n    circle.setAttribute('stroke','#0ea5a9');\n    circle.setAttribute('stroke-width','1.6');\n    circle.style.fill = 'rgba(255,255,255,0.03)';\n    circle.style.filter = 'drop-shadow(0 6px 16px rgba(2,6,23,0.6))';\n    g.appendChild(circle);\n\n    const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n    text.setAttribute('x',0);\n    text.setAttribute('y',6);\n    text.setAttribute('fill','#bfeffd');\n    text.setAttribute('font-size','12');\n    text.setAttribute('font-weight','700');\n    text.setAttribute('text-anchor','middle');\n    text.textContent = n.label;\n    g.appendChild(text);\n\n    // Attach listeners\n    g.addEventListener('mousedown', (ev)=>{\n      ev.stopPropagation();\n      if(mode === 'addEdge'){\n        if(!pendingEdgeFrom){\n          pendingEdgeFrom = n.label;\n          updateStatus(`Selected source \"${n.label}\". Now click target node.`);\n        }else{\n          const from = pendingEdgeFrom;\n          const to = n.label;\n          const directed = edgeTypeSel.value === 'directed';\n          const weight = weightInput.value;\n          graph.addEdge(from,to,{directed,weight});\n          pendingEdgeFrom = null;\n          render();\n        }\n        return;\n      }\n      if(mode === 'addNode'){\n        // create node at click\n        const p = screenToSvg(ev.clientX,ev.clientY);\n        const label = nodeLabelInput.value.trim() || uid('v');\n        graph.addNode(label,{x:p.x,y:p.y});\n        render();\n        return;\n      }\n      // start dragging / select node\n      setSelectedNode(n.label);\n      dragging = n;\n      const pt = screenToSvg(ev.clientX,ev.clientY);\n      dragOffset.x = n.x - pt.x;\n      dragOffset.y = n.y - pt.y;\n    });\n\n    g.addEventListener('mouseover', ()=>{\n      if(selectedNode === n.label) return;\n      circle.setAttribute('stroke','#38bdf8');\n      circle.setAttribute('stroke-width','2.6');\n    });\n    g.addEventListener('mouseout', ()=>{\n      if(selectedNode === n.label) return;\n      circle.setAttribute('stroke','#0ea5a9');\n      circle.setAttribute('stroke-width','1.6');\n    });\n\n    nodesGroup.appendChild(g);\n  }\n\n  // attach global listeners for drag end\n  window.onmousemove = function(ev){\n    if(!dragging) return;\n    const pt = screenToSvg(ev.clientX,ev.clientY);\n    dragging.x = pt.x + dragOffset.x;\n    dragging.y = pt.y + dragOffset.y;\n    render(); // simple approach: re-render each movement\n  };\n  window.onmouseup = function(){\n    dragging = null;\n  };\n\n  // Build adjacency list UI\n  listContent.innerHTML = '';\n  const sortedNodes = Array.from(graph.nodes.keys()).sort();\n  for(const label of sortedNodes){\n    const div = document.createElement('div');\n    div.className = 'item';\n    const left = document.createElement('div');\n    left.style.display = 'flex';\n    left.style.alignItems = 'center';\n    left.style.gap = '8px';\n\n    const badge = document.createElement('div');\n    badge.className = 'nodeBadge';\n    badge.textContent = label;\n    badge.addEventListener('click', ()=>{ focusOnNode(label); });\n    left.appendChild(badge);\n\n    const edgesWrap = document.createElement('div');\n    edgesWrap.className = 'edgeList';\n    const edges = graph.adj.get(label) || [];\n    if(edges.length === 0){\n      const empty = document.createElement('div');\n      empty.style.color = 'var(--muted)';\n      empty.textContent = '(no neighbors)';\n      edgesWrap.appendChild(empty);\n    }else{\n      edges.forEach(e=>{\n        // show neighbor chip\n        const ch = document.createElement('div');\n        ch.className = 'chip';\n        ch.textContent = `${e.to}${e.weight!=null ? ` (${e.weight})` : ''}${e.directed ? ' →' : ''}`;\n        ch.title = `Click to highlight ${e.to}. Double-click to remove this edge.`;\n        ch.addEventListener('click', ()=>{ focusOnNode(e.to); });\n        ch.addEventListener('dblclick', ()=>{\n          if(confirm(`Remove edge ${label} → ${e.to}?`)){\n            graph.removeEdgeById(e.id);\n            render();\n          }\n        });\n        edgesWrap.appendChild(ch);\n      });\n    }\n\n    left.appendChild(edgesWrap);\n    div.appendChild(left);\n\n    const right = document.createElement('div');\n    const remBtn = document.createElement('button');\n    remBtn.className = 'smallbtn mutebtn';\n    remBtn.textContent = 'Remove';\n    remBtn.addEventListener('click', ()=>{\n      if(confirm(`Remove node \"${label}\" and its edges?`)){\n        graph.removeNode(label);\n        render();\n      }\n    });\n    right.appendChild(remBtn);\n    div.appendChild(right);\n\n    listContent.appendChild(div);\n  }\n\n  // highlight selected node/edge\n  applyHighlights();\n}\n\n// Selection handling\nfunction setSelectedNode(label){\n  selectedNode = label;\n  selectedEdgeId = null;\n  applyHighlights();\n  // scroll adjacency pane to entry\n  const entries = Array.from(listContent.querySelectorAll('.nodeBadge'));\n  for(const b of entries){\n    if(b.textContent === label){\n      b.scrollIntoView({behavior:'smooth',block:'center'});\n      b.classList.add('highlight');\n      setTimeout(()=>b.classList.remove('highlight'),800);\n      break;\n    }\n  }\n}\n\nfunction selectEdge(edgeId){\n  selectedEdgeId = edgeId;\n  selectedNode = null;\n  applyHighlights();\n}\n\nfunction applyHighlights(){\n  // reset\n  for(const c of nodesGroup.querySelectorAll('g')){\n    c.style.opacity = 1;\n    c.querySelector('circle').setAttribute('stroke','#0ea5a9');\n    c.querySelector('circle').setAttribute('stroke-width','1.6');\n  }\n  for(const l of edgesGroup.querySelectorAll('line')){\n    l.style.opacity = 0.85;\n    l.setAttribute('stroke-width','2.5');\n  }\n\n  if(selectedNode){\n    // dim non-neighbors\n    const neighbors = new Set([selectedNode]);\n    for(const e of graph.adj.get(selectedNode) || []) neighbors.add(e.to);\n    for(const g of nodesGroup.querySelectorAll('g')){\n      const lab = g.dataset.label;\n      if(!neighbors.has(lab)) g.style.opacity = 0.25;\n      else {\n        g.style.opacity = 1;\n        if(lab === selectedNode){\n          g.querySelector('circle').setAttribute('stroke','#f97316');\n          g.querySelector('circle').setAttribute('stroke-width','2.6');\n        }else{\n          g.querySelector('circle').setAttribute('stroke','#7dd3fc');\n          g.querySelector('circle').setAttribute('stroke-width','2.2');\n        }\n      }\n    }\n    // highlight incident edges\n    for(const l of edgesGroup.querySelectorAll('line')){\n      const id = l.dataset.edgeId;\n      // find corresponding edge in exported edges\n      // simple heuristic: if either endpoint is selected, highlight\n      // We'll parse coordinates to match endpoints\n      const x1 = Number(l.getAttribute('x1')), y1 = Number(l.getAttribute('y1'));\n      const x2 = Number(l.getAttribute('x2')), y2 = Number(l.getAttribute('y2'));\n      const a = findNodeAt(x1,y1), b = findNodeAt(x2,y2);\n      if(a === selectedNode || b === selectedNode){\n        l.style.opacity = 1;\n        l.setAttribute('stroke-width','3.4');\n      }else{\n        l.style.opacity = 0.12;\n      }\n    }\n  }else if(selectedEdgeId){\n    // highlight this edge\n    for(const l of edgesGroup.querySelectorAll('line')){\n      if(l.dataset.edgeId === selectedEdgeId){\n        l.style.opacity = 1;\n        l.setAttribute('stroke-width','4');\n      }else{\n        l.style.opacity = 0.16;\n      }\n    }\n    // dim nodes not part of edge\n    let ep = null;\n    // locate edge endpoints by id in graph data\n    for(const [u,edges] of graph.adj.entries()){\n      for(const e of edges){\n        if(e.id === selectedEdgeId || e.mirrorOf === selectedEdgeId){\n          ep = {from:u,to:e.to};\n          break;\n        }\n      }\n      if(ep) break;\n    }\n    for(const g of nodesGroup.querySelectorAll('g')){\n      const lab = g.dataset.label;\n      if(ep && (lab === ep.from || lab === ep.to)){\n        g.style.opacity = 1;\n        g.querySelector('circle').setAttribute('stroke','#f97316');\n      }else{\n        g.style.opacity = 0.24;\n      }\n    }\n  }else{\n    // no selection; full view\n    for(const g of nodesGroup.querySelectorAll('g')) g.style.opacity = 1;\n    for(const l of edgesGroup.querySelectorAll('line')) l.style.opacity = 0.85;\n  }\n\n  updateInfo();\n}\n\nfunction findNodeAt(x,y){\n  for(const n of graph.nodes.values()){\n    // match by coordinates\n    if(Math.abs(n.x - x) < 1e-6 && Math.abs(n.y - y) < 1e-6) return n.label;\n  }\n  // fallback: find nearest\n  let nearest=null; let dist=1e9;\n  for(const n of graph.nodes.values()){\n    const d = Math.hypot(n.x-x,n.y-y);\n    if(d < dist){ dist=d; nearest=n.label; }\n  }\n  return nearest;\n}\n\nfunction focusOnNode(label){\n  setSelectedNode(label);\n  // center view by nudging svg viewBox (simple approach: not implemented complex pan; scroll to node element)\n  // highlight will show neighbors\n}\n\n// small status update\nfunction updateStatus(msg){\n  const old = info.textContent;\n  info.textContent = msg;\n  setTimeout(()=>{ if(info.textContent === msg) updateInfo(); }, 2000);\n}\n\n// Initial render\nsetMode('select');\nrender();\n\n// Helpful keyboard shortcuts\nwindow.addEventListener('keydown', (ev)=>{\n  if(ev.key === 'n') setMode('addNode');\n  if(ev.key === 'e') setMode('addEdge');\n  if(ev.key === 'Escape') { setMode('select'); pendingEdgeFrom = null; }\n});\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}