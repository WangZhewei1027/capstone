{
  "id": "e9328a11-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:50.264Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Hash Map",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>HashMap Demo (JavaScript) — Interactive</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color: #111; }\n  h1 { margin: 0 0 8px 0; font-size: 20px; }\n  p.lead { margin: 6px 0 18px 0; color: #444; }\n  .container { display: flex; gap: 18px; flex-wrap: wrap; }\n  .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; background: #fafafa; min-width: 320px; }\n  label { display:block; margin-top: 8px; font-size: 13px; color: #333; }\n  input[type=\"text\"], input[type=\"number\"], select { width: 100%; padding: 8px; margin-top:6px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 6px; }\n  button { margin-top: 8px; padding: 8px 10px; border-radius: 6px; border: 1px solid #888; background: #f5f5f5; cursor: pointer; }\n  button.primary { background: #007bff; color: white; border-color: #005ecb; }\n  .row { display:flex; gap:8px; }\n  .meta { font-size: 13px; color: #333; margin-top:8px; display:flex; gap:12px; flex-wrap:wrap; }\n  .buckets { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }\n  .bucket { width: 120px; min-height:36px; border-radius:6px; border:1px solid #ddd; padding:6px; background:#fff; box-sizing:border-box; }\n  .bucketHeader { font-weight:600; font-size:12px; color:#333; margin-bottom:6px; display:flex; justify-content:space-between; }\n  .entry { padding:6px; border-radius:6px; margin-bottom:6px; font-size:13px; display:flex; justify-content:space-between; gap:8px; background: linear-gradient(180deg,#f7f7ff,#eef1ff); border:1px solid #d0d6ff; }\n  .entry.object { background: linear-gradient(180deg,#fff7e6,#fff1d6); border-color:#ffd6a6; }\n  .entry .key { color:#044; font-weight:600; }\n  .log { height:160px; overflow:auto; border:1px solid #e6e6e6; background:#fff; padding:8px; border-radius:6px; font-family: monospace; font-size:12px; }\n  .small { font-size:12px; color:#555; }\n  pre.code { max-height: 340px; overflow:auto; background:#0b0c0d; color:#cfe9ff; padding:12px; border-radius:6px; font-size:13px; }\n  .controls { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n  .obj-list { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }\n  .obj-pill { padding:6px 8px; border-radius:12px; background:#efefef; border:1px solid #ddd; font-size:13px; display:flex; gap:8px; align-items:center; }\n  .muted { color:#666; font-size:13px; }\n  .badge { display:inline-block; padding:2px 6px; border-radius:8px; background:#eee; font-size:12px; border:1px solid #ddd; }\n  .footer { margin-top:14px; font-size:13px; color:#555; }\n  .grow { flex:1; }\n  .example-btns { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n</style>\n</head>\n<body>\n  <h1>HashMap (JS) — Interactive Demo</h1>\n  <p class=\"lead\">This page implements a simple HashMap in JavaScript (separate chaining) with collision handling, object keys, automatic resize (rehash), and interactive visualization.</p>\n\n  <div class=\"container\">\n    <div class=\"panel\" style=\"flex:1 1 420px;\">\n      <strong>Controls</strong>\n      <label>Key type\n        <select id=\"keyType\">\n          <option value=\"string\">String</option>\n          <option value=\"number\">Number</option>\n          <option value=\"object\">Object (use created object)</option>\n        </select>\n      </label>\n\n      <label id=\"keyInputLabel\">Key (string)\n        <input id=\"keyInput\" type=\"text\" value=\"foo\" />\n      </label>\n\n      <label>Value\n        <input id=\"valueInput\" type=\"text\" value=\"bar\" />\n      </label>\n\n      <div class=\"controls\">\n        <button id=\"putBtn\" class=\"primary\">put(key, value)</button>\n        <button id=\"getBtn\">get(key)</button>\n        <button id=\"hasBtn\">has(key)</button>\n        <button id=\"deleteBtn\">delete(key)</button>\n        <button id=\"clearBtn\">clear()</button>\n      </div>\n\n      <label style=\"margin-top:12px;\">Objects you can use as keys (click to create new object)</label>\n      <div class=\"row\">\n        <button id=\"createObjBtn\">Create Object Key</button>\n        <div class=\"muted grow\" id=\"objCount\">0 objects available</div>\n      </div>\n      <div class=\"obj-list\" id=\"objList\"></div>\n\n      <div class=\"example-btns\">\n        <button id=\"demoCollide\">Demo collisions</button>\n        <button id=\"demoResize\">Demo resize rehash</button>\n        <button id=\"demoRandom\">Random inserts</button>\n      </div>\n\n      <div class=\"meta\">\n        <div class=\"badge\">size: <span id=\"size\">0</span></div>\n        <div class=\"badge\">capacity: <span id=\"capacity\">8</span></div>\n        <div class=\"badge\">loadFactor: <span id=\"load\">0</span></div>\n        <div class=\"badge\">rehashes: <span id=\"rehashes\">0</span></div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <strong>Operation Log</strong>\n        <div class=\"log\" id=\"log\"></div>\n      </div>\n    </div>\n\n    <div class=\"panel\" style=\"flex:1 1 560px;\">\n      <strong>Buckets (visual)</strong>\n      <div class=\"small muted\">Each bucket is an array (separate chaining). Click an entry to remove it.</div>\n      <div class=\"buckets\" id=\"buckets\"></div>\n\n      <div style=\"margin-top:12px;\">\n        <strong>Quick Inspect</strong>\n        <div class=\"small\">Keys: <span id=\"keysSummary\" class=\"muted\"></span></div>\n        <div class=\"small\">Values: <span id=\"valuesSummary\" class=\"muted\"></span></div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <strong>HashMap Implementation (source)</strong>\n        <pre class=\"code\" id=\"codeBlock\"></pre>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  HashMap implementation (separate chaining).\n  - Supports string, number, boolean, undefined, null (treated as primitives)\n  - Supports objects by assigning them a hidden unique id symbol (so object identity is preserved)\n  - Automatic resize: grows when loadFactor > 0.75, shrinks when loadFactor < 0.20 (min capacity 4)\n  - Buckets are arrays of { key, value, hash }\n*/\n\n// Unique symbol to tag objects with an id for hashing\nconst OBJECT_HASH_PROP = Symbol('[[HashMapID]]');\n\nclass HashMap {\n  constructor(initialCapacity = 8) {\n    this._capacity = Math.max(4, initialCapacity | 0);\n    this._buckets = Array.from({length: this._capacity}, () => []);\n    this._size = 0;\n    this._idCounter = 1; // used only for object keys internal ids\n    this._rehashCount = 0;\n  }\n\n  // Public API\n\n  put(key, value) {\n    const hash = this._rawHash(key);\n    const idx = this._indexForHash(hash);\n    const bucket = this._buckets[idx];\n\n    // find existing entry\n    for (let entry of bucket) {\n      if (this._keyEquals(entry.key, key)) {\n        entry.value = value;\n        return; // updated, size unchanged\n      }\n    }\n\n    // new entry\n    bucket.push({key, value, hash});\n    this._size++;\n    this._ensureCapacityAfterInsert();\n  }\n\n  get(key) {\n    const hash = this._rawHash(key);\n    const bucket = this._buckets[this._indexForHash(hash)];\n    for (let entry of bucket) {\n      if (this._keyEquals(entry.key, key)) return entry.value;\n    }\n    return undefined;\n  }\n\n  has(key) {\n    const hash = this._rawHash(key);\n    const bucket = this._buckets[this._indexForHash(hash)];\n    for (let entry of bucket) if (this._keyEquals(entry.key, key)) return true;\n    return false;\n  }\n\n  delete(key) {\n    const hash = this._rawHash(key);\n    const idx = this._indexForHash(hash);\n    const bucket = this._buckets[idx];\n    for (let i=0;i<bucket.length;i++) {\n      if (this._keyEquals(bucket[i].key, key)) {\n        bucket.splice(i,1);\n        this._size--;\n        this._ensureCapacityAfterDelete();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  clear() {\n    this._buckets = Array.from({length: this._capacity}, () => []);\n    this._size = 0;\n  }\n\n  keys() {\n    const out = [];\n    for (let b of this._buckets) for (let e of b) out.push(e.key);\n    return out;\n  }\n\n  values() {\n    const out = [];\n    for (let b of this._buckets) for (let e of b) out.push(e.value);\n    return out;\n  }\n\n  entries() {\n    const out = [];\n    for (let b of this._buckets) for (let e of b) out.push([e.key,e.value]);\n    return out;\n  }\n\n  // Private helpers\n\n  _rawHash(key) {\n    // Normalizes a key to an integer hash (32-bit)\n    const t = typeof key;\n    if (t === 'number') {\n      // handle NaN\n      if (Number.isNaN(key)) return 0;\n      // mix bits for floats/large numbers\n      let x = key | 0;\n      if (x !== key) { // not integer\n        // simple float mixing\n        x = Math.floor(key * 2654435761) | 0;\n      }\n      return this._mixBits(x);\n    }\n    if (t === 'string') {\n      return this._stringHash(key);\n    }\n    if (t === 'boolean') {\n      return key ? 1231 : 1237;\n    }\n    if (key === null || key === undefined) {\n      return key === null ? 3 : 7;\n    }\n    // object (including arrays, functions)\n    return this._objectHash(key);\n  }\n\n  _stringHash(str) {\n    // djb2-ish hashing for strings -> 32-bit int\n    let h = 5381;\n    for (let i = 0; i < str.length; i++) {\n      h = ((h << 5) + h) ^ str.charCodeAt(i); // h * 33 ^ c\n    }\n    return this._mixBits(h);\n  }\n\n  _objectHash(obj) {\n    // If object already has assigned id, use it; otherwise assign one.\n    if (!Object.prototype.hasOwnProperty.call(obj, OBJECT_HASH_PROP)) {\n      // define non-enumerable property\n      Object.defineProperty(obj, OBJECT_HASH_PROP, {\n        value: this._idCounter++,\n        configurable: false,\n        enumerable: false,\n        writable: false\n      });\n    }\n    return this._mixBits(obj[OBJECT_HASH_PROP]);\n  }\n\n  _mixBits(x) {\n    // Mix bits to reduce clustering; keep within 32-bit signed int range\n    x = x | 0;\n    x = ((x >>> 16) ^ x) * 0x45d9f3b;\n    x = ((x >>> 16) ^ x) * 0x45d9f3b;\n    x = (x >>> 16) ^ x;\n    return x | 0;\n  }\n\n  _indexForHash(hash) {\n    // positive modulo\n    const idx = (hash >>> 0) % this._capacity;\n    return idx;\n  }\n\n  _keyEquals(a, b) {\n    // For primitives, === works. For objects we compare their assigned id symbol.\n    if (a === b) return true;\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      return a[OBJECT_HASH_PROP] === b[OBJECT_HASH_PROP];\n    }\n    return false;\n  }\n\n  _ensureCapacityAfterInsert() {\n    const load = this._size / this._capacity;\n    if (load > 0.75) {\n      this._resize(this._capacity * 2);\n    }\n  }\n\n  _ensureCapacityAfterDelete() {\n    const load = this._size / this._capacity;\n    if (this._capacity > 4 && load < 0.20) {\n      this._resize(Math.max(4, Math.floor(this._capacity / 2)));\n    }\n  }\n\n  _resize(newCapacity) {\n    newCapacity = Math.max(4, newCapacity | 0);\n    if (newCapacity === this._capacity) return;\n    const oldBuckets = this._buckets;\n    this._buckets = Array.from({length: newCapacity}, () => []);\n    this._capacity = newCapacity;\n    this._size = 0;\n    for (let b of oldBuckets) {\n      for (let e of b) {\n        // re-insert preserving same key objects and values\n        const idx = this._indexForHash(e.hash);\n        this._buckets[idx].push({key: e.key, value: e.value, hash: e.hash});\n        this._size++;\n      }\n    }\n    this._rehashCount++;\n  }\n\n  // Introspection\n  get size() { return this._size; }\n  get capacity() { return this._capacity; }\n  get loadFactor() { return +(this._size / this._capacity).toFixed(3); }\n  get rehashes() { return this._rehashCount; }\n  // for visualization\n  _rawBuckets() { return this._buckets; }\n}\n\n\n// ---------- Demo UI logic ----------\nconst map = new HashMap(8);\nconst logEl = document.getElementById('log');\nconst bucketsEl = document.getElementById('buckets');\nconst sizeEl = document.getElementById('size');\nconst capEl = document.getElementById('capacity');\nconst loadEl = document.getElementById('load');\nconst rehashEl = document.getElementById('rehashes');\nconst keysSummary = document.getElementById('keysSummary');\nconst valuesSummary = document.getElementById('valuesSummary');\nconst keyType = document.getElementById('keyType');\nconst keyInput = document.getElementById('keyInput');\nconst keyInputLabel = document.getElementById('keyInputLabel');\nconst valueInput = document.getElementById('valueInput');\nconst objListEl = document.getElementById('objList');\nconst objCountEl = document.getElementById('objCount');\nconst codeBlock = document.getElementById('codeBlock');\n\nlet createdObjects = []; // hold references for object keys\n\nfunction appendLog(text) {\n  const now = new Date().toLocaleTimeString();\n  logEl.textContent = `[${now}] ${text}\\n` + logEl.textContent;\n}\n\n// update UI representation of buckets\nfunction render() {\n  // meta\n  sizeEl.textContent = map.size;\n  capEl.textContent = map.capacity;\n  loadEl.textContent = map.loadFactor;\n  rehashEl.textContent = map.rehashes;\n\n  // buckets\n  bucketsEl.innerHTML = '';\n  const buckets = map._rawBuckets();\n  for (let i = 0; i < buckets.length; i++) {\n    const bucket = document.createElement('div');\n    bucket.className = 'bucket';\n    const header = document.createElement('div');\n    header.className = 'bucketHeader';\n    header.innerHTML = `#${i} <span class=\"small muted\">(${buckets[i].length})</span>`;\n    bucket.appendChild(header);\n\n    if (buckets[i].length === 0) {\n      const empty = document.createElement('div');\n      empty.className = 'small muted';\n      empty.textContent = 'empty';\n      bucket.appendChild(empty);\n    } else {\n      for (let entry of buckets[i]) {\n        const e = document.createElement('div');\n        e.className = 'entry' + (typeof entry.key === 'object' ? ' object' : '');\n        e.title = 'hash: ' + entry.hash;\n        const k = document.createElement('div');\n        k.className = 'key';\n        k.textContent = prettyKey(entry.key);\n        const v = document.createElement('div');\n        v.className = 'val';\n        v.textContent = String(entry.value);\n        e.appendChild(k);\n        e.appendChild(v);\n        // clicking entry deletes it\n        e.addEventListener('click', () => {\n          const ok = confirm('Delete entry with key ' + prettyKey(entry.key) + '?');\n          if (ok) {\n            const removed = map.delete(entry.key);\n            appendLog('delete(' + prettyKey(entry.key) + ') => ' + removed);\n            render();\n          }\n        });\n        bucket.appendChild(e);\n      }\n    }\n    bucketsEl.appendChild(bucket);\n  }\n\n  // summaries\n  keysSummary.textContent = map.keys().map(k => prettyKey(k)).slice(0,10).join(', ') || '—';\n  valuesSummary.textContent = map.values().slice(0,10).map(v => String(v)).join(', ') || '—';\n\n  // code view\n  codeBlock.textContent = HashMap.toString(); // show source of class (approx)\n}\n\n// pretty key representation\nfunction prettyKey(k) {\n  if (typeof k === 'string') return '\"' + k + '\"';\n  if (typeof k === 'number') return String(k);\n  if (k === null) return 'null';\n  if (k === undefined) return 'undefined';\n  if (typeof k === 'object') {\n    return 'Object#' + (k[OBJECT_HASH_PROP] || '?');\n  }\n  return String(k);\n}\n\n// UI wired actions\ndocument.getElementById('putBtn').addEventListener('click', () => {\n  const key = readKeyInput();\n  const value = valueInput.value;\n  map.put(key, value);\n  appendLog('put(' + prettyKey(key) + ', \"' + value + '\")');\n  render();\n});\n\ndocument.getElementById('getBtn').addEventListener('click', () => {\n  const key = readKeyInput();\n  const v = map.get(key);\n  appendLog('get(' + prettyKey(key) + ') => ' + (v === undefined ? 'undefined' : JSON.stringify(v)));\n  render();\n});\n\ndocument.getElementById('hasBtn').addEventListener('click', () => {\n  const key = readKeyInput();\n  const h = map.has(key);\n  appendLog('has(' + prettyKey(key) + ') => ' + h);\n  render();\n});\n\ndocument.getElementById('deleteBtn').addEventListener('click', () => {\n  const key = readKeyInput();\n  const d = map.delete(key);\n  appendLog('delete(' + prettyKey(key) + ') => ' + d);\n  render();\n});\n\ndocument.getElementById('clearBtn').addEventListener('click', () => {\n  map.clear();\n  appendLog('clear()');\n  render();\n});\n\nkeyType.addEventListener('change', () => {\n  const t = keyType.value;\n  if (t === 'string') {\n    keyInputLabel.textContent = 'Key (string)';\n    keyInput.type = 'text';\n    keyInput.value = 'foo';\n  } else if (t === 'number') {\n    keyInputLabel.textContent = 'Key (number)';\n    keyInput.type = 'number';\n    keyInput.value = '42';\n  } else {\n    keyInputLabel.textContent = 'Choose an object key from list below';\n    keyInput.type = 'text';\n    keyInput.value = '';\n  }\n});\n\ndocument.getElementById('createObjBtn').addEventListener('click', () => {\n  // create a random object with a display property\n  const obj = { createdAt: new Date().toLocaleTimeString(), seed: Math.floor(Math.random() * 10000) };\n  // attach an accessor (this will assign the object's hidden id when we inspect it internally in map)\n  createdObjects.push(obj);\n  refreshObjList();\n  appendLog('Created new object for use as key: ' + JSON.stringify(obj));\n});\n\nfunction refreshObjList() {\n  objListEl.innerHTML = '';\n  objCountEl.textContent = createdObjects.length + ' objects available';\n  createdObjects.forEach((o, i) => {\n    const pill = document.createElement('div');\n    pill.className = 'obj-pill';\n    pill.textContent = 'Object[' + i + ']';\n    const btnSet = document.createElement('button'); btnSet.textContent = 'use'; btnSet.style.padding='4px 6px';\n    const btnInfo = document.createElement('button'); btnInfo.textContent = 'inspect'; btnInfo.style.padding='4px 6px';\n    pill.appendChild(btnSet); pill.appendChild(btnInfo);\n    btnSet.addEventListener('click', () => {\n      // set selection to this object\n      keyType.value = 'object';\n      keyType.dispatchEvent(new Event('change'));\n      // store the index in input field so readKeyInput can find it\n      keyInput.value = String(i);\n      appendLog('Selected object['+i+'] as key');\n    });\n    btnInfo.addEventListener('click', () => {\n      alert('Object['+i+'] = ' + JSON.stringify(o) + '\\\\n(internal id: ' + (o[OBJECT_HASH_PROP]||'(not set)') + ')');\n    });\n    objListEl.appendChild(pill);\n  });\n}\n\nfunction readKeyInput() {\n  const t = keyType.value;\n  if (t === 'string') return String(keyInput.value);\n  if (t === 'number') return Number(keyInput.value);\n  if (t === 'object') {\n    const idx = Number(keyInput.value);\n    if (!Number.isFinite(idx) || idx < 0 || idx >= createdObjects.length) {\n      alert('Invalid object index. Create objects and choose one.');\n      throw new Error('invalid object index');\n    }\n    return createdObjects[idx];\n  }\n  return keyInput.value;\n}\n\n// Example demos\ndocument.getElementById('demoCollide').addEventListener('click', () => {\n  // Create several strings that intentionally collide for small table sizes by manipulating characters.\n  // We will reset map to small capacity to force collisions.\n  map._resize(4);\n  map.clear();\n  appendLog('Demo collisions: resized to capacity 4 and inserting keys that often collide.');\n  const keys = ['a','b','c','d','e','f','g','h','aa','bb','cc','ab','ba'];\n  keys.forEach((k,i) => {\n    map.put(k, 'val'+i);\n  });\n  render();\n});\n\ndocument.getElementById('demoResize').addEventListener('click', () => {\n  map._resize(4);\n  map.clear();\n  appendLog('Demo resize: start with capacity 4 and insert many entries to trigger grow.');\n  for (let i=0;i<30;i++) map.put('k'+i, 'v'+i);\n  appendLog('Inserted 30 entries; map should have resized multiple times.');\n  render();\n});\n\ndocument.getElementById('demoRandom').addEventListener('click', () => {\n  map._resize(8);\n  map.clear();\n  appendLog('Random demo: inserting 12 random entries (mix of numbers/strings/objects).');\n  // create some objects too\n  for (let i=0;i<4;i++) {\n    const o = { seed: Math.random(), i };\n    createdObjects.push(o);\n  }\n  refreshObjList();\n  for (let i=0;i<12;i++) {\n    const r = Math.random();\n    if (r < 0.33) map.put('s' + (Math.floor(Math.random()*100)), 'str'+i);\n    else if (r < 0.66) map.put(i, 'num' + i);\n    else {\n      const o = createdObjects[Math.floor(Math.random()*createdObjects.length)];\n      map.put(o, 'obj'+i);\n    }\n  }\n  render();\n});\n\n// Clicking entries removes them (wired in render)\n\n// initialize\nrender();\nappendLog('HashMap initialized.');\n\n// Display HashMap code exemplar (trimmed, show essential methods)\n(function showCodeText() {\n  const code = `// HashMap (separate chaining) - essential methods\nclass HashMap {\n  constructor(initialCapacity = 8) { ... }\n\n  put(key, value) {\n    const hash = this._rawHash(key);\n    const idx = this._indexForHash(hash);\n    const bucket = this._buckets[idx];\n    for (let entry of bucket) {\n      if (this._keyEquals(entry.key, key)) { entry.value = value; return; }\n    }\n    bucket.push({key, value, hash});\n    this._size++;\n    if (this._size / this._capacity > 0.75) this._resize(this._capacity * 2);\n  }\n\n  get(key) { ... } // find bucket by hash and compare keys\n  delete(key) { ... } // remove from bucket, possibly shrink\n  // hashing: numbers, strings (djb2-like), and objects (assign hidden id)\n}`;\n  codeBlock.textContent = code;\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Map"
    }
  ],
  "topic": "Hash Map",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}