{
  "id": "e932d830-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:12.998Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3dd6a0;\n      --muted:#93a4bf;\n      --danger:#ff6b6b;\n      --card:#0b1624;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071427 0%, #071f33 100%);color:#e6f0ff}\n    .app{\n      display:flex;\n      flex-direction:column;\n      min-height:100vh;\n      padding:18px;\n      gap:14px;\n      box-sizing:border-box;\n    }\n    header{\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    h1{font-size:18px;margin:0}\n    .controls{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      align-items:center;\n      background:var(--panel);\n      padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,0.5);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .controls .left, .controls .right{display:flex;gap:8px;align-items:center;}\n    input[type=\"number\"]{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);outline:none}\n    button{\n      padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);color:#dff5ea;cursor:pointer;\n    }\n    button.secondary{background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);color:var(--muted)}\n    button.danger{background:linear-gradient(180deg,rgba(255,0,0,0.06),transparent);color:var(--danger)}\n    .panel{\n      display:flex;gap:12px;\n    }\n    .leftPanel{\n      flex:1;\n      min-height:420px;\n      background:var(--card);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);\n      box-shadow:0 8px 30px rgba(2,6,23,0.6);\n    }\n    #canvasWrap{width:100%;height:520px;overflow:hidden;border-radius:8px;background:linear-gradient(180deg,rgba(7,26,46,0.2),rgba(6,16,30,0.2));display:flex;align-items:center;justify-content:center}\n    svg{width:100%;height:100%}\n    .rightPanel{\n      width:360px;min-width:260px;\n      background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);\n    }\n    .info{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:8px}\n    .info .row{display:flex;justify-content:space-between;gap:8px;align-items:center}\n    .log{height:240px;overflow:auto;background:var(--glass);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;color:#cfeee0}\n    .legend{display:flex;gap:8px;flex-wrap:wrap}\n    .legend .item{display:flex;gap:6px;align-items:center;color:var(--muted);font-size:13px}\n    .node-svg{transition:transform 160ms ease}\n    .small{font-size:13px;color:var(--muted)}\n    footer{margin-top:auto;color:var(--muted);font-size:12px;display:flex;justify-content:space-between;align-items:center}\n    .controls .speed{display:flex;align-items:center;gap:8px}\n    .speed input[type=\"range\"]{width:120px}\n    .traversalButtons{display:flex;gap:6px;flex-wrap:wrap}\n    @media (max-width:900px){\n      .panel{flex-direction:column}\n      .rightPanel{width:100%}\n      #canvasWrap{height:420px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <h1>Binary Search Tree (BST) Visualizer</h1>\n      <div style=\"color:var(--muted);font-size:13px\">Insert, delete, search and animate traversals</div>\n    </header>\n\n    <div class=\"controls\">\n      <div class=\"left\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"Value (integer)\" />\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"deleteBtn\" class=\"danger\">Delete</button>\n        <button id=\"searchBtn\" class=\"secondary\">Search</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        <button id=\"randomBtn\" class=\"secondary\">Randomize</button>\n      </div>\n\n      <div class=\"right\" style=\"margin-left:auto;align-items:center\">\n        <div class=\"speed small\" title=\"Animation speed\">\n          <label style=\"color:var(--muted);font-size:13px\">Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"0\" max=\"1000\" value=\"320\" />\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"leftPanel\">\n        <div id=\"canvasWrap\">\n          <svg id=\"svgCanvas\" viewBox=\"0 0 1200 520\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        </div>\n      </div>\n\n      <div class=\"rightPanel\">\n        <div class=\"info\">\n          <div class=\"row\"><div>Nodes</div><div id=\"nodeCount\">0</div></div>\n          <div class=\"row\"><div>Height</div><div id=\"height\">0</div></div>\n          <div class=\"row\"><div>Min / Max</div><div id=\"minmax\">—</div></div>\n          <div class=\"row\"><div>Time complexities</div>\n            <div style=\"text-align:right;font-size:12px;color:var(--muted)\">\n              Search/Insert/Delete:<br/>\n              Avg: O(log n) · Worst: O(n)\n            </div>\n          </div>\n        </div>\n\n        <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.02);margin:10px 0\"/>\n\n        <div style=\"display:flex;flex-direction:column;gap:8px\">\n          <div class=\"traversalButtons\">\n            <button id=\"inorderBtn\" class=\"secondary\">In-order</button>\n            <button id=\"preorderBtn\" class=\"secondary\">Pre-order</button>\n            <button id=\"postorderBtn\" class=\"secondary\">Post-order</button>\n            <button id=\"levelBtn\" class=\"secondary\">Level-order</button>\n            <button id=\"stepTraversal\" class=\"secondary\">Step traversal</button>\n          </div>\n\n          <div style=\"display:flex;gap:8px;align-items:center\">\n            <button id=\"pauseBtn\" class=\"secondary\">Pause</button>\n            <button id=\"resumeBtn\" class=\"secondary\">Resume</button>\n          </div>\n\n          <div class=\"small\" style=\"color:var(--muted)\">Legend</div>\n          <div class=\"legend\">\n            <div class=\"item\"><svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#1e90b0\"/></svg> Visited</div>\n            <div class=\"item\"><svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#3dd6a0\"/></svg> Inserted / Found</div>\n            <div class=\"item\"><svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#ff6b6b\"/></svg> Deleted / Removing</div>\n          </div>\n        </div>\n\n        <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.02);margin:10px 0\"/>\n\n        <div class=\"small\" style=\"color:var(--muted)\">Console</div>\n        <div id=\"log\" class=\"log\"></div>\n      </div>\n    </div>\n\n    <footer>\n      <div>Tip: Use \"Randomize\" to insert several nodes quickly. Duplicate values are ignored.</div>\n      <div style=\"opacity:0.8\">Built with plain JavaScript • Visualization only</div>\n    </footer>\n  </div>\n\n<script>\n/*\n  Binary Search Tree Visualizer\n  - Insert/delete/search\n  - Traversals with animation\n  - SVG rendering\n  - Simple layout: root centered, spread halves per level\n*/\n\n// Model: BST Node\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    // UI properties\n    this.x = 0;\n    this.y = 0;\n    this.id = Node._id++;\n  }\n}\nNode._id = 1;\n\n// BST class with methods\nclass BST {\n  constructor() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  insert(value) {\n    if (this.root === null) {\n      this.root = new Node(value);\n      this.size++;\n      return { inserted: this.root, path: [this.root] };\n    }\n    let node = this.root;\n    const path = [];\n    while (node) {\n      path.push(node);\n      if (value === node.value) return { inserted: null, path };\n      if (value < node.value) {\n        if (!node.left) {\n          node.left = new Node(value);\n          this.size++;\n          path.push(node.left);\n          return { inserted: node.left, path };\n        } else node = node.left;\n      } else {\n        if (!node.right) {\n          node.right = new Node(value);\n          this.size++;\n          path.push(node.right);\n          return { inserted: node.right, path };\n        } else node = node.right;\n      }\n    }\n  }\n\n  search(value) {\n    let node = this.root;\n    const path = [];\n    while (node) {\n      path.push(node);\n      if (value === node.value) return { found: node, path };\n      node = value < node.value ? node.left : node.right;\n    }\n    return { found: null, path };\n  }\n\n  // helper to find min node and parent from a given node\n  _minNodeWithParent(node, parent=null) {\n    let p = parent;\n    let cur = node;\n    while (cur.left) {\n      p = cur;\n      cur = cur.left;\n    }\n    return { minNode: cur, parent: p };\n  }\n\n  delete(value) {\n    // returns {deletedNode, path}\n    let node = this.root;\n    let parent = null;\n    const path = [];\n    while (node && node.value !== value) {\n      path.push(node);\n      parent = node;\n      node = value < node.value ? node.left : node.right;\n    }\n    if (!node) return { deletedNode: null, path };\n    path.push(node);\n\n    // Case 1: no children or one child, case 2: two children\n    if (!node.left || !node.right) {\n      const child = node.left ? node.left : node.right;\n      if (!parent) {\n        // deleting root\n        this.root = child;\n      } else if (parent.left === node) {\n        parent.left = child;\n      } else parent.right = child;\n      this.size--;\n      return { deletedNode: node, path };\n    } else {\n      // two children: find inorder successor (min in right subtree)\n      const { minNode: succ, parent: succParent } = this._minNodeWithParent(node.right, node);\n      // We'll copy successor's value into node, then delete successor node\n      const succPath = [];\n      // build path from root to successor for animation clarity\n      let cur = this.root;\n      while (cur && cur !== succ) {\n        succPath.push(cur);\n        cur = (succ.value < cur.value) ? cur.left : cur.right;\n      }\n      succPath.push(succ);\n      // Replace value\n      const oldValue = node.value;\n      node.value = succ.value;\n      // Now delete successor which has at most one child (right child)\n      const succChild = succ.right;\n      if (succParent.left === succ) succParent.left = succChild;\n      else succParent.right = succChild;\n      this.size--;\n      // return node as the \"deleted\" (conceptually we removed succ and moved its value)\n      return { deletedNode: succ, path: path.concat(succPath) };\n    }\n  }\n\n  // Traversals returning arrays\n  inorder(node=this.root, arr=[]) {\n    if (!node) return arr;\n    this.inorder(node.left, arr);\n    arr.push(node);\n    this.inorder(node.right, arr);\n    return arr;\n  }\n  preorder(node=this.root, arr=[]) {\n    if (!node) return arr;\n    arr.push(node);\n    this.preorder(node.left, arr);\n    this.preorder(node.right, arr);\n    return arr;\n  }\n  postorder(node=this.root, arr=[]) {\n    if (!node) return arr;\n    this.postorder(node.left, arr);\n    this.postorder(node.right, arr);\n    arr.push(node);\n    return arr;\n  }\n  levelOrder() {\n    const arr = [];\n    if (!this.root) return arr;\n    const q = [this.root];\n    while (q.length) {\n      const n = q.shift();\n      arr.push(n);\n      if (n.left) q.push(n.left);\n      if (n.right) q.push(n.right);\n    }\n    return arr;\n  }\n\n  height(node=this.root) {\n    if (!node) return 0;\n    return 1 + Math.max(this.height(node.left), this.height(node.right));\n  }\n\n  min(node=this.root) {\n    if (!node) return null;\n    while (node.left) node=node.left;\n    return node.value;\n  }\n  max(node=this.root) {\n    if (!node) return null;\n    while (node.right) node=node.right;\n    return node.value;\n  }\n}\n\n// UI & Rendering\nconst svg = document.getElementById('svgCanvas');\nconst logEl = document.getElementById('log');\nconst nodeCountEl = document.getElementById('nodeCount');\nconst heightEl = document.getElementById('height');\nconst minmaxEl = document.getElementById('minmax');\nconst valueInput = document.getElementById('valueInput');\nconst speedRange = document.getElementById('speedRange');\n\nlet tree = new BST();\nlet running = false;\nlet paused = false;\nlet animationDelay = 320; // ms\nlet pendingTimeouts = [];\n\n// utility logging\nfunction log(...args){\n  const time = new Date().toLocaleTimeString();\n  const text = args.map(a=> (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');\n  logEl.innerHTML = `<div style=\"margin-bottom:6px\">[${time}] ${text}</div>` + logEl.innerHTML;\n}\n\n// cleanup timeouts\nfunction clearPending(){\n  pendingTimeouts.forEach(t => clearTimeout(t));\n  pendingTimeouts = [];\n  running = false;\n  paused = false;\n}\n\nfunction schedule(fn, delay){\n  const t = setTimeout(()=>{\n    fn();\n    // remove from pending\n    pendingTimeouts = pendingTimeouts.filter(x=>x!==t);\n  }, delay);\n  pendingTimeouts.push(t);\n  return t;\n}\n\n// Rendering functions\nfunction clearSVG(){\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\nfunction computeLayout() {\n  // Set positions: root centered, spread halves each level.\n  const width = 1200;\n  const levelHeight = 86;\n  function place(node, x, y, spread) {\n    if (!node) return;\n    node.x = x;\n    node.y = y;\n    if (node.left) place(node.left, x - spread, y + levelHeight, spread/1.9);\n    if (node.right) place(node.right, x + spread, y + levelHeight, spread/1.9);\n  }\n  if (tree.root) {\n    place(tree.root, width/2, 60, width/4);\n  }\n}\n\nfunction drawTree(highlights = {}) {\n  // highlights: visited: Set(ids), active: Set(ids), removed: Set(ids)\n  clearSVG();\n  computeLayout();\n  const width = 1200, height = 520;\n\n  // draw edges first\n  function drawEdges(node) {\n    if (!node) return;\n    if (node.left) {\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('x1', node.x);\n      line.setAttribute('y1', node.y+20);\n      line.setAttribute('x2', node.left.x);\n      line.setAttribute('y2', node.left.y-20);\n      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      line.setAttribute('stroke-width','2');\n      svg.appendChild(line);\n    }\n    if (node.right) {\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('x1', node.x);\n      line.setAttribute('y1', node.y+20);\n      line.setAttribute('x2', node.right.x);\n      line.setAttribute('y2', node.right.y-20);\n      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      line.setAttribute('stroke-width','2');\n      svg.appendChild(line);\n    }\n    drawEdges(node.left);\n    drawEdges(node.right);\n  }\n  drawEdges(tree.root);\n\n  // draw nodes\n  function drawNode(node) {\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${node.x},${node.y})`);\n    g.classList.add('node-svg');\n    // background circle\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r', 20);\n    circle.setAttribute('cx', 0);\n    circle.setAttribute('cy', 0);\n    circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n    circle.setAttribute('stroke-width', 1.6);\n\n    // decide fill based on highlights\n    const fill = highlights.removed && highlights.removed.has(node.id) ? '#ff6b6b'\n                : highlights.inserted && highlights.inserted.has(node.id) ? '#3dd6a0'\n                : highlights.visited && highlights.visited.has(node.id) ? '#1e90b0'\n                : 'rgba(255,255,255,0.02)';\n\n    circle.setAttribute('fill', fill);\n\n    // text\n    const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n    text.setAttribute('x',0);\n    text.setAttribute('y',6);\n    text.setAttribute('text-anchor','middle');\n    text.setAttribute('font-size','13');\n    text.setAttribute('font-family','monospace');\n    text.setAttribute('fill', fill === 'rgba(255,255,255,0.02)' ? '#cfeee0' : '#072021');\n    text.textContent = node.value;\n\n    g.appendChild(circle);\n    g.appendChild(text);\n\n    svg.appendChild(g);\n\n    if (node.left) drawNode(node.left);\n    if (node.right) drawNode(node.right);\n  }\n\n  drawNode(tree.root);\n\n  updateStats();\n}\n\nfunction updateStats() {\n  nodeCountEl.textContent = tree.size;\n  heightEl.textContent = tree.height();\n  const mn = tree.min(); const mx = tree.max();\n  minmaxEl.textContent = (mn===null ? '—' : mn) + (mn===null ? '' : '  /  ' + mx);\n}\n\n// Controls and interactions\ndocument.getElementById('insertBtn').addEventListener('click', ()=>{\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) {\n    log('Enter an integer value to insert.');\n    return;\n  }\n  clearPending();\n  animateInsert(v);\n});\n\ndocument.getElementById('deleteBtn').addEventListener('click', ()=>{\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) {\n    log('Enter an integer value to delete.');\n    return;\n  }\n  clearPending();\n  animateDelete(v);\n});\n\ndocument.getElementById('searchBtn').addEventListener('click', ()=>{\n  const v = parseInt(valueInput.value);\n  if (Number.isNaN(v)) {\n    log('Enter an integer value to search.');\n    return;\n  }\n  clearPending();\n  animateSearch(v);\n});\n\ndocument.getElementById('clearBtn').addEventListener('click', ()=>{\n  clearPending();\n  tree = new BST();\n  Node._id = 1;\n  drawTree();\n  log('Tree cleared.');\n});\n\ndocument.getElementById('randomBtn').addEventListener('click', ()=>{\n  clearPending();\n  // generate random set of unique ints\n  const count = 8 + Math.floor(Math.random()*8);\n  const vals = new Set();\n  while (vals.size < count) vals.add(Math.floor(Math.random()*90)+1);\n  const arr = Array.from(vals);\n  log('Randomizing tree with', arr.length, 'values:', arr.join(', '));\n  // insert with animation\n  let delay = 0;\n  arr.forEach((v,i) => {\n    schedule(()=> {\n      tree.insert(v);\n      drawTree({inserted: new Set([getNodeByValue(v)?.id])});\n    }, delay);\n    delay += 140;\n  });\n  schedule(()=> {\n    drawTree();\n    log('Random insertion complete.');\n  }, delay+200);\n});\n\ndocument.getElementById('inorderBtn').addEventListener('click', ()=> {\n  clearPending();\n  const list = tree.inorder();\n  animateTraversal(list, 'In-order');\n});\ndocument.getElementById('preorderBtn').addEventListener('click', ()=> {\n  clearPending();\n  const list = tree.preorder();\n  animateTraversal(list, 'Pre-order');\n});\ndocument.getElementById('postorderBtn').addEventListener('click', ()=> {\n  clearPending();\n  const list = tree.postorder();\n  animateTraversal(list, 'Post-order');\n});\ndocument.getElementById('levelBtn').addEventListener('click', ()=> {\n  clearPending();\n  const list = tree.levelOrder();\n  animateTraversal(list, 'Level-order');\n});\n\ndocument.getElementById('stepTraversal').addEventListener('click', ()=> {\n  clearPending();\n  const list = tree.inorder();\n  // step mode: show one node at a time using prompt-less stepping (Pause/Resume used)\n  runStepTraversal(list);\n});\n\ndocument.getElementById('pauseBtn').addEventListener('click', ()=>{\n  paused = true;\n  clearPending(); // stop further scheduled actions\n  log('Paused.');\n});\ndocument.getElementById('resumeBtn').addEventListener('click', ()=>{\n  if (!running) log('Nothing to resume.');\n  paused = false;\n  log('Resume not implemented for mid-animation. Start an action again.');\n});\n\n// speed control\nspeedRange.addEventListener('input', ()=>{\n  animationDelay = parseInt(speedRange.value);\n});\n\n// helper to get node by value (search first occurrence)\nfunction getNodeByValue(val){\n  const s = tree.search(val);\n  return s.found;\n}\n\n// Animations\nfunction animateInsert(value) {\n  const res = tree.insert(value);\n  if (!res.inserted) {\n    drawTree({visited: new Set(res.path.map(n=>n.id))});\n    log('Value', value, 'already exists — duplicates are ignored.');\n    return;\n  }\n  running = true;\n  const path = res.path; // nodes visited + inserted node at end\n  const visitedSet = new Set();\n  const insertedSet = new Set([res.inserted.id]);\n  let t = 0;\n  const stepDelay = Math.max(80, animationDelay/1.6);\n  path.forEach((node,i) => {\n    schedule(()=> {\n      visitedSet.add(node.id);\n      drawTree({visited: visitedSet, inserted: insertedSet});\n      if (i < path.length - 1) log('Visiting', node.value);\n      else log('Inserted', node.value);\n    }, t);\n    t += stepDelay;\n  });\n  schedule(()=> {\n    running = false;\n    drawTree({inserted: insertedSet});\n  }, t+60);\n}\n\nfunction animateSearch(value) {\n  const res = tree.search(value);\n  const path = res.path;\n  running = true;\n  const visitedSet = new Set();\n  let t = 0;\n  const stepDelay = Math.max(80, animationDelay/1.6);\n  path.forEach((node,i)=>{\n    schedule(()=> {\n      visitedSet.add(node.id);\n      drawTree({visited: visitedSet});\n      log('Checking', node.value);\n    }, t);\n    t += stepDelay;\n  });\n  schedule(()=> {\n    running = false;\n    if (res.found) {\n      drawTree({inserted: new Set([res.found.id])});\n      log('Found', value);\n    } else {\n      drawTree({visited: visitedSet});\n      log('Not found:', value);\n    }\n  }, t+50);\n}\n\nfunction animateDelete(value) {\n  const res = tree.delete(value);\n  if (!res.deletedNode) {\n    drawTree({visited: new Set(res.path.map(n=>n.id))});\n    log('Value', value, 'not found; cannot delete.');\n    return;\n  }\n  running = true;\n  const path = res.path;\n  const visitedSet = new Set();\n  const removedSet = new Set([res.deletedNode.id]);\n  let t = 0;\n  const stepDelay = Math.max(90, animationDelay/1.8);\n  path.forEach((node,i) => {\n    schedule(()=> {\n      visitedSet.add(node.id);\n      drawTree({visited: visitedSet, removed: removedSet});\n      log('Visiting', node.value);\n    }, t);\n    t += stepDelay;\n  });\n  schedule(()=> {\n    // final refresh (tree already updated by delete)\n    drawTree({removed: removedSet});\n    running = false;\n    log('Deleted', value);\n  }, t+120);\n}\n\nfunction animateTraversal(list, name) {\n  if (!list || list.length === 0) {\n    log(name + ' traversal: tree empty.');\n    return;\n  }\n  running = true;\n  const visited = new Set();\n  let t = 0;\n  const stepDelay = Math.max(200, animationDelay);\n  list.forEach((node,i) => {\n    schedule(()=> {\n      visited.add(node.id);\n      drawTree({visited});\n      log(name + ' visiting', node.value);\n    }, t);\n    t += stepDelay;\n  });\n  schedule(()=> {\n    running = false;\n    drawTree();\n    log(name + ' complete. Sequence:', list.map(n=>n.value).join(', '));\n  }, t+80);\n}\n\n// step traversal: manual stepping using \"Pause\" and \"Resume\" isn't ideal, implement simple stepper\nfunction runStepTraversal(list) {\n  if (!list.length) { log('Tree empty.'); return; }\n  let idx = 0;\n  running = true;\n  paused = true; // start paused, user presses Resume to advance? We'll implement a \"click to step\" by clicking the svg\n  log('Step traversal: click anywhere on the canvas to advance through nodes (or press Clear to stop).');\n  function stepOnce() {\n    if (idx >= list.length) {\n      svg.removeEventListener('click', onClick);\n      running = false;\n      drawTree();\n      log('Step traversal complete.');\n      return;\n    }\n    const node = list[idx++];\n    drawTree({visited:new Set([node.id])});\n    log('Step visiting', node.value);\n  }\n  function onClick(){\n    stepOnce();\n  }\n  svg.addEventListener('click', onClick);\n  // initial highlight first node\n  stepOnce();\n}\n\n// initial draw\ndrawTree();\nlog('BST visualizer ready. Examples: insert 50, 30, 70, 20, 40, 60, 80.');\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}