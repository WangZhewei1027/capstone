{
  "id": "f18278f1-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:42.625Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Nearest Neighbors (KNN) Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n        }\n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 10px;\n        }\n        .subtitle {\n            text-align: center;\n            color: #7f8c8d;\n            margin-bottom: 30px;\n        }\n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n        }\n        .panel {\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            padding: 20px;\n            flex: 1;\n            min-width: 300px;\n        }\n        .canvas-container {\n            position: relative;\n            margin-bottom: 15px;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background: #f8f9fa;\n            border-radius: 4px;\n            touch-action: none;\n        }\n        .controls {\n            margin-top: 15px;\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            align-items: center;\n        }\n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            padding: 8px 15px;\n            cursor: pointer;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button.active {\n            background-color: #2ecc71;\n        }\n        button.clear {\n            background-color: #e74c3c;\n        }\n        button.clear:hover {\n            background-color: #c0392b;\n        }\n        input[type=\"range\"] {\n            width: 100%;\n            margin: 10px 0;\n        }\n        .legend {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            margin-top: 10px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 15px;\n            height: 15px;\n            border-radius: 50%;\n        }\n        .explanation {\n            margin-top: 20px;\n            line-height: 1.6;\n        }\n        .status {\n            margin-top: 10px;\n            font-style: italic;\n            color: #7f8c8d;\n        }\n    </style>\n</head>\n<body>\n    <h1>K-Nearest Neighbors (KNN) Algorithm</h1>\n    <p class=\"subtitle\">Click or tap on the canvas to add data points and see how KNN classifies new points.</p>\n    \n    <div class=\"container\">\n        <div class=\"panel\">\n            <div class=\"canvas-container\">\n                <canvas id=\"knnCanvas\" width=\"500\" height=\"500\"></canvas>\n            </div>\n            <div class=\"controls\">\n                <button id=\"classA\" class=\"active\">Add Class A (Blue)</button>\n                <button id=\"classB\">Add Class B (Red)</button>\n                <button id=\"classify\">Classify Mode (Green)</button>\n                <button id=\"clear\">Clear All</button>\n            </div>\n            <div class=\"controls\">\n                <label for=\"kValue\">K Value: <span id=\"kDisplay\">3</span></label>\n                <input type=\"range\" id=\"kValue\" min=\"1\" max=\"15\" value=\"3\">\n            </div>\n            <div class=\"legend\">\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n                    <span>Class A</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n                    <span>Class B</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                    <span>Classifying Point</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #f1c40f;\"></div>\n                    <span>Nearest Neighbors</span>\n                </div>\n            </div>\n            <div class=\"status\" id=\"status\">Add some training data points first, then switch to classify mode and click on the canvas.</div>\n        </div>\n        \n        <div class=\"panel\">\n            <h2>How K-Nearest Neighbors Works</h2>\n            <div class=\"explanation\">\n                <p><strong>K-Nearest Neighbors (KNN)</strong> is a simple, intuitive machine learning algorithm used for classification and regression.</p>\n                \n                <h3>Key Steps:</h3>\n                <ol>\n                    <li><strong>Store Training Data:</strong> KNN memorizes all training examples with their labels.</li>\n                    <li><strong>Calculate Distance:</strong> For a new point, it calculates the distance to all stored points.</li>\n                    <li><strong>Find Nearest Neighbors:</strong> It selects the K closest points (neighbors).</li>\n                    <li><strong>Majority Vote:</strong> For classification, the most common class among neighbors determines the new point's class.</li>\n                </ol>\n                \n                <h3>Try It Out:</h3>\n                <ul>\n                    <li>Click \"Add Class A\" or \"Add Class B\" and place training points on the canvas</li>\n                    <li>Switch to \"Classify Mode\" and click to classify new points</li>\n                    <li>Adjust the K value to see how it affects classification</li>\n                    <li>Watch how the nearest neighbors (highlighted in yellow) influence the classification</li>\n                </ul>\n                \n                <h3>Considerations:</h3>\n                <p>The value of K affects the algorithm:</p>\n                <ul>\n                    <li><strong>Small K</strong> (e.g., 1): More sensitive to noise, may overfit</li>\n                    <li><strong>Large K</strong>: More robust to noise but may underfit, blurring boundaries</li>\n                </ul>\n                \n                <p>Experiment with different K values and data distributions to see how KNN behaves!</p>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Canvas and context setup\n        const canvas = document.getElementById('knnCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Configuration\n        const pointRadius = 8;\n        const neighborRadius = 12;\n        const colors = {\n            classA: '#3498db',\n            classB: '#e74c3c',\n            classifying: '#2ecc71',\n            neighbors: '#f1c40f'\n        };\n        \n        // State variables\n        let mode = 'classify'; // 'classA', 'classB', or 'classify'\n        let kValue = 3;\n        let points = {\n            classA: [],\n            classB: [],\n            classifying: null\n        };\n        \n        // DOM elements\n        const classABtn = document.getElementById('classA');\n        const classBBtn = document.getElementById('classB');\n        const classifyBtn = document.getElementById('classify');\n        const clearBtn = document.getElementById('clear');\n        const kValueSlider = document.getElementById('kValue');\n        const kDisplay = document.getElementById('kDisplay');\n        const statusEl = document.getElementById('status');\n        \n        // Event listeners\n        classABtn.addEventListener('click', () => setMode('classA'));\n        classBBtn.addEventListener('click', () => setMode('classB'));\n        classifyBtn.addEventListener('click', () => setMode('classify'));\n        clearBtn.addEventListener('click', clearCanvas);\n        kValueSlider.addEventListener('input', updateKValue);\n        \n        // Canvas interaction\n        canvas.addEventListener('mousedown', handleCanvasClick);\n        canvas.addEventListener('touchstart', handleCanvasTouch, { passive: false });\n        \n        // Initialize\n        setMode('classA');\n        updateKValue();\n        drawCanvas();\n        \n        // Functions\n        function setMode(newMode) {\n            mode = newMode;\n            \n            // Update button states\n            classABtn.classList.toggle('active', newMode === 'classA');\n            classBBtn.classList.toggle('active', newMode === 'classB');\n            classifyBtn.classList.toggle('active', newMode === 'classify');\n            \n            if (newMode === 'classify') {\n                statusEl.textContent = 'Click on the canvas to classify a new point';\n            } else {\n                statusEl.textContent = `Click to add ${newMode === 'classA' ? 'Class A (Blue)' : 'Class B (Red)'} training points`;\n            }\n        }\n        \n        function updateKValue() {\n            kValue = parseInt(kValueSlider.value);\n            kDisplay.textContent = kValue;\n            if (points.classifying) {\n                classifyPoint(points.classifying.x, points.classifying.y);\n            }\n            drawCanvas();\n        }\n        \n        function handleCanvasClick(e) {\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            handlePointAddition(x, y);\n        }\n        \n        function handleCanvasTouch(e) {\n            e.preventDefault();\n            const rect = canvas.getBoundingClientRect();\n            const touch = e.touches[0];\n            const x = touch.clientX - rect.left;\n            const y = touch.clientY - rect.top;\n            \n            handlePointAddition(x, y);\n        }\n        \n        function handlePointAddition(x, y) {\n            if (mode === 'classify') {\n                classifyPoint(x, y);\n            } else {\n                points[mode].push({x, y});\n                statusEl.textContent = `Added ${mode === 'classA' ? 'Class A' : 'Class B'} point`;\n            }\n            drawCanvas();\n        }\n        \n        function classifyPoint(x, y) {\n            points.classifying = {x, y, neighbors: [], classification: null};\n            \n            // If no training data, can't classify\n            if (points.classA.length === 0 && points.classB.length === 0) {\n                statusEl.textContent = 'Add training points before classifying';\n                return;\n            }\n            \n            // Calculate distances to all points\n            const distances = [];\n            \n            points.classA.forEach(point => {\n                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));\n                distances.push({point, distance, class: 'classA'});\n            });\n            \n            points.classB.forEach(point => {\n                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));\n                distances.push({point, distance, class: 'classB'});\n            });\n            \n            // Sort by distance and get k nearest neighbors\n            distances.sort((a, b) => a.distance - b.distance);\n            points.classifying.neighbors = distances.slice(0, kValue);\n            \n            // Count votes for each class\n            const votes = {classA: 0, classB: 0};\n            points.classifying.neighbors.forEach(neighbor => {\n                votes[neighbor.class]++;\n            });\n            \n            // Determine classification based on majority vote\n            if (votes.classA > votes.classB) {\n                points.classifying.classification = 'classA';\n                statusEl.textContent = `Classification: Class A (${votes.classA} vs ${votes.classB} votes)`;\n            } else if (votes.classB > votes.classA) {\n                points.classifying.classification = 'classB';\n                statusEl.textContent = `Classification: Class B (${votes.classB} vs ${votes.classA} votes)`;\n            } else {\n                points.classifying.classification = 'tie';\n                statusEl.textContent = `Classification: Tie (${votes.classA} vs ${votes.classB} votes)`;\n            }\n        }\n        \n        function clearCanvas() {\n            points = {\n                classA: [],\n                classB: [],\n                classifying: null\n            };\n            statusEl.textContent = 'Canvas cleared. Add training points to begin.';\n            drawCanvas();\n        }\n        \n        function drawCanvas() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw grid for better visualization\n            drawGrid();\n            \n            // Draw lines to neighbors if classifying\n            if (points.classifying && points.classifying.neighbors) {\n                points.classifying.neighbors.forEach(neighbor => {\n                    ctx.beginPath();\n                    ctx.moveTo(points.classifying.x, points.classifying.y);\n                    ctx.lineTo(neighbor.point.x, neighbor.point.y);\n                    ctx.strokeStyle = colors.neighbors + '80'; // Semi-transparent\n                    ctx.lineWidth = 1;\n                    ctx.stroke();\n                });\n            }\n            \n            // Draw training points\n            points.classA.forEach(point => drawPoint(point, colors.classA));\n            points.classB.forEach(point => drawPoint(point, colors.classB));\n            \n            // Draw classifying point if exists\n            if (points.classifying) {\n                drawPoint(points.classifying, colors.classifying);\n                \n                // Draw neighbor highlights\n                if (points.classifying.neighbors) {\n                    points.classifying.neighbors.forEach(neighbor => {\n                        drawNeighborHighlight(neighbor.point);\n                    });\n                }\n            }\n        }\n        \n        function drawGrid() {\n            ctx.strokeStyle = '#e0e0e0';\n            ctx.lineWidth = 0.5;\n            \n            // Vertical lines\n            for (let x = 0; x <= canvas.width; x += 50) {\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, canvas.height);\n                ctx.stroke();\n            }\n            \n            // Horizontal lines\n            for (let y = 0; y <= canvas.height; y += 50) {\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(canvas.width, y);\n                ctx.stroke();\n            }\n        }\n        \n        function drawPoint(point, color) {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);\n            ctx.fillStyle = color;\n            ctx.fill();\n            ctx.strokeStyle = '#2c3e50';\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n        \n        function drawNeighborHighlight(point) {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, neighborRadius, 0, Math.PI * 2);\n            ctx.fillStyle = colors.neighbors + '40'; // More transparent\n            ctx.fill();\n        }\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}