{
  "id": "d79bdd51-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:25.477Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Tree Visualization & Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #controls {\n    margin-bottom: 15px;\n  }\n  #tree-container {\n    text-align: center;\n  }\n  svg {\n    border: 1px solid #ccc;\n    max-width: 100%;\n    height: 500px;\n  }\n  .node circle {\n    fill: #69a3f3;\n    stroke: #1e70bf;\n    stroke-width: 2px;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    font-size: 14px;\n    text-anchor: middle;\n    dominant-baseline: middle;\n    pointer-events: none;\n  }\n  .link {\n    fill: none;\n    stroke: #aaa;\n    stroke-width: 2px;\n  }\n  #log {\n    margin-top: 20px;\n    height: 120px;\n    overflow-y: auto;\n    background: #f9f9f9;\n    border: 1px solid #ddd;\n    padding: 8px;\n    font-family: monospace;\n    white-space: pre-wrap;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 5px;\n    font-size: 14px;\n  }\n  button {\n    padding: 6px 14px;\n    font-size: 14px;\n    margin-left: 5px;\n    cursor: pointer;\n  }\n  #traversal-buttons button {\n    margin: 2px;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Tree Visualization & Demo</h1>\n\n<div id=\"controls\">\n  <label for=\"nodeValue\">Node Value (integer): </label>\n  <input type=\"number\" id=\"nodeValue\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n</div>\n\n<div id=\"traversal-buttons\">\n  <button id=\"inorderBtn\">Inorder Traversal</button>\n  <button id=\"preorderBtn\">Preorder Traversal</button>\n  <button id=\"postorderBtn\">Postorder Traversal</button>\n  <button id=\"levelorderBtn\">Level-order Traversal</button>\n</div>\n\n<div id=\"tree-container\">\n  <svg id=\"treeSVG\" width=\"1000\" height=\"500\"></svg>\n</div>\n\n<h3>Traversal Output:</h3>\n<div id=\"log\"></div>\n\n<script>\n  // Binary Tree Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  // Binary Search Tree class with visualization\n  class BinaryTree {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      if (this.root === null) {\n        this.root = new Node(value);\n      } else {\n        this._insertNode(this.root, value);\n      }\n    }\n\n    _insertNode(node, value) {\n      if (value === node.value) {\n        // Disallow duplicates for this demo\n        alert(\"Duplicate nodes not allowed.\");\n        return;\n      }\n      if (value < node.value) {\n        if (node.left === null) {\n          node.left = new Node(value);\n        } else {\n          this._insertNode(node.left, value);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = new Node(value);\n        } else {\n          this._insertNode(node.right, value);\n        }\n      }\n    }\n\n    inorderTraversal(callback) {\n      function inorder(node) {\n        if (node === null) return;\n        inorder(node.left);\n        callback(node.value);\n        inorder(node.right);\n      }\n      inorder(this.root);\n    }\n\n    preorderTraversal(callback) {\n      function preorder(node) {\n        if (node === null) return;\n        callback(node.value);\n        preorder(node.left);\n        preorder(node.right);\n      }\n      preorder(this.root);\n    }\n\n    postorderTraversal(callback) {\n      function postorder(node) {\n        if (node === null) return;\n        postorder(node.left);\n        postorder(node.right);\n        callback(node.value);\n      }\n      postorder(this.root);\n    }\n\n    levelOrderTraversal(callback) {\n      if (!this.root) return;\n      const queue = [this.root];\n      while (queue.length > 0) {\n        const node = queue.shift();\n        callback(node.value);\n        if (node.left !== null) queue.push(node.left);\n        if (node.right !== null) queue.push(node.right);\n      }\n    }\n\n    clear() {\n      this.root = null;\n    }\n  }\n\n  // Visualization & UI\n  const svg = document.getElementById(\"treeSVG\");\n  const WIDTH = svg.clientWidth;\n  const HEIGHT = svg.clientHeight;\n  const NODE_RADIUS = 20;\n  const VERTICAL_GAP = 70;\n\n  let tree = new BinaryTree();\n\n  // To compute positions we do a tree layout (basic)\n  // First, get the height, then do an inorder traversal to assign x based on order,\n  // and y based on depth\n\n  function getHeight(node) {\n    if (!node) return 0;\n    return 1 + Math.max(getHeight(node.left), getHeight(node.right));\n  }\n\n  // Assign x position tracking inorder index\n  function assignPositions(root) {\n    let positions = new Map();\n    let x = 0;\n    function inorderPosition(node, depth) {\n      if (!node) return;\n      inorderPosition(node.left, depth + 1);\n      positions.set(node, { depth, x: x++ });\n      inorderPosition(node.right, depth + 1);\n    }\n    inorderPosition(root, 0);\n    return positions;\n  }\n\n  // Draw tree function\n  function drawTree() {\n    // Clear svg\n    while (svg.firstChild) {\n      svg.removeChild(svg.firstChild);\n    }\n    if (!tree.root) return;\n\n    const height = getHeight(tree.root);\n    const positions = assignPositions(tree.root);\n\n    // Find max x for scaling horizontally\n    let maxX = 0;\n    for (let pos of positions.values()) {\n      if (pos.x > maxX) maxX = pos.x;\n    }\n\n    // Functions to convert logical x,y to svg coords\n    function getCoordX(x) {\n      if (maxX === 0) return WIDTH / 2;\n      return (x * (WIDTH - 2 * NODE_RADIUS - 20)) / maxX + NODE_RADIUS + 10;\n    }\n    function getCoordY(depth) {\n      return depth * VERTICAL_GAP + NODE_RADIUS + 10;\n    }\n\n    // Draw links first\n    for (let [node, pos] of positions.entries()) {\n      if (node.left) {\n        let leftPos = positions.get(node.left);\n        drawLink(\n          getCoordX(pos.x),\n          getCoordY(pos.depth),\n          getCoordX(leftPos.x),\n          getCoordY(leftPos.depth)\n        );\n      }\n      if (node.right) {\n        let rightPos = positions.get(node.right);\n        drawLink(\n          getCoordX(pos.x),\n          getCoordY(pos.depth),\n          getCoordX(rightPos.x),\n          getCoordY(rightPos.depth)\n        );\n      }\n    }\n\n    // Draw nodes on top of links\n    for (let [node, pos] of positions.entries()) {\n      drawNode(getCoordX(pos.x), getCoordY(pos.depth), node.value);\n    }\n  }\n\n  function drawNode(cx, cy, value) {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.setAttribute(\"class\", \"node\");\n\n    const circle = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    circle.setAttribute(\"cx\", cx);\n    circle.setAttribute(\"cy\", cy);\n    circle.setAttribute(\"r\", NODE_RADIUS);\n\n    const text = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"text\"\n    );\n    text.setAttribute(\"x\", cx);\n    text.setAttribute(\"y\", cy + 1); // +1 for vertical center visually\n    text.textContent = value;\n\n    g.appendChild(circle);\n    g.appendChild(text);\n    svg.appendChild(g);\n  }\n\n  function drawLink(x1, y1, x2, y2) {\n    const path = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"path\"\n    );\n    path.setAttribute(\"class\", \"link\");\n\n    // Draw smooth curve from parent to child\n    const deltaX = x2 - x1;\n    const deltaY = y2 - y1;\n    const c1x = x1;\n    const c1y = y1 + deltaY / 2;\n    const c2x = x2;\n    const c2y = y1 + deltaY / 2;\n\n    const d = `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;\n\n    path.setAttribute(\"d\", d);\n\n    svg.appendChild(path);\n  }\n\n  // Logging function\n  function log(msg) {\n    const logDiv = document.getElementById(\"log\");\n    logDiv.textContent += msg + \"\\n\";\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  function clearLog() {\n    document.getElementById(\"log\").textContent = \"\";\n  }\n\n  // UI controls\n  document.getElementById(\"insertBtn\").addEventListener(\"click\", () => {\n    const valInput = document.getElementById(\"nodeValue\");\n    const val = parseInt(valInput.value);\n    if (isNaN(val)) {\n      alert(\"Please enter a valid integer value.\");\n      return;\n    }\n    tree.insert(val);\n    drawTree();\n    valInput.value = \"\";\n    valInput.focus();\n  });\n\n  document.getElementById(\"clearBtn\").addEventListener(\"click\", () => {\n    if (confirm(\"Are you sure you want to clear the entire tree?\")) {\n      tree.clear();\n      drawTree();\n      clearLog();\n    }\n  });\n\n  document.getElementById(\"inorderBtn\").addEventListener(\"click\", () => {\n    clearLog();\n    log(\"Inorder Traversal:\");\n    let values = [];\n    tree.inorderTraversal((val) => values.push(val));\n    log(values.join(\" → \"));\n  });\n\n  document.getElementById(\"preorderBtn\").addEventListener(\"click\", () => {\n    clearLog();\n    log(\"Preorder Traversal:\");\n    let values = [];\n    tree.preorderTraversal((val) => values.push(val));\n    log(values.join(\" → \"));\n  });\n\n  document.getElementById(\"postorderBtn\").addEventListener(\"click\", () => {\n    clearLog();\n    log(\"Postorder Traversal:\");\n    let values = [];\n    tree.postorderTraversal((val) => values.push(val));\n    log(values.join(\" → \"));\n  });\n\n  document.getElementById(\"levelorderBtn\").addEventListener(\"click\", () => {\n    clearLog();\n    log(\"Level-order Traversal:\");\n    let values = [];\n    tree.levelOrderTraversal((val) => values.push(val));\n    log(values.join(\" → \"));\n  });\n\n  // Insert sample values on load\n  window.onload = () => {\n    [50, 30, 70, 20, 40, 60, 80].forEach((v) => tree.insert(v));\n    drawTree();\n  };\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}