{
  "id": "98e2f320-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:07.811Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 20px; color: #111; }\n  h1 { margin: 0 0 8px 0; font-size: 20px; }\n  p { margin: 6px 0; color: #333; }\n  #container { display: flex; gap: 16px; align-items: flex-start; }\n  #left { width: 720px; }\n  #canvasWrap { position: relative; border: 1px solid #ccc; background: #fff; }\n  canvas { display: block; }\n  #infoBox { margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }\n  .control { background: #fafafa; border: 1px solid #e6e6e6; padding: 8px; border-radius: 6px; }\n  label { display: inline-block; margin-right: 8px; font-size: 13px; }\n  input[type=\"range\"] { vertical-align: middle; }\n  select, button, input[type=\"number\"] { font-size: 13px; padding: 4px 6px; }\n  .legend { display: flex; gap: 10px; align-items: center; }\n  .swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; margin-right: 6px; border: 1px solid #3332; }\n  #right { width: 320px; }\n  .section { margin-bottom: 12px; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #fcfcfc; }\n  .muted { color: #666; font-size: 13px; }\n  .btn { padding: 6px 8px; border-radius: 6px; border: 1px solid #cfcfcf; background: #fff; cursor: pointer; }\n  .btn:active { transform: translateY(1px); }\n  #controlsTop { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n  small { color: #555; }\n  footer { margin-top: 12px; color: #666; font-size: 13px; }\n</style>\n</head>\n<body>\n<h1>K-Nearest Neighbors (KNN) Interactive Demo</h1>\n<p class=\"muted\">Click on the canvas to add training points (left-click). Right-click to place a query point and see its K nearest neighbors and predicted class. Adjust K, distance metric, or toggle the decision boundary shading.</p>\n\n<div id=\"container\">\n  <div id=\"left\">\n    <div id=\"canvasWrap\" class=\"control\">\n      <canvas id=\"plot\" width=\"720\" height=\"540\"></canvas>\n    </div>\n\n    <div id=\"infoBox\">\n      <div class=\"control\">\n        <label>Mode:</label>\n        <select id=\"mode\">\n          <option value=\"add\">Add training points</option>\n          <option value=\"query\">Place query point (right-click also)</option>\n        </select>\n      </div>\n\n      <div class=\"control\">\n        <label>Active class:</label>\n        <select id=\"classSelect\"></select>\n      </div>\n\n      <div class=\"control\">\n        <label>K = <span id=\"kval\">3</span></label><br>\n        <input id=\"k\" type=\"range\" min=\"1\" max=\"25\" value=\"3\"/>\n      </div>\n\n      <div class=\"control\">\n        <label>Distance:</label>\n        <select id=\"metric\">\n          <option value=\"euclidean\">Euclidean</option>\n          <option value=\"manhattan\">Manhattan</option>\n          <option value=\"chebyshev\">Chebyshev</option>\n        </select>\n      </div>\n\n      <div class=\"control\">\n        <label>Weighting:</label>\n        <select id=\"weighting\">\n          <option value=\"uniform\">Uniform vote</option>\n          <option value=\"distance\">Distance-weighted (1/d)</option>\n        </select>\n      </div>\n\n      <div class=\"control\">\n        <label>Decision boundary:</label>\n        <input type=\"checkbox\" id=\"drawBoundary\" checked/>\n      </div>\n    </div>\n\n    <div style=\"margin-top:8px; display:flex; gap:8px;\">\n      <button id=\"genBtn\" class=\"btn\">Generate random clusters</button>\n      <button id=\"clearBtn\" class=\"btn\">Clear training points</button>\n      <button id=\"clearQueriesBtn\" class=\"btn\">Clear queries</button>\n      <button id=\"shuffleBtn\" class=\"btn\">Shuffle K (auto adjust)</button>\n    </div>\n\n    <div style=\"margin-top:10px;\" class=\"muted\">\n      <small>Left-click: add training point. Right-click: place a query point and classify it. Toggle modes for other behaviours.</small>\n    </div>\n  </div>\n\n  <div id=\"right\">\n    <div class=\"section\">\n      <strong>Classes</strong>\n      <div id=\"classesList\" style=\"margin-top:8px;\"></div>\n      <div style=\"margin-top:8px;\">\n        <button id=\"addClassBtn\" class=\"btn\">Add class</button>\n        <button id=\"removeClassBtn\" class=\"btn\">Remove last</button>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <strong>Last classification</strong>\n      <div id=\"lastResult\" style=\"margin-top:8px;\">No query yet.</div>\n    </div>\n\n    <div class=\"section\">\n      <strong>Options</strong>\n      <div style=\"margin-top:8px;\">\n        <label>Boundary resolution:</label><br>\n        <input id=\"res\" type=\"range\" min=\"8\" max=\"80\" value=\"28\"/>\n        <div class=\"muted\">Lower number = coarser, faster</div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <strong>Quick stats</strong>\n      <div id=\"stats\" style=\"margin-top:8px;\">Training points: 0</div>\n    </div>\n  </div>\n</div>\n\n<footer>\n  Implementation note: This demo implements a simple KNN classifier (multi-class) with options for different distance metrics and weighting. Ties are broken by sum of neighbor distances per class (smaller wins), then by lowest class index.\n</footer>\n\n<script>\n(() => {\n  // Canvas and coordinate utilities\n  const canvas = document.getElementById('plot');\n  const ctx = canvas.getContext('2d', {alpha:false});\n  const W = canvas.width, H = canvas.height;\n  const pad = 8;\n\n  // UI elements\n  const classSelect = document.getElementById('classSelect');\n  const classesList = document.getElementById('classesList');\n  const addClassBtn = document.getElementById('addClassBtn');\n  const removeClassBtn = document.getElementById('removeClassBtn');\n  const kSlider = document.getElementById('k');\n  const kvalLabel = document.getElementById('kval');\n  const metricSelect = document.getElementById('metric');\n  const weightingSelect = document.getElementById('weighting');\n  const drawBoundaryCheckbox = document.getElementById('drawBoundary');\n  const modeSelect = document.getElementById('mode');\n  const genBtn = document.getElementById('genBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const clearQueriesBtn = document.getElementById('clearQueriesBtn');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const lastResultDiv = document.getElementById('lastResult');\n  const statsDiv = document.getElementById('stats');\n  const resSlider = document.getElementById('res');\n\n  // Data\n  let classes = [\n    {name: 'Class 0', color: '#e53935'},\n    {name: 'Class 1', color: '#1e88e5'},\n    {name: 'Class 2', color: '#43a047'}\n  ];\n  let points = []; // training points: {x,y,label}\n  let queries = []; // query points: {x,y,prediction,neighbors}\n  let activeClass = 0;\n\n  // State\n  let drawBoundary = true;\n  let resolution = parseInt(resSlider.value,10);\n  let metric = 'euclidean';\n  let weighting = 'uniform';\n  let mode = 'add';\n\n  // Helpers: map between canvas coords and normalized [0,1]\n  function toNorm(pt) {\n    return {x: (pt.x - pad) / (W - pad*2), y: 1 - (pt.y - pad) / (H - pad*2)};\n  }\n  function fromNorm(n) {\n    return {x: pad + n.x * (W - pad*2), y: pad + (1 - n.y) * (H - pad*2)};\n  }\n  function clamp01(v){ return Math.max(0, Math.min(1, v)); }\n\n  // Distance metrics\n  function dist(a, b, metric) {\n    const dx = a.x - b.x, dy = a.y - b.y;\n    if (metric === 'euclidean') return Math.hypot(dx, dy);\n    if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);\n    if (metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));\n    return Math.hypot(dx, dy);\n  }\n\n  // KNN classifier\n  function knnClassify(query, k, metric, weighting) {\n    if (points.length === 0) return {label: null, neighbors: [], classVotes: {}};\n    // compute distances to training points\n    const dlist = points.map((p, i) => {\n      const d = dist(query, p, metric);\n      return {i, d, label: p.label, point: p};\n    });\n    dlist.sort((a,b) => a.d - b.d);\n    const klist = dlist.slice(0, Math.min(k, dlist.length));\n    // Count votes\n    const votes = {};\n    const distSums = {}; // for tie-break\n    for (const nb of klist) {\n      const lbl = nb.label;\n      let w = 1;\n      if (weighting === 'distance') {\n        w = nb.d === 0 ? 1e9 : 1 / nb.d; // very large weight for zero distance\n      }\n      votes[lbl] = (votes[lbl] || 0) + w;\n      distSums[lbl] = (distSums[lbl] || 0) + nb.d;\n    }\n    // find best label: highest votes; tie-break by smaller dist sum; then smallest label index\n    const sortedLabels = Object.keys(votes).map(l => parseInt(l,10));\n    sortedLabels.sort((A,B) => {\n      if (votes[B] !== votes[A]) return votes[B] - votes[A];\n      if ((distSums[A]||0) !== (distSums[B]||0)) return (distSums[A]||0) - (distSums[B]||0);\n      return A - B;\n    });\n    const chosen = sortedLabels.length ? sortedLabels[0] : null;\n    return {label: chosen, neighbors: klist, classVotes: votes};\n  }\n\n  // Drawing\n  function clearCanvas() {\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0,0,W,H);\n  }\n\n  function drawBackgroundGrid() {\n    // Draw border / axes\n    ctx.strokeStyle = '#eee';\n    ctx.lineWidth = 1;\n    ctx.strokeRect(pad, pad, W - pad*2, H - pad*2);\n  }\n\n  function drawDecisionBoundary() {\n    if (!drawBoundary) return;\n    const res = Math.max(4, Math.min(128, parseInt(resSlider.value,10)));\n    const cellW = (W - pad*2) / res;\n    const cellH = (H - pad*2) / res;\n    // For each cell center, classify\n    const k = Math.max(1, parseInt(kSlider.value,10));\n    for (let yi = 0; yi < res; yi++) {\n      for (let xi = 0; xi < res; xi++) {\n        const cx = pad + (xi + 0.5) * cellW;\n        const cy = pad + (yi + 0.5) * cellH;\n        const norm = toNorm({x: cx, y: cy});\n        const result = knnClassify(norm, k, metric, weighting);\n        if (result.label === null) continue;\n        const col = hexToRgba(classes[result.label].color, 0.14);\n        ctx.fillStyle = col;\n        ctx.fillRect(pad + xi*cellW, pad + yi*cellH, Math.ceil(cellW), Math.ceil(cellH));\n      }\n    }\n  }\n\n  function drawPoints() {\n    // training points\n    for (const p of points) {\n      const c = fromNorm(p);\n      ctx.beginPath();\n      ctx.fillStyle = classes[p.label].color;\n      ctx.strokeStyle = '#222a';\n      ctx.lineWidth = 1;\n      ctx.arc(c.x, c.y, 7, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n      // small inner dot\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.arc(c.x, c.y, 2.2, 0, Math.PI*2);\n      ctx.fill();\n    }\n    // query points\n    for (const q of queries) {\n      const c = fromNorm(q);\n      // fill with predicted color (light)\n      if (q.prediction !== null) {\n        ctx.fillStyle = hexToRgba(classes[q.prediction].color, 0.28);\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, 12, 0, Math.PI*2);\n        ctx.fill();\n      }\n      // draw cross\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(c.x-9, c.y-9); ctx.lineTo(c.x+9, c.y+9);\n      ctx.moveTo(c.x-9, c.y+9); ctx.lineTo(c.x+9, c.y-9);\n      ctx.stroke();\n\n      // draw neighbors\n      if (q.neighbors && q.neighbors.length) {\n        for (const nb of q.neighbors) {\n          const p = fromNorm(nb.point);\n          ctx.beginPath();\n          ctx.strokeStyle = hexToRgba(classes[nb.label].color, 0.85);\n          ctx.lineWidth = 1.5;\n          ctx.moveTo(c.x, c.y);\n          ctx.lineTo(p.x, p.y);\n          ctx.stroke();\n          // draw neighbor outline\n          ctx.beginPath();\n          ctx.strokeStyle = '#000';\n          ctx.lineWidth = 1;\n          ctx.arc(p.x, p.y, 6, 0, Math.PI*2);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  function render() {\n    clearCanvas();\n    drawBackgroundGrid();\n    if (drawBoundary) drawDecisionBoundary();\n    drawPoints();\n    drawLegend();\n    statsDiv.textContent = `Training points: ${points.length} — Queries: ${queries.length}`;\n  }\n\n  function drawLegend() {\n    // small legend top-left\n    const x = pad + 6, y = pad + 6;\n    ctx.save();\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left'; ctx.textBaseline = 'middle';\n    for (let i=0;i<classes.length;i++) {\n      ctx.fillStyle = classes[i].color;\n      roundRect(ctx, x, y + i*22, 14, 14, 3);\n      ctx.fill();\n      ctx.fillStyle = '#111';\n      ctx.fillText(` ${classes[i].name}`, x+22, y + i*22 + 7);\n    }\n    ctx.restore();\n  }\n\n  // Utility functions\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y, x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x, y+h, r);\n    ctx.arcTo(x, y+h, x, y, r);\n    ctx.arcTo(x, y, x+w, y, r);\n    ctx.closePath();\n  }\n\n  function hexToRgba(hex, alpha) {\n    const h = hex.replace('#','');\n    const bigint = parseInt(h.length===3 ? h.split('').map(c => c+c).join('') : h, 16);\n    const r = (bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;\n    return `rgba(${r},${g},${b},${alpha})`;\n  }\n\n  // Interaction\n  canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); });\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;\n    const norm = toNorm({x: cx, y: cy});\n    if (e.button === 0) {\n      // left click\n      if (mode === 'add') {\n        addTrainingPoint(norm.x, norm.y, activeClass);\n      } else if (mode === 'query') {\n        addQuery(norm);\n      }\n    } else if (e.button === 2) {\n      // right click: always add query\n      addQuery(norm);\n    }\n  });\n\n  function addTrainingPoint(nx, ny, label) {\n    points.push({x: clamp01(nx), y: clamp01(ny), label});\n    recomputeAllQueries();\n    render();\n  }\n\n  function addQuery(norm) {\n    const k = Math.max(1, parseInt(kSlider.value,10));\n    const result = knnClassify(norm, k, metric, weighting);\n    const q = {x: clamp01(norm.x), y: clamp01(norm.y), prediction: result.label, neighbors: result.neighbors};\n    queries.push(q);\n    updateLastResult(q);\n    render();\n  }\n\n  function recomputeAllQueries() {\n    const k = Math.max(1, parseInt(kSlider.value,10));\n    for (const q of queries) {\n      const result = knnClassify(q, k, metric, weighting);\n      q.prediction = result.label;\n      q.neighbors = result.neighbors;\n    }\n    updateLastResult(queries.length ? queries[queries.length-1] : null);\n  }\n\n  function updateLastResult(q) {\n    if (!q) {\n      lastResultDiv.innerHTML = 'No query yet.';\n      return;\n    }\n    if (q.prediction === null) {\n      lastResultDiv.innerHTML = 'No training data.';\n      return;\n    }\n    const votes = {};\n    for (const nb of q.neighbors) {\n      votes[nb.label] = (votes[nb.label] || 0) + 1;\n    }\n    const voteText = Object.keys(votes).map(l => `${classes[l].name}: ${votes[l]}`).join(', ');\n    lastResultDiv.innerHTML = `\n      Predicted: <strong style=\"color:${classes[q.prediction].color}\">${classes[q.prediction].name}</strong><br/>\n      Neighbors: ${q.neighbors.length} (${voteText})\n    `;\n  }\n\n  // Class management UI\n  function refreshClassUI() {\n    // class select dropdown\n    classSelect.innerHTML = '';\n    for (let i=0;i<classes.length;i++) {\n      const opt = document.createElement('option');\n      opt.value = i;\n      opt.textContent = `${classes[i].name}`;\n      opt.style.color = classes[i].color;\n      classSelect.appendChild(opt);\n    }\n    if (activeClass >= classes.length) activeClass = classes.length-1;\n    classSelect.value = activeClass;\n    // classes list on right panel\n    classesList.innerHTML = '';\n    classes.forEach((c, idx) => {\n      const row = document.createElement('div');\n      row.style.display = 'flex';\n      row.style.alignItems = 'center';\n      row.style.marginBottom = '6px';\n      const sw = document.createElement('div');\n      sw.className = 'swatch';\n      sw.style.background = c.color;\n      sw.style.border = '1px solid #6662';\n      sw.title = c.name;\n      const inpc = document.createElement('input');\n      inpc.type = 'text';\n      inpc.value = c.name;\n      inpc.style.marginLeft = '8px';\n      inpc.style.flex = '1';\n      inpc.addEventListener('change', (e) => { classes[idx].name = e.target.value; render(); refreshClassUI(); });\n      const colorp = document.createElement('input');\n      colorp.type = 'color';\n      colorp.value = c.color;\n      colorp.style.marginLeft = '8px';\n      colorp.addEventListener('input', (e) => { classes[idx].color = e.target.value; render(); refreshClassUI(); });\n      row.appendChild(sw);\n      row.appendChild(inpc);\n      row.appendChild(colorp);\n      classesList.appendChild(row);\n    });\n    render();\n  }\n\n  addClassBtn.addEventListener('click', () => {\n    const idx = classes.length;\n    const col = randomColor();\n    classes.push({name: `Class ${idx}`, color: col});\n    refreshClassUI();\n  });\n  removeClassBtn.addEventListener('click', () => {\n    if (classes.length <= 1) return;\n    classes.pop();\n    // remove points of that class\n    points = points.filter(p => p.label < classes.length);\n    queries = [];\n    refreshClassUI();\n    recomputeAllQueries();\n    render();\n  });\n\n  classSelect.addEventListener('change', (e) => {\n    activeClass = parseInt(e.target.value,10);\n  });\n\n  kSlider.addEventListener('input', (e) => {\n    kvalLabel.textContent = e.target.value;\n  });\n  kSlider.addEventListener('change', (e) => {\n    recomputeAllQueries();\n    render();\n  });\n\n  metricSelect.addEventListener('change', (e) => {\n    metric = e.target.value;\n    recomputeAllQueries();\n    render();\n  });\n\n  weightingSelect.addEventListener('change', (e) => {\n    weighting = e.target.value;\n    recomputeAllQueries();\n    render();\n  });\n\n  drawBoundaryCheckbox.addEventListener('change', (e) => {\n    drawBoundary = e.target.checked;\n    render();\n  });\n\n  modeSelect.addEventListener('change', (e) => {\n    mode = e.target.value;\n  });\n\n  resSlider.addEventListener('change', (e) => {\n    resolution = parseInt(e.target.value,10);\n    render();\n  });\n\n  genBtn.addEventListener('click', () => {\n    // generate 3 clusters (or number of classes) random\n    points = [];\n    const C = classes.length;\n    for (let i=0;i<C;i++) {\n      const cx = Math.random()*0.7 + 0.15;\n      const cy = Math.random()*0.7 + 0.15;\n      const n = 8 + Math.floor(Math.random()*12);\n      for (let j=0;j<n;j++) {\n        const r = Math.random()*0.12;\n        const ang = Math.random()*Math.PI*2;\n        const x = clamp01(cx + Math.cos(ang)*r);\n        const y = clamp01(cy + Math.sin(ang)*r);\n        points.push({x,y,label:i});\n      }\n    }\n    queries = [];\n    recomputeAllQueries();\n    render();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    points = [];\n    queries = [];\n    render();\n  });\n\n  clearQueriesBtn.addEventListener('click', () => {\n    queries = [];\n    lastResultDiv.innerHTML = 'No query yet.';\n    render();\n  });\n\n  shuffleBtn.addEventListener('click', () => {\n    // set k to odd around sqrt(N)\n    const n = points.length || 1;\n    const sval = Math.max(1, Math.round(Math.sqrt(n)));\n    // make odd if possible\n    const knew = sval % 2 === 0 ? sval+1 : sval;\n    kSlider.value = Math.min(kSlider.max, knew);\n    kvalLabel.textContent = kSlider.value;\n    recomputeAllQueries();\n    render();\n  });\n\n  function randomColor() {\n    const hues = ['#e53935','#1e88e5','#43a047','#fb8c00','#8e24aa','#00acc1','#f4511e'];\n    return hues[Math.floor(Math.random()*hues.length)];\n  }\n\n  // Initialize default UI\n  refreshClassUI();\n\n  // Initialize with some random clusters\n  genBtn.click();\n\n  // Small helper: compute leave-one-out accuracy\n  function leaveOneOutAccuracy() {\n    if (points.length < 2) return 0;\n    let correct = 0;\n    for (let i=0;i<points.length;i++) {\n      const left = points.slice(0,i).concat(points.slice(i+1));\n      const query = {x: points[i].x, y: points[i].y};\n      // temporarily swap points\n      const backup = points;\n      points = left;\n      const res = knnClassify(query, Math.max(1, parseInt(kSlider.value,10)), metric, weighting);\n      if (res.label === backup[i].label) correct++;\n      points = backup;\n    }\n    return correct / points.length;\n  }\n\n  // Periodically update stats and render (handles resizing not implemented)\n  setInterval(() => {\n    // update last result display if needed\n    if (queries.length) updateLastResult(queries[queries.length-1]);\n    // update \"quick stats\" maybe show accuracy\n    const acc = leaveOneOutAccuracy();\n    // avoid heavy computation too often: only compute if points changes? Keep simple.\n    // display\n    // statsDiv.textContent = `Training points: ${points.length} — Queries: ${queries.length} — LOO acc: ${(acc*100).toFixed(1)}%`;\n    render();\n  }, 1000);\n\n  // initial render\n  render();\n\n  // Expose for debugging (console)\n  window._knnDemo = {\n    points, queries, classes, knnClassify\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}