{
  "id": "f181dcb2-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:21:50.897Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            margin: 20px 0;\n            text-align: center;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 10px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        .canvas-container {\n            display: flex;\n            justify-content: center;\n            margin: 20px 0;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .info-panel {\n            background-color: white;\n            padding: 15px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            margin-top: 20px;\n        }\n        .step-info {\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        .mst-edges {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n        }\n        .edge-item {\n            background-color: #e7f4e4;\n            padding: 5px 10px;\n            border-radius: 3px;\n            border-left: 3px solid #4CAF50;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Prim's Algorithm Visualization</h1>\n        \n        <div class=\"controls\">\n            <button id=\"generateGraph\">Generate New Graph</button>\n            <button id=\"startPrim\">Start Prim's Algorithm</button>\n            <button id=\"stepPrim\">Step Forward</button>\n            <button id=\"reset\">Reset</button>\n        </div>\n\n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n        </div>\n\n        <div class=\"info-panel\">\n            <div class=\"step-info\" id=\"stepInfo\">Ready to start Prim's algorithm</div>\n            <div>Minimum Spanning Tree Edges:</div>\n            <div class=\"mst-edges\" id=\"mstEdges\"></div>\n            <div>Total Weight: <span id=\"totalWeight\">0</span></div>\n        </div>\n    </div>\n\n    <script>\n        class PrimAlgorithm {\n            constructor() {\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.nodes = [];\n                this.edges = [];\n                this.mst = [];\n                this.visited = new Set();\n                this.currentStep = 0;\n                this.animationSpeed = 500;\n                this.animationId = null;\n                \n                this.initializeEventListeners();\n                this.generateRandomGraph();\n                this.drawGraph();\n            }\n\n            initializeEventListeners() {\n                document.getElementById('generateGraph').addEventListener('click', () => {\n                    this.generateRandomGraph();\n                    this.drawGraph();\n                });\n\n                document.getElementById('startPrim').addEventListener('click', () => {\n                    this.startPrimAlgorithm();\n                });\n\n                document.getElementById('stepPrim').addEventListener('click', () => {\n                    this.stepPrimAlgorithm();\n                });\n\n                document.getElementById('reset').addEventListener('click', () => {\n                    this.resetAlgorithm();\n                });\n            }\n\n            generateRandomGraph() {\n                this.nodes = [];\n                this.edges = [];\n                this.mst = [];\n                this.visited.clear();\n                this.currentStep = 0;\n\n                // Generate 8 random nodes\n                const nodeCount = 8;\n                for (let i = 0; i < nodeCount; i++) {\n                    this.nodes.push({\n                        id: i,\n                        x: 100 + Math.random() * 600,\n                        y: 100 + Math.random() * 400,\n                        label: String.fromCharCode(65 + i) // A, B, C, ...\n                    });\n                }\n\n                // Generate edges with random weights\n                for (let i = 0; i < nodeCount; i++) {\n                    for (let j = i + 1; j < nodeCount; j++) {\n                        // Randomly decide if there should be an edge (70% chance)\n                        if (Math.random() < 0.7) {\n                            const weight = Math.floor(Math.random() * 20) + 1;\n                            this.edges.push({\n                                from: i,\n                                to: j,\n                                weight: weight\n                            });\n                        }\n                    }\n                }\n            }\n\n            drawGraph() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.ctx.strokeStyle = '#ddd';\n                this.ctx.lineWidth = 2;\n                this.ctx.font = '12px Arial';\n                this.ctx.fillStyle = '#666';\n                \n                this.edges.forEach(edge => {\n                    const fromNode = this.nodes[edge.from];\n                    const toNode = this.nodes[edge.to];\n                    \n                    this.ctx.beginPath();\n                    this.ctx.moveTo(fromNode.x, fromNode.y);\n                    this.ctx.lineTo(toNode.x, toNode.y);\n                    this.ctx.stroke();\n                    \n                    // Draw weight\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    this.ctx.fillText(edge.weight.toString(), midX + 5, midY - 5);\n                });\n\n                // Highlight MST edges\n                this.ctx.strokeStyle = '#4CAF50';\n                this.ctx.lineWidth = 3;\n                this.mst.forEach(edge => {\n                    const fromNode = this.nodes[edge.from];\n                    const toNode = this.nodes[edge.to];\n                    \n                    this.ctx.beginPath();\n                    this.ctx.moveTo(fromNode.x, fromNode.y);\n                    this.ctx.lineTo(toNode.x, toNode.y);\n                    this.ctx.stroke();\n                    \n                    // Highlight weight\n                    const midX = (fromNode.x + toNode.x) / 2;\n                    const midY = (fromNode.y + toNode.y) / 2;\n                    this.ctx.fillStyle = '#4CAF50';\n                    this.ctx.fillText(edge.weight.toString(), midX + 5, midY - 5);\n                });\n\n                // Draw nodes\n                this.nodes.forEach((node, index) => {\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);\n                    \n                    if (this.visited.has(index)) {\n                        this.ctx.fillStyle = '#4CAF50';\n                    } else {\n                        this.ctx.fillStyle = '#2196F3';\n                    }\n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#333';\n                    this.ctx.lineWidth = 2;\n                    this.ctx.stroke();\n                    \n                    // Draw node label\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 14px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.label, node.x, node.y);\n                });\n\n                this.updateInfoPanel();\n            }\n\n            startPrimAlgorithm() {\n                if (this.animationId) {\n                    clearInterval(this.animationId);\n                }\n                \n                this.resetAlgorithm();\n                this.animationId = setInterval(() => {\n                    if (!this.stepPrimAlgorithm()) {\n                        clearInterval(this.animationId);\n                        this.animationId = null;\n                    }\n                }, this.animationSpeed);\n            }\n\n            stepPrimAlgorithm() {\n                if (this.currentStep === 0) {\n                    // Start with first node\n                    const startNode = 0;\n                    this.visited.add(startNode);\n                    document.getElementById('stepInfo').textContent = \n                        `Step ${++this.currentStep}: Starting with node ${this.nodes[startNode].label}`;\n                    this.drawGraph();\n                    return true;\n                }\n\n                if (this.visited.size === this.nodes.length) {\n                    document.getElementById('stepInfo').textContent = \n                        'Algorithm completed! Minimum Spanning Tree found.';\n                    return false;\n                }\n\n                // Find minimum weight edge connecting visited and unvisited nodes\n                let minEdge = null;\n                let minWeight = Infinity;\n\n                this.edges.forEach(edge => {\n                    const fromVisited = this.visited.has(edge.from);\n                    const toVisited = this.visited.has(edge.to);\n                    \n                    if ((fromVisited && !toVisited) || (!fromVisited && toVisited)) {\n                        if (edge.weight < minWeight) {\n                            minWeight = edge.weight;\n                            minEdge = edge;\n                        }\n                    }\n                });\n\n                if (minEdge) {\n                    // Add the edge to MST\n                    this.mst.push(minEdge);\n                    \n                    // Mark the new node as visited\n                    if (this.visited.has(minEdge.from)) {\n                        this.visited.add(minEdge.to);\n                    } else {\n                        this.visited.add(minEdge.from);\n                    }\n\n                    const fromNode = this.nodes[minEdge.from].label;\n                    const toNode = this.nodes[minEdge.to].label;\n                    \n                    document.getElementById('stepInfo').textContent = \n                        `Step ${++this.currentStep}: Added edge ${fromNode}-${toNode} (weight: ${minEdge.weight})`;\n                    \n                    this.drawGraph();\n                    return true;\n                }\n\n                document.getElementById('stepInfo').textContent = 'No more edges to add.';\n                return false;\n            }\n\n            resetAlgorithm() {\n                this.mst = [];\n                this.visited.clear();\n                this.currentStep = 0;\n                document.getElementById('stepInfo').textContent = 'Ready to start Prim\\'s algorithm';\n                this.drawGraph();\n            }\n\n            updateInfoPanel() {\n                const mstEdgesContainer = document.getElementById('mstEdges');\n                mstEdgesContainer.innerHTML = '';\n                \n                this.mst.forEach(edge => {\n                    const edgeElement = document.createElement('div');\n                    edgeElement.className = 'edge-item';\n                    edgeElement.textContent = \n                        `${this.nodes[edge.from].label}-${this.nodes[edge.to].label} (${edge.weight})`;\n                    mstEdgesContainer.appendChild(edgeElement);\n                });\n\n                const totalWeight = this.mst.reduce((sum, edge) => sum + edge.weight, 0);\n                document.getElementById('totalWeight').textContent = totalWeight;\n            }\n        }\n\n        // Initialize the Prim's algorithm visualization when the page loads\n        document.addEventListener('DOMContentLoaded', () => {\n            new PrimAlgorithm();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}