{
  "id": "d7b3ec71-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:59.015Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra’s Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  header {\n    background: #20232a;\n    color: white;\n    padding: 10px 20px;\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    flex-grow: 1;\n    background: #f0f0f0;\n  }\n  #graph-container {\n    flex: 2;\n    position: relative;\n    background: white;\n    border-right: 2px solid #ccc;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n  #controls {\n    flex: 1;\n    padding: 20px;\n    box-sizing: border-box;\n    background: #fafafa;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    margin-bottom: 5px;\n    font-weight: bold;\n  }\n  select, button {\n    width: 100%;\n    padding: 8px;\n    font-size: 1rem;\n  }\n  #log {\n    margin-top: 20px;\n    height: 250px;\n    overflow-y: auto;\n    background: #222;\n    color: #eee;\n    font-family: monospace;\n    padding: 10px;\n    border-radius: 4px;\n    white-space: pre-wrap;\n  }\n  .node {\n    cursor: pointer;\n    transition: fill 0.3s, stroke 0.3s;\n  }\n  .node circle {\n    stroke: #333;\n    stroke-width: 2px;\n    fill: #61dafb;\n    transition: fill 0.3s;\n  }\n  .node text {\n    pointer-events: none;\n    user-select: none;\n    font-weight: bold;\n    fill: #222;\n  }\n  .edge {\n    stroke: #999;\n    stroke-width: 2px;\n    fill: none;\n    marker-end: url(#arrowhead);\n    transition: stroke 0.3s;\n  }\n  .edge-label {\n    fill: #666;\n    font-size: 0.8rem;\n    user-select: none;\n  }\n  .visited circle {\n    fill: #95d6a4;\n  }\n  .current circle {\n    fill: #f9d976;\n    stroke: #f39c12;\n    stroke-width: 4px;\n  }\n  .path-edge {\n    stroke: #f39c12;\n    stroke-width: 4px;\n  }\n  .final-node circle {\n    fill: #f87171;\n    stroke: #c53030;\n    stroke-width: 4px;\n  }\n  button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n  footer {\n    text-align: center;\n    padding: 8px;\n    font-size: 0.8rem;\n    background: #20232a;\n    color: white;\n  }\n\n</style>\n</head>\n<body>\n<header>\n  <h1>Dijkstra’s Algorithm Visualization</h1>\n</header>\n<div id=\"container\">\n  <div id=\"graph-container\">\n    <svg id=\"graph\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 600\" aria-label=\"Graph visualization\"></svg>\n  </div>\n  <div id=\"controls\">\n    <h2>Controls</h2>\n    <label for=\"startNode\">Start Node:</label>\n    <select id=\"startNode\"></select>\n\n    <label for=\"endNode\">End Node (optional):</label>\n    <select id=\"endNode\">\n      <option value=\"\">None (show all shortest distances)</option>\n    </select>\n\n    <button id=\"startBtn\">Start Algorithm</button>\n    <button id=\"stepBtn\" disabled>Next Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n\n    <div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n  </div>\n</div>\n<footer>\n  Created by ChatGPT &mdash; Demonstration of Dijkstra’s Algorithm\n</footer>\n\n<script>\n// Hardcoded graph data (nodes and edges with weights)\nconst nodes = [\n  {id: 'A', x: 150, y: 100},\n  {id: 'B', x: 400, y: 80},\n  {id: 'C', x: 650, y: 120},\n  {id: 'D', x: 200, y: 300},\n  {id: 'E', x: 450, y: 300},\n  {id: 'F', x: 650, y: 320},\n  {id: 'G', x: 350, y: 480},\n  {id: 'H', x: 600, y: 500},\n];\n\nconst edges = [\n  {from: 'A', to: 'B', weight: 4},\n  {from: 'A', to: 'D', weight: 2},\n  {from: 'B', to: 'C', weight: 3},\n  {from: 'B', to: 'E', weight: 2},\n  {from: 'C', to: 'F', weight: 4},\n  {from: 'D', to: 'E', weight: 3},\n  {from: 'D', to: 'G', weight: 4},\n  {from: 'E', to: 'F', weight: 1},\n  {from: 'E', to: 'G', weight: 1},\n  {from: 'F', to: 'H', weight: 2},\n  {from: 'G', to: 'H', weight: 3},\n];\n\n// Bidirectional edges for undirected graph\n// We'll add reverse edges too for convenience in adjacency list\nconst allEdges = [];\nedges.forEach(e => {\n  allEdges.push(e);\n  allEdges.push({from: e.to, to: e.from, weight: e.weight});\n});\n\n// Build adjacency list\nconst adjacencyList = {};\nnodes.forEach(n => {\n  adjacencyList[n.id] = [];\n});\nallEdges.forEach(e => {\n  adjacencyList[e.from].push({to: e.to, weight: e.weight});\n});\n\n// Globals to manage state\nlet distances = {};\nlet previous = {};\nlet visited = {};\nlet unvisitedSet = new Set();\nlet currentNode = null;\nlet finished = false;\nlet endNode = null;\n\nconst svg = document.getElementById('graph');\nconst logDiv = document.getElementById('log');\n\nconst startSelect = document.getElementById('startNode');\nconst endSelect = document.getElementById('endNode');\nconst startBtn = document.getElementById('startBtn');\nconst stepBtn = document.getElementById('stepBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nfunction log(msg) {\n  logDiv.textContent += msg + '\\n';\n  logDiv.scrollTop = logDiv.scrollHeight;\n}\n\nfunction clearLog() {\n  logDiv.textContent = '';\n}\n\n// Populate start and end selects\nfunction populateSelects() {\n  nodes.forEach(n => {\n    const optionStart = document.createElement('option');\n    optionStart.value = n.id;\n    optionStart.textContent = n.id;\n    startSelect.appendChild(optionStart);\n\n    const optionEnd = document.createElement('option');\n    optionEnd.value = n.id;\n    optionEnd.textContent = n.id;\n    endSelect.appendChild(optionEnd);\n  });\n}\n\n// Draw arrowhead marker for edges\nfunction defineArrowMarker() {\n  const ns = \"http://www.w3.org/2000/svg\";\n  const marker = document.createElementNS(ns, 'marker');\n  marker.setAttribute('id', 'arrowhead');\n  marker.setAttribute('markerWidth', '10');\n  marker.setAttribute('markerHeight', '7');\n  marker.setAttribute('refX', '10');\n  marker.setAttribute('refY', '3.5');\n  marker.setAttribute('orient', 'auto');\n  marker.setAttribute('markerUnits', 'strokeWidth');\n\n  const path = document.createElementNS(ns, 'path');\n  path.setAttribute('d', 'M0,0 L10,3.5 L0,7 Z');\n  path.setAttribute('fill', '#999');\n  marker.appendChild(path);\n\n  const defs = document.createElementNS(ns, 'defs');\n  defs.appendChild(marker);\n  svg.appendChild(defs);\n}\n\n// Clear SVG\nfunction clearSVG() {\n  while (svg.firstChild) {\n    svg.removeChild(svg.firstChild);\n  }\n  defineArrowMarker();\n}\n\n// Draw edges\nfunction drawEdges(highlightEdges = new Set()) {\n  const ns = \"http://www.w3.org/2000/svg\";\n  // Draw edges below nodes\n  edges.forEach(({from, to, weight}, i) => {\n    const fromNode = nodes.find(n => n.id === from);\n    const toNode = nodes.find(n => n.id === to);\n    // Draw line with some offset from center to keep arrow visible\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const dist = Math.sqrt(dx*dx + dy*dy);\n    const offset = 25;\n    const startX = fromNode.x + (dx/dist)*offset;\n    const startY = fromNode.y + (dy/dist)*offset;\n    const endX = toNode.x - (dx/dist)*offset;\n    const endY = toNode.y - (dy/dist)*offset;\n\n    const line = document.createElementNS(ns, 'line');\n    line.setAttribute('x1', startX);\n    line.setAttribute('y1', startY);\n    line.setAttribute('x2', endX);\n    line.setAttribute('y2', endY);\n    line.setAttribute('class', 'edge');\n\n    // Highlight if edge is part of shortest path tree or current path\n    if (highlightEdges.has(from + '->' + to) || highlightEdges.has(to + '->' + from)) {\n      line.classList.add('path-edge');\n      line.setAttribute('stroke', '#f39c12');\n      line.setAttribute('stroke-width', 4);\n      line.removeAttribute('marker-end'); // remove arrow on highlighted path edges to keep clean\n    } else {\n      line.setAttribute('stroke', '#999');\n      line.setAttribute('stroke-width', 2);\n      line.setAttribute('marker-end', 'url(#arrowhead)');\n    }\n\n    svg.appendChild(line);\n\n    // Edge label\n    const label = document.createElementNS(ns, 'text');\n    label.setAttribute('class', 'edge-label');\n    label.setAttribute('x', (startX + endX) / 2);\n    label.setAttribute('y', (startY + endY) / 2 - 5);\n    label.textContent = weight;\n    svg.appendChild(label);\n  });\n}\n\nfunction drawNodes() {\n  const ns = \"http://www.w3.org/2000/svg\";\n\n  nodes.forEach(n => {\n    const group = document.createElementNS(ns, 'g');\n    group.setAttribute('class', 'node');\n    group.setAttribute('tabindex', '0');\n    group.setAttribute('aria-label', `Node ${n.id}`);\n    group.dataset.id = n.id;\n\n    const circle = document.createElementNS(ns, 'circle');\n    circle.setAttribute('cx', n.x);\n    circle.setAttribute('cy', n.y);\n    circle.setAttribute('r', 20);\n\n    const text = document.createElementNS(ns, 'text');\n    text.setAttribute('x', n.x);\n    text.setAttribute('y', n.y + 6);\n    text.setAttribute('text-anchor', 'middle');\n    text.textContent = n.id;\n\n    group.appendChild(circle);\n    group.appendChild(text);\n    svg.appendChild(group);\n  });\n}\n\n// Update nodes colors depending on state\nfunction updateNodes() {\n  const nodeGroups = svg.querySelectorAll('.node');\n  nodeGroups.forEach(g => {\n    const id = g.dataset.id;\n    g.classList.remove('visited', 'current', 'final-node');\n    if (id === currentNode) {\n      g.classList.add('current');\n    } else if (visited[id]) {\n      g.classList.add('visited');\n    }\n    if (finished && endNode && id === endNode) {\n      g.classList.add('final-node');\n    }\n    // Show distance as tooltip (title)\n    const circle = g.querySelector('circle');\n    const dist = distances[id];\n    if (dist === Infinity) {\n      circle.setAttribute('title', 'Distance: ∞');\n    } else {\n      circle.setAttribute('title', `Distance: ${dist}`);\n    }\n  });\n}\n\n// Highlight edges that form shortest path tree or path\nfunction getHighlightEdges() {\n  const edgesSet = new Set();\n  for (const [node, prev] of Object.entries(previous)) {\n    if (prev) {\n      edgesSet.add(prev + '->' + node);\n    }\n  }\n  if (finished && endNode) {\n    // Show shortest path edges from start to end\n    let pathNode = endNode;\n    while (previous[pathNode]) {\n      const p = previous[pathNode];\n      edgesSet.add(p + '->' + pathNode);\n      pathNode = p;\n    }\n  }\n  return edgesSet;\n}\n\n// Initialize algorithm variables & state\nfunction initialize(start) {\n  distances = {};\n  previous = {};\n  visited = {};\n  unvisitedSet = new Set();\n\n  nodes.forEach(n => {\n    distances[n.id] = Infinity;\n    previous[n.id] = null;\n    visited[n.id] = false;\n    unvisitedSet.add(n.id);\n  });\n\n  distances[start] = 0;\n  currentNode = null;\n  finished = false;\n  endNode = endSelect.value || null;\n  clearLog();\n  log(`Algorithm initialized with start node ${start}.`);\n}\n\n// Get unvisited node with smallest distance\nfunction getNextNode() {\n  let minDist = Infinity;\n  let minNode = null;\n  unvisitedSet.forEach(node => {\n    if (distances[node] < minDist) {\n      minDist = distances[node];\n      minNode = node;\n    }\n  });\n  return minNode;\n}\n\n// Perform one step of Dijkstra's Algorithm\nfunction step() {\n  if (finished) return;\n\n  if (currentNode === null) {\n    currentNode = getNextNode();\n    if (currentNode === null) {\n      finished = true;\n      log(\"All nodes visited, algorithm finished.\");\n      return;\n    }\n    log(`Selected starting node ${currentNode} with distance 0.`);\n  } else {\n    // Mark current node visited\n    visited[currentNode] = true;\n    unvisitedSet.delete(currentNode);\n    log(`Visiting node ${currentNode} with current distance ${distances[currentNode]}.`);\n\n    // Update distances of neighbors\n    adjacencyList[currentNode].forEach(({to, weight}) => {\n      if (!visited[to]) {\n        const newDist = distances[currentNode] + weight;\n        if (newDist < distances[to]) {\n          distances[to] = newDist;\n          previous[to] = currentNode;\n          log(`Updated distance of node ${to} to ${newDist} (via ${currentNode}).`);\n        } else {\n          log(`Node ${to} not updated; current distance ${distances[to]} <= new distance ${newDist}.`);\n        }\n      }\n    });\n\n    // Select next node\n    currentNode = getNextNode();\n    if (currentNode === null) {\n      finished = true;\n      log(\"All reachable nodes visited, algorithm finished.\");\n    } else {\n      log(`Next node to visit: ${currentNode} with distance ${distances[currentNode]}.`);\n    }\n  }\n\n  updateVisualization();\n}\n\nfunction updateVisualization() {\n  clearSVG();\n  const highlightEdges = getHighlightEdges();\n  drawEdges(highlightEdges);\n  drawNodes();\n  updateNodes();\n\n  // Show final shortest path if finished and endNode selected\n  if (finished && endNode) {\n    let path = [];\n    let stepNode = endNode;\n    if (distances[endNode] === Infinity) {\n      log(`No path to node ${endNode} found.`);\n    } else {\n      while (stepNode !== null) {\n        path.unshift(stepNode);\n        stepNode = previous[stepNode];\n      }\n      log(`Shortest path to node ${endNode}: ${path.join(' -> ')} (total cost: ${distances[endNode]})`);\n    }\n  }\n}\n\nfunction startAlgorithm() {\n  const startNodeId = startSelect.value;\n  if (!startNodeId) {\n    alert('Please select a start node.');\n    return;\n  }\n  initialize(startNodeId);\n  updateVisualization();\n\n  startBtn.disabled = true;\n  stepBtn.disabled = false;\n  resetBtn.disabled = false;\n}\n\nfunction resetAlgorithm() {\n  distances = {};\n  previous = {};\n  visited = {};\n  unvisitedSet = new Set();\n  currentNode = null;\n  finished = false;\n  clearLog();\n\n  startBtn.disabled = false;\n  stepBtn.disabled = true;\n  resetBtn.disabled = true;\n\n  clearSVG();\n  drawEdges();\n  drawNodes();\n}\n\nfunction onEndNodeChange() {\n  // Nothing special needed here for now, just allow selection\n}\n\n// Initialization\nfunction init() {\n  populateSelects();\n  clearSVG();\n  drawEdges();\n  drawNodes();\n\n  startBtn.addEventListener('click', startAlgorithm);\n  stepBtn.addEventListener('click', step);\n  resetBtn.addEventListener('click', resetAlgorithm);\n  endSelect.addEventListener('change', onEndNodeChange);\n\n  // Initialize buttons states\n  stepBtn.disabled = true;\n  resetBtn.disabled = true;\n}\n\ninit();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}