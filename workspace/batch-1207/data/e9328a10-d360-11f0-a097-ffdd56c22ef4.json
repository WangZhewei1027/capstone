{
  "id": "e9328a10-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:51.270Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Hash Table Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724; --card:#0b1220; --accent:#4fd1c5; --muted:#94a3b8; --danger:#ff6b6b;\n      --ok:#7ee787; --glass: rgba(255,255,255,0.03);\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #071220 100%);color:#e6eef6}\n    .wrap{max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6)}\n    header{display:flex;align-items:center;gap:16px;padding-bottom:16px;border-bottom:1px solid rgba(255,255,255,0.03)}\n    h1{font-size:20px;margin:0}\n    .controls{display:flex;gap:12px;flex-wrap:wrap;padding:14px 0}\n    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}\n    .col{display:flex;flex-direction:column}\n    input[type=\"text\"], select, input[type=\"number\"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.05);background:var(--glass);color:var(--muted);min-width:160px}\n    button{background:var(--accent);border:0;padding:8px 12px;border-radius:10px;color:#022;cursor:pointer;font-weight:600}\n    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}\n    .row{display:flex;gap:12px;align-items:flex-end}\n    .vis{margin-top:18px;padding:16px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));min-height:220px}\n    .buckets{display:flex;gap:8px;flex-wrap:wrap}\n    .bucket{width:80px;border-radius:8px;padding:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);text-align:center;position:relative}\n    .idx{position:absolute;left:6px;top:6px;font-size:11px;color:var(--muted)}\n    .cells{margin-top:16px;display:flex;flex-direction:column;gap:6px;align-items:center}\n    .node{padding:6px 8px;border-radius:8px;background:#071831;color:#cfeff0;border:1px solid rgba(255,255,255,0.03);min-width:40px}\n    .empty{opacity:0.4;color:var(--muted);font-size:13px;padding:10px 0}\n    .log{margin-top:14px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.22);max-height:160px;overflow:auto;font-size:13px;color:var(--muted)}\n    .meta{display:flex;gap:12px;align-items:center;margin-left:auto}\n    .badge{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.02)}\n    .highlight{box-shadow:0 0 0 3px rgba(79,209,197,0.12) inset}\n    .probe{outline:3px solid rgba(125, 250, 180, 0.12);transition:all .22s}\n    .found{animation:found 900ms ease}\n    @keyframes found{0%{transform:scale(1)}40%{transform:scale(1.05)}100%{transform:scale(1)}}\n    .tomb{background:#2b2f36;color:#bbb}\n    .controls small{display:block;color:var(--muted);margin-top:6px;font-size:12px}\n    footer{margin-top:14px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}\n    .legend{display:flex;gap:8px;align-items:center}\n    .legend div{display:flex;gap:6px;align-items:center}\n    .sw{width:16px;height:12px;border-radius:4px;background:var(--accent);box-shadow:0 0 0 3px rgba(79,209,197,0.08) inset}\n    @media (max-width:880px){.buckets{justify-content:center}.meta{display:none}}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <h1>Hash Table Visualizer</h1>\n      <div class=\"meta\">\n        <div class=\"badge\">Count: <span id=\"count\">0</span></div>\n        <div class=\"badge\">Capacity: <span id=\"cap\">8</span></div>\n        <div class=\"badge\">Load: <span id=\"load\">0%</span></div>\n      </div>\n    </header>\n\n    <section class=\"controls\">\n      <div class=\"col\" style=\"flex:1;min-width:260px\">\n        <label>Key (string or number)</label>\n        <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. Alice or 42\" />\n      </div>\n\n      <div class=\"col\">\n        <label>Choose collision handling</label>\n        <select id=\"mode\">\n          <option value=\"chaining\">Separate chaining (linked lists)</option>\n          <option value=\"linear\">Open addressing (linear probing)</option>\n        </select>\n      </div>\n\n      <div class=\"col\">\n        <label>Hash function</label>\n        <select id=\"hashFn\">\n          <option value=\"djb2\">djb2 (strings), modulo for numbers</option>\n          <option value=\"poly\">Polynomial rolling</option>\n          <option value=\"sum\">Sum char codes</option>\n        </select>\n      </div>\n\n      <div class=\"col\">\n        <label>Table capacity</label>\n        <select id=\"capacitySelect\">\n          <option>8</option><option>16</option><option>32</option><option>64</option>\n        </select>\n        <small>Changing capacity resets the table</small>\n      </div>\n\n      <div class=\"col\" style=\"min-width:200px\">\n        <div class=\"row\">\n          <button id=\"insertBtn\">Insert</button>\n          <button id=\"searchBtn\" class=\"secondary\">Search</button>\n          <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n        </div>\n        <div style=\"margin-top:8px\" class=\"row\">\n          <button id=\"randBtn\" class=\"secondary\">Insert Random</button>\n          <button id=\"bulkBtn\" class=\"secondary\">Bulk Insert 6</button>\n          <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"col\">\n        <label>Auto-resize threshold (load factor %)</label>\n        <input id=\"threshold\" type=\"number\" value=\"70\" min=\"10\" max=\"95\" />\n        <small>When exceeded, table will resize (double)</small>\n      </div>\n    </section>\n\n    <section class=\"vis\">\n      <div class=\"buckets\" id=\"buckets\"></div>\n      <div class=\"log\" id=\"log\"></div>\n    </section>\n\n    <footer>\n      Tip: Try strings and numbers. Switch collision handling to see chaining vs linear probing behavior. Click Log entries to scroll.\n      <div style=\"margin-top:8px\" class=\"legend\">\n        <div><div class=\"sw\"></div> Bucket highlight</div>\n        <div><div style=\"width:16px;height:12px;background:#2b2f36;border-radius:4px;margin-left:2px\"></div> Tombstone (deleted)</div>\n      </div>\n    </footer>\n  </div>\n\n<script>\n/*\n  Hash Table Visualizer\n  - Supports separate chaining and linear probing (open addressing)\n  - Several simple hash functions for strings\n  - Animates probing and highlights buckets\n  - Auto-resize when load factor exceeds threshold\n*/\n\n(function(){\n  // Utilities\n  const el = id => document.getElementById(id);\n  const log = (msg, strong=false) => {\n    const out = el('log');\n    const div = document.createElement('div');\n    div.style.padding = '6px 4px';\n    div.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';\n    div.innerHTML = (strong?'<b style=\"color:var(--accent)\">'+msg+'</b>':msg);\n    out.prepend(div);\n  };\n\n  function isNumberString(s){\n    return /^-?\\d+(\\.\\d+)?$/.test(String(s).trim());\n  }\n\n  function toKey(raw){\n    const s = String(raw);\n    if(isNumberString(s)) {\n      const n = Number(s);\n      return {type:'number', value:n, raw:s};\n    }\n    return {type:'string', value:s, raw:s};\n  }\n\n  // Hash functions\n  const hashFns = {\n    djb2(key, cap){\n      // djb2 for strings; for numbers use modulo\n      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;\n      let str = key.value;\n      let h = 5381;\n      for(let i=0;i<str.length;i++) h = ((h<<5) + h) + str.charCodeAt(i);\n      return Math.abs(h) % cap;\n    },\n    poly(key, cap){\n      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;\n      const p = 31;\n      let h = 0;\n      for(let i=0;i<key.value.length;i++){\n        h = (h * p + key.value.charCodeAt(i)) % 1_000_000_007;\n      }\n      return Math.abs(h) % cap;\n    },\n    sum(key, cap){\n      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;\n      let s = 0;\n      for(let ch of key.value) s += ch.charCodeAt(0);\n      return Math.abs(s) % cap;\n    }\n  };\n\n  // Hash Table implementation (visual-friendly)\n  class HashTable {\n    constructor(capacity=8, mode='chaining', hashName='djb2', onUpdate = ()=>{}){\n      this.capacity = capacity;\n      this.count = 0;\n      this.mode = mode;\n      this.hashName = hashName;\n      this.onUpdate = onUpdate;\n      this.tombstone = {__tomb: true};\n      this.clear();\n    }\n\n    clear(){\n      if(this.mode === 'chaining'){\n        this.table = new Array(this.capacity).fill(0).map(()=>[]);\n      }else{\n        this.table = new Array(this.capacity).fill(null);\n      }\n      this.count = 0;\n      this.onUpdate();\n    }\n\n    _hash(key){ return hashFns[this.hashName](key, this.capacity); }\n\n    contains(rawKey){\n      const key = toKey(rawKey);\n      if(this.mode === 'chaining'){\n        const idx = this._hash(key);\n        return this.table[idx].some(e => e.raw === key.raw);\n      }else{\n        let idx = this._hash(key);\n        for(let i=0;i<this.capacity;i++){\n          const j = (idx + i) % this.capacity;\n          const cell = this.table[j];\n          if(cell === null) return false;\n          if(cell === this.tombstone) continue;\n          if(cell.raw === key.raw) return true;\n        }\n        return false;\n      }\n    }\n\n    // returns an animation plan (array of steps) for UI to play\n    planInsert(rawKey){\n      const key = toKey(rawKey);\n      const ops = [];\n      const idx = this._hash(key);\n      ops.push({type:'compute', idx, key});\n      if(this.mode === 'chaining'){\n        // highlight bucket, then append node\n        ops.push({type:'bucket', idx});\n        const bucket = this.table[idx];\n        const exists = bucket.some(e => e.raw === key.raw);\n        if(exists){\n          ops.push({type:'exists', idx});\n        } else {\n          ops.push({type:'insert_chain', idx, key});\n        }\n      } else {\n        // linear probing plan\n        let start = idx;\n        for(let step=0; step<this.capacity; step++){\n          const j = (start + step) % this.capacity;\n          ops.push({type:'probe', idx:j, step});\n          const cell = this.table[j];\n          if(cell === null || cell === this.tombstone){\n            ops.push({type:'place', idx:j, key});\n            break;\n          }\n          if(cell.raw === key.raw){\n            ops.push({type:'exists', idx:j});\n            break;\n          }\n        }\n      }\n      return ops;\n    }\n\n    // similarly planSearch\n    planSearch(rawKey){\n      const key = toKey(rawKey);\n      const ops = [];\n      const idx = this._hash(key);\n      ops.push({type:'compute', idx, key});\n      if(this.mode === 'chaining'){\n        ops.push({type:'bucket', idx});\n        const bucket = this.table[idx];\n        for(let i=0;i<bucket.length;i++){\n          ops.push({type:'check_chain', idx, pos:i, entry:bucket[i]});\n          if(bucket[i].raw === key.raw){\n            ops.push({type:'found', idx, pos:i});\n            return ops;\n          }\n        }\n        ops.push({type:'notfound', idx});\n      }else{\n        let start = idx;\n        for(let step=0; step<this.capacity; step++){\n          const j = (start + step) % this.capacity;\n          ops.push({type:'probe', idx:j, step});\n          const cell = this.table[j];\n          if(cell === null){\n            ops.push({type:'notfound', idx:j});\n            break;\n          }\n          if(cell === this.tombstone) continue;\n          if(cell.raw === key.raw){\n            ops.push({type:'found', idx:j});\n            break;\n          }\n        }\n      }\n      return ops;\n    }\n\n    planDelete(rawKey){\n      const key = toKey(rawKey);\n      const ops = this.planSearch(rawKey);\n      // append delete action if found\n      ops.push({type:'delete_attempt', key});\n      return ops;\n    }\n\n    // The actual operations (no animation). Return status and message.\n    insert(rawKey){\n      const key = toKey(rawKey);\n      if(this.contains(key.raw)){\n        return {ok:false, msg:'Key already present'};\n      }\n      if(this.mode === 'chaining'){\n        const idx = this._hash(key);\n        this.table[idx].push(key);\n        this.count++;\n      } else {\n        let idx = this._hash(key);\n        for(let i=0;i<this.capacity;i++){\n          const j = (idx + i) % this.capacity;\n          const cell = this.table[j];\n          if(cell === null || cell === this.tombstone){\n            this.table[j] = key;\n            this.count++;\n            break;\n          }\n        }\n      }\n      this._maybeResize();\n      this.onUpdate();\n      return {ok:true, msg:'Inserted'};\n    }\n\n    search(rawKey){\n      return this.contains(rawKey);\n    }\n\n    delete(rawKey){\n      const key = toKey(rawKey);\n      if(this.mode === 'chaining'){\n        const idx = this._hash(key);\n        const bucket = this.table[idx];\n        const i = bucket.findIndex(e => e.raw === key.raw);\n        if(i >= 0){\n          bucket.splice(i,1);\n          this.count--;\n          this.onUpdate();\n          return {ok:true, msg:'Deleted'};\n        } else {\n          return {ok:false, msg:'Not found'};\n        }\n      } else {\n        let idx = this._hash(key);\n        for(let i=0;i<this.capacity;i++){\n          const j = (idx + i) % this.capacity;\n          const cell = this.table[j];\n          if(cell === null) return {ok:false, msg:'Not found'};\n          if(cell === this.tombstone) continue;\n          if(cell.raw === key.raw){\n            this.table[j] = this.tombstone;\n            this.count--;\n            this.onUpdate();\n            return {ok:true, msg:'Deleted (marked tombstone)'};\n          }\n        }\n        return {ok:false, msg:'Not found'};\n      }\n    }\n\n    _maybeResize(){\n      const load = Math.round(this.count / this.capacity * 100);\n      const threshold = Number(el('threshold').value || 70);\n      if(load > threshold){\n        // double capacity\n        const newCap = this.capacity * 2;\n        log(`Auto-resize: capacity ${this.capacity} → ${newCap}`, true);\n        const old = this.table;\n        this.capacity = newCap;\n        if(this.mode === 'chaining') this.table = new Array(this.capacity).fill(0).map(()=>[]);\n        else this.table = new Array(this.capacity).fill(null);\n        const all = [];\n        if(this.mode === 'chaining'){\n          for(const b of old) for(const e of b) all.push(e.raw);\n        } else {\n          for(const c of old) if(c && c !== this.tombstone) all.push(c.raw);\n        }\n        this.count = 0;\n        for(const k of all) this.insert(k);\n      }\n    }\n  }\n\n  // UI wiring\n  const bucketContainer = el('buckets');\n  const keyInput = el('keyInput');\n  const insertBtn = el('insertBtn');\n  const searchBtn = el('searchBtn');\n  const deleteBtn = el('deleteBtn');\n  const clearBtn = el('clearBtn');\n  const randBtn = el('randBtn');\n  const bulkBtn = el('bulkBtn');\n  const modeSelect = el('mode');\n  const hashSelect = el('hashFn');\n  const capSelect = el('capacitySelect');\n  const countEl = el('count');\n  const capEl = el('cap');\n  const loadEl = el('load');\n\n  let table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);\n\n  function redraw(){\n    // update meta\n    countEl.textContent = table.count;\n    capEl.textContent = table.capacity;\n    const load = Math.round(table.count / table.capacity * 100);\n    loadEl.textContent = load + '%';\n\n    // draw buckets\n    bucketContainer.innerHTML = '';\n    for(let i=0;i<table.capacity;i++){\n      const b = document.createElement('div');\n      b.className = 'bucket';\n      b.dataset.idx = i;\n      const idx = document.createElement('div');\n      idx.className = 'idx';\n      idx.textContent = i;\n      b.appendChild(idx);\n\n      const cells = document.createElement('div');\n      cells.className = 'cells';\n      if(table.mode === 'chaining'){\n        const bucket = table.table[i];\n        if(bucket.length === 0){\n          const e = document.createElement('div');\n          e.className = 'empty';\n          e.textContent = 'empty';\n          cells.appendChild(e);\n        } else {\n          for(const ent of bucket){\n            const n = document.createElement('div');\n            n.className = 'node';\n            n.textContent = ent.raw;\n            cells.appendChild(n);\n          }\n        }\n      } else {\n        const cell = table.table[i];\n        if(cell === null){\n          const e = document.createElement('div');\n          e.className = 'empty';\n          e.style.padding = '10px 0';\n          e.textContent = 'empty';\n          cells.appendChild(e);\n        } else if(cell === table.tombstone){\n          const t = document.createElement('div');\n          t.className = 'node tomb';\n          t.textContent = 'deleted';\n          cells.appendChild(t);\n        } else {\n          const n = document.createElement('div');\n          n.className = 'node';\n          n.textContent = cell.raw;\n          cells.appendChild(n);\n        }\n      }\n      b.appendChild(cells);\n      b.addEventListener('click', ()=> logBucket(i));\n      bucketContainer.appendChild(b);\n    }\n  }\n\n  function logBucket(i){\n    if(table.mode === 'chaining'){\n      const b = table.table[i];\n      log(`Bucket ${i}: [ ${b.map(x=>x.raw).join(', ')} ]`);\n    } else {\n      const c = table.table[i];\n      if(c === null) log(`Bucket ${i}: empty`);\n      else if(c === table.tombstone) log(`Bucket ${i}: tombstone`);\n      else log(`Bucket ${i}: ${c.raw}`);\n    }\n  }\n\n  // Visual animator: takes plan and plays steps with highlights\n  let animating = false;\n  async function playPlan(plan){\n    if(animating) return;\n    animating = true;\n    clearHighlights();\n\n    for(const step of plan){\n      clearHighlights();\n      if(step.type === 'compute'){\n        log(`Hash(${step.key.raw}) → index ${step.idx}`);\n        highlightBucket(step.idx,'highlight');\n        await sleep(450);\n      } else if(step.type === 'bucket'){\n        highlightBucket(step.idx, 'probe');\n        await sleep(450);\n      } else if(step.type === 'insert_chain'){\n        highlightBucket(step.idx,'probe');\n        await sleep(350);\n        table.insert(step.key.raw);\n        redraw();\n        log(`Inserted ${step.key.raw} into bucket ${step.idx}`, true);\n        const b = getBucketEl(step.idx);\n        if(b) animNode(b, step.key.raw);\n        await sleep(500);\n      } else if(step.type === 'probe'){\n        highlightBucket(step.idx,'probe');\n        log(`Probing index ${step.idx}`);\n        await sleep(350);\n      } else if(step.type === 'place'){\n        highlightBucket(step.idx,'probe');\n        await sleep(250);\n        table.insert(step.key.raw);\n        redraw();\n        log(`Placed ${step.key.raw} at index ${step.idx}`, true);\n        const b = getBucketEl(step.idx);\n        if(b) animNode(b, step.key.raw);\n        await sleep(500);\n      } else if(step.type === 'exists'){\n        highlightBucket(step.idx,'found');\n        log(`Key already exists at ${step.idx}`);\n        await sleep(600);\n      } else if(step.type === 'check_chain'){\n        const b = getBucketEl(step.idx);\n        const nodes = b ? b.querySelectorAll('.node') : [];\n        if(nodes[step.pos]){\n          nodes[step.pos].classList.add('probe');\n        }\n        await sleep(380);\n      } else if(step.type === 'found'){\n        highlightBucket(step.idx,'found');\n        log(`Found key at ${step.idx}`, true);\n        await sleep(600);\n      } else if(step.type === 'notfound'){\n        highlightBucket(step.idx,'highlight');\n        log(`Not found (stopped at ${step.idx})`);\n        await sleep(500);\n      } else if(step.type === 'delete_attempt'){\n        // perform deletion and log result\n        const res = table.delete(step.key.raw);\n        redraw();\n        if(res.ok) log(res.msg, true);\n        else log(res.msg);\n        await sleep(300);\n      }\n    }\n\n    clearHighlights();\n    animating = false;\n  }\n\n  function animNode(bucketEl, label){\n    // find last node containing label and add pulse\n    const nodes = [...bucketEl.querySelectorAll('.node')].filter(n=>n.textContent===label);\n    if(nodes.length) nodes[nodes.length-1].classList.add('found');\n    setTimeout(()=>{ for(const n of nodes) n.classList.remove('found'); }, 800);\n  }\n\n  function getBucketEl(i){\n    return bucketContainer.querySelector('.bucket[data-idx=\"'+i+'\"]');\n  }\n\n  function highlightBucket(i, cls='highlight'){\n    const elb = getBucketEl(i);\n    if(elb) elb.classList.add(cls);\n  }\n\n  function clearHighlights(){\n    const nodes = bucketContainer.querySelectorAll('.bucket');\n    nodes.forEach(n => { n.classList.remove('highlight','probe','found'); const inner = n.querySelectorAll('.node'); inner.forEach(x=>x.classList.remove('probe')); });\n  }\n\n  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }\n\n  // UI events\n  insertBtn.addEventListener('click', async ()=>{\n    const key = keyInput.value.trim();\n    if(!key){ alert('Enter a key'); return; }\n    table.hashName = hashSelect.value;\n    table.mode = modeSelect.value;\n    const plan = table.planInsert(key);\n    await playPlan(plan);\n  });\n\n  searchBtn.addEventListener('click', async ()=>{\n    const key = keyInput.value.trim();\n    if(!key){ alert('Enter a key'); return; }\n    table.hashName = hashSelect.value;\n    table.mode = modeSelect.value;\n    const plan = table.planSearch(key);\n    await playPlan(plan);\n  });\n\n  deleteBtn.addEventListener('click', async ()=>{\n    const key = keyInput.value.trim();\n    if(!key){ alert('Enter a key'); return; }\n    table.hashName = hashSelect.value;\n    table.mode = modeSelect.value;\n    const plan = table.planDelete(key);\n    await playPlan(plan);\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);\n    redraw();\n    log('Table cleared', true);\n  });\n\n  randBtn.addEventListener('click', async ()=>{\n    const key = randomKey();\n    keyInput.value = key;\n    const plan = table.planInsert(key);\n    await playPlan(plan);\n  });\n\n  bulkBtn.addEventListener('click', async ()=>{\n    const arr = [];\n    for(let i=0;i<6;i++) arr.push(randomKey());\n    for(const k of arr){\n      keyInput.value = k;\n      const plan = table.planInsert(k);\n      await playPlan(plan);\n      await sleep(120);\n    }\n  });\n\n  modeSelect.addEventListener('change', ()=>{\n    // changing mode resets table\n    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);\n    redraw();\n    log('Switched collision handling. Table reset', true);\n  });\n\n  hashSelect.addEventListener('change', ()=>{\n    table.hashName = hashSelect.value;\n    log(`Hash function set to ${hashSelect.value}`, true);\n  });\n\n  capSelect.addEventListener('change', ()=>{\n    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);\n    redraw();\n    log('Capacity changed. Table reset', true);\n  });\n\n  // random key generator\n  function randomKey(){\n    if(Math.random() < 0.5) return (Math.floor(Math.random()*200)).toString();\n    const names = ['Alice','Bob','Carol','Dave','Eve','Mallory','Trent','Peggy','Victor','Sybil'];\n    return names[Math.floor(Math.random()*names.length)] + Math.floor(Math.random()*100);\n  }\n\n  // initial draw\n  redraw();\n  log('Ready. Insert keys to see hashing and collisions visualized.');\n\n  // expose to window for debugging (optional)\n  window.ht = table;\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}