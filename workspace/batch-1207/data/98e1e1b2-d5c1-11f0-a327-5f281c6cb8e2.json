{
  "id": "98e1e1b2-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:36.483Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Heap Sort Visualization</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --card:#0b1220;\n    --accent:#4f46e5;\n    --muted:#94a3b8;\n    --good:#16a34a;\n    --bad:#ef4444;\n    --panel:#071028;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  body{background:linear-gradient(180deg,var(--bg),#071027);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:18px;}\n  .app{width:1100px;max-width:98vw;background:linear-gradient(180deg,var(--card),#041025);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(2,6,23,0.7);}\n  h1{margin:0 0 8px 0;font-size:18px;color:#e6eef8;}\n  .top{display:flex;gap:12px;align-items:center;margin-bottom:12px;}\n  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n  .controls > *{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:#e6eef8;}\n  input[type=range]{accent-color:var(--accent); width:140px;}\n  button{cursor:pointer;border:none;background:linear-gradient(180deg,var(--accent),#3b34d8);padding:8px 12px;border-radius:8px;color:white;font-weight:600;}\n  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600;}\n  .main{display:flex;gap:12px;}\n  .left{width:420px;background:linear-gradient(180deg,var(--panel),#041424);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);}\n  .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;font-size:13px;line-height:1.4;color:#cbd5e1;}\n  .line{padding:4px 6px;border-radius:6px;margin-bottom:4px;}\n  .line.highlight{background:linear-gradient(90deg,rgba(79,70,229,0.15),rgba(79,70,229,0.06));box-shadow:0 4px 18px rgba(79,70,229,0.06);border-left:4px solid var(--accent);}\n  .right{flex:1;background:linear-gradient(180deg,var(--panel),#041424);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:8px;align-items:stretch;}\n  canvas{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:block;}\n  .status{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;}\n  .legend{display:flex;gap:8px;align-items:center;}\n  .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:999px;font-size:13px;background:rgba(255,255,255,0.02);}\n  .dot{width:10px;height:10px;border-radius:50%;}\n  .dot.compare{background:#f59e0b;}\n  .dot.swap{background:#ef4444;}\n  .dot.sorted{background:#16a34a;}\n  .footer-note{font-size:12px;color:var(--muted);margin-top:8px;}\n  label{font-size:13px;color:var(--muted);display:block;margin-bottom:4px;}\n  .row{display:flex;gap:8px;align-items:center;}\n  .small{font-size:13px;color:var(--muted);}\n  input[type=number]{width:70px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}\n  .muted{color:var(--muted);}\n  .valueBox{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:46px;text-align:center;}\n</style>\n</head>\n<body>\n<div class=\"app\" role=\"application\" aria-label=\"Heap Sort visualization\">\n  <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n    <div>\n      <h1>Heap Sort — Interactive Visualization</h1>\n      <div class=\"small muted\">Build a max-heap, then repeatedly extract the maximum element to sort the array.</div>\n    </div>\n    <div class=\"legend\">\n      <div class=\"chip\"><span class=\"dot compare\"></span> compare</div>\n      <div class=\"chip\"><span class=\"dot swap\"></span> swap</div>\n      <div class=\"chip\"><span class=\"dot sorted\"></span> placed</div>\n    </div>\n  </div>\n\n  <div class=\"top\">\n    <div class=\"controls\" style=\"flex:1;\">\n      <label style=\"display:inline-block;\">Array size:\n        <input id=\"size\" type=\"number\" min=\"5\" max=\"40\" value=\"12\" />\n      </label>\n      <label style=\"display:inline-block;\">Speed:\n        <input id=\"speed\" type=\"range\" min=\"1\" max=\"10\" value=\"6\" />\n      </label>\n      <label style=\"display:inline-block;\">Max value:\n        <input id=\"maxVal\" type=\"number\" min=\"5\" max=\"200\" value=\"60\" />\n      </label>\n      <button id=\"randomBtn\" class=\"secondary\">Randomize</button>\n      <button id=\"startBtn\">Start</button>\n      <button id=\"stepBtn\" class=\"secondary\">Step</button>\n      <button id=\"resetBtn\" class=\"secondary\">Reset</button>\n    </div>\n    <div style=\"text-align:right;\">\n      <div class=\"small muted\">Current action:</div>\n      <div class=\"valueBox\" id=\"actionLabel\">idle</div>\n    </div>\n  </div>\n\n  <div class=\"main\">\n    <div class=\"left\">\n      <div style=\"font-weight:700;margin-bottom:8px;\">Pseudocode (highlighted)</div>\n      <div class=\"code\" id=\"codeBlock\" aria-hidden=\"false\">\n        <!-- Lines will be injected -->\n      </div>\n      <div class=\"footer-note\">You can play/pause, step through each comparison/swap, or reset with a new random array.</div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"status\">\n        <div class=\"small muted\">Array visualization & heap tree</div>\n        <div class=\"small muted\">Comparisons: <span id=\"compCount\">0</span> • Swaps: <span id=\"swapCount\">0</span></div>\n      </div>\n      <canvas id=\"canvas\" width=\"620\" height=\"420\"></canvas>\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"small muted\">Heap size: <span id=\"heapSizeLabel\">0</span></div>\n        <div class=\"small muted\">Sorted (placed) elements shown in green on the right of the array</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n  // Heap Sort Visualization\n  // Single-file interactive demo with play/pause/step and pseudocode highlighting.\n\n  (function(){\n    // DOM\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n    const sizeInput = document.getElementById('size');\n    const speedInput = document.getElementById('speed');\n    const maxValInput = document.getElementById('maxVal');\n    const randomBtn = document.getElementById('randomBtn');\n    const startBtn = document.getElementById('startBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const codeBlock = document.getElementById('codeBlock');\n    const actionLabel = document.getElementById('actionLabel');\n    const compCountEl = document.getElementById('compCount');\n    const swapCountEl = document.getElementById('swapCount');\n    const heapSizeLabel = document.getElementById('heapSizeLabel');\n\n    // Pseudocode lines for highlighting\n    const lines = [\n      \"heapSort(A):\",\n      \"  n = A.length\",\n      \"  // build max heap\",\n      \"  for i = floor(n/2)-1 downto 0:\",\n      \"    heapify(A, n, i)\",\n      \"  // extract elements from heap\",\n      \"  for end = n-1 downto 1:\",\n      \"    swap(A[0], A[end])\",\n      \"    heapify(A, end, 0)\",\n      \"\",\n      \"heapify(A, heapSize, i):\",\n      \"  largest = i\",\n      \"  left = 2*i + 1\",\n      \"  right = 2*i + 2\",\n      \"  if left < heapSize and A[left] > A[largest]:\",\n      \"    largest = left\",\n      \"  if right < heapSize and A[right] > A[largest]:\",\n      \"    largest = right\",\n      \"  if largest != i:\",\n      \"    swap(A[i], A[largest])\",\n      \"    heapify(A, heapSize, largest)\"\n    ];\n\n    // Render pseudocode\n    function renderCode() {\n      codeBlock.innerHTML = '';\n      lines.forEach((text, idx) => {\n        const div = document.createElement('div');\n        div.className = 'line';\n        div.id = 'line-' + idx;\n        div.textContent = text;\n        codeBlock.appendChild(div);\n      });\n    }\n    renderCode();\n\n    // State\n    let array = [];\n    let heapSize = 0;\n    let comparisons = 0;\n    let swaps = 0;\n    let highlights = { compare: [], swap: [], heapifyIndex: null, building: false };\n    let sortedBoundary = null; // index from which elements are 'placed' (i.e., sorted tail)\n    let running = false;\n    let paused = true;\n    let resumeResolve = null;\n    let stepRequested = false;\n\n    // Initialize\n    function randomArray(n, maxVal) {\n      const a = [];\n      for (let i=0;i<n;i++) a.push(Math.floor(Math.random() * maxVal) + 1);\n      return a;\n    }\n\n    function resetMetrics() {\n      comparisons = 0; swaps = 0;\n      compCountEl.textContent = comparisons;\n      swapCountEl.textContent = swaps;\n    }\n\n    function setAction(text) {\n      actionLabel.textContent = text;\n    }\n\n    // Draw visual: array bars on top, tree below\n    function draw() {\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n      const w = canvas.width, h = canvas.height;\n      const pad = 12;\n      const arrayAreaH = 80;\n      const treeAreaH = h - arrayAreaH - pad*2;\n\n      // Draw array bars\n      const n = array.length;\n      const barGap = 6;\n      const barW = Math.max(6, (w - pad*2 - barGap*(n-1)) / n);\n      const maxVal = Math.max(1, ...array);\n      for (let i=0;i<n;i++){\n        const x = pad + i*(barW + barGap);\n        const val = array[i];\n        const barH = (arrayAreaH - 24) * (val / maxVal);\n        const y = pad + (arrayAreaH - barH);\n        // Determine color:\n        let fill = '#2b3440';\n        if (highlights.swap && highlights.swap.includes(i)) fill = '#ef4444';\n        else if (highlights.compare && highlights.compare.includes(i)) fill = '#f59e0b';\n        else if (sortedBoundary !== null && i >= sortedBoundary) fill = '#16a34a';\n        else fill = '#3b82f6';\n        ctx.fillStyle = fill;\n        roundRect(ctx, x, y, barW, barH, 4);\n        ctx.fill();\n\n        // border\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        ctx.strokeRect(x, y, barW, barH);\n\n        // value text\n        ctx.fillStyle = '#e6eef8';\n        ctx.font = '12px ui-monospace, monospace';\n        ctx.textAlign = 'center';\n        ctx.fillText(String(val), x + barW/2, y - 6);\n      }\n\n      // Draw heap tree\n      const treeTop = pad + arrayAreaH + 6;\n      if (n === 0) return;\n      // node positions by index\n      const positions = [];\n      // compute levels\n      let level = 0;\n      while ((1<<level) <= n) level++;\n      // levelCount = level\n      for (let i=0;i<n;i++){\n        const lvl = Math.floor(Math.log2(i+1));\n        const indexInLevel = i - ((1<<lvl)-1);\n        const itemsInThisLevel = Math.min(n - ((1<<lvl)-1), 1<<lvl);\n        const spacing = (w - pad*2) / (itemsInThisLevel);\n        const x = pad + spacing*(indexInLevel) + spacing/2;\n        const y = treeTop + lvl * 78;\n        positions[i] = {x,y};\n      }\n      // draw edges\n      ctx.lineWidth = 2;\n      for (let i=0;i<n;i++){\n        const left = 2*i+1, right = 2*i+2;\n        const p = positions[i];\n        if (!p) continue;\n        if (left < n){\n          drawEdge(p, positions[left], left);\n        }\n        if (right < n){\n          drawEdge(p, positions[right], right);\n        }\n      }\n      // draw nodes\n      for (let i=0;i<n;i++){\n        const p = positions[i];\n        const nodeR = 18;\n        // fill based on state\n        let nodeFill = '#082032';\n        if (highlights.swap && highlights.swap.includes(i)) nodeFill = '#ef4444';\n        else if (highlights.compare && highlights.compare.includes(i)) nodeFill = '#f59e0b';\n        else if (sortedBoundary !== null && i >= sortedBoundary) nodeFill = '#064e3b';\n        else nodeFill = '#08304b';\n        ctx.beginPath();\n        ctx.fillStyle = nodeFill;\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        roundRect(ctx, p.x - nodeR, p.y - nodeR, nodeR*2, nodeR*2, 12);\n        ctx.fill();\n        ctx.stroke();\n\n        // index label small\n        ctx.fillStyle = '#9fb2c9';\n        ctx.font = '11px ui-monospace, monospace';\n        ctx.textAlign = 'center';\n        ctx.fillText(String(i), p.x, p.y - 6);\n\n        // value\n        ctx.fillStyle = '#e6eef8';\n        ctx.font = '13px ui-monospace, monospace';\n        ctx.fillText(String(array[i]), p.x, p.y + 10);\n      }\n\n      // heap size label\n      heapSizeLabel.textContent = String(heapSize);\n    }\n\n    function drawEdge(p1, p2, childIndex) {\n      ctx.beginPath();\n      // color line differently if child is in sorted boundary (extracted) - draw faded\n      if (sortedBoundary !== null && childIndex >= sortedBoundary) ctx.strokeStyle = 'rgba(16,185,129,0.12)';\n      else ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctx.lineWidth = 2;\n      ctx.moveTo(p1.x, p1.y + 16);\n      ctx.quadraticCurveTo((p1.x + p2.x)/2, (p1.y + p2.y)/2, p2.x, p2.y - 16);\n      ctx.stroke();\n    }\n\n    function roundRect(ctx, x, y, w, h, r) {\n      const radius = r || 4;\n      ctx.beginPath();\n      ctx.moveTo(x+radius, y);\n      ctx.arcTo(x+w, y, x+w, y+h, radius);\n      ctx.arcTo(x+w, y+h, x, y+h, radius);\n      ctx.arcTo(x, y+h, x, y, radius);\n      ctx.arcTo(x, y, x+w, y, radius);\n      ctx.closePath();\n    }\n\n    // Helpers to control pausing and stepping\n    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\n\n    // wait() returns when allowed to proceed one atomic visualization step.\n    // If running but not paused: waits for delay\n    // If paused: waits until resume (play) OR a single step is requested.\n    async function wait() {\n      const baseDelay = 600; // base milliseconds\n      const speed = Number(speedInput.value) || 6;\n      const delay = Math.max(40, baseDelay - (speed-1)*60); // faster => smaller delay\n\n      if (!paused) {\n        await sleep(delay);\n        return;\n      } else {\n        // paused: return on step or resume\n        setAction('paused');\n        return new Promise(res=>{\n          resumeResolve = (mode) => {\n            resumeResolve = null;\n            if (mode === 'step') {\n              // one step: resolve immediately\n              res();\n            } else {\n              // resumed: wait delay then continue\n              sleep(delay).then(res);\n            }\n          };\n        });\n      }\n    }\n\n    // Highlight helpers\n    function setCompare(i,j) {\n      highlights.compare = [i];\n      if (typeof j === 'number') highlights.compare.push(j);\n      highlights.swap = [];\n      updateUI();\n    }\n    function setSwap(i,j) {\n      highlights.swap = [i];\n      if (typeof j === 'number') highlights.swap.push(j);\n      highlights.compare = [];\n      updateUI();\n    }\n    function clearHighlights() {\n      highlights.compare = [];\n      highlights.swap = [];\n      updateUI();\n    }\n\n    // Update pseudocode highlight and UI\n    function highlightLine(idx) {\n      // clear\n      for (let k=0;k<lines.length;k++){\n        const el = document.getElementById('line-'+k);\n        if (el) el.classList.remove('highlight');\n      }\n      if (typeof idx === 'number' && idx >= 0 && idx < lines.length) {\n        const el = document.getElementById('line-'+idx);\n        if (el) el.classList.add('highlight');\n      }\n    }\n\n    function updateUI() {\n      compCountEl.textContent = comparisons;\n      swapCountEl.textContent = swaps;\n      draw();\n    }\n\n    // Async heapify with visualization\n    async function heapify(i) {\n      highlightLine(11); // \"heapify...\"\n      setAction(`heapify: index ${i}`);\n      await wait();\n\n      let largest = i;\n      highlightLine(12); // largest = i\n      await wait();\n\n      const left = 2*i + 1;\n      const right = 2*i + 2;\n      highlightLine(13);\n      await wait();\n\n      if (left < heapSize) {\n        highlightLine(14); // compare left\n        setCompare(left, largest);\n        setAction(`compare A[${left}] (${array[left]}) vs A[${largest}] (${array[largest]})`);\n        comparisons++; updateUI();\n        await wait();\n        if (array[left] > array[largest]) {\n          largest = left;\n          highlightLine(15); // largest = left\n          setAction(`largest = ${left}`);\n          await wait();\n        }\n      }\n\n      if (right < heapSize) {\n        highlightLine(16); // compare right\n        setCompare(right, largest);\n        setAction(`compare A[${right}] (${array[right]}) vs A[${largest}] (${array[largest]})`);\n        comparisons++; updateUI();\n        await wait();\n        if (array[right] > array[largest]) {\n          largest = right;\n          highlightLine(17); // largest = right\n          setAction(`largest = ${right}`);\n          await wait();\n        }\n      }\n\n      if (largest !== i) {\n        // swap and recurse\n        highlightLine(18); // if largest != i\n        setAction(`swap A[${i}] (${array[i]}) and A[${largest}] (${array[largest]})`);\n        setSwap(i, largest);\n        await wait();\n        // perform swap\n        const tmp = array[i]; array[i] = array[largest]; array[largest] = tmp;\n        swaps++; updateUI();\n        await wait();\n        highlightLine(19); // swap line\n        await wait();\n        // recursive heapify on largest\n        await heapify(largest);\n      } else {\n        clearHighlights();\n        highlightLine(null);\n        setAction('heapify done');\n        await wait();\n      }\n    }\n\n    // Heap sort main routine (async)\n    async function heapSort() {\n      running = true;\n      paused = false;\n      startBtn.textContent = 'Pause';\n      setAction('build max-heap');\n      highlightLine(2);\n      await wait();\n\n      heapSize = array.length;\n      // build max heap\n      for (let i = Math.floor(heapSize/2) - 1; i >= 0; i--) {\n        highlightLine(3);\n        setAction(`build: heapify index ${i}`);\n        await wait();\n        await heapify(i);\n      }\n      setAction('max heap built');\n      highlightLine(null);\n      await wait();\n\n      // extract elements\n      for (let end = array.length - 1; end >= 1; end--) {\n        highlightLine(6);\n        setAction(`extract max -> swap A[0] and A[${end}]`);\n        setSwap(0,end);\n        await wait();\n        // swap root with end\n        const tmp = array[0]; array[0] = array[end]; array[end] = tmp;\n        swaps++; updateUI();\n        // mark that element as sorted\n        sortedBoundary = end;\n        await wait();\n\n        heapSize = end; // reduce heap\n        setAction(`heapify at root for heapSize=${heapSize}`);\n        await wait();\n        await heapify(0);\n      }\n\n      // done\n      sortedBoundary = 0;\n      highlights = {compare:[], swap:[], heapifyIndex:null};\n      updateUI();\n      setAction('sorted');\n      running = false;\n      paused = true;\n      startBtn.textContent = 'Start';\n      highlightLine(null);\n    }\n\n    // Controls\n    function initArray() {\n      const n = Math.max(5, Math.min(40, Number(sizeInput.value) || 12));\n      const maxVal = Math.max(5, Number(maxValInput.value) || 60);\n      array = randomArray(n, maxVal);\n      heapSize = array.length;\n      sortedBoundary = array.length;\n      resetMetrics();\n      clearHighlights();\n      setAction('ready');\n      draw();\n    }\n\n    randomBtn.addEventListener('click', () => {\n      if (running) return;\n      initArray();\n    });\n\n    resetBtn.addEventListener('click', () => {\n      if (running) return;\n      initArray();\n    });\n\n    startBtn.addEventListener('click', async () => {\n      if (!running) {\n        // start\n        // reset metrics if starting fresh\n        if (sortedBoundary === null || sortedBoundary === array.length) {\n          // new run\n        }\n        paused = false;\n        running = true;\n        startBtn.textContent = 'Pause';\n        stepRequested = false;\n        heapSize = array.length;\n        // start heap sort\n        heapSort().catch(err=>{\n          console.error(err);\n          running=false;\n          paused=true;\n        });\n      } else {\n        // toggle pause\n        paused = !paused;\n        if (!paused) {\n          // resume\n          setAction('running');\n          startBtn.textContent = 'Pause';\n          if (resumeResolve) resumeResolve('resume');\n          else resumeResolve = null;\n        } else {\n          setAction('paused');\n          startBtn.textContent = 'Resume';\n        }\n      }\n    });\n\n    stepBtn.addEventListener('click', () => {\n      if (!running) {\n        // start in paused mode and take one step\n        paused = true;\n        running = true;\n        startBtn.textContent = 'Resume';\n        heapSize = array.length;\n        // start heapSort but it will immediately hit wait() and pause\n        heapSort().catch(err=>{\n          console.error(err);\n          running=false;\n          paused=true;\n        });\n      }\n      // Trigger single step resolution\n      if (resumeResolve) {\n        resumeResolve('step');\n      } else {\n        // nothing currently waiting; still set a token that wait() will check\n        // but our wait() always sets resumeResolve when paused; so this is unlikely\n      }\n    });\n\n    // Handle manual resumeResolve calls from outside (buttons)\n    window.addEventListener('click', (e)=>{\n      // no-op\n    });\n\n    // If user pressed space or Enter while focused on buttons, allow keyboard step/pause\n    document.addEventListener('keydown', (e)=>{\n      if (e.code === 'Space') {\n        e.preventDefault();\n        startBtn.click();\n      } else if (e.key === 'ArrowRight') {\n        e.preventDefault();\n        stepBtn.click();\n      } else if (e.key === 'r' || e.key === 'R') {\n        e.preventDefault();\n        randomBtn.click();\n      }\n    });\n\n    // initialize UI\n    initArray();\n\n    // keep drawing occasionally to reflect changes\n    let anim = setInterval(draw, 200);\n\n    // expose some things for debugging (not required)\n    window.__heapViz = { array, draw };\n\n  })();\n  </script>\n</div>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}