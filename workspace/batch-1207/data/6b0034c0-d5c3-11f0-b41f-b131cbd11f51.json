{
  "id": "6b0034c0-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:30:47.815Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Weighted Graph Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            margin-bottom: 20px;\n            text-align: center;\n        }\n        button {\n            padding: 8px 16px;\n            margin: 0 5px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        .canvas-container {\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            overflow: hidden;\n        }\n        canvas {\n            display: block;\n            background-color: #fafafa;\n        }\n        .info-panel {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f9f9f9;\n            border-radius: 4px;\n            border-left: 4px solid #4CAF50;\n        }\n        .node-info, .edge-info {\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Weighted Graph Visualization</h1>\n        \n        <div class=\"controls\">\n            <button id=\"addNodeBtn\">Add Node</button>\n            <button id=\"addEdgeBtn\">Add Edge</button>\n            <button id=\"clearBtn\">Clear Graph</button>\n            <button id=\"dijkstraBtn\">Run Dijkstra's Algorithm</button>\n            <button id=\"resetBtn\">Reset</button>\n        </div>\n        \n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"1000\" height=\"600\"></canvas>\n        </div>\n        \n        <div class=\"info-panel\">\n            <h3>Instructions:</h3>\n            <p><strong>Add Node:</strong> Click anywhere on the canvas to add a node</p>\n            <p><strong>Add Edge:</strong> Click on two nodes to create a weighted edge between them</p>\n            <p><strong>Run Dijkstra:</strong> Select a start node to find shortest paths to all other nodes</p>\n            <p><strong>Edge Weight:</strong> Click on an edge to edit its weight</p>\n        </div>\n    </div>\n\n    <script>\n        class WeightedGraph {\n            constructor() {\n                this.nodes = [];\n                this.edges = [];\n                this.selectedNodes = [];\n                this.startNode = null;\n                this.mode = 'addNode'; // 'addNode', 'addEdge', 'dijkstra'\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.nodeRadius = 20;\n                \n                this.setupEventListeners();\n                this.draw();\n            }\n            \n            setupEventListeners() {\n                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));\n                \n                document.getElementById('addNodeBtn').addEventListener('click', () => {\n                    this.mode = 'addNode';\n                    this.updateButtons();\n                });\n                \n                document.getElementById('addEdgeBtn').addEventListener('click', () => {\n                    this.mode = 'addEdge';\n                    this.selectedNodes = [];\n                    this.updateButtons();\n                });\n                \n                document.getElementById('dijkstraBtn').addEventListener('click', () => {\n                    this.mode = 'dijkstra';\n                    this.selectedNodes = [];\n                    this.updateButtons();\n                });\n                \n                document.getElementById('clearBtn').addEventListener('click', () => {\n                    this.nodes = [];\n                    this.edges = [];\n                    this.selectedNodes = [];\n                    this.startNode = null;\n                    this.draw();\n                });\n                \n                document.getElementById('resetBtn').addEventListener('click', () => {\n                    this.selectedNodes = [];\n                    this.startNode = null;\n                    this.draw();\n                });\n            }\n            \n            updateButtons() {\n                const buttons = ['addNodeBtn', 'addEdgeBtn', 'dijkstraBtn'];\n                buttons.forEach(btnId => {\n                    const btn = document.getElementById(btnId);\n                    btn.disabled = btnId.replace('Btn', '') === this.mode;\n                });\n            }\n            \n            handleCanvasClick(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n                \n                switch(this.mode) {\n                    case 'addNode':\n                        this.addNode(x, y);\n                        break;\n                    case 'addEdge':\n                        this.handleEdgeModeClick(x, y);\n                        break;\n                    case 'dijkstra':\n                        this.handleDijkstraModeClick(x, y);\n                        break;\n                }\n            }\n            \n            addNode(x, y) {\n                // Generate a unique label (A, B, C, ...)\n                const label = String.fromCharCode(65 + this.nodes.length);\n                this.nodes.push({ x, y, label, distance: Infinity, previous: null });\n                this.draw();\n            }\n            \n            handleEdgeModeClick(x, y) {\n                const clickedNode = this.getNodeAt(x, y);\n                \n                if (clickedNode) {\n                    this.selectedNodes.push(clickedNode);\n                    \n                    if (this.selectedNodes.length === 2) {\n                        const weight = prompt('Enter edge weight:', '1');\n                        if (weight && !isNaN(weight)) {\n                            this.addEdge(this.selectedNodes[0], this.selectedNodes[1], parseInt(weight));\n                        }\n                        this.selectedNodes = [];\n                    }\n                }\n            }\n            \n            handleDijkstraModeClick(x, y) {\n                const clickedNode = this.getNodeAt(x, y);\n                \n                if (clickedNode) {\n                    if (!this.startNode) {\n                        this.startNode = clickedNode;\n                        this.runDijkstra();\n                    } else {\n                        // Show path to clicked node\n                        this.highlightPath(clickedNode);\n                    }\n                }\n            }\n            \n            getNodeAt(x, y) {\n                for (let node of this.nodes) {\n                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);\n                    if (distance <= this.nodeRadius) {\n                        return node;\n                    }\n                }\n                return null;\n            }\n            \n            addEdge(node1, node2, weight) {\n                // Check if edge already exists\n                const existingEdge = this.edges.find(edge => \n                    (edge.from === node1 && edge.to === node2) || \n                    (edge.from === node2 && edge.to === node1)\n                );\n                \n                if (!existingEdge) {\n                    this.edges.push({ from: node1, to: node2, weight });\n                }\n                this.draw();\n            }\n            \n            runDijkstra() {\n                // Reset distances\n                this.nodes.forEach(node => {\n                    node.distance = Infinity;\n                    node.previous = null;\n                });\n                \n                this.startNode.distance = 0;\n                \n                const unvisited = [...this.nodes];\n                \n                while (unvisited.length > 0) {\n                    // Find node with smallest distance\n                    unvisited.sort((a, b) => a.distance - b.distance);\n                    const current = unvisited.shift();\n                    \n                    if (current.distance === Infinity) break;\n                    \n                    // Update distances to neighbors\n                    this.edges.forEach(edge => {\n                        if (edge.from === current || edge.to === current) {\n                            const neighbor = edge.from === current ? edge.to : edge.from;\n                            \n                            if (unvisited.includes(neighbor)) {\n                                const newDistance = current.distance + edge.weight;\n                                if (newDistance < neighbor.distance) {\n                                    neighbor.distance = newDistance;\n                                    neighbor.previous = current;\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                this.draw();\n            }\n            \n            highlightPath(targetNode) {\n                this.draw();\n                \n                // Draw the path from start to target\n                let current = targetNode;\n                const path = [];\n                \n                while (current && current !== this.startNode) {\n                    path.unshift(current);\n                    current = current.previous;\n                }\n                \n                if (current === this.startNode) {\n                    path.unshift(this.startNode);\n                    \n                    // Draw the path\n                    this.ctx.strokeStyle = '#ff0000';\n                    this.ctx.lineWidth = 3;\n                    \n                    for (let i = 0; i < path.length - 1; i++) {\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(path[i].x, path[i].y);\n                        this.ctx.lineTo(path[i + 1].x, path[i + 1].y);\n                        this.ctx.stroke();\n                    }\n                    \n                    // Highlight nodes in path\n                    path.forEach(node => {\n                        this.ctx.fillStyle = '#ff0000';\n                        this.ctx.beginPath();\n                        this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);\n                        this.ctx.fill();\n                        \n                        this.ctx.fillStyle = 'white';\n                        this.ctx.font = '16px Arial';\n                        this.ctx.textAlign = 'center';\n                        this.ctx.textBaseline = 'middle';\n                        this.ctx.fillText(node.label, node.x, node.y);\n                    });\n                }\n            }\n            \n            draw() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.edges.forEach(edge => {\n                    this.drawEdge(edge);\n                });\n                \n                // Draw nodes\n                this.nodes.forEach(node => {\n                    this.drawNode(node);\n                });\n                \n                // Highlight selected nodes\n                this.selectedNodes.forEach(node => {\n                    this.ctx.strokeStyle = '#ff9900';\n                    this.ctx.lineWidth = 3;\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);\n                    this.ctx.stroke();\n                });\n                \n                // Highlight start node for Dijkstra\n                if (this.startNode) {\n                    this.ctx.strokeStyle = '#00cc00';\n                    this.ctx.lineWidth = 3;\n                    this.ctx.beginPath();\n                    this.ctx.arc(this.startNode.x, this.startNode.y, this.nodeRadius, 0, Math.PI * 2);\n                    this.ctx.stroke();\n                }\n            }\n            \n            drawEdge(edge) {\n                this.ctx.strokeStyle = '#333';\n                this.ctx.lineWidth = 2;\n                this.ctx.beginPath();\n                this.ctx.moveTo(edge.from.x, edge.from.y);\n                this.ctx.lineTo(edge.to.x, edge.to.y);\n                this.ctx.stroke();\n                \n                // Draw weight\n                const midX = (edge.from.x + edge.to.x) / 2;\n                const midY = (edge.from.y + edge.to.y) / 2;\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.fillRect(midX - 15, midY - 10, 30, 20);\n                \n                this.ctx.fillStyle = '#333';\n                this.ctx.font = '14px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(edge.weight.toString(), midX, midY);\n            }\n            \n            drawNode(node) {\n                // Node circle\n                this.ctx.fillStyle = '#4CAF50';\n                this.ctx.beginPath();\n                this.ctx.arc(node.x, node.y, this.nodeRadius, 0, Math.PI * 2);\n                this.ctx.fill();\n                \n                // Node label\n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '16px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(node.label, node.x, node.y);\n                \n                // Display distance if calculated\n                if (node.distance !== Infinity) {\n                    this.ctx.fillStyle = '#333';\n                    this.ctx.font = '12px Arial';\n                    this.ctx.fillText(node.distance.toString(), node.x, node.y + 25);\n                }\n            }\n        }\n        \n        // Initialize the graph when the page loads\n        window.addEventListener('load', () => {\n            new WeightedGraph();\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}