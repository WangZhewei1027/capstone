{
  "id": "f180a430-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:21:59.806Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Graph Visualization (Directed/Undirected)</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background: #f5f5f5;\n        }\n        .controls {\n            background: white;\n            padding: 15px;\n            border-radius: 8px;\n            margin-bottom: 20px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        button {\n            padding: 8px 16px;\n            margin: 5px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            background: #4CAF50;\n            color: white;\n        }\n        button:hover {\n            background: #45a049;\n        }\n        button.active {\n            background: #2196F3;\n        }\n        select, input {\n            padding: 8px;\n            margin: 5px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        #graphCanvas {\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        .info-panel {\n            background: white;\n            padding: 15px;\n            border-radius: 8px;\n            margin-top: 20px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"controls\">\n        <h2>Graph Visualization</h2>\n        <button id=\"addNodeBtn\">Add Node</button>\n        <button id=\"addEdgeBtn\">Add Edge</button>\n        <button id=\"clearBtn\">Clear Graph</button>\n        <label>\n            Graph Type:\n            <select id=\"graphType\">\n                <option value=\"undirected\">Undirected</option>\n                <option value=\"directed\">Directed</option>\n            </select>\n        </label>\n        <label>\n            Algorithm:\n            <select id=\"algorithm\">\n                <option value=\"none\">None</option>\n                <option value=\"bfs\">BFS</option>\n                <option value=\"dfs\">DFS</option>\n            </select>\n        </label>\n        <button id=\"runAlgorithm\">Run Algorithm</button>\n    </div>\n\n    <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n\n    <div class=\"info-panel\">\n        <h3>Graph Information</h3>\n        <div id=\"graphInfo\">Nodes: 0, Edges: 0</div>\n        <div id=\"algorithmOutput\"></div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor() {\n                this.nodes = new Map();\n                this.edges = [];\n                this.directed = false;\n            }\n\n            addNode(id, x, y) {\n                this.nodes.set(id, { id, x, y, visited: false });\n            }\n\n            addEdge(from, to, weight = 1) {\n                const edge = { from, to, weight, visited: false };\n                this.edges.push(edge);\n                \n                if (!this.directed) {\n                    this.edges.push({ to, from, weight, visited: false });\n                }\n            }\n\n            removeNode(id) {\n                this.nodes.delete(id);\n                this.edges = this.edges.filter(edge => edge.from !== id && edge.to !== id);\n            }\n\n            clear() {\n                this.nodes.clear();\n                this.edges = [];\n            }\n\n            bfs(startId) {\n                const visited = new Set();\n                const queue = [startId];\n                const result = [];\n                visited.add(startId);\n\n                while (queue.length > 0) {\n                    const current = queue.shift();\n                    result.push(current);\n\n                    const neighbors = this.edges\n                        .filter(edge => edge.from === current && !visited.has(edge.to))\n                        .map(edge => edge.to);\n\n                    neighbors.forEach(neighbor => {\n                        visited.add(neighbor);\n                        queue.push(neighbor);\n                    });\n                }\n                return result;\n            }\n\n            dfs(startId) {\n                const visited = new Set();\n                const result = [];\n\n                const dfsRecursive = (nodeId) => {\n                    visited.add(nodeId);\n                    result.push(nodeId);\n\n                    const neighbors = this.edges\n                        .filter(edge => edge.from === nodeId && !visited.has(edge.to))\n                        .map(edge => edge.to);\n\n                    neighbors.forEach(neighbor => dfsRecursive(neighbor));\n                };\n\n                dfsRecursive(startId);\n                return result;\n            }\n        }\n\n        class GraphVisualizer {\n            constructor(canvasId) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.graph = new Graph();\n                this.selectedNode = null;\n                this.draggingNode = null;\n                this.nodeRadius = 20;\n                this.nextNodeId = 1;\n                \n                this.setupEventListeners();\n                this.draw();\n            }\n\n            setupEventListeners() {\n                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));\n                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n\n                document.getElementById('addNodeBtn').addEventListener('click', () => {\n                    this.addRandomNode();\n                });\n\n                document.getElementById('addEdgeBtn').addEventListener('click', () => {\n                    this.selectedNode = null;\n                });\n\n                document.getElementById('clearBtn').addEventListener('click', () => {\n                    this.graph.clear();\n                    this.nextNodeId = 1;\n                    this.selectedNode = null;\n                    this.draw();\n                    this.updateInfo();\n                });\n\n                document.getElementById('graphType').addEventListener('change', (e) => {\n                    this.graph.directed = e.target.value === 'directed';\n                    this.graph.edges = [];\n                    this.draw();\n                    this.updateInfo();\n                });\n\n                document.getElementById('runAlgorithm').addEventListener('click', () => {\n                    this.runSelectedAlgorithm();\n                });\n            }\n\n            handleCanvasClick(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n\n                const clickedNode = this.findNodeAt(x, y);\n                \n                if (clickedNode) {\n                    if (this.selectedNode && this.selectedNode !== clickedNode) {\n                        this.graph.addEdge(this.selectedNode, clickedNode);\n                        this.selectedNode = null;\n                    } else {\n                        this.selectedNode = clickedNode;\n                    }\n                } else {\n                    this.graph.addNode(this.nextNodeId++, x, y);\n                    this.selectedNode = null;\n                }\n                \n                this.draw();\n                this.updateInfo();\n            }\n\n            handleMouseDown(e) {\n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n\n                const node = this.findNodeAt(x, y);\n                if (node) {\n                    this.draggingNode = node;\n                }\n            }\n\n            handleMouseMove(e) {\n                if (this.draggingNode) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    \n                    const node = this.graph.nodes.get(this.draggingNode);\n                    node.x = x;\n                    node.y = y;\n                    this.draw();\n                }\n            }\n\n            handleMouseUp() {\n                this.draggingNode = null;\n            }\n\n            findNodeAt(x, y) {\n                for (const [id, node] of this.graph.nodes) {\n                    const distance = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);\n                    if (distance <= this.nodeRadius) {\n                        return id;\n                    }\n                }\n                return null;\n            }\n\n            addRandomNode() {\n                const x = 50 + Math.random() * (this.canvas.width - 100);\n                const y = 50 + Math.random() * (this.canvas.height - 100);\n                this.graph.addNode(this.nextNodeId++, x, y);\n                this.draw();\n                this.updateInfo();\n            }\n\n            draw() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Draw edges\n                this.ctx.strokeStyle = '#666';\n                this.ctx.lineWidth = 2;\n                \n                this.graph.edges.forEach(edge => {\n                    const fromNode = this.graph.nodes.get(edge.from);\n                    const toNode = this.graph.nodes.get(edge.to);\n                    \n                    if (fromNode && toNode) {\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(fromNode.x, fromNode.y);\n                        \n                        if (this.graph.directed) {\n                            // Draw arrow for directed edges\n                            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);\n                            const headLength = 10;\n                            const endX = toNode.x - this.nodeRadius * Math.cos(angle);\n                            const endY = toNode.y - this.nodeRadius * Math.sin(angle);\n                            \n                            this.ctx.lineTo(endX, endY);\n                            this.ctx.stroke();\n                            \n                            // Arrow head\n                            this.ctx.beginPath();\n                            this.ctx.moveTo(endX, endY);\n                            this.ctx.lineTo(\n                                endX - headLength * Math.cos(angle - Math.PI / 6),\n                                endY - headLength * Math.sin(angle - Math.PI / 6)\n                            );\n                            this.ctx.moveTo(endX, endY);\n                            this.ctx.lineTo(\n                                endX - headLength * Math.cos(angle + Math.PI / 6),\n                                endY - headLength * Math.sin(angle + Math.PI / 6)\n                            );\n                            this.ctx.stroke();\n                        } else {\n                            this.ctx.lineTo(toNode.x, toNode.y);\n                            this.ctx.stroke();\n                        }\n                    }\n                });\n\n                // Draw nodes\n                this.ctx.fillStyle = '#2196F3';\n                this.ctx.strokeStyle = '#1976D2';\n                this.ctx.lineWidth = 2;\n                \n                for (const node of this.graph.nodes.values()) {\n                    this.ctx.beginPath();\n                    this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);\n                    \n                    if (node.visited) {\n                        this.ctx.fillStyle = '#4CAF50';\n                    } else if (node.id === this.selectedNode) {\n                        this.ctx.fillStyle = '#FF9800';\n                    } else {\n                        this.ctx.fillStyle = '#2196F3';\n                    }\n                    \n                    this.ctx.fill();\n                    this.ctx.stroke();\n                    \n                    // Draw node label\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = '14px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(node.id, node.x, node.y);\n                }\n            }\n\n            updateInfo() {\n                const info = document.getElementById('graphInfo');\n                info.textContent = `Nodes: ${this.graph.nodes.size}, Edges: ${this.graph.edges.length} (${this.graph.directed ? 'Directed' : 'Undirected'})`;\n            }\n\n            runSelectedAlgorithm() {\n                const algorithm = document.getElementById('algorithm').value;\n                const output = document.getElementById('algorithmOutput');\n                \n                if (algorithm === 'none' || this.graph.nodes.size === 0) {\n                    output.textContent = 'Please select an algorithm and ensure graph has nodes';\n                    return;\n                }\n\n                // Reset visited states\n                for (const node of this.graph.nodes.values()) {\n                    node.visited = false;\n                }\n                for (const edge of this.graph.edges) {\n                    edge.visited = false;\n                }\n\n                let result;\n                const startNode = Array.from(this.graph.nodes.keys())[0];\n\n                if (algorithm === 'bfs') {\n                    result = this.graph.bfs(startNode);\n                    output.textContent = `BFS Order: ${result.join(' → ')}`;\n                } else if (algorithm === 'dfs') {\n                    result = this.graph.dfs(startNode);\n                    output.textContent = `DFS Order: ${result.join(' → ')}`;\n                }\n\n                // Visualize algorithm steps\n                this.visualizeAlgorithm(result);\n            }\n\n            async visualizeAlgorithm(nodeOrder) {\n                for (let i = 0; i < nodeOrder.length; i++) {\n                    const nodeId = nodeOrder[i];\n                    const node = this.graph.nodes.get(nodeId);\n                    node.visited = true;\n                    this.draw();\n                    \n                    await new Promise(resolve => setTimeout(resolve, 800));\n                }\n            }\n        }\n\n        // Initialize the graph visualizer when page loads\n        window.addEventListener('load', () => {\n            new GraphVisualizer('graphCanvas');\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}