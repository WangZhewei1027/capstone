{
  "id": "f181b5a0-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:23:36.805Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Breadth-First Search (BFS) Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            padding: 20px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n\n        .container {\n            max-width: 1200px;\n            width: 100%;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n            overflow: hidden;\n            margin-bottom: 20px;\n        }\n\n        header {\n            background: #2c3e50;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }\n\n        h1 {\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n        }\n\n        .subtitle {\n            font-size: 1.2rem;\n            opacity: 0.9;\n        }\n\n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            padding: 20px;\n            gap: 20px;\n        }\n\n        .controls {\n            flex: 1;\n            min-width: 300px;\n            background: #f8f9fa;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n        }\n\n        .visualization {\n            flex: 2;\n            min-width: 400px;\n            height: 500px;\n            background: #fff;\n            border: 2px solid #e9ecef;\n            border-radius: 10px;\n            position: relative;\n            overflow: hidden;\n        }\n\n        .btn {\n            background: #3498db;\n            color: white;\n            border: none;\n            padding: 12px 20px;\n            margin: 10px 5px;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 1rem;\n            transition: all 0.3s ease;\n            width: calc(50% - 10px);\n        }\n\n        .btn:hover {\n            background: #2980b9;\n            transform: translateY(-2px);\n        }\n\n        .btn:active {\n            transform: translateY(0);\n        }\n\n        .queue-display {\n            background: #2c3e50;\n            color: white;\n            padding: 15px;\n            border-radius: 5px;\n            margin-top: 20px;\n            min-height: 100px;\n        }\n\n        .queue-title {\n            font-weight: bold;\n            margin-bottom: 10px;\n            text-align: center;\n        }\n\n        .queue-items {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 8px;\n            justify-content: center;\n        }\n\n        .queue-item {\n            background: #3498db;\n            padding: 8px 15px;\n            border-radius: 20px;\n            font-weight: bold;\n            transition: all 0.3s ease;\n        }\n\n        .visited {\n            background: #27ae60;\n        }\n\n        .current {\n            background: #e74c3c;\n            transform: scale(1.1);\n        }\n\n        .node {\n            position: absolute;\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            background: #3498db;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            transition: all 0.5s ease;\n            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n        }\n\n        .edge {\n            position: absolute;\n            height: 3px;\n            background: #7f8c8d;\n            transform-origin: 0 0;\n            z-index: -1;\n        }\n\n        .status {\n            margin-top: 20px;\n            padding: 15px;\n            background: #fff3cd;\n            border-radius: 5px;\n            border-left: 4px solid #ffc107;\n        }\n\n        .algorithm-info {\n            margin-top: 20px;\n            padding: 20px;\n            background: #e8f4fc;\n            border-radius: 10px;\n        }\n\n        .info-title {\n            font-size: 1.5rem;\n            margin-bottom: 10px;\n            color: #2c3e50;\n        }\n\n        .complexity {\n            display: flex;\n            justify-content: space-around;\n            margin-top: 15px;\n        }\n\n        .complexity-item {\n            text-align: center;\n            padding: 10px;\n            background: white;\n            border-radius: 5px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n            flex: 1;\n            margin: 0 5px;\n        }\n\n        .complexity-value {\n            font-size: 1.5rem;\n            font-weight: bold;\n            color: #3498db;\n        }\n\n        .fas {\n            margin-right: 8px;\n        }\n\n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n            .controls, .visualization {\n                min-width: 100%;\n            }\n        }\n    </style>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Breadth-First Search (BFS)</h1>\n            <div class=\"subtitle\">A graph traversal algorithm that explores all neighbors at the present depth before moving to nodes at the next depth level</div>\n        </header>\n\n        <div class=\"content\">\n            <div class=\"controls\">\n                <h2><i class=\"fas fa-sliders-h\"></i>Controls</h2>\n                <button class=\"btn\" id=\"startBtn\"><i class=\"fas fa-play\"></i> Start BFS</button>\n                <button class=\"btn\" id=\"resetBtn\"><i class=\"fas fa-redo\"></i> Reset</button>\n                <button class=\"btn\" id=\"randomGraphBtn\"><i class=\"fas fa-random\"></i> Random Graph</button>\n                <button class=\"btn\" id=\"stepBtn\"><i class=\"fas fa-step-forward\"></i> Step by Step</button>\n\n                <div class=\"queue-display\">\n                    <div class=\"queue-title\">BFS Queue</div>\n                    <div class=\"queue-items\" id=\"queueItems\"></div>\n                </div>\n\n                <div class=\"status\" id=\"status\">\n                    Click \"Start BFS\" to begin the visualization\n                </div>\n            </div>\n\n            <div class=\"visualization\" id=\"visualization\">\n                <!-- Graph will be rendered here -->\n            </div>\n        </div>\n\n        <div class=\"algorithm-info\">\n            <h2 class=\"info-title\"><i class=\"fas fa-info-circle\"></i>Algorithm Information</h2>\n            <p>Breadth-First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadthward motion. It uses a queue data structure to keep track of the nodes to visit.</p>\n            \n            <div class=\"complexity\">\n                <div class=\"complexity-item\">\n                    <div class=\"complexity-label\">Time Complexity</div>\n                    <div class=\"complexity-value\">O(V + E)</div>\n                    <div>V: Vertices, E: Edges</div>\n                </div>\n                <div class=\"complexity-item\">\n                    <div class=\"complexity-label\">Space Complexity</div>\n                    <div class=\"complexity-value\">O(V)</div>\n                    <div>V: Vertices</div>\n                </div>\n                <div class=\"complexity-item\">\n                    <div class=\"complexity-label\">Optimal for</div>\n                    <div class=\"complexity-value\">Shortest Path</div>\n                    <div>Unweighted graphs</div>\n                </div>\n            </div>\n\n            <h3 style=\"margin-top: 15px;\">BFS Algorithm Steps:</h3>\n            <ol style=\"margin-left: 20px; margin-top: 10px;\">\n                <li>Start from the root node and mark it as visited</li>\n                <li>Add the root node to the queue</li>\n                <li>While the queue is not empty:\n                    <ul>\n                        <li>Dequeue a node from the queue</li>\n                        <li>Visit all its unvisited neighbors and add them to the queue</li>\n                        <li>Mark neighbors as visited</li>\n                    </ul>\n                </li>\n            </ol>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = {};\n                this.positions = {};\n            }\n\n            addNode(id, x, y) {\n                this.nodes.push(id);\n                this.edges[id] = [];\n                this.positions[id] = { x, y };\n            }\n\n            addEdge(from, to) {\n                if (this.edges[from].indexOf(to) === -1) {\n                    this.edges[from].push(to);\n                }\n                if (this.edges[to].indexOf(from) === -1) {\n                    this.edges[to].push(from);\n                }\n            }\n\n            getNeighbors(node) {\n                return this.edges[node] || [];\n            }\n        }\n\n        // BFS Algorithm implementation\n        class BFS {\n            constructor(graph) {\n                this.graph = graph;\n                this.visited = {};\n                this.queue = [];\n                this.order = [];\n                this.step = 0;\n                this.isCompleted = false;\n            }\n\n            start(startNode) {\n                this.visited = {};\n                this.queue = [startNode];\n                this.order = [];\n                this.step = 0;\n                this.isCompleted = false;\n                this.visited[startNode] = true;\n                this.order.push({ node: startNode, action: 'visit' });\n            }\n\n            nextStep() {\n                if (this.queue.length === 0) {\n                    this.isCompleted = true;\n                    return null;\n                }\n\n                const currentNode = this.queue.shift();\n                this.order.push({ node: currentNode, action: 'process' });\n\n                const neighbors = this.graph.getNeighbors(currentNode);\n                for (const neighbor of neighbors) {\n                    if (!this.visited[neighbor]) {\n                        this.visited[neighbor] = true;\n                        this.queue.push(neighbor);\n                        this.order.push({ node: neighbor, action: 'visit' });\n                    }\n                }\n\n                this.step++;\n                return currentNode;\n            }\n\n            isFinished() {\n                return this.isCompleted;\n            }\n        }\n\n        // Visualization controller\n        class BFSVisualizer {\n            constructor() {\n                this.graph = new Graph();\n                this.bfs = null;\n                this.isRunning = false;\n                this.animationSpeed = 1000;\n                this.animationInterval = null;\n                this.currentNode = null;\n\n                this.initializeGraph();\n                this.setupEventListeners();\n                this.renderGraph();\n            }\n\n            initializeGraph() {\n                // Create a sample graph\n                this.graph.addNode('A', 100, 100);\n                this.graph.addNode('B', 250, 100);\n                this.graph.addNode('C', 400, 100);\n                this.graph.addNode('D', 100, 250);\n                this.graph.addNode('E', 250, 250);\n                this.graph.addNode('F', 400, 250);\n                this.graph.addNode('G', 175, 350);\n                this.graph.addNode('H', 325, 350);\n\n                this.graph.addEdge('A', 'B');\n                this.graph.addEdge('A', 'D');\n                this.graph.addEdge('B', 'C');\n                this.graph.addEdge('B', 'E');\n                this.graph.addEdge('C', 'F');\n                this.graph.addEdge('D', 'E');\n                this.graph.addEdge('E', 'F');\n                this.graph.addEdge('E', 'G');\n                this.graph.addEdge('F', 'H');\n                this.graph.addEdge('G', 'H');\n            }\n\n            setupEventListeners() {\n                document.getElementById('startBtn').addEventListener('click', () => this.startBFS());\n                document.getElementById('resetBtn').addEventListener('click', () => this.reset());\n                document.getElementById('randomGraphBtn').addEventListener('click', () => this.generateRandomGraph());\n                document.getElementById('stepBtn').addEventListener('click', () => this.stepBFS());\n            }\n\n            startBFS() {\n                if (this.isRunning) return;\n                \n                this.resetVisualization();\n                this.bfs = new BFS(this.graph);\n                this.bfs.start('A');\n                this.isRunning = true;\n                \n                this.animationInterval = setInterval(() => {\n                    this.stepBFS();\n                }, this.animationSpeed);\n            }\n\n            stepBFS() {\n                if (!this.bfs || this.bfs.isFinished()) {\n                    if (this.animationInterval) {\n                        clearInterval(this.animationInterval);\n                        this.animationInterval = null;\n                    }\n                    this.isRunning = false;\n                    document.getElementById('status').textContent = 'BFS completed!';\n                    return;\n                }\n\n                const currentNode = this.bfs.nextStep();\n                this.updateVisualization();\n                this.updateQueueDisplay();\n                \n                if (currentNode) {\n                    document.getElementById('status').textContent = `Processing node: ${currentNode}`;\n                }\n            }\n\n            reset() {\n                if (this.animationInterval) {\n                    clearInterval(this.animationInterval);\n                    this.animationInterval = null;\n                }\n                this.isRunning = false;\n                this.bfs = null;\n                this.resetVisualization();\n                document.getElementById('status').textContent = 'Graph reset. Click \"Start BFS\" to begin.';\n                document.getElementById('queueItems').innerHTML = '';\n            }\n\n            resetVisualization() {\n                // Reset all nodes to default state\n                const nodes = document.querySelectorAll('.node');\n                nodes.forEach(node => {\n                    node.classList.remove('visited', 'current');\n                    node.style.background = '#3498db';\n                });\n            }\n\n            updateVisualization() {\n                if (!this.bfs) return;\n\n                // Update node states based on BFS progress\n                const nodes = document.querySelectorAll('.node');\n                nodes.forEach(node => {\n                    const nodeId = node.textContent;\n                    node.classList.remove('visited', 'current');\n                    \n                    if (this.bfs.visited[nodeId]) {\n                        node.classList.add('visited');\n                    }\n                    \n                    if (this.bfs.queue.length > 0 && nodeId === this.bfs.queue[0]) {\n                        node.classList.add('current');\n                    }\n                });\n            }\n\n            updateQueueDisplay() {\n                if (!this.bfs) return;\n                \n                const queueItems = document.getElementById('queueItems');\n                queueItems.innerHTML = '';\n                \n                this.bfs.queue.forEach(node => {\n                    const queueItem = document.createElement('div');\n                    queueItem.className = 'queue-item';\n                    queueItem.textContent = node;\n                    queueItems.appendChild(queueItem);\n                });\n            }\n\n            renderGraph() {\n                const container = document.getElementById('visualization');\n                container.innerHTML = '';\n\n                // Render edges first (so they appear behind nodes)\n                for (const fromNode of this.graph.nodes) {\n                    for (const toNode of this.graph.edges[fromNode]) {\n                        if (fromNode < toNode) { // Avoid rendering edges twice\n                            this.renderEdge(fromNode, toNode);\n                        }\n                    }\n                }\n\n                // Render nodes\n                for (const nodeId of this.graph.nodes) {\n                    this.renderNode(nodeId);\n                }\n            }\n\n            renderNode(nodeId) {\n                const container = document.getElementById('visualization');\n                const pos = this.graph.positions[nodeId];\n                \n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.textContent = nodeId;\n                nodeElement.style.left = `${pos.x - 25}px`;\n                nodeElement.style.top = `${pos.y - 25}px`;\n                \n                container.appendChild(nodeElement);\n            }\n\n            renderEdge(fromNode, toNode) {\n                const container = document.getElementById('visualization');\n                const fromPos = this.graph.positions[fromNode];\n                const toPos = this.graph.positions[toNode];\n                \n                const dx = toPos.x - fromPos.x;\n                const dy = toPos.y - fromPos.y;\n                const length = Math.sqrt(dx * dx + dy * dy);\n                const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                \n                const edgeElement = document.createElement('div');\n                edgeElement.className = 'edge';\n                edgeElement.style.width = `${length}px`;\n                edgeElement.style.left = `${fromPos.x}px`;\n                edgeElement.style.top = `${fromPos.y}px`;\n                edgeElement.style.transform = `rotate(${angle}deg)`;\n                \n                container.appendChild(edgeElement);\n            }\n\n            generateRandomGraph() {\n                this.reset();\n                \n                this.graph = new Graph();\n                const nodeCount = Math.floor(Math.random() * 6) + 5; // 5-10 nodes\n                const nodes = [];\n                \n                // Generate nodes with random positions\n                for (let i = 0; i < nodeCount; i++) {\n                    const nodeId = String.fromCharCode(65 + i); // A, B, C, ...\n                    const x = 100 + Math.random() * 500;\n                    const y = 100 + Math.random() * 300;\n                    \n                    this.graph.addNode(nodeId, x, y);\n                    nodes.push(nodeId);\n                }\n                \n                // Generate edges - ensure the graph is connected\n                for (let i = 1; i < nodeCount; i++) {\n                    const randomNode = nodes[Math.floor(Math.random() * i)];\n                    this.graph.addEdge(nodes[i], randomNode);\n                }\n                \n                // Add some additional random edges\n                const additionalEdges = Math.floor(Math.random() * nodeCount) +"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}