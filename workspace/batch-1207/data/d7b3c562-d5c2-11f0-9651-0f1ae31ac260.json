{
  "id": "d7b3c562-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:59.452Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Depth-First Search (DFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  h1 {\n    margin-bottom: 5px;\n  }\n  #graph {\n    margin-top: 20px;\n    border: 1px solid #ccc;\n    background-color: #fafafa;\n  }\n  #controls {\n    margin-top: 10px;\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    flex-wrap: wrap;\n    max-width: 600px;\n    justify-content: center;\n  }\n  label {\n    font-weight: bold;\n  }\n  input[type=\"number\"] {\n    width: 50px;\n  }\n  button {\n    cursor: pointer;\n    padding: 8px 16px;\n    border: none;\n    border-radius: 5px;\n    background-color: #4a90e2;\n    color: white;\n    font-size: 1rem;\n    transition: background-color 0.3s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #357abd;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: default;\n  }\n  #log {\n    margin-top: 20px;\n    width: 600px;\n    max-height: 150px;\n    overflow-y: auto;\n    border: 1px solid #ddd;\n    background: white;\n    padding: 8px;\n    font-family: monospace;\n    font-size: 0.9rem;\n  }\n  svg {\n    overflow: visible;\n  }\n  .node {\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  .node circle {\n    stroke: #666;\n    stroke-width: 2px;\n  }\n  .node.unvisited circle {\n    fill: white;\n    stroke: #666;\n  }\n  .node.visiting circle {\n    fill: #f4d35e;\n    stroke: #f4d35e;\n  }\n  .node.visited circle {\n    fill: #61c0bf;\n    stroke: #247f7f;\n  }\n  .edge {\n    stroke: #999;\n    stroke-width: 2px;\n    fill: none;\n    transition: stroke 0.3s;\n  }\n  .edge.visiting {\n    stroke: #f4d35e;\n    stroke-width: 3px;\n  }\n  .edge.visited {\n    stroke: #61c0bf;\n    stroke-width: 3px;\n  }\n  #instructions {\n    max-width: 600px;\n    text-align: center;\n    margin-top: 10px;\n    font-size: 0.9rem;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<h1>Depth-First Search (DFS) Visualization</h1>\n<div id=\"instructions\">\n  Click on a node to choose the <strong>start node</strong>. Then press \"Start DFS\" to see the algorithm explore the graph step-by-step.\n</div>\n<div id=\"controls\">\n  <label for=\"nodeCount\">Number of nodes (3-10): </label>\n  <input type=\"number\" id=\"nodeCount\" min=\"3\" max=\"10\" value=\"6\" />\n  <button id=\"generateBtn\">Generate New Graph</button>\n  <button id=\"startBtn\" disabled>Start DFS</button>\n  <button id=\"resetBtn\" disabled>Reset</button>\n</div>\n<svg id=\"graph\" width=\"600\" height=\"500\" aria-label=\"Graph visualization\"></svg>\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\" role=\"log\"></div>\n<script>\n(() => {\n  const svg = document.getElementById('graph');\n  const nodeCountInput = document.getElementById('nodeCount');\n  const generateBtn = document.getElementById('generateBtn');\n  const startBtn = document.getElementById('startBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const log = document.getElementById('log');\n\n  const width = 600;\n  const height = 500;\n  const radius = 20;\n\n  let graph = {};\n  let adjacencyList = {};\n  let nodes = [];\n  let edges = [];\n  let startNode = null;\n  let dfsStack = [];\n  let visited = new Set();\n  let dfsInterval = null;\n\n  // Helpers\n  function logMessage(msg) {\n    const time = new Date().toLocaleTimeString();\n    log.innerHTML += `[${time}] ${msg}<br/>`;\n    log.scrollTop = log.scrollHeight;\n  }\n\n  function clearLog() {\n    log.innerHTML = '';\n  }\n\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Generate a random undirected connected graph using a simple algorithm:\n  // 1) Create a chain connecting all nodes to ensure connectivity.\n  // 2) Add some random edges.\n  function generateGraph(n) {\n    adjacencyList = {};\n    nodes = [];\n    edges = [];\n    for (let i = 0; i < n; i++) {\n      adjacencyList[i] = new Set();\n    }\n\n    // Positions on circle\n    const angleStep = (2 * Math.PI) / n;\n    for (let i = 0; i < n; i++) {\n      const angle = i * angleStep - Math.PI / 2;\n      const x = width / 2 + Math.cos(angle) * (height / 2 - 60);\n      const y = height / 2 + Math.sin(angle) * (height / 2 - 60);\n      nodes.push({ id: i, x, y, state: 'unvisited' }); // state: unvisited, visiting, visited\n    }\n    // 1) Connect in a chain to ensure connectivity\n    for (let i = 0; i < n - 1; i++) {\n      adjacencyList[i].add(i + 1);\n      adjacencyList[i + 1].add(i);\n    }\n    edges.push(\n      ...Array.from({ length: n - 1 }, (_, i) => ({\n        source: i,\n        target: i + 1,\n        state: 'unvisited', // unvisited, visiting, visited\n      }))\n    );\n\n    // 2) Add some random edges\n    const extraEdgesCount = Math.min(n, 3 + randInt(0, 3));\n    let tries = 0;\n    while (edges.length < n - 1 + extraEdgesCount && tries < 30) {\n      const a = randInt(0, n - 1);\n      const b = randInt(0, n - 1);\n      if (a !== b && !adjacencyList[a].has(b)) {\n        adjacencyList[a].add(b);\n        adjacencyList[b].add(a);\n        edges.push({ source: a, target: b, state: 'unvisited' });\n      }\n      tries++;\n    }\n  }\n\n  // Draw the graph in svg\n  function drawGraph() {\n    // Clear svg\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n    // Draw edges\n    edges.forEach((edge, i) => {\n      const sourceNode = nodes[edge.source];\n      const targetNode = nodes[edge.target];\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.setAttribute('x1', sourceNode.x);\n      line.setAttribute('y1', sourceNode.y);\n      line.setAttribute('x2', targetNode.x);\n      line.setAttribute('y2', targetNode.y);\n      line.classList.add('edge', edge.state);\n      line.setAttribute('data-edge-index', i);\n      svg.appendChild(line);\n    });\n\n    // Draw nodes\n    nodes.forEach((node) => {\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      g.classList.add('node', node.state);\n      g.setAttribute('tabindex', '0');\n      g.setAttribute('role', 'button');\n      g.setAttribute('aria-label', `Node ${node.id}${startNode === node.id ? ' (start node)' : ''}`);\n      g.setAttribute('data-node-id', node.id);\n      g.style.transform = `translate(${node.x}px, ${node.y}px)`;\n      // Circle\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('r', radius);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n      g.appendChild(circle);\n      // Text\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 5);\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('font-weight', 'bold');\n      text.textContent = node.id;\n      g.appendChild(text);\n\n      svg.appendChild(g);\n    });\n  }\n\n  // Update nodes and edges classes for visualization\n  function updateVisualization() {\n    const nodeElements = svg.querySelectorAll('.node');\n    nodeElements.forEach((el) => {\n      const id = Number(el.getAttribute('data-node-id'));\n      const nodeObj = nodes[id];\n      el.className.baseVal = 'node ' + nodeObj.state;\n      el.setAttribute('aria-label', `Node ${id}${startNode === id ? ' (start node)' : ''}`);\n    });\n    const edgeElements = svg.querySelectorAll('.edge');\n    edgeElements.forEach((el) => {\n      const index = Number(el.getAttribute('data-edge-index'));\n      el.className.baseVal = 'edge ' + edges[index].state;\n    });\n  }\n\n  // Find edge object index between two nodes (undirected)\n  function findEdgeIndex(a, b) {\n    return edges.findIndex(\n      (e) =>\n        (e.source === a && e.target === b) || (e.source === b && e.target === a)\n    );\n  }\n\n  function resetStates() {\n    visited = new Set();\n    dfsStack = [];\n    nodes.forEach((node) => (node.state = 'unvisited'));\n    edges.forEach((edge) => (edge.state = 'unvisited'));\n    updateVisualization();\n  }\n\n  function handleNodeClick(e) {\n    if (dfsStack.length > 0) return; // Disable changing start node during run\n    const target = e.currentTarget;\n    const nodeId = Number(target.getAttribute('data-node-id'));\n    if (startNode !== null) {\n      nodes[startNode].state = 'unvisited';\n    }\n    startNode = nodeId;\n    nodes[startNode].state = 'visiting';\n    updateVisualization();\n    startBtn.disabled = false;\n    logMessage(`Start node selected: Node ${startNode}`);\n  }\n\n  async function runDFS() {\n    if (startNode === null) return;\n    startBtn.disabled = true;\n    generateBtn.disabled = true;\n    nodeCountInput.disabled = true;\n    resetBtn.disabled = false;\n\n    resetStates();\n    nodes[startNode].state = 'visiting';\n    updateVisualization();\n    logMessage(`Starting DFS from node ${startNode}`);\n\n    const stack = [startNode];\n    visited.add(startNode);\n\n    while (stack.length > 0) {\n      const current = stack[stack.length - 1];\n      const currentNode = nodes[current];\n      currentNode.state = 'visiting';\n      updateVisualization();\n\n      // Find unvisited neighbors\n      const neighbors = Array.from(adjacencyList[current]).filter((n) => !visited.has(n));\n\n      if (neighbors.length === 0) {\n        // Mark node visited, pop stack\n        currentNode.state = 'visited';\n        logMessage(`Visited node ${current}`);\n        stack.pop();\n        updateVisualization();\n        await delay(800);\n      } else {\n        const next = neighbors[0];\n        // Mark edge visiting\n        const edgeIndex = findEdgeIndex(current, next);\n        if (edgeIndex !== -1) {\n          edges[edgeIndex].state = 'visiting';\n          updateVisualization();\n          logMessage(`Exploring edge (${current} â†’ ${next})`);\n        }\n\n        await delay(800);\n\n        visited.add(next);\n        stack.push(next);\n        nodes[next].state = 'visiting';\n\n        if (edgeIndex !== -1) {\n          edges[edgeIndex].state = 'visited';\n        }\n        updateVisualization();\n        logMessage(`Discovered node ${next}`);\n        await delay(800);\n      }\n    }\n    logMessage('DFS Complete.');\n    startBtn.disabled = true;\n    generateBtn.disabled = false;\n    nodeCountInput.disabled = false;\n  }\n\n  function delay(ms) {\n    return new Promise((res) => setTimeout(res, ms));\n  }\n\n  // Reset everything, allow new graph generation or DFS start\n  function reset() {\n    clearTimeout(dfsInterval);\n    dfsInterval = null;\n    startNode = null;\n    resetBtn.disabled = true;\n    startBtn.disabled = true;\n    generateBtn.disabled = false;\n    nodeCountInput.disabled = false;\n    clearLog();\n    nodes.forEach((node) => (node.state = 'unvisited'));\n    edges.forEach((edge) => (edge.state = 'unvisited'));\n    updateVisualization();\n  }\n\n  // Init\n  function init() {\n    generateGraph(Number(nodeCountInput.value));\n    clearLog();\n    drawGraph();\n    updateVisualization();\n\n    startNode = null;\n    startBtn.disabled = true;\n    resetBtn.disabled = true;\n  }\n\n  // Event listeners\n  generateBtn.addEventListener('click', () => {\n    reset();\n    generateGraph(Number(nodeCountInput.value));\n    drawGraph();\n    updateVisualization();\n  });\n\n  startBtn.addEventListener('click', async () => {\n    await runDFS();\n  });\n\n  resetBtn.addEventListener('click', () => {\n    reset();\n  });\n\n  // Add click handlers on nodes (delegation after graph draw)\n  function addNodeClickHandlers() {\n    const nodeElements = svg.querySelectorAll('.node');\n    nodeElements.forEach((el) => {\n      el.addEventListener('click', handleNodeClick);\n      el.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          handleNodeClick.call(el, e);\n        }\n      });\n    });\n  }\n\n  // After graph draw\n  function refreshHandlers() {\n    addNodeClickHandlers();\n  }\n\n  nodeCountInput.addEventListener('change', (e) => {\n    let val = Number(e.target.value);\n    if (val < 3) val = 3;\n    if (val > 10) val = 10;\n    e.target.value = val;\n  });\n\n  // After generating or regenerating graph: reset and add handlers\n  generateBtn.addEventListener('click', () => {\n    setTimeout(refreshHandlers, 50);\n  });\n\n  // Initial load\n  init();\n  refreshHandlers();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}