{
  "id": "d7b30213-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:25:11.459Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    overflow: hidden;\n    background: #f0f0f0;\n  }\n  #container {\n    position: relative;\n    width: 100vw;\n    height: 100vh;\n  }\n  canvas {\n    background: #fff;\n    display: block;\n    margin: 0 auto;\n    box-shadow: 0 0 8px rgba(0,0,0,0.15);\n  }\n  #info {\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    background: rgba(255,255,255,0.9);\n    border-radius: 6px;\n    padding: 10px 15px;\n    max-width: 320px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n    user-select: none;\n  }\n  #info h2 {\n    margin-top:0;\n    font-weight: 600;\n    font-size: 18px;\n  }\n  #info p {\n    font-size: 14px;\n    margin: 5px 0;\n    line-height: 1.3;\n  }\n  #resetButton {\n    margin-top: 10px;\n    background-color: #2979ff;\n    border: none;\n    color: white;\n    padding: 6px 12px;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n  }\n  #resetButton:hover {\n    background-color: #1c54b2;\n  }\n  #instructions {\n    font-size: 13px;\n    color: #555;\n    margin-top: 8px;\n    line-height: 1.4;\n  }\n</style>\n</head>\n<body>\n<div id=\"container\">\n  <canvas id=\"graphCanvas\" width=\"900\" height=\"600\"></canvas>\n  <div id=\"info\">\n    <h2>Weighted Graph Demo</h2>\n    <p><b>Instructions:</b></p>\n    <p id=\"instructions\">\n      - Click on empty space to add a node.<br>\n      - Click on two nodes consecutively to create an edge.<br>\n      - After selecting the second node, you will be prompted to enter a weight.<br>\n      - Drag nodes to reposition.<br>\n      - Right-click a node to delete it (and connected edges).<br>\n      - Right-click an edge (near its line) to delete that edge.<br>\n      - The graph shows nodes as circles, edges as lines with weights displayed near them.<br>\n    </p>\n    <button id=\"resetButton\">Reset Graph</button>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  let nodes = [];\n  let edges = [];\n\n  const nodeRadius = 20;\n\n  // For dragging:\n  let dragNode = null;\n  let dragOffsetX = 0;\n  let dragOffsetY = 0;\n\n  // For creating edges:\n  let selectedNode = null;\n\n  // Utility to get mouse position relative to canvas\n  function getMousePos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top,\n    };\n  }\n\n  // Find a node under a point (within radius)\n  function findNodeAt(x, y) {\n    return nodes.find(\n      (node) =>\n        Math.hypot(node.x - x, node.y - y) <= nodeRadius\n    );\n  }\n\n  // Find an edge near a point - we approximate by checking distance from mouse to edge line segment\n  function findEdgeAt(x, y) {\n    function distanceToSegment(px, py, x1, y1, x2, y2) {\n      // https://stackoverflow.com/questions/849211/\n      const A = px - x1;\n      const B = py - y1;\n      const C = x2 - x1;\n      const D = y2 - y1;\n\n      const dot = A * C + B * D;\n      const len_sq = C * C + D * D;\n      let param = -1;\n      if (len_sq !== 0) //in case of 0 length line\n          param = dot / len_sq;\n\n      let xx, yy;\n\n      if (param < 0) {\n        xx = x1;\n        yy = y1;\n      }\n      else if (param > 1) {\n        xx = x2;\n        yy = y2;\n      }\n      else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n      }\n\n      const dx = px - xx;\n      const dy = py - yy;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    for(let edge of edges) {\n      const n1 = nodes.find(n => n.id === edge.from);\n      const n2 = nodes.find(n => n.id === edge.to);\n\n      if (!n1 || !n2) continue;\n\n      const dist = distanceToSegment(x, y, n1.x, n1.y, n2.x, n2.y);\n      if(dist <= 8) {\n        return edge;\n      }\n    }\n    return null;\n  }\n\n  // Draw arrowed line from (x1,y1) to (x2,y2)\n  function drawArrowedLine(x1, y1, x2, y2, options = {}) {\n    const {color = \"#333\", arrowSize=10, width=2} = options;\n    const headlen = arrowSize;\n\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const angle = Math.atan2(dy, dx);\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    // draw arrowhead\n    ctx.beginPath();\n    ctx.moveTo(x2, y2);\n    ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));\n    ctx.lineTo(x2, y2);\n    ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));\n    ctx.fillStyle = color;\n    ctx.fill();\n  }\n\n  // Draw the weighted graph\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges first\n    edges.forEach(edge => {\n      const fromNode = nodes.find(n => n.id === edge.from);\n      const toNode = nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      // Draw a slightly offset edge so arrow and label are visible clear from node circle\n\n      // Compute line vector & unit vector\n      const dx = toNode.x - fromNode.x;\n      const dy = toNode.y - fromNode.y;\n      const dist = Math.hypot(dx, dy);\n      if (dist === 0) return;\n      const ux = dx / dist;\n      const uy = dy / dist;\n\n      // start and end points adjusted to node circle edge\n      const startX = fromNode.x + ux * nodeRadius;\n      const startY = fromNode.y + uy * nodeRadius;\n      const endX = toNode.x - ux * nodeRadius;\n      const endY = toNode.y - uy * nodeRadius;\n\n      // Draw line with arrow\n      drawArrowedLine(startX, startY, endX, endY, {color:\"#555\", width:2});\n\n      // Draw weight label near middle of edge, offset perpendicular to edge line\n      const midX = (startX + endX) / 2;\n      const midY = (startY + endY) / 2;\n      const offset = 15;\n      // Perpendicular vector\n      const px = -uy;\n      const py = ux;\n\n      ctx.fillStyle = \"#222\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(edge.weight, midX + px * offset, midY + py * offset);\n    });\n\n    // Draw nodes on top\n    nodes.forEach(node => {\n      ctx.beginPath();\n      ctx.fillStyle = node === selectedNode ? \"#4a90e2\" : \"#0077cc\";\n      ctx.strokeStyle = \"#004d80\";\n      ctx.lineWidth = 2;\n      ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      // Node label = node.id or letter\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"bold 14px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node.label, node.x, node.y);\n    });\n  }\n\n  // Add a node at position (x,y)\n  function addNode(x, y) {\n    // Generate label as letter A, B, C, ...\n    const nextLabel = String.fromCharCode(65 + nodes.length);\n    const newNode = {\n      id: generateId(),\n      label: nextLabel,\n      x,\n      y\n    };\n    nodes.push(newNode);\n  }\n\n  function generateId() {\n    // unique but simple incremental string id\n    return 'n' + Date.now() + Math.random().toString(36).slice(2,6);\n  }\n\n  // Add an edge from nodeFrom to nodeTo with weight\n  function addEdge(nodeFrom, nodeTo, weight) {\n    // Check if edge already exists\n    const exists = edges.some(e =>\n      e.from === nodeFrom.id && e.to === nodeTo.id);\n    if(exists) {\n      alert(\"Edge already exists!\");\n      return;\n    }\n    edges.push({\n      from: nodeFrom.id,\n      to: nodeTo.id,\n      weight: weight,\n    });\n  }\n\n  // Delete a node and all connected edges\n  function deleteNode(node) {\n    nodes = nodes.filter(n => n !== node);\n    edges = edges.filter(e => e.from !== node.id && e.to !== node.id);\n  }\n\n  // Delete a given edge\n  function deleteEdge(edge) {\n    edges = edges.filter(e => e !== edge);\n  }\n\n  // Interaction handlers\n  canvas.addEventListener(\"mousedown\", evt => {\n    const pos = getMousePos(evt);\n\n    if(evt.button === 2) {\n      // Right click: check if node or edge under pointer to delete\n      const node = findNodeAt(pos.x, pos.y);\n      if(node) {\n        if(confirm(`Delete node ${node.label} and its connected edges?`)) {\n          if(selectedNode === node) selectedNode = null;\n          deleteNode(node);\n          drawGraph();\n        }\n        evt.preventDefault();\n        return;\n      }\n      const edge = findEdgeAt(pos.x, pos.y);\n      if(edge) {\n        if(confirm(`Delete edge from ${getNodeLabelById(edge.from)} to ${getNodeLabelById(edge.to)}?`)) {\n          deleteEdge(edge);\n          drawGraph();\n        }\n        evt.preventDefault();\n        return;\n      }\n      // No node or edge under pointer, do nothing special for right click\n      return;\n    }\n\n    // Left click - first check if a node is clicked for dragging or edge creation\n    const node = findNodeAt(pos.x, pos.y);\n    if(node) {\n      // If no selectedNode previously, set this as selectedNode for creating edge\n      if(!selectedNode) {\n        selectedNode = node;\n        drawGraph();\n      } else if(selectedNode === node) {\n        // clicking same node again cancels selection\n        selectedNode = null;\n        drawGraph();\n      } else {\n        // second node selected, prompt for weight\n        const inputWeight = prompt(`Enter weight for edge from \"${selectedNode.label}\" to \"${node.label}\":`, \"1\");\n        const weightNum = parseFloat(inputWeight);\n        if(!isNaN(weightNum) && weightNum > 0) {\n          addEdge(selectedNode, node, weightNum);\n        } else if(inputWeight !== null) {\n          alert(\"Invalid weight entered. Please enter a positive number.\");\n        }\n        selectedNode = null;\n        drawGraph();\n      }\n      // Start drag for node after edge selection completes - do not drag on the same click\n      return;\n    }\n\n    // No node clicked\n    // Add new node at place\n    if(!selectedNode) {\n      addNode(pos.x, pos.y);\n      drawGraph();\n      return;\n    } else {\n      // If we were in edge select mode (selectedNode), clicking elsewhere cancels it\n      selectedNode = null;\n      drawGraph();\n      return;\n    }\n  }, false);\n\n  // Drag nodes\n  canvas.addEventListener(\"mousedown\", evt => {\n    if(evt.button !== 0) return; // left click only\n\n    const pos = getMousePos(evt);\n    const node = findNodeAt(pos.x, pos.y);\n    if(node) {\n      dragNode = node;\n      dragOffsetX = pos.x - node.x;\n      dragOffsetY = pos.y - node.y;\n      // Prevent text selection while dragging\n      evt.preventDefault();\n    }\n  }, false);\n\n  canvas.addEventListener(\"mousemove\", evt => {\n    if(dragNode) {\n      const pos = getMousePos(evt);\n      dragNode.x = pos.x - dragOffsetX;\n      dragNode.y = pos.y - dragOffsetY;\n\n      // Keep node inside canvas bounds (some padding)\n      dragNode.x = Math.min(canvas.width - nodeRadius, Math.max(nodeRadius, dragNode.x));\n      dragNode.y = Math.min(canvas.height - nodeRadius, Math.max(nodeRadius, dragNode.y));\n\n      drawGraph();\n    }\n  }, false);\n\n  canvas.addEventListener(\"mouseup\", (evt) => {\n    dragNode = null;\n  }, false);\n\n  canvas.addEventListener(\"mouseleave\", (evt) => {\n    dragNode = null;\n  }, false);\n\n  // Disable context menu on canvas to allow custom right-click\n  canvas.addEventListener(\"contextmenu\", e => {\n    e.preventDefault();\n  });\n\n  // Utility to get label by id\n  function getNodeLabelById(id) {\n    const n = nodes.find(n => n.id === id);\n    return n ? n.label : \"?\";\n  }\n\n  // Reset button\n  document.getElementById(\"resetButton\").addEventListener(\"click\", () => {\n    if(confirm(\"Clear entire graph?\")) {\n      nodes = [];\n      edges = [];\n      selectedNode = null;\n      drawGraph();\n    }\n  });\n\n  // Initialize with a sample weighted graph\n  function initSampleGraph() {\n    nodes = [\n      {id: \"n1\", label: \"A\", x: 150, y: 120},\n      {id: \"n2\", label: \"B\", x: 350, y: 180},\n      {id: \"n3\", label: \"C\", x: 240, y: 350},\n      {id: \"n4\", label: \"D\", x: 600, y: 280},\n      {id: \"n5\", label: \"E\", x: 700, y: 120},\n      {id: \"n6\", label: \"F\", x: 620, y: 420},\n    ];\n    edges = [\n      {from: \"n1\", to: \"n2\", weight: 5},\n      {from: \"n1\", to: \"n3\", weight: 3},\n      {from: \"n2\", to: \"n4\", weight: 2},\n      {from: \"n3\", to: \"n4\", weight: 7},\n      {from: \"n4\", to: \"n5\", weight: 4},\n      {from: \"n4\", to: \"n6\", weight: 6},\n      {from: \"n5\", to: \"n6\", weight: 1},\n    ];\n  }\n\n  initSampleGraph();\n  drawGraph();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}