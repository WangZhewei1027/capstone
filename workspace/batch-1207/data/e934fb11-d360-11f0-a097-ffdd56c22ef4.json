{
  "id": "e934fb11-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:55.290Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 16px; color: #111; }\n    h1 { font-size: 20px; margin: 0 0 8px 0; }\n    p.lead { margin: 4px 0 16px 0; color: #333; font-size: 14px; }\n    #container { display: flex; gap: 16px; }\n    #left { flex: 1 1 640px; }\n    #canvasWrap { background: #fff; border: 1px solid #ccc; display: inline-block; }\n    canvas { display: block; background: linear-gradient(180deg,#f8f9fb,#fcfdff); cursor: crosshair; }\n    #controls { width: 340px; flex: 0 0 340px; }\n    .panel { border: 1px solid #ddd; padding: 10px; margin-bottom: 12px; background: #fafafa; border-radius: 6px; }\n    label { display: block; margin: 6px 0 4px; font-weight: 600; font-size: 13px; }\n    input[type=\"range\"] { width: 100%; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .btn { background:#1976d2; color:white; padding:6px 10px; border-radius:4px; border:none; cursor:pointer; }\n    .btn.ghost { background:#fff; color:#1976d2; border:1px solid #1976d2; }\n    .btn.small { padding:4px 8px; font-size:13px; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .legend-item { display:flex; gap:6px; align-items:center; font-size:13px; }\n    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #aaa; }\n    #info { font-size:13px; line-height:1.4; margin-top:8px; }\n    table { width:100%; border-collapse: collapse; font-size:13px; }\n    th, td { text-align:left; padding:4px; border-bottom:1px dashed #eee; }\n    .small-muted { font-size:12px; color:#666; }\n    .controls-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    .modeToggle { display:flex; gap:4px; }\n    .modeToggle button { padding:6px 8px; border-radius:4px; border:1px solid #ccc; background:#fff; cursor:pointer; }\n    .modeToggle button.active { border-color:#1976d2; background:#e8f0ff; color:#0b57b0; }\n    .hint { font-size:12px; color:#555; margin-top:6px; }\n  </style>\n</head>\n<body>\n  <h1>K-Nearest Neighbors (KNN) — Interactive Demo</h1>\n  <p class=\"lead\">Visualize how KNN classifies a point in 2D. Add training points, pick K and a distance metric, click to place a query point, and see which neighbors vote.</p>\n\n  <div id=\"container\">\n    <div id=\"left\">\n      <div id=\"canvasWrap\" class=\"panel\">\n        <canvas id=\"plot\" width=\"720\" height=\"480\" title=\"Click to set or add points\"></canvas>\n        <div style=\"padding:8px 6px;\"><span class=\"small-muted\">Click:</span>\n          <strong id=\"clickModeLabel\">Place query</strong> — Hold Shift and click to add a training point of the selected class. Right-click to remove nearest training point.</div>\n      </div>\n    </div>\n\n    <div id=\"controls\">\n      <div class=\"panel\">\n        <label>K (neighbors): <span id=\"kVal\">3</span></label>\n        <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" value=\"3\" />\n        <div class=\"controls-row\" style=\"margin-top:8px;\">\n          <label style=\"margin:0;\">Distance metric</label>\n          <select id=\"metric\">\n            <option value=\"euclidean\">Euclidean</option>\n            <option value=\"manhattan\">Manhattan (L1)</option>\n            <option value=\"chebyshev\">Chebyshev (L∞)</option>\n          </select>\n        </div>\n\n        <label style=\"margin-top:8px;\">Voting</label>\n        <div class=\"controls-row\">\n          <label><input type=\"radio\" name=\"weight\" value=\"uniform\" checked /> Uniform</label>\n          <label><input type=\"radio\" name=\"weight\" value=\"distance\" /> Distance-weighted</label>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <label><input id=\"showBoundary\" type=\"checkbox\" checked /> Show decision boundary</label>\n        </div>\n\n        <div style=\"margin-top:8px;\">  \n          <div class=\"controls-row\">\n            <button id=\"genBlobs\" class=\"btn small\">Generate random blobs</button>\n            <button id=\"clearBtn\" class=\"btn ghost small\">Clear</button>\n          </div>\n          <div class=\"hint\">Use Shift+Click to add training points of the selected class. Click normally to set the query point. Right-click to remove nearest training point.</div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Classes / Add training points</label>\n        <div class=\"legend\" id=\"classLegend\"></div>\n        <div style=\"margin-top:8px;\">\n          <button id=\"addClassBtn\" class=\"btn small\">Add class</button>\n          <button id=\"resetClassesBtn\" class=\"btn ghost small\">Reset to 3 classes</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Prediction</label>\n        <div id=\"info\"><em>No query point yet. Click on canvas to classify.</em></div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Quick actions</label>\n        <div class=\"row\" style=\"gap:6px;\">\n          <button id=\"shuffleBtn\" class=\"btn small\">Shuffle training points</button>\n          <button id=\"splitBtn\" class=\"btn small ghost\">Randomize placement</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Notes</label>\n        <ul style=\"margin:6px 0 0 18px; font-size:13px; color:#444;\">\n          <li>KNN is a simple instance-based classifier — it assigns labels based on the labels of the nearest training points.</li>\n          <li>Distance-weighted voting gives more influence to closer neighbors.</li>\n          <li>Decision boundary shows which class the model would predict at each location.</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Canvas and drawing setup\n  const canvas = document.getElementById('plot');\n  const ctx = canvas.getContext('2d');\n  const W = canvas.width, H = canvas.height;\n\n  // UI elements\n  const kRange = document.getElementById('kRange');\n  const kVal = document.getElementById('kVal');\n  const metricSelect = document.getElementById('metric');\n  const weightRadios = document.getElementsByName('weight');\n  const showBoundaryCheckbox = document.getElementById('showBoundary');\n  const infoDiv = document.getElementById('info');\n  const genBlobsBtn = document.getElementById('genBlobs');\n  const clearBtn = document.getElementById('clearBtn');\n  const classLegend = document.getElementById('classLegend');\n  const addClassBtn = document.getElementById('addClassBtn');\n  const resetClassesBtn = document.getElementById('resetClassesBtn');\n  const clickModeLabel = document.getElementById('clickModeLabel');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const splitBtn = document.getElementById('splitBtn');\n\n  let classes = []; // array of class objects {id, color, name}\n  let points = []; // training points: {x:0..1, y:0..1, label: classId}\n  let query = null; // {x,y}\n  let selectedClassId = 0;\n  let showBoundary = true;\n\n  // Colors to use for classes\n  const baseColors = [\n    '#e53935','#1e88e5','#43a047','#ffb300','#8e24aa','#00acc1','#ff7043','#546e7a'\n  ];\n\n  // Utility helpers\n  function rand(min=0,max=1){ return Math.random()*(max-min)+min; }\n  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }\n\n  // Coordinate mapping between normalized space (0..1) and canvas pixels\n  function toPx(p){ return {x: Math.round(p.x*W), y: Math.round((1-p.y)*H)}; } // invert y for display\n  function fromPx(px){ return {x: clamp(px.x / W, 0, 1), y: clamp(1 - (px.y / H), 0, 1)}; }\n\n  // Initialize some classes\n  function ensureDefaultClasses(){\n    classes = [];\n    for(let i=0;i<3;i++){\n      classes.push({ id: i, color: baseColors[i % baseColors.length], name: 'Class ' + (i+1) });\n    }\n    selectedClassId = 0;\n    renderClassLegend();\n  }\n\n  function addClass(){\n    const id = classes.length ? Math.max(...classes.map(c=>c.id)) + 1 : 0;\n    const color = baseColors[classes.length % baseColors.length] || randomColor();\n    classes.push({id, color, name: 'Class ' + (classes.length+1)});\n    selectedClassId = id;\n    renderClassLegend();\n  }\n\n  function resetToThreeClasses(){\n    ensureDefaultClasses();\n    points = [];\n    query = null;\n    redraw();\n  }\n\n  function randomColor(){\n    const h = Math.floor(Math.random()*360);\n    const s = 60 + Math.random()*20;\n    const l = 45 + Math.random()*10;\n    return `hsl(${h} ${s}% ${l}%)`;\n  }\n\n  function renderClassLegend(){\n    classLegend.innerHTML = '';\n    classes.forEach(c => {\n      const item = document.createElement('div');\n      item.className = 'legend-item';\n      item.innerHTML = `\n        <div class=\"swatch\" style=\"background:${c.color};\"></div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <label style=\"cursor:pointer;\"><input type=\"radio\" name=\"selClass\" value=\"${c.id}\" ${c.id===selectedClassId ? 'checked' : ''}/> ${c.name}</label>\n          <button data-id=\"${c.id}\" title=\"Add one point of this class\" class=\"btn small ghost\">Add point</button>\n        </div>\n      `;\n      classLegend.appendChild(item);\n      item.querySelector('input[type=radio]').addEventListener('change', () => {\n        selectedClassId = c.id;\n      });\n      item.querySelector('button').addEventListener('click', () => {\n        // add a random training point of this class near center\n        const p = { x: rand(0.1,0.9), y: rand(0.1,0.9), label: c.id };\n        points.push(p);\n        redraw();\n      });\n    });\n  }\n\n  // Distance metrics\n  function distance(a,b,metric='euclidean'){\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    if(metric === 'euclidean') return Math.sqrt(dx*dx + dy*dy);\n    if(metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);\n    if(metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n\n  // KNN classifier: returns {predictedLabel, probs: map label=>prob, neighbors: array of neighbors}\n  function knnClassify(queryPoint, K, metric, weighting){\n    if(!queryPoint || points.length===0) return null;\n    const list = points.map(pt => {\n      return { point: pt, dist: distance(queryPoint, pt, metric) };\n    });\n    list.sort((a,b)=>a.dist-b.dist);\n    const neighbors = list.slice(0, Math.min(K, list.length));\n    // Voting\n    const counts = new Map();\n    let totalWeight = 0;\n    neighbors.forEach(n => {\n      const d = n.dist;\n      let w = 1;\n      if(weighting === 'distance'){\n        w = 1.0 / (d + 1e-9); // closer => larger weight\n      }\n      const lab = n.point.label;\n      counts.set(lab, (counts.get(lab) || 0) + w);\n      totalWeight += w;\n    });\n    // compute probs\n    const probs = {};\n    for(const c of classes){\n      const s = counts.get(c.id) || 0;\n      probs[c.id] = totalWeight ? s / totalWeight : 0;\n    }\n    // predicted label is argmax of probs\n    let best = null, bestVal = -Infinity;\n    for(const [lab,val] of Object.entries(probs)){\n      if(val > bestVal){ best = parseInt(lab); bestVal = val; }\n    }\n    return { predictedLabel: best, probs, neighbors };\n  }\n\n  // Drawing functions\n  function clearCanvas(){\n    ctx.clearRect(0,0,W,H);\n    // subtle grid\n    ctx.save();\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0,0,W,H);\n    ctx.restore();\n  }\n\n  function drawBoundaryIfNeeded(){\n    if(!showBoundary) return;\n    // Render decision boundary via coarse grid sampling\n    const step = 8; // px step\n    const metric = metricSelect.value;\n    const weighting = getWeighting();\n    const K = Math.min(parseInt(kRange.value), Math.max(1, points.length));\n    if(points.length===0) return;\n    for(let px=0; px<W; px+=step){\n      for(let py=0; py<H; py+=step){\n        const q = fromPx({x:px,y:py});\n        const res = knnClassify(q, K, metric, weighting);\n        if(!res) continue;\n        const lab = res.predictedLabel;\n        const color = classes.find(c=>c.id===lab)?.color || '#000';\n        // convert color to rgba with low alpha\n        ctx.fillStyle = hexToRgba(color, 0.12);\n        ctx.fillRect(px, py, step, step);\n      }\n    }\n    // anti-aliased boundary overlay: draw faint strokes between cells with different classes\n    // (skip for speed)\n  }\n\n  // helper to turn hex or hsl into rgba with alpha\n  function hexToRgba(col, a){\n    // If starts with hsl or rgb, just use it with alpha if possible\n    if(col.startsWith('hsl') || col.startsWith('rgb')) {\n      return col.replace('hsl','hsla').replace('rgb','rgba').replace(')',`, ${a})`);\n    }\n    // hex -> rgba\n    const c = col.replace('#','');\n    const bigint = parseInt(c, 16);\n    const r = (bigint >> 16) & 255;\n    const g = (bigint >> 8) & 255;\n    const b = bigint & 255;\n    return `rgba(${r},${g},${b},${a})`;\n  }\n\n  function drawPointsAndQuery(highlightNeighbors = []){\n    // draw training points\n    points.forEach((pt, idx) => {\n      const px = toPx(pt);\n      const cls = classes.find(c=>c.id===pt.label);\n      const color = cls ? cls.color : '#000';\n      ctx.beginPath();\n      ctx.fillStyle = color;\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 1;\n      // marker: square for training\n      const s = 8;\n      ctx.rect(px.x - s/2, px.y - s/2, s, s);\n      ctx.fill();\n      ctx.stroke();\n      // small inner dot for index\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.arc(px.x, px.y, 2, 0, Math.PI*2);\n      ctx.fill();\n    });\n\n    // highlight neighbors with rings and numbers\n    highlightNeighbors.forEach((n, i) => {\n      const p = toPx(n.point);\n      ctx.beginPath();\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([4,3]);\n      ctx.arc(p.x, p.y, 14, 0, Math.PI*2);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      // draw neighbor index\n      ctx.fillStyle = '#111';\n      ctx.font = '12px sans-serif';\n      ctx.fillText((i+1).toString(), p.x - 6, p.y + 4);\n    });\n\n    // draw query point\n    if(query){\n      const qp = toPx(query);\n      ctx.beginPath();\n      ctx.fillStyle = 'white';\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.arc(qp.x, qp.y, 10, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.fillStyle = '#111';\n      ctx.font = '12px sans-serif';\n      ctx.fillText('Q', qp.x - 4, qp.y + 5);\n    }\n  }\n\n  function redraw(){\n    clearCanvas();\n    drawBoundaryIfNeeded();\n    // draw axes labels or border\n    ctx.save();\n    ctx.strokeStyle = '#ddd';\n    ctx.lineWidth = 1;\n    ctx.strokeRect(0.5,0.5,W-1, H-1);\n    ctx.restore();\n\n    // compute neighbors to highlight if query exists\n    const K = Math.min(parseInt(kRange.value), Math.max(1, points.length));\n    const metric = metricSelect.value;\n    const weighting = getWeighting();\n    let neighborsToShow = [];\n    if(query && points.length>0){\n      const res = knnClassify(query, K, metric, weighting);\n      if(res) neighborsToShow = res.neighbors;\n      // draw decision info box\n      displayPredictionInfo(res);\n    } else {\n      displayNoQueryInfo();\n    }\n\n    drawPointsAndQuery(neighborsToShow);\n  }\n\n  function displayNoQueryInfo(){\n    infoDiv.innerHTML = `<em>No query point yet. Click on canvas to classify.</em>\n      <div style=\"margin-top:8px;\" class=\"small-muted\">Training points: <strong>${points.length}</strong></div>`;\n  }\n\n  function displayPredictionInfo(res){\n    if(!res) {\n      displayNoQueryInfo();\n      return;\n    }\n    const pred = res.predictedLabel;\n    const cls = classes.find(c=>c.id===pred);\n    const metric = metricSelect.value;\n    let html = `<div style=\"margin-bottom:6px;\">Predicted: <strong style=\"color:${cls?.color};\">${cls?.name || pred}</strong></div>`;\n    // show probabilities\n    html += `<table><thead><tr><th>Class</th><th>Probability</th></tr></thead><tbody>`;\n    const sorted = Object.entries(res.probs).sort((a,b)=>b[1]-a[1]);\n    sorted.forEach(([lab,prob])=>{\n      const cc = classes.find(c=>c.id==lab);\n      html += `<tr><td><span style=\"display:inline-block;width:10px;height:10px;margin-right:6px;background:${cc?.color};border-radius:2px;\"></span>${cc?.name}</td><td>${(prob*100).toFixed(1)}%</td></tr>`;\n    });\n    html += `</tbody></table>`;\n\n    // neighbor list\n    html += `<div style=\"margin-top:8px;\"><strong>Neighbors (closest first):</strong><div class=\"small-muted\">Distance measured with ${metric}, K=${kRange.value}</div>`;\n    html += `<ol style=\"margin:6px 0 0 18px;\">`;\n    res.neighbors.forEach((n, i) => {\n      const c = classes.find(cc=>cc.id===n.point.label);\n      html += `<li style=\"margin:4px 0;\"><span style=\"color:${c?.color};font-weight:600\">${c?.name}</span> — dist ${(n.dist).toFixed(3)}</li>`;\n    });\n    html += `</ol></div>`;\n    infoDiv.innerHTML = html;\n  }\n\n  // event handlers\n  canvas.addEventListener('click', (ev) => {\n    ev.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const px = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};\n    const norm = fromPx(px);\n    if(ev.shiftKey){\n      // add training point of selected class\n      points.push({x: norm.x, y: norm.y, label: selectedClassId});\n      redraw();\n    } else {\n      // set query point\n      query = norm;\n      redraw();\n    }\n  });\n\n  // right-click to remove nearest training point\n  canvas.addEventListener('contextmenu', (ev) => {\n    ev.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const px = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};\n    const norm = fromPx(px);\n    if(points.length === 0) return;\n    // find nearest training point in normalized coords (Euclidean)\n    let bestIdx = -1, bestD = Infinity;\n    points.forEach((pt, idx) => {\n      const dx = pt.x - norm.x, dy = pt.y - norm.y;\n      const d = Math.sqrt(dx*dx + dy*dy);\n      if(d < bestD){ bestD = d; bestIdx = idx; }\n    });\n    if(bestIdx >= 0){\n      points.splice(bestIdx,1);\n      redraw();\n    }\n  });\n\n  // UI updates\n  kRange.addEventListener('input', () => {\n    kVal.textContent = kRange.value;\n    redraw();\n  });\n\n  metricSelect.addEventListener('change', redraw);\n  showBoundaryCheckbox.addEventListener('change', () => { showBoundary = showBoundaryCheckbox.checked; redraw(); });\n\n  genBlobsBtn.addEventListener('click', () => {\n    // Generate random blobs for each class\n    points = [];\n    const perClass = 40;\n    classes.forEach((c, idx) => {\n      // choose a mean within bounds\n      const mx = 0.12 + (idx/(classes.length||1))*0.76 + rand(-0.08,0.08);\n      const my = 0.12 + (0.2 + Math.sin(idx*2.3))*0.6 + rand(-0.08,0.08);\n      const spread = 0.06 + Math.random()*0.08;\n      for(let i=0;i<perClass;i++){\n        const x = clamp(mx + (rand()-0.5)*spread*2, 0.02, 0.98);\n        const y = clamp(my + (rand()-0.5)*spread*2, 0.02, 0.98);\n        points.push({x,y,label:c.id});\n      }\n    });\n    query = null;\n    redraw();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    points = [];\n    query = null;\n    redraw();\n  });\n\n  addClassBtn.addEventListener('click', () => {\n    addClass();\n  });\n\n  resetClassesBtn.addEventListener('click', () => {\n    resetToThreeClasses();\n  });\n\n  shuffleBtn.addEventListener('click', () => {\n    // jitter all training points a bit\n    points = points.map(p => ({x: clamp(p.x + (rand()-0.5)*0.08, 0,1), y: clamp(p.y + (rand()-0.5)*0.08,0,1), label: p.label}));\n    redraw();\n  });\n\n  splitBtn.addEventListener('click', () => {\n    // reposition training points randomly across canvas\n    points = points.map(p => ({x: rand(0.05,0.95), y: rand(0.05,0.95), label: p.label}));\n    redraw();\n  });\n\n  function getWeighting(){\n    for(const r of weightRadios) if(r.checked) return r.value;\n    return 'uniform';\n  }\n  // re-render when weight changes\n  weightRadios.forEach(r => r.addEventListener('change', redraw));\n\n  // Keyboard shortcuts display mode\n  document.addEventListener('keydown', (e) => {\n    if(e.key === 'q'){ // toggle query mode message\n      clickModeLabel.textContent = clickModeLabel.textContent === 'Place query' ? 'Place training points (Shift+Click)' : 'Place query';\n    }\n  });\n\n  // Initial setup\n  ensureDefaultClasses();\n  // seed some points for demo\n  function seedDemo(){\n    // make a few points per class\n    points = [];\n    for(let i=0;i<classes.length;i++){\n      const mx = 0.2 + i * (0.6 / Math.max(1, classes.length-1));\n      for(let j=0;j<18;j++){\n        const angle = Math.random() * Math.PI*2;\n        const r = 0.06 + Math.random()*0.06;\n        const x = clamp(mx + Math.cos(angle)*r + rand(-0.02,0.02), 0.02, 0.98);\n        const y = clamp(0.5 + Math.sin(angle)*r + rand(-0.03,0.03), 0.02, 0.98);\n        points.push({x,y,label: classes[i].id});\n      }\n    }\n    query = {x:0.5, y:0.5};\n    redraw();\n  }\n\n  seedDemo();\n\n  // expose a tiny help overlay on first use\n  setTimeout(() => {\n    // no-op; we already have instructions\n  }, 500);\n\n  // ensure the UI shows current K\n  kVal.textContent = kRange.value;\n\n  // Add responsive redraw for window resize (scale canvas if needed)\n  window.addEventListener('resize', () => {\n    // keep fixed size for simplicity; could implement scaling\n    redraw();\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}