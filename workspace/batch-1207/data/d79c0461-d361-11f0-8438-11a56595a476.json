{
  "id": "d79c0461-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:01.618Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Red-Black Tree Visualization and Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    background-color: #f9fafb;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  h1 {\n    margin: 1rem 0 0.25rem 0;\n  }\n  #controls {\n    margin: 0.5rem 0 1rem 0;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 0.3rem 0.5rem;\n    font-size: 1.1rem;\n  }\n  button {\n    font-size: 1.1rem;\n    padding: 0.4rem 1rem;\n    margin-left: 0.5rem;\n    cursor: pointer;\n  }\n  #message {\n    margin-top: 0.5rem;\n    min-height: 1.2em;\n    color: #aa0000;\n  }\n  svg {\n    background-color: white;\n    border: 1px solid #ddd;\n    border-radius: 0.25rem;\n  }\n  .node {\n    cursor: pointer;\n    user-select: none;\n    transition: filter 0.3s ease;\n  }\n  .node:hover {\n    filter: drop-shadow(0 0 4px rgba(0,0,0,0.3));\n  }\n  .red {\n    fill: #e53935;\n    stroke: #b71c1c;\n  }\n  .black {\n    fill: #212121;\n    stroke: #000000;\n  }\n  .nil {\n    fill: #b0bec5;\n    stroke: #78909c;\n    font-style: italic;\n  }\n  line.link {\n    stroke: #555;\n    stroke-width: 2px;\n  }\n  #explanation {\n    max-width: 700px;\n    margin: 1rem;\n    font-size: 0.95rem;\n    line-height: 1.4;\n    background: #f0f4f8;\n    padding: 1rem 1rem 1rem 1rem;\n    border-radius: 5px;\n  }\n  a {\n    color: #1565c0;\n  }\n</style>\n</head>\n<body>\n<h1>Red-Black Tree Visualization</h1>\n\n<div id=\"controls\">\n  <input id=\"valueInput\" type=\"number\" placeholder=\"Enter value\" />\n  <button id=\"insertBtn\" title=\"Insert value\">Insert</button>\n  <button id=\"clearBtn\" title=\"Clear tree\">Clear Tree</button>\n</div>\n<div id=\"message\"></div>\n<svg id=\"treeSVG\" width=\"900\" height=\"500\" aria-label=\"Red-Black Tree visualization\" role=\"img\"></svg>\n<div id=\"explanation\">\n  <h2>About Red-Black Trees</h2>\n  <p>\n    A <strong>Red-Black Tree</strong> is a balanced binary search tree with extra color information for each node (red or black) that maintains the following properties to guarantee balanced height and thus fast operations:\n  </p>\n  <ul>\n    <li>Every node is either red or black.</li>\n    <li>The root is black.</li>\n    <li>All leaves (<em>nil</em> nodes) are black.</li>\n    <li>If a node is red, then both its children are black (no two reds in a row).</li>\n    <li>For each node, all paths from the node to its descendant leaves contain the same number of black nodes.</li>\n  </ul>\n  <p>\n    These properties ensure the height remains logarithmic with respect to the number of nodes, providing <code>O(log n)</code> complexity for insertion, deletion, and search.\n  </p>\n  <p>\n    Try inserting values above and watch how the tree balances and colors update.\n  </p>\n  <p>\n    Learn more: <a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\" target=\"_blank\" rel=\"noopener\">Wikipedia: Red-Black Tree</a>\n  </p>\n</div>\n\n<script>\n// --- Red Black Tree Implementation with Visualization ---\n\n// NIL node singleton to represent leaves\nclass NILNode {\n  constructor() {\n    this.color = \"black\";\n    this.isNil = true;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    this.value = null;\n  }\n}\nconst NIL = new NILNode();\n\nclass Node {\n  constructor(value, color = \"red\", parent = NIL) {\n    this.value = value;\n    this.color = color; // 'red' or 'black'\n    this.left = NIL;\n    this.right = NIL;\n    this.parent = parent;\n    this.isNil = false;\n  }\n}\n\nclass RedBlackTree {\n  constructor() {\n    this.root = NIL;\n  }\n\n  leftRotate(x) {\n    let y = x.right;\n    x.right = y.left;\n    if (y.left !== NIL) y.left.parent = x;\n    y.parent = x.parent;\n    if (x.parent === NIL) this.root = y;\n    else if (x === x.parent.left) x.parent.left = y;\n    else x.parent.right = y;\n    y.left = x;\n    x.parent = y;\n  }\n\n  rightRotate(y) {\n    let x = y.left;\n    y.left = x.right;\n    if (x.right !== NIL) x.right.parent = y;\n    x.parent = y.parent;\n    if (y.parent === NIL) this.root = x;\n    else if (y === y.parent.left) y.parent.left = x;\n    else y.parent.right = x;\n    x.right = y;\n    y.parent = x;\n  }\n\n  insert(value) {\n    let newNode = new Node(value);\n    let y = NIL;\n    let x = this.root;\n\n    while (x !== NIL) {\n      y = x;\n      if (value === x.value) {\n        // Duplicate, do not insert\n        return false;\n      }\n      if (value < x.value) x = x.left;\n      else x = x.right;\n    }\n\n    newNode.parent = y;\n    if (y === NIL) this.root = newNode;\n    else if (value < y.value) y.left = newNode;\n    else y.right = newNode;\n\n    newNode.left = NIL;\n    newNode.right = NIL;\n    newNode.color = \"red\";\n\n    this.insertFixup(newNode);\n    return true;\n  }\n\n  insertFixup(z) {\n    while (z.parent.color === \"red\") {\n      if (z.parent === z.parent.parent.left) {\n        let y = z.parent.parent.right;\n        if (y.color === \"red\") {\n          // Case 1\n          z.parent.color = \"black\";\n          y.color = \"black\";\n          z.parent.parent.color = \"red\";\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.right) {\n            // Case 2\n            z = z.parent;\n            this.leftRotate(z);\n          }\n          // Case 3\n          z.parent.color = \"black\";\n          z.parent.parent.color = \"red\";\n          this.rightRotate(z.parent.parent);\n        }\n      } else {\n        // Mirror cases\n        let y = z.parent.parent.left;\n        if (y.color === \"red\") {\n          // Case 1\n          z.parent.color = \"black\";\n          y.color = \"black\";\n          z.parent.parent.color = \"red\";\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.left) {\n            // Case 2\n            z = z.parent;\n            this.rightRotate(z);\n          }\n          // Case 3\n          z.parent.color = \"black\";\n          z.parent.parent.color = \"red\";\n          this.leftRotate(z.parent.parent);\n        }\n      }\n    }\n    this.root.color = \"black\";\n  }\n\n  clear() {\n    this.root = NIL;\n  }\n}\n\n// --- Visualization ---\n\nconst svg = document.getElementById(\"treeSVG\");\nconst width = svg.clientWidth;\nconst height = svg.clientHeight;\nconst radius = 18;\n\nfunction clearSVG() {\n  while (svg.firstChild) {\n    svg.removeChild(svg.firstChild);\n  }\n}\n\n// Calculate positions for nodes using in-order traversal and depth\nfunction calcNodePositions(treeRoot) {\n  const positions = new Map();\n  let maxDepth = 0;\n\n  // We need x positions spaced to avoid node overlap\n  // Use an in-order traversal to assign x positions increasing order\n  let xCounter = 0;\n\n  function inorder(node, depth) {\n    if (node === NIL) return;\n    if (depth > maxDepth) maxDepth = depth;\n    inorder(node.left, depth + 1);\n    positions.set(node, { x: xCounter, depth });\n    xCounter++;\n    inorder(node.right, depth + 1);\n  }\n\n  if (treeRoot === NIL) return { positions, maxDepth: 0 };\n  inorder(treeRoot, 0);\n  return { positions, maxDepth };\n}\n\nfunction drawTree(tree) {\n  clearSVG();\n  if (tree.root === NIL) {\n    // show empty message or nothing\n    return;\n  }\n  const { positions, maxDepth } = calcNodePositions(tree.root);\n\n  // Compute spacing\n  // Horizontal spacing = width / (total nodes + 1)\n  const totalNodes = positions.size;\n  const hSpacing = width / (totalNodes + 1);\n  const vSpacing = height / (maxDepth + 2);\n\n  // Draw edges first (lines)\n  positions.forEach((pos, node) => {\n    if (node.left !== NIL) {\n      drawLine(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, positions.get(node.left).x * hSpacing + hSpacing, positions.get(node.left).depth * vSpacing + vSpacing);\n    }\n    if (node.right !== NIL) {\n      drawLine(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, positions.get(node.right).x * hSpacing + hSpacing, positions.get(node.right).depth * vSpacing + vSpacing);\n    }\n  });\n\n  // Draw nodes\n  positions.forEach((pos, node) => {\n    drawNode(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, node);\n  });\n}\n\nfunction drawLine(x1, y1, x2, y2) {\n  const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n  line.setAttribute(\"x1\", x1);\n  line.setAttribute(\"y1\", y1);\n  line.setAttribute(\"x2\", x2);\n  line.setAttribute(\"y2\", y2);\n  line.setAttribute(\"class\", \"link\");\n  line.setAttribute(\"stroke-linecap\", \"round\");\n  svg.appendChild(line);\n}\n\nfunction drawNode(cx, cy, node) {\n  const group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  group.setAttribute(\"class\", \"node\");\n  group.setAttribute(\"transform\", `translate(${cx},${cy})`);\n  group.setAttribute(\"aria-label\", `Node value ${node.value}, color ${node.color}`);\n  group.setAttribute(\"role\", \"img\");\n\n  const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n  circle.setAttribute(\"r\", radius);\n  circle.setAttribute(\"class\", node.color === \"red\" ? \"red\" : \"black\");\n  circle.setAttribute(\"stroke-width\", \"3\");\n  group.appendChild(circle);\n\n  const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n  text.setAttribute(\"text-anchor\", \"middle\");\n  text.setAttribute(\"dominant-baseline\", \"middle\");\n  text.setAttribute(\"fill\", node.color === \"red\" ? \"#fff5f5\" : \"#e0e0e0\");\n  text.style.fontWeight = \"600\";\n  text.style.userSelect = \"none\";\n  text.textContent = node.value;\n  group.appendChild(text);\n\n  svg.appendChild(group);\n}\n\n// --- UI Interaction ---\n\nconst tree = new RedBlackTree();\n\nconst insertBtn = document.getElementById(\"insertBtn\");\nconst clearBtn = document.getElementById(\"clearBtn\");\nconst valueInput = document.getElementById(\"valueInput\");\nconst messageEl = document.getElementById(\"message\");\n\nfunction showMessage(msg, error = false) {\n  messageEl.textContent = msg;\n  messageEl.style.color = error ? \"#aa0000\" : \"#007700\";\n}\n\ninsertBtn.addEventListener(\"click\", () => {\n  const valStr = valueInput.value.trim();\n  if (valStr === \"\") {\n    showMessage(\"Please enter a value to insert.\", true);\n    valueInput.focus();\n    return;\n  }\n  const valNum = Number(valStr);\n  if (!Number.isInteger(valNum)) {\n    showMessage(\"Only integers are allowed.\", true);\n    valueInput.focus();\n    return;\n  }\n  const inserted = tree.insert(valNum);\n  if (!inserted) {\n    showMessage(`Value ${valNum} already exists in the tree.`, true);\n  } else {\n    showMessage(`Inserted value ${valNum}.`);\n  }\n  valueInput.value = \"\";\n  valueInput.focus();\n  drawTree(tree);\n});\n\nclearBtn.addEventListener(\"click\", () => {\n  tree.clear();\n  clearSVG();\n  showMessage(\"Tree cleared.\");\n  valueInput.value = \"\";\n  valueInput.focus();\n});\n\n// Press Enter in input triggers insert\nvalueInput.addEventListener(\"keydown\", e => {\n  if (e.key === \"Enter\") {\n    insertBtn.click();\n  }\n});\n\n// Initial message\nshowMessage(\"Enter integers and click Insert to add nodes.\");\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}