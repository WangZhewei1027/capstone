{
  "id": "d7b30211-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:24.209Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap (Min/Max) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    margin-bottom: 5px;\n  }\n  #heapType {\n    margin-bottom: 10px;\n  }\n  input, button {\n    padding: 8px;\n    margin: 4px 0;\n    font-size: 1rem;\n  }\n  #heapVisual {\n    margin-top: 20px;\n  }\n  .heap-array {\n    font-family: monospace;\n    background: #f0f0f0;\n    padding: 10px;\n    border-radius: 6px;\n    display: inline-block;\n  }\n  #treeCanvas {\n    margin-top: 20px;\n    border: 1px solid #ccc;\n    background: #fafafa;\n  }\n  #controls {\n    margin-bottom: 10px;\n  }\n  #messages {\n    margin-top: 10px;\n    min-height: 24px;\n    color: #d33;\n    font-weight: bold;\n  }\n</style>\n</head>\n<body>\n<h1>Heap (Min/Max) Demonstration</h1>\n\n<label for=\"heapType\">Select Heap Type:</label>\n<select id=\"heapType\">\n  <option value=\"min\">Min Heap</option>\n  <option value=\"max\">Max Heap</option>\n</select>\n\n<div id=\"controls\">\n  <input type=\"number\" id=\"newValue\" placeholder=\"Enter value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"extractBtn\">Extract Root</button>\n  <button id=\"clearBtn\">Clear</button>\n</div>\n\n<div id=\"messages\"></div>\n\n<h3>Heap Array Representation:</h3>\n<div class=\"heap-array\" id=\"heapArray\">[]</div>\n\n<h3>Heap Tree Visualization:</h3>\n<canvas id=\"treeCanvas\" width=\"600\" height=\"300\"></canvas>\n\n<script>\n// Heap implementation supporting Min and Max heap types\nclass Heap {\n  constructor(type = 'min') {\n    this.type = type;\n    this.data = [];\n  }\n\n  // Compare function depends on heap type\n  compare(a, b) {\n    if (this.type === 'min') return a < b;\n    else return a > b;\n  }\n\n  insert(value) {\n    this.data.push(value);\n    this.bubbleUp(this.data.length - 1);\n  }\n\n  bubbleUp(index) {\n    if (index === 0) return;\n    const parentIndex = Math.floor((index - 1) / 2);\n    if (this.compare(this.data[index], this.data[parentIndex])) {\n      this.swap(index, parentIndex);\n      this.bubbleUp(parentIndex);\n    }\n  }\n\n  extractRoot() {\n    if (this.data.length === 0) return null;\n    if (this.data.length === 1) return this.data.pop();\n\n    const root = this.data[0];\n    this.data[0] = this.data.pop();\n    this.bubbleDown(0);\n    return root;\n  }\n\n  bubbleDown(index) {\n    const leftIndex = 2 * index + 1;\n    const rightIndex = 2 * index + 2;\n    let swapIndex = index;\n\n    if (\n      leftIndex < this.data.length &&\n      this.compare(this.data[leftIndex], this.data[swapIndex])\n    ) {\n      swapIndex = leftIndex;\n    }\n\n    if (\n      rightIndex < this.data.length &&\n      this.compare(this.data[rightIndex], this.data[swapIndex])\n    ) {\n      swapIndex = rightIndex;\n    }\n\n    if (swapIndex !== index) {\n      this.swap(index, swapIndex);\n      this.bubbleDown(swapIndex);\n    }\n  }\n\n  swap(i, j) {\n    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];\n  }\n\n  clear() {\n    this.data = [];\n  }\n\n  getHeap() {\n    return this.data.slice();\n  }\n}\n\n// Drawing the heap tree on canvas\nfunction drawHeapTree(heapArray, canvas, type) {\n  const ctx = canvas.getContext('2d');\n  const width = canvas.width;\n  const height = canvas.height;\n  ctx.clearRect(0, 0, width, height);\n\n  if (heapArray.length === 0) {\n    ctx.font = '16px Arial';\n    ctx.fillStyle = '#666';\n    ctx.fillText('Heap is empty', width / 2 - 50, height / 2);\n    return;\n  }\n\n  // Calculate x,y positions for each node in a binary tree layout\n  const nodePositions = [];\n  const levels = Math.floor(Math.log2(heapArray.length)) + 1;\n  const levelHeight = height / (levels + 1);\n\n  // For each level, calculate horizontal spacing\n  for (let level = 0; level < levels; level++) {\n    const levelCount = Math.pow(2, level);\n    const horizontalSpacing = width / (levelCount + 1);\n    for (let i = 0; i < levelCount; i++) {\n      const nodeIndex = Math.pow(2, level) - 1 + i;\n      if (nodeIndex >= heapArray.length) break;\n      const x = horizontalSpacing * (i + 1);\n      const y = levelHeight * (level + 1);\n      nodePositions[nodeIndex] = { x, y };\n    }\n  }\n\n  // Draw edges\n  ctx.strokeStyle = '#333';\n  ctx.lineWidth = 2;\n  for (let i = 1; i < heapArray.length; i++) {\n    const parentIndex = Math.floor((i - 1) / 2);\n    const from = nodePositions[parentIndex];\n    const to = nodePositions[i];\n    ctx.beginPath();\n    ctx.moveTo(from.x, from.y + 20);\n    ctx.lineTo(to.x, to.y - 20);\n    ctx.stroke();\n  }\n\n  // Draw nodes\n  const radius = 20;\n  for (let i = 0; i < heapArray.length; i++) {\n    const node = nodePositions[i];\n    ctx.beginPath();\n    ctx.fillStyle = type === 'min' ? '#4caf50' : '#ff5722';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // Draw text (value)\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(heapArray[i], node.x, node.y);\n  }\n}\n\n// Main app logic\ndocument.addEventListener('DOMContentLoaded', () => {\n  const heapTypeSelect = document.getElementById('heapType');\n  const insertBtn = document.getElementById('insertBtn');\n  const extractBtn = document.getElementById('extractBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const newValueInput = document.getElementById('newValue');\n  const heapArrayDiv = document.getElementById('heapArray');\n  const treeCanvas = document.getElementById('treeCanvas');\n  const messages = document.getElementById('messages');\n\n  let heap = new Heap(heapTypeSelect.value);\n\n  function updateDisplay() {\n    const arr = heap.getHeap();\n    heapArrayDiv.textContent = JSON.stringify(arr);\n    drawHeapTree(arr, treeCanvas, heap.type);\n  }\n\n  function showMessage(msg, isError = false) {\n    messages.textContent = msg;\n    messages.style.color = isError ? '#d33' : '#333';\n    if (msg !== '') {\n      setTimeout(() => {\n        if (messages.textContent === msg) messages.textContent = '';\n      }, 3000);\n    }\n  }\n\n  insertBtn.addEventListener('click', () => {\n    const valStr = newValueInput.value.trim();\n    if (valStr === '') {\n      showMessage('Please enter a value to insert.', true);\n      return;\n    }\n    const val = Number(valStr);\n    if (isNaN(val)) {\n      showMessage('Invalid number entered.', true);\n      return;\n    }\n    heap.insert(val);\n    newValueInput.value = '';\n    updateDisplay();\n    showMessage(`Inserted value ${val}.`, false);\n  });\n\n  extractBtn.addEventListener('click', () => {\n    const root = heap.extractRoot();\n    if (root === null) {\n      showMessage('Heap is empty, nothing to extract.', true);\n      return;\n    }\n    updateDisplay();\n    showMessage(`Extracted root value ${root}.`, false);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    heap.clear();\n    updateDisplay();\n    showMessage('Heap cleared.', false);\n  });\n\n  heapTypeSelect.addEventListener('change', () => {\n    heap = new Heap(heapTypeSelect.value);\n    updateDisplay();\n    showMessage(`Switched to ${heapTypeSelect.options[heapTypeSelect.selectedIndex].text}. Heap cleared.`, false);\n  });\n\n  updateDisplay();\n});\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}