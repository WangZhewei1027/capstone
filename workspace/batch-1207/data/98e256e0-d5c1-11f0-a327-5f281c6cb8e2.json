{
  "id": "98e256e0-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:37.860Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Bellman-Ford Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#7c3aed;\n      --muted:#94a3b8;\n      --card:#0b1220;\n      --ok:#16a34a;\n      --bad:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{background: linear-gradient(180deg,#071029 0%, #071727 50%); color:#e6eef8; display:flex; gap:12px; padding:14px; box-sizing:border-box;}\n    .sidebar{\n      width:360px;\n      min-width:260px;\n      background:var(--panel);\n      padding:12px;\n      border-radius:12px;\n      box-shadow: 0 6px 22px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n    }\n    .canvas-wrap{\n      flex:1;\n      position:relative;\n      border-radius:12px;\n      overflow:hidden;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n      display:flex;\n      flex-direction:column;\n    }\n    .topbar{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    button, .seg {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button.active, .seg.active { border-color: var(--accent); color:#c7b3ff; box-shadow: 0 4px 18px rgba(124,58,237,0.12); }\n    button.small { padding:6px 8px; font-size:12px; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; }\n    .hint{ font-size:12px; color:var(--muted); margin-top:6px;}\n    canvas{ flex:1; display:block; background:\n      radial-gradient(1200px 800px at 10% 10%, rgba(124,58,237,0.04), transparent 6%),\n      radial-gradient(700px 400px at 90% 90%, rgba(16,185,129,0.02), transparent 4%); cursor:crosshair;\n    }\n    .panel-section {\n      background:var(--glass);\n      border-radius:10px;\n      padding:10px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .row { display:flex; gap:8px; align-items:center; }\n    .table {\n      max-height:220px;\n      overflow:auto;\n      margin-top:8px;\n      border-radius:6px;\n      border:1px solid rgba(255,255,255,0.02);\n      padding:6px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n    }\n    .table .item { display:flex; gap:10px; align-items:center; padding:6px 6px; border-radius:6px; }\n    .badge { font-size:12px; color: #111827; background: rgba(255,255,255,0.06); padding:4px 8px; border-radius:6px; min-width:38px; text-align:center; }\n    .status { font-size:13px; }\n    .log { max-height:160px; overflow:auto; font-size:13px; color:var(--muted); background:transparent; padding:6px; border-radius:6px; }\n    .footer {\n      display:flex;\n      gap:8px;\n      margin-top:auto;\n      align-items:center;\n      justify-content:space-between;\n    }\n    .small-muted { font-size:12px; color:var(--muted); }\n    .danger { color:var(--bad); font-weight:600; }\n    .ok { color:var(--ok); font-weight:600; }\n    .node-label { font-weight:700; font-size:13px; color:#e6eef8; }\n    .controls .seg { padding:6px 8px; }\n    .help { font-size:12px; color:var(--muted); }\n    input[type=range]{ width:120px; }\n  </style>\n</head>\n<body>\n  <div class=\"sidebar panel-section\">\n    <div class=\"topbar\">\n      <div style=\"font-weight:800; font-size:16px; color:#fff;\">Bellman-Ford Visualizer</div>\n      <div style=\"margin-left:auto; font-size:12px; color:var(--muted);\">Step-by-step relaxation</div>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"btn-add-node\" class=\"seg active\">Add Node</button>\n      <button id=\"btn-add-edge\" class=\"seg\">Add Edge</button>\n      <button id=\"btn-select-source\" class=\"seg\">Select Source</button>\n      <button id=\"btn-set-target\" class=\"seg\">Select Target</button>\n      <button id=\"btn-clear\" class=\"seg small\">Clear</button>\n    </div>\n    <div class=\"hint\">Click canvas to add nodes. For edges: click source node then target node. Double-click node to delete it. Double-click edge to delete it.</div>\n\n    <div class=\"panel-section\" style=\"margin-top:8px;\">\n      <div style=\"display:flex; gap:8px; align-items:center;\">\n        <button id=\"btn-run\" class=\"seg\">Run Bellman‑Ford</button>\n        <button id=\"btn-step-back\" class=\"seg small\">⟵</button>\n        <button id=\"btn-step\" class=\"seg small\">⟶</button>\n        <button id=\"btn-play\" class=\"seg small\">Play</button>\n        <label class=\"small-muted\" style=\"margin-left:auto\">Speed:</label>\n        <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" value=\"800\" step=\"50\" />\n      </div>\n      <div class=\"hint\">Step through relaxations. After n-1 iterations, Bellman-Ford detects negative cycles if present.</div>\n    </div>\n\n    <div class=\"panel-section\">\n      <div style=\"display:flex; gap:8px; align-items:center;\">\n        <div class=\"small-muted\">Iterations:</div>\n        <div id=\"lbl-iteration\" class=\"badge\">0</div>\n        <div style=\"width:8px;\"></div>\n        <div class=\"small-muted\">Current Edge:</div>\n        <div id=\"lbl-edge\" class=\"badge\">—</div>\n      </div>\n\n      <div class=\"table\" id=\"distance-table\" aria-live=\"polite\"></div>\n    </div>\n\n    <div class=\"panel-section\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div style=\"font-weight:700\">Log</div>\n        <div class=\"small-muted\">Negative cycle: <span id=\"neg-status\" class=\"small-muted\">unknown</span></div>\n      </div>\n      <div class=\"log\" id=\"log\"></div>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"small-muted\">Click a node as Target to highlight shortest path.</div>\n      <div style=\"display:flex; gap:8px;\">\n        <div id=\"lbl-source\" class=\"badge\">S: —</div>\n        <div id=\"lbl-target\" class=\"badge\">T: —</div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n\n<script>\n/*\n  Bellman-Ford Visualizer\n  - Add nodes by clicking canvas.\n  - Add edges by selecting \"Add Edge\" and clicking source then target. You will be prompted for weight (can be negative).\n  - Select source: choose source node for algorithm.\n  - Select target: choose a target node to highlight final path.\n  - Run Bellman-Ford: produces step history. Use arrows to step, Play to animate.\n  - Double-click node to delete. Double-click edge to delete (click near edge).\n*/\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nlet DPR = window.devicePixelRatio || 1;\n\nfunction resizeCanvas(){\n  DPR = window.devicePixelRatio || 1;\n  canvas.width = Math.floor(canvas.clientWidth * DPR);\n  canvas.height = Math.floor(canvas.clientHeight * DPR);\n  ctx.setTransform(DPR,0,0,DPR,0,0);\n  draw();\n}\nwindow.addEventListener('resize', resizeCanvas);\nsetTimeout(resizeCanvas, 10);\n\n// Graph model\nlet nodes = []; // {id,x,y}\nlet edges = []; // {id,u,v,w}\nlet nodeIdCounter = 0;\nlet edgeIdCounter = 0;\n\nconst stateMode = {\n  addNode:true, addEdge:false, selectSource:false, selectTarget:false\n};\n\nconst elements = {\n  btnAddNode: document.getElementById('btn-add-node'),\n  btnAddEdge: document.getElementById('btn-add-edge'),\n  btnSelectSource: document.getElementById('btn-select-source'),\n  btnSetTarget: document.getElementById('btn-set-target'),\n  btnClear: document.getElementById('btn-clear'),\n  btnRun: document.getElementById('btn-run'),\n  btnStep: document.getElementById('btn-step'),\n  btnStepBack: document.getElementById('btn-step-back'),\n  btnPlay: document.getElementById('btn-play'),\n  lblIteration: document.getElementById('lbl-iteration'),\n  lblEdge: document.getElementById('lbl-edge'),\n  distanceTable: document.getElementById('distance-table'),\n  log: document.getElementById('log'),\n  negStatus: document.getElementById('neg-status'),\n  lblSource: document.getElementById('lbl-source'),\n  lblTarget: document.getElementById('lbl-target'),\n  speed: document.getElementById('speed')\n};\n\n// Interaction state\nlet edgeTemp = null; // {fromNodeId}\nlet selectedSource = null;\nlet selectedTarget = null;\n\n// Visualization state\nlet history = []; // snapshots array\nlet stepIndex = 0;\nlet playing = false;\nlet playTimer = null;\n\nfunction setMode(mode){\n  // mode is one of addNode, addEdge, selectSource, selectTarget\n  for(let k in stateMode) stateMode[k] = false;\n  stateMode[mode] = true;\n  elements.btnAddNode.classList.toggle('active', stateMode.addNode);\n  elements.btnAddEdge.classList.toggle('active', stateMode.addEdge);\n  elements.btnSelectSource.classList.toggle('active', stateMode.selectSource);\n  elements.btnSetTarget.classList.toggle('active', stateMode.selectTarget);\n}\nelements.btnAddNode.addEventListener('click', ()=> setMode('addNode'));\nelements.btnAddEdge.addEventListener('click', ()=> setMode('addEdge'));\nelements.btnSelectSource.addEventListener('click', ()=> setMode('selectSource'));\nelements.btnSetTarget.addEventListener('click', ()=> setMode('selectTarget'));\nelements.btnClear.addEventListener('click', ()=> {\n  if(!confirm('Clear entire graph?')) return;\n  nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;\n  history = []; stepIndex = 0; playing = false; clearInterval(playTimer); playTimer=null;\n  selectedSource = null; selectedTarget = null;\n  elements.lblSource.textContent = 'S: —';\n  elements.lblTarget.textContent = 'T: —';\n  elements.negStatus.textContent = 'unknown';\n  elements.distanceTable.innerHTML = '';\n  elements.log.innerHTML = '';\n  draw();\n});\n\nelements.btnRun.addEventListener('click', ()=> {\n  if(nodes.length===0){ alert('Add nodes first'); return; }\n  if(selectedSource==null){ alert('Select a source node first. Click \"Select Source\" and then a node.'); return; }\n  runBellmanFord();\n});\n\nelements.btnStep.addEventListener('click', ()=> {\n  if(history.length===0){ alert('Run algorithm first'); return; }\n  if(stepIndex < history.length-1){\n    stepIndex++;\n    applySnapshot(stepIndex);\n  }\n});\nelements.btnStepBack.addEventListener('click', ()=> {\n  if(history.length===0) return;\n  if(stepIndex>0){ stepIndex--; applySnapshot(stepIndex); }\n});\nelements.btnPlay.addEventListener('click', ()=> {\n  if(history.length===0){ alert('Run algorithm first'); return; }\n  if(playing){ playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }\n  else {\n    playing=true; elements.btnPlay.textContent='Pause';\n    playTimer = setInterval(()=>{\n      if(stepIndex < history.length-1){ stepIndex++; applySnapshot(stepIndex); }\n      else { playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }\n    }, parseInt(elements.speed.value));\n  }\n});\n\nelements.speed.addEventListener('input', ()=> {\n  if(playing){\n    clearInterval(playTimer);\n    playTimer = setInterval(()=>{\n      if(stepIndex < history.length-1){ stepIndex++; applySnapshot(stepIndex); }\n      else { playing=false; clearInterval(playTimer); elements.btnPlay.textContent='Play'; }\n    }, parseInt(elements.speed.value));\n  }\n});\n\n// Canvas events\ncanvas.addEventListener('click', (ev)=> {\n  const rect = canvas.getBoundingClientRect();\n  const x = (ev.clientX - rect.left);\n  const y = (ev.clientY - rect.top);\n  if(stateMode.addNode){\n    addNode(x,y);\n    return;\n  }\n  const clickedNode = findNodeAt(x,y);\n  if(stateMode.addEdge){\n    if(edgeTemp==null){\n      if(clickedNode){\n        edgeTemp = {from: clickedNode.id};\n        // set temporary indicator\n      }\n    } else {\n      if(clickedNode && clickedNode.id !== edgeTemp.from){\n        // prompt weight\n        let w = prompt('Edge weight (number, can be negative):', '1');\n        if(w===null) { edgeTemp=null; draw(); return; }\n        w = parseFloat(w);\n        if(Number.isNaN(w)){ alert('Invalid number'); edgeTemp=null; draw(); return; }\n        addEdge(edgeTemp.from, clickedNode.id, w);\n      }\n      edgeTemp = null;\n    }\n    draw();\n    return;\n  }\n  if(stateMode.selectSource){\n    if(clickedNode){\n      selectedSource = clickedNode.id;\n      elements.lblSource.textContent = 'S: ' + labelForNode(selectedSource);\n      setMode('addNode');\n    }\n    return;\n  }\n  if(stateMode.selectTarget){\n    if(clickedNode){\n      selectedTarget = clickedNode.id;\n      elements.lblTarget.textContent = 'T: ' + labelForNode(selectedTarget);\n      setMode('addNode');\n    }\n    return;\n  }\n  // Not in any mode - maybe select target for path highlight\n  if(clickedNode){\n    selectedTarget = clickedNode.id;\n    elements.lblTarget.textContent = 'T: ' + labelForNode(selectedTarget);\n    draw();\n  }\n});\n\n// double-click to delete nodes / edges\ncanvas.addEventListener('dblclick', (ev)=> {\n  const rect = canvas.getBoundingClientRect();\n  const x = (ev.clientX - rect.left);\n  const y = (ev.clientY - rect.top);\n  const clickedNode = findNodeAt(x,y);\n  if(clickedNode){\n    if(!confirm('Delete node ' + labelForNode(clickedNode.id) + ' and its incident edges?')) return;\n    deleteNode(clickedNode.id);\n    return;\n  }\n  const clickedEdge = findEdgeNear(x,y);\n  if(clickedEdge){\n    if(!confirm('Delete edge ' + labelForNode(clickedEdge.u) + ' → ' + labelForNode(clickedEdge.v) + ' ?')) return;\n    deleteEdge(clickedEdge.id);\n    return;\n  }\n});\n\n// Helpers\nfunction addNode(x,y){\n  const id = nodeIdCounter++;\n  nodes.push({id:id, x:x, y:y});\n  draw();\n}\nfunction deleteNode(id){\n  nodes = nodes.filter(n=>n.id!==id);\n  edges = edges.filter(e=> e.u !== id && e.v !== id);\n  if(selectedSource === id) selectedSource=null;\n  if(selectedTarget === id) selectedTarget=null;\n  draw();\n}\nfunction addEdge(u,v,w){\n  const id = edgeIdCounter++;\n  edges.push({id:id, u:u, v:v, w: w});\n  draw();\n}\nfunction deleteEdge(id){\n  edges = edges.filter(e=>e.id!==id);\n  draw();\n}\nfunction findNodeAt(x,y){\n  for(let i=nodes.length-1;i>=0;i--){\n    const n = nodes[i];\n    const dx = n.x - x, dy = n.y - y;\n    if(Math.sqrt(dx*dx+dy*dy) <= 18) return n;\n  }\n  return null;\n}\nfunction findEdgeNear(x,y){\n  // Returns first edge near click (distance to segment <8)\n  for(let e of edges){\n    const a = nodes.find(n=>n.id===e.u);\n    const b = nodes.find(n=>n.id===e.v);\n    if(!a||!b) continue;\n    const dist = distancePointToSegment({x,y}, a, b);\n    if(dist < 8) return e;\n  }\n  return null;\n}\nfunction distancePointToSegment(p, a, b){\n  const vx = b.x - a.x, vy = b.y - a.y;\n  const wx = p.x - a.x, wy = p.y - a.y;\n  const c1 = vx*wx + vy*wy;\n  if(c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);\n  const c2 = vx*vx + vy*vy;\n  if(c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);\n  const t = c1 / c2;\n  const projx = a.x + t*vx, projy = a.y + t*vy;\n  return Math.hypot(p.x-projx, p.y-projy);\n}\nfunction labelForNode(id){\n  return String.fromCharCode(65 + (id % 26)) + (Math.floor(id/26) ? (Math.floor(id/26)) : '');\n}\n\n// Drawing\nfunction draw(snapshot=null){\n  // snapshot: optional for highlighting current frame (history[stepIndex])\n  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);\n  // draw edges\n  for(let e of edges){\n    drawEdge(e, snapshot);\n  }\n  // draw nodes\n  for(let n of nodes){\n    drawNode(n, snapshot);\n  }\n  // if adding edge and have temp from, draw fade line to mouse? We don't track mouse - skip\n  if(edgeTemp && edgeTemp.from != null){\n    const fromNode = nodes.find(nn=>nn.id===edgeTemp.from);\n    // draw ring around from\n    if(fromNode){\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(124,58,237,0.6)';\n      ctx.lineWidth = 3;\n      ctx.arc(fromNode.x, fromNode.y, 22, 0, Math.PI*2);\n      ctx.stroke();\n    }\n  }\n}\n\nfunction drawNode(n, snapshot){\n  const r = 18;\n  // Determine highlight\n  let fill = 'rgba(8,12,20,0.9)';\n  let stroke = 'rgba(255,255,255,0.06)';\n  let textColor = '#e6eef8';\n  if(n.id === selectedSource) { stroke = 'rgba(124,58,237,0.95)'; fill = 'rgba(124,58,237,0.12)'; }\n  if(n.id === selectedTarget) { stroke = 'rgba(16,185,129,0.95)'; fill = 'rgba(16,185,129,0.08)'; }\n  // If snapshot includes updated nodes or in negative cycle set, color accordingly\n  if(snapshot){\n    const dist = snapshot.distances[n.id];\n    if(Number.isFinite(dist) && snapshot.updated && snapshot.updated.has(n.id)){\n      fill = 'rgba(34,197,94,0.12)'; stroke = 'rgba(34,197,94,0.9)';\n    }\n    if(snapshot.negativeCycleNodes && snapshot.negativeCycleNodes.has(n.id)){\n      fill = 'rgba(239,68,68,0.14)'; stroke = 'rgba(239,68,68,0.9)';\n    }\n  }\n  ctx.beginPath();\n  ctx.fillStyle = fill;\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = 2;\n  roundRect(ctx, n.x - r, n.y - r, r*2, r*2, 40);\n  ctx.fill();\n  ctx.stroke();\n\n  // label\n  ctx.fillStyle = textColor;\n  ctx.font = 'bold 13px system-ui,Arial';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(labelForNode(n.id), n.x, n.y - 2);\n\n  // distance bubble\n  if(snapshot && snapshot.distances){\n    const d = snapshot.distances[n.id];\n    ctx.fillStyle = 'rgba(255,255,255,0.04)';\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.lineWidth = 1;\n    const w = 56, h = 22;\n    roundRect(ctx, n.x - w/2, n.y + 14, w, h, 6);\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = 'rgba(200,220,255,0.95)';\n    ctx.font = '12px system-ui,Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(Number.isFinite(d) ? d.toString() : '∞', n.x, n.y + 14 + h/2);\n  }\n}\n\nfunction drawEdge(e, snapshot){\n  const a = nodes.find(n=>n.id===e.u);\n  const b = nodes.find(n=>n.id===e.v);\n  if(!a || !b) return;\n  // arrow\n  const dx = b.x - a.x, dy = b.y - a.y;\n  const ang = Math.atan2(dy, dx);\n  const offset = 22;\n  const fromX = a.x + Math.cos(ang) * offset;\n  const fromY = a.y + Math.sin(ang) * offset;\n  const toX = b.x - Math.cos(ang) * offset;\n  const toY = b.y - Math.sin(ang) * offset;\n\n  // Determine color\n  let color = 'rgba(255,255,255,0.06)';\n  let width = 1.2;\n  let dashed = false;\n\n  if(snapshot){\n    // Highlight current edge\n    if(snapshot.currentEdge && snapshot.currentEdge.id === e.id){\n      color = 'rgba(124,58,237,0.95)';\n      width = 3.0;\n    }\n    // If relaxed this step, color green\n    if(snapshot.relaxedEdge && snapshot.relaxedEdge.id === e.id){\n      color = 'rgba(34,197,94,0.95)';\n      width = 3.2;\n    }\n    // If part of negative cycle, red\n    if(snapshot.negativeCycleEdges && snapshot.negativeCycleEdges.has(e.id)){\n      color = 'rgba(239,68,68,0.95)';\n      width = 3.0;\n      dashed = false;\n    }\n  }\n\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  if(dashed) ctx.setLineDash([6,6]); else ctx.setLineDash([]);\n  ctx.moveTo(fromX, fromY);\n  ctx.lineTo(toX, toY);\n  ctx.stroke();\n\n  // arrow head\n  ctx.beginPath();\n  ctx.fillStyle = color;\n  ctx.setLineDash([]);\n  const arrowSize = 8;\n  ctx.moveTo(toX, toY);\n  ctx.lineTo(toX - arrowSize * Math.cos(ang - Math.PI/8), toY - arrowSize * Math.sin(ang - Math.PI/8));\n  ctx.lineTo(toX - arrowSize * Math.cos(ang + Math.PI/8), toY - arrowSize * Math.sin(ang + Math.PI/8));\n  ctx.closePath();\n  ctx.fill();\n\n  // weight label near middle\n  const mx = (fromX + toX)/2, my = (fromY + toY)/2;\n  ctx.fillStyle = 'rgba(255,255,255,0.8)';\n  ctx.font = '12px system-ui,Arial';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(e.w, mx, my - 10);\n}\n\nfunction roundRect(ctx,x,y,w,h,r){\n  ctx.beginPath();\n  ctx.moveTo(x+r, y);\n  ctx.arcTo(x+w, y,   x+w, y+h, r);\n  ctx.arcTo(x+w, y+h, x,   y+h, r);\n  ctx.arcTo(x,   y+h, x,   y,   r);\n  ctx.arcTo(x,   y,   x+w, y,   r);\n  ctx.closePath();\n}\n\n// Bellman-Ford algorithm: produce history of snapshots for visualization\nfunction runBellmanFord(){\n  // Build adjacency list from edges\n  const n = nodes.length;\n  const nodeIds = nodes.map(n=>n.id);\n  const idIndex = {};\n  nodeIds.forEach((id, i)=> idIndex[id] = i);\n\n  // Initialize distances\n  const INF = Infinity;\n  let dist = {};\n  let pred = {};\n  for(let id of nodeIds){\n    dist[id] = INF;\n    pred[id] = null;\n  }\n  dist[selectedSource] = 0;\n\n  history = [];\n  // initial snapshot\n  history.push({\n    iteration: 0,\n    edgeIndex: -1,\n    currentEdge: null,\n    relaxedEdge: null,\n    distances: {...dist},\n    predecessors: {...pred},\n    updated: new Set(),\n    negativeCycleEdges: new Set(),\n    negativeCycleNodes: new Set(),\n    log: ['Initialized distances (source ' + labelForNode(selectedSource) + ' = 0)']\n  });\n\n  // Relax edges n-1 times, record each relaxation attempt as a snapshot\n  let log = [];\n  for(let iter=1; iter<=n-1; iter++){\n    let anyUpdateThisIter = false;\n    for(let ei=0; ei<edges.length; ei++){\n      const e = edges[ei];\n      const u = e.u, v = e.v, w = e.w;\n      const oldDistV = dist[v];\n      const currEdgeInfo = {id:e.id, u:u, v:v, w:w};\n      let distancesBefore = {...dist};\n      let predsBefore = {...pred};\n      // create snapshot for current edge attempt before relaxation action\n      history.push({\n        iteration: iter,\n        edgeIndex: ei,\n        currentEdge: currEdgeInfo,\n        relaxedEdge: null,\n        distances: {...dist},\n        predecessors: {...pred},\n        updated: new Set(),\n        negativeCycleEdges: new Set(),\n        negativeCycleNodes: new Set(),\n        log: null\n      });\n\n      if(Number.isFinite(dist[u]) && dist[u] + w < dist[v]){\n        // relax\n        dist[v] = dist[u] + w;\n        pred[v] = u;\n        anyUpdateThisIter = true;\n        const stepLog = 'Iter ' + iter + ': Relax edge ' + labelForNode(u) + '→' + labelForNode(v) + ' (w=' + w + '), updated dist[' + labelForNode(v) + '] = ' + dist[v];\n        history.push({\n          iteration: iter,\n          edgeIndex: ei,\n          currentEdge: currEdgeInfo,\n          relaxedEdge: currEdgeInfo,\n          distances: {...dist},\n          predecessors: {...pred},\n          updated: new Set([v]),\n          negativeCycleEdges: new Set(),\n          negativeCycleNodes: new Set(),\n          log: stepLog\n        });\n      } else {\n        const stepLog = 'Iter ' + iter + ': Edge ' + labelForNode(u) + '→' + labelForNode(v) + ' (w=' + w + '), no change';\n        // Repeat state (no change) to show attempt\n        history.push({\n          iteration: iter,\n          edgeIndex: ei,\n          currentEdge: currEdgeInfo,\n          relaxedEdge: null,\n          distances: {...dist},\n          predecessors: {...pred},\n          updated: new Set(),\n          negativeCycleEdges: new Set(),\n          negativeCycleNodes: new Set(),\n          log: stepLog\n        });\n      }\n    }\n    if(!anyUpdateThisIter){\n      // early stop; record that we have converged\n      history.push({\n        iteration: iter,\n        edgeIndex: edges.length,\n        currentEdge: null,\n        relaxedEdge: null,\n        distances: {...dist},\n        predecessors: {...pred},\n        updated: new Set(),\n        negativeCycleEdges: new Set(),\n        negativeCycleNodes: new Set(),\n        log: 'Terminated early at iteration ' + iter + ' (no changes)'\n      });\n      break;\n    }\n  }\n\n  // After n-1 iterations, detect negative cycles: run one more pass and see edges that can still relax\n  const possibleNegEdges = new Set();\n  for(let e of edges){\n    const u=e.u, v=e.v, w=e.w;\n    if(Number.isFinite(dist[u]) && dist[u] + w < dist[v]){\n      possibleNegEdges.add(e.id);\n    }\n  }\n\n  let negativeCycleNodes = new Set();\n  let negativeCycleEdges = new Set();\n  if(possibleNegEdges.size>0){\n    // From nodes involved, follow predecessors to extract cycles\n    for(let eid of possibleNegEdges){\n      negativeCycleEdges.add(eid);\n      const e = edges.find(x=>x.id===eid);\n      if(!e) continue;\n      // find a node reachable from v by following predecessors up to n times to form a cycle\n      let node = e.v;\n      // move up n steps to ensure within cycle\n      for(let i=0;i<n;i++) node = (pred[node] !== null) ? pred[node] : node;\n      // now record cycle by following successors (pred pointers) until we loop\n      let current = node;\n      const visited = new Set();\n      for(let i=0;i<n*2;i++){\n        if(visited.has(current)) break;\n        visited.add(current);\n        negativeCycleNodes.add(current);\n        if(pred[current] === null) break;\n        // find edge pred[current] -> current\n        const ed = edges.find(x=> x.u === pred[current] && x.v === current);\n        if(ed) negativeCycleEdges.add(ed.id);\n        current = pred[current];\n      }\n    }\n    // record detection snapshot\n    history.push({\n      iteration: Number.MAX_SAFE_INTEGER,\n      edgeIndex: -1,\n      currentEdge: null,\n      relaxedEdge: null,\n      distances: {...dist},\n      predecessors: {...pred},\n      updated: new Set(),\n      negativeCycleEdges: negativeCycleEdges,\n      negativeCycleNodes: negativeCycleNodes,\n      log: 'Negative cycle detected! Edges involved highlighted in red.'\n    });\n  } else {\n    history.push({\n      iteration: Number.MAX_SAFE_INTEGER,\n      edgeIndex: -1,\n      currentEdge: null,\n      relaxedEdge: null,\n      distances: {...dist},\n      predecessors: {...pred},\n      updated: new Set(),\n      negativeCycleEdges: new Set(),\n      negativeCycleNodes: new Set(),\n      log: 'No negative cycle detected.'\n    });\n  }\n\n  // Final snapshot\n  stepIndex = 0;\n  applySnapshot(0);\n  elements.log.innerHTML = '';\n  // show first log\n  setTimeout(()=> appendLog(history[0].log), 10);\n  draw();\n}\n\nfunction appendLog(msg){\n  if(!msg) return;\n  const div = document.createElement('div');\n  div.textContent = msg;\n  elements.log.prepend(div);\n}\n\n// Apply snapshot at given index to UI and draw\nfunction applySnapshot(index){\n  if(index < 0 || index >= history.length) return;\n  stepIndex = index;\n  const snap = history[index];\n  elements.lblIteration.textContent = snap.iteration === Number.MAX_SAFE_INTEGER ? 'final' : snap.iteration;\n  elements.lblEdge.textContent = snap.currentEdge ? (labelForNode(snap.currentEdge.u) + '→' + labelForNode(snap.currentEdge.v)) : '—';\n  // update table\n  renderDistanceTable(snap.distances, snap.predecessors);\n  // update log if available\n  if(snap.log){\n    appendLog(snap.log);\n    if(snap.log.includes('Negative cycle')) elements.negStatus.textContent = 'YES', elements.negStatus.className='danger';\n    else if(snap.log.includes('No negative')) elements.negStatus.textContent='NO', elements.negStatus.className='ok';\n    else elements.negStatus.textContent='running', elements.negStatus.className='';\n  }\n  // prepare highlight info & draw\n  draw(snap);\n\n  // If target is selected, highlight path from source to target (overlay)\n  if(selectedTarget !== null){\n    highlightPath(snap.predecessors, snap.distances, selectedTarget);\n  }\n}\n\n// Render distance table\nfunction renderDistanceTable(distances, predecessors){\n  const items = [];\n  for(let n of nodes){\n    const id = n.id;\n    const d = distances && distances[id];\n    const p = predecessors && predecessors[id];\n    items.push({id,d,p});\n  }\n  // sort by id for consistent display\n  items.sort((a,b)=>a.id-b.id);\n  elements.distanceTable.innerHTML = '';\n  for(let it of items){\n    const div = document.createElement('div');\n    div.className = 'item';\n    const lbl = document.createElement('div');\n    lbl.style.flex = '1';\n    lbl.innerHTML = '<div class=\"node-label\">' + labelForNode(it.id) + '</div><div class=\"small-muted\">pred: ' + (it.p!==null ? labelForNode(it.p) : '—') + '</div>';\n    const val = document.createElement('div');\n    val.className = 'badge';\n    val.textContent = Number.isFinite(it.d) ? it.d : '∞';\n    div.appendChild(lbl);\n    div.appendChild(val);\n    elements.distanceTable.appendChild(div);\n  }\n}\n\n// Highlight path overlay from source to target using current predecessors\nfunction highlightPath(predecessors, distances, targetId){\n  // draw path arrow overlay on top\n  // reconstruct path\n  const path = [];\n  let cur = targetId;\n  const seen = new Set();\n  while(cur !== null && !seen.has(cur)){\n    seen.add(cur);\n    path.push(cur);\n    cur = predecessors[cur] !== undefined ? predecessors[cur] : null;\n  }\n  path.reverse();\n  // If first node must be source, otherwise path invalid\n  if(path.length === 0 || path[0] !== selectedSource){\n    // no valid path\n    return;\n  }\n  // draw arrows for path\n  ctx.save();\n  ctx.globalCompositeOperation = 'lighter';\n  for(let i=0;i<path.length-1;i++){\n    const a = nodes.find(n=>n.id===path[i]);\n    const b = nodes.find(n=>n.id===path[i+1]);\n    if(!a || !b) continue;\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const ang = Math.atan2(dy, dx);\n    const offset = 22;\n    const fromX = a.x + Math.cos(ang) * offset;\n    const fromY = a.y + Math.sin(ang) * offset;\n    const toX = b.x - Math.cos(ang) * offset;\n    const toY = b.y - Math.sin(ang) * offset;\n    ctx.beginPath();\n    ctx.strokeStyle = 'rgba(99,102,241,0.95)';\n    ctx.lineWidth = 4;\n    ctx.moveTo(fromX, fromY);\n    ctx.lineTo(toX, toY);\n    ctx.stroke();\n    // arrow head\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(99,102,241,0.95)';\n    const arrowSize = 10;\n    ctx.moveTo(toX, toY);\n    ctx.lineTo(toX - arrowSize * Math.cos(ang - Math.PI/8), toY - arrowSize * Math.sin(ang - Math.PI/8));\n    ctx.lineTo(toX - arrowSize * Math.cos(ang + Math.PI/8), toY - arrowSize * Math.sin(ang + Math.PI/8));\n    ctx.closePath();\n    ctx.fill();\n  }\n  ctx.restore();\n}\n\n// Initialize with sample graph\nfunction seedSampleGraph(){\n  nodes = [];\n  edges = [];\n  nodeIdCounter = 0; edgeIdCounter = 0;\n  // positions\n  addNode(120,80); // A id 0\n  addNode(300,60); // B id 1\n  addNode(520,80); // C id 2\n  addNode(200,220); // D id 3\n  addNode(420,220); // E id 4\n\n  addEdge(0,1,6);\n  addEdge(0,3,7);\n  addEdge(1,2,5);\n  addEdge(1,3,8);\n  addEdge(1,4,-4);\n  addEdge(2,1,-2);\n  addEdge(3,2,-3);\n  addEdge(3,4,9);\n  addEdge(4,0,2);\n  draw();\n}\nseedSampleGraph();\n\n// Responsive canvas sizing\nfunction fitCanvas(){\n  const wrap = document.querySelector('.canvas-wrap');\n  const rect = wrap.getBoundingClientRect();\n  canvas.style.width = rect.width + 'px';\n  canvas.style.height = rect.height + 'px';\n  resizeCanvas();\n}\nwindow.addEventListener('resize', fitCanvas);\nsetTimeout(fitCanvas, 10);\n\n// Provide simple keyboard shortcuts\nwindow.addEventListener('keydown', (ev)=>{\n  if(ev.key === '1') setMode('addNode');\n  if(ev.key === '2') setMode('addEdge');\n  if(ev.key === '3') setMode('selectSource');\n  if(ev.key === '4') setMode('selectTarget');\n  if(ev.key === ' ') { ev.preventDefault(); elements.btnPlay.click(); }\n  if(ev.key === 'ArrowRight') elements.btnStep.click();\n  if(ev.key === 'ArrowLeft') elements.btnStepBack.click();\n});\n\n// Draw once initially\ndraw();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}