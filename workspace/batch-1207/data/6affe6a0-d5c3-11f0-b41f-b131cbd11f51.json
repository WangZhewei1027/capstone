{
  "id": "6affe6a0-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:31:13.056Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Search Tree Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f0f2f5;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            min-height: 100vh;\n        }\n        \n        .container {\n            max-width: 900px;\n            width: 100%;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 20px;\n        }\n        \n        h1 {\n            color: #1a73e8;\n        }\n        \n        .description {\n            color: #5f6368;\n            margin-bottom: 30px;\n            line-height: 1.5;\n        }\n        \n        .controls {\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n            margin-bottom: 20px;\n        }\n        \n        .input-group {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 15px;\n            flex-wrap: wrap;\n        }\n        \n        input {\n            padding: 10px;\n            border: 1px solid #dadce0;\n            border-radius: 4px;\n            flex-grow: 1;\n            min-width: 150px;\n        }\n        \n        button {\n            background-color: #1a73e8;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.2s;\n        }\n        \n        button:hover {\n            background-color: #0d62d9;\n        }\n        \n        button:active {\n            transform: translateY(1px);\n        }\n        \n        .traversal-buttons {\n            display: grid;\n            grid-template-columns: repeat(2, 1fr);\n            gap: 10px;\n            margin-top: 15px;\n        }\n        \n        .canvas-container {\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n            overflow: auto;\n            max-width: 100%;\n        }\n        \n        #treeCanvas {\n            width: 100%;\n            height: 400px;\n            border: 1px solid #e8eaed;\n        }\n        \n        .operations {\n            margin-top: 20px;\n            display: flex;\n            gap: 10px;\n            justify-content: center;\n            flex-wrap: wrap;\n        }\n        \n        .status {\n            margin-top: 15px;\n            padding: 10px;\n            border-radius: 4px;\n            text-align: center;\n            font-weight: bold;\n            min-height: 20px;\n        }\n        \n        .success {\n            background-color: #e6f4ea;\n            color: #137333;\n        }\n        \n        .error {\n            background-color: #fce8e6;\n            color: #c5221f;\n        }\n        \n        .info {\n            background-color: #e8f0fe;\n            color: #1a73e8;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Binary Search Tree Visualization</h1>\n            <div class=\"description\">\n                A Binary Search Tree (BST) is a tree data structure in which each node has at most two children, \n                referred to as the left child and the right child. For each node, all elements in the left subtree \n                are less than the node, and all elements in the right subtree are greater than the node.\n            </div>\n        </header>\n        \n        <div class=\"controls\">\n            <div class=\"input-group\">\n                <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter a number to add\">\n                <button id=\"addBtn\">Add Node</button>\n                <button id=\"searchBtn\">Search Value</button>\n                <button id=\"resetBtn\">Reset Tree</button>\n            </div>\n            \n            <div class=\"traversal-buttons\">\n                <button id=\"inorderBtn\">In-Order Traversal</button>\n                <button id=\"preorderBtn\">Pre-Order Traversal</button>\n                <button id=\"postorderBtn\">Post-Order Traversal</button>\n                <button id=\"levelorderBtn\">Level-Order Traversal</button>\n            </div>\n        </div>\n        \n        <div class=\"canvas-container\">\n            <canvas id=\"treeCanvas\"></canvas>\n        </div>\n        \n        <div class=\"operations\">\n            <button id=\"minBtn\">Find Minimum</button>\n            <button id=\"maxBtn\">Find Maximum</button>\n            <button id=\"depthBtn\">Calculate Depth</button>\n        </div>\n        \n        <div id=\"status\" class=\"status\"></div>\n    </div>\n\n    <script>\n        // Binary Search Tree implementation\n        class TreeNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n                this.x = 0; // For visualization\n                this.y = 0; // For visualization\n            }\n        }\n\n        class BinarySearchTree {\n            constructor() {\n                this.root = null;\n            }\n            \n            // Insert a new value into the BST\n            insert(value) {\n                const newNode = new TreeNode(value);\n                \n                if (this.root === null) {\n                    this.root = newNode;\n                } else {\n                    this.insertNode(this.root, newNode);\n                }\n                \n                return true;\n            }\n            \n            insertNode(node, newNode) {\n                if (newNode.value < node.value) {\n                    if (node.left === null) {\n                        node.left = newNode;\n                    } else {\n                        this.insertNode(node.left, newNode);\n                    }\n                } else {\n                    if (node.right === null) {\n                        node.right = newNode;\n                    } else {\n                        this.insertNode(node.right, newNode);\n                    }\n                }\n            }\n            \n            // Search for a value in the BST\n            search(value) {\n                return this.searchNode(this.root, value);\n            }\n            \n            searchNode(node, value) {\n                if (node === null) {\n                    return false;\n                }\n                \n                if (value < node.value) {\n                    return this.searchNode(node.left, value);\n                } else if (value > node.value) {\n                    return this.searchNode(node.right, value);\n                } else {\n                    return true;\n                }\n            }\n            \n            // Get the minimum value in the BST\n            findMin() {\n                return this.findMinNode(this.root);\n            }\n            \n            findMinNode(node) {\n                if (node.left === null) {\n                    return node.value;\n                } else {\n                    return this.findMinNode(node.left);\n                }\n            }\n            \n            // Get the maximum value in the BST\n            findMax() {\n                return this.findMaxNode(this.root);\n            }\n            \n            findMaxNode(node) {\n                if (node.right === null) {\n                    return node.value;\n                } else {\n                    return this.findMaxNode(node.right);\n                }\n            }\n            \n            // Get the depth of the tree\n            getDepth() {\n                return this.calculateDepth(this.root);\n            }\n            \n            calculateDepth(node) {\n                if (node === null) {\n                    return 0;\n                } else {\n                    const leftDepth = this.calculateDepth(node.left);\n                    const rightDepth = this.calculateDepth(node.right);\n                    \n                    return Math.max(leftDepth, rightDepth) + 1;\n                }\n            }\n            \n            // Tree traversals\n            inOrderTraversal(callback) {\n                const result = [];\n                this.inOrder(this.root, result);\n                return result;\n            }\n            \n            inOrder(node, result) {\n                if (node !== null) {\n                    this.inOrder(node.left, result);\n                    result.push(node.value);\n                    this.inOrder(node.right, result);\n                }\n            }\n            \n            preOrderTraversal(callback) {\n                const result = [];\n                this.preOrder(this.root, result);\n                return result;\n            }\n            \n            preOrder(node, result) {\n                if (node !== null) {\n                    result.push(node.value);\n                    this.preOrder(node.left, result);\n                    this.preOrder(node.right, result);\n                }\n            }\n            \n            postOrderTraversal(callback) {\n                const result = [];\n                this.postOrder(this.root, result);\n                return result;\n            }\n            \n            postOrder(node, result) {\n                if (node !== null) {\n                    this.postOrder(node.left, result);\n                    this.postOrder(node.right, result);\n                    result.push(node.value);\n                }\n            }\n            \n            levelOrderTraversal() {\n                const result = [];\n                if (this.root === null) {\n                    return result;\n                }\n                \n                const queue = [this.root];\n                \n                while (queue.length > 0) {\n                    const node = queue.shift();\n                    result.push(node.value);\n                    \n                    if (node.left !== null) {\n                        queue.push(node.left);\n                    }\n                    \n                    if (node.right !== null) {\n                        queue.push(node.right);\n                    }\n                }\n                \n                return result;\n            }\n            \n            // Prepare tree for visualization\n            prepareForVisualization() {\n                if (this.root === null) {\n                    return;\n                }\n                \n                // Calculate positions for each node\n                const calculatePositions = (node, level, position, minDistance) => {\n                    if (node === null) {\n                        return;\n                    }\n                    \n                    // Calculate position for left child\n                    calculatePositions(node.left, level + 1, position - minDistance/Math.pow(2, level), minDistance);\n                    \n                    // Set position for current node\n                    node.x = position;\n                    node.y = level * 80;\n                    \n                    // Calculate position for right child\n                    calculatePositions(node.right, level + 1, position + minDistance/Math.pow(2, level), minDistance);\n                };\n                \n                // Start calculation from root\n                calculatePositions(this.root, 0, 450, 450);\n            }\n            \n            // Draw the tree on canvas\n            draw(canvas, ctx) {\n                // Clear canvas\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                \n                if (this.root === null) {\n                    return;\n                }\n                \n                // Prepare tree for visualization\n                this.prepareForVisualization();\n                \n                // Draw connections first (so nodes appear on top)\n                this.drawConnections(this.root, ctx);\n                \n                // Then draw nodes\n                this.drawNodes(this.root, ctx);\n            }\n            \n            drawConnections(node, ctx) {\n                if (node === null) {\n                    return;\n                }\n                \n                ctx.strokeStyle = \"#5f6368\";\n                ctx.lineWidth = 2;\n                \n                if (node.left !== null) {\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(node.left.x, node.left.y);\n                    ctx.stroke();\n                    this.drawConnections(node.left, ctx);\n                }\n                \n                if (node.right !== null) {\n                    ctx.beginPath();\n                    ctx.moveTo(node.x, node.y);\n                    ctx.lineTo(node.right.x, node.right.y);\n                    ctx.stroke();\n                    this.drawConnections(node.right, ctx);\n                }\n            }\n            \n            drawNodes(node, ctx) {\n                if (node === null) {\n                    return;\n                }\n                \n                // Draw the node\n                ctx.fillStyle = \"#1a73e8\";\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);\n                ctx.fill();\n                \n                // Draw the value\n                ctx.fillStyle = \"white\";\n                ctx.font = \"14px Arial\";\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(node.value, node.x, node.y);\n                \n                // Draw children\n                this.drawNodes(node.left, ctx);\n                this.drawNodes(node.right, ctx);\n            }\n        }\n\n        // DOM elements\n        const canvas = document.getElementById('treeCanvas');\n        const ctx = canvas.getContext('2d');\n        const nodeValueInput = document.getElementById('nodeValue');\n        const addBtn = document.getElementById('addBtn');\n        const searchBtn = document.getElementById('searchBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const inorderBtn = document.getElementById('inorderBtn');\n        const preorderBtn = document.getElementById('preorderBtn');\n        const postorderBtn = document.getElementById('postorderBtn');\n        const levelorderBtn = document.getElementById('levelorderBtn');\n        const minBtn = document.getElementById('minBtn');\n        const maxBtn = document.getElementById('maxBtn');\n        const depthBtn = document.getElementById('depthBtn');\n        const statusDiv = document.getElementById('status');\n\n        // Initialize BST\n        const bst = new BinarySearchTree();\n\n        // Adjust canvas size\n        function resizeCanvas() {\n            canvas.width = canvas.offsetWidth;\n            canvas.height = canvas.offsetHeight;\n            bst.draw(canvas, ctx);\n        }\n\n        // Event listeners\n        addBtn.addEventListener('click', () => {\n            const value = parseInt(nodeValueInput.value);\n            if (isNaN(value)) {\n                showStatus(\"Please enter a valid number\", \"error\");\n                return;\n            }\n            \n            if (bst.search(value)) {\n                showStatus(`Value ${value} already exists in the tree`, \"error\");\n            } else {\n                bst.insert(value);\n                bst.draw(canvas, ctx);\n                showStatus(`Value ${value} added to the tree`, \"success\");\n            }\n            \n            nodeValueInput.value = \"\";\n            nodeValueInput.focus();\n        });\n\n        searchBtn.addEventListener('click', () => {\n            const value = parseInt(nodeValueInput.value);\n            if (isNaN(value)) {\n                showStatus(\"Please enter a valid number\", \"error\");\n                return;\n            }\n            \n            if (bst.search(value)) {\n                showStatus(`Value ${value} found in the tree`, \"success\");\n            } else {\n                showStatus(`Value ${value} not found in the tree`, \"error\");\n            }\n        });\n\n        resetBtn.addEventListener('click', () => {\n            bst.root = null;\n            bst.draw(canvas, ctx);\n            showStatus(\"Tree has been reset\", \"info\");\n        });\n\n        inorderBtn.addEventListener('click', () => {\n            const result = bst.inOrderTraversal();\n            showStatus(`In-Order Traversal: [${result.join(\", \")}]`, \"info\");\n        });\n\n        preorderBtn.addEventListener('click', () => {\n            const result = bst.preOrderTraversal();\n            showStatus(`Pre-Order Traversal: [${result.join(\", \")}]`, \"info\");\n        });\n\n        postorderBtn.addEventListener('click', () => {\n            const result = bst.postOrderTraversal();\n            showStatus(`Post-Order Traversal: [${result.join(\", \")}]`, \"info\");\n        });\n\n        levelorderBtn.addEventListener('click', () => {\n            const result = bst.levelOrderTraversal();\n            showStatus(`Level-Order Traversal: [${result.join(\", \")}]`, \"info\");\n        });\n\n        minBtn.addEventListener('click', () => {\n            if (bst.root === null) {\n                showStatus(\"Tree is empty\", \"error\");\n            } else {\n                const min = bst.findMin();\n                showStatus(`Minimum value: ${min}`, \"info\");\n            }\n        });\n\n        maxBtn.addEventListener('click', () => {\n            if (bst.root === null) {\n                showStatus(\"Tree is empty\", \"error\");\n            } else {\n                const max = bst.findMax();\n                showStatus(`Maximum value: ${max}`, \"info\");\n            }\n        });\n\n        depthBtn.addEventListener('click', () => {\n            const depth = bst.getDepth();\n            showStatus(`Tree depth: ${depth}`, \"info\");\n        });\n\n        // Show status message\n        function showStatus(message, type) {\n            statusDiv.textContent = message;\n            statusDiv.className = \"status\";\n            statusDiv.classList.add(type);\n            \n            // Clear status after 3 seconds\n            setTimeout(() => {\n                statusDiv.textContent = \"\";\n                statusDiv.className = \"status\";\n            }, 3000);\n        }\n\n        // Handle window resize\n        window.addEventListener('resize', resizeCanvas);\n\n        // Initialize canvas size\n        resizeCanvas();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}