{
  "id": "d7b32920-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:57.604Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Adjacency Matrix Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    gap: 40px;\n    justify-content: center;\n    flex-wrap: wrap;\n  }\n  #graphCanvas {\n    border: 1px solid #ccc;\n    background-color: #f9f9f9;\n  }\n  table {\n    border-collapse: collapse;\n    margin-top: 10px;\n  }\n  th, td {\n    border: 1px solid #666;\n    padding: 5px 8px;\n    text-align: center;\n    width: 30px;\n    height: 30px;\n    user-select: none;\n    cursor: pointer;\n  }\n  th {\n    background-color: #e0e0e0;\n  }\n  td.active {\n    background-color: #4CAF50;\n    color: white;\n  }\n  td:hover {\n    background-color: #9fcd8a;\n  }\n  #info {\n    margin-top: 20px;\n    text-align: center;\n  }\n  #controls {\n    margin-bottom: 20px;\n    text-align: center;\n  }\n  input[type=number] {\n    width: 50px;\n  }\n  button {\n    margin-left: 10px;\n    padding: 5px 12px;\n    cursor: pointer;\n  }\n  #directedLabel {\n    cursor: pointer;\n    user-select: none;\n    margin-left: 10px;\n  }\n</style>\n</head>\n<body>\n<h1>Adjacency Matrix Visualization</h1>\n<div id=\"controls\">\n  Number of nodes: <input type=\"number\" id=\"numNodes\" min=\"2\" max=\"15\" value=\"5\" />\n  <label id=\"directedLabel\"><input type=\"checkbox\" id=\"directedCheck\" /> Directed graph</label>\n  <button id=\"generateBtn\">Generate Matrix</button>\n</div>\n<div id=\"container\">\n  <div>\n    <h3>Adjacency Matrix (click cells to toggle edges)</h3>\n    <div id=\"matrixContainer\"></div>\n  </div>\n  <div>\n    <h3>Graph Visualization</h3>\n    <canvas id=\"graphCanvas\" width=\"500\" height=\"500\"></canvas>\n  </div>\n</div>\n<div id=\"info\">\n  <p>Click on the matrix cells to add or remove edges between nodes.</p>\n  <p>Green cells indicate edges from row-node to column-node.</p>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const matrixContainer = document.getElementById('matrixContainer');\n  const numNodesInput = document.getElementById('numNodes');\n  const generateBtn = document.getElementById('generateBtn');\n  const directedCheck = document.getElementById('directedCheck');\n\n  let numNodes = Number(numNodesInput.value);\n  let directed = directedCheck.checked;\n  let adjacencyMatrix = [];\n\n  // Coordinates for nodes on canvas\n  let nodesCoords = [];\n\n  // Initialize adjacency matrix with zeros\n  function initMatrix(n) {\n    adjacencyMatrix = [];\n    for (let i = 0; i < n; i++) {\n      const row = Array(n).fill(0);\n      adjacencyMatrix.push(row);\n    }\n  }\n\n  // Generate adjacency matrix HTML table\n  function generateMatrixTable() {\n    const table = document.createElement('table');\n    const thead = document.createElement('thead');\n    const headerRow = document.createElement('tr');\n    const emptyTH = document.createElement('th');\n    headerRow.appendChild(emptyTH);\n    // Column headers (Nodes)\n    for (let c = 0; c < numNodes; c++) {\n      const th = document.createElement('th');\n      th.textContent = `N${c}`;\n      headerRow.appendChild(th);\n    }\n    thead.appendChild(headerRow);\n    table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for (let r = 0; r < numNodes; r++) {\n      const tr = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = `N${r}`;\n      tr.appendChild(rowHeader);\n      for (let c = 0; c < numNodes; c++) {\n        const td = document.createElement('td');\n        td.dataset.row = r;\n        td.dataset.col = c;\n        if (adjacencyMatrix[r][c] === 1) td.classList.add('active');\n        td.title = `Edge from N${r} â†’ N${c}`;\n        td.addEventListener('click', () => {\n          toggleEdge(r, c);\n        });\n        // For undirected: disable cell when c < r to avoid duplicates\n        if (!directed && c < r) {\n          td.style.backgroundColor = '#f0f0f0';\n          td.style.cursor = 'default';\n          td.title = 'Undirected edges mirrored';\n          td.removeEventListener('click', () => {});\n        }\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n\n    matrixContainer.innerHTML = '';\n    matrixContainer.appendChild(table);\n  }\n\n  // Toggle edge presence in adjacency matrix and update UI\n  function toggleEdge(row, col) {\n    if (!directed && col < row) {\n      // For undirected graph, edge toggle handled in mirrored cell\n      row = col;\n      col = row;\n    }\n    adjacencyMatrix[row][col] = adjacencyMatrix[row][col] === 1 ? 0 : 1;\n\n    if (!directed && row !== col) {\n      // Mirror the undirected edge\n      adjacencyMatrix[col][row] = adjacencyMatrix[row][col];\n    }\n\n    generateMatrixTable();\n    drawGraph();\n  }\n\n  // Calculate coordinates for nodes arranged in a circle\n  function calculateNodePositions(radius = 200, centerX = 250, centerY = 250) {\n    nodesCoords = [];\n    for (let i = 0; i < numNodes; i++) {\n      const angle = (2 * Math.PI * i) / numNodes - Math.PI / 2; // start from top (12 o'clock)\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      nodesCoords.push({ x, y });\n    }\n  }\n\n  // Draw arrowhead for directed edges\n  function drawArrowhead(ctx, fromX, fromY, toX, toY, radius = 7) {\n    const dx = toX - fromX;\n    const dy = toY - fromY;\n    const angle = Math.atan2(dy, dx);\n    ctx.save();\n    ctx.translate(toX, toY);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(-radius, radius / 2);\n    ctx.lineTo(-radius, -radius / 2);\n    ctx.closePath();\n    ctx.fillStyle = 'black';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw the graph on the canvas\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    calculateNodePositions();\n\n    // Draw edges\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#444';\n    ctx.fillStyle = '#444';\n\n    for (let r = 0; r < numNodes; r++) {\n      for (let c = 0; c < numNodes; c++) {\n        if (adjacencyMatrix[r][c] === 1) {\n          if (!directed && c < r) {\n            // Skip drawing mirrored edges for undirected graph\n            continue;\n          }\n          const from = nodesCoords[r];\n          const to = nodesCoords[c];\n\n          // For self loop, draw a loop\n          if (r === c) {\n            const node = from;\n            const loopRadius = 20;\n            ctx.beginPath();\n            ctx.arc(node.x, node.y - loopRadius, loopRadius, 0, Math.PI * 2);\n            ctx.stroke();\n            if (directed) {\n              // Draw arrowhead on loop (top center)\n              const arrowX = node.x;\n              const arrowY = node.y - 2 * loopRadius;\n              drawArrowhead(ctx, node.x, node.y - loopRadius - 5, arrowX, arrowY);\n            }\n          } else {\n            // Draw line or curved edge\n            const distX = to.x - from.x;\n            const distY = to.y - from.y;\n            const distance = Math.hypot(distX, distY);\n            const offsetX = (distX / distance) * 15;\n            const offsetY = (distY / distance) * 15;\n\n            ctx.beginPath();\n            \n            // For undirected or directed edges, if reverse edge also exists, curve lines\n            const reverseExists = adjacencyMatrix[c][r] === 1;\n            if (directed && reverseExists && r < c) {\n              // Draw curved edges to distinguish forward and reverse edges\n              const cpX = (from.x + to.x) / 2 + (distY / distance) * 40;\n              const cpY = (from.y + to.y) / 2 - (distX / distance) * 40;\n              ctx.moveTo(from.x + offsetX, from.y + offsetY);\n              ctx.quadraticCurveTo(cpX, cpY, to.x - offsetX, to.y - offsetY);\n              ctx.stroke();\n\n              // Arrowhead for this edge\n              // Approximate position for arrowhead on curve: near to.x, to.y shifted back a bit\n              const t = 0.9; // Parameter close to end of curve\n              // Quadratic Bezier formula for point at t:\n              const qx = (1 - t) * (1 - t) * (from.x + offsetX) + 2 * (1 - t) * t * cpX + t * t * (to.x - offsetX);\n              const qy = (1 - t) * (1 - t) * (from.y + offsetY) + 2 * (1 - t) * t * cpY + t * t * (to.y - offsetY);\n\n              // Derivative for angle:\n              const dx = 2 * (1 - t) * (cpX - (from.x + offsetX)) + 2 * t * ((to.x - offsetX) - cpX);\n              const dy = 2 * (1 - t) * (cpY - (from.y + offsetY)) + 2 * t * ((to.y - offsetY) - cpY);\n\n              ctx.save();\n              ctx.translate(qx, qy);\n              ctx.rotate(Math.atan2(dy, dx));\n              ctx.beginPath();\n              ctx.moveTo(0, 0);\n              ctx.lineTo(-7, 4);\n              ctx.lineTo(-7, -4);\n              ctx.closePath();\n              ctx.fill();\n              ctx.restore();\n\n            } else if (directed) {\n              // Straight line with arrowhead\n              ctx.moveTo(from.x + offsetX, from.y + offsetY);\n              ctx.lineTo(to.x - offsetX, to.y - offsetY);\n              ctx.stroke();\n\n              drawArrowhead(ctx, from.x + offsetX, from.y + offsetY, to.x - offsetX, to.y - offsetY);\n\n            } else {\n              // Undirected: straight line without arrow\n              ctx.moveTo(from.x + offsetX, from.y + offsetY);\n              ctx.lineTo(to.x - offsetX, to.y - offsetY);\n              ctx.stroke();\n            }\n          }\n        }\n      }\n    }\n\n    // Draw nodes on top\n    const nodeRadius = 18;\n    ctx.fillStyle = '#2196f3';\n    ctx.strokeStyle = '#0b5394';\n    ctx.lineWidth = 3;\n    ctx.font = 'bold 14px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    for (let i = 0; i < numNodes; i++) {\n      const { x, y } = nodesCoords[i];\n      ctx.beginPath();\n      ctx.fillStyle = '#2196f3';\n      ctx.strokeStyle = '#0b5394';\n      ctx.lineWidth = 3;\n      ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = 'white';\n      ctx.fillText(`N${i}`, x, y);\n    }\n  }\n\n  // Generate graph & UI based on current settings\n  function generate() {\n    numNodes = Math.min(Math.max(2, Math.round(Number(numNodesInput.value))), 15);\n    directed = directedCheck.checked;\n    numNodesInput.value = numNodes; // sanitize input\n    initMatrix(numNodes);\n    generateMatrixTable();\n    drawGraph();\n  }\n\n  generateBtn.addEventListener('click', generate);\n\n  // Initialize on load\n  generate();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}