{
  "id": "98e2a502-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:01.151Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Recursion Playground — Interactive Demos</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; padding: 0; color: #111; background: #f6f8fb; }\n    header { background: #0b6efd; color: white; padding: 18px 20px; box-shadow: 0 2px 6px rgba(11,110,253,0.15); }\n    header h1 { margin: 0; font-size: 20px; }\n    header p { margin: 6px 0 0; font-size: 13px; opacity: 0.95; }\n    main { display: grid; grid-template-columns: 1fr 420px; gap: 18px; padding: 18px; max-width: 1200px; margin: 18px auto; }\n    section.card { background: white; border-radius: 10px; padding: 14px; box-shadow: 0 2px 8px rgba(22,27,50,0.06); }\n    .card h2 { margin: 2px 0 10px; font-size: 16px; }\n    .small { font-size: 13px; color: #475569; margin-bottom: 8px; }\n    label { display:block; font-size:13px; margin-top:8px; }\n    input[type=\"number\"], select { width:100%; padding:8px 10px; margin-top:6px; border-radius:6px; border:1px solid #d6dbe9; box-sizing:border-box; }\n    button { background:#0b6efd; color:white; padding:8px 12px; border:none; border-radius:8px; cursor:pointer; margin-top:10px; }\n    button.secondary { background:#e6eefc; color:#0b6efd; }\n    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .output { background:#0f1724; color:#e6eefc; padding:10px; border-radius:8px; font-family: monospace; white-space: pre-wrap; max-height:300px; overflow:auto; }\n    .canvas-wrap { background:#fff; border-radius:10px; padding:10px; display:flex; gap:10px; align-items:flex-start; }\n    canvas { background:#fff; border-radius:6px; box-shadow: inset 0 0 0 1px #eef2ff; }\n    .legend { font-size:12px; color:#475569; }\n    .stat { font-size:13px; padding:6px 8px; background:#f1f5f9; border-radius:8px; display:inline-block; margin-right:8px; }\n    .callstack { max-height:320px; overflow:auto; background:#fff; border-radius:8px; padding:10px; border:1px solid #e6eefc; }\n    .frame { padding:8px; margin-bottom:8px; border-radius:8px; background:linear-gradient(180deg,#fbfdff,#f5f9ff); box-shadow: 0 1px 0 rgba(11,110,253,0.05); font-family: monospace; }\n    .frame.active { outline: 2px solid #c7e0ff; background: linear-gradient(180deg,#eaf6ff,#e6f2ff); }\n    footer { text-align:center; color:#94a3b8; font-size:12px; margin:18px 0 40px; }\n    a.inline { color:#0b6efd; text-decoration:none; }\n    @media (max-width:980px) {\n      main { grid-template-columns: 1fr; padding:12px; }\n      .canvas-wrap { flex-direction:column; align-items:center; }\n      canvas { max-width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Recursion Playground</h1>\n    <p>Interactive demonstrations that show how recursion works: call stacks, recursion trees, performance, and a visual fractal.</p>\n  </header>\n\n  <main>\n    <div>\n      <!-- Factorial / Call Stack Demo -->\n      <section class=\"card\" id=\"factorialCard\">\n        <h2>Factorial — Recursion & Call Stack</h2>\n        <div class=\"small\">Compute n! using recursion. See the call stack and the recursion tree of calls.</div>\n\n        <label>n (integer ≥ 0)</label>\n        <input type=\"number\" id=\"factN\" value=\"6\" min=\"0\" step=\"1\">\n\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <button id=\"runFact\">Run Recursive Factorial</button>\n          <button id=\"runFactIter\" class=\"secondary\">Show Iterative</button>\n          <label style=\"margin:0 0 0 8px;\"><input type=\"checkbox\" id=\"animateStack\" checked> animate stack</label>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:12px; align-items:flex-start;\">\n          <div style=\"flex:1;\">\n            <div class=\"small\">Call stack (top = current active call)</div>\n            <div id=\"factStack\" class=\"callstack\" aria-live=\"polite\"></div>\n          </div>\n          <div style=\"width:260px;\">\n            <div class=\"small\">Result & logs</div>\n            <div id=\"factOutput\" class=\"output\">Press \"Run Recursive Factorial\".</div>\n          </div>\n        </div>\n      </section>\n\n      <!-- Fibonacci Demo -->\n      <section class=\"card\" id=\"fibCard\" style=\"margin-top:14px;\">\n        <h2>Fibonacci — naive recursion vs memoization</h2>\n        <div class=\"small\">Compare the explosion of calls in naive recursion with a memoized version that reuses results.</div>\n\n        <label>n (recommended ≤ 35 for naive)</label>\n        <input type=\"number\" id=\"fibN\" value=\"28\" min=\"0\" step=\"1\">\n\n        <div class=\"row\">\n          <button id=\"runFib\">Run Naive Recursion</button>\n          <button id=\"runFibMemo\" class=\"secondary\">Run Memoized</button>\n          <button id=\"showFibTree\" class=\"secondary\">Show Recursion Tree (n ≤ 8)</button>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <span class=\"stat\" id=\"fibTime\">—</span>\n          <span class=\"stat\" id=\"fibCalls\">—</span>\n          <span class=\"legend\">Time and call counts</span>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:10px;\">\n          <div style=\"flex:1;\">\n            <div class=\"small\">Logs</div>\n            <div id=\"fibOutput\" class=\"output\">Press a button to run.</div>\n          </div>\n          <div style=\"width:300px;\">\n            <div class=\"small\">Recursion tree (small n)</div>\n            <div id=\"fibTree\" class=\"callstack\" style=\"max-height:240px;\"></div>\n          </div>\n        </div>\n      </section>\n\n      <!-- Binary Search Demo -->\n      <section class=\"card\" id=\"bsCard\" style=\"margin-top:14px;\">\n        <h2>Binary Search — Divide & Conquer (recursive)</h2>\n        <div class=\"small\">A sorted array and a recursive binary search that highlights mid values and subranges.</div>\n\n        <label>Array size</label>\n        <input type=\"number\" id=\"bsSize\" value=\"15\" min=\"3\" step=\"1\">\n\n        <label>Target (value in array)</label>\n        <input type=\"number\" id=\"bsTarget\" value=\"0\" step=\"1\">\n\n        <div class=\"row\">\n          <button id=\"genArray\">Generate Sorted Array</button>\n          <button id=\"runBS\">Run Recursive Binary Search</button>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:10px; align-items:flex-start;\">\n          <div style=\"flex:1;\">\n            <div class=\"small\">Array (click a value to choose it)</div>\n            <div id=\"bsArray\" class=\"callstack\" style=\"display:flex; flex-wrap:wrap; gap:6px; padding:8px;\"></div>\n          </div>\n          <div style=\"width:300px;\">\n            <div class=\"small\">Trace</div>\n            <div id=\"bsTrace\" class=\"callstack\" style=\"max-height:250px;\"></div>\n          </div>\n        </div>\n      </section>\n    </div>\n\n    <aside>\n      <!-- Fractal / Visual Recursion -->\n      <section class=\"card\">\n        <h2>Fractal Tree — Visual Recursion</h2>\n        <div class=\"small\">A simple recursive branch drawing. Increase depth to see more recursive calls.</div>\n\n        <div class=\"canvas-wrap\" style=\"flex-direction:column;\">\n          <canvas id=\"treeCanvas\" width=\"380\" height=\"380\"></canvas>\n          <div style=\"width:100%; display:flex; gap:8px; align-items:center; margin-top:8px;\">\n            <label style=\"flex:1;\">\n              Depth: <input id=\"treeDepth\" type=\"range\" min=\"0\" max=\"12\" value=\"8\" style=\"width:100%;\">\n            </label>\n            <button id=\"drawTree\">Redraw</button>\n          </div>\n          <div style=\"margin-top:8px;\" class=\"legend\">Tip: larger depth shows more recursion depth — browser stack usage increases with depth.</div>\n        </div>\n      </section>\n\n      <!-- Generic Call Stack Visualizer -->\n      <section class=\"card\" style=\"margin-top:14px;\">\n        <h2>Call Stack Visualization</h2>\n        <div class=\"small\">Shows how recursive calls push and pop frames. Use the example function shown below (sumRange).</div>\n\n        <div class=\"small\" style=\"margin-top:6px;\">\n          sumRange(a, b): recursively computes sum of integers from a to b (inclusive). It's a tail-recursive friendly pattern (not optimized in JS).\n        </div>\n        <label>a</label><input type=\"number\" id=\"srA\" value=\"1\">\n        <label>b</label><input type=\"number\" id=\"srB\" value=\"6\">\n        <div class=\"row\">\n          <button id=\"runSumRange\">Run sumRange</button>\n          <button id=\"stepSumRange\" class=\"secondary\">Step-through</button>\n        </div>\n\n        <div style=\"margin-top:10px;\">\n          <div class=\"small\">Call stack</div>\n          <div id=\"srStack\" class=\"callstack\"></div>\n          <div class=\"small\" style=\"margin-top:8px;\">Output</div>\n          <div id=\"srOutput\" class=\"output\">—</div>\n        </div>\n      </section>\n    </aside>\n  </main>\n\n  <footer>\n    Built to teach recursion — factorial, fibonacci, binary search, and a fractal tree. Try changing inputs!\n  </footer>\n\n  <script>\n    // Utility\n    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }\n    function el(id){ return document.getElementById(id); }\n    function clearChildren(node){ node.innerHTML = ''; }\n\n    // ---------- Factorial Demo ----------\n    const factStackEl = el('factStack'), factOutputEl = el('factOutput');\n    el('runFact').addEventListener('click', async ()=>{\n      const n = Math.max(0, Math.floor(Number(el('factN').value) || 0));\n      clearChildren(factStackEl);\n      factOutputEl.textContent = 'Running recursive factorial...';\n      const animate = el('animateStack').checked;\n\n      let steps = [];\n      // We'll implement recursion that records push/pop events\n      function factorialRec(k){\n        steps.push({type:'push', n:k});\n        if (k <= 1){\n          steps.push({type:'result', n:k, res:1});\n          steps.push({type:'pop', n:k, res:1});\n          return 1;\n        }\n        const r = factorialRec(k-1) * k;\n        steps.push({type:'result', n:k, res:r});\n        steps.push({type:'pop', n:k, res:r});\n        return r;\n      }\n\n      const result = factorialRec(n);\n\n      // Animate or display instantly\n      if (animate){\n        const frames = [];\n        const stack = [];\n        factStackEl.innerHTML = '';\n        for (const ev of steps){\n          if (ev.type === 'push'){\n            stack.unshift(ev);\n            renderStack(stack, factStackEl);\n            await sleep(220);\n          } else if (ev.type === 'result'){\n            // annotate top frame with result\n            if (stack.length && stack[0].n === ev.n) stack[0].res = ev.res;\n            renderStack(stack, factStackEl);\n            await sleep(180);\n          } else if (ev.type === 'pop'){\n            renderStack(stack, factStackEl, ev);\n            await sleep(220);\n            if (stack.length && stack[0].n === ev.n) stack.shift();\n            renderStack(stack, factStackEl);\n            await sleep(120);\n          }\n        }\n        factOutputEl.textContent = `Result: ${n}! = ${result}`;\n      } else {\n        // instant\n        renderStackSummary(steps, factStackEl);\n        factOutputEl.textContent = `Result: ${n}! = ${result}`;\n      }\n    });\n\n    el('runFactIter').addEventListener('click', ()=>{\n      const n = Math.max(0, Math.floor(Number(el('factN').value) || 0));\n      let acc = 1;\n      let log = [];\n      for (let i=1;i<=n;i++){ acc*=i; log.push(`${i}! = ${acc}`); }\n      el('factOutput').textContent = `Iterative result: ${n}! = ${acc}\\nTrace:\\n` + log.join('\\n');\n      clearChildren(factStackEl);\n      // show final frame\n      const d = document.createElement('div'); d.className='frame active'; d.textContent = `iterative frame\\nn=${n}\\nresult=${acc}`; factStackEl.appendChild(d);\n    });\n\n    function renderStack(stack, container, highlightEv){\n      container.innerHTML = '';\n      stack.forEach((frame, idx)=>{\n        const f = document.createElement('div');\n        f.className = 'frame' + (idx === 0 ? ' active' : '');\n        let txt = `fact(${frame.n})`;\n        if (frame.res !== undefined) txt += ` → ${frame.res}`;\n        f.textContent = txt;\n        container.appendChild(f);\n      });\n      if (highlightEv && highlightEv.type==='pop'){\n        const note = document.createElement('div'); note.style.fontSize='12px'; note.style.color='#475569';\n        note.style.marginTop='6px'; note.textContent = `Popped fact(${highlightEv.n}) = ${highlightEv.res}`;\n        container.appendChild(note);\n      }\n    }\n\n    function renderStackSummary(steps, container){\n      container.innerHTML='';\n      // reconstruct final stack (empty after run) but show each unique pushed frame in call order\n      const pushed = steps.filter(s => s.type==='push').map(s=>s.n);\n      pushed.slice().reverse().forEach(n=>{\n        const f = document.createElement('div'); f.className='frame'; f.textContent = `fact(${n})`;\n        container.appendChild(f);\n      });\n      const lastRes = steps.filter(s=>s.type==='result').slice(-1)[0];\n      if (lastRes) {\n        const r = document.createElement('div'); r.style.marginTop='8px'; r.style.fontSize='13px';\n        r.textContent = `Final: fact(${pushed[0]}) = ${lastRes.res}`;\n        container.appendChild(r);\n      }\n    }\n\n    // ---------- Fibonacci Demo ----------\n    const fibOutputEl = el('fibOutput'), fibTreeEl = el('fibTree'), fibTimeEl = el('fibTime'), fibCallsEl = el('fibCalls');\n    el('runFib').addEventListener('click', ()=>{\n      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));\n      fibOutputEl.textContent = 'Running naive recursive Fibonacci...';\n      fibTreeEl.innerHTML='';\n      // count calls\n      let calls=0;\n      const t0 = performance.now();\n      function fib(k){\n        calls++;\n        if (k<=1) return k;\n        return fib(k-1)+fib(k-2);\n      }\n      const res = fib(n);\n      const t1 = performance.now();\n      fibOutputEl.textContent = `fib(${n}) = ${res}`;\n      fibTimeEl.textContent = `Time: ${(t1-t0).toFixed(2)} ms`;\n      fibCallsEl.textContent = `Calls: ${calls.toLocaleString()}`;\n    });\n\n    el('runFibMemo').addEventListener('click', ()=>{\n      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));\n      fibOutputEl.textContent = 'Running memoized Fibonacci...';\n      fibTreeEl.innerHTML='';\n      const t0 = performance.now();\n      let calls=0;\n      const memo = new Map();\n      function fib(k){\n        calls++;\n        if (k<=1) return k;\n        if (memo.has(k)) return memo.get(k);\n        const val = fib(k-1)+fib(k-2);\n        memo.set(k, val);\n        return val;\n      }\n      const res = fib(n);\n      const t1 = performance.now();\n      fibOutputEl.textContent = `fib(${n}) = ${res}\\nMemo entries: ${memo.size}`;\n      fibTimeEl.textContent = `Time: ${(t1-t0).toFixed(2)} ms`;\n      fibCallsEl.textContent = `Effective calls: ${calls.toLocaleString()}`;\n    });\n\n    el('showFibTree').addEventListener('click', ()=>{\n      const n = Math.max(0, Math.floor(Number(el('fibN').value) || 0));\n      fibTreeEl.innerHTML='';\n      if (n>8){ fibTreeEl.textContent='Too big to draw tree (choose n ≤ 8)'; return; }\n      // Build a simple textual tree\n      function buildLines(k, prefix=''){\n        if (k<=1) return [`${prefix}${k}`];\n        const left = buildLines(k-1, prefix + '  ');\n        const right = buildLines(k-2, prefix + '  ');\n        return [`${prefix}${k}`].concat(left).concat(right);\n      }\n      const lines = buildLines(n);\n      fibTreeEl.textContent = lines.join('\\n');\n      fibOutputEl.textContent = 'Recursion tree printed at right.';\n      fibTimeEl.textContent = '—';\n      fibCallsEl.textContent = `Nodes: ${lines.length}`;\n    });\n\n    // ---------- Binary Search Demo ----------\n    const bsArrayEl = el('bsArray'), bsTraceEl = el('bsTrace');\n    let currentArray = [];\n    function genArray(size){\n      const arr = [];\n      let start = Math.floor(Math.random()*10);\n      for (let i=0;i<size;i++){ arr.push(start + i*2 + Math.floor(Math.random()*2)); }\n      arr.sort((a,b)=>a-b);\n      return Array.from(new Set(arr)).slice(0,size); // ensure unique-ish\n    }\n    el('genArray').addEventListener('click', ()=>{\n      const size = Math.max(3, Math.floor(Number(el('bsSize').value) || 10));\n      currentArray = genArray(size);\n      renderArray();\n    });\n    function renderArray(){\n      bsArrayEl.innerHTML='';\n      currentArray.forEach(v=>{\n        const b = document.createElement('button');\n        b.textContent = v; b.style.padding='6px 8px'; b.style.borderRadius='8px'; b.style.border='1px solid #eef2ff';\n        b.style.background='white'; b.style.cursor='pointer';\n        b.onclick = ()=>{ el('bsTarget').value = v; };\n        bsArrayEl.appendChild(b);\n      });\n    }\n    el('runBS').addEventListener('click', ()=>{\n      if (!currentArray.length) currentArray = genArray(Math.max(3,Number(el('bsSize').value)||10));\n      const target = Number(el('bsTarget').value);\n      bsTraceEl.innerHTML = '';\n      // recursive binary search with trace\n      function bs(lo, hi, depth=0){\n        const frame = document.createElement('div'); frame.className='frame'; frame.textContent = `[depth ${depth}] lo=${lo}, hi=${hi}`;\n        bsTraceEl.appendChild(frame);\n        if (lo>hi){ const nf = document.createElement('div'); nf.style.marginTop='6px'; nf.textContent = 'Not found.'; bsTraceEl.appendChild(nf); return -1; }\n        const mid = Math.floor((lo+hi)/2);\n        const midVal = currentArray[mid];\n        const mark = document.createElement('div'); mark.style.fontSize='13px'; mark.textContent = `mid=${mid} → ${midVal}`;\n        frame.appendChild(mark);\n        if (midVal === target){\n          const found = document.createElement('div'); found.style.marginTop='6px'; found.style.color='#0b6efd'; found.textContent = `Found at index ${mid}`;\n          bsTraceEl.appendChild(found);\n          return mid;\n        } else if (target < midVal){\n          return bs(lo, mid-1, depth+1);\n        } else {\n          return bs(mid+1, hi, depth+1);\n        }\n      }\n      const idx = bs(0, currentArray.length-1);\n      if (idx >= 0) {\n        // highlight selection on array\n        Array.from(bsArrayEl.children).forEach((btn, i)=>{\n          btn.style.background = (i===idx) ? '#e6f0ff' : 'white';\n          btn.style.border = (i===idx) ? '1px solid #0b6efd' : '1px solid #eef2ff';\n        });\n      }\n    });\n\n    // initialize array\n    currentArray = genArray(15); renderArray();\n\n    // ---------- Fractal Tree ----------\n    const treeCanvas = el('treeCanvas'), treeDepth = el('treeDepth');\n    const ctx = treeCanvas.getContext('2d');\n    function drawTree(){\n      const w = treeCanvas.width, h = treeCanvas.height;\n      ctx.clearRect(0,0,w,h);\n      ctx.translate(w/2, h-20);\n      const depth = Number(treeDepth.value);\n      ctx.lineCap = 'round';\n      function branch(len, angle, depthLeft){\n        ctx.save();\n        ctx.rotate(angle);\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(0, -len);\n        ctx.strokeStyle = `hsl(${120 - depthLeft*10}, 60%, ${40 + depthLeft*3}%)`;\n        ctx.lineWidth = Math.max(1, depthLeft*0.8 + 1);\n        ctx.stroke();\n        ctx.translate(0, -len);\n        if (depthLeft>0){\n          branch(len*0.75, Math.PI/8, depthLeft-1);\n          branch(len*0.68, -Math.PI/6, depthLeft-1);\n        }\n        ctx.restore();\n      }\n      ctx.save();\n      branch(60, 0, depth);\n      ctx.restore();\n      // reset transform\n      ctx.setTransform(1,0,0,1,0,0);\n    }\n    el('drawTree').addEventListener('click', drawTree);\n    drawTree();\n\n    // ---------- sumRange (call stack visualizer) ----------\n    const srStack = el('srStack'), srOutput = el('srOutput');\n    el('runSumRange').addEventListener('click', async ()=>{\n      srStack.innerHTML=''; srOutput.textContent='Running sumRange...';\n      const a = Number(el('srA').value), b = Number(el('srB').value);\n      let steps = [];\n      function sumRange(a,b){\n        steps.push({type:'push', a:a, b:b});\n        if (a>b){\n          steps.push({type:'pop', a:a, b:b, res:0});\n          return 0;\n        }\n        if (a===b){\n          steps.push({type:'result', a:a, b:b, res:a});\n          steps.push({type:'pop', a:a, b:b, res:a});\n          return a;\n        }\n        const res = a + sumRange(a+1, b);\n        steps.push({type:'result', a:a, b:b, res:res});\n        steps.push({type:'pop', a:a, b:b, res:res});\n        return res;\n      }\n      const res = sumRange(a,b);\n      // animate quickly\n      const stack = [];\n      for (const ev of steps){\n        if (ev.type==='push'){ stack.unshift(ev); renderSRStack(stack); await sleep(160); }\n        else if (ev.type==='result'){ if (stack.length) stack[0].res = ev.res; renderSRStack(stack); await sleep(120); }\n        else if (ev.type==='pop'){ renderSRStack(stack, ev); await sleep(140); if (stack.length) stack.shift(); renderSRStack(stack); await sleep(80); }\n      }\n      srOutput.textContent = `sumRange(${a}, ${b}) = ${res}`;\n    });\n\n    let stepMode = null;\n    el('stepSumRange').addEventListener('click', ()=>{\n      // prepare generator for stepping\n      const a = Number(el('srA').value), b = Number(el('srB').value);\n      srStack.innerHTML=''; srOutput.textContent='Step mode — press Step-through again to advance.';\n      const steps = [];\n      function sumRange(a,b){\n        steps.push({type:'push', a:a, b:b});\n        if (a>b){\n          steps.push({type:'pop', a:a, b:b, res:0});\n          return 0;\n        }\n        if (a===b){\n          steps.push({type:'result', a:a, b:b, res:a});\n          steps.push({type:'pop', a:a, b:b, res:a});\n          return a;\n        }\n        const res = a + sumRange(a+1, b);\n        steps.push({type:'result', a:a, b:b, res:res});\n        steps.push({type:'pop', a:a, b:b, res:res});\n        return res;\n      }\n      sumRange(a,b);\n      // store steps in stepMode\n      stepMode = {steps, idx:0, stack:[]};\n      // replace button behavior to step\n      el('stepSumRange').textContent='Step';\n      el('stepSumRange').onclick = async ()=>{\n        if (!stepMode) return;\n        const ev = stepMode.steps[stepMode.idx++];\n        if (!ev) {\n          srOutput.textContent = 'Done.';\n          el('stepSumRange').textContent='Step-through';\n          // reinstate listener\n          el('stepSumRange').onclick = ()=>{ /* old handler */ stepMode=null; el('stepSumRange').textContent='Step-through'; };\n          return;\n        }\n        if (ev.type==='push'){ stepMode.stack.unshift(ev); renderSRStack(stepMode.stack); }\n        else if (ev.type==='result'){ if (stepMode.stack.length) stepMode.stack[0].res = ev.res; renderSRStack(stepMode.stack); }\n        else if (ev.type==='pop'){ renderSRStack(stepMode.stack, ev); if (stepMode.stack.length) stepMode.stack.shift(); }\n      };\n    });\n\n    function renderSRStack(stack, highlight){\n      srStack.innerHTML='';\n      stack.forEach((f, i)=>{\n        const d = document.createElement('div'); d.className='frame' + (i===0 ? ' active' : '');\n        d.textContent = `sumRange(${f.a}, ${f.b})` + (f.res!==undefined ? ` → ${f.res}` : '');\n        srStack.appendChild(d);\n      });\n      if (highlight){\n        const note = document.createElement('div'); note.style.fontSize='13px'; note.style.color='#475569';\n        note.style.marginTop='6px';\n        note.textContent = `Popped ${highlight.a},${highlight.b} → ${highlight.res}`;\n        srStack.appendChild(note);\n      }\n    }\n\n    // Accessibility & keyboard: allow pressing Enter on inputs to run primary action\n    document.querySelectorAll('input[type=\"number\"]').forEach(inp=>{\n      inp.addEventListener('keydown', (e)=>{\n        if (e.key === 'Enter'){\n          const id = inp.id;\n          if (id.startsWith('fact')) el('runFact').click();\n          else if (id.startsWith('fib')) el('runFib').click();\n          else if (id.startsWith('bs')) el('runBS').click();\n          else if (id.startsWith('sr')) el('runSumRange').click();\n        }\n      });\n    });\n\n    // Minor: on load, set bsTarget to first value\n    el('bsTarget').value = currentArray[0] || 0;\n\n    // Quick explanation printed to console for curious users\n    console.log(\"Recursion Playground loaded. Try factorial, fibonacci, binary search, and draw the fractal tree.\");\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}