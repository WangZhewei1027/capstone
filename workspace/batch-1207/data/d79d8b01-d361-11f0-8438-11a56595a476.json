{
  "id": "d79d8b01-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:03.182Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Topological Sort Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1em;\n    background: #f9f9f9;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n    color: #004080;\n  }\n  #graphInput {\n    width: 100%;\n    height: 150px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  #runBtn {\n    margin-top: 10px;\n    padding: 0.5em 1em;\n    font-size: 16px;\n  }\n  #errorMsg {\n    color: red;\n    margin-top: 10px;\n  }\n  #result {\n    margin-top: 20px;\n    font-size: 18px;\n  }\n  #graphViz {\n    margin-top: 20px;\n    max-width: 100%;\n    overflow-x: auto;\n  }\n  #svgCanvas {\n    border: 1px solid #ccc;\n    background: white;\n  }\n  .node {\n    cursor: default;\n  }\n  .node circle {\n    fill: #e1f5fe;\n    stroke: #0288d1;\n    stroke-width: 2px;\n  }\n  .node text {\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  .edgePath path {\n    stroke: #888;\n    stroke-width: 1.5px;\n    fill: none;\n  }\n  .edgePath marker {\n    fill: #888;\n  }\n</style>\n</head>\n<body>\n<h1>Topological Sort Demonstration</h1>\n<p>Enter a directed acyclic graph (DAG) as edges (one per line) in the format <code>from -> to</code>.<br />\nExample:<br />\n<code>A -> C</code><br />\n<code>B -> C</code><br />\n<code>C -> D</code></p>\n<textarea id=\"graphInput\" spellcheck=\"false\" placeholder=\"Example input:\nA -> C\nB -> C\nC -> D\nD -> E\n\"></textarea>\n<br />\n<button id=\"runBtn\">Run Topological Sort</button>\n<div id=\"errorMsg\"></div>\n<div id=\"result\"></div>\n<div id=\"graphViz\"></div>\n\n<script>\n// Simple graph visualization and topological sort implementation\n\n// Parse input edges\nfunction parseEdges(input) {\n  const lines = input.split('\\n');\n  const edges = [];\n  for (let line of lines) {\n    line = line.trim();\n    if (line === '') continue;\n    // Expected format: \"A -> B\"\n    const match = line.match(/^(.+?)\\s*->\\s*(.+)$/);\n    if (!match) throw new Error(`Invalid line format: \"${line}\"`);\n    const from = match[1].trim();\n    const to = match[2].trim();\n    if (from === '' || to === '') throw new Error(`Empty node found in line: \"${line}\"`);\n    edges.push([from, to]);\n  }\n  return edges;\n}\n\n// Build adjacency list graph from edges\nfunction buildGraph(edges) {\n  const graph = new Map();\n  const nodesSet = new Set();\n  for (const [from, to] of edges) {\n    nodesSet.add(from);\n    nodesSet.add(to);\n    if (!graph.has(from)) graph.set(from, []);\n    graph.get(from).push(to);\n    // Ensure all nodes appear in graph keys (including leaf nodes)\n    if (!graph.has(to)) graph.set(to, []);\n  }\n  return graph;\n}\n\n// Perform topological sort using Kahn's algorithm\n// Returns an array of nodes in topological order or throws if cycle detected\nfunction topologicalSort(graph) {\n  // Calculate in-degree of each node\n  const inDegree = new Map();\n  for (const node of graph.keys()) {\n    inDegree.set(node, 0);\n  }\n  for (const [from, neighbors] of graph.entries()) {\n    for (const v of neighbors) {\n      inDegree.set(v, inDegree.get(v) + 1);\n    }\n  }\n  // Collect nodes with zero in-degree\n  const queue = [];\n  for (const [node, deg] of inDegree.entries()) {\n    if (deg === 0) queue.push(node);\n  }\n  const topoOrder = [];\n  while (queue.length > 0) {\n    const u = queue.shift();\n    topoOrder.push(u);\n    for (const v of graph.get(u)) {\n      inDegree.set(v, inDegree.get(v) - 1);\n      if (inDegree.get(v) === 0) {\n        queue.push(v);\n      }\n    }\n  }\n  if (topoOrder.length !== graph.size) {\n    throw new Error(\"Graph has at least one cycle; topological sort not possible.\");\n  }\n  return topoOrder;\n}\n\n// Visualization of graph with manual positioning (simple layered layout)\nfunction visualizeGraph(graph, topoOrder) {\n  const width = 700;\n  const height = 400;\n\n  // Clear previous\n  const container = document.getElementById('graphViz');\n  container.innerHTML = '';\n\n  // Create SVG\n  const svgns = \"http://www.w3.org/2000/svg\";\n  const svg = document.createElementNS(svgns, \"svg\");\n  svg.setAttribute(\"width\", width);\n  svg.setAttribute(\"height\", height);\n  svg.setAttribute(\"id\", \"svgCanvas\");\n  container.appendChild(svg);\n\n  // Assign layers based on topoOrder: simple heuristic\n  // For each node, layer = max layer of predecessors + 1, roots = 0\n  const nodeLayers = new Map();\n  for (const node of topoOrder) {\n    let maxParentLayer = -1;\n    for (const [p, children] of graph.entries()) {\n      if (children.includes(node)) {\n        const parentLayer = nodeLayers.get(p);\n        if (parentLayer > maxParentLayer) maxParentLayer = parentLayer;\n      }\n    }\n    nodeLayers.set(node, maxParentLayer + 1);\n  }\n\n  // Group nodes by layer\n  const layers = [];\n  for (const [node, layer] of nodeLayers.entries()) {\n    if (!layers[layer]) layers[layer] = [];\n    layers[layer].push(node);\n  }\n\n  // Calculate node coordinates per layer\n  const nodeCoords = new Map();\n  const layerHeight = height / (layers.length + 1);\n  for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {\n    const nodes = layers[layerIdx];\n    const spacing = width / (nodes.length + 1);\n    for (let i = 0; i < nodes.length; i++) {\n      const x = spacing * (i + 1);\n      const y = layerHeight * (layerIdx + 1);\n      nodeCoords.set(nodes[i], { x, y });\n    }\n  }\n\n  // Define arrow marker\n  const marker = document.createElementNS(svgns, 'marker');\n  marker.setAttribute('id', 'arrowhead');\n  marker.setAttribute('markerWidth', '10');\n  marker.setAttribute('markerHeight', '7');\n  marker.setAttribute('refX', '10');\n  marker.setAttribute('refY', '3.5');\n  marker.setAttribute('orient', 'auto');\n  marker.setAttribute('markerUnits', 'strokeWidth');\n  const markerPath = document.createElementNS(svgns, 'path');\n  markerPath.setAttribute('d', 'M0,0 L10,3.5 L0,7 Z');\n  markerPath.setAttribute('fill', '#555');\n  marker.appendChild(markerPath);\n  const defs = document.createElementNS(svgns, 'defs');\n  defs.appendChild(marker);\n  svg.appendChild(defs);\n\n  // Draw edges\n  for (const [from, neighbors] of graph.entries()) {\n    const start = nodeCoords.get(from);\n    for (const to of neighbors) {\n      const end = nodeCoords.get(to);\n      // Draw a straight line with arrow marker\n      const path = document.createElementNS(svgns, 'path');\n      const offset = 20;\n      // Calculate line coordinates shortened so arrow touches node circle edge\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      const length = Math.sqrt(dx*dx + dy*dy);\n      const ratioStart = offset/length;\n      const ratioEnd = (length - offset)/length;\n\n      const startX = start.x + dx * ratioStart;\n      const startY = start.y + dy * ratioStart;\n      const endX = start.x + dx * ratioEnd;\n      const endY = start.y + dy * ratioEnd;\n\n      const d = `M${startX},${startY} L${endX},${endY}`;\n      path.setAttribute('d', d);\n      path.setAttribute('stroke', '#555');\n      path.setAttribute('stroke-width', '2');\n      path.setAttribute('fill', 'none');\n      path.setAttribute('marker-end', 'url(#arrowhead)');\n      svg.appendChild(path);\n    }\n  }\n\n  // Draw nodes\n  for (const [node, pos] of nodeCoords.entries()) {\n    const g = document.createElementNS(svgns, 'g');\n    g.setAttribute('class', 'node');\n    g.setAttribute('transform', `translate(${pos.x},${pos.y})`);\n\n    const circle = document.createElementNS(svgns, 'circle');\n    circle.setAttribute('r', 18);\n    circle.setAttribute('fill', '#e1f5fe');\n    circle.setAttribute('stroke', '#0288d1');\n    circle.setAttribute('stroke-width', '3');\n    g.appendChild(circle);\n\n    const text = document.createElementNS(svgns, 'text');\n    text.textContent = node;\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('dy', '0.35em');\n    text.setAttribute('font-size', '14');\n    text.setAttribute('fill', '#004080');\n    g.appendChild(text);\n\n    svg.appendChild(g);\n  }\n}\n\ndocument.getElementById('runBtn').addEventListener('click', () => {\n  const input = document.getElementById('graphInput').value;\n  const errorMsg = document.getElementById('errorMsg');\n  const resultDiv = document.getElementById('result');\n  errorMsg.textContent = '';\n  resultDiv.textContent = '';\n  try {\n    const edges = parseEdges(input);\n    if(edges.length === 0) throw new Error('Input graph is empty.');\n    const graph = buildGraph(edges);\n    const topoOrder = topologicalSort(graph);\n    resultDiv.innerHTML = `<strong>Topological Order:</strong> ${topoOrder.join(' â†’ ')}`;\n    visualizeGraph(graph, topoOrder);\n  } catch (e) {\n    errorMsg.textContent = e.message;\n    document.getElementById('graphViz').innerHTML = '';\n  }\n});\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}