{
  "id": "d7b4afc1-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:53.279Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    user-select: none;\n  }\n  h1 {\n    text-align: center;\n    margin: 1rem 0 0.5rem 0;\n  }\n  #container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    margin: 0 auto;\n    max-width: 900px;\n    padding: 0 1rem 2rem;\n  }\n  #canvas-container {\n    position: relative;\n    border: 1px solid #333;\n    background: #fefefe;\n    margin-bottom: 1rem;\n  }\n  canvas {\n    display: block;\n    background: #fff;\n  }\n  #controls {\n    width: 100%;\n    max-width: 600px;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 0.5rem 1rem;\n    align-items: center;\n    justify-content: center;\n    margin-bottom: 1rem;\n  }\n  label {\n    white-space: nowrap;\n  }\n  input[type=\"number\"] {\n    width: 60px;\n    padding: 0.2rem 0.3rem;\n    border-radius: 3px;\n    border: 1px solid #aaa;\n    text-align: center;\n  }\n  button {\n    padding: 0.4rem 0.8rem;\n    border-radius: 4px;\n    border: none;\n    background-color: #005bbb;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    transition: background-color 0.3s ease;\n  }\n  button:hover:not(:disabled) {\n    background-color: #003f7f;\n  }\n  button:disabled {\n    background-color: #ccc;\n    cursor: not-allowed;\n  }\n  #instructions {\n    max-width: 600px;\n    font-size: 0.9rem;\n    color: #444;\n    text-align: center;\n    margin-bottom: 1rem;\n  }\n  #info {\n    font-size: 0.9rem;\n    color: #333;\n    margin-top: 0.3rem;\n    text-align: center;\n    min-height: 1.2em;\n  }\n  #legend {\n    margin-top: 0.5rem;\n    max-width: 600px;\n    text-align: center;\n  }\n  #legend span {\n    display: inline-block;\n    margin: 0 6px;\n    width: 18px;\n    height: 18px;\n    vertical-align: middle;\n    border-radius: 50%;\n  }\n</style>\n</head>\n<body>\n  <h1>K-Means Clustering Interactive Demo</h1>\n  <div id=\"container\">\n    <div id=\"canvas-container\">\n      <canvas id=\"canvas\" width=\"700\" height=\"500\" aria-label=\"K-means clustering visualization\"></canvas>\n    </div>\n    <div id=\"controls\">\n      <label for=\"kInput\">Number of Clusters (k):</label>\n      <input type=\"number\" id=\"kInput\" min=\"1\" max=\"10\" value=\"3\" />\n      <label for=\"pointsInput\">Number of Points:</label>\n      <input type=\"number\" id=\"pointsInput\" min=\"10\" max=\"1000\" value=\"150\" step=\"10\" />\n      <button id=\"generateBtn\" title=\"Generate random points\">Generate Points</button>\n      <button id=\"stepBtn\" title=\"Perform one iteration of K-Means\">Step</button>\n      <button id=\"runBtn\" title=\"Run K-Means to completion\">Run</button>\n      <button id=\"resetBtn\" title=\"Reset clustering\">Reset</button>\n      <button id=\"clearBtn\" title=\"Clear all points and clusters\">Clear</button>\n    </div>\n    <div id=\"instructions\">\n      <strong>Instructions:</strong> Click on the canvas to add points manually.<br>\n      Set the number of clusters and points, then generate random points or add points manually.<br>\n      Use Step to see clustering iterations one by one, or Run to complete clustering automatically.<br>\n      Reset to start clustering again with current points.\n    </div>\n    <div id=\"info\"></div>\n    <div id=\"legend\"></div>\n  </div>\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const kInput = document.getElementById('kInput');\n  const pointsInput = document.getElementById('pointsInput');\n  const generateBtn = document.getElementById('generateBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const info = document.getElementById('info');\n  const legend = document.getElementById('legend');\n\n  const width = canvas.width;\n  const height = canvas.height;\n  const POINT_RADIUS = 5;\n  const CENTER_RADIUS = 9;\n\n  // Colors for clusters (max 10 clusters)\n  const colors = [\n    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',\n    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'\n  ];\n\n  let points = []; // {x, y, cluster}\n  let centers = []; // {x, y}\n  let k = parseInt(kInput.value, 10);\n  let running = false;\n\n  // Distance squared between two points\n  function distSq(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return dx * dx + dy * dy;\n  }\n\n  // Initialize random points inside canvas\n  function generateRandomPoints(n) {\n    points = [];\n    for (let i = 0; i < n; i++) {\n      points.push({\n        x: Math.random() * (width - 2 * POINT_RADIUS) + POINT_RADIUS,\n        y: Math.random() * (height - 2 * POINT_RADIUS) + POINT_RADIUS,\n        cluster: null\n      });\n    }\n  }\n\n  // Initialize centers by randomly choosing k distinct points\n  function initializeCenters() {\n    centers = [];\n    if (points.length === 0) return;\n    const takenIndices = new Set();\n    while (centers.length < Math.min(k, points.length)) {\n      const idx = Math.floor(Math.random() * points.length);\n      if (!takenIndices.has(idx)) {\n        takenIndices.add(idx);\n        centers.push({x: points[idx].x, y: points[idx].y});\n      }\n    }\n  }\n\n  // Assign each point to the nearest center\n  function assignClusters() {\n    let changed = false;\n    points.forEach(pt => {\n      let minDist = Infinity;\n      let assigned = null;\n      centers.forEach((c, idx) => {\n        const d = distSq(pt, c);\n        if (d < minDist) {\n          minDist = d;\n          assigned = idx;\n        }\n      });\n      if (pt.cluster !== assigned) {\n        changed = true;\n        pt.cluster = assigned;\n      }\n    });\n    return changed;\n  }\n\n  // Update centers to be mean of assigned points\n  function updateCenters() {\n    const sums = new Array(k).fill(0).map(() => ({x: 0, y: 0, count: 0}));\n    points.forEach(pt => {\n      if (pt.cluster !== null && sums[pt.cluster]) {\n        sums[pt.cluster].x += pt.x;\n        sums[pt.cluster].y += pt.y;\n        sums[pt.cluster].count++;\n      }\n    });\n    let moved = false;\n    sums.forEach((sum, idx) => {\n      if (sum.count > 0) {\n        const newX = sum.x / sum.count;\n        const newY = sum.y / sum.count;\n        if (centers[idx].x !== newX || centers[idx].y !== newY) {\n          moved = true;\n          centers[idx].x = newX;\n          centers[idx].y = newY;\n        }\n      }\n    });\n    return moved;\n  }\n\n  // Perform one iteration: assign clusters, update centers\n  function kMeansStep() {\n    if (points.length === 0 || centers.length === 0) return false;\n    const changedAssign = assignClusters();\n    const changedCenters = updateCenters();\n    draw();\n    return changedAssign || changedCenters;\n  }\n\n  // Draw points and centers\n  function draw() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw points, colored by cluster\n    points.forEach(pt => {\n      ctx.beginPath();\n      ctx.arc(pt.x, pt.y, POINT_RADIUS, 0, 2 * Math.PI);\n      if (pt.cluster !== null) {\n        ctx.fillStyle = colors[pt.cluster % colors.length];\n        ctx.fill();\n        ctx.strokeStyle = '#333';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n      } else {\n        ctx.fillStyle = '#999';\n        ctx.fill();\n      }\n    });\n\n    // Draw centers prominently\n    centers.forEach((c, idx) => {\n      ctx.beginPath();\n      ctx.arc(c.x, c.y, CENTER_RADIUS, 0, 2 * Math.PI);\n      ctx.fillStyle = colors[idx % colors.length];\n      ctx.fill();\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Draw cluster index number\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 14px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(idx + 1, c.x, c.y);\n    });\n\n    // Draw legend\n    legend.innerHTML = centers.map((_, idx) => `\n      <span style=\"background-color:${colors[idx % colors.length]}\" title=\"Cluster ${idx + 1}\"></span>\n      Cluster ${idx + 1}\n    `).join(' &nbsp;&nbsp; ');\n  }\n\n  // Reset clustering but keep points\n  function resetClustering() {\n    if (points.length === 0) return;\n    if (k > points.length) {\n      alert(\"Number of clusters (k) must be less than or equal to number of points.\");\n      return false;\n    }\n    initializeCenters();\n    points.forEach(pt => pt.cluster = null);\n    draw();\n    info.textContent = 'Clustering reset. Click Step or Run to perform iterations.';\n    return true;\n  }\n\n  // Run clustering until convergence or iteration limit\n  function runClustering() {\n    if (running) return;\n    if (!resetClustering()) return;\n    running = true;\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    generateBtn.disabled = true;\n    clearBtn.disabled = true;\n    kInput.disabled = true;\n    pointsInput.disabled = true;\n    resetBtn.disabled = true;\n    info.textContent = 'Running clustering...';\n\n    let iterations = 0;\n    const maxIterations = 100;\n    function iter() {\n      const changed = kMeansStep();\n      iterations++;\n      if (!changed || iterations >= maxIterations) {\n        running = false;\n        stepBtn.disabled = false;\n        runBtn.disabled = false;\n        generateBtn.disabled = false;\n        clearBtn.disabled = false;\n        kInput.disabled = false;\n        pointsInput.disabled = false;\n        resetBtn.disabled = false;\n        info.textContent = `K-Means converged in ${iterations} iteration${iterations > 1 ? 's' : ''}.`;\n      } else {\n        window.requestAnimationFrame(iter);\n      }\n    }\n    window.requestAnimationFrame(iter);\n  }\n\n  // Add point by clicking canvas\n  function addPoint(e) {\n    if (running) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    if (x < POINT_RADIUS || x > width - POINT_RADIUS || y < POINT_RADIUS || y > height - POINT_RADIUS) return;\n    points.push({x, y, cluster: null});\n    if (points.length > 1000) {\n      points.shift(); // Keep max points manageable\n      info.textContent = 'Maximum points reached, oldest point removed.';\n    }\n    draw();\n    info.textContent = 'Point added. Click Reset or Step to start clustering.';\n  }\n\n  // Event listeners\n  generateBtn.addEventListener('click', () => {\n    const n = Math.min(Math.max(parseInt(pointsInput.value, 10) || 150, 10), 1000);\n    pointsInput.value = n;\n    points = [];\n    generateRandomPoints(n);\n    if (k > n) {\n      info.textContent = \"Number of clusters (k) greater than number of points, adjusting k.\";\n      k = n;\n      kInput.value = k;\n    }\n    initializeCenters();\n    points.forEach(pt => pt.cluster = null);\n    draw();\n    info.textContent = `${n} random points generated. Click Step or Run to cluster. You can also add points by clicking the canvas.`;\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if (points.length === 0) {\n      info.textContent = 'No points available to cluster. Please generate or add points.';\n      return;\n    }\n    if (k > points.length) {\n      info.textContent = 'k cannot be greater than number of points.';\n      return;\n    }\n    if (centers.length === 0) {\n      initializeCenters();\n      points.forEach(pt => pt.cluster = null);\n    }\n    const changed = kMeansStep();\n    if (!changed) {\n      info.textContent = 'Clustering has converged.';\n    } else {\n      info.textContent = 'Performed one iteration of K-Means.';\n    }\n  });\n\n  runBtn.addEventListener('click', runClustering);\n\n  resetBtn.addEventListener('click', () => {\n    if (resetClustering()) {\n      info.textContent = 'Clustering reset. Click Step or Run to perform iterations.';\n    }\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if (running) return;\n    points = [];\n    centers = [];\n    draw();\n    info.textContent = 'Cleared all points and clusters.';\n  });\n\n  kInput.addEventListener('change', () => {\n    let val = parseInt(kInput.value, 10);\n    if (isNaN(val) || val < 1) val = 1;\n    if (val > 10) val = 10;\n    if (val > points.length) val = points.length || 1;\n    kInput.value = val;\n    k = val;\n  });\n\n  pointsInput.addEventListener('change', () => {\n    let val = parseInt(pointsInput.value, 10);\n    if (isNaN(val) || val < 10) val = 10;\n    if (val > 1000) val = 1000;\n    pointsInput.value = val;\n  });\n\n  canvas.addEventListener('click', addPoint);\n\n  // Initial draw empty state\n  draw();\n  info.textContent = 'Set parameters and generate points or add points by clicking on the canvas.';\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}