{
  "id": "d79c2b71-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:42.179Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Visualization (Directed/Undirected)</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #f0f2f5;\n  }\n  h1 {\n    text-align: center;\n    margin: 1rem 0 0.5rem;\n  }\n  #container {\n    max-width: 900px;\n    margin: 0 auto 2rem;\n    background: #fff;\n    padding: 1rem;\n    border-radius: 8px;\n    box-shadow: 0 4px 15px rgb(0 0 0 / 0.1);\n  }\n  #controls {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    gap: 1rem;\n    margin-bottom: 1rem;\n    flex-wrap: wrap;\n  }\n  label {\n    font-weight: 600;\n  }\n  select {\n    font-size: 1rem;\n    padding: 0.2rem 0.4rem;\n  }\n  button {\n    padding: 0.45rem 1rem;\n    font-size: 1rem;\n    font-weight: 600;\n    background-color: #0078d7;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: background-color 0.3s ease;\n  }\n  button:hover {\n    background-color: #005fa3;\n  }\n  #graphCanvas {\n    display: block;\n    margin: 0 auto;\n    background: #ffffff;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n  }\n  #legend {\n    margin-top: 1rem;\n    text-align: center;\n  }\n  #legend span {\n    display: inline-block;\n    margin: 0 1rem;\n    font-size: 1.1rem;\n  }\n  #legend .edge-color {\n    width: 20px;\n    height: 3px;\n    background: #0078d7;\n    display: inline-block;\n    vertical-align: middle;\n    margin-right: 0.4rem;\n  }\n</style>\n</head>\n<body>\n  <h1>Graph Visualization: Directed & Undirected Graph</h1>\n  <div id=\"container\">\n    <div id=\"controls\">\n      <label for=\"graphType\">Graph Type:</label>\n      <select id=\"graphType\">\n        <option value=\"undirected\">Undirected Graph</option>\n        <option value=\"directed\">Directed Graph</option>\n      </select>\n      <button id=\"resetBtn\">Reset Graph</button>\n    </div>\n    <canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n    <div id=\"legend\">\n      <span><strong>Legend:</strong></span>\n      <span><svg style=\"width:20px;height:14px;vertical-align:middle;\" viewBox=\"0 0 20 14\" xmlns=\"http://www.w3.org/2000/svg\">\n        <circle cx=\"7\" cy=\"7\" r=\"6\" fill=\"#0078d7\" />\n      </svg> Node</span>\n      <span><div class=\"edge-color\"></div> Edge</span>\n      <span>Arrowhead (only in Directed)</span>\n    </div>\n    <p style=\"text-align:center; max-width: 650px; margin: 20px auto;\">\n      <em>Click on canvas to add nodes. Click a node to select it, then click another to add an edge between them. Switch graph type to see differences.</em>\n    </p>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const graphTypeSelect = document.getElementById('graphType');\n  const resetBtn = document.getElementById('resetBtn');\n\n  const NODE_RADIUS = 20;\n  const ARROW_SIZE = 10;\n\n  // Graph data\n  let nodes = [];\n  let edges = []; // edges: array of objects { from: nodeIndex, to: nodeIndex }\n  let selectedNodeIndex = null;\n  let graphType = graphTypeSelect.value; // 'directed' or 'undirected'\n\n  // Utility: distance between points\n  function distance(x1,y1,x2,y2) {\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n\n  // Check if point is inside node circle\n  function getNodeAt(x, y) {\n    for (let i = nodes.length - 1; i >= 0; i--) {\n      const node = nodes[i];\n      if (distance(x,y,node.x,node.y) <= NODE_RADIUS) return i;\n    }\n    return -1;\n  }\n\n  // Draw arrowhead on ctx at (x,y) pointing towards (fromX, fromY)\n  function drawArrowhead(ctx, fromX, fromY, toX, toY) {\n    const angle = Math.atan2(toY - fromY, toX - fromX);\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(toX, toY);\n    ctx.rotate(angle);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(-ARROW_SIZE, ARROW_SIZE / 2);\n    ctx.lineTo(-ARROW_SIZE, -ARROW_SIZE / 2);\n    ctx.closePath();\n    ctx.fillStyle = '#0078d7';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw everything\n  function draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges\n    edges.forEach(({from, to}) => {\n      const fromNode = nodes[from];\n      const toNode = nodes[to];\n\n      // Calculate line endpoints so arrows/tails don't overlap nodes\n      const dx = toNode.x - fromNode.x;\n      const dy = toNode.y - fromNode.y;\n      const angle = Math.atan2(dy, dx);\n      const fromX = fromNode.x + Math.cos(angle) * NODE_RADIUS;\n      const fromY = fromNode.y + Math.sin(angle) * NODE_RADIUS;\n      const toX = toNode.x - Math.cos(angle) * NODE_RADIUS;\n      const toY = toNode.y - Math.sin(angle) * NODE_RADIUS;\n\n      ctx.strokeStyle = '#0078d7';\n      ctx.fillStyle = '#0078d7';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n\n      if (graphType === 'directed') {\n        drawArrowhead(ctx, fromX, fromY, toX, toY);\n      } else {\n        // For undirected graph, optionally draw something at midpoint to suggest connection\n        // We'll draw a small circle at midpoint:\n        /*\n        const midX = (fromX + toX) / 2;\n        const midY = (fromY + toY) / 2;\n        ctx.beginPath();\n        ctx.arc(midX, midY, 4, 0, 2 * Math.PI);\n        ctx.fill();\n        */\n      }\n    });\n\n    // Draw nodes\n    nodes.forEach((node,i) => {\n      ctx.beginPath();\n      ctx.fillStyle = (i === selectedNodeIndex) ? '#005fa3' : '#0078d7';\n      ctx.strokeStyle = '#003f6b';\n      ctx.lineWidth = 2;\n      ctx.shadowColor = 'rgba(0,0,0,0.1)';\n      ctx.shadowBlur = 3;\n      ctx.shadowOffsetX = 1;\n      ctx.shadowOffsetY = 1;\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.shadowColor = 'transparent';\n      ctx.stroke();\n\n      // Draw node label as its index+1\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(i + 1, node.x, node.y);\n    });\n  }\n\n  // Add node at position\n  function addNode(x, y) {\n    nodes.push({x, y});\n    draw();\n  }\n\n  // Add edge from selectedNodeIndex to target index\n  function addEdge(from, to) {\n    if (from === to) {\n      alert(\"Cannot create edge from a node to itself.\");\n      return;\n    }\n\n    // For undirected graph, we do not want duplicate edges (from->to or to->from)\n    // For directed, prevent duplicate same direction edges.\n\n    if (graphType === 'undirected') {\n      const exists = edges.some(e =>\n        (e.from === from && e.to === to) || (e.from === to && e.to === from));\n      if (exists) {\n        alert(\"This edge already exists.\");\n        return;\n      }\n      edges.push({from, to});\n    } else {\n      const exists = edges.some(e => e.from === from && e.to === to);\n      if (exists) {\n        alert(\"This directed edge already exists.\");\n        return;\n      }\n      edges.push({from, to});\n    }\n    draw();\n  }\n\n  // Reset everything\n  function resetGraph() {\n    nodes = [];\n    edges = [];\n    selectedNodeIndex = null;\n    draw();\n  }\n\n  // Event handlers\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const clickedNodeIndex = getNodeAt(x, y);\n\n    if (clickedNodeIndex === -1) {\n      // Clicked empty space - add node\n      addNode(x, y);\n      selectedNodeIndex = null;\n    } else {\n      // Clicked a node\n      if (selectedNodeIndex === null) {\n        selectedNodeIndex = clickedNodeIndex;\n      } else if (selectedNodeIndex === clickedNodeIndex) {\n        // Clicked same node again, deselect\n        selectedNodeIndex = null;\n      } else {\n        // Add edge from selectedNodeIndex -> clickedNodeIndex\n        addEdge(selectedNodeIndex, clickedNodeIndex);\n        selectedNodeIndex = null;\n      }\n    }\n    draw();\n  });\n\n  graphTypeSelect.addEventListener('change', (e) => {\n    graphType = e.target.value;\n    // When switching graph type, edges remain but directionality changes\n    // No further validation needed here.\n    selectedNodeIndex = null;\n    draw();\n  });\n\n  resetBtn.addEventListener('click', () => {\n    resetGraph();\n  });\n\n  // Initial draw\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}