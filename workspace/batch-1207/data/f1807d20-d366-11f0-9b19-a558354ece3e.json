{
  "id": "f1807d20-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:27.058Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Search Tree Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background-color: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        input, button {\n            padding: 8px 12px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-size: 14px;\n        }\n        button {\n            background-color: #007bff;\n            color: white;\n            cursor: pointer;\n            border: none;\n        }\n        button:hover {\n            background-color: #0056b3;\n        }\n        button:disabled {\n            background-color: #6c757d;\n            cursor: not-allowed;\n        }\n        .canvas-container {\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            padding: 20px;\n            background-color: #f8f9fa;\n            min-height: 400px;\n            position: relative;\n        }\n        canvas {\n            display: block;\n            margin: 0 auto;\n        }\n        .operations {\n            margin-top: 20px;\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 10px;\n        }\n        .status {\n            margin-top: 15px;\n            padding: 10px;\n            border-radius: 4px;\n            background-color: #e9ecef;\n        }\n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #007bff;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            transform: translate(-50%, -50%);\n        }\n        .line {\n            position: absolute;\n            background-color: #333;\n            transform-origin: 0 0;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Binary Search Tree Visualization</h1>\n        \n        <div class=\"controls\">\n            <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter value\" min=\"-999\" max=\"999\">\n            <button onclick=\"insertNode()\">Insert Node</button>\n            <button onclick=\"deleteNode()\">Delete Node</button>\n            <button onclick=\"searchNode()\">Search Node</button>\n            <button onclick=\"clearTree()\">Clear Tree</button>\n            <button onclick=\"generateRandomTree()\">Generate Random Tree</button>\n        </div>\n\n        <div class=\"operations\">\n            <button onclick=\"traversePreOrder()\">Pre-order Traversal</button>\n            <button onclick=\"traverseInOrder()\">In-order Traversal</button>\n            <button onclick=\"traversePostOrder()\">Post-order Traversal</button>\n            <button onclick=\"findMin()\">Find Minimum</button>\n            <button onclick=\"findMax()\">Find Maximum</button>\n            <button onclick=\"getHeight()\">Get Height</button>\n            <button onclick=\"countNodes()\">Count Nodes</button>\n        </div>\n\n        <div class=\"status\" id=\"status\">\n            Ready to build a Binary Search Tree!\n        </div>\n\n        <div class=\"canvas-container\" id=\"treeContainer\">\n            <!-- Tree will be rendered here using DOM elements -->\n        </div>\n    </div>\n\n    <script>\n        class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BinarySearchTree {\n            constructor() {\n                this.root = null;\n            }\n\n            insert(value) {\n                const newNode = new BSTNode(value);\n                \n                if (this.root === null) {\n                    this.root = newNode;\n                    return true;\n                }\n\n                let current = this.root;\n                while (true) {\n                    if (value === current.value) return false; // Duplicate values not allowed\n                    \n                    if (value < current.value) {\n                        if (current.left === null) {\n                            current.left = newNode;\n                            return true;\n                        }\n                        current = current.left;\n                    } else {\n                        if (current.right === null) {\n                            current.right = newNode;\n                            return true;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n\n            search(value) {\n                let current = this.root;\n                while (current) {\n                    if (value === current.value) return current;\n                    current = value < current.value ? current.left : current.right;\n                }\n                return null;\n            }\n\n            delete(value) {\n                this.root = this._deleteNode(this.root, value);\n            }\n\n            _deleteNode(root, value) {\n                if (root === null) return null;\n\n                if (value < root.value) {\n                    root.left = this._deleteNode(root.left, value);\n                } else if (value > root.value) {\n                    root.right = this._deleteNode(root.right, value);\n                } else {\n                    // Node to be deleted found\n                    if (root.left === null) return root.right;\n                    if (root.right === null) return root.left;\n\n                    // Node with two children: get inorder successor\n                    root.value = this._minValue(root.right);\n                    root.right = this._deleteNode(root.right, root.value);\n                }\n                return root;\n            }\n\n            _minValue(node) {\n                let min = node.value;\n                while (node.left !== null) {\n                    min = node.left.value;\n                    node = node.left;\n                }\n                return min;\n            }\n\n            preOrder() {\n                const result = [];\n                this._preOrder(this.root, result);\n                return result;\n            }\n\n            _preOrder(node, result) {\n                if (node !== null) {\n                    result.push(node.value);\n                    this._preOrder(node.left, result);\n                    this._preOrder(node.right, result);\n                }\n            }\n\n            inOrder() {\n                const result = [];\n                this._inOrder(this.root, result);\n                return result;\n            }\n\n            _inOrder(node, result) {\n                if (node !== null) {\n                    this._inOrder(node.left, result);\n                    result.push(node.value);\n                    this._inOrder(node.right, result);\n                }\n            }\n\n            postOrder() {\n                const result = [];\n                this._postOrder(this.root, result);\n                return result;\n            }\n\n            _postOrder(node, result) {\n                if (node !== null) {\n                    this._postOrder(node.left, result);\n                    this._postOrder(node.right, result);\n                    result.push(node.value);\n                }\n            }\n\n            findMin() {\n                if (this.root === null) return null;\n                let current = this.root;\n                while (current.left !== null) {\n                    current = current.left;\n                }\n                return current.value;\n            }\n\n            findMax() {\n                if (this.root === null) return null;\n                let current = this.root;\n                while (current.right !== null) {\n                    current = current.right;\n                }\n                return current.value;\n            }\n\n            getHeight() {\n                return this._getHeight(this.root);\n            }\n\n            _getHeight(node) {\n                if (node === null) return -1;\n                return 1 + Math.max(this._getHeight(node.left), this._getHeight(node.right));\n            }\n\n            countNodes() {\n                return this._countNodes(this.root);\n            }\n\n            _countNodes(node) {\n                if (node === null) return 0;\n                return 1 + this._countNodes(node.left) + this._countNodes(node.right);\n            }\n\n            // Tree visualization helper methods\n            _getNodePositions() {\n                const positions = [];\n                this._calculatePositions(this.root, 0, 0, positions, this.getHeight());\n                return positions;\n            }\n\n            _calculatePositions(node, level, position, positions, maxHeight) {\n                if (node === null) return;\n\n                const x = (position + 0.5) * (800 / Math.pow(2, level));\n                const y = level * 80 + 50;\n\n                positions.push({\n                    value: node.value,\n                    x: x,\n                    y: y,\n                    level: level,\n                    position: position\n                });\n\n                const nextLevel = level + 1;\n                this._calculatePositions(node.left, nextLevel, position * 2, positions, maxHeight);\n                this._calculatePositions(node.right, nextLevel, position * 2 + 1, positions, maxHeight);\n            }\n        }\n\n        // Global BST instance\n        const bst = new BinarySearchTree();\n\n        function updateStatus(message, isError = false) {\n            const statusEl = document.getElementById('status');\n            statusEl.textContent = message;\n            statusEl.style.backgroundColor = isError ? '#f8d7da' : '#d1ecf1';\n            statusEl.style.color = isError ? '#721c24' : '#0c5460';\n        }\n\n        function renderTree() {\n            const container = document.getElementById('treeContainer');\n            container.innerHTML = '';\n\n            if (bst.root === null) {\n                container.innerHTML = '<p style=\"text-align: center; color: #666;\">Tree is empty</p>';\n                return;\n            }\n\n            const positions = bst._getNodePositions();\n\n            // Draw lines first (so they appear behind nodes)\n            positions.forEach(nodePos => {\n                const parent = positions.find(p => \n                    p.level === nodePos.level - 1 && \n                    Math.floor(nodePos.position / 2) === p.position\n                );\n\n                if (parent) {\n                    const line = document.createElement('div');\n                    line.className = 'line';\n                    \n                    const dx = nodePos.x - parent.x;\n                    const dy = nodePos.y - parent.y;\n                    const length = Math.sqrt(dx * dx + dy * dy);\n                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n\n                    line.style.width = length + 'px';\n                    line.style.height = '2px';\n                    line.style.left = parent.x + 'px';\n                    line.style.top = parent.y + 'px';\n                    line.style.transform = `rotate(${angle}deg)`;\n\n                    container.appendChild(line);\n                }\n            });\n\n            // Draw nodes\n            positions.forEach(nodePos => {\n                const node = document.createElement('div');\n                node.className = 'node';\n                node.textContent = nodePos.value;\n                node.style.left = nodePos.x + 'px';\n                node.style.top = nodePos.y + 'px';\n                container.appendChild(node);\n            });\n        }\n\n        function insertNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                updateStatus('Please enter a valid number', true);\n                return;\n            }\n\n            if (bst.insert(value)) {\n                updateStatus(`Node ${value} inserted successfully`);\n                renderTree();\n            } else {\n                updateStatus(`Node ${value} already exists in the tree`, true);\n            }\n            document.getElementById('nodeValue').value = '';\n        }\n\n        function deleteNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                updateStatus('Please enter a valid number', true);\n                return;\n            }\n\n            if (bst.search(value)) {\n                bst.delete(value);\n                updateStatus(`Node ${value} deleted successfully`);\n                renderTree();\n            } else {\n                updateStatus(`Node ${value} not found in the tree`, true);\n            }\n            document.getElementById('nodeValue').value = '';\n        }\n\n        function searchNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                updateStatus('Please enter a valid number', true);\n                return;\n            }\n\n            const result = bst.search(value);\n            if (result) {\n                updateStatus(`Node ${value} found in the tree`);\n            } else {\n                updateStatus(`Node ${value} not found in the tree`, true);\n            }\n            document.getElementById('nodeValue').value = '';\n        }\n\n        function clearTree() {\n            bst.root = null;\n            updateStatus('Tree cleared');\n            renderTree();\n        }\n\n        function generateRandomTree() {\n            clearTree();\n            const nodeCount = Math.floor(Math.random() * 10) + 5; // 5-14 nodes\n            const values = new Set();\n            \n            while (values.size < nodeCount) {\n                values.add(Math.floor(Math.random() * 100) - 25); // -25 to 74\n            }\n\n            values.forEach(value => bst.insert(value));\n            updateStatus(`Generated random tree with ${nodeCount} nodes`);\n            renderTree();\n        }\n\n        function traversePreOrder() {\n            const result = bst.preOrder();\n            updateStatus(`Pre-order traversal: [${result.join(', ')}]`);\n        }\n\n        function traverseInOrder() {\n            const result = bst.inOrder();\n            updateStatus(`In-order traversal: [${result.join(', ')}]`);\n        }\n\n        function traversePostOrder() {\n            const result = bst.postOrder();\n            updateStatus(`Post-order traversal: [${result.join(', ')}]`);\n        }\n\n        function findMin() {\n            const min = bst.findMin();\n            if (min !== null) {\n                updateStatus(`Minimum value: ${min}`);\n            } else {\n                updateStatus('Tree is empty', true);\n            }\n        }\n\n        function findMax() {\n            const max = bst.findMax();\n            if (max !== null) {\n                updateStatus(`Maximum value: ${max}`);\n            } else {\n                updateStatus('Tree is empty', true);\n            }\n        }\n\n        function getHeight() {\n            const height = bst.getHeight();\n            updateStatus(`Tree height: ${height}`);\n        }\n\n        function countNodes() {\n            const count = bst.countNodes();\n            updateStatus(`Number of nodes: ${count}`);\n        }\n\n        // Initial render\n        renderTree();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}