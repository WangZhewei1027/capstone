{
  "id": "98e11e60-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:22.000Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Binary Tree Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --node:#0ea5a4;\n      --node-border:#08363a;\n      --highlight:#f59e0b;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --font-sans: \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071427 60%);font-family:var(--font-sans);color:#e6eef8}\n    .app {\n      display:flex;\n      gap:16px;\n      padding:18px;\n      box-sizing:border-box;\n      height:100vh;\n      align-items:stretch;\n    }\n    .panel{\n      width:360px;\n      background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:14px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    h1{margin:0;font-size:18px;color:#dbeafe}\n    .controls{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    input[type=\"number\"], input[type=\"text\"]{\n      background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:8px;border-radius:8px;min-width:0;\n    }\n    button{\n      background:var(--accent);border:none;color:#03203b;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;\n      box-shadow: 0 4px 8px rgba(59,130,246,0.14);\n    }\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);box-shadow:none;}\n    button.warn{background:var(--danger);color:white;}\n    .row{display:flex;gap:8px;align-items:center;}\n    .small{font-size:13px;color:var(--muted)}\n    .vis {\n      flex:1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius:12px;\n      padding:12px;\n      position:relative;\n      min-width:0;\n      overflow:hidden;\n    }\n    #svgCanvas{\n      width:100%;height:100%;background:transparent;display:block;border-radius:8px;\n    }\n    .legend{\n      display:flex;gap:8px;flex-wrap:wrap;align-items:center;font-size:13px;color:var(--muted)\n    }\n    .badge{\n      padding:6px 8px;border-radius:999px;background:var(--glass);color:var(--muted);font-weight:600;border:1px solid rgba(255,255,255,0.02);\n    }\n    .status{\n      display:flex;gap:8px;align-items:center;flex-wrap:wrap;\n    }\n    .footer{\n      font-size:13px;color:var(--muted);margin-top:auto;\n    }\n    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;}\n    .traversal-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    .result{\n      background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted);font-size:13px;min-height:36px;\n    }\n    .node-label{\n      font-weight:700;color:#021016;\n    }\n    .help{font-size:13px;color:var(--muted)}\n    a{color:var(--accent)}\n    /* Tooltip-ish small */\n    .mini{font-size:12px;color:var(--muted)}\n    /* Responsive */\n    @media (max-width:920px){\n      .app{flex-direction:column;padding:12px;}\n      .panel{width:100%;}\n      .vis{height:58vh;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel\" aria-hidden=\"false\">\n      <h1>Binary Tree (BST) Visualizer</h1>\n      <div class=\"small\">Interactive Binary Search Tree with insert, delete, search, and animated traversals.</div>\n\n      <div class=\"controls\">\n        <div style=\"flex:1\">\n          <div class=\"row\" style=\"gap:6px;\">\n            <input id=\"valueInput\" type=\"number\" placeholder=\"Value (integer)\" />\n            <button id=\"insertBtn\">Insert</button>\n            <button id=\"deleteBtn\" class=\"ghost\">Delete</button>\n          </div>\n          <div class=\"row\" style=\"margin-top:6px;\">\n            <input id=\"searchInput\" type=\"number\" placeholder=\"Search value\" />\n            <button id=\"searchBtn\" class=\"ghost\">Search</button>\n            <button id=\"clearHighlights\" class=\"ghost\">Clear</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"controls-grid\">\n        <div>\n          <div class=\"row\">\n            <input id=\"randomCount\" type=\"number\" min=\"1\" max=\"25\" value=\"8\" />\n            <button id=\"randomBtn\" class=\"ghost\">Random Tree</button>\n            <button id=\"clearBtn\" class=\"ghost\">Clear Tree</button>\n          </div>\n          <div class=\"mini\" style=\"margin-top:6px\">Random adds unique values in range 1..99.</div>\n        </div>\n\n        <div>\n          <div class=\"small\">Traversal</div>\n          <div class=\"traversal-controls\" style=\"margin-top:6px;\">\n            <button id=\"preorder\" class=\"ghost\">Preorder</button>\n            <button id=\"inorder\" class=\"ghost\">Inorder</button>\n            <button id=\"postorder\" class=\"ghost\">Postorder</button>\n            <button id=\"bfs\" class=\"ghost\">Level-order</button>\n            <div style=\"display:flex;align-items:center;gap:6px;margin-left:auto;\">\n              <label class=\"mini\">Speed</label>\n              <input id=\"speed\" type=\"range\" min=\"200\" max=\"1200\" value=\"520\" />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div style=\"display:flex;gap:8px;align-items:center;margin-top:6px;\">\n        <div class=\"badge\">Nodes: <span id=\"nodeCount\">0</span></div>\n        <div class=\"badge\">Height: <span id=\"treeHeight\">0</span></div>\n        <div class=\"badge\">Last Op: <span id=\"lastOp\">—</span></div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <div class=\"small\">Traversal result</div>\n        <div id=\"result\" class=\"result\" aria-live=\"polite\">—</div>\n      </div>\n\n      <div class=\"footer\">\n        Tip: Insert integers. The layout uses an in-order horizontal spacing so BST structure is clear. Click nodes to remove them. Drag the background to pan (hold mouse + move).\n      </div>\n    </div>\n\n    <div class=\"vis\" id=\"visualArea\">\n      <svg id=\"svgCanvas\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n            <feDropShadow dx=\"0\" dy=\"6\" stdDeviation=\"8\" flood-color=\"#000\" flood-opacity=\"0.45\"/>\n          </filter>\n        </defs>\n        <!-- edges and nodes drawn by JS -->\n      </svg>\n      <!-- small legend -->\n      <div style=\"position:absolute;right:14px;bottom:12px;display:flex;gap:8px;align-items:center;\">\n        <div class=\"legend\">\n          <div style=\"display:flex;align-items:center;gap:6px;\">\n            <svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#0ea5a4\"/></svg><div class=\"mini\">Node</div>\n          </div>\n          <div style=\"display:flex;align-items:center;gap:6px;\">\n            <svg width=\"18\" height=\"18\"><rect width=\"18\" height=\"4\" y=\"7\" fill=\"#94a3b8\"/></svg><div class=\"mini\">Edge</div>\n          </div>\n          <div style=\"display:flex;align-items:center;gap:6px;\">\n            <svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#f59e0b\"/></svg><div class=\"mini\">Highlight</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Binary Search Tree visualizer\n    (function(){\n      // Basic BST implementation with nodes\n      class TreeNode {\n        constructor(val){\n          this.val = val;\n          this.left = null;\n          this.right = null;\n          // visualization coordinates\n          this.x = 0; this.y = 0;\n          this.id = TreeNode._nextId++;\n        }\n      }\n      TreeNode._nextId = 1;\n\n      class BST {\n        constructor(){\n          this.root = null;\n          this._count = 0;\n        }\n        insert(val){\n          if(this.root === null){\n            this.root = new TreeNode(val);\n            this._count++;\n            return this.root;\n          }\n          let cur = this.root;\n          while(true){\n            if(val === cur.val) return null; // no duplicates\n            if(val < cur.val){\n              if(cur.left) cur = cur.left;\n              else { cur.left = new TreeNode(val); this._count++; return cur.left; }\n            } else {\n              if(cur.right) cur = cur.right;\n              else { cur.right = new TreeNode(val); this._count++; return cur.right; }\n            }\n          }\n        }\n        contains(val){\n          let cur = this.root;\n          while(cur){\n            if(val === cur.val) return cur;\n            cur = val < cur.val ? cur.left : cur.right;\n          }\n          return null;\n        }\n        remove(val){\n          let deleted = false;\n          function removeNode(node, val){\n            if(!node) return null;\n            if(val < node.val){\n              node.left = removeNode(node.left, val);\n              return node;\n            } else if(val > node.val){\n              node.right = removeNode(node.right, val);\n              return node;\n            } else {\n              // found\n              deleted = true;\n              // no children\n              if(!node.left && !node.right) return null;\n              // one child\n              if(!node.left) return node.right;\n              if(!node.right) return node.left;\n              // two children: find inorder successor (smallest in right)\n              let succParent = node;\n              let succ = node.right;\n              while(succ.left){\n                succParent = succ;\n                succ = succ.left;\n              }\n              node.val = succ.val;\n              // remove successor\n              if(succParent === node) succParent.right = succ.right;\n              else succParent.left = succ.right;\n              return node;\n            }\n          }\n          this.root = removeNode(this.root, val);\n          if(deleted) this._count--;\n          return deleted;\n        }\n        clear(){ this.root = null; this._count = 0; TreeNode._nextId = 1; }\n        count(){ return this._count; }\n        height(){\n          function h(n){ if(!n) return 0; return 1 + Math.max(h(n.left), h(n.right)); }\n          return h(this.root);\n        }\n        inorder(callback){\n          const res = [];\n          function go(n){\n            if(!n) return;\n            go(n.left);\n            res.push(n);\n            go(n.right);\n          }\n          go(this.root);\n          if(callback) res.forEach(callback);\n          return res;\n        }\n        preorder(callback){\n          const res = [];\n          function go(n){\n            if(!n) return;\n            res.push(n);\n            go(n.left);\n            go(n.right);\n          }\n          go(this.root);\n          if(callback) res.forEach(callback);\n          return res;\n        }\n        postorder(callback){\n          const res = [];\n          function go(n){\n            if(!n) return;\n            go(n.left);\n            go(n.right);\n            res.push(n);\n          }\n          go(this.root);\n          if(callback) res.forEach(callback);\n          return res;\n        }\n        levelOrder(callback){\n          const res = [];\n          if(!this.root) return res;\n          const q = [this.root];\n          while(q.length){\n            const n = q.shift();\n            res.push(n);\n            if(n.left) q.push(n.left);\n            if(n.right) q.push(n.right);\n          }\n          if(callback) res.forEach(callback);\n          return res;\n        }\n      }\n\n      // DOM elements\n      const svg = document.getElementById('svgCanvas');\n      const insertBtn = document.getElementById('insertBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const randomCount = document.getElementById('randomCount');\n      const valueInput = document.getElementById('valueInput');\n      const searchInput = document.getElementById('searchInput');\n      const searchBtn = document.getElementById('searchBtn');\n      const clearHighlights = document.getElementById('clearHighlights');\n      const nodeCountEl = document.getElementById('nodeCount');\n      const treeHeightEl = document.getElementById('treeHeight');\n      const lastOpEl = document.getElementById('lastOp');\n      const resultEl = document.getElementById('result');\n      const inorderBtn = document.getElementById('inorder');\n      const preorderBtn = document.getElementById('preorder');\n      const postorderBtn = document.getElementById('postorder');\n      const bfsBtn = document.getElementById('bfs');\n      const speedSlider = document.getElementById('speed');\n      const visualArea = document.getElementById('visualArea');\n\n      // state\n      const tree = new BST();\n      let elementsMap = new Map(); // node.id -> {g,line,...}\n      let highlightTimer = null;\n      let currentAnim = null;\n      let pan = {x:0,y:0};\n      let viewBox = {w:1200,h:700,x:0,y:0};\n\n      // layout constants\n      const margin = {top:40, bottom:40, left:40, right:40};\n      const levelHeight = 90;\n      const nodeRadius = 26;\n\n      // utility create SVG elements\n      function svgEl(tag, attrs){ const el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag); if(attrs) for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }\n\n      // render tree (clear and redraw)\n      function render(){\n        // clear SVG\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n        // re-add defs (shadow)\n        const defs = svg.querySelector('defs');\n        // create defs manually to keep filter\n        const defsNew = svgEl('defs');\n        const filter = svgEl('filter',{id:'shadow',x:'-50%',y:'-50%',width:'200%',height:'200%'});\n        const fe = document.createElementNS(\"http://www.w3.org/2000/svg\",'feDropShadow');\n        fe.setAttribute('dx','0'); fe.setAttribute('dy','6'); fe.setAttribute('stdDeviation','8'); fe.setAttribute('flood-color','#000'); fe.setAttribute('flood-opacity','0.45');\n        filter.appendChild(fe);\n        defsNew.appendChild(filter);\n        svg.appendChild(defsNew);\n\n        elementsMap.clear();\n        if(!tree.root){\n          updateStats();\n          return;\n        }\n\n        // compute positions: use inorder horizontal spacing\n        let counter = 0;\n        const nodesInOrder = [];\n        function inorderAssign(n, depth){\n          if(!n) return;\n          inorderAssign(n.left, depth+1);\n          nodesInOrder.push({node:n, depth:depth});\n          inorderAssign(n.right, depth+1);\n        }\n        inorderAssign(tree.root, 0);\n        const total = nodesInOrder.length;\n        const svgW = viewBox.w - margin.left - margin.right;\n        nodesInOrder.forEach((entry, idx) => {\n          const n = entry.node;\n          const depth = entry.depth;\n          const x = margin.left + ((idx+1) * svgW / (total+1));\n          const y = margin.top + depth * levelHeight + nodeRadius;\n          n.x = x;\n          n.y = y;\n        });\n\n        // draw edges first (lines)\n        function drawEdges(n){\n          if(!n) return;\n          if(n.left){\n            const line = svgEl('line', {\n              x1:n.x, y1:n.y, x2:n.left.x, y2:n.left.y,\n              stroke:'#94a3b8', 'stroke-width':2, 'stroke-linecap':'round'\n            });\n            svg.appendChild(line);\n          }\n          if(n.right){\n            const line = svgEl('line', {\n              x1:n.x, y1:n.y, x2:n.right.x, y2:n.right.y,\n              stroke:'#94a3b8', 'stroke-width':2, 'stroke-linecap':'round'\n            });\n            svg.appendChild(line);\n          }\n          drawEdges(n.left);\n          drawEdges(n.right);\n        }\n        drawEdges(tree.root);\n\n        // draw nodes\n        function drawNodes(n){\n          if(!n) return;\n          const g = svgEl('g', {cursor:'pointer', 'data-id': n.id});\n          // shadow circle\n          const shadow = svgEl('circle', {cx:n.x, cy:n.y+4, r:nodeRadius, fill:'rgba(0,0,0,0.18)'});\n          // main circle\n          const c = svgEl('circle', {cx:n.x, cy:n.y, r:nodeRadius, fill:'#0ea5a4', stroke:'#08363a', 'stroke-width':2});\n          c.style.filter = 'url(#shadow)';\n          // label\n          const t = svgEl('text', {x:n.x, y:n.y+6, 'text-anchor':'middle', 'font-size':14, 'font-family': 'inherit', fill:'#021016', 'font-weight':700});\n          t.textContent = String(n.val);\n\n          g.appendChild(shadow);\n          g.appendChild(c);\n          g.appendChild(t);\n          svg.appendChild(g);\n\n          // store\n          elementsMap.set(n.id, {group:g, circle:c, label:t, node:n});\n\n          // click to delete quickly\n          g.addEventListener('click', (ev)=>{\n            ev.stopPropagation();\n            // delete node on click\n            tree.remove(n.val);\n            lastOpEl.textContent = 'Deleted ' + n.val;\n            cancelAnimation();\n            render();\n          });\n\n          drawNodes(n.left);\n          drawNodes(n.right);\n        }\n        drawNodes(tree.root);\n\n        updateStats();\n      }\n\n      function updateStats(){\n        nodeCountEl.textContent = String(tree.count());\n        treeHeightEl.textContent = String(tree.height());\n      }\n\n      // Traversals with animation\n      function animateTraversal(nodes, label){\n        cancelAnimation();\n        lastOpEl.textContent = label;\n        const speed = Number(speedSlider.value);\n        resultEl.textContent = '';\n        let i = 0;\n        currentAnim = setInterval(()=>{\n          // clear previous highlights\n          elementsMap.forEach((el, id)=>{\n            el.circle.setAttribute('fill','#0ea5a4');\n            el.circle.setAttribute('r', nodeRadius);\n          });\n          if(i >= nodes.length){\n            clearInterval(currentAnim);\n            currentAnim = null;\n            lastOpEl.textContent = 'Traversal complete';\n            return;\n          }\n          const n = nodes[i];\n          const el = elementsMap.get(n.id);\n          if(el){\n            el.circle.setAttribute('fill','#f59e0b');\n            el.circle.setAttribute('r', nodeRadius+2);\n          }\n          // append to result text\n          const arr = nodes.slice(0,i+1).map(x=>x.val);\n          resultEl.textContent = arr.join(', ');\n          i++;\n        }, speed);\n      }\n\n      function cancelAnimation(){\n        if(currentAnim){ clearInterval(currentAnim); currentAnim = null; }\n        // clear highlights\n        elementsMap.forEach((el, id)=>{\n          el.circle.setAttribute('fill','#0ea5a4');\n          el.circle.setAttribute('r', nodeRadius);\n        });\n      }\n\n      // Search with path highlight (non-animated)\n      function highlightSearch(val){\n        cancelAnimation();\n        const path = [];\n        let cur = tree.root;\n        while(cur){\n          path.push(cur);\n          if(val === cur.val) break;\n          cur = val < cur.val ? cur.left : cur.right;\n        }\n        // highlight path progressively\n        let i = 0;\n        const speed = Number(speedSlider.value);\n        currentAnim = setInterval(()=>{\n          elementsMap.forEach((el)=>{ el.circle.setAttribute('fill','#0ea5a4'); el.circle.setAttribute('r', nodeRadius); });\n          if(i >= path.length){\n            clearInterval(currentAnim); currentAnim = null;\n            const found = path.length && path[path.length-1].val === val;\n            lastOpEl.textContent = found ? 'Found ' + val : 'Not found';\n            return;\n          }\n          const n = path[i];\n          const el = elementsMap.get(n.id);\n          if(el){\n            el.circle.setAttribute('fill', i === path.length-1 && n.val===val ? '#10b981' : '#f59e0b');\n            el.circle.setAttribute('r', nodeRadius + (i===path.length-1 && n.val===val ? 4 : 2));\n          }\n          i++;\n        }, speed);\n      }\n\n      // Events\n      insertBtn.addEventListener('click', ()=>{\n        const v = Number(valueInput.value);\n        if(Number.isNaN(v)){ alert('Enter an integer to insert.'); return; }\n        const node = tree.insert(v);\n        if(node === null){\n          lastOpEl.textContent = 'Value exists';\n          return;\n        }\n        lastOpEl.textContent = 'Inserted ' + v;\n        cancelAnimation();\n        render();\n      });\n      deleteBtn.addEventListener('click', ()=>{\n        const v = Number(valueInput.value);\n        if(Number.isNaN(v)){ alert('Enter an integer to delete.'); return; }\n        const ok = tree.remove(v);\n        lastOpEl.textContent = ok ? 'Deleted ' + v : 'Not found';\n        cancelAnimation();\n        render();\n      });\n      clearBtn.addEventListener('click', ()=>{\n        tree.clear();\n        lastOpEl.textContent = 'Cleared tree';\n        cancelAnimation();\n        render();\n      });\n      randomBtn.addEventListener('click', ()=>{\n        tree.clear();\n        const count = Math.max(1, Math.min(25, Number(randomCount.value) || 8));\n        const used = new Set();\n        while(used.size < count){\n          used.add(Math.floor(Math.random()*99)+1);\n        }\n        [...used].forEach(v=>tree.insert(v));\n        lastOpEl.textContent = 'Random tree (' + count + ' nodes)';\n        cancelAnimation();\n        render();\n      });\n      inorderBtn.addEventListener('click', ()=>{\n        const nodes = tree.inorder();\n        animateTraversal(nodes, 'Inorder');\n      });\n      preorderBtn.addEventListener('click', ()=>{\n        const nodes = tree.preorder();\n        animateTraversal(nodes, 'Preorder');\n      });\n      postorderBtn.addEventListener('click', ()=>{\n        const nodes = tree.postorder();\n        animateTraversal(nodes, 'Postorder');\n      });\n      bfsBtn.addEventListener('click', ()=>{\n        const nodes = tree.levelOrder();\n        animateTraversal(nodes, 'Level-order');\n      });\n      searchBtn.addEventListener('click', ()=>{\n        const v = Number(searchInput.value);\n        if(Number.isNaN(v)){ alert('Enter an integer to search.'); return; }\n        highlightSearch(v);\n      });\n      clearHighlights.addEventListener('click', ()=>{\n        cancelAnimation();\n        resultEl.textContent = '—';\n        lastOpEl.textContent = 'Cleared highlights';\n      });\n\n      // click background to unfocus / clear\n      svg.addEventListener('click', (ev)=>{\n        // clear selection\n        cancelAnimation();\n      });\n\n      // Make background pannable (drag to pan)\n      let isPanning = false;\n      let panStart = null;\n      visualArea.addEventListener('mousedown', (ev)=>{\n        if(ev.target.closest('g')) return; // clicked a node\n        isPanning = true;\n        panStart = {x: ev.clientX, y: ev.clientY, vbX:viewBox.x, vbY:viewBox.y};\n        visualArea.style.cursor = 'grabbing';\n        ev.preventDefault();\n      });\n      window.addEventListener('mousemove', (ev)=>{\n        if(!isPanning) return;\n        const dx = (ev.clientX - panStart.x);\n        const dy = (ev.clientY - panStart.y);\n        // translate to viewBox units: assume viewBox width maps to element width\n        const rect = svg.getBoundingClientRect();\n        const scaleX = viewBox.w / rect.width;\n        const scaleY = viewBox.h / rect.height;\n        viewBox.x = panStart.vbX - dx*scaleX;\n        viewBox.y = panStart.vbY - dy*scaleY;\n        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);\n      });\n      window.addEventListener('mouseup', ()=>{\n        if(isPanning){ isPanning=false; visualArea.style.cursor='default'; }\n      });\n\n      // zoom with wheel\n      visualArea.addEventListener('wheel', (ev)=>{\n        ev.preventDefault();\n        const zoomFactor = ev.deltaY > 0 ? 1.08 : 0.92;\n        const rect = svg.getBoundingClientRect();\n        const mx = ev.clientX - rect.left;\n        const my = ev.clientY - rect.top;\n        const svgMouseX = viewBox.x + mx * (viewBox.w / rect.width);\n        const svgMouseY = viewBox.y + my * (viewBox.h / rect.height);\n        viewBox.w *= zoomFactor;\n        viewBox.h *= zoomFactor;\n        viewBox.x = svgMouseX - (mx * (viewBox.w / rect.width));\n        viewBox.y = svgMouseY - (my * (viewBox.h / rect.height));\n        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);\n      }, {passive:false});\n\n      // keyboard shortcuts\n      window.addEventListener('keydown', (ev)=>{\n        if(ev.key === 'Delete'){\n          const v = Number(valueInput.value);\n          if(!Number.isNaN(v)){\n            tree.remove(v); render();\n          }\n        }\n      });\n\n      // initial render\n      render();\n\n      // expose tree for debugging (dev console)\n      window.__bst = tree;\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}