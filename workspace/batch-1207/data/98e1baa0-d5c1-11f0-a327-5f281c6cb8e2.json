{
  "id": "98e1baa0-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:16:59.126Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Priority Queue (Binary Heap) Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #7dd3fc;\n      --muted: #94a3b8;\n      --card: #071026;\n      --good: #10b981;\n      --bad: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    body{\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      margin:0;\n      background: linear-gradient(180deg, #071025 0%, #091226 100%);\n      color:#e6eef7;\n      min-height:100vh;\n      padding:24px;\n      box-sizing:border-box;\n    }\n    h1{ margin:0 0 6px 0; font-size:20px; }\n    p.lead{ margin:4px 0 18px 0; color:var(--muted); font-size:13px; max-width:900px; }\n    .layout{ display:flex; gap:20px; align-items:flex-start; flex-wrap:wrap; }\n    .card{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:12px;\n      padding:14px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    .controls{ width:360px; min-width:260px; }\n    .visual{ flex:1; min-width:340px; max-width:1000px; }\n    label{ display:block; font-size:12px; color:var(--muted); margin-top:8px; }\n    input[type=\"text\"], input[type=\"number\"], select {\n      width:100%;\n      padding:8px 10px;\n      margin-top:6px;\n      background:var(--glass);\n      color:var(--accent);\n      border:1px solid rgba(125,211,252,0.06);\n      border-radius:8px;\n      font-size:14px;\n      box-sizing:border-box;\n    }\n    .row{ display:flex; gap:8px; margin-top:10px; align-items:center; }\n    button {\n      background: linear-gradient(180deg, rgba(125,211,252,0.12), rgba(125,211,252,0.06));\n      color:var(--accent);\n      border:1px solid rgba(125,211,252,0.09);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:500;\n    }\n    .muted{ color:var(--muted); font-size:13px; margin-top:8px; }\n    .status{ margin-top:12px; font-size:13px; color:var(--muted); display:flex; gap:12px; flex-wrap:wrap; }\n    .pill{\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.02);\n      padding:6px 10px;\n      border-radius:999px;\n      font-size:13px;\n      color:var(--accent);\n    }\n    .arrayView{\n      margin-top:12px;\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .item{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--accent);\n      padding:6px 10px;\n      border-radius:8px;\n      font-size:13px;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n    .heap-svg{\n      width:100%;\n      height:420px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      margin-top:12px;\n      border:1px solid rgba(255,255,255,0.02);\n      overflow:auto;\n    }\n    .explain{\n      font-size:13px;\n      color:var(--muted);\n      margin-top:10px;\n      line-height:1.45;\n    }\n    .legend{ margin-top:8px; font-size:13px; color:var(--muted); display:flex; gap:12px; flex-wrap:wrap; }\n    .legend .dot{ width:12px; height:12px; border-radius:99px; display:inline-block; margin-right:6px; }\n    .dot.node{ background:#0ea5e9; }\n    .dot.swap{ background:#fb923c; }\n    .infoBlock{ margin-top:10px; padding:10px; background:rgba(255,255,255,0.02); border-radius:8px; color:var(--muted); font-size:13px; }\n    small.note{ color:var(--muted); display:block; margin-top:8px; font-size:12px; }\n    footer{ margin-top:18px; color:var(--muted); font-size:13px; }\n    @media (max-width:920px){\n      .layout{ flex-direction:column; }\n      .controls{ width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <h1>Priority Queue (Binary Heap) — Interactive Demo</h1>\n  <p class=\"lead\">This demo implements a priority queue using a binary heap. You can insert items with numeric priorities, remove the top-priority item, and visualize the heap as an array and as a binary tree. Toggle between min-heap (lower priority values come out first) and max-heap.</p>\n\n  <div class=\"layout\">\n    <div class=\"card controls\">\n      <label>Heap Type\n        <select id=\"heapType\">\n          <option value=\"min\">Min-Heap (lowest priority first)</option>\n          <option value=\"max\">Max-Heap (highest priority first)</option>\n        </select>\n      </label>\n\n      <label>Value (string)\n        <input id=\"valInput\" type=\"text\" placeholder=\"example: task-A\" value=\"task-A\" />\n      </label>\n\n      <label>Priority (number)\n        <input id=\"prioInput\" type=\"number\" placeholder=\"priority (e.g. 5)\" value=\"5\" />\n      </label>\n\n      <div class=\"row\">\n        <button id=\"enqueueBtn\">Enqueue</button>\n        <button class=\"secondary\" id=\"dequeueBtn\">Dequeue</button>\n        <button class=\"secondary\" id=\"peekBtn\">Peek</button>\n      </div>\n\n      <div class=\"row\">\n        <button id=\"randomBtn\">Add 10 Random</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        <button id=\"bulkBtn\" class=\"secondary\">Add N Items (fast)</button>\n        <input id=\"bulkCount\" type=\"number\" value=\"10000\" style=\"width:110px; margin-left:auto;\" />\n      </div>\n\n      <div class=\"status\">\n        <div class=\"pill\" id=\"sizePill\">Size: 0</div>\n        <div class=\"pill\" id=\"topPill\">Top: —</div>\n        <div class=\"pill\" id=\"opsPill\">Ops: 0</div>\n      </div>\n\n      <div class=\"muted\">Array representation (index -> value:priority)</div>\n      <div class=\"arrayView card\" id=\"arrayContainer\" style=\"margin-top:8px;\"></div>\n\n      <div class=\"infoBlock\">\n        <strong>Notes</strong>\n        <div class=\"explain\">\n          - Enqueue inserts an item with the given priority.<br/>\n          - Dequeue removes and returns the highest-priority item (based on heap type).<br/>\n          - The underlying structure is a binary heap stored in an array; parents/children positions are shown in the visualization.\n        </div>\n      </div>\n\n      <small class=\"note\">Stable ordering is preserved for equal priorities (insertion order).</small>\n    </div>\n\n    <div class=\"card visual\">\n      <div style=\"display:flex; align-items:center; justify-content:space-between; gap:12px;\">\n        <div>\n          <strong>Heap Visualization</strong>\n          <div class=\"legend\">\n            <div><span class=\"dot node\"></span> Node</div>\n            <div><span class=\"dot swap\"></span> Recently swapped (brief highlight)</div>\n          </div>\n        </div>\n        <div style=\"text-align:right\" class=\"muted\">\n          <div id=\"timing\">Last op time: — ms</div>\n          <div id=\"lastAction\">Last: —</div>\n        </div>\n      </div>\n\n      <div id=\"svgWrap\" class=\"heap-svg\">\n        <svg id=\"heapSvg\" width=\"1200\" height=\"420\"></svg>\n      </div>\n\n      <div class=\"muted\" style=\"margin-top:8px;\">Console / trace</div>\n      <div id=\"trace\" class=\"card\" style=\"margin-top:8px; font-size:13px; min-height:46px; max-height:160px; overflow:auto;\"></div>\n\n      <footer>\n        Implementation: binary heap with stable ordering (uses insertion index to break ties). Try enqueueing many items and use \"Add N Items (fast)\" to benchmark.\n      </footer>\n    </div>\n  </div>\n\n  <script>\n    // PriorityQueue implemented with binary heap stored in an array.\n    // Each node { value, priority, idx } where idx is insertion index for stability.\n    class PriorityQueue {\n      constructor(type = 'min') {\n        this.heap = [];\n        this.type = type; // 'min' or 'max'\n        this._counter = 0;\n        this.opCount = 0;\n      }\n\n      setType(type) {\n        if (type !== 'min' && type !== 'max') throw new Error('type must be \"min\" or \"max\"');\n        this.type = type;\n      }\n\n      size() { return this.heap.length; }\n      isEmpty() { return this.size() === 0; }\n\n      _compare(a, b) {\n        // return true if a has higher priority than b (i.e., a should come before b)\n        if (a.priority !== b.priority) {\n          return this.type === 'min' ? a.priority < b.priority : a.priority > b.priority;\n        }\n        // tie-breaker: insertion index (lower idx = earlier insertion, so earlier is higher priority)\n        return a.idx < b.idx;\n      }\n\n      enqueue(value, priority) {\n        const node = { value, priority: Number(priority), idx: this._counter++ };\n        this.heap.push(node);\n        this._bubbleUp(this.heap.length - 1);\n        this.opCount++;\n        return node;\n      }\n\n      peek() {\n        return this.heap[0] || null;\n      }\n\n      dequeue() {\n        const n = this.heap.length;\n        if (n === 0) return null;\n        if (n === 1) {\n          this.opCount++;\n          return this.heap.pop();\n        }\n        const top = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this._sinkDown(0);\n        this.opCount++;\n        return top;\n      }\n\n      clear() {\n        this.heap = [];\n        this._counter = 0;\n        this.opCount++;\n      }\n\n      // faster bulk add without animation: push all and heapify in O(n)\n      bulkAdd(items) {\n        // items: array of {value, priority}\n        for (const it of items) {\n          this.heap.push({ value: it.value, priority: Number(it.priority), idx: this._counter++ });\n        }\n        // heapify: from last parent down to 0\n        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {\n          this._sinkDown(i, false);\n        }\n        this.opCount += items.length;\n      }\n\n      _bubbleUp(idx) {\n        const heap = this.heap;\n        let current = idx;\n        while (current > 0) {\n          const parent = Math.floor((current - 1) / 2);\n          if (this._compare(heap[current], heap[parent])) {\n            this._swap(current, parent);\n            current = parent;\n          } else break;\n        }\n      }\n\n      _sinkDown(idx, allowSwapTrace = true) {\n        const heap = this.heap;\n        const n = heap.length;\n        let current = idx;\n        while (true) {\n          const left = current * 2 + 1;\n          const right = current * 2 + 2;\n          let candidate = current;\n\n          if (left < n && this._compare(heap[left], heap[candidate])) candidate = left;\n          if (right < n && this._compare(heap[right], heap[candidate])) candidate = right;\n          if (candidate !== current) {\n            this._swap(current, candidate, allowSwapTrace);\n            current = candidate;\n          } else break;\n        }\n      }\n\n      _swap(i, j, allowSwapTrace=true) {\n        const h = this.heap;\n        const tmp = h[i];\n        h[i] = h[j];\n        h[j] = tmp;\n        // optional: could log swaps or visualize\n      }\n\n      toArray() {\n        // return shallow copy for display\n        return this.heap.map((n, i) => ({ i, value: n.value, priority: n.priority, idx: n.idx }));\n      }\n    }\n\n    // ---------- UI & Visualization ----------\n    const pq = new PriorityQueue('min');\n\n    // UI elements\n    const valInput = document.getElementById('valInput');\n    const prioInput = document.getElementById('prioInput');\n    const enqueueBtn = document.getElementById('enqueueBtn');\n    const dequeueBtn = document.getElementById('dequeueBtn');\n    const peekBtn = document.getElementById('peekBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const arrayContainer = document.getElementById('arrayContainer');\n    const sizePill = document.getElementById('sizePill');\n    const topPill = document.getElementById('topPill');\n    const opsPill = document.getElementById('opsPill');\n    const heapType = document.getElementById('heapType');\n    const heapSvg = document.getElementById('heapSvg');\n    const trace = document.getElementById('trace');\n    const timing = document.getElementById('timing');\n    const lastAction = document.getElementById('lastAction');\n    const bulkBtn = document.getElementById('bulkBtn');\n    const bulkCount = document.getElementById('bulkCount');\n\n    function logTrace(msg, style='color:#9fbfe6') {\n      const el = document.createElement('div');\n      el.style.padding = '6px 8px';\n      el.style.borderBottom = '1px solid rgba(255,255,255,0.02)';\n      el.style.fontSize = '13px';\n      el.innerHTML = `<span style=\"${style}\">${msg}</span>`;\n      trace.prepend(el);\n    }\n\n    function renderAll(highlightSwap = null) {\n      // update pills and array view\n      const arr = pq.toArray();\n      sizePill.textContent = 'Size: ' + pq.size();\n      opsPill.textContent = 'Ops: ' + pq.opCount;\n      if (pq.peek()) topPill.textContent = `Top: ${pq.peek().value}:${pq.peek().priority}`;\n      else topPill.textContent = 'Top: —';\n\n      // array view\n      arrayContainer.innerHTML = '';\n      if (arr.length === 0) {\n        arrayContainer.innerHTML = '<div class=\"muted\" style=\"padding:10px\">empty</div>';\n      } else {\n        for (const node of arr) {\n          const div = document.createElement('div');\n          div.className = 'item';\n          div.textContent = `${node.i} → ${node.value}:${node.priority}`;\n          arrayContainer.appendChild(div);\n        }\n      }\n\n      // svg visualization\n      renderHeapSvg(arr, highlightSwap);\n    }\n\n    function renderHeapSvg(nodes, highlightSwap) {\n      const svg = heapSvg;\n      // clear\n      while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n      const width = Math.max(600, svg.clientWidth || 800, 1200);\n      const height = svg.clientHeight || 420;\n      svg.setAttribute('width', width);\n      svg.setAttribute('height', height);\n\n      if (nodes.length === 0) return;\n\n      // compute positions per level\n      const positions = [];\n      const levels = Math.floor(Math.log2(nodes.length)) + 1;\n      const levelHeight = Math.min(90, Math.max(60, Math.floor(height / (levels + 1))));\n      for (let i = 0; i < nodes.length; i++) {\n        const level = Math.floor(Math.log2(i + 1));\n        const levelStart = Math.pow(2, level) - 1;\n        const posInLevel = i - levelStart;\n        const itemsInLevel = Math.pow(2, level);\n        const margin = 24;\n        const usableWidth = width - margin * 2;\n        const spacing = usableWidth / itemsInLevel;\n        const x = margin + posInLevel * spacing + spacing / 2;\n        const y = 18 + level * levelHeight;\n        positions[i] = { x, y };\n      }\n\n      // draw lines\n      for (let i = 0; i < nodes.length; i++) {\n        const left = i * 2 + 1;\n        const right = i * 2 + 2;\n        const p = positions[i];\n        if (left < nodes.length) {\n          const c = positions[left];\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y+12);\n          line.setAttribute('x2', c.x); line.setAttribute('y2', c.y-12);\n          line.setAttribute('stroke', 'rgba(255,255,255,0.04)');\n          line.setAttribute('stroke-width', '1.2');\n          svg.appendChild(line);\n        }\n        if (right < nodes.length) {\n          const c = positions[right];\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y+12);\n          line.setAttribute('x2', c.x); line.setAttribute('y2', c.y-12);\n          line.setAttribute('stroke', 'rgba(255,255,255,0.04)');\n          line.setAttribute('stroke-width', '1.2');\n          svg.appendChild(line);\n        }\n      }\n\n      // draw nodes\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        const pos = positions[i];\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n\n        // circle\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('cx', pos.x);\n        circle.setAttribute('cy', pos.y);\n        circle.setAttribute('r', 20);\n        circle.setAttribute('fill', (highlightSwap && (highlightSwap[0] === i || highlightSwap[1] === i)) ? '#fb923c' : '#0ea5e9');\n        circle.setAttribute('opacity', '0.95');\n        g.appendChild(circle);\n\n        // text: value\n        const text1 = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text1.setAttribute('x', pos.x);\n        text1.setAttribute('y', pos.y - 2);\n        text1.setAttribute('text-anchor', 'middle');\n        text1.setAttribute('font-size', '11px');\n        text1.setAttribute('fill', '#001219');\n        text1.setAttribute('font-weight', '700');\n        text1.textContent = String(node.value).slice(0,8);\n        g.appendChild(text1);\n\n        // text: priority\n        const text2 = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text2.setAttribute('x', pos.x);\n        text2.setAttribute('y', pos.y + 14);\n        text2.setAttribute('text-anchor', 'middle');\n        text2.setAttribute('font-size', '11px');\n        text2.setAttribute('fill', '#001219');\n        text2.textContent = node.priority;\n        g.appendChild(text2);\n\n        // index small\n        const text3 = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text3.setAttribute('x', pos.x + 28);\n        text3.setAttribute('y', pos.y - 10);\n        text3.setAttribute('text-anchor', 'start');\n        text3.setAttribute('font-size', '10px');\n        text3.setAttribute('fill', 'rgba(255,255,255,0.35)');\n        text3.textContent = `${node.i}`;\n        g.appendChild(text3);\n\n        svg.appendChild(g);\n      }\n    }\n\n    // Hook up events\n    enqueueBtn.addEventListener('click', () => {\n      const v = valInput.value.trim();\n      const p = prioInput.value;\n      if (v === '' || p === '') {\n        alert('Please provide value and priority.');\n        return;\n      }\n      const t0 = performance.now();\n      const node = pq.enqueue(v, Number(p));\n      const t1 = performance.now();\n      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;\n      lastAction.textContent = `Last: enqueue ${node.value}:${node.priority}`;\n      logTrace(`Enqueued ${node.value}:${node.priority}`);\n      // animate single swap highlight not available here; just re-render\n      renderAll();\n    });\n\n    dequeueBtn.addEventListener('click', () => {\n      if (pq.isEmpty()) {\n        alert('Queue is empty.');\n        return;\n      }\n      const t0 = performance.now();\n      const node = pq.dequeue();\n      const t1 = performance.now();\n      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;\n      lastAction.textContent = `Last: dequeue ${node.value}:${node.priority}`;\n      logTrace(`Dequeued ${node.value}:${node.priority}`, 'color:#9fe6c0');\n      renderAll();\n    });\n\n    peekBtn.addEventListener('click', () => {\n      const node = pq.peek();\n      if (!node) {\n        alert('empty');\n        return;\n      }\n      lastAction.textContent = `Last: peek ${node.value}:${node.priority}`;\n      logTrace(`Peek ${node.value}:${node.priority}`, 'color:#ffd580');\n    });\n\n    heapType.addEventListener('change', (e) => {\n      pq.setType(e.target.value);\n      logTrace(`Heap type set to ${e.target.value}`, 'color:#c6baff');\n      renderAll();\n    });\n\n    randomBtn.addEventListener('click', () => {\n      // add 10 random items\n      const examples = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N'];\n      for (let i = 0; i < 10; i++) {\n        const v = examples[Math.floor(Math.random()*examples.length)] + '-' + Math.floor(Math.random()*999);\n        const p = Math.floor(Math.random()*20);\n        pq.enqueue(v, p);\n      }\n      lastAction.textContent = `Last: added 10 random`;\n      logTrace('Added 10 random items');\n      renderAll();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      pq.clear();\n      logTrace('Cleared heap', 'color:#ef9a9a');\n      lastAction.textContent = `Last: clear`;\n      renderAll();\n    });\n\n    bulkBtn.addEventListener('click', () => {\n      let n = Number(bulkCount.value) || 1000;\n      if (n <= 0) return;\n      const items = [];\n      for (let i = 0; i < n; i++) {\n        items.push({ value: 'v' + (Math.floor(Math.random()*100000)), priority: Math.floor(Math.random()*1000) });\n      }\n      const t0 = performance.now();\n      pq.bulkAdd(items);\n      const t1 = performance.now();\n      timing.textContent = `Last op time: ${(t1 - t0).toFixed(3)} ms`;\n      lastAction.textContent = `Last: bulkAdd ${n} items`;\n      logTrace(`Bulk added ${n} items in ${(t1 - t0).toFixed(3)} ms`, 'color:#b8f3c6');\n      renderAll();\n    });\n\n    // initial render\n    renderAll();\n\n    // small demonstration: visualize a few steps with brief highlight when enqueueing to show bubble-up swaps.\n    // We'll override enqueue to animate swaps for single insert (for teaching).\n    // Keep internal original methods\n    (function addAnimatedEnqueue() {\n      const originalEnqueue = pq.enqueue.bind(pq);\n      // We'll implement an alternate function that performs step-by-step bubble up and highlights swaps.\n      // But for simplicity, we perform original then highlight node path by comparing array copies.\n      enqueueBtn.addEventListener('click', () => {\n        // no special sequence needed; previous handler already called enqueue\n        // We will not duplicate; instead we can create a small animation by briefly highlighting last inserted and its parents.\n        // Find last inserted index = heap.length-1, then show brief flashes moving up\n        const arr = pq.toArray();\n        const lastIndex = arr.length - 1;\n        if (lastIndex < 0) return;\n        // compute path up to root\n        const path = [];\n        let cur = lastIndex;\n        while (cur > 0) {\n          const parent = Math.floor((cur - 1) / 2);\n          path.push([parent, cur]);\n          cur = parent;\n        }\n        // animate highlights sequentially\n        let step = 0;\n        const doStep = () => {\n          if (step >= path.length) {\n            // final render\n            renderAll();\n            return;\n          }\n          const pair = path[step];\n          renderAll(pair);\n          step++;\n          setTimeout(doStep, 160);\n        };\n        doStep();\n      }, { once: false });\n    })();\n\n    // For first-time help\n    logTrace('Priority Queue ready. Use the controls to enqueue/dequeue and visualize the heap.', 'color:#bcdfff');\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}