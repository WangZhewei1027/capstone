{
  "id": "d79db212-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:14.999Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Huffman Coding Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    max-width: 900px;\n    margin: 2rem auto;\n    padding: 1rem;\n    background: #f9f9f9;\n  }\n  h1 {\n    text-align: center;\n    color: #2c3e50;\n  }\n  textarea {\n    width: 100%;\n    height: 120px;\n    font-family: monospace;\n    font-size: 1.1rem;\n    padding: 0.5rem;\n    border-radius: 6px;\n    border: 1px solid #ccc;\n  }\n  button {\n    margin-top: 1rem;\n    padding: 0.6rem 1.2rem;\n    font-size: 1.1rem;\n    cursor: pointer;\n    background: #2980b9;\n    color: white;\n    border: none;\n    border-radius: 5px;\n  }\n  button:disabled {\n    background: #7f8c8d;\n    cursor: not-allowed;\n  }\n  .results {\n    margin-top: 2rem;\n    background: white;\n    border-radius: 8px;\n    padding: 1rem;\n    box-shadow: 0 0 8px rgba(0,0,0,0.1);\n  }\n  .freq-table, .code-table {\n    margin-top: 1rem;\n    border-collapse: collapse;\n    width: 100%;\n  }\n  .freq-table th, .freq-table td,\n  .code-table th, .code-table td {\n    border: 1px solid #ddd;\n    padding: 0.4rem 0.6rem;\n    text-align: center;\n  }\n  .freq-table th, .code-table th {\n    background: #2980b9;\n    color: white;\n  }\n  #tree-svg {\n    margin-top: 1rem;\n    display: block;\n    width: 100%;\n    height: 360px;\n    overflow-x: auto;\n    background: #fff;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n  }\n  .legend {\n    margin-top: 1rem;\n    font-size: 0.9rem;\n    color: #666;\n  }\n</style>\n</head>\n<body>\n\n<h1>Huffman Coding Interactive Demonstration</h1>\n<label for=\"inputText\">Enter text to encode with Huffman coding:</label>\n<textarea id=\"inputText\" placeholder=\"Type or paste text here...\"></textarea>\n<button id=\"encodeBtn\">Build Huffman Tree & Encode</button>\n\n<div class=\"results\" id=\"results\" aria-live=\"polite\" aria-atomic=\"true\" style=\"display:none;\">\n  <h2>Frequency Table</h2>\n  <table class=\"freq-table\" id=\"freqTable\" role=\"table\" aria-describedby=\"freq-desc\">\n    <thead>\n      <tr><th>Character</th><th>Frequency</th></tr>\n    </thead>\n    <tbody></tbody>\n  </table>\n  <div id=\"freq-desc\" hidden>Table shows each character in the input text with its frequency count.</div>\n\n  <h2>Huffman Codes</h2>\n  <table class=\"code-table\" id=\"codeTable\" role=\"table\" aria-describedby=\"code-desc\">\n    <thead>\n      <tr><th>Character</th><th>Code (bits)</th></tr>\n    </thead>\n    <tbody></tbody>\n  </table>\n  <div id=\"code-desc\" hidden>Table shows Huffman binary code for each character.</div>\n\n  <h2>Encoded Binary String</h2>\n  <textarea id=\"encodedOutput\" readonly rows=\"4\" style=\"font-family: monospace; font-size: 1rem;\"></textarea>\n  \n  <h2>Huffman Tree Visualization</h2>\n  <svg id=\"tree-svg\" role=\"img\" aria-label=\"Visual representation of Huffman tree\"></svg>\n\n  <div class=\"legend\">\n    <strong>Legend:</strong> Circles represent nodes. Leaves show characters and frequency. Internal nodes show combined frequencies. Left branches represent '0', right branches '1'.\n  </div>\n</div>\n\n<script>\n(() => {\n  const encodeBtn = document.getElementById(\"encodeBtn\");\n  const inputText = document.getElementById(\"inputText\");\n  const results = document.getElementById(\"results\");\n  const freqTableBody = document.querySelector(\"#freqTable tbody\");\n  const codeTableBody = document.querySelector(\"#codeTable tbody\");\n  const encodedOutput = document.getElementById(\"encodedOutput\");\n  const treeSvg = document.getElementById(\"tree-svg\");\n\n  // Priority Queue class for Huffman\n  class PriorityQueue {\n    constructor() {\n      this.items = [];\n    }\n    enqueue(element, priority) {\n      const node = {element, priority};\n      if (this.isEmpty()) {\n        this.items.push(node);\n      } else {\n        let added = false;\n        for(let i=0; i < this.items.length; i++) {\n          if(priority < this.items[i].priority) {\n            this.items.splice(i, 0, node);\n            added = true;\n            break;\n          }\n        }\n        if(!added) this.items.push(node);\n      }\n    }\n    dequeue() {\n      return this.items.shift();\n    }\n    size() {\n      return this.items.length;\n    }\n    isEmpty() {\n      return this.items.length === 0;\n    }\n  }\n\n  // Build frequency map from input string\n  function buildFrequencyMap(str) {\n    const freq = {};\n    for (const ch of str) {\n      freq[ch] = (freq[ch] || 0) + 1;\n    }\n    return freq;\n  }\n\n  // Build Huffman tree, returning root node\n  function buildHuffmanTree(freqMap) {\n    const pq = new PriorityQueue();\n    // Each node = {char, freq, left, right}\n    for (const ch in freqMap) {\n      pq.enqueue({char: ch, freq: freqMap[ch], left: null, right: null}, freqMap[ch]);\n    }\n\n    while (pq.size() > 1) {\n      const leftNode = pq.dequeue().element;\n      const rightNode = pq.dequeue().element;\n      const mergedFreq = leftNode.freq + rightNode.freq;\n      const mergedNode = {char: null, freq: mergedFreq, left: leftNode, right: rightNode};\n      pq.enqueue(mergedNode, mergedFreq);\n    }\n\n    return pq.isEmpty() ? null : pq.dequeue().element;\n  }\n\n  // Recursively generate codes for each character\n  function generateCodes(node, prefix = \"\", codes = {}) {\n    if (!node) return codes;\n    if (node.char !== null) {\n      codes[node.char] = prefix || \"0\"; // In case single character, assign '0'\n      return codes;\n    }\n    generateCodes(node.left, prefix + \"0\", codes);\n    generateCodes(node.right, prefix + \"1\", codes);\n    return codes;\n  }\n\n  // Encode input string using codes\n  function encodeString(str, codes) {\n    let encoded = \"\";\n    for (const ch of str) {\n      encoded += codes[ch];\n    }\n    return encoded;\n  }\n\n  // Format char for display (show special whitespace explicitly)\n  function formatChar(ch) {\n    switch (ch) {\n      case \" \": return \"‚ê£ (space)\";\n      case \"\\n\": return \"\\\\n (newline)\";\n      case \"\\t\": return \"\\\\t (tab)\";\n      default:\n        if (ch.length === 1 && (ch < ' ' || ch === '\\x7f')) {\n          // Non-printable control chars\n          return `U+${ch.charCodeAt(0).toString(16).padStart(4,'0')}`;\n        }\n        return ch;\n    }\n  }\n\n  // Clear previous outputs\n  function clearOutputs() {\n    freqTableBody.innerHTML = \"\";\n    codeTableBody.innerHTML = \"\";\n    encodedOutput.value = \"\";\n    treeSvg.innerHTML = \"\";\n  }\n\n  // Create frequency table rows\n  function fillFrequencyTable(freqMap) {\n    const entries = Object.entries(freqMap).sort((a,b) => b[1] - a[1]);\n    freqTableBody.innerHTML = \"\";\n    for (const [ch, freq] of entries) {\n      const tr = document.createElement(\"tr\");\n      const tdChar = document.createElement(\"td\");\n      tdChar.textContent = formatChar(ch);\n      tdChar.setAttribute(\"scope\", \"row\");\n      const tdFreq = document.createElement(\"td\");\n      tdFreq.textContent = freq;\n      tr.appendChild(tdChar);\n      tr.appendChild(tdFreq);\n      freqTableBody.appendChild(tr);\n    }\n  }\n\n  // Create code table rows\n  function fillCodeTable(codes) {\n    const entries = Object.entries(codes).sort((a,b) => a[0].localeCompare(b[0]));\n    codeTableBody.innerHTML = \"\";\n    for (const [ch, code] of entries) {\n      const tr = document.createElement(\"tr\");\n      const tdChar = document.createElement(\"td\");\n      tdChar.textContent = formatChar(ch);\n      tdChar.setAttribute(\"scope\", \"row\");\n      const tdCode = document.createElement(\"td\");\n      tdCode.textContent = code;\n      tr.appendChild(tdChar);\n      tr.appendChild(tdCode);\n      codeTableBody.appendChild(tr);\n    }\n  }\n\n  // Draw Huffman tree as SVG\n  // We'll do a horizontal tree: root left to right\n  function drawHuffmanTree(root) {\n    if (!root) return;\n    // Compute layout:\n\n    // Assign x,y positions by inorder traversal coordinates\n    let maxDepth = 0;\n    function depthRecursive(node, depth = 0) {\n      if (!node) return depth-1;\n      maxDepth = Math.max(maxDepth, depth);\n      return Math.max(depthRecursive(node.left, depth+1), depthRecursive(node.right, depth+1));\n    }\n    depthRecursive(root);\n\n    // Compute number of leaves to determine horizontal spacing\n    let leafCount = 0;\n    function countLeaves(n) {\n      if (!n) return 0;\n      if (!n.left && !n.right) return 1;\n      return countLeaves(n.left) + countLeaves(n.right);\n    }\n    leafCount = countLeaves(root);\n\n    // We'll assign x coordinate by horizontal position in leaves enumeration\n    // y coordinate by depth\n    let currentX = 0;\n    const nodePos = new Map();\n\n    function assignPos(node, depth) {\n      if (!node) return;\n      if (!node.left && !node.right) {\n        // Leaf\n        nodePos.set(node, {x: currentX, y: depth});\n        currentX++;\n      } else {\n        if (node.left) assignPos(node.left, depth+1);\n        if (node.right) assignPos(node.right, depth+1);\n        // X is average of children\n        const leftPos = nodePos.get(node.left);\n        const rightPos = nodePos.get(node.right);\n        const x = (leftPos.x + rightPos.x) / 2;\n        nodePos.set(node, {x, y: depth});\n      }\n    }\n    assignPos(root, 0);\n\n    // Define SVG drawing parameters\n    const nodeRadius = 20;\n    const horizontalGap = 70;\n    const verticalGap = 100;\n    const width = Math.max(leafCount * horizontalGap + 100, 600);\n    const height = (maxDepth + 1) * verticalGap + 50;\n\n    // Clear SVG and set dimensions\n    treeSvg.setAttribute(\"width\", width);\n    treeSvg.setAttribute(\"height\", height);\n    treeSvg.innerHTML = \"\";\n\n    // Draw edges (lines)\n    for (const [node, pos] of nodePos.entries()) {\n      if (node.left) {\n        const childPos = nodePos.get(node.left);\n        drawLine(pos, childPos, \"0\");\n      }\n      if (node.right) {\n        const childPos = nodePos.get(node.right);\n        drawLine(pos, childPos, \"1\");\n      }\n    }\n\n    // Draw nodes after lines so they appear on top\n    for (const [node, pos] of nodePos.entries()) {\n      drawNode(node, pos);\n    }\n\n    function drawLine(parentPos, childPos, label) {\n      const x1 = parentPos.x * horizontalGap + 50;\n      const y1 = parentPos.y * verticalGap + 40 + nodeRadius;\n      const x2 = childPos.x * horizontalGap + 50;\n      const y2 = childPos.y * verticalGap + 40 - nodeRadius;\n\n      // Draw line\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      line.setAttribute(\"x1\", x1.toString());\n      line.setAttribute(\"y1\", y1.toString());\n      line.setAttribute(\"x2\", x2.toString());\n      line.setAttribute(\"y2\", y2.toString());\n      line.setAttribute(\"stroke\", \"#34495e\");\n      line.setAttribute(\"stroke-width\", \"2\");\n      treeSvg.appendChild(line);\n\n      // Label '0' or '1' on line midpoint\n      const midX = (x1 + x2) / 2;\n      const midY = (y1 + y2) / 2;\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", midX.toString());\n      text.setAttribute(\"y\", (midY - 5).toString());\n      text.setAttribute(\"fill\", \"#c0392b\");\n      text.setAttribute(\"font-size\", \"14\");\n      text.setAttribute(\"font-weight\", \"bold\");\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.textContent = label;\n      treeSvg.appendChild(text);\n    }\n\n    function drawNode(node, pos) {\n      const cx = pos.x * horizontalGap + 50;\n      const cy = pos.y * verticalGap + 40;\n\n      // Circle\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", cx.toString());\n      circle.setAttribute(\"cy\", cy.toString());\n      circle.setAttribute(\"r\", nodeRadius.toString());\n      circle.setAttribute(\"fill\", node.char === null ? \"#3498db\" : \"#e67e22\");\n      circle.setAttribute(\"stroke\", \"#2c3e50\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      treeSvg.appendChild(circle);\n\n      // Text inside node: freq (and char for leaves)\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", cx.toString());\n      text.setAttribute(\"y\", (cy + 6).toString()); // vertical-align middle approx\n      text.setAttribute(\"fill\", \"white\");\n      text.setAttribute(\"font-weight\", \"bold\");\n      text.setAttribute(\"font-size\", \"14\");\n      text.setAttribute(\"text-anchor\", \"middle\");\n      if (node.char === null) {\n        text.textContent = node.freq;\n      } else {\n        // Show char on top line, freq below\n        // So create two tspans\n\n        const tspChar = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        tspChar.setAttribute(\"x\", cx.toString());\n        tspChar.setAttribute(\"dy\", \"-0.4em\");\n        tspChar.textContent = formatChar(node.char);\n\n        const tspFreq = document.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        tspFreq.setAttribute(\"x\", cx.toString());\n        tspFreq.setAttribute(\"dy\", \"1.2em\");\n        tspFreq.textContent = node.freq;\n\n        text.appendChild(tspChar);\n        text.appendChild(tspFreq);\n      }\n      treeSvg.appendChild(text);\n    }\n  }\n\n  // Event handler for encode button\n  encodeBtn.addEventListener(\"click\", () => {\n    clearOutputs();\n    const text = inputText.value;\n    if (!text) {\n      alert(\"Please enter some text to encode.\");\n      return;\n    }\n\n    const freqMap = buildFrequencyMap(text);\n    fillFrequencyTable(freqMap);\n    const treeRoot = buildHuffmanTree(freqMap);\n    if(!treeRoot) {\n      alert(\"Could not build Huffman tree (empty input).\");\n      return;\n    }\n    const codes = generateCodes(treeRoot);\n    fillCodeTable(codes);\n    const encodedStr = encodeString(text, codes);\n    encodedOutput.value = encodedStr;\n    drawHuffmanTree(treeRoot);\n    results.style.display = \"block\";\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}