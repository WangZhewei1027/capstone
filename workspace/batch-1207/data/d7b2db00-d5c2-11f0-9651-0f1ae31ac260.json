{
  "id": "d7b2db00-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:55.248Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f4f8;\n  }\n  h1 {\n    text-align:center;\n    color: #333;\n  }\n  #controls {\n    margin-bottom: 20px;\n    display: flex;\n    justify-content:center;\n    gap: 10px;\n    flex-wrap: wrap;\n  }\n  input[type=number] {\n    width: 100px;\n    padding: 6px 8px;\n    font-size: 16px;\n  }\n  button {\n    padding: 7px 15px;\n    font-size: 16px;\n    cursor: pointer;\n    border: none;\n    background-color: #1e88e5;\n    color: white;\n    border-radius: 4px;\n  }\n  button:hover:not(:disabled) {\n    background-color: #1565c0;\n  }\n  button:disabled {\n    background-color: #a0a0a0;\n    cursor: default;\n  }\n  #log {\n    max-width: 600px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 8px;\n    padding: 15px;\n    box-shadow: 0 3px 10px rgb(0 0 0 / 0.2);\n    height: 150px;\n    overflow-y: auto;\n    font-family: monospace;\n    font-size: 14px;\n    color: #444;\n  }\n  #tree-container {\n    margin-top: 30px;\n    text-align: center;\n  }\n  svg {\n    max-width: 90%;\n    height: 320px;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 3px 10px rgb(0 0 0 / 0.12);\n  }\n  .node {\n    cursor: pointer;\n    transition: transform 0.3s ease;\n  }\n  .node circle {\n    fill: #42a5f5;\n    stroke: #1e88e5;\n    stroke-width: 3px;\n    transition: fill 0.3s ease;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    user-select: none;\n    pointer-events: none;\n  }\n  .node.highlight circle {\n    fill: #ff7043;\n  }\n  line.edge {\n    stroke: #90caf9;\n    stroke-width: 2px;\n  }\n</style>\n</head>\n<body>\n\n<h1>Binary Search Tree (BST) Interactive Demo</h1>\n\n<div id=\"controls\">\n  <input type=\"number\" id=\"inputValue\" placeholder=\"Value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"searchBtn\">Search</button>\n  <button id=\"deleteBtn\">Delete</button>\n  <button id=\"clearBtn\" title=\"Clear the entire tree\">Clear Tree</button>\n</div>\n\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"false\"></div>\n\n<div id=\"tree-container\">\n  <svg id=\"bst-svg\" role=\"img\" aria-label=\"Binary Search Tree Visualization\"></svg>\n</div>\n\n<script>\n(() => {\n  // BST Node class\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.x = 0;\n      this.y = 0;\n    }\n  }\n\n  // BST class\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      const newNode = new Node(value);\n      if (this.root === null) {\n        this.root = newNode;\n        return true;\n      } else {\n        return this._insertNode(this.root, newNode);\n      }\n    }\n\n    _insertNode(node, newNode) {\n      if (newNode.value === node.value) {\n        return false; // no duplicates allowed\n      }\n      if (newNode.value < node.value) {\n        if (node.left === null) {\n          node.left = newNode;\n          return true;\n        } else {\n          return this._insertNode(node.left, newNode);\n        }\n      } else {\n        if (node.right === null) {\n          node.right = newNode;\n          return true;\n        } else {\n          return this._insertNode(node.right, newNode);\n        }\n      }\n    }\n\n    search(value) {\n      return this._searchNode(this.root, value);\n    }\n\n    _searchNode(node, value) {\n      if (node === null) return null;\n      if (value === node.value) return node;\n      if (value < node.value) return this._searchNode(node.left, value);\n      else return this._searchNode(node.right, value);\n    }\n\n    delete(value) {\n      let deleted = false;\n      this.root = this._deleteNode(this.root, value, (d) => { deleted = d; });\n      return deleted;\n    }\n\n    _deleteNode(node, value, deletedFlag) {\n      if (node === null) return null;\n      if (value < node.value) {\n        node.left = this._deleteNode(node.left, value, deletedFlag);\n        return node;\n      } else if (value > node.value) {\n        node.right = this._deleteNode(node.right, value, deletedFlag);\n        return node;\n      } else {\n        deletedFlag(true);\n        // node with only one child or no child\n        if (node.left === null) return node.right;\n        else if (node.right === null) return node.left;\n\n        // node with two children: get inorder successor (smallest in the right subtree)\n        let minNode = this._minValueNode(node.right);\n        node.value = minNode.value;\n\n        // Delete the inorder successor\n        node.right = this._deleteNode(node.right, minNode.value, () => {});\n        return node;\n      }\n    }\n\n    _minValueNode(node) {\n      let current = node;\n      while (current.left !== null) {\n        current = current.left;\n      }\n      return current;\n    }\n\n    clear() {\n      this.root = null;\n    }\n\n    // inorder traversal for debug or logs (returns array of values)\n    inorder() {\n      const result = [];\n      this._inorder(this.root, result);\n      return result;\n    }\n\n    _inorder(node, arr) {\n      if (node !== null) {\n        this._inorder(node.left, arr);\n        arr.push(node.value);\n        this._inorder(node.right, arr);\n      }\n    }\n  }\n\n  // Visualization code\n  const svg = document.getElementById('bst-svg');\n  const LOG = document.getElementById('log');\n\n  let bst = new BST();\n\n  // Dimensions for visualization\n  const nodeRadius = 20;\n  const verticalGap = 70;\n\n  // Calculate positions for all nodes\n  // We use an in-order traversal to determine x position and levels for y.\n  function calculateNodePositions() {\n    let x = 0;\n    function assignPositions(node, depth) {\n      if (!node) return;\n      assignPositions(node.left, depth + 1);\n      node.x = x++;\n      node.y = depth;\n      assignPositions(node.right, depth + 1);\n    }\n    assignPositions(bst.root, 0);\n  }\n\n  // Render the BST into SVG\n  function renderBST(highlightValue = null) {\n    svg.innerHTML = '';\n\n    if (!bst.root) {\n      svg.setAttribute('viewBox', '0 0 400 150');\n      const emptyText = document.createElementNS('http://www.w3.org/2000/svg','text');\n      emptyText.setAttribute('x', '50%');\n      emptyText.setAttribute('y','50%');\n      emptyText.setAttribute('text-anchor','middle');\n      emptyText.setAttribute('dominant-baseline','middle');\n      emptyText.setAttribute('fill','#666');\n      emptyText.textContent = 'Tree is empty';\n      svg.appendChild(emptyText);\n      return;\n    }\n\n    calculateNodePositions();\n\n    // The horizontal positioning will be based on in-order index scaled to SVG width\n    const nodes = [];\n    function collectNodes(node) {\n      if (!node) return;\n      collectNodes(node.left);\n      nodes.push(node);\n      collectNodes(node.right);\n    }\n    collectNodes(bst.root);\n\n    // Calculate spacing\n    const count = nodes.length;\n    const width = Math.max(400, count * (nodeRadius*3));\n    const height = (getMaxDepth(bst.root) + 1) * verticalGap + 40;\n\n    svg.setAttribute('width', width);\n    svg.setAttribute('height', height);\n    svg.setAttribute('viewBox', `-30 0 ${width+60} ${height}`);\n\n    // Helper to get max depth\n    function getMaxDepth(node) {\n      if (!node) return 0;\n      return 1 + Math.max(getMaxDepth(node.left), getMaxDepth(node.right));\n    }\n\n    // Map x (inorder index) to SVG coordinate\n    const hSpacing = width / (count + 1);\n    // y is based on depth\n\n    function getX(node) {\n      return (node.x + 1) * hSpacing;\n    }\n    function getY(node) {\n      return (node.y * verticalGap) + 40;\n    }\n\n    // Draw edges first (lines)\n    function drawEdges(node) {\n      if (!node) return;\n      if (node.left) drawLine(node, node.left);\n      if (node.right) drawLine(node, node.right);\n      drawEdges(node.left);\n      drawEdges(node.right);\n    }\n    function drawLine(parent, child) {\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('class', 'edge');\n      line.setAttribute('x1', getX(parent));\n      line.setAttribute('y1', getY(parent) + nodeRadius);\n      line.setAttribute('x2', getX(child));\n      line.setAttribute('y2', getY(child) - nodeRadius);\n      svg.appendChild(line);\n    }\n    drawEdges(bst.root);\n\n    // Draw nodes\n    function drawNode(node) {\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('class', 'node');\n      g.setAttribute('transform', `translate(${getX(node)},${getY(node)})`);\n      if (highlightValue !== null && node.value === highlightValue) {\n        g.classList.add('highlight');\n      }\n      // Circle\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', nodeRadius);\n      circle.setAttribute('tabindex', '0');\n      circle.setAttribute('aria-label', `Node with value ${node.value}`);\n      g.appendChild(circle);\n      // Text label\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('dy', '0.35em');\n      text.setAttribute('text-anchor', 'middle');\n      text.textContent = node.value;\n      g.appendChild(text);\n\n      svg.appendChild(g);\n    }\n\n    function drawAllNodes(node) {\n      if (!node) return;\n      drawAllNodes(node.left);\n      drawNode(node);\n      drawAllNodes(node.right);\n    }\n    drawAllNodes(bst.root);\n  }\n\n  // Log helper\n  function log(msg) {\n    const p = document.createElement('div');\n    p.textContent = msg;\n    LOG.appendChild(p);\n    LOG.scrollTop = LOG.scrollHeight;\n  }\n  function clearLog() {\n    LOG.innerHTML = '';\n  }\n\n  // Button and input refs\n  const inputValue = document.getElementById('inputValue');\n  const insertBtn = document.getElementById('insertBtn');\n  const searchBtn = document.getElementById('searchBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const clearBtn = document.getElementById('clearBtn');\n\n  // Input validation and helpers\n  function getInputNumber() {\n    const val = inputValue.value.trim();\n    if (val === '') return null;\n    const num = Number(val);\n    if (Number.isNaN(num) || !Number.isInteger(num)) return null;\n    if (num < -1000000 || num > 1000000) return null; // arbitrary range limit\n    return num;\n  }\n\n  function disableButtons(disabled) {\n    insertBtn.disabled = disabled;\n    searchBtn.disabled = disabled;\n    deleteBtn.disabled = disabled;\n  }\n\n  // Event listeners\n  insertBtn.addEventListener('click', () => {\n    const num = getInputNumber();\n    if (num === null) {\n      alert('Please enter a valid integer between -1,000,000 and 1,000,000.');\n      return;\n    }\n    const success = bst.insert(num);\n    if (success) {\n      log(`Inserted ${num} into the BST.`);\n    } else {\n      log(`Value ${num} already exists in the BST. No duplicates allowed.`);\n    }\n    inputValue.value = '';\n    renderBST();\n  });\n\n  searchBtn.addEventListener('click', () => {\n    const num = getInputNumber();\n    if (num === null) {\n      alert('Please enter a valid integer to search.');\n      return;\n    }\n    disableButtons(true);\n    log(`Searching for value ${num}...`);\n    // Highlight search path with animation\n    let path = [];\n    function findPath(node, val) {\n      if (!node) return false;\n      path.push(node);\n      if (val === node.value) return true;\n      if (val < node.value) return findPath(node.left, val);\n      else return findPath(node.right, val);\n    }\n    path = [];\n    const found = findPath(bst.root, num);\n\n    // Animate highlights (one node at a time)\n    let i = 0;\n    function highlightStep() {\n      if (i > 0) {\n        // Remove highlight from previous node\n        const prevNode = path[i-1];\n        unhighlightValue(prevNode.value);\n      }\n      if (i >= path.length) {\n        if (found) {\n          log(`Value ${num} found in the BST.`);\n          highlightValue(num); // final highlight\n        } else {\n          log(`Value ${num} NOT found in the BST.`);\n        }\n        disableButtons(false);\n        return;\n      }\n      highlightValue(path[i].value);\n      i++;\n      setTimeout(highlightStep, 800);\n    }\n    highlightStep();\n  });\n\n  deleteBtn.addEventListener('click', () => {\n    const num = getInputNumber();\n    if (num === null) {\n      alert('Please enter a valid integer to delete.');\n      return;\n    }\n    const deleted = bst.delete(num);\n    if (deleted) {\n      log(`Deleted ${num} from the BST.`);\n    } else {\n      log(`Value ${num} not found in the BST. Nothing deleted.`);\n    }\n    inputValue.value = '';\n    renderBST();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if (!bst.root) {\n      log('Tree is already empty.');\n      return;\n    }\n    if (confirm('Are you sure you want to clear the entire tree?')) {\n      bst.clear();\n      log('Cleared the entire BST.');\n      renderBST();\n    }\n  });\n\n  inputValue.addEventListener('keydown', e => {\n    if (e.key === 'Enter') {\n      insertBtn.click();\n    }\n  });\n\n  // Highlight node by value\n  function highlightValue(value) {\n    // Add highlight class to the node group\n    const nodes = svg.querySelectorAll('.node');\n    nodes.forEach(n => {\n      const textEl = n.querySelector('text');\n      if (textEl && textEl.textContent == value) {\n        n.classList.add('highlight');\n      }\n    });\n  }\n\n  // Remove highlight from node by value\n  function unhighlightValue(value) {\n    const nodes = svg.querySelectorAll('.node.highlight');\n    nodes.forEach(n => {\n      const textEl = n.querySelector('text');\n      if (textEl && textEl.textContent == value) {\n        n.classList.remove('highlight');\n      }\n    });\n  }\n\n  // Initial render\n  renderBST();\n\n  log('Binary Search Tree demonstration initialized.');\n  log('Use the input box and buttons above to insert, search, and delete nodes.');\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}