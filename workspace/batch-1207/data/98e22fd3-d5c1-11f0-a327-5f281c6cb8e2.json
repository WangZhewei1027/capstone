{
  "id": "98e22fd3-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:19:39.967Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Dijkstra's Algorithm Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{\n    --bg:#f7f9fc;\n    --panel:#ffffff;\n    --accent:#2b78f6;\n    --muted:#6b7280;\n    --good:#10b981;\n    --bad:#ef4444;\n    --node:#ffffff;\n    --node-stroke:#1f2937;\n  }\n  html,body{height:100%;margin:0;font-family:Inter, Roboto, Helvetica, Arial, sans-serif;background:var(--bg);color:#111827}\n  .container{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}\n  .canvas-panel{flex:1;background:linear-gradient(180deg,#eef6ff, #ffffff);border-radius:10px;padding:10px;box-shadow:0 2px 8px rgba(15,23,42,0.06);display:flex;flex-direction:column}\n  #graphCanvas{flex:1;background:transparent;border-radius:6px;cursor:crosshair}\n  .controls{width:380px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 2px 10px rgba(2,6,23,0.06);overflow:auto}\n  h2{margin:2px 0 8px 0;font-size:18px}\n  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}\n  .modes{display:flex;gap:6px;flex-wrap:wrap}\n  button{background:var(--accent);color:#fff;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}\n  .btn-ghost{background:transparent;color:var(--accent);border:1px solid rgba(43,120,246,0.15)}\n  .btn-danger{background:var(--bad)}\n  .small{padding:6px 8px;font-size:14px}\n  label{font-size:13px;color:var(--muted)}\n  input[type=\"number\"],input[type=\"text\"],select{padding:6px;border-radius:6px;border:1px solid #e6e9ee}\n  .info-block{background:#f8fafc;padding:8px;border-radius:8px;margin-bottom:8px;border:1px dashed #e6eefb}\n  .list{max-height:220px;overflow:auto;padding:6px;border-radius:6px;border:1px solid #eef2ff;background:#fcfeff}\n  .row-space{display:flex;justify-content:space-between;align-items:center}\n  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}\n  .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:999px;background:#fff;border:1px solid #eef2ff;font-size:13px}\n  .chip .dot{width:12px;height:12px;border-radius:50%}\n  .dot-unvisited{background:#f3f4f6;border:1px solid #c7cbd6}\n  .dot-frontier{background:#ffb020}\n  .dot-visited{background:#10b981}\n  .dot-current{background:#ef4444}\n  table{width:100%;border-collapse:collapse;font-size:13px}\n  th,td{padding:6px;text-align:left;border-bottom:1px dashed #eef2ff}\n  .pq-item{display:flex;justify-content:space-between;gap:8px;padding:6px;border-radius:6px;background:#fff;border:1px solid #eef2ff;margin-bottom:6px}\n  .small-muted{font-size:12px;color:var(--muted)}\n  .tight{padding:4px 6px}\n  .footer{font-size:12px;color:var(--muted);margin-top:8px}\n  .weight-badge{background:rgba(2,6,23,0.04);padding:3px 6px;border-radius:4px;font-weight:600}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"canvas-panel\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">\n      <div>\n        <h2>Dijkstra Visualizer</h2>\n        <div class=\"small-muted\">Create a graph, set weights, then run Dijkstra step-by-step or animate.</div>\n      </div>\n      <div style=\"text-align:right\">\n        <div class=\"small-muted\">Nodes: <span id=\"nodeCount\">0</span> • Edges: <span id=\"edgeCount\">0</span></div>\n      </div>\n    </div>\n    <canvas id=\"graphCanvas\"></canvas>\n    <div style=\"display:flex;gap:8px;margin-top:8px;align-items:center\">\n      <div class=\"small-muted\">Mode:</div>\n      <div class=\"modes\" id=\"modes\">\n        <button class=\"small\" id=\"mode-add-node\">Add Node</button>\n        <button class=\"small btn-ghost\" id=\"mode-add-edge\">Add Edge</button>\n        <button class=\"small btn-ghost\" id=\"mode-move\">Move</button>\n        <button class=\"small btn-ghost\" id=\"mode-delete\">Delete</button>\n      </div>\n      <div style=\"margin-left:auto;display:flex;gap:6px\">\n        <button class=\"small btn-ghost\" id=\"btn-clear\">Clear</button>\n        <button class=\"small btn-ghost\" id=\"btn-reset\">Reset Dijkstra</button>\n      </div>\n    </div>\n    <div class=\"footer\">Tip: Add nodes by clicking canvas. Use \"Add Edge\" mode: click source then target and enter weight. Toggle \"Directed\" to create one-way edges.</div>\n  </div>\n\n  <div class=\"controls\">\n    <h3>Graph & Dijkstra Controls</h3>\n\n    <div class=\"row\">\n      <label>Directed?</label>\n      <input type=\"checkbox\" id=\"directed\" style=\"margin-left:8px\" />\n      <div style=\"margin-left:auto\" class=\"small-muted\">Default weight:</div>\n      <input type=\"number\" id=\"defaultWeight\" value=\"1\" style=\"width:76px;margin-left:8px\"/>\n    </div>\n\n    <div class=\"row\">\n      <button id=\"btn-run\" class=\"small\">Run (Animate)</button>\n      <button id=\"btn-step\" class=\"small btn-ghost\">Step</button>\n      <button id=\"btn-pause\" class=\"small btn-ghost\">Pause</button>\n      <button id=\"btn-speed\" class=\"small btn-ghost\">Speed: <span id=\"speedLabel\">1x</span></button>\n    </div>\n\n    <div class=\"row\">\n      <label>Start node:</label>\n      <select id=\"startSelect\" style=\"flex:1\"></select>\n    </div>\n\n    <div class=\"row\">\n      <label>Highlight shortest path to:</label>\n      <select id=\"endSelect\" style=\"flex:1\"><option value=\"\">(none)</option></select>\n    </div>\n\n    <div class=\"info-block\">\n      <div class=\"row-space\"><strong>Algorithm state</strong><div class=\"small-muted\">Step-by-step visualization</div></div>\n      <div style=\"display:flex;gap:8px;margin-top:8px\">\n        <div style=\"flex:1\">\n          <div class=\"small-muted\">Priority Queue (min by dist)</div>\n          <div id=\"pqList\" class=\"list\" style=\"min-height:80px\"></div>\n        </div>\n        <div style=\"flex:1\">\n          <div class=\"small-muted\">Distances</div>\n          <div class=\"list\" id=\"distList\"></div>\n        </div>\n      </div>\n      <div style=\"margin-top:8px\">\n        <div class=\"small-muted\">Legend</div>\n        <div class=\"legend\">\n          <div class=\"chip\"><span class=\"dot dot-unvisited\"></span>unvisited</div>\n          <div class=\"chip\"><span class=\"dot dot-frontier\"></span>in priority queue</div>\n          <div class=\"chip\"><span class=\"dot dot-visited\"></span>visited (settled)</div>\n          <div class=\"chip\"><span class=\"dot dot-current\"></span>current exploring</div>\n        </div>\n      </div>\n    </div>\n\n    <h4 style=\"margin-top:10px;margin-bottom:6px\">Nodes & Edges</h4>\n    <div style=\"display:flex;gap:8px;margin-bottom:6px\">\n      <div style=\"flex:1\">\n        <div class=\"small-muted\">Nodes</div>\n        <div class=\"list\" id=\"nodeList\"></div>\n      </div>\n      <div style=\"flex:1\">\n        <div class=\"small-muted\">Edges</div>\n        <div class=\"list\" id=\"edgeList\"></div>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:8px;margin-top:6px\">\n      <button id=\"btn-export\" class=\"small btn-ghost\">Export JSON</button>\n      <button id=\"btn-import\" class=\"small btn-ghost\">Import JSON</button>\n      <input type=\"file\" id=\"fileInput\" style=\"display:none\" />\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <div class=\"small-muted\">Animation speed</div>\n      <input type=\"range\" id=\"speedRange\" min=\"0.25\" max=\"3\" step=\"0.25\" value=\"1\" />\n    </div>\n\n    <div style=\"margin-top:10px\" class=\"small-muted\">\n      Instructions:\n      <ul style=\"margin:6px 0 0 18px;padding:0\">\n        <li>Modes: Add Node (click canvas), Add Edge (click src then dst), Move (drag nodes), Delete (click node/edge).</li>\n        <li>Set a start node, then Run or Step. Watch distances and priority queue update.</li>\n        <li>After finish, pick an end node to highlight the shortest path.</li>\n      </ul>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Canvas and graph state\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n  function resizeCanvas(){\n    canvas.width = canvas.clientWidth * DPR;\n    canvas.height = canvas.clientHeight * DPR;\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    render();\n  }\n  // set initial canvas size to fill panel\n  function fitCanvasToParent(){\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = Math.max(300, rect.width) * DPR;\n    canvas.height = Math.max(200, rect.height) * DPR;\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n  }\n  // ensure canvas fills available space\n  function adjustCanvasStyle(){\n    const parent = canvas.parentElement;\n    canvas.style.width = '100%';\n    canvas.style.height = (parent.clientHeight - 10) + 'px';\n  }\n  adjustCanvasStyle();\n  fitCanvasToParent();\n  window.addEventListener('resize', ()=>{\n    adjustCanvasStyle();\n    fitCanvasToParent();\n    render();\n  });\n\n  // Data structures\n  let nodes = []; // {id,label,x,y}\n  let edges = []; // {id,from,to,weight}\n  let nextNodeId = 1;\n  let nextEdgeId = 1;\n\n  // Interaction\n  let mode = 'add-node'; // add-node, add-edge, move, delete\n  const modeButtons = {\n    'add-node': document.getElementById('mode-add-node'),\n    'add-edge': document.getElementById('mode-add-edge'),\n    'move': document.getElementById('mode-move'),\n    'delete': document.getElementById('mode-delete')\n  };\n  function setMode(m){\n    mode = m;\n    for(const k in modeButtons){\n      modeButtons[k].classList.toggle('btn-ghost', k !== m);\n      modeButtons[k].classList.toggle('small', true);\n      modeButtons[k].classList.toggle('active', k === m);\n      modeButtons[k].style.background = (k === m ? 'var(--accent)' : (k === 'add-node' ? '' : 'transparent'));\n      modeButtons[k].style.color = (k === m ? '#fff' : (k === 'add-node' ? '' : 'var(--accent)'));\n      if(k === 'add-node' && m !== 'add-node'){\n        // restore style of add-node as ghost when not active\n        modeButtons[k].classList.toggle('btn-ghost', true);\n      }\n    }\n    // specific visuals\n    for(const k in modeButtons){\n      modeButtons[k].style.background = (k === m ? 'var(--accent)' : '');\n      modeButtons[k].style.color = (k === m ? '#fff' : '');\n      modeButtons[k].classList.toggle('btn-ghost', k !== m);\n    }\n  }\n  setMode(mode);\n\n  modeButtons['add-node'].addEventListener('click', ()=>setMode('add-node'));\n  modeButtons['add-edge'].addEventListener('click', ()=>setMode('add-edge'));\n  modeButtons['move'].addEventListener('click', ()=>setMode('move'));\n  modeButtons['delete'].addEventListener('click', ()=>setMode('delete'));\n\n  const defaultWeightInput = document.getElementById('defaultWeight');\n  const directedCheckbox = document.getElementById('directed');\n\n  // selection state for add-edge\n  let edgeFromNode = null;\n\n  // dragging\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n\n  // helper finders\n  function nodeAt(x,y){\n    return nodes.find(n=>{\n      const dx = n.x - x, dy = n.y - y;\n      return Math.sqrt(dx*dx+dy*dy) <= 20;\n    });\n  }\n  function edgeAt(x,y){\n    // pick if click near segment midpoint within 8px\n    for(const e of edges){\n      const a = nodes.find(n=>n.id===e.from);\n      const b = nodes.find(n=>n.id===e.to);\n      if(!a||!b) continue;\n      const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;\n      const dx = mx - x, dy = my - y;\n      if(Math.sqrt(dx*dx+dy*dy) < 12) return e;\n    }\n    return null;\n  }\n\n  // canvas event handling\n  canvas.addEventListener('mousedown', (ev)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n\n    if(mode === 'add-node'){\n      addNode(x,y);\n      render();\n      return;\n    }\n    if(mode === 'add-edge'){\n      const n = nodeAt(x,y);\n      if(!n) return;\n      if(!edgeFromNode){\n        edgeFromNode = n;\n      } else {\n        if(edgeFromNode.id === n.id){\n          edgeFromNode = null;\n          render();\n          return;\n        }\n        const w = parseFloat(prompt('Edge weight (positive number):', defaultWeightInput.value || '1'));\n        if(isFinite(w) && w >= 0){\n          addEdge(edgeFromNode.id, n.id, w);\n        }\n        edgeFromNode = null;\n        render();\n      }\n      render();\n      return;\n    }\n    if(mode === 'move'){\n      const n = nodeAt(x,y);\n      if(n){\n        draggingNode = n;\n        dragOffset.x = x - n.x;\n        dragOffset.y = y - n.y;\n      }\n    }\n    if(mode === 'delete'){\n      const n = nodeAt(x,y);\n      if(n){\n        if(confirm('Delete node \"'+n.label+'\"? This removes connected edges.')){\n          deleteNode(n.id);\n          render();\n        }\n        return;\n      }\n      const e = edgeAt(x,y);\n      if(e){\n        if(confirm('Delete edge '+labelEdge(e)+'?')){\n          deleteEdge(e.id);\n          render();\n        }\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (ev)=>{\n    if(draggingNode && mode === 'move'){\n      const rect = canvas.getBoundingClientRect();\n      const x = ev.clientX - rect.left;\n      const y = ev.clientY - rect.top;\n      draggingNode.x = x - dragOffset.x;\n      draggingNode.y = y - dragOffset.y;\n      render();\n    }\n  });\n\n  window.addEventListener('mouseup', ()=>{\n    draggingNode = null;\n  });\n\n  // Add, delete helpers\n  function addNode(x,y){\n    const id = nextNodeId++;\n    const label = String.fromCharCode(64 + id); // A,B,C,... maybe beyond Z becomes symbols\n    nodes.push({id:id, label:label, x:x, y:y});\n    updateNodeEdgeCounts();\n    rebuildNodeSelects();\n  }\n  function deleteNode(id){\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e=> e.from!==id && e.to!==id);\n    updateNodeEdgeCounts();\n    rebuildNodeSelects();\n  }\n  function addEdge(from,to,weight){\n    const id = nextEdgeId++;\n    edges.push({id:id,from:from,to:to,weight:weight});\n    // if undirected, also add reverse? We will treat edges as directed by default; if user wants undirected, they can toggle directed OFF when creating edges.\n    if(!directedCheckbox.checked){\n      // also add reverse implicitly as another edge? For clarity, we create symmetric edge entry to act as undirected\n      edges.push({id: nextEdgeId++, from: to, to: from, weight: weight});\n    }\n    updateNodeEdgeCounts();\n  }\n  function deleteEdge(id){\n    edges = edges.filter(e=>e.id!==id);\n    updateNodeEdgeCounts();\n  }\n  function labelEdge(e){\n    const a = nodes.find(n=>n.id===e.from);\n    const b = nodes.find(n=>n.id===e.to);\n    return `${a? a.label : e.from}→${b? b.label : e.to} (w=${e.weight})`;\n  }\n\n  // Rendering\n  function render(){\n    // clear\n    ctx.clearRect(0,0,canvas.width, canvas.height);\n    // background grid\n    drawGrid();\n    // draw edges\n    for(const e of edges){\n      drawEdge(e);\n    }\n    // draw placeholder for edge-from when adding edge\n    if(edgeFromNode){\n      drawNode(edgeFromNode, {highlight:true, ghostTarget: lastMousePos});\n    }\n    // draw nodes\n    for(const n of nodes){\n      drawNode(n);\n    }\n    // draw UI overlays: selected edge-from indicator\n    // no-op\n    updateLists();\n  }\n\n  function drawGrid(){\n    const w = canvas.clientWidth, h = canvas.clientHeight;\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.0)';\n    ctx.fillRect(0,0,w,h);\n    // subtle grid\n    ctx.strokeStyle = 'rgba(15,23,42,0.03)';\n    ctx.lineWidth = 1;\n    const step = 40;\n    for(let x=0;x<w;x+=step){\n      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();\n    }\n    for(let y=0;y<h;y+=step){\n      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawEdge(e){\n    const a = nodes.find(n=>n.id===e.from);\n    const b = nodes.find(n=>n.id===e.to);\n    if(!a||!b) return;\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const len = Math.sqrt(dx*dx + dy*dy);\n    if(len < 1) return;\n    const ux = dx/len, uy = dy/len;\n    const startX = a.x + ux*20, startY = a.y + uy*20;\n    const endX = b.x - ux*20, endY = b.y - uy*20;\n\n    ctx.save();\n    // edge line\n    ctx.beginPath();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'rgba(15,23,42,0.14)';\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    // arrow for directed graphs\n    if(directedCheckbox.checked){\n      ctx.beginPath();\n      const arwLen = 10;\n      const px = endX, py = endY;\n      ctx.fillStyle = 'rgba(15,23,42,0.6)';\n      ctx.moveTo(px,py);\n      ctx.lineTo(px - ux*arwLen - uy*6, py - uy*arwLen + ux*6);\n      ctx.lineTo(px - ux*arwLen + uy*6, py - uy*arwLen - ux*6);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    // weight label\n    ctx.fillStyle = 'rgba(2,6,23,0.8)';\n    ctx.font = '12px sans-serif';\n    const mx = (startX + endX)/2;\n    const my = (startY + endY)/2;\n    ctx.fillText(String(e.weight), mx + 8, my + 4);\n    ctx.restore();\n  }\n\n  function drawNode(n, opts = {}){\n    const x = n.x, y = n.y;\n    // determine state from algorithm visualization\n    const state = algStateForNode(n.id);\n    const r = 20;\n    ctx.save();\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.strokeStyle = 'rgba(15,23,42,0.08)';\n    ctx.lineWidth = 1;\n    // fill based on state\n    let fill = '#ffffff';\n    let stroke = 'rgba(15,23,42,0.25)';\n    if(state){\n      if(state.isCurrent) fill = '#fee2e2'; // current exploring red-ish\n      else if(state.visited) fill = '#ecfdf5'; // visited green-ish\n      else if(state.inQueue) fill = '#fff7ed'; // frontier orange-ish\n    }\n\n    ctx.beginPath();\n    ctx.arc(x,y,r,0,Math.PI*2);\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = 'rgba(15,23,42,0.12)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // label\n    ctx.fillStyle = '#0f172a';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.label, x, y - 2);\n\n    // distance badge\n    const distText = (distances && distances.hasOwnProperty(n.id) && distances[n.id] < Infinity) ? String(distances[n.id]) : '∞';\n    ctx.fillStyle = 'rgba(2,6,23,0.6)';\n    ctx.font = '11px sans-serif';\n    ctx.fillText(distText, x, y + 14);\n\n    ctx.restore();\n  }\n\n  // Algorithm visualization state\n  let distances = {}; // nodeId -> dist\n  let prev = {}; // nodeId -> previous node id in shortest path\n  let visited = {}; // nodeId -> bool (settled)\n  let inQueue = {}; // nodeId -> bool\n  let currentNodeId = null;\n\n  function algStateForNode(nodeId){\n    if(!started) return null;\n    return {\n      visited: !!visited[nodeId],\n      inQueue: !!inQueue[nodeId],\n      isCurrent: currentNodeId === nodeId\n    };\n  }\n\n  // UI list updates\n  function updateNodeEdgeCounts(){\n    document.getElementById('nodeCount').textContent = nodes.length;\n    document.getElementById('edgeCount').textContent = edges.length;\n    rebuildNodeSelects();\n    updateLists();\n  }\n\n  function rebuildNodeSelects(){\n    const startSel = document.getElementById('startSelect');\n    const endSel = document.getElementById('endSelect');\n    const oldStart = startSel.value;\n    const oldEnd = endSel.value;\n    startSel.innerHTML = '';\n    endSel.innerHTML = '<option value=\"\">(none)</option>';\n    nodes.forEach(n=>{\n      const o = document.createElement('option');\n      o.value = n.id;\n      o.textContent = n.label + ' ('+n.id+')';\n      startSel.appendChild(o);\n      const oe = o.cloneNode(true);\n      endSel.appendChild(oe);\n    });\n    if(nodes.length) startSel.value = oldStart || nodes[0].id;\n    endSel.value = oldEnd || '';\n  }\n\n  function updateLists(){\n    // distances\n    const distList = document.getElementById('distList');\n    distList.innerHTML = '';\n    if(nodes.length === 0){\n      distList.textContent = '(no nodes)';\n    } else {\n      nodes.forEach(n=>{\n        const div = document.createElement('div');\n        div.style.display = 'flex';\n        div.style.justifyContent = 'space-between';\n        div.style.alignItems = 'center';\n        div.style.padding = '6px';\n        div.style.borderBottom = '1px dashed #eef2ff';\n        const left = document.createElement('div');\n        left.textContent = n.label;\n        left.style.fontWeight = '600';\n        const right = document.createElement('div');\n        right.style.color = 'rgba(2,6,23,0.6)';\n        const d = (distances && distances.hasOwnProperty(n.id) && distances[n.id] < Infinity) ? distances[n.id] : '∞';\n        right.textContent = d + (prev[n.id] ? (' ← '+(nodes.find(nn=>nn.id===prev[n.id])?.label || prev[n.id])) : '');\n        div.appendChild(left);\n        div.appendChild(right);\n        distList.appendChild(div);\n      });\n    }\n\n    // PQ\n    const pqDiv = document.getElementById('pqList');\n    pqDiv.innerHTML = '';\n    if(Object.keys(inQueue || {}).filter(k=>inQueue[k]).length === 0){\n      pqDiv.textContent = '(empty)';\n    } else {\n      // show sorted by distances\n      const items = Object.keys(inQueue).filter(k=>inQueue[k]).map(k=>({id:+k,dist:distances[k]}));\n      items.sort((a,b)=> (a.dist === undefined ? Infinity : a.dist) - (b.dist===undefined?Infinity:b.dist));\n      items.forEach(it=>{\n        const row = document.createElement('div');\n        row.className = 'pq-item';\n        const lbl = document.createElement('div');\n        lbl.textContent = (nodes.find(n=>n.id===it.id)?.label || it.id);\n        const d = document.createElement('div');\n        d.textContent = it.dist;\n        d.style.opacity = '0.85';\n        row.appendChild(lbl); row.appendChild(d);\n        pqDiv.appendChild(row);\n      });\n    }\n\n    // node list\n    const nodeList = document.getElementById('nodeList');\n    nodeList.innerHTML = '';\n    nodes.forEach(n=>{\n      const d = document.createElement('div');\n      d.textContent = n.label + ' ('+n.id+')';\n      d.style.padding = '4px 6px';\n      nodeList.appendChild(d);\n    });\n\n    // edge list\n    const edgeList = document.getElementById('edgeList');\n    edgeList.innerHTML = '';\n    edges.forEach(e=>{\n      const el = document.createElement('div');\n      el.textContent = labelEdge(e);\n      el.style.padding = '4px 6px';\n      edgeList.appendChild(el);\n    });\n  }\n\n  // Dijkstra algorithm implementation with generator for step-by-step\n  function* dijkstraGenerator(startId){\n    // Build adjacency list from edges\n    const adj = {};\n    nodes.forEach(n => adj[n.id] = []);\n    edges.forEach(e => {\n      if(adj[e.from]) adj[e.from].push({to: e.to, w: e.weight, edgeId:e.id});\n    });\n    // initialize\n    distances = {};\n    prev = {};\n    visited = {};\n    inQueue = {};\n    currentNodeId = null;\n    nodes.forEach(n => { distances[n.id] = Infinity; prev[n.id] = null; visited[n.id] = false; inQueue[n.id] = false; });\n    distances[startId] = 0;\n    // simple PQ using array; store candidate nodes\n    const pq = [];\n    pqPush(pq, startId, distances[startId]); inQueue[startId] = true;\n    yield {type:'init', distances: {...distances}, prev: {...prev}, pq: pq.slice()};\n    while(pq.length){\n      // pop min\n      const u = pqPop(pq);\n      currentNodeId = u;\n      if(visited[u]) { yield {type:'skip', u}; continue; }\n      // settle u\n      visited[u] = true;\n      inQueue[u] = false;\n      yield {type:'visit', u, distances: {...distances}, prev: {...prev}};\n      // relax edges\n      const neighbors = adj[u] || [];\n      for(const {to:v, w, edgeId} of neighbors){\n        yield {type:'exam', u, v, w};\n        if(visited[v]) { yield {type:'exam-done', u,v}; continue; }\n        const alt = distances[u] + w;\n        if(alt < distances[v]){\n          distances[v] = alt;\n          prev[v] = u;\n          pqPush(pq, v, alt);\n          inQueue[v] = true;\n          yield {type:'update', v, newDist:alt, prev: u, pq: pq.slice(), distances: {...distances}};\n        } else {\n          yield {type:'no-update', v, alt, distances: {...distances}};\n        }\n      }\n    }\n    currentNodeId = null;\n    yield {type:'done', distances: {...distances}, prev: {...prev}};\n  }\n\n  // simple PQ helpers\n  function pqPush(pq, nodeId, dist){\n    pq.push({id:nodeId, dist:dist});\n    // keep sorted by dist ascending\n    pq.sort((a,b)=> a.dist - b.dist);\n  }\n  function pqPop(pq){\n    if(pq.length===0) return null;\n    return pq.shift().id;\n  }\n\n  // Controls: run, step, reset, pause, speed\n  let generator = null;\n  let autoplay = false;\n  let animInterval = null;\n  let animSpeed = 1; // multiplier (1x)\n  let started = false;\n\n  const btnRun = document.getElementById('btn-run');\n  const btnStep = document.getElementById('btn-step');\n  const btnPause = document.getElementById('btn-pause');\n  const btnReset = document.getElementById('btn-reset');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n\n  btnRun.addEventListener('click', ()=>{\n    if(!nodes.length){\n      alert('No nodes to run on.');\n      return;\n    }\n    const startVal = document.getElementById('startSelect').value;\n    if(!startVal){ alert('Select a start node.'); return; }\n    if(generator == null){\n      generator = dijkstraGenerator(+startVal);\n    }\n    autoplay = true;\n    btnRun.disabled = true;\n    btnPause.disabled = false;\n    btnStep.disabled = true;\n    stepAnimation();\n  });\n\n  btnStep.addEventListener('click', ()=>{\n    if(!nodes.length){ alert('No nodes.'); return; }\n    const startVal = document.getElementById('startSelect').value;\n    if(!startVal){ alert('Select a start node.'); return; }\n    if(generator == null){\n      generator = dijkstraGenerator(+startVal);\n      started = true;\n    }\n    const r = generator.next();\n    handleGeneratorResult(r.value);\n  });\n\n  btnPause.addEventListener('click', ()=>{\n    autoplay = false;\n    generator = null;\n    btnRun.disabled = false;\n    btnStep.disabled = false;\n    btnPause.disabled = true;\n    started = false;\n    currentNodeId = null;\n    render();\n  });\n\n  btnReset.addEventListener('click', ()=>{\n    generator = null;\n    autoplay = false;\n    started = false;\n    distances = {};\n    prev = {};\n    visited = {};\n    inQueue = {};\n    currentNodeId = null;\n    render();\n  });\n\n  speedRange.addEventListener('input', ()=>{\n    animSpeed = parseFloat(speedRange.value);\n    speedLabel.textContent = animSpeed + 'x';\n  });\n\n  function stepAnimation(){\n    if(!autoplay) return;\n    // schedule steps with interval inversely proportional to animSpeed\n    const delay = Math.max(120, 600 / animSpeed);\n    if(animInterval) clearInterval(animInterval);\n    animInterval = setInterval(()=>{\n      if(!autoplay) { clearInterval(animInterval); return; }\n      if(!generator){\n        const startVal = document.getElementById('startSelect').value;\n        if(!startVal) return;\n        generator = dijkstraGenerator(+startVal);\n      }\n      const r = generator.next();\n      if(r.done || !r.value){\n        autoplay = false;\n        generator = null;\n        clearInterval(animInterval);\n        btnRun.disabled = false;\n        btnStep.disabled = false;\n        btnPause.disabled = true;\n        started = false;\n        currentNodeId = null;\n        render();\n        return;\n      }\n      handleGeneratorResult(r.value);\n    }, delay);\n  }\n\n  function handleGeneratorResult(val){\n    if(!val) return;\n    const t = val.type;\n    if(t === 'init'){\n      distances = val.distances;\n      prev = val.prev;\n      inQueue = {};\n      Object.keys(val.distances).forEach(k=> inQueue[k]=false);\n      val.pq.forEach(p => inQueue[p.id] = true);\n      started = true;\n      currentNodeId = null;\n      render();\n    } else if(t === 'visit'){\n      distances = val.distances;\n      prev = val.prev;\n      visited[val.u] = true;\n      inQueue[val.u] = false;\n      currentNodeId = val.u;\n      render();\n    } else if(t === 'exam'){\n      // mark current node\n      currentNodeId = val.u;\n      render();\n    } else if(t === 'update'){\n      distances = val.distances;\n      prev = val.prev;\n      inQueue[val.v] = true;\n      currentNodeId = val.u;\n      render();\n    } else if(t === 'no-update' || t === 'exam-done'){\n      // just update state visuals\n      distances = val.distances || distances;\n      render();\n    } else if(t === 'done'){\n      distances = val.distances;\n      prev = val.prev;\n      visited = {};\n      Object.keys(distances).forEach(k => visited[k] = true);\n      currentNodeId = null;\n      started = false;\n      generator = null;\n      autoplay = false;\n      btnRun.disabled = false;\n      btnStep.disabled = false;\n      btnPause.disabled = true;\n      render();\n      alert('Dijkstra complete.');\n    }\n    updateLists();\n  }\n\n  // export/import\n  document.getElementById('btn-export').addEventListener('click', ()=>{\n    const data = {nodes, edges, nextNodeId, nextEdgeId, directed: directedCheckbox.checked};\n    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'graph-dijkstra.json';\n    a.click();\n    URL.revokeObjectURL(url);\n  });\n  document.getElementById('btn-import').addEventListener('click', ()=>{\n    document.getElementById('fileInput').click();\n  });\n  document.getElementById('fileInput').addEventListener('change', (ev)=>{\n    const file = ev.target.files[0];\n    if(!file) return;\n    const fr = new FileReader();\n    fr.onload = function(e){\n      try{\n        const data = JSON.parse(e.target.result);\n        nodes = data.nodes || [];\n        edges = data.edges || [];\n        nextNodeId = data.nextNodeId || (nodes.length + 1);\n        nextEdgeId = data.nextEdgeId || (edges.length + 1);\n        directedCheckbox.checked = data.directed || false;\n        rebuildNodeSelects();\n        updateNodeEdgeCounts();\n        render();\n      }catch(err){\n        alert('Could not import: ' + err.message);\n      }\n    }\n    fr.readAsText(file);\n    ev.target.value = '';\n  });\n\n  // utility to compute shortest path for highlighting\n  function highlightPathTo(targetId){\n    if(!prev || !prev[targetId]) return [];\n    const path = [];\n    let cur = +targetId;\n    while(cur != null){\n      path.push(cur);\n      cur = prev[cur];\n      if(cur === null) break;\n    }\n    return path.reverse();\n  }\n\n  // highlight path when user selects end node\n  document.getElementById('endSelect').addEventListener('change', ()=>{\n    const val = document.getElementById('endSelect').value;\n    if(!val) { render(); return; }\n    if(!prev || !Object.keys(prev).length){\n      alert('No shortest path data available. Run Dijkstra first.');\n      document.getElementById('endSelect').value = '';\n      return;\n    }\n    const path = highlightPathTo(+val);\n    if(path.length <= 1){\n      alert('No path to selected node.');\n      return;\n    }\n    // draw path overlay\n    render();\n    // draw path edges\n    ctx.save();\n    ctx.strokeStyle = 'rgba(59,130,246,0.9)';\n    ctx.lineWidth = 4;\n    for(let i=0;i<path.length-1;i++){\n      const a = nodes.find(n=>n.id===path[i]);\n      const b = nodes.find(n=>n.id===path[i+1]);\n      if(!a||!b) continue;\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.stroke();\n    }\n    // highlight nodes\n    for(const id of path){\n      const n = nodes.find(nn=>nn.id===id);\n      if(!n) continue;\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(59,130,246,0.08)';\n      ctx.arc(n.x, n.y, 26, 0, Math.PI*2);\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(59,130,246,0.2)';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n  });\n\n  // small utilities\n  function clearAll(){\n    nodes = [];\n    edges = [];\n    nextNodeId = 1;\n    nextEdgeId = 1;\n    distances = {};\n    prev = {};\n    visited = {};\n    inQueue = {};\n    generator = null;\n    started = false;\n    currentNodeId = null;\n    edgeFromNode = null;\n    updateNodeEdgeCounts();\n    rebuildNodeSelects();\n    render();\n  }\n  document.getElementById('btn-clear').addEventListener('click', ()=>{\n    if(confirm('Clear entire graph?')){\n      clearAll();\n    }\n  });\n\n  // initial UI state\n  rebuildNodeSelects();\n  updateNodeEdgeCounts();\n  render();\n\n  // track last mouse pos for ghost rendering\n  let lastMousePos = null;\n  canvas.addEventListener('mousemove', (ev)=>{\n    const rect = canvas.getBoundingClientRect();\n    lastMousePos = {x: ev.clientX - rect.left, y: ev.clientY - rect.top};\n    if(edgeFromNode) render();\n  });\n\n  // helper: when new edges are created with directed toggling OFF we added symmetric entries.\n  // If the user wants strictly directed graphs, they can check \"Directed\" to avoid symmetry.\n\n  // Small helper to prepopulate sample graph for users (optional)\n  // Let's add a sample graph on first load for demonstration\n  (function prepopulate(){\n    // Only prepopulate if graph empty\n    if(nodes.length === 0){\n      addNode(100,100); addNode(260,80); addNode(420,130); addNode(160,230); addNode(360,240);\n      addEdge(1,2,2); addEdge(2,3,3); addEdge(1,4,6); addEdge(4,5,1); addEdge(5,3,1); addEdge(2,4,2);\n      // For undirected default, those edges will be duplicated unless directed is checked\n      directedCheckbox.checked = true;\n      updateNodeEdgeCounts();\n      render();\n    }\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}