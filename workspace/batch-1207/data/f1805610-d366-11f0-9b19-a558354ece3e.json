{
  "id": "f1805610-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:34.015Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Tree Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            background-color: #f5f5f5;\n            margin: 20px;\n        }\n        \n        .container {\n            background-color: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n            max-width: 1000px;\n            width: 100%;\n        }\n        \n        .controls {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;\n        }\n        \n        button {\n            padding: 8px 15px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n        }\n        \n        button:hover {\n            background-color: #45a049;\n        }\n        \n        input {\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-size: 14px;\n        }\n        \n        .tree-container {\n            position: relative;\n            min-height: 400px;\n            border: 1px solid #eee;\n            border-radius: 5px;\n            overflow: auto;\n            margin-bottom: 20px;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            background-color: #4CAF50;\n            color: white;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            z-index: 2;\n        }\n        \n        .line {\n            position: absolute;\n            background-color: #666;\n            z-index: 1;\n            transform-origin: 0 0;\n        }\n        \n        .info {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 5px;\n        }\n        \n        .traversal-result {\n            margin-top: 10px;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Binary Tree Visualization</h1>\n        \n        <div class=\"controls\">\n            <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter value\" min=\"0\" max=\"999\">\n            <button onclick=\"insertNode()\">Insert Node</button>\n            <button onclick=\"deleteNode()\">Delete Node</button>\n            <button onclick=\"preorderTraversal()\">Preorder Traversal</button>\n            <button onclick=\"inorderTraversal()\">Inorder Traversal</button>\n            <button onclick=\"postorderTraversal()\">Postorder Traversal</button>\n            <button onclick=\"clearTree()\">Clear Tree</button>\n        </div>\n        \n        <div class=\"tree-container\" id=\"treeCanvas\"></div>\n        \n        <div class=\"info\">\n            <h3>About Binary Trees:</h3>\n            <p>A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.</p>\n            \n            <h4>Tree Traversals:</h4>\n            <ul>\n                <li><strong>Preorder:</strong> Root → Left → Right</li>\n                <li><strong>Inorder:</strong> Left → Root → Right</li>\n                <li><strong>Postorder:</strong> Left → Right → Root</li>\n            </ul>\n            \n            <div class=\"traversal-result\" id=\"traversalResult\"></div>\n        </div>\n    </div>\n\n    <script>\n        class TreeNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BinaryTree {\n            constructor() {\n                this.root = null;\n            }\n\n            insert(value) {\n                const newNode = new TreeNode(value);\n                if (this.root === null) {\n                    this.root = newNode;\n                    return;\n                }\n\n                let queue = [this.root];\n                while (queue.length > 0) {\n                    let current = queue.shift();\n                    \n                    if (current.left === null) {\n                        current.left = newNode;\n                        return;\n                    } else {\n                        queue.push(current.left);\n                    }\n                    \n                    if (current.right === null) {\n                        current.right = newNode;\n                        return;\n                    } else {\n                        queue.push(current.right);\n                    }\n                }\n            }\n\n            delete(value) {\n                if (this.root === null) return;\n                \n                // Find the node to delete and the deepest node\n                let nodeToDelete = null;\n                let deepestNode = null;\n                let parentOfDeepest = null;\n                \n                let queue = [{node: this.root, parent: null}];\n                while (queue.length > 0) {\n                    let {node, parent} = queue.shift();\n                    \n                    if (node.value === value) {\n                        nodeToDelete = node;\n                    }\n                    \n                    deepestNode = node;\n                    parentOfDeepest = parent;\n                    \n                    if (node.left) queue.push({node: node.left, parent: node});\n                    if (node.right) queue.push({node: node.right, parent: node});\n                }\n                \n                if (nodeToDelete && deepestNode) {\n                    // Replace value of node to delete with deepest node's value\n                    nodeToDelete.value = deepestNode.value;\n                    \n                    // Remove the deepest node\n                    if (parentOfDeepest) {\n                        if (parentOfDeepest.left === deepestNode) {\n                            parentOfDeepest.left = null;\n                        } else {\n                            parentOfDeepest.right = null;\n                        }\n                    } else {\n                        this.root = null; // Only one node in tree\n                    }\n                }\n            }\n\n            preorder(node = this.root, result = []) {\n                if (node) {\n                    result.push(node.value);\n                    this.preorder(node.left, result);\n                    this.preorder(node.right, result);\n                }\n                return result;\n            }\n\n            inorder(node = this.root, result = []) {\n                if (node) {\n                    this.inorder(node.left, result);\n                    result.push(node.value);\n                    this.inorder(node.right, result);\n                }\n                return result;\n            }\n\n            postorder(node = this.root, result = []) {\n                if (node) {\n                    this.postorder(node.left, result);\n                    this.postorder(node.right, result);\n                    result.push(node.value);\n                }\n                return result;\n            }\n\n            clear() {\n                this.root = null;\n            }\n        }\n\n        const tree = new BinaryTree();\n        let nodePositions = new Map();\n\n        function insertNode() {\n            const valueInput = document.getElementById('nodeValue');\n            const value = parseInt(valueInput.value);\n            \n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            \n            tree.insert(value);\n            visualizeTree();\n            valueInput.value = '';\n        }\n\n        function deleteNode() {\n            const valueInput = document.getElementById('nodeValue');\n            const value = parseInt(valueInput.value);\n            \n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            \n            tree.delete(value);\n            visualizeTree();\n            valueInput.value = '';\n        }\n\n        function preorderTraversal() {\n            const result = tree.preorder();\n            document.getElementById('traversalResult').textContent = \n                `Preorder Traversal: [${result.join(', ')}]`;\n        }\n\n        function inorderTraversal() {\n            const result = tree.inorder();\n            document.getElementById('traversalResult').textContent = \n                `Inorder Traversal: [${result.join(', ')}]`;\n        }\n\n        function postorderTraversal() {\n            const result = tree.postorder();\n            document.getElementById('traversalResult').textContent = \n                `Postorder Traversal: [${result.join(', ')}]`;\n        }\n\n        function clearTree() {\n            tree.clear();\n            visualizeTree();\n            document.getElementById('traversalResult').textContent = '';\n        }\n\n        function calculatePositions(node, level, pos, positions) {\n            if (!node) return;\n            \n            const x = pos * 80 + 50;\n            const y = level * 80 + 50;\n            \n            positions.set(node, {x, y, value: node.value});\n            \n            const spread = Math.pow(2, 5 - level);\n            \n            if (node.left) {\n                calculatePositions(node.left, level + 1, pos - spread/2, positions);\n            }\n            if (node.right) {\n                calculatePositions(node.right, level + 1, pos + spread/2, positions);\n            }\n        }\n\n        function visualizeTree() {\n            const canvas = document.getElementById('treeCanvas');\n            canvas.innerHTML = '';\n            nodePositions.clear();\n            \n            if (!tree.root) return;\n            \n            // Calculate positions for all nodes\n            calculatePositions(tree.root, 0, Math.pow(2, 5), nodePositions);\n            \n            // Draw lines first (so they appear behind nodes)\n            nodePositions.forEach((position, node) => {\n                if (node.left && nodePositions.has(node.left)) {\n                    const leftPos = nodePositions.get(node.left);\n                    drawLine(position.x, position.y, leftPos.x, leftPos.y);\n                }\n                if (node.right && nodePositions.has(node.right)) {\n                    const rightPos = nodePositions.get(node.right);\n                    drawLine(position.x, position.y, rightPos.x, rightPos.y);\n                }\n            });\n            \n            // Draw nodes\n            nodePositions.forEach((position) => {\n                drawNode(position.x, position.y, position.value);\n            });\n        }\n\n        function drawNode(x, y, value) {\n            const canvas = document.getElementById('treeCanvas');\n            const node = document.createElement('div');\n            node.className = 'node';\n            node.textContent = value;\n            node.style.left = (x - 20) + 'px';\n            node.style.top = (y - 20) + 'px';\n            canvas.appendChild(node);\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const canvas = document.getElementById('treeCanvas');\n            const line = document.createElement('div');\n            line.className = 'line';\n            \n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            \n            line.style.width = length + 'px';\n            line.style.left = x1 + 'px';\n            line.style.top = y1 + 'px';\n            line.style.transform = `rotate(${angle}deg)`;\n            \n            canvas.appendChild(line);\n        }\n\n        // Initialize with some sample nodes\n        tree.insert(10);\n        tree.insert(5);\n        tree.insert(15);\n        tree.insert(3);\n        tree.insert(7);\n        tree.insert(12);\n        tree.insert(18);\n        visualizeTree();\n\n        document.getElementById('nodeValue').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                insertNode();\n            }\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}