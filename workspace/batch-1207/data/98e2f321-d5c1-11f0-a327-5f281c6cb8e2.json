{
  "id": "98e2f321-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:32.648Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>K-Means Clustering Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; background: #f6f7fb; color: #111; }\n    header { padding: 18px 22px; background: linear-gradient(90deg,#2f3e8f,#5b79d8); color: white; }\n    header h1 { margin: 0; font-size: 20px; }\n    main { display: flex; gap: 12px; padding: 14px; }\n    #controls { width: 360px; background: white; border-radius: 8px; padding: 12px; box-shadow: 0 6px 18px rgba(20,30,80,0.08); }\n    .section { margin-bottom: 12px; }\n    label { display:block; font-size: 13px; margin-bottom:6px; color:#333;}\n    input[type=range] { width: 100%; }\n    input[type=number], select, button { font-size: 13px; padding: 6px 8px; border-radius: 6px; border: 1px solid #ccd6ee; }\n    button { background: #2f3e8f; color: white; cursor: pointer; }\n    button.secondary { background: white; color: #2f3e8f; border: 1px solid #cdd7fb; }\n    button.small { padding: 6px 10px; font-size: 13px; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .compact { display:flex; gap:8px; }\n    #canvasWrap { flex: 1; display:flex; flex-direction: column; gap:8px; align-items:stretch; }\n    #canvas { background: linear-gradient(180deg, #ffffff, #f3f7ff); border-radius: 8px; box-shadow: 0 6px 18px rgba(20,30,80,0.06); cursor: crosshair; }\n    .stats { display:flex; gap:10px; align-items:center; font-size: 13px; color:#333; }\n    .muted { color:#6b7280; font-size: 13px; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); display:inline-block; vertical-align: middle; }\n    footer { padding: 10px 18px; font-size: 13px; color:#444; text-align:center; }\n    .hint { font-size:12px; color:#666; margin-top:6px; }\n    .control-row { display:flex; gap:8px; align-items:center; margin-top:6px; }\n    #pointsCount{width:80px;}\n    .small-muted { font-size: 12px; color: #666; }\n    .center-info { font-size: 12px; color:#333; margin-top:6px; max-height:120px; overflow:auto; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>K-Means Clustering — Interactive Visualization</h1>\n  </header>\n\n  <main>\n    <div id=\"controls\">\n      <div class=\"section\">\n        <label>Dataset</label>\n        <div class=\"row\">\n          <select id=\"dataType\">\n            <option value=\"random\">Uniform random</option>\n            <option value=\"blobs\" selected>Gaussian blobs</option>\n            <option value=\"ring\">Ring + noise</option>\n          </select>\n          <input id=\"pointsCount\" type=\"number\" min=\"5\" max=\"2000\" value=\"200\" title=\"Number of points\">\n          <button id=\"generate\" class=\"small\">Generate</button>\n        </div>\n        <div class=\"hint\">Click on canvas to add a point. Drag points to move them.</div>\n      </div>\n\n      <div class=\"section\">\n        <label>Algorithm</label>\n        <div class=\"row\">\n          <label style=\"margin:0;\">k: <strong id=\"kDisplay\">4</strong></label>\n          <input id=\"kRange\" type=\"range\" min=\"1\" max=\"12\" value=\"4\">\n        </div>\n        <div style=\"margin-top:8px;\">\n          <select id=\"initMethod\">\n            <option value=\"random\">Random initialization</option>\n            <option value=\"kmeans++\" selected>K-Means++</option>\n          </select>\n          <select id=\"distanceMetric\" style=\"margin-left:8px; display:none;\">\n            <option>Euclidean</option>\n          </select>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <label>Control</label>\n        <div class=\"compact\" style=\"margin-bottom:8px;\">\n          <button id=\"play\" class=\"small\">Run</button>\n          <button id=\"step\" class=\"small secondary\">Step</button>\n          <button id=\"reset\" class=\"small secondary\">Reset</button>\n          <button id=\"clear\" class=\"small secondary\">Clear Points</button>\n        </div>\n        <div class=\"control-row\">\n          <label style=\"margin:0;\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"2000\" value=\"400\">\n          <label id=\"speedLbl\" class=\"small-muted\">400 ms / it</label>\n        </div>\n        <div class=\"control-row\">\n          <label style=\"margin:0;\">Max Iter</label>\n          <input id=\"maxIter\" type=\"number\" min=\"1\" max=\"1000\" value=\"100\" style=\"width:80px;\">\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <label>Info</label>\n        <div class=\"stats\">\n          <div class=\"muted\">Iteration:</div><div id=\"iter\">0</div>\n          <div class=\"muted\">SSE (inertia):</div><div id=\"sse\">0.00</div>\n          <div class=\"muted\">Converged:</div><div id=\"converged\">—</div>\n        </div>\n        <div class=\"hint\">SSE = sum of squared distances of points to their cluster center (lower is better).</div>\n      </div>\n\n      <div class=\"section\">\n        <label>Cluster Centers</label>\n        <div id=\"centers\" class=\"center-info muted\">No centers yet.</div>\n      </div>\n\n      <div class=\"section\">\n        <div class=\"muted\">Tips:</div>\n        <ul style=\"margin:6px 0 0 18px; padding:0; color:#444; font-size:13px;\">\n          <li>Use K-Means++ for smarter initialization.</li>\n          <li>Empty clusters may occur — they get reinitialized automatically.</li>\n          <li>Try different k and datasets to see behavior.</li>\n        </ul>\n      </div>\n    </div>\n\n    <div id=\"canvasWrap\">\n      <canvas id=\"canvas\" width=\"900\" height=\"620\"></canvas>\n      <div class=\"legend\" id=\"legend\"></div>\n    </div>\n  </main>\n\n  <footer>Interactive K-Means demo • Click points to add • Drag to move • Press Run to animate</footer>\n\n<script>\n/*\n  K-Means Interactive Demo\n  - Single-file HTML + JavaScript\n  - Supports random and k-means++ initializations\n  - Step-by-step iteration, Play/Pause, step, reset\n  - Add and drag points on canvas\n  - Shows SSE, iteration count, and centers\n*/\n\n(() => {\n  // Basic utilities\n  function rand(min=0,max=1){ return Math.random()*(max-min)+min; }\n  function randint(a,b){ return Math.floor(rand(a,b+1)); }\n  function distance2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n\n  // Canvas and UI elements\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const kRange = document.getElementById('kRange');\n  const kDisplay = document.getElementById('kDisplay');\n  const generateBtn = document.getElementById('generate');\n  const dataType = document.getElementById('dataType');\n  const pointsCountInput = document.getElementById('pointsCount');\n  const playBtn = document.getElementById('play');\n  const stepBtn = document.getElementById('step');\n  const resetBtn = document.getElementById('reset');\n  const clearBtn = document.getElementById('clear');\n  const speedSlider = document.getElementById('speed');\n  const speedLbl = document.getElementById('speedLbl');\n  const maxIterInput = document.getElementById('maxIter');\n  const iterLabel = document.getElementById('iter');\n  const sseLabel = document.getElementById('sse');\n  const convergedLabel = document.getElementById('converged');\n  const centersDiv = document.getElementById('centers');\n  const initMethod = document.getElementById('initMethod');\n  const legendDiv = document.getElementById('legend');\n\n  let width = canvas.width, height = canvas.height;\n\n  // Data structures\n  let points = []; // {x,y, cluster}\n  let centers = []; // {x,y, oldX, oldY}\n  let k = parseInt(kRange.value);\n  let running = false;\n  let iter = 0;\n  let maxIter = parseInt(maxIterInput.value);\n  let playTimer = null;\n  let converged = false;\n  let colors = [];\n\n  // Parameters\n  function updateParamsFromUI(){\n    k = parseInt(kRange.value);\n    kDisplay.textContent = k;\n    maxIter = parseInt(maxIterInput.value) || 100;\n    speedLbl.textContent = speedSlider.value + \" ms / it\";\n  }\n  updateParamsFromUI();\n\n  // Color generation for clusters (HSL)\n  function colorForIndex(i){\n    const hue = Math.floor((i*360/k) % 360);\n    return `hsl(${hue} 80% 50%)`;\n  }\n  function updateColors(){\n    colors = [];\n    for(let i=0;i<Math.max(k,1);i++) colors.push(colorForIndex(i));\n    renderLegend();\n  }\n  function renderLegend(){\n    legendDiv.innerHTML = '';\n    for(let i=0;i<Math.min(colors.length,12);i++){\n      const el = document.createElement('div');\n      el.style.display = 'flex';\n      el.style.alignItems = 'center';\n      el.style.gap = '6px';\n      el.innerHTML = `<span class=\"swatch\" style=\"background:${colors[i]};\"></span><span style=\"font-size:13px;color:#333\">Cluster ${i+1}</span>`;\n      legendDiv.appendChild(el);\n    }\n  }\n\n  // Dataset generation\n  function generateDataset(){\n    const n = clamp(parseInt(pointsCountInput.value) || 200, 1, 2000);\n    const type = dataType.value;\n    points = [];\n    if(type === 'random'){\n      for(let i=0;i<n;i++){\n        points.push({x: rand(30, width-30), y: rand(30, height-30), cluster: -1});\n      }\n    } else if(type === 'blobs'){\n      // choose 3-6 blob centers\n      const blobs = randint(3,6);\n      const centersBlob = [];\n      for(let b=0;b<blobs;b++){\n        centersBlob.push({x: rand(80,width-80), y: rand(80,height-80), spread: rand(20,70)});\n      }\n      for(let i=0;i<n;i++){\n        const b = centersBlob[randint(0, blobs-1)];\n        const angle = rand(0,Math.PI*2);\n        const r = Math.abs(randn()) * b.spread;\n        points.push({x: clamp(b.x + Math.cos(angle)*r, 5, width-5), y: clamp(b.y + Math.sin(angle)*r, 5, height-5), cluster: -1});\n      }\n    } else if(type === 'ring'){\n      // One ring cluster + random noise\n      const ringCenter = {x: width/2 + rand(-60,60), y: height/2 + rand(-40,40)};\n      const radius = Math.min(width,height)/4;\n      for(let i=0;i<n;i++){\n        if(Math.random() < 0.75){\n          const ang = rand(0,Math.PI*2);\n          const r = radius + randn()*18;\n          points.push({x: clamp(ringCenter.x + Math.cos(ang)*r, 5, width-5), y: clamp(ringCenter.y + Math.sin(ang)*r, 5, height-5), cluster: -1});\n        } else {\n          points.push({x: rand(10,width-10), y: rand(10,height-10), cluster: -1});\n        }\n      }\n    }\n    iter = 0;\n    converged = false;\n    centers = [];\n    updateColors();\n    computeSSELabel();\n    draw();\n  }\n\n  // Normal(ish) random for blobs\n  function randn(){\n    // Box-Muller\n    let u=0,v=0;\n    while(u===0) u=Math.random();\n    while(v===0) v=Math.random();\n    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);\n  }\n\n  // Initialize centers (random or kmeans++)\n  function initCenters(){\n    centers = [];\n    updateColors();\n    if(k <= 0) return;\n    if(initMethod.value === 'random'){\n      // pick k random points from canvas space (not necessarily existing points)\n      for(let i=0;i<k;i++){\n        centers.push({x: rand(20,width-20), y: rand(20,height-20), oldX: null, oldY: null});\n      }\n    } else {\n      // k-means++ initialization: choose centers from points probabilistically\n      if(points.length === 0){\n        for(let i=0;i<k;i++) centers.push({x: rand(20,width-20), y: rand(20,height-20), oldX:null, oldY:null});\n      } else {\n        // copy points array for distances\n        // 1. choose first center uniformly from points\n        const first = points[randint(0, points.length-1)];\n        centers.push({x:first.x, y:first.y, oldX:null, oldY:null});\n        // choose remaining\n        while(centers.length < k){\n          // compute d^2 to nearest chosen center for each point\n          const d2 = points.map(p => {\n            let minD = Infinity;\n            for(const c of centers){\n              const dd = distance2(p, c);\n              if(dd < minD) minD = dd;\n            }\n            return minD;\n          });\n          // sum\n          const sum = d2.reduce((a,b)=>a+b,0);\n          if(sum === 0){\n            // all points coincide — pick random\n            const p = points[randint(0,points.length-1)];\n            centers.push({x:p.x, y:p.y, oldX:null, oldY:null});\n            continue;\n          }\n          // pick random with probability proportional to d2\n          let r = Math.random()*sum;\n          let idx = 0;\n          while(r > 0 && idx < d2.length){\n            r -= d2[idx];\n            idx++;\n          }\n          idx = clamp(idx-1, 0, points.length-1);\n          const chosen = points[idx];\n          centers.push({x: chosen.x, y: chosen.y, oldX:null, oldY:null});\n        }\n      }\n    }\n    // if k > points, may still have centers created at random positions\n    draw();\n  }\n\n  // Assignment step: assign each point to nearest center\n  function assignPoints(){\n    if(centers.length === 0) return false;\n    let changed = false;\n    for(const p of points){\n      let best = -1, bestD = Infinity;\n      for(let i=0;i<centers.length;i++){\n        const d = distance2(p, centers[i]);\n        if(d < bestD){ bestD = d; best = i; }\n      }\n      if(p.cluster !== best){\n        changed = true;\n        p.cluster = best;\n      }\n    }\n    return changed;\n  }\n\n  // Update step: move centers to mean of assigned points\n  function updateCenters(){\n    const sums = new Array(centers.length).fill(0).map(()=>({x:0,y:0,count:0}));\n    for(const p of points){\n      if(p.cluster>=0 && p.cluster < centers.length){\n        sums[p.cluster].x += p.x;\n        sums[p.cluster].y += p.y;\n        sums[p.cluster].count += 1;\n      }\n    }\n    let anyMoved = false;\n    for(let i=0;i<centers.length;i++){\n      const c = centers[i];\n      c.oldX = c.x; c.oldY = c.y;\n      const s = sums[i];\n      if(s.count === 0){\n        // Empty cluster: reinitialize to random point or random location\n        if(points.length > 0){\n          const pick = points[randint(0, points.length-1)];\n          c.x = pick.x + randn()*6;\n          c.y = pick.y + randn()*6;\n        } else {\n          c.x = rand(20, width-20);\n          c.y = rand(20, height-20);\n        }\n      } else {\n        c.x = s.x / s.count;\n        c.y = s.y / s.count;\n      }\n      if(distance2(c, {x:c.oldX,y:c.oldY}) > 1e-6) anyMoved = true;\n    }\n    return anyMoved;\n  }\n\n  // Compute SSE\n  function computeSSE(){\n    let sse = 0;\n    for(const p of points){\n      if(p.cluster >= 0 && p.cluster < centers.length){\n        sse += distance2(p, centers[p.cluster]);\n      } else {\n        // not assigned -> ignore\n      }\n    }\n    return sse;\n  }\n\n  function computeSSELabel(){\n    const sse = computeSSE();\n    sseLabel.textContent = sse.toFixed(2);\n  }\n\n  // A single iteration: assign + update\n  function iterateOnce(){\n    if(centers.length === 0) initCenters();\n    iter++;\n    iterLabel.textContent = iter;\n    const changedAssign = assignPoints();\n    const moved = updateCenters();\n    computeSSELabel();\n    draw();\n    // converged if no assignment changed and centers did not move\n    converged = !changedAssign && !moved;\n    convergedLabel.textContent = converged ? 'Yes' : 'No';\n    if(converged || iter >= maxIter) {\n      stop();\n    }\n    updateCenterDisplay();\n  }\n\n  // Control functions\n  function play(){\n    if(running) return;\n    running = true;\n    playBtn.textContent = 'Pause';\n    // ensure centers initialized\n    if(centers.length === 0) initCenters();\n    if(iter === 0){\n      // do one step so UI shows progress quickly\n      // but don't auto-stop before starting\n    }\n    const stepFunc = () => {\n      if(!running) return;\n      if(iter >= maxIter || converged) { stop(); return; }\n      iterateOnce();\n    };\n    // immediate first step\n    stepFunc();\n    playTimer = setInterval(stepFunc, parseInt(speedSlider.value));\n  }\n\n  function stop(){\n    running = false;\n    playBtn.textContent = 'Run';\n    if(playTimer){ clearInterval(playTimer); playTimer = null; }\n  }\n\n  function reset(){\n    stop();\n    iter = 0;\n    iterLabel.textContent = 0;\n    converged = false;\n    convergedLabel.textContent = '—';\n    // clear cluster assignments but keep points\n    for(const p of points) p.cluster = -1;\n    centers = [];\n    updateColors();\n    computeSSELabel();\n    updateCenterDisplay();\n    draw();\n  }\n\n  // UI event wiring\n  kRange.addEventListener('input', () => {\n    updateParamsFromUI();\n    updateColors();\n    updateCenterDisplay();\n    draw();\n  });\n  pointsCountInput.addEventListener('change', ()=>{ /* nothing */ });\n  generateBtn.addEventListener('click', ()=>{\n    reset();\n    generateDataset();\n  });\n  initMethod.addEventListener('change', ()=>{ reset(); });\n  playBtn.addEventListener('click', ()=>{ if(running) stop(); else play(); });\n  stepBtn.addEventListener('click', ()=>{\n    stop();\n    if(centers.length === 0) initCenters();\n    iterateOnce();\n  });\n  resetBtn.addEventListener('click', reset);\n  clearBtn.addEventListener('click', ()=>{\n    stop();\n    points = [];\n    centers = [];\n    iter = 0;\n    iterLabel.textContent = 0;\n    computeSSELabel();\n    updateCenterDisplay();\n    draw();\n  });\n  speedSlider.addEventListener('input', ()=>{ speedLbl.textContent = speedSlider.value + \" ms / it\"; if(playTimer){ clearInterval(playTimer); playTimer = setInterval(() => { if(running) iterateOnce(); }, parseInt(speedSlider.value)); }});\n  maxIterInput.addEventListener('change', ()=>{ maxIter = parseInt(maxIterInput.value) || 100; });\n\n  // Mouse interactions for adding and dragging points\n  let draggingPoint = null;\n  let dragOffset = {x:0,y:0};\n\n  function findPointAt(x,y, radius=8){\n    for(let i=points.length-1;i>=0;i--){ // topmost\n      const p = points[i];\n      const dx = p.x - x, dy = p.y - y;\n      if(dx*dx + dy*dy <= radius*radius) return p;\n    }\n    return null;\n  }\n\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    const p = findPointAt(x,y);\n    if(p){\n      draggingPoint = p;\n      dragOffset.x = p.x - x;\n      dragOffset.y = p.y - y;\n      canvas.style.cursor = 'grabbing';\n      stop();\n    } else {\n      // add new point\n      const newP = {x: clamp(x, 2, width-2), y: clamp(y, 2, height-2), cluster: -1};\n      points.push(newP);\n      computeSSELabel();\n      draw();\n    }\n  });\n\n  window.addEventListener('mousemove', (e) => {\n    if(!draggingPoint) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    draggingPoint.x = clamp(x + dragOffset.x, 2, width-2);\n    draggingPoint.y = clamp(y + dragOffset.y, 2, height-2);\n    // optionally reassign on the fly for a live feel\n    draw();\n  });\n\n  window.addEventListener('mouseup', (e) => {\n    if(draggingPoint){\n      draggingPoint = null;\n      canvas.style.cursor = 'crosshair';\n      computeSSELabel();\n      draw();\n    }\n  });\n\n  // Display centers info\n  function updateCenterDisplay(){\n    if(centers.length === 0){\n      centersDiv.textContent = 'No centers yet.';\n      return;\n    }\n    let html = '';\n    for(let i=0;i<centers.length;i++){\n      const c = centers[i];\n      const pts = points.filter(p => p.cluster === i);\n      html += `<div style=\"display:flex;gap:6px;align-items:center;margin-bottom:6px;\">\n        <span class=\"swatch\" style=\"background:${colors[i]}; width:12px;height:12px;\"></span>\n        <div style=\"font-size:13px;color:#222;\">\n          <strong>Cluster ${i+1}</strong> — (${c.x.toFixed(1)}, ${c.y.toFixed(1)}) — ${pts.length} pts\n        </div>\n      </div>`;\n    }\n    centersDiv.innerHTML = html;\n  }\n\n  // Rendering\n  function draw(){\n    ctx.clearRect(0,0,width,height);\n\n    // background grid\n    ctx.save();\n    ctx.fillStyle = '#f7f9ff';\n    ctx.fillRect(0,0,width,height);\n    ctx.restore();\n\n    // draw Voronoi-like colored point fills (optional) - we'll draw semi-transparent fills per cluster for better visuals\n    if(centers.length > 0){\n      // paint approximate cluster regions by drawing many translucent circles around centers (cheap approximation)\n      for(let i=0;i<centers.length;i++){\n        ctx.beginPath();\n        ctx.fillStyle = hexToRGBA(colors[i], 0.04);\n        ctx.arc(centers[i].x, centers[i].y, 120, 0, Math.PI*2);\n        ctx.fill();\n      }\n    }\n\n    // draw points\n    for(const p of points){\n      const col = (p.cluster >= 0 && p.cluster < colors.length) ? colors[p.cluster] : '#999';\n      ctx.beginPath();\n      ctx.fillStyle = col;\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.lineWidth = 1;\n      ctx.moveTo(p.x, p.y);\n      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n    }\n\n    // draw centers (with motion trail)\n    for(let i=0;i<centers.length;i++){\n      const c = centers[i];\n      // draw line from old pos -> new pos to show movement\n      if(c.oldX !== null && (Math.abs(c.oldX-c.x) > 0.01 || Math.abs(c.oldY-c.y) > 0.01)){\n        ctx.beginPath();\n        ctx.strokeStyle = hexToRGBA(colors[i], 0.6);\n        ctx.lineWidth = 2;\n        ctx.setLineDash([6,4]);\n        ctx.moveTo(c.oldX, c.oldY);\n        ctx.lineTo(c.x, c.y);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n      // center marker\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = colors[i];\n      ctx.lineWidth = 2.5;\n      ctx.arc(c.x, c.y, 9, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = '#222';\n      ctx.font = '12px system-ui, Arial';\n      ctx.fillText((i+1).toString(), c.x-4, c.y+4);\n    }\n  }\n\n  // tiny helper to convert HSL/CSS color into rgba with alpha\n  function hexToRGBA(cssColor, alpha){\n    // assume hsl(...) or rgb(...) or hex; just return css with alpha if hsl present\n    if(cssColor.startsWith('hsl')){\n      // convert to rgba by inserting alpha\n      return cssColor.replace('hsl','hsla').replace(')', `, ${alpha})`);\n    } else {\n      // fallback: return as-is with globalAlpha through fillStyle wrapper\n      // We'll use canvas globalAlpha as workaround (but we need a color); return color string\n      // For simplicity, convert hex (#rrggbb) to rgba if provided\n      const m = cssColor.match(/^#?([0-9a-f]{6})$/i);\n      if(m){\n        const v = m[1];\n        const r = parseInt(v.substring(0,2),16);\n        const g = parseInt(v.substring(2,4),16);\n        const b = parseInt(v.substring(4,6),16);\n        return `rgba(${r},${g},${b},${alpha})`;\n      }\n      return cssColor;\n    }\n  }\n\n  // Setup initial dataset\n  generateDataset();\n\n  // Expose some keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      if(running) stop(); else play();\n    } else if(e.key === 'r' || e.key === 'R'){\n      reset();\n    } else if(e.key === 'g' || e.key === 'G'){\n      generateBtn.click();\n    }\n  });\n\n  // Initialize center UI values\n  updateColors();\n  updateCenterDisplay();\n  draw();\n\n  // Start with kmeans++ initialization for convenience\n  initCenters();\n\n  // Resize handling to support device pixel ratio (crisp canvas)\n  function adjustCanvasForDPR(){\n    const dpr = window.devicePixelRatio || 1;\n    const rect = canvas.getBoundingClientRect();\n    width = Math.floor(rect.width);\n    height = Math.floor(rect.height);\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    draw();\n  }\n  // ensure consistent size by matching initial attributes\n  (function initCanvasSize(){\n    // already set by attributes; place a small refresh\n    const rect = canvas.getBoundingClientRect();\n    width = canvas.width; height = canvas.height;\n    draw();\n  })();\n\n  // Window resize - keep canvas pixel size fixed as defined\n  window.addEventListener('resize', () => {\n    // ignore for simplicity; the canvas has fixed dimensions\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}