{
  "id": "6b014631-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:31:07.470Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            max-width: 900px;\n            margin: 0 auto;\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .description {\n            margin-bottom: 20px;\n            line-height: 1.6;\n        }\n        .control-panel {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 10px;\n            flex-wrap: wrap;\n        }\n        button {\n            padding: 8px 16px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        input, select {\n            padding: 8px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .visualization {\n            display: flex;\n            justify-content: space-between;\n            margin-top: 20px;\n        }\n        .graph-container, .result-container {\n            width: 48%;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            padding: 10px;\n            min-height: 300px;\n        }\n        .result-container {\n            overflow-y: auto;\n        }\n        .node {\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background-color: #4CAF50;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            cursor: pointer;\n        }\n        .edge {\n            position: absolute;\n            height: 2px;\n            background-color: #333;\n            pointer-events: none;\n        }\n        .arrow {\n            position: absolute;\n            width: 0;\n            height: 0;\n            border-left: 6px solid transparent;\n            border-right: 6px solid transparent;\n            border-top: 10px solid #333;\n        }\n        .step {\n            margin: 5px 0;\n            padding: 5px;\n            border-radius: 4px;\n        }\n        .current-step {\n            background-color: #e8f4fd;\n            font-weight: bold;\n        }\n        label {\n            display: inline-block;\n            margin-right: 5px;\n        }\n        .error {\n            color: red;\n            margin-top: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Topological Sort Visualization</h1>\n        \n        <div class=\"description\">\n            <p>Topological sort is an algorithm that orders the nodes in a directed acyclic graph (DAG) such that for every directed edge from node A to node B, node A appears before node B in the ordering.</p>\n            <p>Use this tool to visualize the topological sorting process. You can either use a predefined graph or create your own by adding nodes and edges.</p>\n        </div>\n        \n        <div class=\"control-panel\">\n            <button id=\"addNodeBtn\">Add Node</button>\n            <button id=\"addEdgeBtn\">Add Edge</button>\n            <button id=\"resetBtn\">Reset</button>\n            <button id=\"topologicalSortBtn\">Run Topological Sort</button>\n            <button id=\"nextStepBtn\" disabled>Next Step</button>\n            <select id=\"presetGraphs\">\n                <option value=\"\">Select a preset graph</option>\n                <option value=\"linear\">Linear Dependencies</option>\n                <option value=\"tree\">Tree Structure</option>\n                <option value=\"complex\">Complex DAG</option>\n            </select>\n        </div>\n        \n        <div class=\"control-panel\">\n            <label for=\"nodeName\">Node Name:</label>\n            <input type=\"text\" id=\"nodeName\" placeholder=\"Enter node name\" maxlength=\"1\">\n            <label for=\"fromNode\">From Node:</label>\n            <select id=\"fromNode\"></select>\n            <label for=\"toNode\">To Node:</label>\n            <select id=\"toNode\"></select>\n        </div>\n        \n        <div id=\"errorMessage\" class=\"error\"></div>\n        \n        <div class=\"visualization\">\n            <div class=\"graph-container\" id=\"graphContainer\">\n                <!-- Graph will be drawn here -->\n            </div>\n            <div class=\"result-container\" id=\"resultContainer\">\n                <h3>Topological Order:</h3>\n                <div id=\"topologicalOrder\"></div>\n                <h3>Algorithm Steps:</h3>\n                <div id=\"algorithmSteps\"></div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        class Graph {\n            constructor() {\n                this.nodes = new Set();\n                this.adjacencyList = new Map();\n                this.inDegree = new Map();\n            }\n            \n            addNode(node) {\n                if (!this.nodes.has(node)) {\n                    this.nodes.add(node);\n                    this.adjacencyList.set(node, []);\n                    this.inDegree.set(node, 0);\n                }\n            }\n            \n            addEdge(from, to) {\n                if (this.nodes.has(from) && this.nodes.has(to)) {\n                    this.adjacencyList.get(from).push(to);\n                    this.inDegree.set(to, this.inDegree.get(to) + 1);\n                }\n            }\n            \n            // Kahn's algorithm for topological sort\n            topologicalSort() {\n                const result = [];\n                const steps = [];\n                const inDegreeCopy = new Map(this.inDegree);\n                const queue = [];\n                \n                // Initialize queue with nodes having in-degree 0\n                for (const node of this.nodes) {\n                    if (inDegreeCopy.get(node) === 0) {\n                        queue.push(node);\n                    }\n                }\n                \n                steps.push(\"Initialization: Added nodes with in-degree 0 to queue: \" + queue.join(\", \"));\n                \n                let stepCount = 1;\n                while (queue.length > 0) {\n                    const current = queue.shift();\n                    result.push(current);\n                    \n                    steps.push(`Step ${stepCount}: Processing node ${current}. Current topological order: [${result.join(\", \")}]`);\n                    \n                    // Reduce in-degree of neighbors\n                    for (const neighbor of this.adjacencyList.get(current)) {\n                        inDegreeCopy.set(neighbor, inDegreeCopy.get(neighbor) - 1);\n                        \n                        // If in-degree becomes 0, add to queue\n                        if (inDegreeCopy.get(neighbor) === 0) {\n                            queue.push(neighbor);\n                            steps.push(`  -> Node ${neighbor} now has in-degree 0, added to queue`);\n                        } else {\n                            steps.push(`  -> Node ${neighbor} in-degree reduced to ${inDegreeCopy.get(neighbor)}`);\n                        }\n                    }\n                    \n                    stepCount++;\n                }\n                \n                // Check for cycles\n                if (result.length !== this.nodes.size) {\n                    steps.push(\"Cycle detected! Graph is not a DAG.\");\n                    return { order: [], steps, hasCycle: true };\n                }\n                \n                steps.push(\"Topological sort completed successfully!\");\n                return { order: result, steps, hasCycle: false };\n            }\n        }\n\n        // Visualization controller\n        class TopologicalSortVisualizer {\n            constructor() {\n                this.graph = new Graph();\n                this.nodePositions = new Map();\n                this.nodeElements = new Map();\n                this.edgeElements = [];\n                this.currentStep = 0;\n                this.algorithmSteps = [];\n                \n                this.initializeEventListeners();\n                this.updateNodeSelects();\n            }\n            \n            initializeEventListeners() {\n                document.getElementById('addNodeBtn').addEventListener('click', () => this.addNode());\n                document.getElementById('addEdgeBtn').addEventListener('click', () => this.addEdge());\n                document.getElementById('resetBtn').addEventListener('click', () => this.reset());\n                document.getElementById('topologicalSortBtn').addEventListener('click', () => this.runTopologicalSort());\n                document.getElementById('nextStepBtn').addEventListener('click', () => this.nextStep());\n                document.getElementById('presetGraphs').addEventListener('change', (e) => this.loadPresetGraph(e.target.value));\n                \n                // Allow adding nodes by pressing Enter in the node name input\n                document.getElementById('nodeName').addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter') {\n                        this.addNode();\n                    }\n                });\n            }\n            \n            addNode() {\n                const nodeNameInput = document.getElementById('nodeName');\n                const nodeName = nodeNameInput.value.trim().toUpperCase();\n                \n                if (!nodeName) {\n                    this.showError(\"Please enter a node name\");\n                    return;\n                }\n                \n                if (this.graph.nodes.has(nodeName)) {\n                    this.showError(`Node ${nodeName} already exists`);\n                    return;\n                }\n                \n                this.graph.addNode(nodeName);\n                this.createNodeElement(nodeName);\n                this.updateNodeSelects();\n                nodeNameInput.value = '';\n                this.hideError();\n            }\n            \n            addEdge() {\n                const fromNode = document.getElementById('fromNode').value;\n                const toNode = document.getElementById('toNode').value;\n                \n                if (!fromNode || !toNode) {\n                    this.showError(\"Please select both from and to nodes\");\n                    return;\n                }\n                \n                if (fromNode === toNode) {\n                    this.showError(\"Cannot create an edge from a node to itself\");\n                    return;\n                }\n                \n                // Check if edge already exists\n                if (this.graph.adjacencyList.get(fromNode).includes(toNode)) {\n                    this.showError(`Edge from ${fromNode} to ${toNode} already exists`);\n                    return;\n                }\n                \n                this.graph.addEdge(fromNode, toNode);\n                this.createEdgeElement(fromNode, toNode);\n                this.hideError();\n            }\n            \n            createNodeElement(nodeName) {\n                const graphContainer = document.getElementById('graphContainer');\n                const node = document.createElement('div');\n                node.className = 'node';\n                node.id = `node-${nodeName}`;\n                node.textContent = nodeName;\n                \n                // Position nodes in a circular layout\n                const nodeCount = this.graph.nodes.size;\n                const angle = (2 * Math.PI * (nodeCount - 1)) / Math.max(6, nodeCount);\n                const radius = 150;\n                const centerX = graphContainer.offsetWidth / 2;\n                const centerY = graphContainer.offsetHeight / 2;\n                \n                const x = centerX + radius * Math.cos(angle) - 20;\n                const y = centerY + radius * Math.sin(angle) - 20;\n                \n                node.style.left = `${x}px`;\n                node.style.top = `${y}px`;\n                \n                graphContainer.appendChild(node);\n                this.nodeElements.set(nodeName, node);\n                this.nodePositions.set(nodeName, { x: x + 20, y: y + 20 }); // Center of the node\n            }\n            \n            createEdgeElement(fromNode, toNode) {\n                const graphContainer = document.getElementById('graphContainer');\n                const fromPos = this.nodePositions.get(fromNode);\n                const toPos = this.nodePositions.get(toNode);\n                \n                if (!fromPos || !toPos) return;\n                \n                // Calculate edge line\n                const dx = toPos.x - fromPos.x;\n                const dy = toPos.y - fromPos.y;\n                const length = Math.sqrt(dx * dx + dy * dy);\n                const angle = Math.atan2(dy, dx);\n                \n                // Create line element\n                const line = document.createElement('div');\n                line.className = 'edge';\n                line.style.width = `${length}px`;\n                line.style.left = `${fromPos.x}px`;\n                line.style.top = `${fromPos.y}px`;\n                line.style.transform = `rotate(${angle}rad)`;\n                line.style.transformOrigin = '0 0';\n                \n                // Create arrowhead\n                const arrow = document.createElement('div');\n                arrow.className = 'arrow';\n                arrow.style.left = `${toPos.x - 10 * Math.cos(angle)}px`;\n                arrow.style.top = `${toPos.y - 10 * Math.sin(angle)}px`;\n                arrow.style.transform = `rotate(${angle}rad)`;\n                \n                graphContainer.appendChild(line);\n                graphContainer.appendChild(arrow);\n                \n                this.edgeElements.push({ line, arrow, from: fromNode, to: toNode });\n            }\n            \n            updateNodeSelects() {\n                const fromNodeSelect = document.getElementById('fromNode');\n                const toNodeSelect = document.getElementById('toNode');\n                \n                // Clear options\n                fromNodeSelect.innerHTML = '';\n                toNodeSelect.innerHTML = '';\n                \n                // Add options for each node\n                for (const node of this.graph.nodes) {\n                    const option1 = document.createElement('option');\n                    option1.value = node;\n                    option1.textContent = node;\n                    fromNodeSelect.appendChild(option1);\n                    \n                    const option2 = document.createElement('option');\n                    option2.value = node;\n                    option2.textContent = node;\n                    toNodeSelect.appendChild(option2);\n                }\n            }\n            \n            runTopologicalSort() {\n                const result = this.graph.topologicalSort();\n                this.algorithmSteps = result.steps;\n                this.currentStep = 0;\n                \n                // Display the steps\n                const stepsContainer = document.getElementById('algorithmSteps');\n                stepsContainer.innerHTML = '';\n                \n                this.algorithmSteps.forEach((step, index) => {\n                    const stepElement = document.createElement('div');\n                    stepElement.className = 'step';\n                    stepElement.id = `step-${index}`;\n                    stepElement.textContent = step;\n                    stepsContainer.appendChild(stepElement);\n                });\n                \n                // Enable next step button\n                document.getElementById('nextStepBtn').disabled = false;\n                \n                // Reset node colors\n                this.resetNodeColors();\n                \n                // Highlight the first step\n                this.highlightStep(0);\n                \n                // Display result\n                const orderContainer = document.getElementById('topologicalOrder');\n                if (result.hasCycle) {\n                    orderContainer.innerHTML = '<span style=\"color: red;\">Cycle detected! Graph is not a DAG.</span>';\n                } else {\n                    orderContainer.textContent = result.order.join(' â†’ ');\n                }\n            }\n            \n            nextStep() {\n                if (this.currentStep < this.algorithmSteps.length - 1) {\n                    this.currentStep++;\n                    this.highlightStep(this.currentStep);\n                    \n                    // Extract node being processed from step text\n                    const stepText = this.algorithmSteps[this.currentStep];\n                    const match = stepText.match(/Processing node ([A-Z])/);\n                    if (match) {\n                        const node = match[1];\n                        this.highlightNode(node);\n                    }\n                }\n                \n                // Disable button if we've reached the last step\n                if (this.currentStep === this.algorithmSteps.length - 1) {\n                    document.getElementById('nextStepBtn').disabled = true;\n                }\n            }\n            \n            highlightStep(stepIndex) {\n                // Remove highlight from all steps\n                document.querySelectorAll('.step').forEach(step => {\n                    step.classList.remove('current-step');\n                });\n                \n                // Highlight current step\n                const currentStepElement = document.getElementById(`step-${stepIndex}`);\n                if (currentStepElement) {\n                    currentStepElement.classList.add('current-step');\n                    currentStepElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\n                }\n            }\n            \n            highlightNode(nodeName) {\n                // Reset all nodes to default color\n                this.resetNodeColors();\n                \n                // Highlight the current node\n                const nodeElement = this.nodeElements.get(nodeName);\n                if (nodeElement) {\n                    nodeElement.style.backgroundColor = '#2196F3';\n                }\n            }\n            \n            resetNodeColors() {\n                for (const nodeElement of this.nodeElements.values()) {\n                    nodeElement.style.backgroundColor = '#4CAF50';\n                }\n            }\n            \n            loadPresetGraph(preset) {\n                this.reset();\n                \n                switch(preset) {\n                    case 'linear':\n                        // A -> B -> C -> D\n                        this.graph.addNode('A');\n                        this.graph.addNode('B');\n                        this.graph.addNode('C');\n                        this.graph.addNode('D');\n                        this.graph.addEdge('A', 'B');\n                        this.graph.addEdge('B', 'C');\n                        this.graph.addEdge('C', 'D');\n                        break;\n                    \n                    case 'tree':\n                        //     A\n                        //    / \\\n                        //   B   C\n                        //  / \\   \\\n                        // D   E   F\n                        this.graph.addNode('A');\n                        this.graph.addNode('B');\n                        this.graph.addNode('C');\n                        this.graph.addNode('D');\n                        this.graph.addNode('E');\n                        this.graph.addNode('F');\n                        this.graph.addEdge('A', 'B');\n                        this.graph.addEdge('A', 'C');\n                        this.graph.addEdge('B', 'D');\n                        this.graph.addEdge('B', 'E');\n                        this.graph.addEdge('C', 'F');\n                        break;\n                    \n                    case 'complex':\n                        // A -> B -> D -> F\n                        // A -> C -> E -> F\n                        // B -> E\n                        this.graph.addNode('A');\n                        this.graph.addNode('B');\n                        this.graph.addNode('C');\n                        this.graph.addNode('D');\n                        this.graph.addNode('E');\n                        this.graph.addNode('F');\n                        this.graph.addEdge('A', 'B');\n                        this.graph.addEdge('A', 'C');\n                        this.graph.addEdge('B', 'D');\n                        this.graph.addEdge('B', 'E');\n                        this.graph.addEdge('C', 'E');\n                        this.graph.addEdge('D', 'F');\n                        this.graph.addEdge('E', 'F');\n                        break;\n                    \n                    default:\n                        return;\n                }\n                \n                // Create visualization for the preset graph\n                for (const node of this.graph.nodes) {\n                    this.createNodeElement(node);\n                }\n                \n                for (const [from, neighbors] of this.graph.adjacencyList.entries()) {\n                    for (const to of neighbors) {\n                        this.createEdgeElement(from, to);\n                    }\n                }\n"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}