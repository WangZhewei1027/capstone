{
  "id": "e93437c1-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:52.723Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Bellman-Ford Algorithm Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n<style>\n  :root {\n    --bg: #0f1724;\n    --panel: #0b1220;\n    --accent: #3b82f6;\n    --muted: #94a3b8;\n    --good: #16a34a;\n    --bad: #ef4444;\n    --yellow: #f59e0b;\n    --node-fill: #0ea5a4;\n    --node-stroke: #065f5c;\n    --edge: #cbd5e1;\n    --font: 14px/1.2 \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n  }\n  html,body { height:100%; margin:0; background:linear-gradient(180deg,#071027 0%, #071a2b 100%); font:var(--font); color:#e6eef8; }\n  .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n  .left {\n    flex:1;\n    min-width:380px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n    border-radius:8px;\n    padding:12px;\n    box-shadow: 0 6px 24px rgba(2,6,23,0.6);\n    display:flex;\n    flex-direction:column;\n    gap:8px;\n  }\n  .canvas-wrap {\n    flex:1;\n    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n    border-radius:6px;\n    position:relative;\n    overflow:hidden;\n  }\n  svg { width:100%; height:100%; touch-action: none; }\n  .controls {\n    display:flex;\n    gap:8px;\n    flex-wrap:wrap;\n    align-items:center;\n  }\n  .controls button, .controls select {\n    background:transparent;\n    color:var(--accent);\n    border:1px solid rgba(59,130,246,0.18);\n    padding:6px 8px;\n    border-radius:6px;\n    cursor:pointer;\n  }\n  .controls button.active { background:rgba(59,130,246,0.12); }\n  .controls label { color:var(--muted); font-size:13px; display:flex; gap:6px; align-items:center; }\n  .side {\n    width:360px;\n    min-width:280px;\n    max-width:420px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border-radius:8px;\n    padding:12px;\n    box-shadow: 0 6px 24px rgba(2,6,23,0.6);\n    overflow:auto;\n  }\n  h2 { margin:8px 0; font-size:16px; color:#fff; }\n  .legend { display:flex; gap:8px; flex-wrap:wrap; font-size:13px; color:var(--muted); }\n  .legend .item { display:flex; gap:6px; align-items:center; }\n  .badge { width:16px; height:12px; border-radius:3px; display:inline-block; }\n  .panel { background:rgba(255,255,255,0.02); padding:8px; border-radius:6px; margin-bottom:8px; }\n  .list { display:grid; gap:6px; max-height:220px; overflow:auto; padding-right:6px; }\n  .row { display:flex; justify-content:space-between; gap:8px; align-items:center; padding:6px; background:transparent; border-radius:6px; }\n  .row:hover { background:rgba(255,255,255,0.01); }\n  .node-label { display:flex; gap:8px; align-items:center; }\n  .small { font-size:13px; color:var(--muted); }\n  .log { font-family:monospace; font-size:12px; color:#dbeafe; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:8px; border-radius:6px; max-height:220px; overflow:auto; }\n  .footer { display:flex; justify-content:space-between; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; }\n  .btn-danger { border-color:rgba(239,68,68,0.18); color:var(--bad); }\n  input[type=\"number\"] { width:72px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); }\n  .info { font-size:13px; color:var(--muted); margin-bottom:6px; }\n  .distance { font-weight:700; font-size:12px; color:#fff; }\n  .small-muted { font-size:12px; color:var(--muted); }\n  .mode-instructions { color:var(--muted); font-size:13px; }\n  .preset { display:flex; gap:6px; }\n  a.link { color:var(--accent); text-decoration:none; }\n  @media (max-width:900px) { .app{flex-direction:column;} .side{width:100%;} }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"left\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center;gap:8px;\">\n      <div>\n        <h2>Bellman-Ford Visualizer</h2>\n        <div class=\"small-muted\">Build a directed graph (weights can be negative). Step through relaxations and detect negative cycles.</div>\n      </div>\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"badge\" style=\"background:var(--accent)\"></span><span class=\"small-muted\">UI Controls</span></div>\n        <div class=\"item\"><span class=\"badge\" style=\"background:var(--good)\"></span><span class=\"small-muted\">Improved</span></div>\n        <div class=\"item\"><span class=\"badge\" style=\"background:var(--yellow)\"></span><span class=\"small-muted\">Currently checking</span></div>\n        <div class=\"item\"><span class=\"badge\" style=\"background:var(--bad)\"></span><span class=\"small-muted\">Negative cycle</span></div>\n      </div>\n    </div>\n\n    <div class=\"controls\" style=\"margin-top:8px;\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"addEdgeBtn\">Add Edge</button>\n      <button id=\"selectBtn\" class=\"active\">Select/Move</button>\n      <button id=\"delBtn\" class=\"\">Delete</button>\n      <label title=\"Treat edges as undirected (adds opposite directed edge)\">\n        <input type=\"checkbox\" id=\"undirected\"> Undirected\n      </label>\n\n      <select id=\"sourceSelect\" title=\"Choose source vertex\">\n      </select>\n\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"iterBtn\">Next Iteration</button>\n      <button id=\"runBtn\">Run</button>\n      <button id=\"autoBtn\">Auto</button>\n      <button id=\"resetBtn\" class=\"btn-danger\">Reset</button>\n    </div>\n\n    <div class=\"canvas-wrap panel\" id=\"canvasWrap\">\n      <svg id=\"svgCanvas\" width=\"100%\" height=\"520\" viewBox=\"0 0 1200 520\" xmlns=\"http://www.w3.org/2000/svg\">\n        <defs>\n          <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"18\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#cbd5e1\" />\n          </marker>\n          <marker id=\"arrow-green\" markerWidth=\"10\" markerHeight=\"10\" refX=\"18\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#16a34a\" />\n          </marker>\n          <marker id=\"arrow-red\" markerWidth=\"10\" markerHeight=\"10\" refX=\"18\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#ef4444\" />\n          </marker>\n          <marker id=\"arrow-yellow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"18\" refY=\"5\" orient=\"auto\">\n            <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#f59e0b\" />\n          </marker>\n        </defs>\n        <g id=\"edgesLayer\"></g>\n        <g id=\"nodesLayer\"></g>\n      </svg>\n      <div style=\"position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,0.2);padding:6px;border-radius:6px;color:var(--muted);font-size:13px;\">\n        Mode: <span id=\"modeLabel\">Select/Move</span>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:8px;align-items:center;margin-top:8px;\">\n      <div class=\"small-muted\">Presets:</div>\n      <div class=\"preset\">\n        <button id=\"preset1\">Example 1</button>\n        <button id=\"preset2\">Negative Cycle</button>\n        <button id=\"clearBtn\">Clear</button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"side\">\n    <h2>Algorithm State</h2>\n    <div class=\"panel\">\n      <div class=\"info\">Source vertex:\n        <select id=\"sourceSelectSide\"></select>\n      </div>\n      <div style=\"display:flex;gap:8px;align-items:center;margin-bottom:6px;\">\n        <div class=\"small-muted\">Iteration:</div>\n        <div id=\"iterationDisplay\" class=\"distance\">0</div>\n        <div class=\"small-muted\">Edge index:</div>\n        <div id=\"edgeIndexDisplay\" class=\"distance\">0</div>\n      </div>\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <button id=\"markPathBtn\">Highlight Shortest Tree</button>\n        <button id=\"clearHighlights\">Clear Highlights</button>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small-muted\">Vertices</div>\n      <div class=\"list\" id=\"nodesList\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small-muted\">Edges</div>\n      <div class=\"list\" id=\"edgesList\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"small-muted\">Log</div>\n      <div class=\"log\" id=\"log\"></div>\n    </div>\n\n    <div class=\"footer\">\n      <div class=\"small-muted\">Tip: Add nodes on canvas. Click \"Add Edge\" then pick source & target to create an edge.</div>\n      <div style=\"font-size:12px;color:var(--muted)\">Bellman-Ford: O(VE)</div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\nBellman-Ford Visualizer\nAuthor: Generated by AI assistant\nFeatures:\n- Add/move/delete nodes and edges\n- Directed edges (optional undirected mode)\n- Step through each edge relaxation, iterate, run to completion, and auto-animation\n- Detect and highlight negative cycles\n- Show distances and predecessors\n*/\n\nconst svg = document.getElementById('svgCanvas');\nconst nodesLayer = document.getElementById('nodesLayer');\nconst edgesLayer = document.getElementById('edgesLayer');\n\nlet nodes = []; // {id, x, y}\nlet edges = []; // {id, from, to, w}\nlet nextNodeId = 0;\nlet nextEdgeId = 0;\n\nlet mode = 'select'; // 'select', 'addNode', 'addEdge', 'delete'\nlet addEdgeFrom = null;\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\nlet undirectedCheckbox = document.getElementById('undirected');\n\nconst addNodeBtn = document.getElementById('addNodeBtn');\nconst addEdgeBtn = document.getElementById('addEdgeBtn');\nconst selectBtn = document.getElementById('selectBtn');\nconst delBtn = document.getElementById('delBtn');\nconst sourceSelect = document.getElementById('sourceSelect');\nconst sourceSelectSide = document.getElementById('sourceSelectSide');\n\nconst stepBtn = document.getElementById('stepBtn');\nconst iterBtn = document.getElementById('iterBtn');\nconst runBtn = document.getElementById('runBtn');\nconst autoBtn = document.getElementById('autoBtn');\nconst resetBtn = document.getElementById('resetBtn');\nconst clearBtn = document.getElementById('clearBtn');\n\nconst nodesList = document.getElementById('nodesList');\nconst edgesList = document.getElementById('edgesList');\nconst logDiv = document.getElementById('log');\nconst iterationDisplay = document.getElementById('iterationDisplay');\nconst edgeIndexDisplay = document.getElementById('edgeIndexDisplay');\nconst modeLabel = document.getElementById('modeLabel');\nconst markPathBtn = document.getElementById('markPathBtn');\nconst clearHighlightsBtn = document.getElementById('clearHighlights');\n\nconst preset1 = document.getElementById('preset1');\nconst preset2 = document.getElementById('preset2');\n\nlet state = {\n  distances: {}, // id -> number (Infinity)\n  pred: {}, // id -> predecessor id or null\n  V: 0,\n  E: 0,\n  iter: 0,\n  edgeIndex: 0,\n  finished: true,\n  negativeCycle: false,\n  autoTimer: null,\n  running: false,\n};\n\nfunction log(msg) {\n  const d = new Date().toLocaleTimeString();\n  logDiv.innerHTML = `<div>[${d}] ${escapeHtml(msg)}</div>` + logDiv.innerHTML;\n}\nfunction escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }\n\nfunction setMode(m) {\n  mode = m;\n  addNodeBtn.classList.toggle('active', m==='addNode');\n  addEdgeBtn.classList.toggle('active', m==='addEdge');\n  selectBtn.classList.toggle('active', m==='select');\n  delBtn.classList.toggle('active', m==='delete');\n  modeLabel.textContent = m==='select' ? 'Select/Move' : m==='addNode' ? 'Add Node' : m==='addEdge' ? 'Add Edge' : 'Delete';\n}\n\naddNodeBtn.addEventListener('click', ()=>setMode('addNode'));\naddEdgeBtn.addEventListener('click', ()=>setMode('addEdge'));\nselectBtn.addEventListener('click', ()=>setMode('select'));\ndelBtn.addEventListener('click', ()=>setMode('delete'));\n\nsvg.addEventListener('mousedown', svgPointerDown);\nsvg.addEventListener('mousemove', svgPointerMove);\nsvg.addEventListener('mouseup', svgPointerUp);\nsvg.addEventListener('mouseleave', svgPointerUp);\n\nfunction svgPoint(evt){\n  const rect = svg.getBoundingClientRect();\n  const x = evt.clientX - rect.left;\n  const y = evt.clientY - rect.top;\n  return {x, y};\n}\n\nfunction svgPointerDown(evt){\n  const pt = svgPoint(evt);\n  if (mode === 'addNode') {\n    const id = addNode(pt.x, pt.y);\n    render();\n    updateLists();\n    setMode('select');\n    log(`Added node ${id}`);\n  } else if (mode === 'select') {\n    // check node hit\n    const node = nodeAt(pt);\n    if (node) {\n      dragging = node.id;\n      dragOffset.x = pt.x - node.x;\n      dragOffset.y = pt.y - node.y;\n    }\n  } else if (mode === 'addEdge') {\n    const node = nodeAt(pt);\n    if (node) {\n      if (!addEdgeFrom) {\n        addEdgeFrom = node.id;\n        modeLabel.textContent = 'Select target node for edge';\n      } else {\n        const to = node.id;\n        const from = addEdgeFrom;\n        const w = parseFloat(prompt(`Weight for edge ${from} → ${to} (can be negative):`, \"0\"));\n        if (!Number.isFinite(w)) {\n          alert('Invalid weight. Edge aborted.');\n        } else {\n          addEdge(from, to, w);\n          if (undirectedCheckbox.checked) addEdge(to, from, w);\n          log(`Added edge ${from} → ${to} (${w})`);\n        }\n        addEdgeFrom = null;\n        setMode('select');\n        render();\n        updateLists();\n      }\n    }\n  } else if (mode === 'delete') {\n    const node = nodeAt(pt);\n    if (node) {\n      if (confirm(`Delete node ${node.id} and its edges?`)) {\n        removeNode(node.id);\n        render();\n        updateLists();\n        log(`Deleted node ${node.id}`);\n      }\n    } else {\n      const e = edgeAt(pt);\n      if (e) {\n        if (confirm(`Delete edge ${e.from} → ${e.to} (w=${e.w})?`)) {\n          removeEdge(e.id);\n          render();\n          updateLists();\n          log(`Deleted edge ${e.id}`);\n        }\n      }\n    }\n  }\n}\n\nfunction svgPointerMove(evt){\n  if (dragging !== null) {\n    const pt = svgPoint(evt);\n    const node = nodes.find(n=>n.id===dragging);\n    if (node) {\n      node.x = Math.max(24, Math.min(1176, pt.x - dragOffset.x + 24*0)); // clamp on canvas\n      node.y = Math.max(24, Math.min(496, pt.y - dragOffset.y + 24*0));\n      render();\n      updateLists();\n    }\n  }\n}\nfunction svgPointerUp(evt){\n  dragging = null;\n}\n\nfunction nodeAt(pt) {\n  // nodes drawn as circle radius 22\n  for (let i = nodes.length-1; i>=0; i--) {\n    const n = nodes[i];\n    const dx = pt.x - n.x;\n    const dy = pt.y - n.y;\n    if (dx*dx+dy*dy <= 22*22) return n;\n  }\n  return null;\n}\nfunction edgeAt(pt) {\n  // approx: check distance to segment\n  for (let i = edges.length-1; i>=0; i--) {\n    const e = edges[i];\n    const a = nodes.find(n=>n.id===e.from);\n    const b = nodes.find(n=>n.id===e.to);\n    if (!a || !b) continue;\n    const d = pointToSegmentDistance(pt, a, b);\n    if (d < 8) return e;\n  }\n  return null;\n}\nfunction pointToSegmentDistance(p, a, b) {\n  const x = p.x, y = p.y;\n  const x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;\n  const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;\n  const dot = A*C + B*D;\n  const len_sq = C*C + D*D;\n  let param = -1;\n  if (len_sq !== 0) param = dot / len_sq;\n  let xx, yy;\n  if (param < 0) { xx = x1; yy = y1; }\n  else if (param > 1) { xx = x2; yy = y2; }\n  else { xx = x1 + param*C; yy = y1 + param*D; }\n  const dx = x - xx, dy = y - yy;\n  return Math.sqrt(dx*dx + dy*dy);\n}\n\n/* Graph modification functions */\nfunction addNode(x, y) {\n  const id = String(nextNodeId++);\n  nodes.push({id, x, y});\n  refreshSourceOptions();\n  return id;\n}\nfunction removeNode(id) {\n  nodes = nodes.filter(n => n.id !== id);\n  edges = edges.filter(e => e.from !== id && e.to !== id);\n  refreshSourceOptions();\n}\nfunction addEdge(from, to, w) {\n  const id = String(nextEdgeId++);\n  edges.push({id, from, to, w: Number(w)});\n  return id;\n}\nfunction removeEdge(id) {\n  edges = edges.filter(e => e.id !== id);\n}\n\n/* Rendering */\nfunction render() {\n  // clear\n  nodesLayer.innerHTML = '';\n  edgesLayer.innerHTML = '';\n\n  // Draw edges first\n  edges.forEach(e=>{\n    const a = nodes.find(n=>n.id===e.from);\n    const b = nodes.find(n=>n.id===e.to);\n    if (!a || !b) return;\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const len = Math.sqrt(dx*dx + dy*dy) || 1;\n    const ux = dx / len;\n    const uy = dy / len;\n    const r = 22;\n    const startX = a.x + ux*r;\n    const startY = a.y + uy*r;\n    const endX = b.x - ux*r;\n    const endY = b.y - uy*r;\n\n    // line\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('data-edge-id', e.id);\n\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1', startX);\n    line.setAttribute('y1', startY);\n    line.setAttribute('x2', endX);\n    line.setAttribute('y2', endY);\n    line.setAttribute('stroke', 'var(--edge)');\n    line.setAttribute('stroke-width', '2');\n    line.setAttribute('marker-end', 'url(#arrow)');\n    line.setAttribute('class','edge-line');\n    g.appendChild(line);\n\n    // weight label\n    const mx = (startX + endX) / 2;\n    const my = (startY + endY) / 2;\n    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n    txt.setAttribute('x', mx+6);\n    txt.setAttribute('y', my-6);\n    txt.setAttribute('fill', '#cbd5e1');\n    txt.setAttribute('font-size', '12');\n    txt.setAttribute('stroke', 'none');\n    txt.textContent = e.w;\n    g.appendChild(txt);\n\n    // arrow for undirected small offset for self-loops etc not handled\n    // click handler\n    g.addEventListener('click', (ev)=>{\n      ev.stopPropagation();\n      if (mode === 'delete') {\n        if (confirm(`Delete edge ${e.from} → ${e.to} (w=${e.w})?`)) {\n          removeEdge(e.id);\n          render();\n          updateLists();\n          log(`Deleted edge ${e.id}`);\n        }\n      } else {\n        // show properties\n        const newW = prompt(`Edit weight for edge ${e.from} → ${e.to}:`, String(e.w));\n        if (newW !== null) {\n          const v = Number(newW);\n          if (!Number.isFinite(v)) alert('Invalid weight.');\n          else {\n            e.w = v;\n            render();\n            updateLists();\n            log(`Edge ${e.from} → ${e.to} weight set to ${v}`);\n          }\n        }\n      }\n    });\n\n    edgesLayer.appendChild(g);\n  });\n\n  // Draw nodes\n  nodes.forEach(n=>{\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    g.setAttribute('data-node-id', n.id);\n\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r','22');\n    circle.setAttribute('fill','var(--node-fill)');\n    circle.setAttribute('stroke','var(--node-stroke)');\n    circle.setAttribute('stroke-width','2');\n    g.appendChild(circle);\n\n    const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n    label.setAttribute('x','0');\n    label.setAttribute('y','6');\n    label.setAttribute('text-anchor','middle');\n    label.setAttribute('fill','#001219');\n    label.setAttribute('font-weight','700');\n    label.setAttribute('font-size','13');\n    label.textContent = n.id;\n    g.appendChild(label);\n\n    const distLabel = document.createElementNS('http://www.w3.org/2000/svg','text');\n    distLabel.setAttribute('x','0');\n    distLabel.setAttribute('y','26');\n    distLabel.setAttribute('text-anchor','middle');\n    distLabel.setAttribute('fill','#e6eef8');\n    distLabel.setAttribute('font-size','11');\n    distLabel.setAttribute('class','dist-label');\n    const d = state.distances[n.id];\n    distLabel.textContent = d === undefined ? '' : (d === Infinity ? '∞' : d);\n    g.appendChild(distLabel);\n\n    g.addEventListener('mousedown', (ev)=>{\n      ev.stopPropagation();\n      if (mode === 'addEdge') {\n        if (!addEdgeFrom) {\n          addEdgeFrom = n.id;\n          modeLabel.textContent = 'Select target node for edge';\n        } else {\n          const to = n.id;\n          const from = addEdgeFrom;\n          const w = parseFloat(prompt(`Weight for edge ${from} → ${to} (can be negative):`, \"0\"));\n          if (!Number.isFinite(w)) {\n            alert('Invalid weight. Edge aborted.');\n          } else {\n            addEdge(from, to, w);\n            if (undirectedCheckbox.checked) addEdge(to, from, w);\n            log(`Added edge ${from} → ${to} (${w})`);\n          }\n          addEdgeFrom = null;\n          setMode('select');\n          render();\n          updateLists();\n        }\n      } else if (mode === 'delete') {\n        if (confirm(`Delete node ${n.id} and its edges?`)) {\n          removeNode(n.id);\n          render();\n          updateLists();\n          log(`Deleted node ${n.id}`);\n        }\n      } else {\n        // select / drag\n        dragging = n.id;\n        const pt = svgPoint(ev);\n        dragOffset.x = pt.x - n.x;\n        dragOffset.y = pt.y - n.y;\n      }\n    });\n\n    nodesLayer.appendChild(g);\n  });\n\n  // After drawing base, color edges according to algorithm state\n  // Look for edges that have temporary classes in state (we'll set dataset)\n  edgesLayer.querySelectorAll('g').forEach(g=>{\n    const eid = g.getAttribute('data-edge-id');\n    const e = edges.find(x=>x.id===eid);\n    if (!e) return;\n    const line = g.querySelector('line');\n    // default\n    line.setAttribute('stroke', 'var(--edge)');\n    line.setAttribute('marker-end', 'url(#arrow)');\n    // check if marked\n    const info = e._info || {};\n    if (info.type === 'checking') {\n      line.setAttribute('stroke', 'var(--yellow)');\n      line.setAttribute('marker-end', 'url(#arrow-yellow)');\n      g.querySelector('text').setAttribute('fill', 'var(--yellow)');\n    } else if (info.type === 'improved') {\n      line.setAttribute('stroke', 'var(--good)');\n      line.setAttribute('marker-end', 'url(#arrow-green)');\n      g.querySelector('text').setAttribute('fill', 'var(--good)');\n    } else if (info.type === 'neg') {\n      line.setAttribute('stroke', 'var(--bad)');\n      line.setAttribute('marker-end', 'url(#arrow-red)');\n      g.querySelector('text').setAttribute('fill', 'var(--bad)');\n    } else {\n      g.querySelector('text').setAttribute('fill', '#cbd5e1');\n    }\n  });\n\n  // highlight predecessor tree if asked\n  if (state.treeHighlight) {\n    const pred = state.pred || {};\n    edgesLayer.querySelectorAll('g').forEach(g=>{\n      const eid = g.getAttribute('data-edge-id');\n      const e = edges.find(x=>x.id===eid);\n      if (!e) return;\n      if (pred[e.to] === e.from) {\n        const line = g.querySelector('line');\n        line.setAttribute('stroke', 'rgba(99,102,241,0.98)');\n        line.setAttribute('stroke-width', '3');\n        g.querySelector('text').setAttribute('fill', '#eef2ff');\n      }\n    });\n  }\n}\n\n/* UI lists */\nfunction updateLists() {\n  // nodes dropdowns\n  const sourceId = sourceSelect.value || (nodes[0] && nodes[0].id) || '';\n  populateSourceOptions(sourceId);\n\n  // nodes list\n  nodesList.innerHTML = '';\n  nodes.forEach(n=>{\n    const el = document.createElement('div');\n    el.className = 'row';\n    el.innerHTML = `<div class=\"node-label\"><strong>${n.id}</strong> <div class=\"small-muted\">(${Math.round(n.x)},${Math.round(n.y)})</div></div>\n      <div class=\"small-muted\">d=${state.distances[n.id]===undefined? '—' : (state.distances[n.id]===Infinity ? '∞' : state.distances[n.id])}<span style=\"margin-left:8px;color:var(--muted)\">pred=${state.pred[n.id]===undefined? '—': state.pred[n.id]}</span></div>`;\n    nodesList.appendChild(el);\n  });\n\n  // edges list\n  edgesList.innerHTML = '';\n  edges.forEach(e=>{\n    const el = document.createElement('div');\n    el.className = 'row';\n    el.innerHTML = `<div class=\"node-label\"><strong>${e.from} → ${e.to}</strong><div class=\"small-muted\">id:${e.id}</div></div>\n      <div class=\"small-muted\">w=${e.w}</div>`;\n    edgesList.appendChild(el);\n  });\n\n  iterationDisplay.textContent = state.iter;\n  edgeIndexDisplay.textContent = state.edgeIndex;\n}\n\nfunction populateSourceOptions(selectedId) {\n  sourceSelect.innerHTML = '';\n  sourceSelectSide.innerHTML = '';\n  nodes.forEach(n=>{\n    const opt = document.createElement('option'); opt.value = n.id; opt.textContent = n.id;\n    sourceSelect.appendChild(opt);\n    const opt2 = opt.cloneNode(true);\n    sourceSelectSide.appendChild(opt2);\n  });\n  if (selectedId && Array.from(sourceSelect.options).some(o=>o.value===selectedId)) {\n    sourceSelect.value = selectedId;\n    sourceSelectSide.value = selectedId;\n  } else {\n    if (nodes[0]) {\n      sourceSelect.value = nodes[0].id;\n      sourceSelectSide.value = nodes[0].id;\n    }\n  }\n}\n\nfunction refreshSourceOptions() {\n  populateSourceOptions(sourceSelect.value);\n}\n\n/* Bellman-Ford Implementation with step control */\n\nfunction initAlgorithm() {\n  state.V = nodes.length;\n  state.E = edges.length;\n  state.distances = {};\n  state.pred = {};\n  nodes.forEach(n=>{\n    state.distances[n.id] = Infinity;\n    state.pred[n.id] = null;\n  });\n  const src = sourceSelect.value || nodes[0] && nodes[0].id;\n  if (!src) {\n    alert('Please add nodes and select a source.');\n    return false;\n  }\n  state.distances[src] = 0;\n  state.iter = 1;\n  state.edgeIndex = 0;\n  state.finished = false;\n  state.negativeCycle = false;\n  state.running = false;\n  state.treeHighlight = false;\n  // clear edge info\n  edges.forEach(e=> e._info = null);\n  log(`Initialized. Source = ${src}`);\n  render();\n  updateLists();\n  return true;\n}\n\nfunction stepOnce() {\n  if (state.finished) {\n    log('Algorithm already finished. Reset to run again.');\n    return;\n  }\n  if (state.iter > Math.max(1, state.V-1)) {\n    // After V-1 iterations, check for negative cycles\n    const neg = detectNegativeCycleAfterRelaxations();\n    if (neg) {\n      state.negativeCycle = true;\n      log('Negative cycle detected! Highlighted in red.');\n      state.finished = true;\n      render();\n      updateLists();\n      return;\n    } else {\n      log('No negative cycle detected. Algorithm complete.');\n      state.finished = true;\n      render();\n      updateLists();\n      return;\n    }\n  }\n  if (edges.length === 0) {\n    // nothing to relax\n    state.iter++;\n    if (state.iter > state.V-1) {\n      state.finished = true;\n      log('No edges to relax. Algorithm complete.');\n    }\n    render();\n    updateLists();\n    return;\n  }\n  const e = edges[state.edgeIndex];\n  // mark checking\n  edges.forEach(ed => ed._info = null);\n  e._info = {type:'checking'};\n  render();\n\n  // relax\n  const u = e.from, v = e.to, w = e.w;\n  const du = state.distances[u];\n  const dv = state.distances[v];\n  if (du !== Infinity && du + w < dv) {\n    state.distances[v] = du + w;\n    state.pred[v] = u;\n    e._info = {type:'improved'};\n    log(`Relaxed edge ${u} → ${v}: updated d[${v}] from ${dv===Infinity?'∞':dv} to ${state.distances[v]}`);\n  } else {\n    log(`Checked edge ${u} → ${v}: no improvement.`);\n  }\n\n  // advance edgeIndex / iteration\n  state.edgeIndex++;\n  if (state.edgeIndex >= edges.length) {\n    state.edgeIndex = 0;\n    state.iter++;\n  }\n  render();\n  updateLists();\n}\n\nfunction detectNegativeCycleAfterRelaxations() {\n  // If any edge can be relaxed, there's a negative cycle reachable\n  let found = false;\n  let markerEdge = null;\n  for (const e of edges) {\n    const du = state.distances[e.from];\n    if (du !== Infinity && du + e.w < state.distances[e.to]) {\n      found = true;\n      markerEdge = e;\n      break;\n    }\n  }\n  if (!found) {\n    return false;\n  }\n  // Try to extract nodes in cycle: start from markerEdge.to and follow pred V times, then loop detection\n  let v = markerEdge.to;\n  for (let i=0;i<state.V;i++) {\n    v = state.pred[v] || v;\n  }\n  // now traverse until we loop back to v\n  const cycleNodes = new Set();\n  let cur = v;\n  do {\n    cycleNodes.add(cur);\n    cur = state.pred[cur] || cur;\n    // avoid infinite fallback, break if too many steps\n    if (cycleNodes.size > state.V) break;\n  } while (cur !== v && cur !== null && cur !== undefined);\n\n  // mark edges that are inside cycle (pred relationships)\n  edges.forEach(e => e._info = null);\n  edges.forEach(e=>{\n    if (cycleNodes.has(e.from) && cycleNodes.has(e.to) && state.pred[e.to] === e.from) e._info = {type:'neg'};\n  });\n  // ensure marker edge shown red too\n  const me = edges.find(e=>e.id===markerEdge.id);\n  if (me) me._info = {type:'neg'};\n\n  render();\n  return true;\n}\n\nfunction iterateOnce() {\n  // perform a full iteration over all edges\n  if (state.finished) { log('Algorithm already finished. Reset to run again.'); return; }\n  if (!initCheckSource()) return;\n  for (let i=0;i<edges.length;i++) {\n    const e = edges[i];\n    // mark checking\n    edges.forEach(ed => ed._info = null);\n    e._info = {type:'checking'};\n    render();\n    // small delay simulation could be added, but here synchronous\n    const u = e.from, v = e.to, w = e.w;\n    const du = state.distances[u];\n    if (du !== Infinity && du + w < state.distances[v]) {\n      state.distances[v] = du + w;\n      state.pred[v] = u;\n      e._info = {type:'improved'};\n      log(`Relaxed edge ${u} → ${v}: updated d[${v}] to ${state.distances[v]}`);\n    } else {\n      log(`Checked edge ${u} → ${v}: no improvement.`);\n    }\n  }\n  state.iter++;\n  if (state.iter > state.V-1) {\n    // check negative cycle\n    const neg = detectNegativeCycleAfterRelaxations();\n    if (neg) {\n      state.negativeCycle = true;\n      state.finished = true;\n      log('Negative cycle detected after iterations.');\n    } else {\n      state.finished = true;\n      log('Completed all iterations. No negative cycle detected.');\n    }\n  } else {\n    log(`Completed iteration ${state.iter-1}.`);\n  }\n  render();\n  updateLists();\n}\n\nfunction initCheckSource() {\n  if (Object.keys(state.distances).length === 0) {\n    // hasn't been initialized\n    return initAlgorithm();\n  }\n  return true;\n}\n\nstepBtn.addEventListener('click', ()=>{\n  if (!initCheckSource()) return;\n  stepOnce();\n});\n\niterBtn.addEventListener('click', ()=>{\n  if (!initCheckSource()) return;\n  iterateOnce();\n});\n\nrunBtn.addEventListener('click', ()=>{\n  if (!initCheckSource()) return;\n  // run to completion (synchronously, but we animate states)\n  runToCompletion();\n});\n\nfunction runToCompletion() {\n  if (state.finished) { log('Already finished.'); return; }\n  runBtn.disabled = true;\n  stepBtn.disabled = true;\n  iterBtn.disabled = true;\n  autoBtn.disabled = true;\n\n  const maxSteps = (state.V - 1) * Math.max(1, edges.length) + edges.length + 5;\n  let steps = 0;\n  const timer = setInterval(()=>{\n    if (state.finished || steps > maxSteps) {\n      clearInterval(timer);\n      runBtn.disabled = false;\n      stepBtn.disabled = false;\n      iterBtn.disabled = false;\n      autoBtn.disabled = false;\n      log('Run completed.');\n      return;\n    }\n    stepOnce();\n    steps++;\n  }, 250);\n}\n\nlet autoRunning = false;\nautoBtn.addEventListener('click', ()=>{\n  if (!initCheckSource()) return;\n  if (!autoRunning) {\n    autoRunning = true;\n    autoBtn.textContent = 'Stop';\n    state.autoTimer = setInterval(()=>{\n      if (state.finished) {\n        clearInterval(state.autoTimer);\n        autoRunning = false;\n        autoBtn.textContent = 'Auto';\n        return;\n      }\n      stepOnce();\n    }, 600);\n  } else {\n    autoRunning = false;\n    autoBtn.textContent = 'Auto';\n    clearInterval(state.autoTimer);\n  }\n});\n\nresetBtn.addEventListener('click', ()=>{\n  if (confirm('Reset algorithm state (keeps graph)?')) {\n    state.distances = {};\n    state.pred = {};\n    state.iter = 0;\n    state.edgeIndex = 0;\n    state.finished = true;\n    state.negativeCycle = false;\n    edges.forEach(e=>e._info = null);\n    state.treeHighlight = false;\n    render();\n    updateLists();\n    log('Algorithm state reset.');\n  }\n});\n\nmarkPathBtn.addEventListener('click', ()=>{\n  state.treeHighlight = !state.treeHighlight;\n  render();\n});\nclearHighlightsBtn.addEventListener('click', ()=>{\n  state.treeHighlight = false;\n  edges.forEach(e=>e._info = null);\n  render();\n});\n\n/* Negative cycle detection on run (helper already implemented) */\n\n/* Utility: find nodes/edges by id */\nfunction getNode(id){ return nodes.find(n=>n.id===id); }\nfunction getEdge(id){ return edges.find(e=>e.id===id); }\n\n/* Presets */\npreset1.addEventListener('click', ()=>{\n  clearGraph();\n  // Create sample graph (no negative cycle)\n  addNode(140, 120); //0\n  addNode(420, 80); //1\n  addNode(720, 120); //2\n  addNode(240, 320); //3\n  addNode(540, 320); //4\n  addEdge('0','1',6);\n  addEdge('0','3',7);\n  addEdge('1','2',5);\n  addEdge('1','3',8);\n  addEdge('1','4', -4);\n  addEdge('2','1', -2);\n  addEdge('3','2', -3);\n  addEdge('3','4',9);\n  addEdge('4','2',7);\n  nextNodeId = nodes.length;\n  nextEdgeId = edges.length;\n  refreshSourceOptions();\n  render();\n  updateLists();\n  log('Loaded Example 1.');\n});\n\npreset2.addEventListener('click', ()=>{\n  clearGraph();\n  // negative cycle example\n  addNode(160, 120); //0\n  addNode(460, 120); //1\n  addNode(760, 120); //2\n  addEdge('0','1',1);\n  addEdge('1','2', -1);\n  addEdge('2','1', -3); // creates negative cycle between 1 and 2\n  refreshSourceOptions();\n  render();\n  updateLists();\n  log('Loaded Negative Cycle example.');\n});\n\nclearBtn.addEventListener('click', ()=>{\n  if (confirm('Clear entire graph?')) {\n    clearGraph();\n    render();\n    updateLists();\n    log('Graph cleared.');\n  }\n});\n\nfunction clearGraph() {\n  nodes = [];\n  edges = [];\n  nextNodeId = 0;\n  nextEdgeId = 0;\n  state = {\n    distances: {},\n    pred: {},\n    V:0, E:0, iter:0, edgeIndex:0, finished:true, negativeCycle:false, autoTimer:null, running:false, treeHighlight:false\n  };\n  refreshSourceOptions();\n}\n\n/* Helpers for running detection */\nfunction detectNegativeCycle() {\n  // not used directly\n  return detectNegativeCycleAfterRelaxations();\n}\n\n/* Initialization on load */\n(function init(){\n  // add a tiny demo graph\n  addNode(140, 120);\n  addNode(320, 90);\n  addNode(500, 140);\n  addNode(260, 300);\n  addEdge('0','1',5);\n  addEdge('0','3',2);\n  addEdge('1','2',-3);\n  addEdge('2','3',1);\n  refreshSourceOptions();\n  render();\n  updateLists();\n  log('Welcome! Use \"Add Node\" (click) and \"Add Edge\" (click nodes) to build a graph. Then pick a source and Step/Run.');\n})();\n\n/* Utility to find negative cycle nodes (used above) implemented earlier */\n\n/* Small extra: keep source selection synchronized */\nsourceSelect.addEventListener('change', ()=>{\n  sourceSelectSide.value = sourceSelect.value;\n});\nsourceSelectSide.addEventListener('change', ()=>{\n  sourceSelect.value = sourceSelectSide.value;\n});\n\n/* Escape: reset addEdgeFrom when clicking background */\nsvg.addEventListener('click', (ev)=>{\n  if (mode === 'addEdge' && addEdgeFrom) {\n    // clicking empty space cancels\n    addEdgeFrom = null;\n    setMode('select');\n  }\n});\n\n/* Keyboard shortcuts */\nwindow.addEventListener('keydown', (ev)=>{\n  if (ev.key === 'n') setMode('addNode');\n  if (ev.key === 'e') setMode('addEdge');\n  if (ev.key === 's') setMode('select');\n  if (ev.key === 'Delete') setMode('delete');\n});\n\n/* End of script */\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}