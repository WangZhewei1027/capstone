{
  "id": "f180cb40-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:21:28.026Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Adjacency Matrix Demonstration</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 900px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background-color: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            margin: 20px 0;\n            text-align: center;\n        }\n        button {\n            padding: 10px 15px;\n            margin: 5px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        #graph-controls {\n            margin: 20px 0;\n        }\n        .matrix-container {\n            overflow-x: auto;\n            margin: 20px 0;\n        }\n        table {\n            border-collapse: collapse;\n            margin: 20px auto;\n        }\n        th, td {\n            border: 1px solid #ddd;\n            padding: 10px;\n            text-align: center;\n            min-width: 40px;\n        }\n        th {\n            background-color: #f2f2f2;\n        }\n        .node-label {\n            background-color: #e9ecef;\n            font-weight: bold;\n        }\n        .highlight {\n            background-color: #ffeb3b;\n        }\n        .edge-cell {\n            cursor: pointer;\n        }\n        .edge-cell:hover {\n            background-color: #e3f2fd;\n        }\n        .graph-display {\n            margin: 20px auto;\n            text-align: center;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n        }\n        .explanation {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #f8f9fa;\n            border-radius: 5px;\n        }\n        input[type=\"number\"] {\n            padding: 5px;\n            width: 60px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Adjacency Matrix Demonstration</h1>\n        \n        <div class=\"controls\">\n            <div id=\"graph-controls\">\n                <label for=\"node-count\">Number of nodes: </label>\n                <input type=\"number\" id=\"node-count\" min=\"2\" max=\"10\" value=\"5\">\n                <button id=\"generate-graph\">Generate Graph</button>\n                <button id=\"clear-graph\">Clear Graph</button>\n                <button id=\"toggle-directed\">Toggle Directed/Undirected</button>\n            </div>\n        </div>\n\n        <div class=\"graph-display\">\n            <canvas id=\"graph-canvas\" width=\"500\" height=\"400\"></canvas>\n        </div>\n\n        <div class=\"matrix-container\">\n            <h3>Adjacency Matrix</h3>\n            <div id=\"matrix-display\"></div>\n        </div>\n\n        <div class=\"explanation\">\n            <h3>What is an Adjacency Matrix?</h3>\n            <p>An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</p>\n            <ul>\n                <li>In an <strong>undirected graph</strong>, the matrix is symmetric</li>\n                <li>In a <strong>directed graph</strong>, the matrix may not be symmetric</li>\n                <li>A value of 1 indicates an edge between nodes, 0 indicates no edge</li>\n                <li>The diagonal is typically 0 (no self-loops in this demonstration)</li>\n            </ul>\n            <p><strong>Click on matrix cells to add/remove edges between nodes.</strong></p>\n        </div>\n    </div>\n\n    <script>\n        class Graph {\n            constructor(size = 5) {\n                this.size = size;\n                this.matrix = this.createEmptyMatrix(size);\n                this.isDirected = false;\n                this.nodePositions = [];\n                this.calculateNodePositions();\n            }\n\n            createEmptyMatrix(size) {\n                return Array(size).fill().map(() => Array(size).fill(0));\n            }\n\n            calculateNodePositions() {\n                this.nodePositions = [];\n                const centerX = 250;\n                const centerY = 200;\n                const radius = 150;\n\n                for (let i = 0; i < this.size; i++) {\n                    const angle = (2 * Math.PI * i) / this.size;\n                    const x = centerX + radius * Math.cos(angle);\n                    const y = centerY + radius * Math.sin(angle);\n                    this.nodePositions.push({ x, y });\n                }\n            }\n\n            toggleEdge(i, j) {\n                if (i === j) return; // No self-loops\n\n                if (this.isDirected) {\n                    this.matrix[i][j] = this.matrix[i][j] ? 0 : 1;\n                } else {\n                    this.matrix[i][j] = this.matrix[i][j] ? 0 : 1;\n                    this.matrix[j][i] = this.matrix[i][j];\n                }\n            }\n\n            clear() {\n                this.matrix = this.createEmptyMatrix(this.size);\n            }\n\n            resize(newSize) {\n                this.size = newSize;\n                this.matrix = this.createEmptyMatrix(newSize);\n                this.calculateNodePositions();\n            }\n\n            toggleDirected() {\n                this.isDirected = !this.isDirected;\n                // Convert existing edges if needed\n                if (!this.isDirected) {\n                    for (let i = 0; i < this.size; i++) {\n                        for (let j = i + 1; j < this.size; j++) {\n                            if (this.matrix[i][j] || this.matrix[j][i]) {\n                                this.matrix[i][j] = 1;\n                                this.matrix[j][i] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        class GraphVisualizer {\n            constructor(canvasId) {\n                this.canvas = document.getElementById(canvasId);\n                this.ctx = this.canvas.getContext('2d');\n                this.graph = new Graph();\n            }\n\n            drawGraph() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                this.drawEdges();\n                this.drawNodes();\n            }\n\n            drawNodes() {\n                this.ctx.fillStyle = '#4CAF50';\n                this.ctx.strokeStyle = '#2E7D32';\n                this.ctx.lineWidth = 2;\n\n                for (let i = 0; i < this.graph.nodePositions.length; i++) {\n                    const pos = this.graph.nodePositions[i];\n                    \n                    // Draw node\n                    this.ctx.beginPath();\n                    this.ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    this.ctx.stroke();\n\n                    // Draw node label\n                    this.ctx.fillStyle = 'white';\n                    this.ctx.font = 'bold 16px Arial';\n                    this.ctx.textAlign = 'center';\n                    this.ctx.textBaseline = 'middle';\n                    this.ctx.fillText(i, pos.x, pos.y);\n                    this.ctx.fillStyle = '#4CAF50';\n                }\n            }\n\n            drawEdges() {\n                this.ctx.strokeStyle = '#666';\n                this.ctx.lineWidth = 2;\n\n                for (let i = 0; i < this.graph.size; i++) {\n                    for (let j = 0; j < this.graph.size; j++) {\n                        if (this.graph.matrix[i][j]) {\n                            const start = this.graph.nodePositions[i];\n                            const end = this.graph.nodePositions[j];\n\n                            this.ctx.beginPath();\n                            this.ctx.moveTo(start.x, start.y);\n\n                            if (this.graph.isDirected && i !== j) {\n                                // Draw arrow for directed edges\n                                this.drawArrow(start, end);\n                            } else {\n                                // Straight line for undirected or self-loops\n                                this.ctx.lineTo(end.x, end.y);\n                                this.ctx.stroke();\n                            }\n                        }\n                    }\n                }\n            }\n\n            drawArrow(start, end) {\n                const headLength = 15;\n                const dx = end.x - start.x;\n                const dy = end.y - start.y;\n                const angle = Math.atan2(dy, dx);\n                const length = Math.sqrt(dx * dx + dy * dy) - 20; // Adjust for node radius\n\n                // Calculate the endpoint considering node radius\n                const adjustedEndX = start.x + Math.cos(angle) * length;\n                const adjustedEndY = start.y + Math.sin(angle) * length;\n\n                this.ctx.lineTo(adjustedEndX, adjustedEndY);\n                this.ctx.stroke();\n\n                // Draw arrowhead\n                this.ctx.beginPath();\n                this.ctx.moveTo(adjustedEndX, adjustedEndY);\n                this.ctx.lineTo(\n                    adjustedEndX - headLength * Math.cos(angle - Math.PI / 6),\n                    adjustedEndY - headLength * Math.sin(angle - Math.PI / 6)\n                );\n                this.ctx.moveTo(adjustedEndX, adjustedEndY);\n                this.ctx.lineTo(\n                    adjustedEndX - headLength * Math.cos(angle + Math.PI / 6),\n                    adjustedEndY - headLength * Math.sin(angle + Math.PI / 6)\n                );\n                this.ctx.stroke();\n            }\n        }\n\n        class MatrixDisplay {\n            constructor(containerId) {\n                this.container = document.getElementById(containerId);\n            }\n\n            updateMatrix(graph) {\n                this.container.innerHTML = '';\n                const table = document.createElement('table');\n                \n                // Create header row\n                const headerRow = document.createElement('tr');\n                headerRow.innerHTML = '<th></th>';\n                for (let i = 0; i < graph.size; i++) {\n                    headerRow.innerHTML += `<th class=\"node-label\">${i}</th>`;\n                }\n                table.appendChild(headerRow);\n\n                // Create data rows\n                for (let i = 0; i < graph.size; i++) {\n                    const row = document.createElement('tr');\n                    row.innerHTML = `<td class=\"node-label\">${i}</td>`;\n                    \n                    for (let j = 0; j < graph.size; j++) {\n                        const cell = document.createElement('td');\n                        cell.textContent = graph.matrix[i][j];\n                        cell.className = 'edge-cell';\n                        cell.dataset.row = i;\n                        cell.dataset.col = j;\n                        \n                        if (graph.matrix[i][j] === 1) {\n                            cell.style.backgroundColor = '#4CAF50';\n                            cell.style.color = 'white';\n                        }\n                        \n                        row.appendChild(cell);\n                    }\n                    table.appendChild(row);\n                }\n                \n                this.container.appendChild(table);\n            }\n        }\n\n        // Initialize application\n        const graph = new Graph();\n        const visualizer = new GraphVisualizer('graph-canvas');\n        const matrixDisplay = new MatrixDisplay('matrix-display');\n\n        function updateDisplay() {\n            visualizer.drawGraph();\n            matrixDisplay.updateMatrix(graph);\n        }\n\n        // Event listeners\n        document.getElementById('generate-graph').addEventListener('click', () => {\n            const nodeCount = parseInt(document.getElementById('node-count').value);\n            graph.resize(nodeCount);\n            updateDisplay();\n        });\n\n        document.getElementById('clear-graph').addEventListener('click', () => {\n            graph.clear();\n            updateDisplay();\n        });\n\n        document.getElementById('toggle-directed').addEventListener('click', () => {\n            graph.toggleDirected();\n            updateDisplay();\n        });\n\n        // Handle matrix cell clicks\n        document.getElementById('matrix-display').addEventListener('click', (e) => {\n            if (e.target.classList.contains('edge-cell')) {\n                const row = parseInt(e.target.dataset.row);\n                const col = parseInt(e.target.dataset.col);\n                graph.toggleEdge(row, col);\n                updateDisplay();\n            }\n        });\n\n        // Initial display\n        updateDisplay();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}