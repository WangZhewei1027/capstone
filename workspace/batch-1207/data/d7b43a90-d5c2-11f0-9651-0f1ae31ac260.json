{
  "id": "d7b43a90-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:28.403Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Topological Sort Visualization</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n      background: #f4f6f8;\n      color: #333;\n    }\n    h1 {\n      text-align: center;\n      margin-bottom: 10px;\n    }\n    #input-area {\n      display: flex;\n      gap: 20px;\n      margin-bottom: 20px;\n      flex-wrap: wrap;\n      justify-content: center;\n    }\n    textarea {\n      width: 350px;\n      height: 150px;\n      font-family: monospace;\n      font-size: 14px;\n      padding: 10px;\n      border-radius: 6px;\n      border: 1px solid #bbb;\n      resize: vertical;\n    }\n    button {\n      padding: 12px 25px;\n      font-size: 16px;\n      border: none;\n      border-radius: 6px;\n      cursor: pointer;\n      background-color: #0078d7;\n      color: white;\n      height: 46px;\n      align-self: flex-end;\n      transition: background-color 0.2s ease;\n    }\n    button:hover {\n      background-color: #005ea2;\n    }\n    #result {\n      margin-top: 20px;\n      font-size: 18px;\n      text-align: center;\n      min-height: 40px;\n      background: white;\n      padding: 15px 20px;\n      border-radius: 8px;\n      border: 1px solid #ddd;\n      max-width: 700px;\n      margin-left: auto;\n      margin-right: auto;\n      word-break: break-word;\n    }\n    #graph {\n      margin-top: 30px;\n      max-width: 900px;\n      margin-left: auto;\n      margin-right: auto;\n      border: 1px solid #ccc;\n      background: white;\n      border-radius: 8px;\n      padding: 10px;\n    }\n    svg {\n      width: 100%;\n      height: 400px;\n    }\n    .node circle {\n      fill: #4a90e2;\n      cursor: default;\n      transition: fill 0.3s;\n    }\n    .node text {\n      fill: white;\n      font-weight: bold;\n      font-size: 14px;\n      user-select: none;\n      pointer-events: none;\n    }\n    .node.highlight circle {\n      fill: #e94e77;\n      transition: fill 0.3s;\n    }\n    .edge path {\n      stroke: #999;\n      stroke-width: 2;\n      fill: none;\n      marker-end: url(#arrowhead);\n      transition: stroke 0.3s;\n    }\n    .edge.highlight path {\n      stroke: #e94e77;\n      stroke-width: 3;\n    }\n    #error {\n      color: #d93025;\n      font-weight: bold;\n      text-align: center;\n      margin-top: 10px;\n    }\n    label {\n      font-weight: bold;\n      display: block;\n      margin-bottom: 6px;\n      text-align: center;\n    }\n    @media (max-width: 800px) {\n      #input-area {\n        flex-direction: column;\n        align-items: center;\n      }\n      textarea {\n        width: 90vw;\n      }\n      button {\n        width: 90vw;\n      }\n    }\n  </style>\n</head>\n<body>\n  <h1>Topological Sort Demo</h1>\n  <div id=\"input-area\">\n    <div>\n      <label for=\"nodes\">Nodes (one per line)</label>\n      <textarea id=\"nodes\" placeholder=\"e.g. A&#10;B&#10;C&#10;D\"></textarea>\n    </div>\n    <div>\n      <label for=\"edges\">Edges (format: from,to one per line)</label>\n      <textarea id=\"edges\" placeholder=\"e.g.&#10;A,B&#10;B,C&#10;A,C&#10;C,D\"></textarea>\n    </div>\n  </div>\n  <div style=\"text-align:center;\">\n    <button id=\"run-btn\">Run Topological Sort</button>\n  </div>\n  <div id=\"error\"></div>\n  <div id=\"result\"></div>\n  <div id=\"graph\"></div>\n\n  <script>\n    // Utility to clear an element's children\n    function clearElem(elem) {\n      while (elem.firstChild) {\n        elem.removeChild(elem.firstChild);\n      }\n    }\n\n    // Graph rendering section\n    class GraphRenderer {\n      constructor(container) {\n        this.container = container;\n        this.svgNS = \"http://www.w3.org/2000/svg\";\n        this.width = 880;\n        this.height = 400;\n        this.nodeRadius = 20;\n        this.nodePositions = new Map(); // nodeId -> {x, y}\n        this.nodes = [];\n        this.edges = [];\n        this.svg = null;\n      }\n\n      createSVG() {\n        clearElem(this.container);\n        this.svg = document.createElementNS(this.svgNS, \"svg\");\n        this.svg.setAttribute(\"width\", this.width);\n        this.svg.setAttribute(\"height\", this.height);\n        this.container.appendChild(this.svg);\n\n        // Define Arrowhead Marker for edges\n        let defs = document.createElementNS(this.svgNS, \"defs\");\n        let marker = document.createElementNS(this.svgNS, \"marker\");\n        marker.setAttribute(\"id\", \"arrowhead\");\n        marker.setAttribute(\"markerWidth\", \"10\");\n        marker.setAttribute(\"markerHeight\", \"7\");\n        marker.setAttribute(\"refX\", \"10\");\n        marker.setAttribute(\"refY\", \"3.5\");\n        marker.setAttribute(\"orient\", \"auto\");\n        marker.setAttribute(\"fill\", \"#999\");\n        let path = document.createElementNS(this.svgNS, \"path\");\n        path.setAttribute(\"d\", \"M0,0 L10,3.5 L0,7 Z\");\n        marker.appendChild(path);\n        defs.appendChild(marker);\n        this.svg.appendChild(defs);\n      }\n\n      layoutNodes(nodes, edges) {\n        // Simple layered layout based on topological levels\n        // We'll assign levels based on longest distance from any root node\n        // and then distribute nodes horizontally on that level.\n\n        // Build adjacency list and in-degree\n        let adj = new Map();\n        for (let n of nodes) adj.set(n, []);\n        for (let [from, to] of edges) {\n          adj.get(from).push(to);\n        }\n\n        // Find nodes with in-degree 0 (roots)\n        let inDegree = new Map();\n        for (let n of nodes) {\n          inDegree.set(n, 0);\n        }\n        for (let [from, to] of edges) {\n          inDegree.set(to, (inDegree.get(to) || 0) + 1);\n        }\n        let queue = [];\n        for (let n of nodes) {\n          if (inDegree.get(n) === 0) queue.push(n);\n        }\n\n        // Compute levels by BFS\n        let levels = new Map();\n        for (let n of nodes) levels.set(n, 0);\n        while (queue.length) {\n          let u = queue.shift();\n          for (let v of adj.get(u)) {\n            if (levels.get(v) < levels.get(u) + 1) {\n              levels.set(v, levels.get(u) + 1);\n            }\n            inDegree.set(v, inDegree.get(v) - 1);\n            if (inDegree.get(v) === 0) queue.push(v);\n          }\n        }\n\n        // Group nodes by level\n        let levelGroups = new Map();\n        for (let [node, level] of levels.entries()) {\n          if (!levelGroups.has(level)) levelGroups.set(level, []);\n          levelGroups.get(level).push(node);\n        }\n\n        // Position nodes - vertical spacing by level, horizontal by index in group\n        let maxLevel = Math.max(...levels.values());\n        let verticalSpacing = (this.height - 40) / (maxLevel + 1);\n        this.nodePositions.clear();\n\n        for (let level = 0; level <= maxLevel; level++) {\n          let group = levelGroups.get(level) || [];\n          let horizontalSpacing = this.width / (group.length + 1);\n          group.forEach((node, idx) => {\n            let x = horizontalSpacing * (idx + 1);\n            let y = 20 + verticalSpacing * level;\n            this.nodePositions.set(node, { x, y });\n          });\n        }\n      }\n\n      drawGraph(nodes, edges, highlightNodes = [], highlightEdges = []) {\n        if (!this.svg) this.createSVG();\n\n        clearElem(this.svg);\n\n        // Redraw arrow marker (needs to be in defs inside SVG)\n        let defs = document.createElementNS(this.svgNS, \"defs\");\n        let marker = document.createElementNS(this.svgNS, \"marker\");\n        marker.setAttribute(\"id\", \"arrowhead\");\n        marker.setAttribute(\"markerWidth\", \"10\");\n        marker.setAttribute(\"markerHeight\", \"7\");\n        marker.setAttribute(\"refX\", \"10\");\n        marker.setAttribute(\"refY\", \"3.5\");\n        marker.setAttribute(\"orient\", \"auto\");\n        marker.setAttribute(\"fill\", \"#999\");\n        let path = document.createElementNS(this.svgNS, \"path\");\n        path.setAttribute(\"d\", \"M0,0 L10,3.5 L0,7 Z\");\n        marker.appendChild(path);\n        defs.appendChild(marker);\n        this.svg.appendChild(defs);\n\n        // Draw edges first\n        for (let [from, to] of edges) {\n          let fromPos = this.nodePositions.get(from);\n          let toPos = this.nodePositions.get(to);\n          if (!fromPos || !toPos) continue;\n\n          let edgeGroup = document.createElementNS(this.svgNS, \"g\");\n          edgeGroup.setAttribute(\"class\", \"edge\");\n\n          // Highlight edge if in highlightEdges\n          if (\n            highlightEdges.some(\n              ([f, t]) => f === from && t === to\n            )\n          ) {\n            edgeGroup.classList.add(\"highlight\");\n          }\n\n          // We'll draw a straight line with arrow head\n          // Adjust line start/end so it doesn't overlap circles\n          let dx = toPos.x - fromPos.x;\n          let dy = toPos.y - fromPos.y;\n          let dist = Math.sqrt(dx * dx + dy * dy);\n          let ratioStart = this.nodeRadius / dist;\n          let ratioEnd = this.nodeRadius / dist;\n          let startX = fromPos.x + dx * ratioStart;\n          let startY = fromPos.y + dy * ratioStart;\n          let endX = toPos.x - dx * ratioEnd;\n          let endY = toPos.y - dy * ratioEnd;\n\n          let path = document.createElementNS(this.svgNS, \"path\");\n          let d = `M${startX},${startY} L${endX},${endY}`;\n          path.setAttribute(\"d\", d);\n          path.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n          edgeGroup.appendChild(path);\n          this.svg.appendChild(edgeGroup);\n        }\n\n        // Draw nodes on top\n        for (let node of nodes) {\n          let pos = this.nodePositions.get(node);\n          if (!pos) continue;\n\n          let group = document.createElementNS(this.svgNS, \"g\");\n          group.setAttribute(\"class\", \"node\");\n          group.setAttribute(\"data-node\", node);\n\n          if (highlightNodes.includes(node)) {\n            group.classList.add(\"highlight\");\n          }\n\n          let circle = document.createElementNS(this.svgNS, \"circle\");\n          circle.setAttribute(\"cx\", pos.x);\n          circle.setAttribute(\"cy\", pos.y);\n          circle.setAttribute(\"r\", this.nodeRadius);\n          group.appendChild(circle);\n\n          let text = document.createElementNS(this.svgNS, \"text\");\n          text.setAttribute(\"x\", pos.x);\n          text.setAttribute(\"y\", pos.y + 5);\n          text.setAttribute(\"text-anchor\", \"middle\");\n          text.textContent = node;\n          group.appendChild(text);\n\n          this.svg.appendChild(group);\n        }\n      }\n    }\n\n    // Topological sort function using Kahn's algorithm\n    // Returns an object { order: [...], hasCycle: boolean }\n    function topologicalSort(nodes, edges) {\n      let adj = new Map();\n      for (let node of nodes) adj.set(node, []);\n      for (let [from, to] of edges) {\n        adj.get(from).push(to);\n      }\n      let inDegree = new Map();\n      for (let node of nodes) inDegree.set(node, 0);\n      for (let [from, to] of edges) {\n        inDegree.set(to, inDegree.get(to) + 1);\n      }\n\n      let queue = [];\n      for (let node of nodes) {\n        if (inDegree.get(node) === 0) queue.push(node);\n      }\n\n      let order = [];\n      while (queue.length) {\n        let u = queue.shift();\n        order.push(u);\n        for (let v of adj.get(u)) {\n          inDegree.set(v, inDegree.get(v) - 1);\n          if (inDegree.get(v) === 0) queue.push(v);\n        }\n      }\n\n      if (order.length !== nodes.length) {\n        return { order: [], hasCycle: true };\n      } else {\n        return { order, hasCycle: false };\n      }\n    }\n\n    // Main app\n    (function () {\n      const nodesInput = document.getElementById(\"nodes\");\n      const edgesInput = document.getElementById(\"edges\");\n      const runBtn = document.getElementById(\"run-btn\");\n      const resultDiv = document.getElementById(\"result\");\n      const errorDiv = document.getElementById(\"error\");\n      const graphDiv = document.getElementById(\"graph\");\n\n      // Pre-fill example data\n      nodesInput.value = \"A\\nB\\nC\\nD\\nE\\nF\";\n      edgesInput.value = \"A,B\\nB,C\\nA,C\\nC,D\\nE,F\";\n\n      const graphRenderer = new GraphRenderer(graphDiv);\n\n      function parseInput() {\n        errorDiv.textContent = \"\";\n        resultDiv.textContent = \"\";\n        let nodesRaw = nodesInput.value.trim();\n        let edgesRaw = edgesInput.value.trim();\n\n        if (!nodesRaw) {\n          errorDiv.textContent = \"Please enter nodes.\";\n          return null;\n        }\n        let nodes = nodesRaw.split(\"\\n\").map(s => s.trim()).filter(s => s.length > 0);\n        if (new Set(nodes).size !== nodes.length) {\n          errorDiv.textContent = \"Duplicate nodes detected.\";\n          return null;\n        }\n\n        let edges = [];\n        if (edgesRaw.length > 0) {\n          let lines = edgesRaw.split(\"\\n\");\n          for (let line of lines) {\n            let parts = line.split(\",\");\n            if (parts.length !== 2) {\n              errorDiv.textContent = `Invalid edge format: \"${line}\". Use \"from,to\".`;\n              return null;\n            }\n            let from = parts[0].trim();\n            let to = parts[1].trim();\n            if (!nodes.includes(from)) {\n              errorDiv.textContent = `Edge source node \"${from}\" not in nodes list.`;\n              return null;\n            }\n            if (!nodes.includes(to)) {\n              errorDiv.textContent = `Edge destination node \"${to}\" not in nodes list.`;\n              return null;\n            }\n            edges.push([from, to]);\n          }\n        }\n        return { nodes, edges };\n      }\n\n      // Highlight step by step the topological sort order\n      async function animateTopoSort(nodes, edges, order) {\n        graphRenderer.layoutNodes(nodes, edges);\n        let highlights = [];\n        resultDiv.textContent = \"Animating topological order...\";\n        for (let i = 0; i < order.length; i++) {\n          highlights.push(order[i]);\n          // highlight all edges from previously highlighted nodes to current node\n          let hlEdges = [];\n          if (i > 0) {\n            for (let j = 0; j <= i; j++) {\n              for (let [from, to] of edges) {\n                if (highlights.includes(from) && to === order[j]) {\n                  hlEdges.push([from, to]);\n                }\n              }\n            }\n          }\n          graphRenderer.drawGraph(nodes, edges, highlights, hlEdges);\n          await new Promise(r => setTimeout(r, 700));\n        }\n        resultDiv.textContent = `Topological order: ${order.join(\" â†’ \")}`;\n      }\n\n      runBtn.addEventListener(\"click\", async () => {\n        const parsed = parseInput();\n        if (!parsed) return;\n\n        const { nodes, edges } = parsed;\n\n        const { order, hasCycle } = topologicalSort(nodes, edges);\n\n        if (hasCycle) {\n          errorDiv.textContent = \"Graph has at least one cycle. Topological sort not possible.\";\n          graphRenderer.layoutNodes(nodes, edges);\n          graphRenderer.drawGraph(nodes, edges);\n          resultDiv.textContent = \"\";\n          return;\n        } else {\n          errorDiv.textContent = \"\";\n          await animateTopoSort(nodes, edges, order);\n        }\n      });\n\n      // Initial rendering\n      (function initialRender() {\n        const parsed = parseInput();\n        if (parsed) {\n          const { nodes, edges } = parsed;\n          graphRenderer.layoutNodes(nodes, edges);\n          graphRenderer.drawGraph(nodes, edges);\n        }\n      })();\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}