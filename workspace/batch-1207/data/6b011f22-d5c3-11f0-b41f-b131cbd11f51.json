{
  "id": "6b011f22-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:30:30.156Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background-color: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        .description {\n            text-align: center;\n            margin-bottom: 30px;\n            line-height: 1.6;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 10px;\n            margin-bottom: 20px;\n        }\n        button {\n            padding: 10px 20px;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n            transition: background-color 0.3s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #95a5a6;\n            cursor: not-allowed;\n        }\n        .canvas-container {\n            position: relative;\n            margin-bottom: 30px;\n        }\n        canvas {\n            display: block;\n            margin: 0 auto;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            background-color: white;\n        }\n        .info-panel {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 20px;\n            margin-top: 20px;\n        }\n        .panel {\n            background-color: #f9f9f9;\n            padding: 15px;\n            border-radius: 4px;\n            border-left: 4px solid #3498db;\n        }\n        h2 {\n            color: #2c3e50;\n            margin-top: 0;\n            font-size: 18px;\n        }\n        .algorithm-steps {\n            grid-column: span 2;\n        }\n        #step-list {\n            list-style-type: none;\n            padding: 0;\n        }\n        #step-list li {\n            padding: 5px 0;\n            border-bottom: 1px solid #eee;\n        }\n        #step-list li.active {\n            background-color: #e8f4fd;\n            font-weight: bold;\n        }\n        .log {\n            font-family: monospace;\n            font-size: 14px;\n            background-color: #2c3e50;\n            color: #ecf0f1;\n            padding: 10px;\n            border-radius: 4px;\n            height: 150px;\n            overflow-y: auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Kruskal's Algorithm Visualization</h1>\n        \n        <div class=\"description\">\n            <p>Kruskal's Algorithm is a greedy algorithm that finds a Minimum Spanning Tree (MST) for a weighted undirected graph.</p>\n            <p>The algorithm works by sorting all edges from lowest to highest weight, then adding them to the MST if they don't form a cycle.</p>\n        </div>\n        \n        <div class=\"controls\">\n            <button id=\"generate-btn\">Generate New Graph</button>\n            <button id=\"step-btn\">Next Step</button>\n            <button id=\"auto-btn\">Auto Run</button>\n            <button id=\"reset-btn\">Reset</button>\n        </div>\n        \n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n        </div>\n        \n        <div class=\"info-panel\">\n            <div class=\"panel\">\n                <h2>Current Edge</h2>\n                <div id=\"current-edge\">None</div>\n            </div>\n            \n            <div class=\"panel\">\n                <h2>MST Weight</h2>\n                <div id=\"mst-weight\">0</div>\n            </div>\n            \n            <div class=\"panel algorithm-steps\">\n                <h2>Algorithm Steps</h2>\n                <ul id=\"step-list\"></ul>\n            </div>\n            \n            <div class=\"panel\">\n                <h2>Execution Log</h2>\n                <div id=\"log\" class=\"log\"></div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // DOM elements\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        const generateBtn = document.getElementById('generate-btn');\n        const stepBtn = document.getElementById('step-btn');\n        const autoBtn = document.getElementById('auto-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const currentEdgeDisplay = document.getElementById('current-edge');\n        const mstWeightDisplay = document.getElementById('mst-weight');\n        const stepList = document.getElementById('step-list');\n        const logDisplay = document.getElementById('log');\n\n        // Graph configuration\n        let vertices = [];\n        let edges = [];\n        let mstEdges = [];\n        let currentStep = 0;\n        let isRunning = false;\n        let autoInterval;\n        \n        // Union-Find data structure for cycle detection\n        class UnionFind {\n            constructor(size) {\n                this.parent = new Array(size);\n                this.rank = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    this.parent[i] = i;\n                    this.rank[i] = 0;\n                }\n            }\n            \n            find(x) {\n                if (this.parent[x] !== x) {\n                    this.parent[x] = this.find(this.parent[x]);\n                }\n                return this.parent[x];\n            }\n            \n            union(x, y) {\n                let rootX = this.find(x);\n                let rootY = this.find(y);\n                \n                if (rootX !== rootY) {\n                    if (this.rank[rootX] < this.rank[rootY]) {\n                        this.parent[rootX] = rootY;\n                    } else if (this.rank[rootX] > this.rank[rootY]) {\n                        this.parent[rootY] = rootX;\n                    } else {\n                        this.parent[rootY] = rootX;\n                        this.rank[rootX]++;\n                    }\n                    return true;\n                }\n                return false;\n            }\n        }\n        \n        let uf;\n\n        // Initialize visualization\n        function init() {\n            generateGraph();\n            resetVisualization();\n            \n            // Clear logs and step list\n            logDisplay.innerHTML = '';\n            stepList.innerHTML = '';\n            \n            // Add initial steps description\n            addStep(\"Initialize: Sort all edges by weight\", 0);\n            addStep(\"Process edges in sorted order\", 1);\n            addStep(\"If edge doesn't form a cycle, add to MST\", 2);\n            addStep(\"Continue until MST has V-1 edges\", 3);\n            addStep(\"MST complete\", 4);\n            \n            // Update MST weight display\n            updateMSTWeight();\n        }\n        \n        // Generate a random graph\n        function generateGraph() {\n            vertices = [];\n            edges = [];\n            \n            const numVertices = Math.floor(Math.random() * 6) + 6; // 6 to 11 vertices\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const radius = Math.min(canvas.width, canvas.height) * 0.35;\n            \n            // Create vertices in a circular layout\n            for (let i = 0; i < numVertices; i++) {\n                const angle = (2 * Math.PI * i) / numVertices;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                \n                vertices.push({\n                    id: i,\n                    x: x,\n                    y: y,\n                    label: String.fromCharCode(65 + i) // A, B, C, ...\n                });\n            }\n            \n            // Create edges with random weights - ensuring connectivity\n            const connected = new Set();\n            const unconnected = new Set([...Array(numVertices).keys()]);\n            \n            // First, create a spanning tree to ensure connectivity\n            const shuffledIndices = [...Array(numVertices).keys()].sort(() => Math.random() - 0.5);\n            \n            for (let i = 1; i < numVertices; i++) {\n                const v1 = shuffledIndices[i];\n                const v2 = shuffledIndices[Math.floor(Math.random() * i)];\n                const weight = Math.floor(Math.random() * 20) + 1;\n                \n                edges.push({\n                    v1: v1,\n                    v2: v2,\n                    weight: weight,\n                    id: edges.length\n                });\n                \n                connected.add(v1);\n                connected.add(v2);\n                unconnected.delete(v1);\n                unconnected.delete(v2);\n            }\n            \n            // Add some additional edges randomly\n            const maxEdges = Math.floor(numVertices * (numVertices - 1) / 3);\n            while (edges.length < maxEdges) {\n                const v1 = Math.floor(Math.random() * numVertices);\n                let v2 = Math.floor(Math.random() * numVertices);\n                \n                // Ensure v1 != v2 and edge doesn't already exist\n                if (v1 === v2) continue;\n                \n                const edgeExists = edges.some(e => \n                    (e.v1 === v1 && e.v2 === v2) || (e.v1 === v2 && e.v2 === v1)\n                );\n                \n                if (!edgeExists) {\n                    const weight = Math.floor(Math.random() * 20) + 1;\n                    edges.push({\n                        v1: v1,\n                        v2: v2,\n                        weight: weight,\n                        id: edges.length\n                    });\n                }\n            }\n            \n            // Sort edges by weight for Kruskal's algorithm\n            edges.sort((a, b) => a.weight - b.weight);\n            \n            log(`Generated graph with ${numVertices} vertices and ${edges.length} edges`);\n            \n            // Initialize Union-Find structure\n            uf = new UnionFind(numVertices);\n        }\n        \n        // Reset visualization to initial state\n        function resetVisualization() {\n            mstEdges = [];\n            currentStep = 0;\n            isRunning = false;\n            uf = new UnionFind(vertices.length);\n            \n            // Reset button states\n            stepBtn.disabled = false;\n            autoBtn.disabled = false;\n            generateBtn.disabled = false;\n            \n            // Clear auto-run interval if active\n            if (autoInterval) {\n                clearInterval(autoInterval);\n                autoInterval = null;\n            }\n            \n            // Update displays\n            currentEdgeDisplay.textContent = 'None';\n            updateMSTWeight();\n            \n            // Update step list\n            const steps = stepList.querySelectorAll('li');\n            steps.forEach(step => step.classList.remove('active'));\n            if (steps.length > 0) steps[0].classList.add('active');\n            \n            log('Visualization reset');\n            drawGraph();\n        }\n        \n        // Execute next step of the algorithm\n        function nextStep() {\n            if (currentStep >= edges.length) {\n                log('Algorithm complete - MST found!');\n                stepBtn.disabled = true;\n                autoBtn.disabled = true;\n                return;\n            }\n            \n            const edge = edges[currentStep];\n            const v1Root = uf.find(edge.v1);\n            const v2Root = uf.find(edge.v2);\n            \n            currentEdgeDisplay.textContent = \n                `${vertices[edge.v1].label} - ${vertices[edge.v2].label} (weight: ${edge.weight})`;\n            \n            // Check if adding this edge would create a cycle\n            if (v1Root !== v2Root) {\n                // No cycle - add edge to MST\n                uf.union(edge.v1, edge.v2);\n                mstEdges.push(edge);\n                log(`Added edge ${vertices[edge.v1].label}-${vertices[edge.v2].label} (weight: ${edge.weight}) to MST`);\n            } else {\n                log(`Skipped edge ${vertices[edge.v1].label}-${vertices[edge.v2].label} (weight: ${edge.weight}) - would create cycle`);\n            }\n            \n            currentStep++;\n            \n            // Update step list highlighting\n            const steps = stepList.querySelectorAll('li');\n            steps.forEach(step => step.classList.remove('active'));\n            \n            if (currentStep < edges.length) {\n                steps[3].classList.add('active');\n            } else {\n                steps[4].classList.add('active');\n            }\n            \n            updateMSTWeight();\n            drawGraph();\n            \n            // Check if MST is complete (V-1 edges)\n            if (mstEdges.length === vertices.length - 1) {\n                log('MST complete! Found minimum spanning tree.');\n                stepBtn.disabled = true;\n                autoBtn.disabled = true;\n                if (autoInterval) {\n                    clearInterval(autoInterval);\n                    autoInterval = null;\n                }\n            }\n        }\n        \n        // Automatically run the algorithm\n        function autoRun() {\n            if (isRunning) {\n                // Stop auto-run\n                isRunning = false;\n                autoBtn.textContent = 'Auto Run';\n                if (autoInterval) {\n                    clearInterval(autoInterval);\n                    autoInterval = null;\n                }\n                stepBtn.disabled = false;\n                generateBtn.disabled = false;\n            } else {\n                // Start auto-run\n                isRunning = true;\n                autoBtn.textContent = 'Stop';\n                stepBtn.disabled = true;\n                generateBtn.disabled = true;\n                \n                autoInterval = setInterval(() => {\n                    nextStep();\n                    \n                    // Stop if algorithm is complete\n                    if (currentStep >= edges.length || mstEdges.length === vertices.length - 1) {\n                        clearInterval(autoInterval);\n                        autoInterval = null;\n                        isRunning = false;\n                        autoBtn.textContent = 'Auto Run';\n                        stepBtn.disabled = true;\n                        generateBtn.disabled = false;\n                    }\n                }, 1000);\n            }\n        }\n        \n        // Update MST weight display\n        function updateMSTWeight() {\n            const weight = mstEdges.reduce((sum, edge) => sum + edge.weight, 0);\n            mstWeightDisplay.textContent = weight;\n        }\n        \n        // Add a step to the algorithm steps list\n        function addStep(text, index) {\n            const li = document.createElement('li');\n            li.textContent = text;\n            if (index === 0) li.classList.add('active');\n            stepList.appendChild(li);\n        }\n        \n        // Add a message to the log\n        function log(message) {\n            const timestamp = new Date().toLocaleTimeString();\n            logDisplay.innerHTML += `[${timestamp}] ${message}<br>`;\n            logDisplay.scrollTop = logDisplay.scrollHeight;\n        }\n        \n        // Draw the graph on the canvas\n        function drawGraph() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            edges.forEach(edge => {\n                const v1 = vertices[edge.v1];\n                const v2 = vertices[edge.v2];\n                \n                // Check if this edge is in MST\n                const isInMST = mstEdges.some(e => e.id === edge.id);\n                \n                // Check if this is the current edge being considered\n                const isCurrent = currentStep > 0 && edges[currentStep - 1].id === edge.id;\n                \n                // Set style based on edge status\n                if (isInMST) {\n                    ctx.strokeStyle = '#27ae60'; // Green for MST edges\n                    ctx.lineWidth = 3;\n                } else if (isCurrent) {\n                    ctx.strokeStyle = '#e74c3c'; // Red for current edge\n                    ctx.lineWidth = 3;\n                } else {\n                    ctx.strokeStyle = '#bdc3c7'; // Gray for other edges\n                    ctx.lineWidth = 1;\n                }\n                \n                // Draw the edge line\n                ctx.beginPath();\n                ctx.moveTo(v1.x, v1.y);\n                ctx.lineTo(v2.x, v2.y);\n                ctx.stroke();\n                \n                // Draw edge weight\n                const midX = (v1.x + v2.x) / 2;\n                const midY = (v1.y + v2.y) / 2;\n                \n                ctx.fillStyle = isInMST ? '#27ae60' : (isCurrent ? '#e74c3c' : '#34495e');\n                ctx.font = '12px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                \n                // Draw background for weight text\n                ctx.fillStyle = 'white';\n                ctx.fillRect(midX - 12, midY - 8, 24, 16);\n                \n                // Draw weight text\n                ctx.fillStyle = isInMST ? '#27ae60' : (isCurrent ? '#e74c3c' : '#34495e');\n                ctx.fillText(edge.weight, midX, midY);\n            });\n            \n            // Draw vertices\n            vertices.forEach(vertex => {\n                ctx.beginPath();\n                ctx.arc(vertex.x, vertex.y, 20, 0, 2 * Math.PI);\n                ctx.fillStyle = '#3498db';\n                ctx.fill();\n                ctx.strokeStyle = '#2980b9';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw vertex label\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(vertex.label, vertex.x, vertex.y);\n            });\n        }\n        \n        // Event listeners\n        generateBtn.addEventListener('click', init);\n        stepBtn.addEventListener('click', nextStep);\n        autoBtn.addEventListener('click', autoRun);\n        resetBtn.addEventListener('click', resetVisualization);\n        \n        // Initialize the visualization\n        init();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}