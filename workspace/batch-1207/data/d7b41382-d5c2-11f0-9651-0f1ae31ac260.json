{
  "id": "d7b41382-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:52.843Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex; flex-direction: column; align-items: center;\n    background: #f8f9fa;\n  }\n  h1 {\n    margin-top: 1rem;\n  }\n  #graphCanvas {\n    border: 1px solid #333;\n    background: white;\n    margin: 1rem 0;\n    cursor: pointer;\n  }\n  #controls {\n    margin-bottom: 1rem;\n  }\n  button {\n    margin: 0 0.3rem;\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n    cursor: pointer;\n  }\n  #info {\n    max-width: 700px;\n    background: #fff;\n    border: 1px solid #ddd;\n    padding: 1rem;\n    border-radius: 5px;\n    line-height: 1.4;\n  }\n  #weight-input {\n    width: 50px;\n  }\n  #instructions {\n    max-width: 700px;\n    background: #e2f0d9;\n    border: 1px solid #a3c293;\n    margin-bottom: 1rem;\n    padding: 0.8rem 1rem;\n    border-radius: 6px;\n    font-size: 0.95rem;\n  }\n  footer {\n    margin: 2rem 0 1rem 0;\n    font-size: 0.9rem;\n    color: #666;\n  }\n  a {\n    color: #0a66c2;\n  }\n</style>\n</head>\n<body>\n<h1>Prim's Algorithm Visualization</h1>\n\n<div id=\"instructions\">\n  <strong>Instructions:</strong>\n  <ul>\n    <li>Click on the canvas to add vertices (nodes).</li>\n    <li>Click two nodes one after another to create an edge, then enter the edge weight.</li>\n    <li>Repeat to build your undirected weighted graph.</li>\n    <li>Click <em>Reset Graph</em> to start over.</li>\n    <li>Once ready, select a starting node (green highlight) from dropdown and click <em>Run Prim's Algorithm</em>.</li>\n    <li>The minimum spanning tree edges appear in red, with total cost displayed.</li>\n  </ul>\n</div>\n\n<canvas id=\"graphCanvas\" width=\"700\" height=\"500\" aria-label=\"Graph Canvas\"></canvas>\n\n<div id=\"controls\">\n  <label for=\"startNodeSelect\">Start Node:</label>\n  <select id=\"startNodeSelect\" disabled aria-label=\"Select start node for Prim's algorithm\"></select>\n  <button id=\"runPrim\" disabled>Run Prim's Algorithm</button>\n  <button id=\"resetGraph\">Reset Graph</button>\n  <button id=\"clearMST\" disabled>Clear MST</button>\n</div>\n\n<div id=\"info\" aria-live=\"polite\" aria-atomic=\"true\" role=\"region\">\n  Build a graph by adding nodes and edges above.\n</div>\n\n<footer>\n  &copy; 2024 &mdash; Prim's Algorithm Demo | <a href=\"https://en.wikipedia.org/wiki/Prim%27s_algorithm\" target=\"_blank\" rel=\"noopener\">Learn more</a>\n</footer>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const info = document.getElementById('info');\n  const startNodeSelect = document.getElementById('startNodeSelect');\n  const runPrimBtn = document.getElementById('runPrim');\n  const resetGraphBtn = document.getElementById('resetGraph');\n  const clearMSTBtn = document.getElementById('clearMST');\n\n  const NODE_RADIUS = 20;\n  const EDGE_COLOR = '#555';\n  const SELECTED_EDGE_COLOR = '#c0392b'; // red for MST edges\n  const NODE_COLOR = '#2980b9';\n  const NODE_HIGHLIGHT_COLOR = '#27ae60'; // green for start node\n  const NODE_SELECTED_COLOR = '#f39c12';\n  const EDGE_SELECTED_COLOR = '#f39c12';\n\n  let nodes = [];\n  let edges = [];\n  /*\n    nodes: {id: Number, x: Number, y: Number}\n    edges: {id1: Number, id2: Number, weight: Number, inMST: Boolean}\n  */\n\n  let edgeCreationStep = 0; // 0: waiting for first node, 1: waiting for second node\n  let edgeFirstNode = null;\n\n  let mstEdges = [];\n\n  function distance(x1,y1,x2,y2) {\n    return Math.sqrt((x1-x2)**2 + (y1-y2)**2);\n  }\n\n  function draw() {\n    ctx.clearRect(0,0, canvas.width, canvas.height);\n\n    // Draw all edges\n    edges.forEach(edge => {\n      const n1 = nodes.find(n => n.id === edge.id1);\n      const n2 = nodes.find(n => n.id === edge.id2);\n      if (!n1 || !n2) return;\n      ctx.beginPath();\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      ctx.strokeStyle = edge.inMST ? SELECTED_EDGE_COLOR : EDGE_COLOR;\n      ctx.lineWidth = edge.inMST ? 4 : 2;\n      ctx.stroke();\n\n      // Draw weight label at midpoint\n      const mx = (n1.x + n2.x) / 2;\n      const my = (n1.y + n2.y) / 2;\n      ctx.fillStyle = edge.inMST ? SELECTED_EDGE_COLOR : '#000';\n      ctx.font = '14px Arial';\n      ctx.fillText(edge.weight, mx + 5, my - 5);\n    });\n\n    // Draw nodes\n    nodes.forEach(node => {\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);\n      let fillStyle = NODE_COLOR;\n      // Highlight start node green\n      if (node.id === +startNodeSelect.value) fillStyle = NODE_HIGHLIGHT_COLOR;\n      // Highlight selected node for edge creation\n      if (edgeFirstNode && node.id === edgeFirstNode.id) fillStyle = NODE_SELECTED_COLOR;\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Draw node id inside\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n    });\n\n    // If waiting for second node, show helper line from first node to mouse position\n    if(edgeCreationStep === 1 && edgeFirstNode && lastMousePos){\n      ctx.beginPath();\n      ctx.moveTo(edgeFirstNode.x, edgeFirstNode.y);\n      ctx.lineTo(lastMousePos.x, lastMousePos.y);\n      ctx.strokeStyle = EDGE_SELECTED_COLOR;\n      ctx.lineWidth = 1;\n      ctx.setLineDash([5,5]);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n  }\n\n  // Detect node at mouse position\n  function getNodeAt(x,y) {\n    return nodes.find(n => distance(n.x, n.y, x, y) <= NODE_RADIUS);\n  }\n\n  // Add node at position, assign next id\n  function addNode(x,y) {\n    const newId = nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 1;\n    nodes.push({id:newId, x, y});\n    updateStartNodeSelect();\n    info.textContent = `Node ${newId} added. Now add edges by clicking two nodes in succession.`;\n    runPrimBtn.disabled = false;\n    clearMSTBtn.disabled = true;\n    draw();\n  }\n\n  // Add edge between two nodes\n  function addEdge(id1, id2, weight) {\n    // Check duplicate edge or self-loop\n    if(id1 === id2) return false;\n    if(edges.some(e => (e.id1 === id1 && e.id2 === id2) || (e.id1 === id2 && e.id2 === id1))) {\n      return false;\n    }\n    edges.push({id1, id2, weight, inMST:false});\n    info.textContent = `Edge added between node ${id1} and node ${id2} with weight ${weight}.`;\n    clearMSTBtn.disabled = true;\n    draw();\n    return true;\n  }\n\n  // Prompt to enter weight for an edge\n  function promptWeight() {\n    let weight = null;\n    while (true) {\n      weight = prompt(\"Enter edge weight (positive integer):\", \"1\");\n      if (weight === null) return null;\n      weight = parseInt(weight);\n      if (!Number.isNaN(weight) && weight > 0) return weight;\n      alert(\"Please enter a positive integer weight.\");\n    }\n  }\n\n  // Implement Prim's Algorithm\n  function prim(startId) {\n    // Reset MST flags first\n    edges.forEach(e => e.inMST = false);\n    mstEdges = [];\n\n    const selected = new Set();\n    selected.add(startId);\n\n    // Create adjacency list for graph (undirected)\n    const adjacency = {};\n    nodes.forEach(n => adjacency[n.id] = []);\n    edges.forEach(e => {\n      adjacency[e.id1].push({node:e.id2, weight:e.weight});\n      adjacency[e.id2].push({node:e.id1, weight:e.weight});\n    });\n\n    let totalCost = 0;\n\n    while(selected.size < nodes.length) {\n      let minEdge = null;\n      let minWeight = Infinity;\n\n      selected.forEach(u => {\n        adjacency[u].forEach(({node:v, weight:w}) => {\n          if (!selected.has(v) && w < minWeight) {\n            minWeight = w;\n            minEdge = {id1: u, id2: v, weight: w};\n          }\n        });\n      });\n\n      if (!minEdge) break; // Graph not connected\n\n      selected.add(minEdge.id2);\n      totalCost += minEdge.weight;\n\n      // Mark edge in the edges array inMST = true\n      const edge = edges.find(e => \n        (e.id1 === minEdge.id1 && e.id2 === minEdge.id2) || (e.id1 === minEdge.id2 && e.id2 === minEdge.id1));\n      if (edge) edge.inMST = true;\n      mstEdges.push(minEdge);\n    }\n\n    draw();\n\n    // Check if MST includes all nodes\n    if(selected.size === nodes.length) {\n      info.textContent = `Prim's algorithm completed. Total cost of MST: ${totalCost}.`;\n      clearMSTBtn.disabled = false;\n    } else {\n      info.textContent = 'Graph is not connected. MST cannot be formed covering all nodes.';\n      clearMSTBtn.disabled = false;\n    }\n  }\n\n  // Update start node dropdown for Prim's\n  function updateStartNodeSelect() {\n    startNodeSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const option = document.createElement('option');\n      option.value = n.id;\n      option.textContent = `Node ${n.id}`;\n      startNodeSelect.appendChild(option);\n    });\n    startNodeSelect.disabled = nodes.length === 0;\n    runPrimBtn.disabled = nodes.length === 0;\n  }\n\n  // Clear MST edges shown (reset inMST)\n  function clearMST() {\n    edges.forEach(e => e.inMST = false);\n    mstEdges = [];\n    clearMSTBtn.disabled = true;\n    info.textContent = 'MST cleared. You can run Prim\\'s algorithm again.';\n    draw();\n  }\n\n  // Reset entire graph\n  function resetGraph() {\n    nodes = [];\n    edges = [];\n    mstEdges = [];\n    edgeCreationStep = 0;\n    edgeFirstNode = null;\n    startNodeSelect.innerHTML = '';\n    startNodeSelect.disabled = true;\n    runPrimBtn.disabled = true;\n    clearMSTBtn.disabled = true;\n    info.textContent = 'Graph reset. Add new nodes by clicking on the canvas.';\n    draw();\n  }\n\n  // Variables for mouse move helper line\n  let lastMousePos = null;\n\n  // Event listeners\n  canvas.addEventListener('click', e => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const clickedNode = getNodeAt(x,y);\n\n    if(edgeCreationStep === 0) {\n      if(clickedNode) {\n        // First node for edge creation selected\n        edgeFirstNode = clickedNode;\n        edgeCreationStep = 1;\n        info.textContent = `Selected Node ${edgeFirstNode.id} as first node for edge. Click second node to connect.`;\n        draw();\n      } else {\n        // Add a new node\n        addNode(x,y);\n      }\n    } else if(edgeCreationStep === 1) {\n      if(clickedNode && clickedNode.id !== edgeFirstNode.id) {\n        // Add edge from edgeFirstNode to clickedNode\n        // Prompt weight input\n        let weight = promptWeight();\n        if(weight !== null) {\n          const added = addEdge(edgeFirstNode.id, clickedNode.id, weight);\n          if(!added) {\n            alert('Edge already exists or invalid. Try a different node.');\n          }\n          edgeCreationStep = 0;\n          edgeFirstNode = null;\n          info.textContent += ` Ready to add new edges or nodes.`;\n          draw();\n        } else {\n          info.textContent = 'Edge creation cancelled. Select first node again or add nodes.';\n          edgeCreationStep = 0;\n          edgeFirstNode = null;\n          draw();\n        }\n      } else {\n        info.textContent = 'You must select a different second node to create edge. Operation cancelled.';\n        edgeCreationStep = 0;\n        edgeFirstNode = null;\n        draw();\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', e => {\n    if(edgeCreationStep === 1 && edgeFirstNode) {\n      const rect = canvas.getBoundingClientRect();\n      lastMousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n      draw();\n    }\n  });\n\n  runPrimBtn.addEventListener('click', () => {\n    if(nodes.length === 0) {\n      alert('No nodes to run algorithm on.');\n      return;\n    }\n    prim(+startNodeSelect.value);\n  });\n\n  resetGraphBtn.addEventListener('click', () => {\n    if(confirm('Are you sure you want to reset the entire graph?')) {\n      resetGraph();\n    }\n  });\n\n  clearMSTBtn.addEventListener('click', () => {\n    clearMST();\n  });\n\n  // On load init\n  resetGraph();\n\n  // Accessibility: keyboard support to add nodes and edges could be added,\n  // but for simplicity this demo uses mouse interaction.\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}