{
  "id": "e9332651-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:41.182Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Interactive Weighted Graph Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #60a5fa;\n      --accent-2: #34d399;\n      --muted: #94a3b8;\n      --danger: #fb7185;\n      --canvas: #071024;\n      --card: #071029;\n    }\n    html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:linear-gradient(180deg,var(--bg),#061224 60%); color:#e6eef8; }\n    .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n    .left {\n      width:75%;\n      background:linear-gradient(180deg,var(--canvas),#031024);\n      border-radius:12px;\n      padding:12px;\n      box-sizing:border-box;\n      position:relative;\n      box-shadow:0 6px 30px rgba(2,6,23,0.7);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .topbar { display:flex; gap:8px; align-items:center; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    button, select, input[type=\"number\"], .mode-toggle {\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      transition:all .15s;\n    }\n    button:hover, .mode-toggle:hover { transform:translateY(-2px); border-color:rgba(255,255,255,0.12); color:#fff; }\n    button.primary { background:linear-gradient(90deg,var(--accent),#7dd3fc); color:#07203a; border:none; }\n    .mode-toggle.active { border-color:var(--accent); color:var(--accent); box-shadow:0 4px 18px rgba(96,165,250,0.08); }\n    .right {\n      width:25%;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .panel {\n      background:linear-gradient(180deg,var(--panel),var(--card));\n      padding:12px;\n      border-radius:12px;\n      box-shadow:0 6px 16px rgba(2,6,23,0.5);\n      overflow:auto;\n    }\n    .canvas-wrap { flex:1; border-radius:10px; background:transparent; position:relative; }\n    svg { width:100%; height:100%; display:block; border-radius:8px; cursor:crosshair; }\n    .hint { font-size:12px; color:var(--muted); }\n    .small { font-size:13px; color:var(--muted); }\n    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .legend .chip { padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.03); color:var(--muted); font-size:13px; border:1px dashed rgba(255,255,255,0.03); }\n    .adj { font-family:monospace; font-size:13px; color:#dbeafe; white-space:pre-wrap; }\n    .footer { display:flex; justify-content:space-between; align-items:center; gap:8px; }\n    .info-line { font-size:13px; color:var(--muted); }\n    .weight-badge { background:rgba(0,0,0,0.45); padding:4px 6px; border-radius:6px; font-size:12px; color:#fff; border:1px solid rgba(255,255,255,0.04); }\n    .status { font-size:13px; color:var(--muted); }\n    .title { font-weight:600; color:#e6f0ff; }\n    a { color:var(--accent); text-decoration:none; }\n    .small-muted { font-size:12px; color:var(--muted); }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <div class=\"topbar\">\n        <div style=\"display:flex;flex-direction:column;\">\n          <div class=\"title\">Interactive Weighted Graph</div>\n          <div class=\"small-muted\">Create nodes & edges, set weights, run Dijkstra or MST (Prim). Drag to move nodes.</div>\n        </div>\n        <div style=\"flex:1\"></div>\n        <div class=\"controls\">\n          <button id=\"mode-add\" class=\"mode-toggle active\" title=\"Add node\">Add Node</button>\n          <button id=\"mode-edge\" class=\"mode-toggle\" title=\"Add edge (click two nodes)\">Add Edge</button>\n          <button id=\"mode-move\" class=\"mode-toggle\" title=\"Move nodes\">Move</button>\n          <button id=\"mode-del\" class=\"mode-toggle\" title=\"Delete node/edge\">Delete</button>\n\n          <label class=\"small-muted\" title=\"Default weight when adding edges\">Default weight</label>\n          <input id=\"default-weight\" type=\"number\" min=\"1\" value=\"1\" style=\"width:70px\" />\n\n          <label style=\"display:flex;align-items:center;gap:6px;\">\n            <input id=\"directed\" type=\"checkbox\" /> &nbsp;<span class=\"small-muted\">Directed</span>\n          </label>\n\n          <button id=\"random\" title=\"Generate random graph\">Random</button>\n          <button id=\"clear\" title=\"Clear graph\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap panel\" style=\"padding:8px;\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        <div style=\"position:absolute;right:18px;bottom:12px;\">\n          <div class=\"weight-badge\" id=\"status\">Mode: Add Node</div>\n        </div>\n      </div>\n\n      <div class=\"footer\" style=\"margin-top:8px;\">\n        <div style=\"display:flex; gap:8px; align-items:center;\">\n          <button id=\"dijkstra\" class=\"primary\">Dijkstra (Shortest Path)</button>\n          <button id=\"prim\">Prim's MST</button>\n          <button id=\"animate-steps\">Toggle Step Animation</button>\n          <div class=\"hint\">Click source and target when running Dijkstra. For MST it picks a node.</div>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <div class=\"small-muted\">Selected:</div>\n          <div id=\"selected-info\" class=\"weight-badge\">None</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"panel\">\n        <div class=\"title\">Graph Info</div>\n        <div style=\"margin-top:8px;\">\n          <div class=\"small-muted\">Nodes: <span id=\"node-count\">0</span> &nbsp; Edges: <span id=\"edge-count\">0</span></div>\n          <div style=\"margin-top:8px;\">\n            <div class=\"small-muted\">Adjacency List</div>\n            <div id=\"adj\" class=\"adj\">[]</div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"title\">How to Use</div>\n        <ol style=\"color:var(--muted); font-size:13px; margin-top:8px; padding-left:18px;\">\n          <li>Click 'Add Node' then click anywhere on the canvas to create nodes.</li>\n          <li>Choose 'Add Edge', click two nodes to connect them. You'll be prompted for a weight.</li>\n          <li>Drag in 'Move' mode to reposition nodes.</li>\n          <li>'Delete' mode removes a clicked node or edge.</li>\n          <li>Toggle 'Directed' to make edges directed.</li>\n          <li>Click 'Dijkstra' then click source and target nodes to find shortest path.</li>\n          <li>Click 'Prim' to compute a minimum spanning tree (undirected edges considered).</li>\n        </ol>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"title\">Legend</div>\n        <div class=\"legend\" style=\"margin-top:8px;\">\n          <div class=\"chip\">Blue edge = normal</div>\n          <div class=\"chip\" style=\"background:linear-gradient(90deg,#f97316,#fb923c);color:#071022\">Orange = active / selected</div>\n          <div class=\"chip\" style=\"background:linear-gradient(90deg,#34d399,#10b981);color:#042018\">Green = result (path / MST)</div>\n          <div class=\"chip\">Hover nodes to see id and distance during algorithms</div>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n<script>\n(function(){\n  const svg = document.getElementById('svg');\n  const MODE_ADD = 'add';\n  const MODE_EDGE = 'edge';\n  const MODE_MOVE = 'move';\n  const MODE_DEL = 'del';\n  let mode = MODE_ADD;\n  let directed = false;\n  let defaultWeight = 1;\n  let animateSteps = true;\n\n  let nodes = []; // {id,x,y}\n  let edges = []; // {id,a,b,w,directed}\n  let nodeIdCounter = 0, edgeIdCounter = 0;\n\n  const R = 18; // node radius\n  const showStatus = document.getElementById('status');\n  const nodeCountEl = document.getElementById('node-count');\n  const edgeCountEl = document.getElementById('edge-count');\n  const adjEl = document.getElementById('adj');\n  const selectedInfo = document.getElementById('selected-info');\n\n  const modeButtons = {\n    add: document.getElementById('mode-add'),\n    edge: document.getElementById('mode-edge'),\n    move: document.getElementById('mode-move'),\n    del: document.getElementById('mode-del')\n  };\n\n  function setMode(newMode) {\n    mode = newMode;\n    showStatus.textContent = 'Mode: ' + (mode === MODE_ADD ? 'Add Node' : mode === MODE_EDGE ? 'Add Edge' : mode === MODE_MOVE ? 'Move' : 'Delete');\n    for (let k in modeButtons) modeButtons[k].classList.toggle('active', k === newMode);\n    resetSelections();\n  }\n\n  modeButtons.add.addEventListener('click', ()=> setMode(MODE_ADD));\n  modeButtons.edge.addEventListener('click', ()=> setMode(MODE_EDGE));\n  modeButtons.move.addEventListener('click', ()=> setMode(MODE_MOVE));\n  modeButtons.del.addEventListener('click', ()=> setMode(MODE_DEL));\n\n  document.getElementById('default-weight').addEventListener('change', (e)=>{\n    defaultWeight = Math.max(0, Number(e.target.value) || 0);\n  });\n\n  document.getElementById('directed').addEventListener('change', (e)=>{\n    directed = e.target.checked;\n  });\n\n  document.getElementById('clear').addEventListener('click', ()=>{\n    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;\n    resetSelections();\n    redraw();\n  });\n\n  document.getElementById('random').addEventListener('click', ()=>{\n    generateRandomGraph();\n  });\n\n  document.getElementById('dijkstra').addEventListener('click', ()=>{\n    startDijkstraMode();\n  });\n\n  document.getElementById('prim').addEventListener('click', ()=>{\n    runPrimMST();\n  });\n\n  document.getElementById('animate-steps').addEventListener('click', ()=>{\n    animateSteps = !animateSteps;\n    alert('Step animation ' + (animateSteps ? 'ON' : 'OFF'));\n  });\n\n  function generateRandomGraph(){\n    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;\n    const n = 8 + Math.floor(Math.random()*6);\n    for (let i=0;i<n;i++){\n      nodes.push({id: nodeIdCounter++, x: 120 + Math.random()*960, y: 80 + Math.random()*520});\n    }\n    // Add roughly 1.5*n edges\n    const m = Math.floor(n * (1.4 + Math.random()*0.8));\n    for (let i=0;i<m;i++){\n      const a = nodes[Math.floor(Math.random()*nodes.length)];\n      const b = nodes[Math.floor(Math.random()*nodes.length)];\n      if (a === b) continue;\n      // prevent duplicate edge (simple check for undirected)\n      if (edges.some(e => (e.a===a.id && e.b===b.id) || (!directed && e.a===b.id && e.b===a.id))) continue;\n      edges.push({id: edgeIdCounter++, a:a.id, b:b.id, w: 1+Math.floor(Math.random()*15), directed: Math.random() < 0.2});\n    }\n    redraw();\n  }\n\n  // Rendering\n  function redraw(highlight = {}) {\n    // highlight: {pathEdges:Set(edgeId), pathNodes:Set(nodeId), activeEdge:edgeId, activeNode:nodeId, mstEdges:Set}\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n    // defs for arrowheads\n    const defs = createSvg('defs', {});\n    defs.innerHTML = `\n      <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"10\" refY=\"3.5\" orient=\"auto\">\n        <path d=\"M0,0 L10,3.5 L0,7 z\" fill=\"#60a5fa\"></path>\n      </marker>\n      <marker id=\"arrowhead-orange\" markerWidth=\"10\" markerHeight=\"7\" refX=\"10\" refY=\"3.5\" orient=\"auto\">\n        <path d=\"M0,0 L10,3.5 L0,7 z\" fill=\"#fb923c\"></path>\n      </marker>\n      <marker id=\"arrowhead-green\" markerWidth=\"10\" markerHeight=\"7\" refX=\"10\" refY=\"3.5\" orient=\"auto\">\n        <path d=\"M0,0 L10,3.5 L0,7 z\" fill=\"#34d399\"></path>\n      </marker>\n    `;\n    svg.appendChild(defs);\n\n    // draw edges\n    const edgeGroup = createSvg('g', {});\n    // sort so selected/highlight edges drawn last\n    const normalEdges = edges.filter(e => !highlight.pathEdges || !highlight.pathEdges.has(e.id));\n    normalEdges.forEach(e => {\n      const a = nodes.find(n => n.id === e.a);\n      const b = nodes.find(n => n.id === e.b);\n      if (!a || !b) return;\n      drawEdge(edgeGroup, e, a, b, highlight);\n    });\n    if (highlight.pathEdges) {\n      highlight.pathEdges.forEach(eid=>{\n        const e = edges.find(z=>z.id===eid); if (!e) return;\n        const a = nodes.find(n => n.id === e.a);\n        const b = nodes.find(n => n.id === e.b);\n        drawEdge(edgeGroup, e, a, b, highlight, true);\n      });\n    }\n    svg.appendChild(edgeGroup);\n\n    // draw nodes\n    const nodeGroup = createSvg('g', {});\n    nodes.forEach(n => {\n      drawNode(nodeGroup, n, highlight);\n    });\n    svg.appendChild(nodeGroup);\n\n    updateStats();\n  }\n\n  function drawEdge(parent, e, a, b, highlight, emphasized=false) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const dist = Math.hypot(dx, dy);\n    const ux = dx / dist;\n    const uy = dy / dist;\n    const startX = a.x + ux * R;\n    const startY = a.y + uy * R;\n    const endX = b.x - ux * R;\n    const endY = b.y - uy * R;\n\n    const isPath = highlight.pathEdges && highlight.pathEdges.has(e.id);\n    const stroke = isPath ? '#34d399' : (highlight.activeEdge === e.id ? '#fb923c' : '#60a5fa');\n    const strokeWidth = isPath ? 4 : (highlight.activeEdge === e.id ? 4 : 2);\n    const markerId = isPath ? 'arrowhead-green' : (highlight.activeEdge === e.id ? 'arrowhead-orange' : 'arrowhead');\n\n    const line = createSvg('line', { x1:startX, y1:startY, x2:endX, y2:endY, stroke, 'stroke-width':strokeWidth, 'stroke-linecap':'round' });\n    if (e.directed || e.directed === true) {\n      line.setAttribute('marker-end', `url(#${markerId})`);\n    } else if (directed) {\n      // if global directed toggle on and edge isn't directed, show symmetric small arrow?\n      // We'll only show arrows if edge.directed true or global directed toggled when adding.\n    }\n    line.style.cursor = 'pointer';\n    line.addEventListener('click', (ev)=>{\n      ev.stopPropagation();\n      if (mode === MODE_DEL) {\n        if (confirm('Delete this edge?')) {\n          edges = edges.filter(x=>x.id!==e.id);\n          redraw();\n        }\n      } else {\n        // toggle highlight\n        resetSelections();\n        redraw({activeEdge: e.id});\n        selectedInfo.textContent = `Edge ${e.id} (${e.a} → ${e.b}) w=${e.w}`;\n      }\n    });\n\n    parent.appendChild(line);\n\n    // weight label at midpoint with offset perpendicular\n    const mx = (startX + endX) / 2;\n    const my = (startY + endY) / 2;\n    const px = -uy; const py = ux; // perpendicular\n    const labelX = mx + px * 10;\n    const labelY = my + py * 10;\n\n    const rect = createSvg('rect', { x: labelX - 18, y: labelY - 12, rx:6, ry:6, width: 36, height: 20, fill: 'rgba(0,0,0,0.45)', stroke: 'rgba(255,255,255,0.03)', 'pointer-events':'none' });\n    parent.appendChild(rect);\n    const text = createSvg('text', { x: labelX, y: labelY + 4, 'text-anchor':'middle', 'font-size':12, fill:'#e6f0ff', 'pointer-events':'none' });\n    text.textContent = e.w;\n    parent.appendChild(text);\n  }\n\n  function drawNode(parent, n, highlight) {\n    const isPathNode = highlight.pathNodes && highlight.pathNodes.has(n.id);\n    const fill = isPathNode ? '#10b981' : (highlight.activeNode === n.id ? '#fb923c' : '#071a32');\n    const stroke = isPathNode ? '#34d399' : (highlight.activeNode === n.id ? '#fb923c' : '#60a5fa');\n    const strokeWidth = isPathNode ? 3 : (highlight.activeNode === n.id ? 3 : 2);\n\n    const g = createSvg('g', { transform:`translate(${n.x},${n.y})` });\n    const circle = createSvg('circle', { cx:0, cy:0, r:R, fill, stroke, 'stroke-width': strokeWidth });\n    circle.style.cursor = 'pointer';\n    circle.addEventListener('mousedown', (ev)=>{\n      ev.stopPropagation();\n      if (mode === MODE_MOVE) {\n        startDrag(n, ev);\n      } else if (mode === MODE_ADD) {\n        // do nothing (can't add node on existing)\n      } else if (mode === MODE_EDGE) {\n        handleEdgeClick(n);\n      } else if (mode === MODE_DEL) {\n        if (confirm('Delete node ' + n.id + ' and its edges?')) {\n          edges = edges.filter(e => e.a!==n.id && e.b!==n.id);\n          nodes = nodes.filter(nd => nd.id!==n.id);\n          redraw();\n        }\n      }\n    });\n    circle.addEventListener('click', (ev)=> {\n      ev.stopPropagation();\n      // update selected info if not edge mode\n      if (mode !== MODE_EDGE) {\n        resetSelections();\n        redraw({activeNode: n.id});\n        selectedInfo.textContent = `Node ${n.id}`;\n      }\n    });\n    circle.addEventListener('mouseenter', ()=>{\n      // show tooltip-ish by drawing label nearby\n      redraw({activeNode: n.id});\n    });\n    g.appendChild(circle);\n    const text = createSvg('text', { x:0, y:6, 'text-anchor':'middle', 'font-size':13, fill:'#fff', 'pointer-events':'none' });\n    text.textContent = n.id;\n    g.appendChild(text);\n    parent.appendChild(g);\n  }\n\n  function createSvg(tag, attrs) {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    for (const k in attrs) el.setAttribute(k, attrs[k]);\n    return el;\n  }\n\n  // Interaction\n  svg.addEventListener('click', (ev)=>{\n    const pt = svgPoint(ev);\n    if (mode === MODE_ADD) {\n      addNode(pt.x, pt.y);\n    } else if (mode !== MODE_MOVE && mode !== MODE_EDGE && mode !== MODE_DEL) {\n      // nothing\n    } else {\n      // click on background resets selection\n      resetSelections();\n      redraw();\n    }\n  });\n\n  function svgPoint(ev) {\n    const rect = svg.getBoundingClientRect();\n    // viewBox 0 0 1200 700 mapping to client rect\n    const vw = rect.width, vh = rect.height;\n    const x = (ev.clientX - rect.left) * (1200 / vw);\n    const y = (ev.clientY - rect.top) * (700 / vh);\n    return {x,y};\n  }\n\n  function addNode(x,y) {\n    const n = {id: nodeIdCounter++, x, y};\n    nodes.push(n);\n    redraw();\n  }\n\n  let edgeFirstNode = null;\n  function handleEdgeClick(n) {\n    if (!edgeFirstNode) {\n      edgeFirstNode = n;\n      selectedInfo.textContent = `Edge from ${n.id} → ... (click target)`;\n      redraw({activeNode: n.id});\n    } else if (edgeFirstNode.id === n.id) {\n      // clicked same node - cancel\n      edgeFirstNode = null;\n      selectedInfo.textContent = 'None';\n      redraw();\n    } else {\n      // create edge between edgeFirstNode and n\n      let weight = Number(document.getElementById('default-weight').value) || defaultWeight;\n      const input = prompt('Weight for edge ' + edgeFirstNode.id + ' → ' + n.id + ' (number):', weight);\n      if (input === null) {\n        edgeFirstNode = null; redraw(); return;\n      }\n      weight = Number(input);\n      if (!isFinite(weight)) weight = defaultWeight;\n      // check duplicate\n      if (edges.some(e => e.a===edgeFirstNode.id && e.b===n.id && e.directed===directed)) {\n        if (!confirm('An identical edge exists. Add duplicate anyway?')) {\n          edgeFirstNode = null; redraw(); return;\n        }\n      }\n      const e = {id: edgeIdCounter++, a:edgeFirstNode.id, b:n.id, w: weight, directed: directed};\n      edges.push(e);\n      edgeFirstNode = null;\n      selectedInfo.textContent = 'None';\n      redraw();\n    }\n  }\n\n  // Dragging\n  let dragNode = null;\n  let dragOffset = {x:0,y:0};\n  function startDrag(n, ev) {\n    dragNode = n;\n    const pt = svgPoint(ev);\n    dragOffset.x = n.x - pt.x;\n    dragOffset.y = n.y - pt.y;\n    document.addEventListener('mousemove', onDrag);\n    document.addEventListener('mouseup', endDrag);\n  }\n  function onDrag(ev) {\n    if (!dragNode) return;\n    const pt = svgPoint(ev);\n    dragNode.x = pt.x + dragOffset.x;\n    dragNode.y = pt.y + dragOffset.y;\n    redraw();\n  }\n  function endDrag(ev) {\n    dragNode = null;\n    document.removeEventListener('mousemove', onDrag);\n    document.removeEventListener('mouseup', endDrag);\n  }\n\n  function resetSelections() {\n    edgeFirstNode = null;\n    selectedInfo.textContent = 'None';\n  }\n\n  function updateStats() {\n    nodeCountEl.textContent = nodes.length;\n    edgeCountEl.textContent = edges.length;\n    // build adjacency list\n    const adj = {};\n    nodes.forEach(n => adj[n.id] = []);\n    edges.forEach(e => {\n      adj[e.a].push({to: e.b, w: e.w, edgeId:e.id});\n      if (!e.directed) adj[e.b].push({to: e.a, w: e.w, edgeId:e.id});\n    });\n    let txt = '';\n    for (let id in adj) {\n      txt += id + ': ';\n      txt += adj[id].map(x => `${x.to}(w=${x.w})`).join(', ');\n      txt += '\\n';\n    }\n    adjEl.textContent = txt || '[]';\n  }\n\n  // Algorithms\n  function startDijkstraMode() {\n    if (nodes.length === 0) { alert('No nodes'); return; }\n    alert('Dijkstra: Click source node then target node on canvas.');\n    let src = null;\n    let tgt = null;\n    const handler = (ev)=>{\n      ev.stopPropagation();\n      // find clicked node from mouse position\n      const pt = svgPoint(ev);\n      const clicked = nodes.find(n => Math.hypot(n.x-pt.x,n.y-pt.y) <= R+4);\n      if (!clicked) return;\n      if (!src) {\n        src = clicked.id;\n        redraw({activeNode: clicked.id});\n        selectedInfo.textContent = 'Dijkstra source: ' + src;\n      } else if (!tgt) {\n        tgt = clicked.id;\n        selectedInfo.textContent = 'Dijkstra target: ' + tgt;\n        svg.removeEventListener('click', handler, true);\n        computeDijkstra(src, tgt);\n      }\n    };\n    svg.addEventListener('click', handler, true);\n  }\n\n  function computeDijkstra(srcId, tgtId) {\n    // Build adjacency\n    const adj = {};\n    nodes.forEach(n=>adj[n.id]=[]);\n    edges.forEach(e=>{\n      adj[e.a].push({to:e.b,w:e.w,edgeId:e.id});\n      if (!e.directed) adj[e.b].push({to:e.a,w:e.w,edgeId:e.id});\n    });\n    const dist = {};\n    const prev = {};\n    const prevEdge = {};\n    nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; prevEdge[n.id]=null; });\n    dist[srcId] = 0;\n    const visited = new Set();\n    // simple PQ\n    const pq = new MinPQ();\n    pq.push({id:srcId, d:0});\n    const steps = [];\n    while (!pq.empty()) {\n      const cur = pq.pop();\n      if (visited.has(cur.id)) continue;\n      visited.add(cur.id);\n      steps.push({type:'visit', id:cur.id, dist: dist[cur.id]});\n      if (cur.id === tgtId) break;\n      for (const e of adj[cur.id]) {\n        const nd = dist[cur.id] + e.w;\n        if (nd < dist[e.to]) {\n          dist[e.to] = nd;\n          prev[e.to] = cur.id;\n          prevEdge[e.to] = e.edgeId;\n          pq.push({id:e.to, d:nd});\n          steps.push({type:'relax', from:cur.id, to:e.to, newDist:nd, edgeId:e.edgeId});\n        }\n      }\n    }\n\n    if (dist[tgtId] === Infinity) {\n      alert('No path found from ' + srcId + ' to ' + tgtId);\n      redraw();\n      return;\n    }\n    // reconstruct path\n    const pathNodes = new Set();\n    const pathEdges = new Set();\n    let cur = tgtId;\n    while (cur !== null) {\n      pathNodes.add(cur);\n      if (prevEdge[cur] !== null) pathEdges.add(prevEdge[cur]);\n      cur = prev[cur];\n    }\n    // Optionally animate steps\n    if (animateSteps) {\n      playDijkstraSteps(steps, pathNodes, pathEdges, dist, srcId, tgtId);\n    } else {\n      redraw({pathNodes, pathEdges});\n      selectedInfo.textContent = `Shortest ${srcId}→${tgtId} distance=${dist[tgtId]}`;\n      showDistanceOverlay(dist);\n    }\n  }\n\n  function playDijkstraSteps(steps, pathNodes, pathEdges, dist, srcId, tgtId) {\n    let i = 0;\n    const stepInterval = 400;\n    const interval = setInterval(()=>{\n      if (i >= steps.length) {\n        // final: highlight path\n        clearInterval(interval);\n        redraw({pathNodes, pathEdges});\n        selectedInfo.textContent = `Shortest ${srcId}→${tgtId} distance=${dist[tgtId]}`;\n        showDistanceOverlay(dist);\n        return;\n      }\n      const s = steps[i++];\n      if (s.type === 'visit') {\n        redraw({activeNode: s.id});\n      } else if (s.type === 'relax') {\n        redraw({activeEdge: s.edgeId, activeNode: s.to});\n      } else {\n        redraw();\n      }\n    }, stepInterval);\n  }\n\n  function showDistanceOverlay(dist) {\n    // draw distances next to nodes temporarily\n    // We'll overlay small number tags on nodes\n    // For simplicity, redraw with an overlay group with distances\n    const overlay = createSvg('g', { id: 'overlay' });\n    nodes.forEach(n => {\n      const x = n.x + 22;\n      const y = n.y - 12;\n      const rect = createSvg('rect', { x:x-6, y:y-12, rx:6, ry:6, width: 44, height: 20, fill: 'rgba(0,0,0,0.45)', stroke: 'rgba(255,255,255,0.03)' });\n      const text = createSvg('text', { x:x+16, y:y+4, 'text-anchor':'middle', 'font-size':12, fill:'#e6f0ff' });\n      const d = dist[n.id] === Infinity ? '∞' : dist[n.id];\n      text.textContent = d;\n      overlay.appendChild(rect);\n      overlay.appendChild(text);\n    });\n    svg.appendChild(overlay);\n    // remove after 5 sec\n    setTimeout(()=>{ const el = document.getElementById('overlay'); if (el) el.remove(); }, 5000);\n  }\n\n  // Prim MST\n  function runPrimMST() {\n    if (nodes.length === 0) { alert('No nodes'); return; }\n    // For Prim we ignore directed edges and treat graph as undirected\n    const adj = {};\n    nodes.forEach(n=>adj[n.id]=[]);\n    edges.forEach(e=>{\n      adj[e.a].push({to:e.b,w:e.w,edgeId:e.id});\n      adj[e.b].push({to:e.a,w:e.w,edgeId:e.id});\n    });\n    const startId = nodes[0].id;\n    const inTree = new Set([startId]);\n    const edgeSet = new Set();\n    const pq = new MinPQ();\n    for (const e of adj[startId]) pq.push({edgeId: e.edgeId, from: startId, to: e.to, w: e.w});\n    const steps = [];\n    while (!pq.empty()) {\n      const cur = pq.pop();\n      if (inTree.has(cur.to)) continue;\n      inTree.add(cur.to);\n      edgeSet.add(cur.edgeId);\n      steps.push({type:'addEdge', edgeId: cur.edgeId, from:cur.from, to:cur.to, w:cur.w});\n      for (const e of adj[cur.to]) {\n        if (!inTree.has(e.to)) pq.push({edgeId:e.edgeId, from:cur.to, to:e.to, w:e.w});\n      }\n    }\n    if (inTree.size !== nodes.length) {\n      alert('Graph is not connected — MST covers its component.');\n    }\n    // animate\n    if (animateSteps) {\n      playPrimSteps(steps, edgeSet);\n    } else {\n      redraw({pathEdges: edgeSet});\n      selectedInfo.textContent = `Prim MST edges: ${Array.from(edgeSet).join(', ')}`;\n    }\n  }\n\n  function playPrimSteps(steps, edgeSet) {\n    let i = 0;\n    const interval = setInterval(()=>{\n      if (i >= steps.length) {\n        clearInterval(interval);\n        redraw({pathEdges: edgeSet});\n        selectedInfo.textContent = 'Prim MST done';\n        return;\n      }\n      const s = steps[i++];\n      redraw({activeEdge: s.edgeId});\n    }, 450);\n  }\n\n  // Utilities: MinPQ\n  function MinPQ() {\n    this.arr = [];\n  }\n  MinPQ.prototype.push = function(obj) {\n    this.arr.push(obj);\n  };\n  MinPQ.prototype.pop = function() {\n    if (this.arr.length === 0) return null;\n    let idx = 0;\n    for (let i=1;i<this.arr.length;i++) {\n      if ((this.arr[i].d || this.arr[i].w) < (this.arr[idx].d || this.arr[idx].w)) idx = i;\n    }\n    return this.arr.splice(idx,1)[0];\n  };\n  MinPQ.prototype.empty = function() { return this.arr.length === 0; };\n\n  // initial render\n  redraw();\n\n  // small helper: clicking edges needs to know event propagation order; we attached click handlers in drawEdge\n\n  // Prevent text selection while dragging\n  document.addEventListener('selectstart', (e)=>{ if (dragNode) e.preventDefault(); });\n\n  // Expose for testing via console (optional)\n  window._graphDemo = { nodes, edges, redraw };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}