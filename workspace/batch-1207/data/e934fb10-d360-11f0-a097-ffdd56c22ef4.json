{
  "id": "e934fb10-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:28.843Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Linear Regression Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:#f6f8fa; color:#111; }\n    .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n    .left { flex:1 1 0; display:flex; flex-direction:column; gap:8px; }\n    .canvas-wrap { flex:1; background:white; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; display:flex; flex-direction:column; }\n    canvas { width:100%; height:100%; background:linear-gradient(180deg,#ffffff,#fbfdff); border-radius:6px; cursor:crosshair; display:block; }\n    .controls { width:360px; flex:0 0 360px; display:flex; flex-direction:column; gap:8px; }\n    .panel { background:white; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; }\n    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }\n    label { font-size:13px; color:#333; }\n    input[type=range] { width:160px; }\n    button { background:#2563eb; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }\n    button.ghost { background:transparent; border:1px solid #cbd5e1; color:#111; }\n    small.gray { color:#666; display:block; margin-top:6px; }\n    .stats { font-family:monospace; white-space:pre; font-size:13px; color:#111; }\n    .hint { font-size:13px; color:#444; }\n    .muted { color:#666; font-size:13px; }\n    .checkbox { display:flex; gap:6px; align-items:center; }\n    .point-list { max-height:160px; overflow:auto; border-top:1px dashed #eee; padding-top:8px; }\n    .point-row { display:flex; justify-content:space-between; gap:8px; padding:4px 0; border-bottom:1px dashed #fafafa; }\n    .small-btn { background:#eef2ff; color:#1e3a8a; border:none; padding:6px 8px; border-radius:6px; cursor:pointer; }\n    .center { display:flex; gap:8px; align-items:center; }\n    .footer { font-size:12px; color:#666; text-align:center; margin-top:8px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <div class=\"canvas-wrap panel\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n          <div>\n            <strong>Linear Regression — Interactive</strong>\n            <div class=\"muted\" style=\"margin-top:4px;\">Click to add a point. Drag to move. Double-click to remove a point.</div>\n          </div>\n          <div class=\"muted\">Points: <span id=\"count\">0</span></div>\n        </div>\n        <canvas id=\"chart\"></canvas>\n        <div style=\"display:flex;gap:8px;margin-top:8px;align-items:center;justify-content:space-between;\">\n          <div class=\"muted\">X,Y scaled 0–100</div>\n          <div class=\"muted\">Click empty area to add point</div>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n        <div>\n          <div class=\"muted\">Fit type</div>\n          <div style=\"display:flex;gap:8px;margin-top:6px;\">\n            <button id=\"btn-ols\" class=\"small-btn\">Analytic (OLS)</button>\n            <button id=\"btn-gd\" class=\"small-btn\">Gradient Descent</button>\n            <button id=\"btn-reset\" class=\"ghost\">Clear</button>\n          </div>\n        </div>\n        <div style=\"text-align:right;\">\n          <div class=\"muted\">Residuals</div>\n          <div style=\"margin-top:6px;\">\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"show-res\" checked> Show</label>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;flex-direction:row;gap:12px;\">\n        <div style=\"flex:1;\">\n          <label>Generate random points</label>\n          <div style=\"display:flex;gap:8px;margin-top:6px;\">\n            <input id=\"randN\" type=\"number\" min=\"1\" max=\"200\" value=\"10\" style=\"width:72px;padding:6px;border:1px solid #ddd;border-radius:6px;\">\n            <button id=\"btn-gen\" class=\"small-btn\">Generate</button>\n            <button id=\"btn-gen-noise\" class=\"ghost\">From underlying line</button>\n          </div>\n          <small class=\"gray\">You can generate random spread or points sampled from a hidden line + noise.</small>\n        </div>\n        <div style=\"width:160px;\">\n          <label>Noise (σ)</label>\n          <input id=\"noise\" type=\"range\" min=\"0\" max=\"30\" value=\"8\">\n          <div class=\"muted\" style=\"text-align:right;\" id=\"noiseVal\">8</div>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;gap:12px;align-items:center;\">\n        <div style=\"flex:1;\">\n          <label>Gradient Descent settings</label>\n          <div style=\"display:flex;gap:8px;margin-top:8px;align-items:center;\">\n            <div>\n              <div class=\"muted\">Learning rate</div>\n              <input id=\"lr\" type=\"range\" min=\"0.0005\" max=\"1\" step=\"0.0005\" value=\"0.01\" style=\"width:180px;\">\n              <div class=\"muted\" id=\"lrVal\">0.0100</div>\n            </div>\n            <div>\n              <div class=\"muted\">Iterations</div>\n              <input id=\"iters\" type=\"number\" min=\"1\" max=\"100000\" value=\"200\" style=\"width:90px;padding:6px;border:1px solid #ddd;border-radius:6px;\">\n            </div>\n          </div>\n        </div>\n        <div style=\"display:flex;flex-direction:column;gap:6px;\">\n          <button id=\"run-gd\" style=\"background:#10b981;color:white;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;\">Run GD</button>\n          <button id=\"stop-gd\" class=\"ghost\">Stop</button>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;gap:12px;align-items:flex-start;\">\n        <div style=\"flex:1;\">\n          <div style=\"display:flex;justify-content:space-between;\">\n            <label>Statistics & model</label>\n            <div class=\"muted\">Updated live</div>\n          </div>\n          <pre class=\"stats\" id=\"stats\">No data yet.</pre>\n        </div>\n        <div style=\"width:160px;\">\n          <label>Display</label>\n          <div style=\"display:flex;flex-direction:column;gap:6px;margin-top:8px;\">\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"show-ols\" checked> Show OLS line</label>\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"show-gd\" checked> Show GD line</label>\n            <label class=\"checkbox\"><input type=\"checkbox\" id=\"show-points\" checked> Show points</label>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n        <div class=\"muted\">Tips: Drag points to see the line update. Use Gradient Descent to watch optimization converge.</div>\n        <div class=\"footer\">Made for learning • No libraries • OLS uses normal equations</div>\n      </div>\n    </div>\n\n    <div class=\"controls\">\n      <div class=\"panel\">\n        <strong>Point list</strong>\n        <div class=\"point-list\" id=\"pointList\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Actions</strong>\n        <div style=\"display:flex;flex-direction:column;gap:8px;margin-top:8px;\">\n          <button id=\"btn-add-slope\" class=\"ghost\">Add points on a line</button>\n          <button id=\"btn-random\" class=\"small-btn\">Add one random point</button>\n          <button id=\"btn-center\" class=\"ghost\">Center points</button>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>About</strong>\n        <div style=\"margin-top:8px;\" class=\"muted\">\n          Ordinary Least Squares (OLS) analytic solution:\n          slope m = cov(x,y) / var(x)\n          intercept b = mean(y) - m * mean(x)\n          R² = 1 - SSE / SST\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\nInteractive Linear Regression Demo\n- Click to add points\n- Drag to move points\n- Double-click to remove\n- Analytic OLS fit computed from data\n- Optional Gradient Descent optimizer to fit m and b\n- Residuals and R^2 displayed\n*/\n\n(() => {\n  // Utility & state\n  const canvas = document.getElementById('chart');\n  const ctx = canvas.getContext('2d');\n  let width = 800, height = 480;\n  function resize() {\n    // size canvas to container\n    const rect = canvas.getBoundingClientRect();\n    width = Math.floor(rect.width);\n    height = Math.floor(rect.height);\n    // set actual canvas pixel size for crispness\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    draw();\n  }\n  new ResizeObserver(resize).observe(canvas.parentElement);\n\n  // Internal points: x,y in range [0,100]\n  let points = [];\n  const pointRadius = 6;\n  let dragging = null;\n  document.getElementById('count').textContent = points.length;\n\n  // GD state\n  let gdRunning = false;\n  let gdParams = { m:0, b:0 };\n  let gdStep = 0;\n\n  // Hidden \"true\" line used when generating sample-from-line\n  let trueLine = { m: 0.6, b: 30 }; // in 0-100 units\n\n  // DOM elements\n  const statsEl = document.getElementById('stats');\n  const pointListEl = document.getElementById('pointList');\n  const noiseEl = document.getElementById('noise');\n  const noiseValEl = document.getElementById('noiseVal');\n  const lrEl = document.getElementById('lr');\n  const lrValEl = document.getElementById('lrVal');\n  const itersEl = document.getElementById('iters');\n  const showResEl = document.getElementById('show-res');\n  const showOlsEl = document.getElementById('show-ols');\n  const showGdEl = document.getElementById('show-gd');\n  const showPointsEl = document.getElementById('show-points');\n\n  // initial display\n  noiseValEl.textContent = noiseEl.value;\n  lrValEl.textContent = Number(lrEl.value).toFixed(4);\n\n  // Mapping between data coords (0..100) and canvas pixels\n  const pad = 32;\n  function dataToScreen(pt) {\n    const x = pad + (pt.x / 100) * (width - pad*2);\n    const y = pad + ((100 - pt.y) / 100) * (height - pad*2);\n    return { x, y };\n  }\n  function screenToData(px, py) {\n    const x = Math.max(0, Math.min(100, ((px - pad) / (width - pad*2)) * 100));\n    const y = Math.max(0, Math.min(100, (1 - ((py - pad) / (height - pad*2))) * 100));\n    return { x, y };\n  }\n\n  // Drawing functions\n  function clearCanvas() {\n    ctx.clearRect(0,0,width,height);\n  }\n  function drawGrid() {\n    ctx.save();\n    ctx.strokeStyle = '#f1f5f9';\n    ctx.lineWidth = 1;\n    // vertical lines every 10\n    for (let i=0;i<=10;i++) {\n      const x = pad + i*(width-2*pad)/10;\n      ctx.beginPath();\n      ctx.moveTo(x, pad);\n      ctx.lineTo(x, height-pad);\n      ctx.stroke();\n    }\n    for (let j=0;j<=10;j++) {\n      const y = pad + j*(height-2*pad)/10;\n      ctx.beginPath();\n      ctx.moveTo(pad, y);\n      ctx.lineTo(width-pad, y);\n      ctx.stroke();\n    }\n    // axes border\n    ctx.strokeStyle = '#e6eef8';\n    ctx.lineWidth = 1.5;\n    ctx.strokeRect(pad, pad, width-2*pad, height-2*pad);\n    // labels\n    ctx.fillStyle = '#556';\n    ctx.font = '12px system-ui,Arial';\n    ctx.textAlign = 'center';\n    for (let i=0;i<=10;i++) {\n      const x = pad + i*(width-2*pad)/10;\n      ctx.fillText((i*10).toString(), x, height - 6);\n    }\n    ctx.textAlign = 'right';\n    for (let j=0;j<=10;j++) {\n      const y = pad + j*(height-2*pad)/10;\n      ctx.fillText((100 - j*10).toString(), pad-6, y+4);\n    }\n    ctx.restore();\n  }\n\n  function drawPoints() {\n    if (!showPointsEl.checked) return;\n    for (let i=0;i<points.length;i++) {\n      const p = points[i];\n      const s = dataToScreen(p);\n      ctx.beginPath();\n      ctx.fillStyle = (p === dragging) ? '#ffb86b' : '#1f77b4';\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 2;\n      ctx.arc(s.x, s.y, pointRadius, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n      // index label\n      ctx.fillStyle = '#064e3b';\n      ctx.font = '11px monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(i), s.x, s.y+4);\n    }\n  }\n\n  function drawResiduals(m,b) {\n    if (!showResEl.checked) return;\n    ctx.save();\n    ctx.lineWidth = 1.25;\n    for (let p of points) {\n      const s = dataToScreen(p);\n      // predicted y\n      const yhat = m*p.x + b;\n      const s2 = dataToScreen({ x: p.x, y: yhat });\n      ctx.beginPath();\n      ctx.strokeStyle = '#f97316';\n      ctx.moveTo(s.x, s.y);\n      ctx.lineTo(s2.x, s2.y);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawLine(m,b,opts={color:'#ef476f',wide:2,dashed:false}) {\n    // compute intersection with x=0 and x=100\n    const y0 = m*0 + b;\n    const y1 = m*100 + b;\n    // clip to 0..100 for drawing range\n    let xA=0, yA=y0, xB=100, yB=y1;\n    // if both points out of box, try clip by y bounds too\n    const pts = [];\n    function pushIfIn(x,y) {\n      if (y>=-1000 && y<=1100 && x>=-1000 && x<=1100) pts.push({x,y});\n    }\n    pushIfIn(xA,yA); pushIfIn(xB,yB);\n    // If y out of bounds, clip at y=0..100 using param t\n    if (yA < 0 || yA > 100 || yB < 0 || yB > 100) {\n      pts.length = 0;\n      // check intersect with edges x=0, x=100, y=0, y=100\n      const candidates = [\n        {x:0, y:m*0+b},\n        {x:100, y:m*100+b},\n      ];\n      // intersection with y=0: solve 0 = m x + b -> x = -b/m if m != 0\n      if (Math.abs(m) > 1e-8) candidates.push({x: (-b)/m, y:0});\n      if (Math.abs(m) > 1e-8) candidates.push({x: (100 - b)/m, y:100});\n      for (let c of candidates) {\n        if (c.x >= 0-1e-6 && c.x <= 100+1e-6 && c.y >= 0-1e-6 && c.y <= 100+1e-6) pts.push(c);\n      }\n    }\n    if (pts.length < 2) return; // nothing to draw\n    // take two extreme by x\n    pts.sort((a,b2)=>a.x-b2.x);\n    const a = pts[0], b2 = pts[pts.length-1];\n    const sa = dataToScreen(a), sb = dataToScreen(b2);\n\n    ctx.save();\n    ctx.lineWidth = opts.wide || 2;\n    ctx.strokeStyle = opts.color || '#000';\n    if (opts.dashed) ctx.setLineDash([6,6]);\n    ctx.beginPath();\n    ctx.moveTo(sa.x, sa.y);\n    ctx.lineTo(sb.x, sb.y);\n    ctx.stroke();\n    ctx.setLineDash([]);\n    ctx.restore();\n  }\n\n  function drawLegend(stats) {\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.strokeStyle = '#e6eef8';\n    ctx.lineWidth = 1;\n    const w = 260, h = 86;\n    const x = width - pad - w, y = pad + 6;\n    roundRect(ctx, x, y, w, h, 8, true, true);\n    ctx.fillStyle = '#0f172a';\n    ctx.font = '12px system-ui,Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Model summary', x+12, y+20);\n    ctx.font = '13px monospace';\n    if (stats) {\n      ctx.fillStyle = '#111827';\n      ctx.fillText(`OLS: m=${stats.ols.m.toFixed(4)}, b=${stats.ols.b.toFixed(3)}`, x+12, y+40);\n      ctx.fillText(`GD:  m=${stats.gd.m.toFixed(4)}, b=${stats.gd.b.toFixed(3)}`, x+12, y+58);\n      ctx.fillStyle = '#6b7280';\n      ctx.font = '12px monospace';\n      ctx.fillText(`R²=${stats.r2.toFixed(4)}  RMSE=${stats.rmse.toFixed(3)}`, x+12, y+76);\n    } else {\n      ctx.fillText('No data', x+12, y+40);\n    }\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y,   x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x,   y+h, r);\n    ctx.arcTo(x,   y+h, x,   y,   r);\n    ctx.arcTo(x,   y,   x+w, y,   r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Compute analytic OLS\n  function computeOLS(pts) {\n    const n = pts.length;\n    if (n === 0) return null;\n    if (n === 1) return { m:0, b: pts[0].y };\n    let sx=0, sy=0;\n    for (let p of pts) { sx += p.x; sy += p.y; }\n    const mx = sx/n, my = sy/n;\n    let num = 0, den = 0;\n    for (let p of pts) {\n      num += (p.x - mx)*(p.y - my);\n      den += (p.x - mx)*(p.x - mx);\n    }\n    if (Math.abs(den) < 1e-12) return { m:0, b:my }; // vertical variance zero; degenerate\n    const m = num/den;\n    const b = my - m*mx;\n    return { m, b };\n  }\n\n  function computeStats(pts, model) {\n    if (!model || pts.length === 0) return null;\n    const n = pts.length;\n    let sse = 0, sst = 0;\n    let sy=0;\n    for (let p of pts) sy += p.y;\n    const my = sy/n;\n    for (let p of pts) {\n      const yhat = model.m*p.x + model.b;\n      sse += (p.y - yhat)*(p.y - yhat);\n      sst += (p.y - my)*(p.y - my);\n    }\n    const r2 = (sst === 0) ? 1 : Math.max(0, 1 - sse/sst);\n    const rmse = Math.sqrt(sse/n);\n    return { sse, sst, r2, rmse };\n  }\n\n  // Update UI stats and left panel\n  function updateStats(olsModel, gdModel) {\n    const ols = olsModel || {m:0,b:0};\n    const gd = gdModel || {m:0,b:0};\n    const bestModel = olsModel || gdModel || {m:0,b:0};\n    const stats = computeStats(points, bestModel) || { sse:0, sst:0, r2:0, rmse:0 };\n    const text = [];\n    text.push(`Points: ${points.length}`);\n    if (points.length >= 2) {\n      text.push('');\n      text.push(`OLS: slope m = ${ols.m.toFixed(6)}`);\n      text.push(`     intercept b = ${ols.b.toFixed(6)}`);\n      text.push('');\n      text.push(`GD:  slope m = ${gd.m.toFixed(6)}`);\n      text.push(`     intercept b = ${gd.b.toFixed(6)}`);\n      text.push('');\n      text.push(`R² (OLS) = ${computeStats(points, ols).r2.toFixed(6)}`);\n      text.push(`RMSE (OLS) = ${computeStats(points, ols).rmse.toFixed(6)}`);\n    } else if (points.length === 1) {\n      text.push('');\n      text.push('Only one point — infinite fits; intercept shown as y of the point');\n    } else {\n      text.push('');\n      text.push('Add points to compute regression.');\n    }\n    statsEl.textContent = text.join('\\n');\n    draw(); // ensure legend updated\n  }\n\n  function updatePointList() {\n    pointListEl.innerHTML = '';\n    points.forEach((p,i) => {\n      const row = document.createElement('div');\n      row.className = 'point-row';\n      const lbl = document.createElement('div');\n      lbl.textContent = `${i}: (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`;\n      const actions = document.createElement('div');\n      actions.style.display = 'flex';\n      actions.style.gap = '6px';\n      const btnDel = document.createElement('button');\n      btnDel.textContent = 'Delete';\n      btnDel.className = 'small-btn';\n      btnDel.onclick = () => { points.splice(i,1); updateAfterChange(); };\n      const btnCenter = document.createElement('button');\n      btnCenter.textContent = 'Center';\n      btnCenter.className = 'ghost';\n      btnCenter.onclick = () => { p.x = 50; p.y = 50; updateAfterChange(); };\n      actions.appendChild(btnCenter);\n      actions.appendChild(btnDel);\n      row.appendChild(lbl);\n      row.appendChild(actions);\n      pointListEl.appendChild(row);\n    });\n  }\n\n  // Main draw\n  function draw() {\n    clearCanvas();\n    drawGrid();\n\n    const ols = computeOLS(points);\n    const gd = { m: gdParams.m, b: gdParams.b };\n    // draw lines behind points\n    if (showOlsEl.checked && ols) drawLine(ols.m, ols.b, { color:'#ef476f', wide:2, dashed:false });\n    if (showGdEl.checked && points.length >= 1) drawLine(gd.m, gd.b, { color:'#06b6d4', wide:2, dashed:true });\n\n    // residuals (for OLS by default)\n    if (showResEl.checked && ols) drawResiduals(ols.m, ols.b);\n\n    drawPoints();\n\n    // draw small legend with numeric stats\n    const stats = {\n      ols: ols || {m:0,b:0},\n      gd: gd,\n      r2: (ols? computeStats(points, ols).r2 : 0),\n      rmse: (ols? computeStats(points, ols).rmse : 0)\n    };\n    drawLegend(stats);\n  }\n\n  // Interaction\n  function findPointNear(px,py) {\n    for (let i=points.length-1;i>=0;i--) {\n      const p = points[i];\n      const s = dataToScreen(p);\n      const dx = s.x - px, dy = s.y - py;\n      if (Math.sqrt(dx*dx + dy*dy) <= pointRadius+6) return {p, i};\n    }\n    return null;\n  }\n\n  let lastClickTime = 0;\n  canvas.addEventListener('pointerdown', (ev) => {\n    ev.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const px = ev.clientX - rect.left;\n    const py = ev.clientY - rect.top;\n    const hit = findPointNear(px,py);\n    if (hit) {\n      // Check double-click for deletion\n      const now = Date.now();\n      if (now - lastClickTime < 330) {\n        // double-click: delete\n        points.splice(hit.i, 1);\n        updateAfterChange();\n        lastClickTime = 0;\n        return;\n      }\n      lastClickTime = now;\n      // start dragging\n      dragging = hit.p;\n      // highlight\n      draw();\n      canvas.setPointerCapture(ev.pointerId);\n    } else {\n      // add new point\n      const d = screenToData(px,py);\n      points.push({ x: d.x, y: d.y });\n      updateAfterChange();\n    }\n  });\n\n  canvas.addEventListener('pointermove', (ev) => {\n    if (!dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const px = ev.clientX - rect.left;\n    const py = ev.clientY - rect.top;\n    const d = screenToData(px,py);\n    dragging.x = d.x;\n    dragging.y = d.y;\n    updateAfterChange(false);\n  });\n\n  canvas.addEventListener('pointerup', (ev) => {\n    if (dragging) {\n      dragging = null;\n      updateAfterChange();\n    }\n    try { canvas.releasePointerCapture(ev.pointerId); } catch(e){}\n  });\n\n  // Helpers for adding points\n  function addRandomPoint() {\n    const x = Math.random()*100;\n    const y = Math.random()*100;\n    points.push({x,y});\n    updateAfterChange();\n  }\n\n  function generateRandom(n, noise=8) {\n    for (let i=0;i<n;i++) addRandomPoint();\n    // optionally jitter noise small? Already random\n  }\n\n  function generateFromLine(n, noise=8) {\n    // random slope and intercept chosen if none\n    trueLine.m = (Math.random()*2 - 1) * 1.2; // -1.2 .. 1.2\n    trueLine.b = 20 + Math.random()*60; // 20 .. 80\n    points = [];\n    for (let i=0;i<n;i++) {\n      const x = Math.random()*100;\n      const y = trueLine.m*x + trueLine.b + (randNorm()*noise);\n      points.push({ x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) });\n    }\n    updateAfterChange();\n  }\n\n  // Gaussian approx random\n  function randNorm() {\n    // Box-Muller\n    let u=0,v=0;\n    while(u===0) u = Math.random();\n    while(v===0) v = Math.random();\n    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2*Math.PI*v);\n  }\n\n  // Gradient Descent routine\n  function runGD(iterations, lr, onStep) {\n    if (points.length === 0) return;\n    // Initialize parameters to current OLS or zeros\n    const ols = computeOLS(points);\n    gdParams.m = ols ? ols.m : 0;\n    gdParams.b = ols ? ols.b : 0;\n    gdStep = 0;\n    gdRunning = true;\n    return new Promise((resolve) => {\n      function stepBatch() {\n        if (!gdRunning) { resolve(false); return; }\n        const batch = Math.min(200, iterations - gdStep);\n        for (let k=0;k<batch;k++) {\n          const grads = computeGradient(points, gdParams);\n          gdParams.m -= lr * grads.dm;\n          gdParams.b -= lr * grads.db;\n          gdStep++;\n          if (gdStep >= iterations) break;\n        }\n        onStep && onStep();\n        if (gdStep < iterations && gdRunning) {\n          // schedule next\n          setTimeout(stepBatch, 12);\n        } else {\n          gdRunning = false;\n          resolve(true);\n        }\n      }\n      stepBatch();\n    });\n  }\n\n  function stopGD() {\n    gdRunning = false;\n  }\n\n  function computeGradient(pts, params) {\n    // dM = -2/N * sum x*(y - (m x + b))\n    // dB = -2/N * sum (y - (m x + b))\n    const N = pts.length;\n    let dm = 0, db = 0;\n    for (let p of pts) {\n      const pred = params.m*p.x + params.b;\n      const err = p.y - pred;\n      dm += -2 * p.x * err;\n      db += -2 * err;\n    }\n    dm /= N; db /= N;\n    return { dm, db };\n  }\n\n  // Update after points change\n  function updateAfterChange(alsoUpdateList=true) {\n    document.getElementById('count').textContent = points.length;\n    if (alsoUpdateList) updatePointList();\n    // recompute OLS and update GD initial guess maybe\n    const ols = computeOLS(points);\n    if (!gdRunning) {\n      // set gdParams to ols so it's visible\n      if (ols) { gdParams.m = ols.m; gdParams.b = ols.b; }\n    }\n    updateStats(ols, gdParams);\n    draw();\n  }\n\n  // Hook buttons/inputs\n  document.getElementById('btn-ols').addEventListener('click', () => {\n    // quick compute and set GD params to OLS\n    const ols = computeOLS(points);\n    if (!ols) { alert('Need at least one point'); return; }\n    gdParams.m = ols.m; gdParams.b = ols.b;\n    updateAfterChange();\n  });\n\n  document.getElementById('btn-gd').addEventListener('click', () => {\n    // show GD line (no immediate effect)\n    updateAfterChange();\n  });\n\n  document.getElementById('btn-reset').addEventListener('click', () => {\n    points = [];\n    updateAfterChange();\n  });\n\n  document.getElementById('btn-gen').addEventListener('click', () => {\n    const n = Math.max(1, Math.min(500, Number(document.getElementById('randN').value) || 10));\n    for (let i=0;i<n;i++) generateRandom(1);\n  });\n\n  document.getElementById('btn-gen-noise').addEventListener('click', () => {\n    const n = Math.max(1, Math.min(500, Number(document.getElementById('randN').value) || 10));\n    const noise = Number(noiseEl.value) || 8;\n    generateFromLine(n, noise);\n  });\n\n  document.getElementById('btn-random').addEventListener('click', addRandomPoint);\n\n  document.getElementById('btn-add-slope').addEventListener('click', () => {\n    // Add a few points lying close to a random line\n    const m = (Math.random()*2 - 1) * 1.2;\n    const b = 10 + Math.random()*80;\n    for (let i=0;i<8;i++) {\n      const x = 5 + Math.random()*90;\n      const y = m*x + b + randNorm()*6;\n      points.push({ x: Math.max(0,Math.min(100,x)), y: Math.max(0,Math.min(100,y)) });\n    }\n    updateAfterChange();\n  });\n\n  document.getElementById('btn-center').addEventListener('click', () => {\n    for (let p of points) { p.x = Math.max(0, Math.min(100, p.x - 50 + 50)); p.y = Math.max(0, Math.min(100, p.y - 50 + 50)); }\n    updateAfterChange();\n  });\n\n  document.getElementById('noise').addEventListener('input', (e) => {\n    noiseValEl.textContent = e.target.value;\n  });\n\n  lrEl.addEventListener('input', (e) => {\n    lrValEl.textContent = Number(e.target.value).toFixed(4);\n  });\n\n  document.getElementById('run-gd').addEventListener('click', async () => {\n    if (points.length === 0) { alert('Add points first'); return; }\n    const iters = Math.max(1, Math.min(1000000, Number(itersEl.value) || 200));\n    const lr = Number(lrEl.value);\n    document.getElementById('run-gd').disabled = true;\n    document.getElementById('stop-gd').disabled = false;\n    await runGD(iters, lr, () => {\n      updateAfterChange(false);\n    });\n    document.getElementById('run-gd').disabled = false;\n    document.getElementById('stop-gd').disabled = true;\n    updateAfterChange();\n  });\n\n  document.getElementById('stop-gd').addEventListener('click', () => {\n    stopGD();\n    document.getElementById('run-gd').disabled = false;\n    document.getElementById('stop-gd').disabled = true;\n  });\n\n  showResEl.addEventListener('change', draw);\n  showOlsEl.addEventListener('change', draw);\n  showGdEl.addEventListener('change', draw);\n  showPointsEl.addEventListener('change', draw);\n\n  // Keyboard: press \"g\" to generate, \"c\" to clear\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'g') { generateRandom(10); }\n    if (e.key === 'c') { points = []; updateAfterChange(); }\n  });\n\n  // initial rendering\n  updateAfterChange();\n\n  // small animation to show GD line moving if running\n  function animate() {\n    if (gdRunning) {\n      // lightly nudge draw\n      updateAfterChange(false);\n    }\n    requestAnimationFrame(animate);\n  }\n  animate();\n\n  // Ensure canvas resizes initially\n  setTimeout(resize, 50);\n\n  // Expose some functions to console for exploration\n  window.lr = () => lrEl.value;\n  window.pointsData = points;\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}