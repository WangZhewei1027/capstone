{
  "id": "f1807d21-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:13.184Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Red-Black Tree Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background: #f5f5f5;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            align-items: center;\n        }\n        input, button {\n            padding: 8px 12px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        button {\n            background: #007cba;\n            color: white;\n            cursor: pointer;\n            border: none;\n        }\n        button:hover {\n            background: #005a87;\n        }\n        button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n        }\n        .tree-container {\n            display: flex;\n            justify-content: center;\n            min-height: 400px;\n            border: 1px solid #eee;\n            padding: 20px;\n            overflow: auto;\n        }\n        .node {\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n            margin: 20px;\n            position: relative;\n        }\n        .red {\n            background: #dc3545;\n        }\n        .black {\n            background: #212529;\n        }\n        .line {\n            position: absolute;\n            background: #333;\n            transform-origin: top left;\n        }\n        .operations {\n            margin-top: 20px;\n        }\n        .log {\n            margin-top: 20px;\n            padding: 10px;\n            background: #f8f9fa;\n            border-radius: 4px;\n            max-height: 150px;\n            overflow-y: auto;\n            font-family: monospace;\n        }\n        .node-wrapper {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Red-Black Tree Visualization</h1>\n        \n        <div class=\"controls\">\n            <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter value\" min=\"0\">\n            <button onclick=\"insertNode()\">Insert</button>\n            <button onclick=\"deleteNode()\" id=\"deleteBtn\" disabled>Delete</button>\n            <button onclick=\"searchNode()\">Search</button>\n            <button onclick=\"clearTree()\">Clear Tree</button>\n            <button onclick=\"generateRandomTree()\">Generate Random Tree</button>\n            <span>Operations: <span id=\"opCount\">0</span></span>\n        </div>\n\n        <div class=\"tree-container\" id=\"treeContainer\">\n            <!-- Tree will be rendered here -->\n        </div>\n\n        <div class=\"operations\">\n            <h3>Operations Log</h3>\n            <div class=\"log\" id=\"log\"></div>\n        </div>\n    </div>\n\n    <script>\n        class RBNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n                this.parent = null;\n                this.color = 'red'; // New nodes are always red\n                this.isNull = false; // For leaf nodes\n            }\n        }\n\n        class RedBlackTree {\n            constructor() {\n                this.NIL = new RBNode(null);\n                this.NIL.color = 'black';\n                this.NIL.isNull = true;\n                this.root = this.NIL;\n                this.operationCount = 0;\n            }\n\n            log(message) {\n                const log = document.getElementById('log');\n                log.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}<br>`;\n                log.scrollTop = log.scrollHeight;\n                document.getElementById('opCount').textContent = ++this.operationCount;\n            }\n\n            leftRotate(x) {\n                this.log(`Left rotate at node ${x.value}`);\n                const y = x.right;\n                x.right = y.left;\n                \n                if (!y.left.isNull) {\n                    y.left.parent = x;\n                }\n                \n                y.parent = x.parent;\n                \n                if (x.parent.isNull) {\n                    this.root = y;\n                } else if (x === x.parent.left) {\n                    x.parent.left = y;\n                } else {\n                    x.parent.right = y;\n                }\n                \n                y.left = x;\n                x.parent = y;\n            }\n\n            rightRotate(y) {\n                this.log(`Right rotate at node ${y.value}`);\n                const x = y.left;\n                y.left = x.right;\n                \n                if (!x.right.isNull) {\n                    x.right.parent = y;\n                }\n                \n                x.parent = y.parent;\n                \n                if (y.parent.isNull) {\n                    this.root = x;\n                } else if (y === y.parent.right) {\n                    y.parent.right = x;\n                } else {\n                    y.parent.left = x;\n                }\n                \n                x.right = y;\n                y.parent = x;\n            }\n\n            insertFixup(z) {\n                while (z.parent.color === 'red') {\n                    if (z.parent === z.parent.parent.left) {\n                        const y = z.parent.parent.right;\n                        \n                        if (y.color === 'red') {\n                            z.parent.color = 'black';\n                            y.color = 'black';\n                            z.parent.parent.color = 'red';\n                            z = z.parent.parent;\n                            this.log(`Case 1: Recoloring nodes around ${z.value}`);\n                        } else {\n                            if (z === z.parent.right) {\n                                z = z.parent;\n                                this.leftRotate(z);\n                            }\n                            z.parent.color = 'black';\n                            z.parent.parent.color = 'red';\n                            this.rightRotate(z.parent.parent);\n                            this.log(`Case 2/3: Restructuring around ${z.value}`);\n                        }\n                    } else {\n                        const y = z.parent.parent.left;\n                        \n                        if (y.color === 'red') {\n                            z.parent.color = 'black';\n                            y.color = 'black';\n                            z.parent.parent.color = 'red';\n                            z = z.parent.parent;\n                            this.log(`Case 1 (mirror): Recoloring nodes around ${z.value}`);\n                        } else {\n                            if (z === z.parent.left) {\n                                z = z.parent;\n                                this.rightRotate(z);\n                            }\n                            z.parent.color = 'black';\n                            z.parent.parent.color = 'red';\n                            this.leftRotate(z.parent.parent);\n                            this.log(`Case 2/3 (mirror): Restructuring around ${z.value}`);\n                        }\n                    }\n                }\n                this.root.color = 'black';\n            }\n\n            insert(value) {\n                this.log(`Inserting value: ${value}`);\n                const z = new RBNode(value);\n                z.left = this.NIL;\n                z.right = this.NIL;\n                \n                let y = this.NIL;\n                let x = this.root;\n                \n                while (!x.isNull) {\n                    y = x;\n                    if (z.value < x.value) {\n                        x = x.left;\n                    } else {\n                        x = x.right;\n                    }\n                }\n                \n                z.parent = y;\n                \n                if (y.isNull) {\n                    this.root = z;\n                } else if (z.value < y.value) {\n                    y.left = z;\n                } else {\n                    y.right = z;\n                }\n                \n                this.insertFixup(z);\n                this.renderTree();\n            }\n\n            search(value) {\n                this.log(`Searching for value: ${value}`);\n                let current = this.root;\n                let found = false;\n                \n                while (!current.isNull) {\n                    if (value === current.value) {\n                        found = true;\n                        break;\n                    } else if (value < current.value) {\n                        current = current.left;\n                    } else {\n                        current = current.right;\n                    }\n                }\n                \n                if (found) {\n                    this.log(`✓ Value ${value} found in the tree`);\n                    this.highlightNode(value, true);\n                } else {\n                    this.log(`✗ Value ${value} not found in the tree`);\n                }\n                \n                return found;\n            }\n\n            highlightNode(value, isFound) {\n                const nodes = document.querySelectorAll('.node');\n                nodes.forEach(node => {\n                    if (parseInt(node.textContent) === value) {\n                        node.style.boxShadow = isFound ? '0 0 10px green' : '0 0 10px orange';\n                        setTimeout(() => node.style.boxShadow = '', 2000);\n                    }\n                });\n            }\n\n            renderTree() {\n                const container = document.getElementById('treeContainer');\n                container.innerHTML = '';\n                \n                if (this.root.isNull) {\n                    container.innerHTML = '<p>Tree is empty</p>';\n                    return;\n                }\n                \n                const levels = this.getTreeLevels();\n                this.drawTree(levels, container);\n            }\n\n            getTreeLevels() {\n                const levels = [];\n                const queue = [{node: this.root, level: 0, pos: 0}];\n                \n                while (queue.length > 0) {\n                    const {node, level, pos} = queue.shift();\n                    \n                    if (!levels[level]) levels[level] = [];\n                    levels[level][pos] = node;\n                    \n                    if (!node.left.isNull) {\n                        queue.push({node: node.left, level: level + 1, pos: pos * 2});\n                    }\n                    if (!node.right.isNull) {\n                        queue.push({node: node.right, level: level + 1, pos: pos * 2 + 1});\n                    }\n                }\n                \n                return levels;\n            }\n\n            drawTree(levels, container) {\n                const maxLevel = levels.length - 1;\n                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svg.style.width = '100%';\n                svg.style.height = '400px';\n                svg.style.position = 'absolute';\n                \n                const nodeContainer = document.createElement('div');\n                nodeContainer.style.position = 'relative';\n                nodeContainer.style.minHeight = '400px';\n                \n                levels.forEach((levelNodes, level) => {\n                    const levelDiv = document.createElement('div');\n                    levelDiv.style.display = 'flex';\n                    levelDiv.style.justifyContent = 'center';\n                    levelDiv.style.marginBottom = '40px';\n                    \n                    const levelWidth = Math.pow(2, level);\n                    levelNodes.forEach((node, index) => {\n                        if (node) {\n                            const nodeDiv = document.createElement('div');\n                            nodeDiv.className = `node ${node.color}`;\n                            nodeDiv.textContent = node.value;\n                            nodeDiv.style.margin = `0 ${80 / levelWidth}px`;\n                            nodeDiv.dataset.value = node.value;\n                            \n                            levelDiv.appendChild(nodeDiv);\n                            \n                            // Draw lines to children\n                            if (!node.left.isNull) {\n                                this.drawLine(svg, nodeDiv, level + 1, index * 2, levelWidth * 2);\n                            }\n                            if (!node.right.isNull) {\n                                this.drawLine(svg, nodeDiv, level + 1, index * 2 + 1, levelWidth * 2);\n                            }\n                        }\n                    });\n                    \n                    nodeContainer.appendChild(levelDiv);\n                });\n                \n                container.appendChild(svg);\n                container.appendChild(nodeContainer);\n            }\n\n            drawLine(svg, parentNode, childLevel, childIndex, totalWidth) {\n                const parentRect = parentNode.getBoundingClientRect();\n                const containerRect = document.getElementById('treeContainer').getBoundingClientRect();\n                \n                const x1 = parentRect.left + parentRect.width / 2 - containerRect.left;\n                const y1 = parentRect.top + parentRect.height - containerRect.top;\n                \n                const childLevelDiv = document.querySelectorAll('#treeContainer > div > div')[childLevel];\n                if (!childLevelDiv) return;\n                \n                const childNodes = childLevelDiv.children;\n                const childNode = childNodes[childIndex];\n                if (!childNode) return;\n                \n                const childRect = childNode.getBoundingClientRect();\n                const x2 = childRect.left + childRect.width / 2 - containerRect.left;\n                const y2 = childRect.top - containerRect.top;\n                \n                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                line.setAttribute('x1', x1);\n                line.setAttribute('y1', y1);\n                line.setAttribute('x2', x2);\n                line.setAttribute('y2', y2);\n                line.setAttribute('stroke', '#333');\n                line.setAttribute('stroke-width', '2');\n                \n                svg.appendChild(line);\n            }\n        }\n\n        const tree = new RedBlackTree();\n\n        function insertNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            tree.insert(value);\n            document.getElementById('nodeValue').value = '';\n            updateDeleteButton();\n        }\n\n        function deleteNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            // Delete functionality would be implemented here\n            tree.log(`Delete operation for value ${value} (not implemented in this demo)`);\n            document.getElementById('nodeValue').value = '';\n            updateDeleteButton();\n        }\n\n        function searchNode() {\n            const value = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            tree.search(value);\n            document.getElementById('nodeValue').value = '';\n        }\n\n        function clearTree() {\n            tree.root = tree.NIL;\n            tree.operationCount = 0;\n            document.getElementById('opCount').textContent = '0';\n            document.getElementById('log').innerHTML = '';\n            tree.renderTree();\n            updateDeleteButton();\n            tree.log('Tree cleared');\n        }\n\n        function generateRandomTree() {\n            clearTree();\n            const count = Math.floor(Math.random() * 10) + 5;\n            for (let i = 0; i < count; i++) {\n                const value = Math.floor(Math.random() * 100);\n                tree.insert(value);\n            }\n            updateDeleteButton();\n        }\n\n        function updateDeleteButton() {\n            const deleteBtn = document.getElementById('deleteBtn');\n            deleteBtn.disabled = tree.root.isNull;\n        }\n\n        // Initialize\n        updateDeleteButton();\n        tree.renderTree();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}