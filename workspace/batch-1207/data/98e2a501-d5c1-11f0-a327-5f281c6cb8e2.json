{
  "id": "98e2a501-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:20.545Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Huffman Coding Visualizer</title>\n<style>\n  :root{--bg:#0f1724;--panel:#111827;--accent:#3b82f6;--muted:#94a3b8;--card:#0b1220;--good:#16a34a;--bad:#ef4444}\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial}\n  body{background:linear-gradient(180deg,#051025 0%, #071428 50%, #021324 100%);color:#e6eef8;display:flex;flex-direction:column;gap:12px;padding:16px;}\n  header{display:flex;align-items:center;gap:12px}\n  header h1{margin:0;font-size:20px}\n  .container{display:grid;grid-template-columns:370px 1fr;gap:16px;align-items:start}\n  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}\n  .controls{display:flex;flex-direction:column;gap:10px}\n  textarea,input,select,button{font-family:inherit;font-size:13px}\n  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}\n  textarea{width:100%;min-height:84px;background:#071223;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;color:#e6eef8;resize:vertical}\n  input[type=\"text\"],select{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#071223;color:#e6eef8}\n  .row{display:flex;gap:8px}\n  .row > *{flex:1}\n  button{background:var(--accent);border:none;color:white;padding:10px;border-radius:8px;cursor:pointer}\n  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}\n  .small{padding:8px;font-size:13px;border-radius:6px}\n  .kbd{background:#081226;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace}\n  .meta{display:flex;gap:8px;flex-wrap:wrap}\n  .stat{background:#061226;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:120px}\n  .tree-area{height:640px;position:relative;overflow:auto;background:linear-gradient(180deg,#071a2b,rgba(7,24,43,0.6));border-radius:10px;padding:12px}\n  svg{width:100%;height:100%}\n  .codes{max-height:300px;overflow:auto;margin-top:8px;border-radius:6px;padding:8px;background:#061226;border:1px solid rgba(255,255,255,0.02)}\n  table{width:100%;border-collapse:collapse;font-size:13px}\n  th,td{padding:6px 8px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03)}\n  th{font-size:12px;color:var(--muted)}\n  .node{stroke:#0b1220;stroke-width:1.5}\n  .leaf{fill:#0ea5a4}\n  .internal{fill:#3b82f6}\n  .highlight{stroke:#f59e0b;stroke-width:3}\n  .pq{background:#061226;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);margin-top:8px}\n  .controls-row{display:flex;gap:8px;align-items:center}\n  .toggle{display:inline-flex;align-items:center;gap:8px}\n  .smallmuted{color:var(--muted);font-size:13px}\n  a{color:var(--accent)}\n  footer{color:var(--muted);font-size:13px}\n  .bitbox{background:#071426;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);font-family:monospace;white-space:nowrap;overflow:auto}\n  @media(max-width:900px){.container{grid-template-columns:1fr;}}\n</style>\n</head>\n<body>\n<header>\n  <h1>Huffman Coding Visualizer</h1>\n  <div class=\"smallmuted\">Interactive demonstration of building a Huffman tree, generating codes, encoding and decoding.</div>\n</header>\n\n<div class=\"container\">\n  <div class=\"panel controls\">\n    <label for=\"inputText\">Input text (or enter symbol:frequency lines below)</label>\n    <textarea id=\"inputText\" placeholder=\"Type text to analyze, e.g.: hello world\"></textarea>\n\n    <label for=\"freqInput\">Optional custom frequencies (one per line, e.g. A:5 or space:10). If filled, this overrides the text above.</label>\n    <textarea id=\"freqInput\" placeholder=\"Example:\na:5\nb:2\n :10\"></textarea>\n\n    <div class=\"row\">\n      <button id=\"buildBtn\">Build Huffman Tree</button>\n      <button id=\"randomBtn\" class=\"ghost\">Sample text</button>\n    </div>\n\n    <div class=\"controls-row\">\n      <div style=\"flex:1\">\n        <label>Step through tree construction</label>\n        <div class=\"row\">\n          <button id=\"stepBack\" class=\"ghost small\">◀ Step Back</button>\n          <button id=\"stepForward\" class=\"ghost small\">Step ▶</button>\n          <button id=\"playBtn\" class=\"small\">Play ▶</button>\n        </div>\n      </div>\n      <div style=\"width:120px\">\n        <label>Speed (ms)</label>\n        <input type=\"range\" id=\"speed\" min=\"200\" max=\"2000\" step=\"100\" value=\"800\"/>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:8px;align-items:center;justify-content:space-between\">\n      <div class=\"smallmuted\">Priority queue shows nodes available each step.</div>\n      <button id=\"resetBtn\" class=\"ghost small\">Reset</button>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <label>Encoding / Decoding</label>\n      <div class=\"row\">\n        <input id=\"encodeInput\" type=\"text\" placeholder=\"Text to encode (uses current mapping)\"/>\n        <button id=\"encodeBtn\" class=\"small\">Encode</button>\n      </div>\n      <div style=\"margin-top:8px\" class=\"row\">\n        <input id=\"bitInput\" type=\"text\" placeholder=\"Bits to decode (e.g. 010011)\"/>\n        <button id=\"decodeBtn\" class=\"small\">Decode</button>\n      </div>\n    </div>\n\n    <div style=\"margin-top:8px\" class=\"meta\">\n      <div class=\"stat\"><div class=\"smallmuted\">Original length</div><div id=\"origLen\">—</div></div>\n      <div class=\"stat\"><div class=\"smallmuted\">Encoded bits</div><div id=\"encLen\">—</div></div>\n      <div class=\"stat\"><div class=\"smallmuted\">Compression</div><div id=\"ratio\">—</div></div>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <label>Codes</label>\n      <div id=\"codes\" class=\"codes\">No codes yet</div>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <label>Priority Queue (current step)</label>\n      <div id=\"pq\" class=\"pq\">—</div>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <label>Encoded bits (top 400 shown)</label>\n      <div id=\"bitbox\" class=\"bitbox\">—</div>\n    </div>\n\n    <div style=\"margin-top:8px\">\n      <label>Decode result</label>\n      <div id=\"decodeResult\" class=\"bitbox\">—</div>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <label>Tree visualization</label>\n    <div class=\"tree-area\" id=\"treeArea\">\n      <svg id=\"svgRoot\" viewBox=\"0 0 1200 640\" preserveAspectRatio=\"xMinYMin meet\"></svg>\n    </div>\n  </div>\n</div>\n\n<footer style=\"margin-top:8px\">\n  Explanation: Huffman coding builds an optimal prefix code by repeatedly merging the two least-frequent symbols into a combined node. Left edges are shown as \"0\" and right edges as \"1\". Use the step controls to watch the merges.\n</footer>\n\n<script>\n/* Huffman Coding Visualizer\n   - Build freq table from input text or explicit frequencies\n   - Construct Huffman tree; record merge steps\n   - Visualize tree, nodes, codes; allow step-through animation\n   - Encode/decode functionality\n*/\n\n(function(){\n  // Utilities\n  const $ = id => document.getElementById(id)\n  const svg = $('svgRoot')\n  const treeArea = $('treeArea')\n\n  // State\n  let nodes = []             // all nodes created (leaves and internals)\n  let steps = []             // snapshots of {queue: [{id,weight,labels}], merge: {left,right,newId}} per merge\n  let stepIndex = 0\n  let playTimer = null\n\n  // DOM elements\n  const inputText = $('inputText')\n  const freqInput = $('freqInput')\n  const buildBtn = $('buildBtn')\n  const randomBtn = $('randomBtn')\n  const stepForward = $('stepForward')\n  const stepBack = $('stepBack')\n  const playBtn = $('playBtn')\n  const resetBtn = $('resetBtn')\n  const speed = $('speed')\n  const codesDiv = $('codes')\n  const pqDiv = $('pq')\n  const origLenDiv = $('origLen')\n  const encLenDiv = $('encLen')\n  const ratioDiv = $('ratio')\n  const encodeInput = $('encodeInput')\n  const encodeBtn = $('encodeBtn')\n  const bitInput = $('bitInput')\n  const decodeBtn = $('decodeBtn')\n  const bitbox = $('bitbox')\n  const decodeResult = $('decodeResult')\n\n  // Sample texts\n  const samples = [\n    \"this is an example for huffman encoding\",\n    \"hello hello hello huffman coding test\",\n    \"the quick brown fox jumps over the lazy dog\",\n    \"aaaaabbbbcccdde\"\n  ]\n  randomBtn.addEventListener('click', ()=>{\n    inputText.value = samples[Math.floor(Math.random()*samples.length)]\n  })\n\n  buildBtn.addEventListener('click', buildFromInput)\n  stepForward.addEventListener('click', ()=>{ stepIndex = Math.min(stepIndex+1, steps.length); renderStep() })\n  stepBack.addEventListener('click', ()=>{ stepIndex = Math.max(stepIndex-1, 0); renderStep() })\n  playBtn.addEventListener('click', togglePlay)\n  resetBtn.addEventListener('click', resetAll)\n  encodeBtn.addEventListener('click', doEncode)\n  decodeBtn.addEventListener('click', doDecode)\n\n  // buildFromInput: read input text / freq input and build steps\n  function buildFromInput(){\n    resetAll()\n    const freqSpec = parseFreqInput(freqInput.value.trim())\n    let freq\n    if (Object.keys(freqSpec).length > 0) {\n      freq = freqSpec\n    } else {\n      const txt = inputText.value\n      if (!txt) { alert('Enter text or custom frequencies first.'); return }\n      freq = buildFreqFromText(txt)\n    }\n    // Create leaf nodes\n    nodes = []\n    let idCounter = 0\n    const leaves = []\n    for (const sym of Object.keys(freq).sort()) {\n      const node = { id: 'n'+(idCounter++), sym, weight: freq[sym], left:null, right:null, isLeaf:true }\n      nodes.push(node)\n      leaves.push(node)\n    }\n    // Edge case: single symbol -> assign code \"0\"\n    if (leaves.length === 1) {\n      const root = { id:'n'+(idCounter++), sym:null, weight:leaves[0].weight, left:leaves[0], right:null, isLeaf:false }\n      nodes.push(root)\n      steps = [{ queue: leaves.map(n=>snapshotNode(n)), merge: null }]\n      steps.push({ queue: [snapshotNode(root)], merge: { left: leaves[0].id, right: null, newId: root.id } })\n      stepIndex = steps.length\n      buildCodes(root)\n      renderStep()\n      return\n    }\n\n    // Priority queue: array of nodes, sorted by weight then by symbol ordering for determinism\n    function pqCompare(a,b){\n      if (a.weight !== b.weight) return a.weight - b.weight\n      // tie-breaker: leaf vs internal, then symbol alphabetical, then id\n      const at = a.isLeaf ? 0 : 1\n      const bt = b.isLeaf ? 0 : 1\n      if (at !== bt) return at - bt\n      const sa = a.isLeaf ? String(a.sym) : combinedLabel(a)\n      const sb = b.isLeaf ? String(b.sym) : combinedLabel(b)\n      if (sa !== sb) return sa < sb ? -1 : 1\n      return a.id < b.id ? -1 : 1\n    }\n    function combinedLabel(n){\n      if (!n) return ''\n      if (n.isLeaf) return String(n.sym)\n      const left = n.left ? combinedLabel(n.left) : ''\n      const right = n.right ? combinedLabel(n.right) : ''\n      return '('+left+'|'+right+')'\n    }\n\n    // Initialize PQ\n    let pq = leaves.slice().sort(pqCompare)\n    steps = []\n    steps.push({ queue: pq.map(n=>snapshotNode(n)), merge: null })\n\n    // Iteratively merge two smallest\n    while (pq.length > 1) {\n      const a = pq.shift()\n      const b = pq.shift()\n      const merged = { id:'n'+(idCounter++), sym:null, weight: a.weight + b.weight, left:a, right:b, isLeaf:false }\n      nodes.push(merged)\n      // Insert back into pq keeping sort\n      pq.push(merged)\n      pq.sort(pqCompare)\n      steps.push({ queue: pq.map(n=>snapshotNode(n)), merge: { left: a.id, right: b.id, newId: merged.id } })\n    }\n\n    // Final root is pq[0]\n    stepIndex = 0\n    buildCodes(pq[0])\n    renderStep()\n  }\n\n  function snapshotNode(n){\n    return { id: n.id, weight: n.weight, label: n.isLeaf ? String(n.sym) : combinedLabel(n) }\n    function combinedLabel(n2){\n      if (n2.isLeaf) return String(n2.sym)\n      const l = n2.left ? combinedLabel(n2.left) : ''\n      const r = n2.right ? combinedLabel(n2.right) : ''\n      return '('+l+'|'+r+')'\n    }\n  }\n\n  function buildFreqFromText(text){\n    const freq = {}\n    for (let ch of text) {\n      freq[ch] = (freq[ch] || 0) + 1\n    }\n    return freq\n  }\n\n  function parseFreqInput(txt){\n    const out = {}\n    if (!txt) return out\n    const lines = txt.split('\\n')\n    for (let line of lines) {\n      line = line.trim()\n      if (!line) continue\n      const m = line.match(/^(.+?)\\s*[:=]\\s*(\\d+)\\s*$/)\n      if (m) {\n        let sym = m[1]\n        // allow special names like \"space\" or \"newline\"\n        if (sym.toLowerCase() === 'space') sym = ' '\n        else if (sym.toLowerCase() === 'newline') sym = '\\n'\n        else if (sym.toLowerCase() === 'tab') sym = '\\t'\n        out[sym] = parseInt(m[2],10)\n      } else {\n        // fallback: single char then number separated by whitespace\n        const p = line.split(/\\s+/)\n        if (p.length >= 2 && p[p.length-1].match(/^\\d+$/)) {\n          const num = parseInt(p[p.length-1],10)\n          const sym = line.slice(0, line.lastIndexOf(p[p.length-1])).trim()\n          let s = sym\n          if (s.toLowerCase() === 'space') s = ' '\n          out[s] = num\n        }\n      }\n    }\n    return out\n  }\n\n  // Build codes for a final root node\n  let currentCodes = {}\n  function buildCodes(root){\n    currentCodes = {}\n    if (!root) return\n    // Edge single leaf: assign code '0'\n    if (root.isLeaf) {\n      currentCodes[root.sym] = '0'\n      return\n    }\n    const dfs = (node, prefix)=>{\n      if (!node) return\n      if (node.isLeaf) {\n        currentCodes[node.sym] = prefix || '0'\n        return\n      }\n      dfs(node.left, prefix + '0')\n      dfs(node.right, prefix + '1')\n    }\n    dfs(root, '')\n  }\n\n  // Render functions\n  function renderStep(){\n    clearSvg()\n    if (steps.length === 0) {\n      codesDiv.innerText = 'No codes yet'\n      pqDiv.innerText = '—'\n      origLenDiv.innerText = '—'\n      encLenDiv.innerText = '—'\n      ratioDiv.innerText = '—'\n      bitbox.innerText = '—'\n      decodeResult.innerText = '—'\n      return\n    }\n    // Clamp stepIndex\n    stepIndex = Math.max(0, Math.min(stepIndex, steps.length))\n    // Show PQ for current step\n    const snap = (stepIndex === 0) ? steps[0] : steps[Math.max(0, stepIndex-1)]\n    pqDiv.innerHTML = pqHtml(snap.queue, (stepIndex > 0 ? steps[stepIndex-1].merge : null))\n    // Determine which nodes should be visible at this step\n    const visibleIds = new Set()\n    // At step 0: show initial leaves only\n    if (stepIndex === 0) {\n      for (const q of steps[0].queue) visibleIds.add(q.id)\n    } else {\n      // Include leaves that are referenced by any remaining PQ node or by merges already performed\n      // Strategy: reconstruct by applying merges from step 1..stepIndex-1 adding merged nodes\n      // start with leaves from first queue\n      for (const q of steps[0].queue) visibleIds.add(q.id)\n      for (let si = 1; si <= stepIndex; si++) {\n        const merge = steps[si].merge\n        if (!merge) continue\n        visibleIds.add(merge.newId)\n        if (merge.left) visibleIds.add(merge.left)\n        if (merge.right) visibleIds.add(merge.right)\n      }\n    }\n\n    // Build a map of id -> node object from nodes list\n    const nodeMap = {}\n    for (const n of nodes) nodeMap[n.id] = n\n\n    // Build a minimal set of nodes to display: include any visible node and recursively include children if visible\n    const displayNodes = []\n    for (const id of visibleIds) {\n      if (nodeMap[id]) displayNodes.push(nodeMap[id])\n    }\n\n    // Determine root for layout: if we've completed all merges, root is last merged; else choose the highest merged/new node at current step or fallback\n    let root = null\n    if (stepIndex >= steps.length) {\n      root = nodes.find(n => n.id === steps[steps.length-1].merge.newId) || nodeMap[steps[0].queue[0].id]\n    } else {\n      // find the latest merge performed (<= stepIndex)\n      let lastMerge = null\n      for (let si = 1; si <= stepIndex; si++) {\n        const m = steps[si].merge\n        if (m) lastMerge = m\n      }\n      if (lastMerge) root = nodeMap[lastMerge.newId]\n      else {\n        // no merges yet: pick an arbitrary leaf (leftmost)\n        root = nodeMap[steps[0].queue[0].id]\n      }\n    }\n    if (!root) root = displayNodes[0]\n\n    // Layout positions: compute subtree widths and assign x,y\n    const positions = {}\n    const levelHeight = 80\n    function computeWidths(node){\n      if (!node) return 0\n      // If node not in displayNodes set, treat as width 0\n      if (!visibleIds.has(node.id)) return 0\n      if (node.isLeaf) {\n        return 1\n      } else {\n        const lw = computeWidths(node.left)\n        const rw = computeWidths(node.right)\n        const w = Math.max(1, lw + rw)\n        return w\n      }\n    }\n    const totalWidthUnits = computeWidths(root) || 1\n    let cursor = 0\n    function assign(node, depth){\n      if (!node) return\n      if (!visibleIds.has(node.id)) return\n      if (node.isLeaf) {\n        const x = ((cursor + 0.5) / totalWidthUnits) * 1000 + 60\n        positions[node.id] = {x, y: 20 + depth*levelHeight}\n        cursor++\n      } else {\n        // place children first\n        assign(node.left, depth+1)\n        assign(node.right, depth+1)\n        // position here as midpoint of children available positions\n        const leftPos = node.left && positions[node.left.id]\n        const rightPos = node.right && positions[node.right.id]\n        let x\n        if (leftPos && rightPos) x = (leftPos.x + rightPos.x)/2\n        else if (leftPos) x = leftPos.x\n        else if (rightPos) x = rightPos.x\n        else {\n          // no children visible: assign at next cursor\n          x = ((cursor + 0.5) / totalWidthUnits) * 1000 + 60\n          cursor++\n        }\n        positions[node.id] = {x, y: 20 + depth*levelHeight}\n      }\n    }\n    assign(root, 0)\n\n    // Draw edges and nodes for visible nodes\n    // We'll draw edges first (so nodes overlay them)\n    const svgNS = \"http://www.w3.org/2000/svg\"\n\n    // edges\n    for (const id of Object.keys(positions)) {\n      const node = nodeMap[id]\n      if (!node || node.isLeaf) continue\n      const p = positions[id]\n      if (node.left && positions[node.left.id]) {\n        const c = positions[node.left.id]\n        const line = document.createElementNS(svgNS, 'path')\n        const d = `M ${p.x} ${p.y+18} C ${p.x} ${p.y+40} ${c.x} ${c.y-10} ${c.x} ${c.y-8}`\n        line.setAttribute('d', d)\n        line.setAttribute('stroke', '#2b6ea3')\n        line.setAttribute('fill', 'none')\n        line.setAttribute('opacity', '0.9')\n        svg.appendChild(line)\n        // label 0 near left branch\n        const tx = document.createElementNS(svgNS, 'text')\n        tx.setAttribute('x', (p.x*0.66 + c.x*0.34))\n        tx.setAttribute('y', (p.y*0.66 + c.y*0.34)-6)\n        tx.setAttribute('fill', '#bfe0ff')\n        tx.setAttribute('font-size', '11')\n        tx.setAttribute('text-anchor','middle')\n        tx.textContent = '0'\n        svg.appendChild(tx)\n      }\n      if (node.right && positions[node.right.id]) {\n        const c = positions[node.right.id]\n        const p2 = positions[id]\n        const line = document.createElementNS(svgNS, 'path')\n        const d = `M ${p2.x} ${p2.y+18} C ${p2.x} ${p2.y+40} ${c.x} ${c.y-10} ${c.x} ${c.y-8}`\n        line.setAttribute('d', d)\n        line.setAttribute('stroke', '#60a5fa')\n        line.setAttribute('fill', 'none')\n        line.setAttribute('opacity', '0.9')\n        svg.appendChild(line)\n        // label 1 near right branch\n        const tx = document.createElementNS(svgNS, 'text')\n        tx.setAttribute('x', (p2.x*0.66 + c.x*0.34))\n        tx.setAttribute('y', (p2.y*0.66 + c.y*0.34)-6)\n        tx.setAttribute('fill', '#bfe0ff')\n        tx.setAttribute('font-size', '11')\n        tx.setAttribute('text-anchor','middle')\n        tx.textContent = '1'\n        svg.appendChild(tx)\n      }\n    }\n\n    // nodes\n    for (const id of Object.keys(positions)) {\n      const n = nodeMap[id]\n      const pos = positions[id]\n      const g = document.createElementNS(svgNS, 'g')\n      g.setAttribute('transform', `translate(${pos.x},${pos.y})`)\n      // circle\n      const circ = document.createElementNS(svgNS, 'circle')\n      circ.setAttribute('r', 18)\n      circ.setAttribute('class', 'node')\n      circ.setAttribute('stroke', '#062033')\n      circ.setAttribute('stroke-width', '2')\n      circ.setAttribute('fill', n.isLeaf ? '#06b6a4' : '#3b82f6')\n      // highlight merged node at current step (if any)\n      const curMerge = (stepIndex>0 && stepIndex<=steps.length-1) ? steps[stepIndex].merge : null\n      if (curMerge && curMerge.newId === id) {\n        circ.setAttribute('stroke', '#f59e0b')\n        circ.setAttribute('stroke-width', '3')\n      }\n      g.appendChild(circ)\n      // text: weight\n      const txt1 = document.createElementNS(svgNS, 'text')\n      txt1.setAttribute('y', -2)\n      txt1.setAttribute('fill', '#031827')\n      txt1.setAttribute('font-weight', '700')\n      txt1.setAttribute('font-size', '12')\n      txt1.setAttribute('text-anchor','middle')\n      txt1.textContent = n.weight\n      g.appendChild(txt1)\n      // symbol for leaf\n      if (n.isLeaf) {\n        const txt2 = document.createElementNS(svgNS, 'text')\n        txt2.setAttribute('y', 18)\n        txt2.setAttribute('fill', '#bfe0ff')\n        txt2.setAttribute('font-size', '12')\n        txt2.setAttribute('text-anchor','middle')\n        txt2.textContent = printable(n.sym)\n        g.appendChild(txt2)\n      }\n      svg.appendChild(g)\n    }\n\n    // Update codes display: if fully built, show final codes; else show codes for partial tree (if possible)\n    const finalRoot = nodes.find(n => steps.length>0 && n.id === steps[steps.length-1].merge.newId)\n    if (finalRoot) {\n      buildCodes(finalRoot)\n      // original text metrics\n      const freq = {}\n      if (freqInput.value.trim()) {\n        Object.assign(freq, parseFreqInput(freqInput.value.trim()))\n      } else {\n        const txt = inputText.value || ''\n        const f = buildFreqFromText(txt)\n        Object.assign(freq, f)\n      }\n      let origBits = 0\n      let totalChars = 0\n      for (const s of Object.keys(freq)) {\n        totalChars += freq[s]\n        const code = currentCodes[s] || ''\n        origBits += freq[s] * code.length\n      }\n      // For original size assuming 8 bits per character\n      const origSizeBits = (inputText.value || '').length * 8\n      origLenDiv.innerText = (inputText.value || '').length + ' chars (' + origSizeBits + ' bits at 8b/c)'\n      encLenDiv.innerText = origBits + ' bits'\n      ratioDiv.innerText = origBits ? ( (origBits / origSizeBits * 100).toFixed(1) + '% of original') : '—'\n      // codes table\n      codesDiv.innerHTML = buildCodesHtml(currentCodes, freq)\n      // show encoded bits for the entire input text\n      const txt = inputText.value || ''\n      const encoded = encodeTextWithCodes(txt, currentCodes)\n      bitbox.innerText = encoded ? encoded.slice(0,400) + (encoded.length>400 ? '…' : '') : '(empty)'\n    } else {\n      codesDiv.innerText = 'Tree not complete yet; advance steps to final merge to see final codes.'\n      origLenDiv.innerText = '—'\n      encLenDiv.innerText = '—'\n      ratioDiv.innerText = '—'\n      bitbox.innerText = '—'\n    }\n\n    // adjust svg viewBox to content (rough)\n    const allX = Object.values(positions).map(p=>p.x)\n    const allY = Object.values(positions).map(p=>p.y)\n    if (allX.length>0) {\n      const minX = Math.min(...allX)-80\n      const maxX = Math.max(...allX)+80\n      const minY = 0\n      const maxY = Math.max(...allY)+120\n      const width = Math.max(900, maxX-minX)\n      const height = Math.max(300, maxY-minY)\n      svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`)\n    }\n  }\n\n  function pqHtml(queue, merge){\n    if (!queue || queue.length===0) return '—'\n    const rows = queue.map(q=> `<div style=\"display:flex;justify-content:space-between;padding:4px 6px;border-radius:6px;margin-bottom:4px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)\"><div style=\"font-family:monospace\">${escapeHtml(q.label)}</div><div style=\"color:#bfe0ff\">${q.weight}</div></div>`).join('')\n    let top = '<div style=\"font-size:13px;color:var(--muted);margin-bottom:6px\">[' + queue.map(q=>q.id).join(', ') + ']</div>'\n    if (merge) {\n      top += `<div style=\"font-size:13px;color:#f59e0b;margin-bottom:6px\">Last merge: ${merge.left}${merge.right ? ' + ' + merge.right : ''} → ${merge.newId}</div>`\n    }\n    return top + rows\n  }\n\n  function buildCodesHtml(codes, freq){\n    const entries = Object.keys(codes).sort((a,b)=> ( (freq && freq[b] ? freq[b] :0) - (freq && freq[a] ? freq[a] :0) ) || (a<b?-1:1))\n    let html = '<table><thead><tr><th>Symbol</th><th>Frequency</th><th>Code</th><th>Bits</th></tr></thead><tbody>'\n    for (const s of entries) {\n      const code = codes[s]\n      const f = freq && freq[s] ? freq[s] : '-'\n      html += `<tr><td class=\"kbd\">${escapeHtml(printable(s))}</td><td>${f}</td><td><span class=\"kbd\">${escapeHtml(code)}</span></td><td>${code.length}</td></tr>`\n    }\n    html += '</tbody></table>'\n    return html\n  }\n\n  function escapeHtml(s){\n    if (s === null || s === undefined) return ''\n    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')\n  }\n\n  function printable(s){\n    if (s === ' ') return '␣ (space)'\n    if (s === '\\n') return '␤ (newline)'\n    if (s === '\\t') return '\\\\t (tab)'\n    if (s === '') return '(empty)'\n    return String(s)\n  }\n\n  function clearSvg(){\n    while (svg.firstChild) svg.removeChild(svg.firstChild)\n  }\n\n  // Encoding & decoding helpers\n  function encodeTextWithCodes(txt, codes){\n    if (!txt || !codes) return ''\n    let out = ''\n    for (let ch of txt) {\n      const c = codes[ch]\n      if (!c) return null\n      out += c\n    }\n    return out\n  }\n\n  function doEncode(){\n    if (!currentCodes || Object.keys(currentCodes).length===0) {\n      alert('No code mapping available. Build the tree first and reach the final merge.')\n      return\n    }\n    const text = encodeInput.value\n    if (!text) { alert('Enter text to encode'); return }\n    const enc = encodeTextWithCodes(text, currentCodes)\n    if (enc === null) {\n      alert('Input contains symbols not present in the codes.')\n      return\n    }\n    bitbox.innerText = enc.slice(0,400) + (enc.length>400 ? '…' : '')\n    encLenDiv.innerText = enc.length + ' bits (encoded input)'\n  }\n\n  function doDecode(){\n    if (!nodes || nodes.length===0) { alert('Build a tree first.'); return }\n    // Need final root (complete tree)\n    const finalMerge = steps.length ? steps[steps.length-1].merge : null\n    if (!finalMerge) { alert('Tree not complete; advance to final merge to decode.'); return }\n    const root = nodes.find(n => n.id === finalMerge.newId)\n    if (!root) { alert('No final tree available.'); return }\n    const bits = bitInput.value.trim()\n    if (!bits) { alert('Enter bits to decode'); return }\n    // validate bits\n    if (!/^[01]+$/.test(bits)) { alert('Bits must be 0/1 only'); return }\n    let out = ''\n    let node = root\n    for (let i=0;i<bits.length;i++){\n      const b = bits[i]\n      if (b === '0') node = node.left\n      else node = node.right\n      if (!node) { decodeResult.innerText = 'Decoding failed at bit index ' + i + ' (no child)'; return }\n      if (node.isLeaf) {\n        out += node.sym\n        node = root\n      }\n    }\n    decodeResult.innerText = out || '(empty)'\n  }\n\n  // Play control\n  function togglePlay(){\n    if (playTimer) {\n      clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play ▶'\n    } else {\n      playBtn.textContent = 'Pause ❚❚'\n      playTimer = setInterval(()=>{\n        if (stepIndex < steps.length) {\n          stepIndex++\n          renderStep()\n        } else {\n          clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play ▶'\n        }\n      }, parseInt(speed.value,10))\n    }\n  }\n\n  function resetAll(){\n    nodes = []\n    steps = []\n    stepIndex = 0\n    currentCodes = {}\n    clearSvg()\n    renderStep()\n  }\n\n  // Initialize with a default sample\n  inputText.value = samples[0]\n  buildFromInput()\n\n  // Accessibility: keyboard shortcuts\n  document.addEventListener('keydown', (e)=>{\n    if (e.key === 'ArrowRight') { stepIndex = Math.min(stepIndex+1, steps.length); renderStep() }\n    if (e.key === 'ArrowLeft') { stepIndex = Math.max(stepIndex-1, 0); renderStep() }\n    if (e.key === ' ') { e.preventDefault(); togglePlay() }\n  })\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}