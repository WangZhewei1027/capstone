{
  "id": "e934fb12-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:37.980Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>K-Means Clustering — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#f6f7fb;\n      --panel:#ffffff;\n      --muted:#666;\n      --accent:#2b7cff;\n      --danger:#e05d5d;\n      --ok:#3bb273;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#eef2ff 0%, var(--bg) 40%); display:flex; align-items:stretch; padding:20px; box-sizing:border-box;}\n    .container{max-width:1200px;margin:auto; width:100%; display:flex; gap:18px;}\n    .left{flex:1; background:var(--panel); border-radius:12px; padding:14px; box-shadow:0 6px 18px rgba(20,30,60,0.06);}\n    .right{width:320px; background:var(--panel); border-radius:12px; padding:14px; box-shadow:0 6px 18px rgba(20,30,60,0.06); display:flex; flex-direction:column; gap:12px;}\n    h1{font-size:18px;margin:0 0 6px 0;}\n    p.lead{margin:0;color:var(--muted);font-size:13px;}\n    canvas{width:100%; height:600px; border-radius:8px; background:linear-gradient(180deg,#ffffff 0%, #fafbff 100%); display:block; box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);}\n    .row{display:flex; gap:8px; align-items:center;}\n    .controls{display:flex; flex-direction:column; gap:10px;}\n    label{font-size:13px;color:#333;}\n    input[type=\"range\"]{width:100%;}\n    .small{font-size:12px;color:var(--muted);}\n    button{background:var(--accent); color:white; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600;}\n    button.secondary{background:#f3f6ff; color:#234; font-weight:600; border:1px solid rgba(20,40,100,0.06);}\n    button.warn{background:var(--danger);}\n    .inline{display:flex; gap:8px; align-items:center;}\n    select{padding:8px;border-radius:8px;border:1px solid #e6e9f2;background:white;}\n    .stat{background:#f8fafc;border-radius:8px;padding:8px;font-size:13px;color:#222;}\n    .muted{color:var(--muted);font-size:13px;}\n    .colors-legend{display:flex;flex-wrap:wrap;gap:6px;}\n    .legend-item{display:flex;gap:6px;align-items:center;padding:6px;border-radius:6px;background:#fbfcff;border:1px solid #f0f4ff;font-size:12px;}\n    .swatch{width:14px;height:14px;border-radius:3px;}\n    footer{font-size:12px;color:var(--muted);margin-top:8px;}\n    .btn-row{display:flex; gap:8px; flex-wrap:wrap;}\n    .linklike{background:none;border:0;color:var(--accent);cursor:pointer;padding:0;font-weight:600;}\n    .toggle{display:inline-flex;align-items:center;gap:8px;}\n    .note{font-size:12px;color:var(--muted);}\n    .center{display:flex;align-items:center;justify-content:center;}\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"K-Means clustering demo\">\n    <div class=\"left\">\n      <h1>K-Means Clustering — Visual Interactive Demo</h1>\n      <p class=\"lead\">Generate 2D points, pick K, and watch the algorithm group points into clusters. Try different initialization methods and step through iterations.</p>\n\n      <canvas id=\"plot\" width=\"900\" height=\"600\" title=\"Click to add points when Add Points mode is on\"></canvas>\n\n      <div style=\"display:flex;justify-content:space-between;gap:12px;margin-top:10px;\">\n        <div class=\"muted\">Click a point and drag to move it. Toggle \"Add Points\" to add new points by clicking on the plot.</div>\n        <div class=\"muted\">Legend: large squares are centroids; small are data points.</div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"controls\">\n        <div class=\"row\">\n          <label for=\"nPoints\">Points</label>\n          <div style=\"flex:1;margin-left:8px;\">\n            <input id=\"nPoints\" type=\"range\" min=\"10\" max=\"1000\" value=\"150\" />\n            <div class=\"small\">Count: <span id=\"nPointsVal\">150</span></div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"k\">K (clusters)</label>\n          <div style=\"flex:1;margin-left:8px;\">\n            <input id=\"k\" type=\"range\" min=\"1\" max=\"12\" value=\"4\" />\n            <div class=\"small\">K: <span id=\"kVal\">4</span></div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"init\">Initialization</label>\n          <select id=\"init\" style=\"flex:1;margin-left:8px;\">\n            <option value=\"random\">Random</option>\n            <option value=\"kmeans++\" selected>K-Means++</option>\n          </select>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"speed\">Speed (ms)</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"250\" />\n          <div class=\"small\">Animation delay: <span id=\"speedVal\">250</span> ms</div>\n        </div>\n\n        <div class=\"btn-row\">\n          <button id=\"initBtn\" class=\"secondary\">Initialize</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"runBtn\">Run</button>\n          <button id=\"stopBtn\" class=\"secondary\" disabled>Stop</button>\n        </div>\n\n        <div class=\"btn-row\" style=\"margin-top:6px;\">\n          <button id=\"randomBtn\" class=\"secondary\">Randomize Data</button>\n          <button id=\"clearBtn\" class=\"secondary\">Clear Points</button>\n          <button id=\"resetBtn\" class=\"warn\">Reset All</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;margin-top:6px;\">\n          <label class=\"toggle\"><input id=\"addToggle\" type=\"checkbox\" /> Add Points</label>\n          <label class=\"toggle\"><input id=\"dragToggle\" type=\"checkbox\" checked /> Drag Points</label>\n        </div>\n      </div>\n\n      <div class=\"stat\">\n        <div style=\"display:flex;justify-content:space-between;\">\n          <div>Iteration: <strong id=\"iter\">0</strong></div>\n          <div>Assignments changed: <strong id=\"changed\">—</strong></div>\n        </div>\n        <div style=\"display:flex;justify-content:space-between;margin-top:6px;\">\n          <div>SSE (sum squared errors): <strong id=\"sse\">—</strong></div>\n          <div>Empty clusters: <strong id=\"empty\">0</strong></div>\n        </div>\n      </div>\n\n      <div class=\"stat\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>Colors</div>\n          <div class=\"small\">Up to 12 colors</div>\n        </div>\n        <div class=\"colors-legend\" id=\"legend\" style=\"margin-top:8px;\"></div>\n      </div>\n\n      <div class=\"stat\" style=\"font-size:13px;\">\n        <div><strong>How it works (quick):</strong></div>\n        <ol style=\"padding-left:18px;margin:6px 0 0 0;\">\n          <li>Initialize K centroids (random or K-Means++).</li>\n          <li>Assign each point to nearest centroid.</li>\n          <li>Move centroids to the mean of assigned points.</li>\n          <li>Repeat until assignments don't change or centroids stabilize.</li>\n        </ol>\n      </div>\n\n      <footer>\n        Tip: Try different K and initialization methods. Use \"Step\" to see intermediate changes.\n      </footer>\n    </div>\n  </div>\n\n  <script>\n  // K-Means Interactive Demo\n  (function(){\n    // Canvas and UI elements\n    const canvas = document.getElementById('plot');\n    const ctx = canvas.getContext('2d');\n    const nPointsInput = document.getElementById('nPoints');\n    const nPointsVal = document.getElementById('nPointsVal');\n    const kInput = document.getElementById('k');\n    const kVal = document.getElementById('kVal');\n    const initSelect = document.getElementById('init');\n    const speedInput = document.getElementById('speed');\n    const speedVal = document.getElementById('speedVal');\n    const initBtn = document.getElementById('initBtn');\n    const stepBtn = document.getElementById('stepBtn');\n    const runBtn = document.getElementById('runBtn');\n    const stopBtn = document.getElementById('stopBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const addToggle = document.getElementById('addToggle');\n    const dragToggle = document.getElementById('dragToggle');\n    const iterElem = document.getElementById('iter');\n    const changedElem = document.getElementById('changed');\n    const sseElem = document.getElementById('sse');\n    const emptyElem = document.getElementById('empty');\n    const legend = document.getElementById('legend');\n\n    // State\n    let points = []; // {x:0-1,y:0-1,cluster:-1}\n    let centroids = []; // {x,y}\n    let iteration = 0;\n    let intervalId = null;\n    let lastAssignments = null;\n    let animationDelay = Number(speedInput.value);\n    let draggingPoint = null;\n    let dragOffset = {x:0,y:0};\n\n    // Colors - up to 12 distinct; for larger K we will generate hues\n    const baseColors = [\n      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b',\n      '#e377c2','#7f7f7f','#bcbd22','#17becf','#393b79','#5254a3'\n    ];\n\n    function colorFor(kIndex, K){\n      if (kIndex < baseColors.length) return baseColors[kIndex];\n      // generate using HSL\n      const hue = Math.round((kIndex*360/K) % 360);\n      return `hsl(${hue} 70% 45%)`;\n    }\n\n    // Canvas coordinate helpers\n    const padding = 30;\n    function toCanvas(p){\n      return {cx: padding + p.x*(canvas.width-2*padding), cy: padding + (1-p.y)*(canvas.height-2*padding)};\n    }\n    function fromCanvas(cx, cy){\n      const x = (cx - padding) / (canvas.width - 2*padding);\n      const y = 1 - (cy - padding) / (canvas.height - 2*padding);\n      return {x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y))};\n    }\n\n    // Utilities\n    function rand() { return Math.random(); }\n    function randNormal() {\n      // Box-Muller\n      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();\n      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);\n    }\n\n    // Generate initial clustered data for nicer looking demos\n    function generateData(n){\n      points = [];\n      // Create between 2 and 5 random Gaussian blobs\n      const blobs = Math.max(2, Math.min(6, Math.round(Math.sqrt(n)/3)));\n      const centers = [];\n      for(let i=0;i<blobs;i++){\n        centers.push({x: Math.random()*0.8+0.1, y: Math.random()*0.8+0.1, s: 0.03 + Math.random()*0.06});\n      }\n      for(let i=0;i<n;i++){\n        const b = centers[Math.floor(Math.random()*blobs)];\n        const x = b.x + randNormal()*b.s;\n        const y = b.y + randNormal()*b.s;\n        points.push({x: Math.min(1, Math.max(0, x)), y: Math.min(1, Math.max(0, y)), cluster: -1});\n      }\n      lastAssignments = null;\n      iteration = 0;\n      updateStats();\n      draw();\n    }\n\n    // K-Means++ initialization\n    function kmeansPlusPlusInit(K){\n      centroids = [];\n      if (points.length === 0) return;\n      // pick first uniformly at random from points\n      centroids.push({...points[Math.floor(Math.random()*points.length)]});\n      while(centroids.length < K){\n        // compute squared distances to nearest centroid for each point\n        const d2 = points.map(p => {\n          let md2 = Infinity;\n          for(const c of centroids){\n            const dx = p.x - c.x, dy = p.y - c.y;\n            const dist2 = dx*dx + dy*dy;\n            if (dist2 < md2) md2 = dist2;\n          }\n          return md2;\n        });\n        const sum = d2.reduce((a,b)=>a+b,0);\n        if (sum === 0){\n          // all points identical; pick random\n          centroids.push({...points[Math.floor(Math.random()*points.length)]});\n          continue;\n        }\n        // choose next point weighted by d2\n        let r = Math.random()*sum;\n        let idx = 0;\n        while(r > d2[idx]){ r -= d2[idx]; idx++; if(idx>=d2.length) break; }\n        centroids.push({...points[idx]});\n      }\n    }\n\n    // Random initialization: pick K random positions in unit square\n    function randomInit(K){\n      centroids = [];\n      for(let i=0;i<K;i++){\n        centroids.push({x: Math.random(), y: Math.random()});\n      }\n    }\n\n    // Assign points to nearest centroid; returns count changed\n    function assignPoints(){\n      if (centroids.length === 0) return 0;\n      let changed = 0;\n      for(const p of points){\n        let best = -1;\n        let bestD = Infinity;\n        for(let i=0;i<centroids.length;i++){\n          const c = centroids[i];\n          const dx = p.x - c.x, dy = p.y - c.y;\n          const d2 = dx*dx + dy*dy;\n          if (d2 < bestD){ bestD = d2; best = i; }\n        }\n        if (p.cluster !== best){\n          p.cluster = best;\n          changed++;\n        }\n      }\n      return changed;\n    }\n\n    // Update centroids to means; returns number of empty clusters\n    function updateCentroids(){\n      const K = centroids.length;\n      const sums = Array(K).fill(0).map(()=>({x:0,y:0,count:0}));\n      for(const p of points){\n        if (p.cluster >=0 && p.cluster < K){\n          sums[p.cluster].x += p.x;\n          sums[p.cluster].y += p.y;\n          sums[p.cluster].count++;\n        }\n      }\n      let empty = 0;\n      for(let i=0;i<K;i++){\n        if (sums[i].count === 0){\n          // empty cluster: reinitialize to random point (strategy)\n          centroids[i] = {...points[Math.floor(Math.random()*points.length)] || {x: Math.random(), y: Math.random()}};\n          empty++;\n        } else {\n          centroids[i].x = sums[i].x / sums[i].count;\n          centroids[i].y = sums[i].y / sums[i].count;\n        }\n      }\n      return empty;\n    }\n\n    function computeSSE(){\n      let sse = 0;\n      for(const p of points){\n        if (p.cluster >= 0 && centroids[p.cluster]){\n          const dx = p.x - centroids[p.cluster].x;\n          const dy = p.y - centroids[p.cluster].y;\n          sse += dx*dx + dy*dy;\n        }\n      }\n      return sse;\n    }\n\n    // One K-means iteration: assign then update\n    function kmeansStep(){\n      if (centroids.length === 0) return {changed:0, empty:0, sse:0};\n      const changed = assignPoints();\n      const empty = updateCentroids();\n      const sse = computeSSE();\n      iteration++;\n      updateStats(changed, empty, sse);\n      return {changed, empty, sse};\n    }\n\n    // Run until convergence or maxSteps\n    function runUntilConverged(maxSteps=1000){\n      if (centroids.length === 0) return;\n      let steps = 0;\n      while(steps < maxSteps){\n        const {changed} = kmeansStep();\n        steps++;\n        if (changed === 0) break;\n      }\n    }\n\n    // Draw functions\n    function draw(){\n      // Clear\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n      // Background grid\n      ctx.fillStyle = '#fff';\n      ctx.fillRect(0,0,canvas.width,canvas.height);\n\n      // Draw border/margins\n      ctx.strokeStyle = 'rgba(20,30,60,0.04)';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);\n\n      // Draw points grouped by cluster to color them\n      // Draw lines from points to centroid (optional subtle)\n      for(const p of points){\n        const c = toCanvas(p);\n        const color = (p.cluster >= 0 && centroids[p.cluster]) ? colorFor(p.cluster, centroids.length) : '#d6d8e6';\n        // optional line to centroid\n        if (p.cluster >= 0 && centroids[p.cluster]){\n          const cc = toCanvas(centroids[p.cluster]);\n          ctx.strokeStyle = hexToRgba(color, 0.06);\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          ctx.moveTo(c.cx, c.cy);\n          ctx.lineTo(cc.cx, cc.cy);\n          ctx.stroke();\n        }\n        // point\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.arc(c.cx, c.cy, 4, 0, Math.PI*2);\n        ctx.fill();\n        // outline\n        ctx.strokeStyle = 'rgba(255,255,255,0.6)';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n      }\n\n      // Draw centroids on top\n      for(let i=0;i<centroids.length;i++){\n        const c = toCanvas(centroids[i]);\n        const color = colorFor(i, centroids.length);\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(c.cx, c.cy, 10, 0, Math.PI*2);\n        ctx.fill();\n        // square inside\n        ctx.fillStyle = color;\n        roundRect(ctx, c.cx-9, c.cy-9, 18, 18, 4, true, false);\n        // border\n        ctx.strokeStyle = hexToRgba(color, 0.6);\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n      // Axes or border labels\n      ctx.fillStyle = '#444';\n      ctx.font = '12px sans-serif';\n      ctx.fillText('X', canvas.width - 18, canvas.height - 8);\n      ctx.fillText('Y', 8, 14);\n    }\n\n    // Drawing helpers\n    function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n      if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};\n      ctx.beginPath();\n      ctx.moveTo(x + r.tl, y);\n      ctx.lineTo(x + w - r.tr, y);\n      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);\n      ctx.lineTo(x + w, y + h - r.br);\n      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);\n      ctx.lineTo(x + r.bl, y + h);\n      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);\n      ctx.lineTo(x, y + r.tl);\n      ctx.quadraticCurveTo(x, y, x + r.tl, y);\n      if (fill) ctx.fill();\n      if (stroke) ctx.stroke();\n    }\n\n    function hexToRgba(hex, alpha){\n      // hex like #rrggbb\n      const h = hex.replace('#','');\n      const bigint = parseInt(h,16);\n      const r = (bigint >> 16) & 255;\n      const g = (bigint >> 8) & 255;\n      const b = bigint & 255;\n      return `rgba(${r},${g},${b},${alpha})`;\n    }\n\n    // UI update functions\n    function updateStats(changed = null, empty = null, sse = null){\n      iterElem.textContent = iteration;\n      changedElem.textContent = (changed === null ? '—' : changed);\n      sseElem.textContent = (sse === null ? '—' : sse.toFixed(4));\n      emptyElem.textContent = (empty === null ? '—' : empty);\n      renderLegend();\n    }\n\n    function renderLegend(){\n      legend.innerHTML = '';\n      const K = centroids.length;\n      const counts = Array(K).fill(0);\n      for(const p of points) if (p.cluster >=0 && p.cluster < K) counts[p.cluster]++;\n      for(let i=0;i<K;i++){\n        const item = document.createElement('div');\n        item.className = 'legend-item';\n        const sw = document.createElement('div');\n        sw.className = 'swatch';\n        sw.style.background = colorFor(i, K);\n        item.appendChild(sw);\n        const txt = document.createElement('div');\n        txt.textContent = `C${i} (${counts[i]||0})`;\n        txt.style.minWidth = '56px';\n        txt.style.fontSize = '12px';\n        item.appendChild(txt);\n        legend.appendChild(item);\n      }\n    }\n\n    // Control handlers\n    nPointsInput.addEventListener('input', () => {\n      nPointsVal.textContent = nPointsInput.value;\n    });\n    kInput.addEventListener('input', () => {\n      kVal.textContent = kInput.value;\n    });\n    speedInput.addEventListener('input', () => {\n      speedVal.textContent = speedInput.value;\n      animationDelay = Number(speedInput.value);\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = setInterval(stepAndDraw, animationDelay);\n      }\n    });\n\n    initBtn.addEventListener('click', () => {\n      initializeCentroids();\n      draw();\n    });\n\n    stepBtn.addEventListener('click', () => {\n      stepAndDraw();\n    });\n\n    runBtn.addEventListener('click', () => {\n      if (intervalId) return;\n      intervalId = setInterval(stepAndDraw, animationDelay);\n      runBtn.disabled = true;\n      stopBtn.disabled = false;\n    });\n\n    stopBtn.addEventListener('click', () => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n      }\n      runBtn.disabled = false;\n      stopBtn.disabled = true;\n    });\n\n    randomBtn.addEventListener('click', () => {\n      generateData(Number(nPointsInput.value));\n      centroids = [];\n      iteration = 0;\n      updateStats();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      points = [];\n      centroids = [];\n      iteration = 0;\n      updateStats();\n      draw();\n    });\n\n    resetBtn.addEventListener('click', () => {\n      // Reset everything to defaults\n      nPointsInput.value = 150;\n      kInput.value = 4;\n      speedInput.value = 250;\n      initSelect.value = 'kmeans++';\n      nPointsVal.textContent = nPointsInput.value;\n      kVal.textContent = kInput.value;\n      speedVal.textContent = speedInput.value;\n      generateData(Number(nPointsInput.value));\n      centroids = [];\n      iteration = 0;\n      updateStats();\n      draw();\n    });\n\n    // Initialization (centroids)\n    function initializeCentroids(){\n      const K = Math.max(1, Math.min(points.length || 1, Number(kInput.value)));\n      if (initSelect.value === 'kmeans++'){\n        kmeansPlusPlusInit(K);\n      } else {\n        randomInit(K);\n      }\n      // assign once to start\n      lastAssignments = null;\n      iteration = 0;\n      const changed = assignPoints();\n      const empty = updateCentroids();\n      const sse = computeSSE();\n      updateStats(changed, empty, sse);\n      draw();\n    }\n\n    // Step and draw: one K-means iteration and redraw\n    function stepAndDraw(){\n      if (centroids.length === 0){\n        initializeCentroids();\n        return;\n      }\n      const {changed, empty, sse} = kmeansStep();\n      draw();\n      if (changed === 0){\n        // converged: stop if running\n        if (intervalId){\n          clearInterval(intervalId);\n          intervalId = null;\n          runBtn.disabled = false;\n          stopBtn.disabled = true;\n        }\n      }\n    }\n\n    // Mouse interaction: add points, drag points\n    canvas.addEventListener('mousedown', (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);\n      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);\n      if (addToggle.checked){\n        const p = fromCanvas(cx, cy);\n        points.push({x:p.x,y:p.y,cluster:-1});\n        draw();\n        updateStats();\n        return;\n      }\n      if (dragToggle.checked){\n        // find closest point within threshold\n        let best = null;\n        let bestDist = 12;\n        for(const p of points){\n          const c = toCanvas(p);\n          const dx = c.cx - cx, dy = c.cy - cy;\n          const d = Math.sqrt(dx*dx+dy*dy);\n          if (d < bestDist){\n            bestDist = d;\n            best = p;\n          }\n        }\n        if (best){\n          draggingPoint = best;\n          const cp = toCanvas(best);\n          dragOffset.x = cp.cx - cx;\n          dragOffset.y = cp.cy - cy;\n        }\n      }\n    });\n\n    window.addEventListener('mousemove', (e) => {\n      if (!draggingPoint) return;\n      const rect = canvas.getBoundingClientRect();\n      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);\n      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);\n      const p = fromCanvas(cx + dragOffset.x, cy + dragOffset.y);\n      draggingPoint.x = p.x;\n      draggingPoint.y = p.y;\n      // moving points invalidates clustering assignments\n      // optionally, keep cluster but better to set to -1 so next step recomputes\n      // we choose to keep cluster but update drawing\n      draw();\n    });\n\n    window.addEventListener('mouseup', (e) => {\n      if (draggingPoint) {\n        draggingPoint = null;\n      }\n    });\n\n    // Double-click to remove nearest point\n    canvas.addEventListener('dblclick', (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);\n      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);\n      let bestIdx = -1;\n      let bestD = 12;\n      for(let i=0;i<points.length;i++){\n        const p = points[i];\n        const c = toCanvas(p);\n        const dx = c.cx - cx, dy = c.cy - cy;\n        const d = Math.sqrt(dx*dx+dy*dy);\n        if (d < bestD){ bestD = d; bestIdx = i; }\n      }\n      if (bestIdx >= 0) {\n        points.splice(bestIdx, 1);\n        draw();\n        updateStats();\n      }\n    });\n\n    // Responsive canvas actual pixel ratio\n    function fixCanvasSize(){\n      const ratio = window.devicePixelRatio || 1;\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = Math.round(rect.width * ratio);\n      canvas.height = Math.round(rect.height * ratio);\n      ctx.setTransform(ratio,0,0,ratio,0,0);\n      draw();\n    }\n    window.addEventListener('resize', fixCanvasSize);\n\n    // Initial setup\n    function init(){\n      nPointsVal.textContent = nPointsInput.value;\n      kVal.textContent = kInput.value;\n      speedVal.textContent = speedInput.value;\n      animationDelay = Number(speedInput.value);\n      generateData(Number(nPointsInput.value));\n      renderLegend();\n      fixCanvasSize();\n    }\n\n    // Keyboard shortcuts\n    window.addEventListener('keydown', (e) => {\n      if (e.key === ' ') { e.preventDefault(); stepAndDraw(); }\n      if (e.key === 'r') { generateData(Number(nPointsInput.value)); draw(); }\n    });\n\n    // Generate a palette legend initially (empty if no centroids)\n    function renderInitialLegend(){\n      legend.innerHTML = '';\n      const K = Number(kInput.value);\n      for(let i=0;i<K;i++){\n        const item = document.createElement('div');\n        item.className = 'legend-item';\n        const sw = document.createElement('div');\n        sw.className = 'swatch';\n        sw.style.background = colorFor(i, K);\n        item.appendChild(sw);\n        const txt = document.createElement('div');\n        txt.textContent = `C${i}`;\n        txt.style.fontSize = '12px';\n        item.appendChild(txt);\n        legend.appendChild(item);\n      }\n    }\n\n    // Run init\n    init();\n    renderInitialLegend();\n\n    // Expose some functions for console (debug)\n    window._kmeansDemo = {\n      points, centroids, step: stepAndDraw, init: initializeCentroids, run: () => {\n        if (!intervalId) { intervalId = setInterval(stepAndDraw, animationDelay); runBtn.disabled = true; stopBtn.disabled = false; }\n      }, stop: () => { if (intervalId){ clearInterval(intervalId); intervalId=null; runBtn.disabled=false; stopBtn.disabled=true; } }\n    };\n\n  })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}