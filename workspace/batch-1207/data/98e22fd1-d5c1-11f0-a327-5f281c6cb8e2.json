{
  "id": "98e22fd1-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:38.050Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Depth-First Search (DFS) Visualizer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --muted:#94a3b8;\n    --accent:#06b6d4;\n    --accent-2:#7c3aed;\n    --card:#0b1116;\n    --good:#10b981;\n    --warn:#f59e0b;\n    --danger:#ef4444;\n    --node-size:36px;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;color:var(--muted);background:linear-gradient(180deg,#021124 0%, #071022 40%);}\n  .app{display:flex;gap:12px;padding:18px;box-sizing:border-box;height:100%;}\n  .controls{width:360px;min-width:300px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(2,6,23,0.6);}\n  .controls h2{margin:6px 0 12px;color:#dbeafe;font-size:18px;}\n  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}\n  label{font-size:13px;color:var(--muted);min-width:110px;}\n  input[type=\"number\"], select, textarea{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:6px;font-size:13px;outline:none;width:100%;}\n  input[type=\"range\"]{width:160px;}\n  button{background:linear-gradient(180deg,var(--accent),#0891b2);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;}\n  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-weight:600;}\n  .canvas{flex:1;min-width:400px;background:linear-gradient(180deg,#031126 0%, #071029 100%);border-radius:12px;padding:12px;display:flex;flex-direction:column;}\n  .svg-wrap{flex:1;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));position:relative;overflow:hidden;}\n  svg{width:100%;height:100%;}\n  .bottom-controls{display:flex;gap:8px;align-items:center;margin-top:10px;}\n  .small{font-size:13px;color:var(--muted);}\n  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}\n  .legend .item{display:flex;gap:8px;align-items:center;padding:6px 8px;background:rgba(255,255,255,0.02);border-radius:6px;font-size:13px;}\n  .node{cursor:pointer;stroke:#071428;stroke-width:2px;}\n  .node.unvisited{fill:#0b1220;stroke:#19303b;}\n  .node.discovered{fill:#ffb020;stroke:#663c00;}\n  .node.current{fill:#06b6d4;stroke:#02323a;}\n  .node.finished{fill:#10b981;stroke:#064f3b;}\n  .label{font-size:12px;fill:#e6f0ff;pointer-events:none;font-weight:600;}\n  .edge{stroke:rgba(255,255,255,0.08);stroke-width:2;stroke-linecap:round;}\n  .edge.highlight{stroke:#ef4444;stroke-width:3;opacity:0.95;}\n  .edge.tree{stroke:#7c3aed;stroke-width:3;opacity:0.9;}\n  .panel{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;margin-top:8px;font-size:13px;}\n  .stack-list{display:flex;flex-direction:column;gap:6px;}\n  .stack-item{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:6px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}\n  .times{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;}\n  .time-badge{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;color:var(--muted);min-width:62px;text-align:center;}\n  .footer-note{color:var(--muted);font-size:12px;margin-top:8px;}\n  .controls .muted{font-size:13px;color:var(--muted);margin-bottom:6px;}\n  .flex{display:flex;gap:8px;align-items:center;}\n  input[type=\"text\"]{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted);}\n  .row-buttons{display:flex;gap:8px;flex-wrap:wrap;}\n  .big-btn{padding:10px 14px;border-radius:8px;font-weight:700;}\n  .status{font-weight:700;color:#c7f9ff;}\n  .info-line{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;}\n  .hint{color:#9fb6cc;font-size:12px}\n  textarea{height:70px;}\n  .adj-label{font-size:12px;color:#cbd5e1}\n  .credits{font-size:12px;color:var(--muted);margin-top:6px}\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"controls\">\n    <h2>DFS Visualizer</h2>\n    <div class=\"info-line\">\n      <div class=\"muted\">Algorithm</div>\n      <div>\n        <select id=\"algo\">\n          <option value=\"recursive\">Recursive DFS</option>\n          <option value=\"iterative\">Iterative (stack) DFS</option>\n        </select>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Nodes</label>\n      <input id=\"nodeCount\" type=\"number\" min=\"3\" max=\"32\" value=\"9\"/>\n    </div>\n    <div class=\"row\">\n      <label>Density</label>\n      <input id=\"density\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" value=\"0.25\"/>\n      <div class=\"small\" id=\"densityLabel\">0.25</div>\n    </div>\n\n    <div class=\"row\">\n      <label>Start node</label>\n      <select id=\"startNode\"></select>\n    </div>\n\n    <div class=\"row\">\n      <label>Graph</label>\n      <div style=\"flex:1;display:flex;gap:8px;\">\n        <button id=\"gen\" class=\"big-btn\">Generate</button>\n        <button id=\"randomize\" class=\"ghost\">Randomize</button>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Adjacency (optional)</label>\n      <textarea id=\"adjInput\" placeholder=\"Optional custom adjacency list: one line per node: neighbors separated by spaces&#10;e.g.&#10;1 2&#10;0 3&#10;...\"></textarea>\n    </div>\n\n    <div class=\"row\">\n      <label>Controls</label>\n      <div class=\"row-buttons\" style=\"flex:1;\">\n        <button id=\"run\" class=\"big-btn\">Run</button>\n        <button id=\"step\" class=\"ghost\">Step</button>\n        <button id=\"play\" class=\"ghost\">Play</button>\n        <button id=\"reset\" class=\"ghost\">Reset</button>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Speed</label>\n      <input id=\"speed\" type=\"range\" min=\"50\" max=\"2000\" step=\"50\" value=\"650\"/>\n      <div class=\"small\" id=\"speedLabel\">650 ms</div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div style=\"font-weight:700;color:#e6f0ff\">Runtime</div>\n        <div class=\"small muted\">Current step: <span id=\"stepCounter\">0</span>/<span id=\"totalSteps\">0</span></div>\n      </div>\n\n      <div style=\"display:flex;gap:12px;margin-top:8px;\">\n        <div style=\"flex:1\">\n          <div class=\"small muted\">Call stack / Stack (top on right)</div>\n          <div id=\"stackBox\" class=\"stack-list\" style=\"margin-top:8px;\"></div>\n        </div>\n        <div style=\"flex:1\">\n          <div class=\"small muted\">Visited order</div>\n          <div id=\"visitedOrder\" class=\"panel\" style=\"margin-top:8px;min-height:42px\"></div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <div class=\"small muted\">Discovery / Finish times</div>\n        <div id=\"timesBox\" class=\"times\"></div>\n      </div>\n\n      <div class=\"footer-note\">Click a node in the canvas to set start node. Edges are undirected. Use the adjacency textarea to provide an exact graph.</div>\n    </div>\n\n    <div class=\"credits\">Built for learning — shows both recursive and iterative DFS with step-by-step state snapshots.</div>\n  </div>\n\n  <div class=\"canvas\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <div style=\"font-weight:800;color:#e6f0ff\">Graph canvas</div>\n        <div class=\"small muted\">(click nodes to choose start)</div>\n      </div>\n      <div style=\"display:flex;gap:10px;align-items:center;\">\n        <div class=\"legend\">\n          <div class=\"item\"><div style=\"width:12px;height:12px;background:#0b1220;border-radius:3px;border:1px solid #19303b\"></div> unvisited</div>\n          <div class=\"item\"><div style=\"width:12px;height:12px;background:#ffb020;border-radius:3px\"></div> discovered</div>\n          <div class=\"item\"><div style=\"width:12px;height:12px;background:#06b6d4;border-radius:3px\"></div> current</div>\n          <div class=\"item\"><div style=\"width:12px;height:12px;background:#10b981;border-radius:3px\"></div> finished</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"svg-wrap\" id=\"svgWrap\">\n      <svg id=\"svgCanvas\" viewBox=\"0 0 900 640\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n\n    <div class=\"bottom-controls\">\n      <div class=\"small muted\">Highlighted edge: <span id=\"edgeLabel\">—</span></div>\n      <div style=\"flex:1\"></div>\n      <div class=\"small muted\">Algorithm: <span id=\"algoLabel\"></span></div>\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  // Utility helpers\n  const $ = (s,el=document) => el.querySelector(s);\n  const $$ = (s,el=document) => Array.from(el.querySelectorAll(s));\n\n  // Elements\n  const svg = $('#svgCanvas');\n  const nodeCountInput = $('#nodeCount');\n  const densityInput = $('#density');\n  const densityLabel = $('#densityLabel');\n  const genBtn = $('#gen');\n  const randomizeBtn = $('#randomize');\n  const startSelect = $('#startNode');\n  const adjInput = $('#adjInput');\n  const runBtn = $('#run');\n  const stepBtn = $('#step');\n  const playBtn = $('#play');\n  const resetBtn = $('#reset');\n  const algoSelect = $('#algo');\n  const algoLabel = $('#algoLabel');\n  const speedInput = $('#speed');\n  const speedLabel = $('#speedLabel');\n  const stackBox = $('#stackBox');\n  const visitedOrder = $('#visitedOrder');\n  const timesBox = $('#timesBox');\n  const stepCounter = $('#stepCounter');\n  const totalSteps = $('#totalSteps');\n  const edgeLabel = $('#edgeLabel');\n\n  // State\n  let nodes = []; // {id,x,y}\n  let edges = []; // {u,v,svgLine,svgGroup}\n  let adj = []; // adjacency list: array of arrays\n  let snapshots = []; // array of states for animation\n  let playing = false;\n  let playTimer = null;\n  let curStep = 0;\n  let discovery = [];\n  let finish = [];\n\n  // Config\n  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}\n\n  // Initial\n  densityLabel.textContent = densityInput.value;\n  speedLabel.textContent = speedInput.value + ' ms';\n  algoLabel.textContent = algoSelect.value === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';\n\n  // SVG helpers\n  function clearSVG(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function drawGraph(){\n    clearSVG();\n    // edges behind nodes\n    edges.forEach(e=>{\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('class','edge');\n      line.setAttribute('x1', nodes[e.u].x);\n      line.setAttribute('y1', nodes[e.u].y);\n      line.setAttribute('x2', nodes[e.v].x);\n      line.setAttribute('y2', nodes[e.v].y);\n      g.appendChild(line);\n      svg.appendChild(g);\n      e.svgLine = line;\n      e.svgGroup = g;\n    });\n\n    // node circles and labels\n    nodes.forEach(n=>{\n      const group = document.createElementNS('http://www.w3.org/2000/svg','g');\n      group.setAttribute('data-id', n.id);\n      group.style.cursor = 'pointer';\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('class','node unvisited');\n      circle.setAttribute('r', 18);\n      circle.setAttribute('cx', n.x);\n      circle.setAttribute('cy', n.y);\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('class','label');\n      text.setAttribute('x', n.x);\n      text.setAttribute('y', n.y+4);\n      text.setAttribute('text-anchor','middle');\n      text.textContent = String(n.id);\n      group.appendChild(circle);\n      group.appendChild(text);\n      svg.appendChild(group);\n\n      group.addEventListener('click', (ev)=>{\n        ev.stopPropagation();\n        setStartNode(n.id);\n      });\n\n      n.svg = {group, circle, text};\n    });\n\n    // allow clicking background to clear start selection\n    svg.addEventListener('click', (ev)=>{/*placeholder*/});\n  }\n\n  function setStartNode(id){\n    startSelect.value = id;\n    highlightStartSelect();\n  }\n\n  // Graph generation\n  function genNodes(n){\n    const cx = 450, cy = 300;\n    const radius = Math.min(260, 32*n);\n    nodes = [];\n    for(let i=0;i<n;i++){\n      const angle = (i/n) * Math.PI*2 - Math.PI/2;\n      const x = cx + Math.cos(angle)*(radius + (Math.random()*40-20));\n      const y = cy + Math.sin(angle)*(radius + (Math.random()*40-20));\n      nodes.push({id:i,x,y});\n    }\n  }\n\n  // edges helper: add undirected edge if not exists\n  function addEdge(edgesArr,u,v){\n    if(u===v) return;\n    const key = (a,b)=> a<b? a+'-'+b : b+'-'+a;\n    const present = edgesArr.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));\n    if(!present) edgesArr.push({u,v});\n  }\n\n  function genEdgesByDensity(n, density){\n    const e = [];\n    // ensure connectivity by creating a chain first\n    for(let i=1;i<n;i++){\n      addEdge(e,i-1, i);\n    }\n    // add random edges\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < density){\n          addEdge(e,i,j);\n        }\n      }\n    }\n    return e;\n  }\n\n  function buildAdjFromEdges(edgesList, n){\n    const A = Array.from({length:n}, ()=>[]);\n    edgesList.forEach(e=>{\n      A[e.u].push(e.v);\n      A[e.v].push(e.u);\n    });\n    // sort neighbors for deterministic behavior\n    A.forEach(arr => arr.sort((a,b)=>a-b));\n    return A;\n  }\n\n  function parseAdjInput(txt){\n    const lines = txt.trim().split(/\\n+/).map(s=>s.trim());\n    if(lines.length===0 || lines.length < Number(nodeCountInput.value)) return null;\n    const parsed = lines.map((line,idx)=>{\n      if(!line) return [];\n      return line.split(/[\\s,]+/).map(x=>Number(x)).filter(x=>!isNaN(x));\n    });\n    // check valid\n    for(let i=0;i<parsed.length;i++){\n      if(!Array.isArray(parsed[i])) return null;\n      parsed[i].forEach(v=>{\n        if(v<0 || v>=parsed.length) throw new Error('Adjacency contains out-of-range node: ' + v);\n      });\n    }\n    // build edges from it\n    const edgesList = [];\n    parsed.forEach((nbrs,i)=>{\n      nbrs.forEach(j=> { if(i<j) edgesList.push({u:i,v:j}); });\n    });\n    return {adj:parsed, edges:edgesList};\n  }\n\n  function generateGraph(){\n    const n = clamp(Number(nodeCountInput.value)||9, 3, 32);\n    genNodes(n);\n\n    const adjTxt = adjInput.value.trim();\n    if(adjTxt){\n      try {\n        const res = parseAdjInput(adjTxt);\n        if(res){\n          adj = res.adj;\n          // ensure position array length matches\n          if(nodes.length !== adj.length){\n            // adjust nodes count to match adjacency length\n            nodeCountInput.value = adj.length;\n            genNodes(adj.length);\n          }\n          edges = res.edges.slice();\n        } else {\n          // fallback to random generation\n          edges = genEdgesByDensity(n, Number(densityInput.value));\n          adj = buildAdjFromEdges(edges,n);\n        }\n      } catch(err){\n        alert('Adjacency parse error: ' + err.message);\n        edges = genEdgesByDensity(n, Number(densityInput.value));\n        adj = buildAdjFromEdges(edges,n);\n      }\n    } else {\n      edges = genEdgesByDensity(n, Number(densityInput.value));\n      adj = buildAdjFromEdges(edges,n);\n    }\n\n    // Draw and populate start select\n    drawGraph();\n    populateStartSelect();\n    resetAnimationState();\n  }\n\n  function populateStartSelect(){\n    startSelect.innerHTML = '';\n    nodes.forEach(n=>{\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = 'Node ' + n.id;\n      startSelect.appendChild(opt);\n    });\n    // default to 0\n    startSelect.value = nodes.length? nodes[0].id : 0;\n    highlightStartSelect();\n  }\n\n  function highlightStartSelect(){\n    // highlight the chosen start node visually (outline)\n    nodes.forEach(n=>{\n      n.svg.circle.style.filter = '';\n      if(String(n.id) === String(startSelect.value)){\n        n.svg.circle.style.stroke = '#ffff';\n        n.svg.circle.style.strokeWidth = 2.5;\n      } else {\n        n.svg.circle.style.strokeWidth = 2;\n        n.svg.circle.style.stroke = ''; // CSS will handle default\n      }\n    });\n  }\n\n  // Snapshot model:\n  // { visited: Array(boolean), discoveredTimes: Array|null or number, finishTimes: Array|null, callStack: Array, iterStack: Array, highlightedEdge: [u,v] or null, event: string }\n  function pushSnapshot(state){\n    // deep-ish copy of arrays for safety\n    snapshots.push({\n      visited: state.visited.slice(),\n      discoveredTimes: state.discoveredTimes.slice(),\n      finishTimes: state.finishTimes.slice(),\n      callStack: state.callStack.slice(),\n      iterStack: state.iterStack ? state.iterStack.map(x=>Object.assign({},x)) : null,\n      highlightedEdge: state.highlightedEdge ? state.highlightedEdge.slice() : null,\n      event: state.event || ''\n    });\n  }\n\n  // DFS implementations that generate snapshots (do not animate directly)\n  function generateRecursiveDFS(start){\n    const n = nodes.length;\n    const visited = Array(n).fill(false);\n    const discoveredTimes = Array(n).fill(null);\n    const finishTimes = Array(n).fill(null);\n    let time = 0;\n    const callStack = [];\n    const state = {visited, discoveredTimes, finishTimes, callStack, iterStack:null, highlightedEdge:null, event:''};\n    snapshots = [];\n\n    function dfs(u, parentEdge){\n      // push call\n      callStack.push(u);\n      state.event = 'call ' + u;\n      state.highlightedEdge = parentEdge ? [parentEdge[0],parentEdge[1]] : null;\n      pushSnapshot(state);\n\n      if(!visited[u]){\n        visited[u] = true;\n        discoveredTimes[u] = ++time;\n        state.event = 'discover ' + u;\n        state.highlightedEdge = parentEdge ? [parentEdge[0],parentEdge[1]] : null;\n        pushSnapshot(state);\n      }\n\n      for(const v of adj[u]){\n        state.event = 'check edge ' + u + '→' + v;\n        state.highlightedEdge = [u,v];\n        pushSnapshot(state);\n        if(!visited[v]){\n          // record tree edge\n          state.event = 'tree edge ' + u + '→' + v;\n          state.highlightedEdge = [u,v];\n          pushSnapshot(state);\n          dfs(v, [u,v]);\n          // after return snapshot\n          state.event = 'back to ' + u;\n          state.highlightedEdge = [u,v];\n          pushSnapshot(state);\n        } else {\n          state.event = 'skip visited ' + v;\n          pushSnapshot(state);\n        }\n      }\n\n      // finish\n      finishTimes[u] = ++time;\n      state.event = 'finish ' + u;\n      state.highlightedEdge = null;\n      pushSnapshot(state);\n      callStack.pop();\n      state.event = 'return ' + u;\n      pushSnapshot(state);\n    }\n\n    dfs(start, null);\n\n    return {snapshots, discoveredTimes, finishTimes};\n  }\n\n  function generateIterativeDFS(start){\n    const n = nodes.length;\n    const visited = Array(n).fill(false);\n    const discoveredTimes = Array(n).fill(null);\n    const finishTimes = Array(n).fill(null);\n    let time = 0;\n    const iterStack = []; // frames: {node, nextIndex, parent}\n    const state = {visited, discoveredTimes, finishTimes, callStack: [], iterStack, highlightedEdge:null, event:''};\n    snapshots = [];\n\n    // push initial frame\n    iterStack.push({node:start, nextIndex:0, parent:null});\n    state.event='push '+start;\n    state.highlightedEdge=null;\n    pushSnapshot(state);\n\n    while(iterStack.length){\n      const frame = iterStack[iterStack.length-1];\n      const u = frame.node;\n      if(!visited[u]){\n        visited[u] = true;\n        discoveredTimes[u] = ++time;\n        state.event = 'discover ' + u;\n        pushSnapshot(state);\n      }\n      if(frame.nextIndex < adj[u].length){\n        const v = adj[u][frame.nextIndex];\n        frame.nextIndex++;\n        state.highlightedEdge = [u,v];\n        state.event = 'check edge ' + u + '→' + v;\n        pushSnapshot(state);\n        if(!visited[v]){\n          state.event = 'tree edge push ' + v;\n          iterStack.push({node:v,nextIndex:0,parent:u});\n          pushSnapshot(state);\n        } else {\n          state.event = 'skip visited ' + v;\n          pushSnapshot(state);\n        }\n      } else {\n        // all neighbors processed\n        finishTimes[u] = ++time;\n        state.event = 'finish ' + u;\n        state.highlightedEdge = null;\n        pushSnapshot(state);\n        iterStack.pop();\n        state.event = 'pop ' + u;\n        pushSnapshot(state);\n      }\n    }\n    return {snapshots, discoveredTimes, finishTimes};\n  }\n\n  // Animation / UI update\n  function applySnapshot(idx){\n    if(idx < 0) idx = 0;\n    if(idx >= snapshots.length) idx = snapshots.length-1;\n    const s = snapshots[idx];\n    // update nodes styling\n    s.visited.forEach((v,i)=>{\n      const c = nodes[i].svg.circle;\n      c.classList.remove('unvisited','discovered','current','finished');\n      if(s.finishTimes[i] !== null){\n        c.classList.add('finished');\n      } else if(s.visited[i]){\n        // currently discovered but maybe current\n        if(s.callStack && s.callStack.length && Number(s.callStack[s.callStack.length-1]) === i){\n          c.classList.add('current');\n        } else if(s.iterStack && s.iterStack.length && Number(s.iterStack[s.iterStack.length-1].node) === i){\n          c.classList.add('current');\n        } else {\n          c.classList.add('discovered');\n        }\n      } else {\n        c.classList.add('unvisited');\n      }\n    });\n\n    // update edges styling\n    edges.forEach(e=>{\n      e.svgLine.classList.remove('highlight','tree');\n      if(s.highlightedEdge){\n        const [a,b] = s.highlightedEdge;\n        if( (e.u===a && e.v===b) || (e.u===b && e.v===a) ){\n          e.svgLine.classList.add('highlight');\n        }\n      }\n    });\n\n    // show stack / callStack\n    stackBox.innerHTML = '';\n    const stackArr = (s.iterStack && s.iterStack.length) ? s.iterStack.map(f=>String(f.node)) : s.callStack;\n    if(stackArr && stackArr.length){\n      // display items, left to right with top at right\n      const frag = document.createDocumentFragment();\n      for(let i=0;i<stackArr.length;i++){\n        const div = document.createElement('div');\n        div.className = 'stack-item';\n        div.textContent = 'Node ' + stackArr[i];\n        frag.appendChild(div);\n      }\n      stackBox.appendChild(frag);\n    } else {\n      stackBox.innerHTML = '<div class=\"stack-item\" style=\"opacity:0.6\">Empty</div>';\n    }\n\n    // visited order\n    visitedOrder.innerHTML = '';\n    const visitedList = [];\n    for(let i=0;i<s.discoveredTimes.length;i++){\n      if(s.discoveredTimes[i] !== null) visitedList.push({id:i,t:s.discoveredTimes[i]});\n    }\n    visitedList.sort((a,b)=>a.t-b.t);\n    if(visitedList.length){\n      visitedList.forEach(it=>{\n        const d = document.createElement('div');\n        d.className = 'small';\n        d.style.padding='4px';\n        d.textContent = `Node ${it.id} (d=${it.t})`;\n        visitedOrder.appendChild(d);\n      });\n    } else {\n      visitedOrder.textContent = '';\n    }\n\n    // times grid\n    timesBox.innerHTML = '';\n    for(let i=0;i<s.discoveredTimes.length;i++){\n      const div = document.createElement('div');\n      div.className = 'time-badge';\n      div.innerHTML = `<div style=\"font-weight:700;color:#cfefff\">#${i}</div><div style=\"font-size:12px\">d:${s.discoveredTimes[i]??'–'} f:${s.finishTimes[i]??'–'}</div>`;\n      timesBox.appendChild(div);\n    }\n\n    // edge label and counters\n    edgeLabel.textContent = s.highlightedEdge ? `${s.highlightedEdge[0]} → ${s.highlightedEdge[1]}` : '—';\n    stepCounter.textContent = idx;\n    totalSteps.textContent = snapshots.length-1;\n  }\n\n  function resetAnimationState(){\n    snapshots = [];\n    curStep = 0;\n    playing = false;\n    if(playTimer) { clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play'; }\n    // reset node styles\n    nodes.forEach(n=>{\n      n.svg.circle.classList.remove('discovered','finished','current');\n      n.svg.circle.classList.add('unvisited');\n    });\n    edges.forEach(e=> e.svgLine.classList.remove('highlight','tree'));\n    visitedOrder.innerHTML = '';\n    stackBox.innerHTML = '<div class=\"stack-item\" style=\"opacity:0.6\">Empty</div>';\n    timesBox.innerHTML = '';\n    stepCounter.textContent = '0';\n    totalSteps.textContent = '0';\n    edgeLabel.textContent = '—';\n  }\n\n  function prepareAndRun(){\n    // produce snapshots using chosen algorithm and starting node\n    resetAnimationState();\n    const start = Number(startSelect.value);\n    if(isNaN(start) || start < 0 || start >= nodes.length){ alert('Invalid start node'); return; }\n    if(algoSelect.value === 'recursive'){\n      const res = generateRecursiveDFS(start);\n      snapshots = res.snapshots;\n    } else {\n      const res = generateIterativeDFS(start);\n      snapshots = res.snapshots;\n    }\n    // ensure there is at least one snapshot to show (even empty)\n    if(snapshots.length === 0) snapshots.push({\n      visited:Array(nodes.length).fill(false),\n      discoveredTimes:Array(nodes.length).fill(null),\n      finishTimes:Array(nodes.length).fill(null),\n      callStack:[],\n      iterStack:null,\n      highlightedEdge:null,\n      event:'init'\n    });\n    // step counters start at 0 meaning before any step; we'll show snapshot[0] for step 0\n    curStep = 0;\n    applySnapshot(curStep);\n  }\n\n  function doStep(){\n    if(snapshots.length === 0) return;\n    if(curStep < snapshots.length-1){\n      curStep++;\n      applySnapshot(curStep);\n    }\n  }\n\n  function doPlay(){\n    if(playing){\n      playing = false;\n      playBtn.textContent = 'Play';\n      if(playTimer){ clearInterval(playTimer); playTimer = null; }\n    } else {\n      playing = true;\n      playBtn.textContent = 'Pause';\n      const delay = Number(speedInput.value);\n      playTimer = setInterval(()=>{\n        if(curStep < snapshots.length-1){\n          curStep++;\n          applySnapshot(curStep);\n        } else {\n          // end\n          playing = false;\n          playBtn.textContent = 'Play';\n          clearInterval(playTimer);\n          playTimer = null;\n        }\n      }, delay);\n    }\n  }\n\n  // Event wiring\n  genBtn.addEventListener('click', ()=>{\n    generateGraph();\n  });\n\n  randomizeBtn.addEventListener('click', ()=>{\n    // slight randomization but keep node count\n    densityInput.value = (Math.random()*0.6 + 0.05).toFixed(2);\n    densityLabel.textContent = densityInput.value;\n    generateGraph();\n  });\n\n  densityInput.addEventListener('input', ()=>{\n    densityLabel.textContent = densityInput.value;\n  });\n\n  nodeCountInput.addEventListener('change', ()=>{\n    nodeCountInput.value = clamp(Number(nodeCountInput.value)||9, 3, 32);\n  });\n\n  startSelect.addEventListener('change', highlightStartSelect);\n\n  algoSelect.addEventListener('change', ()=>{\n    algoLabel.textContent = algoSelect.value === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    prepareAndRun();\n    // jump to last step\n    if(snapshots.length) {\n      curStep = snapshots.length-1;\n      applySnapshot(curStep);\n    }\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(snapshots.length === 0){\n      prepareAndRun();\n    } else {\n      doStep();\n    }\n  });\n\n  playBtn.addEventListener('click', ()=>{\n    if(snapshots.length === 0) prepareAndRun();\n    doPlay();\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    resetAnimationState();\n  });\n\n  speedInput.addEventListener('input', ()=>{\n    speedLabel.textContent = speedInput.value + ' ms';\n    if(playing){\n      // restart timer with new speed\n      clearInterval(playTimer);\n      playTimer = setInterval(()=>{\n        if(curStep < snapshots.length-1){\n          curStep++;\n          applySnapshot(curStep);\n        } else {\n          playing = false;\n          playBtn.textContent = 'Play';\n          clearInterval(playTimer);\n          playTimer = null;\n        }\n      }, Number(speedInput.value));\n    }\n  });\n\n  adjInput.addEventListener('change', ()=>{\n    // if adjacency provided, auto-generate graph from it\n    generateGraph();\n  });\n\n  // initial generation\n  generateGraph();\n\n  // Expose some keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      playBtn.click();\n    } else if(e.key === 'ArrowRight'){\n      stepBtn.click();\n    } else if(e.key === 'r' && (e.ctrlKey||e.metaKey)){\n      e.preventDefault();\n      genBtn.click();\n    }\n  });\n\n  // Make SVG responsive to viewBox size changes\n  function resizeSVG(){\n    // nothing needed; viewBox used\n  }\n  window.addEventListener('resize', resizeSVG);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}