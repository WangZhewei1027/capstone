{
  "id": "98e22fd2-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:15.314Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Breadth-First Search (BFS) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --accent-2:#7c3aed;\n      --cell:#0b1220;\n      --wall:#111827;\n      --visited:#fde68a;\n      --frontier:#60a5fa;\n      --path:#34d399;\n      --start:#ef4444;\n      --end:#f97316;\n      --text:#e6eef8;\n      --muted:#9aa8bd;\n      --control-bg:#0b1220;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n      background: linear-gradient(180deg,#071229 0%, #071833 60%, #0b1730 100%);\n      color:var(--text);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    .app {\n      display:grid;\n      grid-template-columns: 420px 1fr;\n      gap:18px;\n      padding:28px;\n      height:100vh;\n      box-sizing:border-box;\n    }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding:16px;\n      border-radius:12px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.45);\n      overflow:auto;\n    }\n\n    .left {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    h1{\n      margin:0 0 6px 0;\n      font-size:18px;\n      letter-spacing:0.2px;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .controls {\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      margin-top:8px;\n    }\n\n    button, select, input[type=number], input[type=range]{\n      background:var(--control-bg);\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--text);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button.primary {\n      background:linear-gradient(90deg,var(--accent),var(--accent-2));\n      color:white;\n      border:none;\n      box-shadow: 0 6px 16px rgba(96,165,250,0.12);\n    }\n    button.warn{\n      background:linear-gradient(90deg,#ef4444,#f97316);\n      color:white;\n      border:none;\n    }\n\n    .tools {\n      display:flex;\n      gap:8px;\n      margin-top:10px;\n    }\n\n    .tool {\n      padding:8px 10px;\n      border-radius:8px;\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.02);\n      display:flex;\n      gap:8px;\n      align-items:center;\n      cursor:pointer;\n      font-size:13px;\n    }\n    .tool.active{\n      outline:2px solid rgba(96,165,250,0.12);\n      box-shadow: inset 0 -4px 0 rgba(96,165,250,0.06);\n      background:linear-gradient(180deg, rgba(96,165,250,0.04), rgba(124,58,237,0.02));\n    }\n\n    .small {\n      font-size:12px;\n      padding:6px 8px;\n    }\n\n    .grid-wrap {\n      display:flex;\n      gap:18px;\n      align-items:flex-start;\n    }\n\n    .grid {\n      display:grid;\n      background:linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));\n      border-radius:8px;\n      padding:10px;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n      user-select:none;\n    }\n    .cell {\n      width:28px;\n      height:28px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-size:11px;\n      color:rgba(255,255,255,0.85);\n      border-radius:6px;\n      transition:background 120ms linear, transform 90ms ease;\n      box-sizing:border-box;\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n    .cell.empty { background: rgba(255,255,255,0.01); color:var(--muted); }\n    .cell.wall { background: var(--wall); color:rgba(255,255,255,0.65); }\n    .cell.start { background:var(--start); color:white; font-weight:700; }\n    .cell.end { background:var(--end); color:white; font-weight:700; }\n    .cell.frontier { background:var(--frontier); color:black; }\n    .cell.visited { background:var(--visited); color:black; }\n    .cell.path { background:var(--path); color:white; font-weight:700; }\n\n    .legend {\n      display:flex;\n      gap:8px;\n      flex-direction:column;\n    }\n    .legend-row { display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted); }\n\n    .swatch {\n      width:16px; height:16px; border-radius:4px; border:1px solid rgba(255,255,255,0.02);\n    }\n\n    .info {\n      margin-top:6px;\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.5;\n    }\n\n    .right {\n      display:flex;\n      flex-direction:column;\n    }\n\n    .board-area {\n      display:flex;\n      gap:12px;\n      align-items:flex-start;\n    }\n\n    .stats {\n      margin-top:12px;\n      display:grid;\n      grid-template-columns:1fr 1fr;\n      gap:10px;\n      font-size:13px;\n    }\n\n    .stat {\n      background:var(--glass);\n      padding:8px;\n      border-radius:8px;\n      text-align:center;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .stat strong { display:block; font-size:18px; }\n\n    .queue-box {\n      margin-top:12px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:8px;\n      padding:8px;\n      border:1px solid rgba(255,255,255,0.03);\n      font-size:13px;\n    }\n    .queue-list { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; color:var(--muted); }\n    .queue-item { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; font-weight:600; color:var(--text); font-size:12px; }\n\n    .pseudocode {\n      margin-top:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      padding:10px;\n      border-radius:8px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Courier New\", monospace;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n      white-space:pre;\n    }\n\n    .footer {\n      margin-top:18px;\n      font-size:12px;\n      color:var(--muted);\n    }\n\n    @media (max-width:1000px){\n      .app { grid-template-columns: 1fr; padding:14px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel left\">\n      <div>\n        <h1>Breadth-First Search (BFS)</h1>\n        <p class=\"lead\">Interactive visualization: draw walls, pick start & end, then step through or run BFS to find the shortest path on a grid.</p>\n      </div>\n\n      <div class=\"controls\">\n        <label>Rows <input id=\"rows\" type=\"number\" min=\"5\" max=\"40\" value=\"16\" style=\"width:72px\"></label>\n        <label>Cols <input id=\"cols\" type=\"number\" min=\"5\" max=\"60\" value=\"28\" style=\"width:72px\"></label>\n        <button id=\"resize\" title=\"Resize grid\">Resize Grid</button>\n        <button id=\"randomWalls\">Random Walls</button>\n        <button id=\"clearWalls\">Clear Walls</button>\n      </div>\n\n      <div class=\"tools\" style=\"margin-top:12px;\">\n        <div class=\"tool active\" id=\"tool-wall\" data-tool=\"wall\">Draw Walls</div>\n        <div class=\"tool\" id=\"tool-start\" data-tool=\"start\">Set Start</div>\n        <div class=\"tool\" id=\"tool-end\" data-tool=\"end\">Set End</div>\n        <div class=\"tool\" id=\"tool-erase\" data-tool=\"erase\">Erase</div>\n      </div>\n\n      <div style=\"display:flex;gap:8px;margin-top:12px;align-items:center;\">\n        <button class=\"primary\" id=\"run\">Run</button>\n        <button id=\"step\">Step</button>\n        <button id=\"pause\">Pause</button>\n        <button id=\"reset\">Reset</button>\n        <div style=\"display:flex;flex-direction:column;margin-left:8px;\">\n          <label style=\"font-size:12px;color:var(--muted)\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"220\" step=\"10\" style=\"width:160px\">\n        </div>\n      </div>\n\n      <div style=\"display:flex;gap:8px;margin-top:12px;align-items:center;\">\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--start)\"></div>\n          <div style=\"font-size:13px;\">Start</div>\n        </div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--end)\"></div>\n          <div style=\"font-size:13px;\">End</div>\n        </div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--wall)\"></div>\n          <div style=\"font-size:13px;\">Wall</div>\n        </div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--frontier)\"></div>\n          <div style=\"font-size:13px;\">Frontier (Queue)</div>\n        </div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--visited)\"></div>\n          <div style=\"font-size:13px;\">Visited</div>\n        </div>\n        <div style=\"display:flex;gap:6px;align-items:center;\">\n          <div class=\"swatch\" style=\"background:var(--path)\"></div>\n          <div style=\"font-size:13px;\">Final Path</div>\n        </div>\n      </div>\n\n      <div class=\"info\">\n        Controls:\n        <ul style=\"margin:6px 0 0 18px;\">\n          <li>Left-click and drag to paint walls (or erase). Use the tool buttons to place Start/End.</li>\n          <li>Run will animate BFS until the end is found or all reachable cells are visited.</li>\n          <li>Step advances one BFS expansion (dequeue one node). Pause stops the animation.</li>\n          <li>BFS finds the shortest path in an unweighted grid (4-neighbors).</li>\n        </ul>\n      </div>\n\n      <div class=\"pseudocode\">\nBFS(start, goal):\n  Q = empty queue\n  enqueue Q with start\n  mark start visited\n  while Q not empty:\n    current = dequeue Q\n    if current == goal:\n      return reconstruct_path(goal)\n    for each neighbor of current:\n      if neighbor not visited and not wall:\n        mark visited\n        parent[neighbor] = current\n        enqueue neighbor\n  return no path\n      </div>\n\n      <div class=\"footer\">\n        Tip: Resize the grid, add walls and try different configurations. BFS explores in waves and guarantees the shortest path on an unweighted grid.\n      </div>\n    </div>\n\n    <div class=\"panel right\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div>\n          <strong style=\"font-size:16px\">Grid</strong>\n          <div style=\"font-size:13px;color:var(--muted)\">Click cells to interact. Drag to paint.</div>\n        </div>\n        <div style=\"text-align:right\">\n          <div style=\"font-size:13px;color:var(--muted)\">Algorithm State</div>\n          <div style=\"font-weight:700;font-size:15px\" id=\"state\">Idle</div>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px;\" class=\"board-area\">\n        <div>\n          <div id=\"grid\" class=\"grid\"></div>\n        </div>\n        <div style=\"min-width:220px;\">\n          <div class=\"stats\">\n            <div class=\"stat\">\n              <div style=\"color:var(--muted)\">Visit Count</div>\n              <strong id=\"visitCount\">0</strong>\n            </div>\n            <div class=\"stat\">\n              <div style=\"color:var(--muted)\">Queue Size</div>\n              <strong id=\"queueSize\">0</strong>\n            </div>\n          </div>\n\n          <div class=\"queue-box\" id=\"queueBox\">\n            <div style=\"font-weight:700\">Queue (front → back)</div>\n            <div id=\"queueList\" class=\"queue-list\"></div>\n          </div>\n\n          <div style=\"margin-top:12px;\">\n            <div style=\"font-weight:700\">Found Path</div>\n            <div id=\"pathInfo\" style=\"color:var(--muted);margin-top:6px\">Length: -</div>\n          </div>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n  <script>\n    // BFS Visualizer JavaScript\n    (function(){\n      // Grid data and state\n      const DEFAULT_ROWS = 16;\n      const DEFAULT_COLS = 28;\n\n      let rows = DEFAULT_ROWS;\n      let cols = DEFAULT_COLS;\n      let gridEl = document.getElementById('grid');\n\n      // Cell states: 'empty', 'wall', 'start', 'end', 'visited', 'frontier', 'path'\n      let cells = []; // 2D array of state strings\n      let start = {r: Math.floor(rows/2), c: Math.floor(cols/4)};\n      let end = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n\n      // BFS runtime structures\n      let visited = null; // 2D bool\n      let parent = null; // 2D parent pointers {r,c} or null\n      let queue = []; // array of {r,c}\n      let intervalId = null;\n      let isRunning = false;\n      let animationDelay = 220; // ms\n      let exploring = false;\n      let found = false;\n\n      // UI elements\n      const rowsInput = document.getElementById('rows');\n      const colsInput = document.getElementById('cols');\n      const resizeBtn = document.getElementById('resize');\n      const randomWallsBtn = document.getElementById('randomWalls');\n      const clearWallsBtn = document.getElementById('clearWalls');\n      const runBtn = document.getElementById('run');\n      const stepBtn = document.getElementById('step');\n      const pauseBtn = document.getElementById('pause');\n      const resetBtn = document.getElementById('reset');\n      const speedRange = document.getElementById('speed');\n      const stateEl = document.getElementById('state');\n      const queueListEl = document.getElementById('queueList');\n      const queueSizeEl = document.getElementById('queueSize');\n      const visitCountEl = document.getElementById('visitCount');\n      const pathInfoEl = document.getElementById('pathInfo');\n\n      // Tools\n      const toolEls = Array.from(document.querySelectorAll('.tool'));\n      let currentTool = 'wall';\n      toolEls.forEach(t => t.addEventListener('click', ()=> {\n        toolEls.forEach(x => x.classList.remove('active'));\n        t.classList.add('active');\n        currentTool = t.dataset.tool;\n      }));\n\n      // Prevent context menu to allow right-click behavior if needed\n      document.addEventListener('contextmenu', e => e.preventDefault());\n\n      // Initialize\n      function initGrid(r = rows, c = cols){\n        rows = r;\n        cols = c;\n        rowsInput.value = rows;\n        colsInput.value = cols;\n\n        // Initialize cell states\n        cells = new Array(rows);\n        visited = new Array(rows);\n        parent = new Array(rows);\n        for(let i=0;i<rows;i++){\n          cells[i] = new Array(cols).fill('empty');\n          visited[i] = new Array(cols).fill(false);\n          parent[i] = new Array(cols).fill(null);\n        }\n\n        // Place start and end (safely inside)\n        start = {r: Math.max(0, Math.min(rows-1, Math.floor(rows/2))), c: Math.max(0, Math.min(cols-1, Math.floor(cols/4)))};\n        end = {r: Math.max(0, Math.min(rows-1, Math.floor(rows/2))), c: Math.max(0, Math.min(cols-1, Math.floor(cols*3/4)))};\n        cells[start.r][start.c] = 'start';\n        cells[end.r][end.c] = 'end';\n\n        renderGrid();\n        resetBFSState();\n      }\n\n      function renderGrid(){\n        // CSS grid columns\n        gridEl.style.gridTemplateColumns = `repeat(${cols}, 28px)`;\n        gridEl.innerHTML = '';\n        for(let r=0;r<rows;r++){\n          for(let c=0;c<cols;c++){\n            const div = document.createElement('div');\n            div.className = 'cell ' + cells[r][c];\n            div.dataset.r = r;\n            div.dataset.c = c;\n            // Show small label for start/end; visited frontier will be colored\n            if(cells[r][c] === 'start') div.textContent = 'S';\n            else if(cells[r][c] === 'end') div.textContent = 'E';\n            else div.textContent = '';\n\n            // Mouse interactions\n            div.addEventListener('mousedown', onCellMouseDown);\n            div.addEventListener('mouseenter', onCellMouseEnter);\n            div.addEventListener('mouseup', onCellMouseUp);\n            // store element for faster updates\n            gridEl.appendChild(div);\n          }\n        }\n      }\n\n      // Helpers to update single cell class and text\n      function updateCellStyle(r,c){\n        const idx = r*cols + c;\n        const el = gridEl.children[idx];\n        if(!el) return;\n        const state = cells[r][c];\n        el.className = 'cell ' + state;\n        el.textContent = (state === 'start') ? 'S' : (state === 'end') ? 'E' : (state === 'path') ? '•' : (state === 'visited') ? '' : '';\n      }\n\n      // Mouse painting handling\n      let mouseDown = false;\n      let paintMode = null;\n\n      function onCellMouseDown(e){\n        e.preventDefault();\n        mouseDown = true;\n        const r = +this.dataset.r;\n        const c = +this.dataset.c;\n        // Determine action based on current tool\n        if(currentTool === 'wall'){\n          paintMode = 'wall';\n          toggleWallAt(r,c,true);\n        } else if(currentTool === 'erase'){\n          paintMode = 'erase';\n          toggleWallAt(r,c,false);\n        } else if(currentTool === 'start'){\n          setStart(r,c);\n        } else if(currentTool === 'end'){\n          setEnd(r,c);\n        }\n      }\n      function onCellMouseEnter(e){\n        if(!mouseDown) return;\n        const r = +this.dataset.r;\n        const c = +this.dataset.c;\n        if(paintMode === 'wall') toggleWallAt(r,c,true);\n        if(paintMode === 'erase') toggleWallAt(r,c,false);\n      }\n      function onCellMouseUp(e){\n        mouseDown = false;\n        paintMode = null;\n      }\n      window.addEventListener('mouseup', ()=> { mouseDown = false; paintMode = null; });\n\n      function toggleWallAt(r,c,make){\n        // can't toggle start or end\n        if((r === start.r && c === start.c) || (r === end.r && c === end.c)) return;\n        cells[r][c] = make ? 'wall' : 'empty';\n        updateCellStyle(r,c);\n        resetBFSState();\n      }\n\n      function setStart(r,c){\n        if(cells[r][c] === 'wall' || (r===end.r && c===end.c)) return;\n        // clear old start\n        cells[start.r][start.c] = 'empty';\n        updateCellStyle(start.r,start.c);\n        start = {r,c};\n        cells[r][c] = 'start';\n        updateCellStyle(r,c);\n        resetBFSState();\n      }\n\n      function setEnd(r,c){\n        if(cells[r][c] === 'wall' || (r===start.r && c===start.c)) return;\n        // clear old end\n        cells[end.r][end.c] = 'empty';\n        updateCellStyle(end.r,end.c);\n        end = {r,c};\n        cells[r][c] = 'end';\n        updateCellStyle(r,c);\n        resetBFSState();\n      }\n\n      // BFS functions\n      function resetBFSState(){\n        // Clear visited/frontier/path but keep walls and start/end\n        visited = new Array(rows);\n        parent = new Array(rows);\n        for(let i=0;i<rows;i++){\n          visited[i] = new Array(cols).fill(false);\n          parent[i] = new Array(cols).fill(null);\n          for(let j=0;j<cols;j++){\n            if(cells[i][j] === 'visited' || cells[i][j] === 'frontier' || cells[i][j] === 'path'){\n              cells[i][j] = 'empty';\n              updateCellStyle(i,j);\n            }\n          }\n        }\n        queue = [];\n        exploring = false;\n        found = false;\n        isRunning = false;\n        clearInterval(intervalId);\n        intervalId = null;\n        stateEl.textContent = 'Idle';\n        queueListEl.innerHTML = '';\n        queueSizeEl.textContent = '0';\n        visitCountEl.textContent = '0';\n        pathInfoEl.textContent = 'Length: -';\n        runBtn.disabled = false;\n      }\n\n      function initializeBFS(){\n        // Called before run/step to (re)start BFS from the current start\n        resetBFSState();\n        queue = [];\n        enqueue(start.r,start.c);\n        visited[start.r][start.c] = true;\n        // mark start as visited visually? Keep as 'start' cell\n        stateEl.textContent = 'Running';\n      }\n\n      function enqueue(r,c){\n        queue.push({r,c});\n        // mark as frontier unless it's start or end\n        const keyState = cells[r][c];\n        if(!(r===start.r && c===start.c) && !(r===end.r && c===end.c)){\n          cells[r][c] = 'frontier';\n          updateCellStyle(r,c);\n        }\n        updateQueueUI();\n      }\n\n      function dequeue(){\n        const el = queue.shift();\n        updateQueueUI();\n        return el;\n      }\n\n      function updateQueueUI(){\n        queueListEl.innerHTML = '';\n        queue.forEach(q => {\n          const item = document.createElement('div');\n          item.className = 'queue-item';\n          item.textContent = `[${q.r},${q.c}]`;\n          queueListEl.appendChild(item);\n        });\n        queueSizeEl.textContent = queue.length;\n      }\n\n      function neighbors(r,c){\n        const out = [];\n        const dirs = [[-1,0],[1,0],[0,-1],[0,1]]; // 4-neighbors\n        for(const d of dirs){\n          const nr = r + d[0];\n          const nc = c + d[1];\n          if(nr>=0 && nr<rows && nc>=0 && nc<cols) out.push({r:nr,c:nc});\n        }\n        return out;\n      }\n\n      function stepBFS(){\n        // Perform one dequeue and expand; return status: 'running' | 'found' | 'done'\n        if(found || queue.length === 0){\n          stateEl.textContent = found ? 'Found' : 'Done - no path';\n          isRunning = false;\n          clearInterval(intervalId);\n          intervalId = null;\n          return 'done';\n        }\n        const cur = dequeue();\n        const r = cur.r, c = cur.c;\n\n        // mark as visited (but keep start/end appearance)\n        if(!(r===start.r && c===start.c) && !(r===end.r && c===end.c)){\n          cells[r][c] = 'visited';\n          updateCellStyle(r,c);\n        }\n        visitCountEl.textContent = (+visitCountEl.textContent || 0) + 1;\n\n        // If this is the goal\n        if(r === end.r && c === end.c){\n          found = true;\n          reconstructPath();\n          stateEl.textContent = 'Found';\n          isRunning = false;\n          clearInterval(intervalId);\n          intervalId = null;\n          return 'found';\n        }\n\n        // Expand neighbors\n        for(const nb of neighbors(r,c)){\n          const nr = nb.r, nc = nb.c;\n          if(visited[nr][nc]) continue;\n          if(cells[nr][nc] === 'wall') continue;\n          visited[nr][nc] = true;\n          parent[nr][nc] = {r,c};\n          enqueue(nr,nc);\n        }\n        return 'running';\n      }\n\n      function reconstructPath(){\n        // Use parent pointers from end to start\n        let path = [];\n        let cur = {r:end.r, c:end.c};\n        while(cur){\n          path.push(cur);\n          const p = parent[cur.r][cur.c];\n          if(!p) break;\n          cur = p;\n        }\n        // If last is not start, no path\n        if(!(path.length && path[path.length-1].r === start.r && path[path.length-1].c === start.c)){\n          pathInfoEl.textContent = 'Length: - (no path)';\n          return;\n        }\n        // Visualize path\n        for(const node of path){\n          if((node.r === start.r && node.c === start.c) || (node.r === end.r && node.c === end.c)) continue;\n          cells[node.r][node.c] = 'path';\n          updateCellStyle(node.r,node.c);\n        }\n        pathInfoEl.textContent = 'Length: ' + (path.length - 1);\n      }\n\n      // Controls\n      resizeBtn.addEventListener('click', ()=> {\n        const r = parseInt(rowsInput.value)||rows;\n        const c = parseInt(colsInput.value)||cols;\n        if(r<5 || c<5 || r>40 || c>60){\n          alert('Rows 5-40, Cols 5-60');\n          return;\n        }\n        initGrid(r,c);\n      });\n\n      randomWallsBtn.addEventListener('click', ()=> {\n        // randomize walls with some probability\n        resetBFSState();\n        const prob = 0.28; // 28% walls by default\n        for(let i=0;i<rows;i++){\n          for(let j=0;j<cols;j++){\n            if((i===start.r && j===start.c) || (i===end.r && j===end.c)) continue;\n            cells[i][j] = (Math.random() < prob) ? 'wall' : 'empty';\n            updateCellStyle(i,j);\n          }\n        }\n      });\n\n      clearWallsBtn.addEventListener('click', ()=> {\n        for(let i=0;i<rows;i++){\n          for(let j=0;j<cols;j++){\n            if(cells[i][j] === 'wall') {\n              cells[i][j] = 'empty';\n              updateCellStyle(i,j);\n            }\n          }\n        }\n        resetBFSState();\n      });\n\n      runBtn.addEventListener('click', ()=> {\n        if(isRunning) return;\n        initializeBFS();\n        isRunning = true;\n        animationDelay = parseInt(speedRange.value);\n        intervalId = setInterval(()=> {\n          const res = stepBFS();\n          if(res === 'done' || res === 'found'){\n            // nothing extra\n          }\n        }, animationDelay);\n      });\n\n      stepBtn.addEventListener('click', ()=> {\n        if(!isRunning && queue.length === 0){\n          initializeBFS();\n        }\n        // Do one step\n        isRunning = false;\n        clearInterval(intervalId);\n        intervalId = null;\n        stepBFS();\n      });\n\n      pauseBtn.addEventListener('click', ()=> {\n        isRunning = false;\n        clearInterval(intervalId);\n        intervalId = null;\n        stateEl.textContent = 'Paused';\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        resetBFSState();\n      });\n\n      speedRange.addEventListener('input', ()=> {\n        animationDelay = parseInt(speedRange.value);\n        if(isRunning){\n          clearInterval(intervalId);\n          intervalId = setInterval(()=> {\n            stepBFS();\n          }, animationDelay);\n        }\n      });\n\n      // Initialize first time\n      initGrid(DEFAULT_ROWS, DEFAULT_COLS);\n\n      // Optional: keyboard shortcuts\n      window.addEventListener('keydown', (e)=> {\n        if(e.key === 'r') randomWallsBtn.click();\n        if(e.key === 'c') clearWallsBtn.click();\n        if(e.key === ' ') { e.preventDefault(); runBtn.click(); }\n        if(e.key === 'p') pauseBtn.click();\n        if(e.key === 's') stepBtn.click();\n      });\n\n      // For accessibility: expose a function to programmatically run BFS to completion quickly (without animation)\n      // This can be useful when user wants immediate answer.\n      // Add a modifier: shift+Run will compute instantly\n      runBtn.addEventListener('click', (ev)=> {\n        if(ev.shiftKey){\n          // compute quickly without animation\n          initializeBFS();\n          while(queue.length && !found){\n            stepBFS();\n          }\n        }\n      });\n\n      // End of script\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}