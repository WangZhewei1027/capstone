{
  "id": "98e27df2-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:04.675Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Fibonacci Sequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Fibonacci Sequence Explorer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; color: #111; }\n    body { margin: 0; padding: 20px; background: #f7f9fc; }\n    h1 { margin: 0 0 8px 0; font-size: 20px; }\n    p.lead { margin: 6px 0 16px 0; color: #444; max-width: 900px; }\n    .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:12px; }\n    .controls > * { background:white; border:1px solid #d6dde6; padding:8px; border-radius:6px; }\n    label { font-size:13px; color:#333; display:flex; gap:8px; align-items:center; }\n    input[type=range] { width:240px; }\n    button { cursor:pointer; border:1px solid #2b76d2; background: linear-gradient(#2f88ff,#1f6ad7); color:white; padding:8px 12px; border-radius:6px; font-weight:600; }\n    button.secondary { border:1px solid #999; background: #fff; color:#111; box-shadow:none; }\n    .methods { display:flex; gap:8px; flex-wrap:wrap; }\n    .grid { display:grid; grid-template-columns: 1fr 420px; gap:16px; align-items:start; }\n    .panel { background:white; border:1px solid #e1e8f0; border-radius:8px; padding:12px; }\n    .panel h2 { margin:0 0 8px 0; font-size:16px; }\n    #sequence { display:flex; gap:6px; flex-wrap:wrap; }\n    .term { background:#f1f6ff; border:1px solid #d9e8ff; padding:6px 8px; border-radius:6px; font-family: monospace; font-size:13px; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }\n    .term.big { background:#fff7e6; border-color:#ffe4b5; }\n    .meta { font-size:13px; color:#555; margin-top:8px; }\n    canvas { width:100%; height:220px; background: linear-gradient(180deg,#ffffff,#f6fbff); border-radius:6px; display:block; }\n    .small { font-size:12px; color:#666; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .chip { background:#eef6ff; border:1px solid #d9edff; padding:6px 8px; border-radius:999px; font-size:12px; }\n    footer { margin-top:18px; font-size:12px; color:#666; }\n    .warning { color:#9b2c2c; background:#fff1f1; border:1px solid #ffdede; padding:8px; border-radius:6px; }\n    .ratio { margin-top:8px; font-family:monospace; font-size:13px; }\n    .controls-column { display:flex; flex-direction:column; gap:8px; }\n    @media (max-width:900px){ .grid { grid-template-columns: 1fr; } canvas { height:200px; } }\n  </style>\n</head>\n<body>\n  <h1>Fibonacci Sequence Explorer</h1>\n  <p class=\"lead\">Generate and visualize Fibonacci numbers. Try different algorithms (iterative, naive recursion, memoized, Binet's formula), animate the construction step-by-step, and watch the ratios converge to the golden ratio φ ≈ 1.618...</p>\n\n  <div class=\"controls\">\n    <label>Count:\n      <input id=\"count\" type=\"range\" min=\"0\" max=\"200\" value=\"20\">\n      <input id=\"countNumber\" type=\"number\" min=\"0\" max=\"200\" value=\"20\" style=\"width:72px;\">\n    </label>\n\n    <div class=\"methods\">\n      <button id=\"iterBtn\">Iterative</button>\n      <button id=\"recurBtn\" class=\"secondary\">Naive Recursion</button>\n      <button id=\"memoBtn\">Recursion + Memo</button>\n      <button id=\"binetBtn\" class=\"secondary\">Binet (float)</button>\n    </div>\n\n    <div class=\"controls-column\" style=\"margin-left:auto;\">\n      <label><input id=\"animateCheckbox\" type=\"checkbox\"> Animate construction</label>\n      <label class=\"small\">Step speed:\n        <input id=\"speed\" type=\"range\" min=\"10\" max=\"1000\" value=\"120\">\n      </label>\n    </div>\n  </div>\n\n  <div class=\"grid\">\n    <div class=\"panel\">\n      <h2>Sequence</h2>\n      <div id=\"sequence\" aria-live=\"polite\"></div>\n      <div class=\"meta\">\n        <div id=\"time\" class=\"small\"></div>\n        <div id=\"notes\" class=\"small\"></div>\n      </div>\n\n      <div class=\"ratio\" id=\"ratios\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <h2>Visualization</h2>\n      <canvas id=\"canvas\" width=\"600\" height=\"220\"></canvas>\n      <div class=\"legend\">\n        <div class=\"chip\">bars: magnitude</div>\n        <div class=\"chip\">hover to see full value</div>\n        <div class=\"chip\" id=\"phiChip\">φ ≈ 1.6180339887</div>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <button id=\"animateBars\" class=\"secondary\">Animate Bars</button>\n        <button id=\"downloadBtn\" class=\"secondary\">Download as PNG</button>\n      </div>\n      <div id=\"canvasHint\" class=\"small\" style=\"margin-top:8px;\"></div>\n    </div>\n  </div>\n\n  <footer>\n    Tips: Naive recursion is exponential — it will be slow for n &gt; ~40. Iterative and memoized recursion are fast and can use BigInt to produce exact integers for large n.\n  </footer>\n\n  <script>\n    // Utilities and Fibonacci implementations (using BigInt for exactness)\n    const $ = id => document.getElementById(id);\n\n    function fibIterative(n){\n      // returns array of BigInt from F0..Fn\n      const out = [];\n      if (n >= 0) out.push(0n);\n      if (n >= 1) out.push(1n);\n      let a = 0n, b = 1n;\n      for (let i = 2; i <= n; i++){\n        const c = a + b;\n        out.push(c);\n        a = b; b = c;\n      }\n      return out;\n    }\n\n    function fibNaive(n){\n      // naive recursive, returns BigInt\n      if (n === 0) return 0n;\n      if (n === 1) return 1n;\n      return fibNaive(n-1) + fibNaive(n-2);\n    }\n\n    function fibMemo(n, memo = {}){\n      if (n === 0) return 0n;\n      if (n === 1) return 1n;\n      if (memo[n] !== undefined) return memo[n];\n      memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);\n      return memo[n];\n    }\n\n    function fibMemoArray(n){\n      // returns array F0..Fn using memoization\n      const arr = [];\n      function f(k){\n        if (k === 0) return 0n;\n        if (k === 1) return 1n;\n        if (arr[k] !== undefined) return arr[k];\n        arr[k] = f(k-1) + f(k-2);\n        return arr[k];\n      }\n      for (let i = 0; i <= n; i++) f(i);\n      return arr;\n    }\n\n    function fibBinetArray(n){\n      // Uses floating point Binet formula - accurate for small n (n ≲ 70)\n      // returns array of Numbers (may lose precision for large n)\n      const phi = (1 + Math.sqrt(5)) / 2;\n      const psi = (1 - Math.sqrt(5)) / 2;\n      const out = [];\n      for (let i = 0; i <= n; i++){\n        const val = Math.round((Math.pow(phi,i) - Math.pow(psi,i)) / Math.sqrt(5));\n        out.push(val);\n      }\n      return out;\n    }\n\n    // DOM and drawing\n    const countRange = $('count');\n    const countNumber = $('countNumber');\n    const sequenceEl = $('sequence');\n    const timeEl = $('time');\n    const notesEl = $('notes');\n    const ratiosEl = $('ratios');\n    const animateCheckbox = $('animateCheckbox');\n    const speedRange = $('speed');\n\n    // Canvas\n    const canvas = $('canvas');\n    const ctx = canvas.getContext('2d');\n    let currentValues = [];\n    let hoverIndex = -1;\n\n    function formatBigInt(n){\n      // show as string, but shorten with ellipsis for display element width\n      return n.toString();\n    }\n\n    function renderSequence(values, highlightIndex = -1){\n      currentValues = values.map(v => (typeof v === 'bigint') ? v : BigInt(v));\n      sequenceEl.innerHTML = '';\n      values.forEach((val, i) => {\n        const div = document.createElement('div');\n        div.className = 'term' + ((String(val).length > 18) ? ' big' : '');\n        div.tabIndex = 0;\n        div.title = String(val);\n        if (i === highlightIndex) div.style.boxShadow = 'inset 0 0 0 2px rgba(90,140,255,0.18)';\n        div.textContent = i + ': ' + (typeof val === 'bigint' ? formatBigInt(val) : String(val));\n        sequenceEl.appendChild(div);\n      });\n      renderRatios(values);\n      drawBars(values);\n    }\n\n    function renderRatios(values){\n      if (values.length < 2){\n        ratiosEl.textContent = '';\n        return;\n      }\n      const parts = [];\n      for (let i = 1; i < values.length; i++){\n        // compute ratio F_i / F_{i-1} using Number for display;\n        let a = values[i];\n        let b = values[i-1];\n        // convert to Number safely when possible:\n        let ratio;\n        try {\n          ratio = (typeof a === 'bigint' || typeof b === 'bigint') ? Number(a) / Number(b) : a / b;\n        } catch(e) { ratio = NaN; }\n        parts.push((i) + ':' + (isFinite(ratio) ? ratio.toFixed(6) : '—'));\n        if (i >= 15) break; // avoid too many\n      }\n      ratiosEl.textContent = 'Ratios (Fi/Fi-1): ' + parts.join('  ');\n    }\n\n    function drawBars(values){\n      const w = canvas.width = canvas.clientWidth * devicePixelRatio;\n      const h = canvas.height = canvas.clientHeight * devicePixelRatio;\n      ctx.clearRect(0,0,w,h);\n      if (!values || values.length === 0) return;\n      // convert to numbers by normalizing to last value; use logarithmic scale for very large numbers\n      const last = values[values.length-1];\n      const useLog = true; // helps scale across many magnitudes\n      // convert to numeric magnitude by length of decimal digits if BigInt\n      const magnitudes = values.map(v => {\n        const s = typeof v === 'bigint' ? v.toString() : String(Math.abs(v));\n        // remove sign\n        const digits = s.replace(/^-/, '').length;\n        // approximate numeric magnitude for plotting by digits and first few digits\n        const leading = Number(s.slice(0,6));\n        return {digits, leading, raw: v};\n      });\n      const maxDigits = Math.max(...magnitudes.map(m => m.digits));\n      // horizontal layout\n      const pad = 10 * devicePixelRatio;\n      const areaW = w - 2*pad;\n      const barGap = Math.max(4 * devicePixelRatio, Math.floor(areaW / (magnitudes.length * 15)));\n      const barWidth = Math.max(6 * devicePixelRatio, (areaW - barGap*(magnitudes.length+1)) / magnitudes.length);\n      let x = pad + barGap;\n      for (let i=0;i<magnitudes.length;i++){\n        const m = magnitudes[i];\n        // height proportional to digits and leading digits\n        const frac = (m.digits - 1) + (m.leading / Math.pow(10, Math.min(6,m.digits)));\n        const norm = frac / (maxDigits); // 0..1\n        const barH = Math.max(4*devicePixelRatio, norm * (h - 40*devicePixelRatio));\n        // style\n        const grd = ctx.createLinearGradient(0, h-barH, 0, h);\n        grd.addColorStop(0, i%2? '#d6ecff' : '#eaf6ff');\n        grd.addColorStop(1, '#b8e1ff');\n        ctx.fillStyle = grd;\n        ctx.strokeStyle = '#a6d4ff';\n        ctx.lineWidth = Math.max(1, devicePixelRatio);\n        ctx.fillRect(x, h - barH, barWidth, barH);\n        ctx.strokeRect(x, h - barH, barWidth, barH);\n        // index label\n        ctx.fillStyle = '#2c3e50';\n        ctx.font = `${12*devicePixelRatio}px system-ui, monospace`;\n        ctx.textAlign = 'center';\n        ctx.fillText(i, x + barWidth/2, h - barH - 6*devicePixelRatio);\n        // maybe mark hovered\n        if (i === hoverIndex){\n          ctx.strokeStyle = 'rgba(80,120,255,0.9)';\n          ctx.lineWidth = 2 * devicePixelRatio;\n          ctx.strokeRect(x-2*devicePixelRatio, h - barH-2*devicePixelRatio, barWidth+4*devicePixelRatio, barH+4*devicePixelRatio);\n        }\n        x += barWidth + barGap;\n      }\n      // bottom axis\n      ctx.fillStyle = '#444';\n      ctx.font = `${11*devicePixelRatio}px system-ui, monospace`;\n      ctx.textAlign = 'left';\n      ctx.fillText('F0..F' + (values.length - 1), pad, 14*devicePixelRatio);\n    }\n\n    // Canvas interactivity: show tooltip-like full value on hover\n    canvas.addEventListener('mousemove', (ev) => {\n      if (!currentValues || currentValues.length === 0) return;\n      const rect = canvas.getBoundingClientRect();\n      const x = (ev.clientX - rect.left) * devicePixelRatio;\n      const w = canvas.width;\n      const pad = 10 * devicePixelRatio;\n      const areaW = w - 2*pad;\n      const barGap = Math.max(4 * devicePixelRatio, Math.floor(areaW / (currentValues.length * 15)));\n      const barWidth = Math.max(6 * devicePixelRatio, (areaW - barGap*(currentValues.length+1)) / currentValues.length);\n      let mx = pad + barGap;\n      let found = -1;\n      for (let i=0;i<currentValues.length;i++){\n        if (x >= mx && x <= mx + barWidth) { found = i; break; }\n        mx += barWidth + barGap;\n      }\n      hoverIndex = found;\n      drawBars(currentValues);\n      if (found >= 0){\n        const hint = $('canvasHint');\n        hint.textContent = 'Index ' + found + ': ' + String(currentValues[found]);\n      } else {\n        $('canvasHint').textContent = '';\n      }\n    });\n\n    canvas.addEventListener('mouseleave', () => { hoverIndex = -1; drawBars(currentValues); $('canvasHint').textContent = ''; });\n\n    // Buttons and behavior\n    countRange.addEventListener('input', e => { countNumber.value = countRange.value; });\n    countNumber.addEventListener('change', e => {\n      let v = Number(countNumber.value);\n      if (isNaN(v) || v < 0) v = 0;\n      if (v > 200) v = 200;\n      countNumber.value = v;\n      countRange.value = v;\n    });\n\n    function measure(fn){\n      const t0 = performance.now();\n      const res = fn();\n      const t1 = performance.now();\n      return {res, time: t1 - t0};\n    }\n\n    async function showIterative(){\n      const n = Number(countRange.value);\n      timeEl.textContent = 'Computing (iterative)...';\n      notesEl.textContent = '';\n      if (animateCheckbox.checked){\n        await animateIterative(n);\n      } else {\n        const {res, time} = measure(() => fibIterative(n));\n        renderSequence(res);\n        timeEl.textContent = `Iterative: computed F0..F${n} in ${time.toFixed(3)} ms (exact, BigInt)`;\n      }\n    }\n\n    async function animateIterative(n){\n      sequenceEl.innerHTML = '';\n      let a = 0n, b = 1n;\n      const arr = [];\n      const speed = Math.max(10, Number(speedRange.value));\n      function pushTerm(i, val){\n        const div = document.createElement('div');\n        div.className = 'term' + ((String(val).length > 18) ? ' big' : '');\n        div.title = String(val);\n        div.textContent = i + ': ' + formatBigInt(val);\n        sequenceEl.appendChild(div);\n      }\n      const t0 = performance.now();\n      if (n >= 0){ arr.push(0n); pushTerm(0, 0n); await sleep(speed); }\n      if (n >= 1){ arr.push(1n); pushTerm(1, 1n); await sleep(speed); }\n      for (let i = 2; i <= n; i++){\n        const c = a + b;\n        // note: we must keep a and b updated; initial a=0,b=1 corresponds to F0,F1; but we haven't set a,b accordingly\n        // adjust: after first two pushes, set a=0,b=1\n        if (i===2) { a=0n; b=1n; }\n        const next = a + b;\n        arr.push(next);\n        pushTerm(i, next);\n        a = b; b = next;\n        await sleep(speed);\n      }\n      const t1 = performance.now();\n      timeEl.textContent = `Iterative (animated): computed F0..F${n} in ${(t1-t0).toFixed(1)} ms (rendering took extra time)`;\n      renderRatios(arr);\n      drawBars(arr);\n      currentValues = arr;\n    }\n\n    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n    async function showNaive(){\n      const n = Number(countRange.value);\n      timeEl.textContent = 'Computing (naive recursion)...';\n      notesEl.textContent = '';\n      if (n > 45){\n        notesEl.innerHTML = '<span class=\"warning\">Naive recursion is exponential and will be very slow for n > ~45. Please choose a smaller n or use memoization/iterative method.</span>';\n        return;\n      }\n      // compute each term to render sequence as F0..Fn\n      const arr = [];\n      const t0 = performance.now();\n      for (let i = 0; i <= n; i++){\n        arr.push(fibNaive(i));\n      }\n      const t1 = performance.now();\n      renderSequence(arr);\n      timeEl.textContent = `Naive recursion: computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (exponential complexity)`;\n    }\n\n    async function showMemo(){\n      const n = Number(countRange.value);\n      timeEl.textContent = 'Computing (memoized recursion)...';\n      notesEl.textContent = '';\n      const t0 = performance.now();\n      const arr = fibMemoArray(n);\n      const t1 = performance.now();\n      renderSequence(arr);\n      timeEl.textContent = `Memoized recursion: computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (exact, BigInt)`;\n    }\n\n    async function showBinet(){\n      const n = Number(countRange.value);\n      timeEl.textContent = 'Computing (Binet)...';\n      notesEl.textContent = '';\n      if (n > 70){\n        notesEl.innerHTML = '<span class=\"warning\">Binet uses floating-point arithmetic and will lose precision for n &gt; ~70. Prefer iterative or memoized BigInt methods for exact results.</span>';\n      }\n      const t0 = performance.now();\n      const arr = fibBinetArray(n);\n      const t1 = performance.now();\n      renderSequence(arr);\n      timeEl.textContent = `Binet (float): computed F0..F${n} in ${(t1-t0).toFixed(3)} ms (floating approximation)`;\n    }\n\n    $('iterBtn').addEventListener('click', showIterative);\n    $('recurBtn').addEventListener('click', showNaive);\n    $('memoBtn').addEventListener('click', showMemo);\n    $('binetBtn').addEventListener('click', showBinet);\n\n    // initial render\n    showIterative();\n\n    // animate bars: visually expand each bar\n    $('animateBars').addEventListener('click', async () => {\n      const values = currentValues.slice();\n      if (!values || values.length === 0) return;\n      const steps = values.length;\n      const orig = canvas.cloneNode();\n      // simple grow animation: gradually reveal bars\n      for (let k = 1; k <= values.length; k++){\n        drawBars(values.slice(0,k));\n        await sleep(80);\n      }\n      drawBars(values);\n    });\n\n    // download canvas\n    $('downloadBtn').addEventListener('click', () => {\n      const link = document.createElement('a');\n      link.download = 'fibonacci_visualization.png';\n      link.href = canvas.toDataURL('image/png');\n      link.click();\n    });\n\n    // convenience: pressing Enter in number input triggers iterative\n    countNumber.addEventListener('keydown', (e) => { if (e.key === 'Enter') showIterative(); });\n\n    // responsiveness: redraw on resize\n    let resizeTO;\n    window.addEventListener('resize', () => {\n      clearTimeout(resizeTO);\n      resizeTO = setTimeout(() => drawBars(currentValues), 100);\n    });\n\n    // Extra: show golden ratio chip computed\n    (function computePhi(){ const phi = (1 + Math.sqrt(5)) / 2; $('phiChip').textContent = 'φ ≈ ' + phi.toFixed(10); })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Fibonacci Sequence"
    }
  ],
  "topic": "Fibonacci Sequence",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}