{
  "id": "d7b41380-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:25:36.269Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Floyd-Warshall Algorithm Visualization</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n      background: #fefefe;\n      color: #333;\n    }\n    h1 {\n      text-align: center;\n      margin-bottom: 10px;\n    }\n    #graphInput {\n      width: 100%;\n      height: 120px;\n      font-family: monospace;\n      font-size: 1rem;\n      margin-bottom: 10px;\n    }\n    label {\n      font-weight: bold;\n    }\n    button {\n      background-color: #007bff;\n      color: white;\n      border: none;\n      padding: 10px 20px;\n      font-size: 1rem;\n      cursor: pointer;\n      border-radius: 5px;\n      margin: 5px 0;\n    }\n    button:disabled {\n      background-color: #cccccc;\n      cursor: not-allowed;\n    }\n    table {\n      border-collapse: collapse;\n      margin-top: 15px;\n      width: 100%;\n      max-width: 600px;\n    }\n    th, td {\n      border: 1px solid #aaa;\n      padding: 8px;\n      text-align: center;\n      min-width: 40px;\n    }\n    th {\n      background-color: #007bff;\n      color: white;\n      font-weight: bold;\n    }\n    #steps {\n      margin-top: 20px;\n      font-size: 0.9rem;\n      max-height: 320px;\n      overflow-y: auto;\n      background-color: #f7f7f7;\n      border: 1px solid #ddd;\n      padding: 10px;\n      white-space: pre-wrap;\n    }\n    #canvasContainer {\n      text-align: center;\n      margin-top: 20px;\n    }\n    canvas {\n      border: 1px solid #ccc;\n      background: #f9f9f9;\n    }\n    #info {\n      max-width: 700px;\n      margin: 0 auto 20px auto;\n      font-size: 0.95rem;\n      line-height: 1.4;\n      color: #555;\n    }\n    footer {\n      margin-top: 40px;\n      text-align: center;\n      font-size: 0.8rem;\n      color: #888;\n    }\n  </style>\n</head>\n<body>\n  <h1>Floyd-Warshall Algorithm Visualization</h1>\n  <div id=\"info\">\n    <p>\n      Enter the weighted adjacency matrix of a directed graph below.\n      Use <code>INF</code> or <code>Infinity</code> for no direct edge.\n      The matrix should be square, with rows separated by new lines,\n      and values separated by spaces or commas.\n    </p>\n    <p>\n      Example for 4 nodes (0-indexed):\n    </p>\n    <pre>0 3 INF 7\n8 0 2 INF\n5 INF 0 1\n2 INF INF 0\n    </pre>\n  </div>\n  <label for=\"graphInput\">Adjacency Matrix:</label><br />\n  <textarea id=\"graphInput\" aria-label=\"Adjacency Matrix Input\" spellcheck=\"false\">0 3 INF 7\n8 0 2 INF\n5 INF 0 1\n2 INF INF 0</textarea>\n  <br />\n  <button id=\"startBtn\">Start Floyd-Warshall</button>\n  <button id=\"stepBtn\" disabled>Next Step</button>\n  <button id=\"resetBtn\" disabled>Reset</button>\n\n  <div id=\"canvasContainer\">\n    <canvas id=\"graphCanvas\" width=\"600\" height=\"400\" aria-label=\"Graph visualization\"></canvas>\n  </div>\n\n  <div id=\"matrixContainer\">\n    <h2>Distance Matrix (D)</h2>\n    <div id=\"distanceMatrix\"></div>\n  </div>\n  \n  <div id=\"steps\">\n    <strong>Algorithm Steps:</strong>\n    <div id=\"log\"></div>\n  </div>\n\n<script>\n(() => {\n  const INF = Infinity;\n\n  // Elements references\n  const graphInput = document.getElementById('graphInput');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const distanceMatrixDiv = document.getElementById('distanceMatrix');\n  const logDiv = document.getElementById('log');\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  // State variables\n  let graph = null;       // adjacency matrix with numbers/INF\n  let dist = null;        // distance matrix\n  let next = null;        // next matrix for path reconstruction (optional)\n  let n = 0;              // number of vertices\n  let k = 0, i = 0, j = 0; // loop indices for steps\n  let running = false;\n  let stepped = false;\n  let nodesPositions = [];\n\n  // Parse user input into matrix\n  function parseInput(inputText) {\n    const lines = inputText.trim().split('\\n');\n    const matrix = [];\n    for (const line of lines) {\n      // Split by space or comma, filter empty strings\n      const vals = line.trim().split(/[\\s,]+/).filter(v => v.length > 0);\n      matrix.push(vals.map(v => {\n        const val = v.trim().toUpperCase();\n        if (val === 'INF' || val === 'INFINITY') return INF;\n        const num = Number(v);\n        if (isNaN(num)) throw new Error(`Invalid number: ${v}`);\n        return num;\n      }));\n    }\n    // Check square matrix\n    const size = matrix.length;\n    for (const row of matrix) {\n      if (row.length !== size) throw new Error('Matrix must be square');\n    }\n    return matrix;\n  }\n\n  // Create a deep copy matrix\n  function copyMatrix(matrix) {\n    return matrix.map(row => row.slice());\n  }\n\n  // Initialize adjacency and distance matrices\n  function initialize(graphMatrix) {\n    n = graphMatrix.length;\n    graph = graphMatrix;\n    dist = copyMatrix(graph);\n    // Initialize next matrix for path reconstruction:\n    next = [];\n    for(let u=0; u<n; u++){\n      next[u] = [];\n      for(let v=0; v<n; v++){\n        if(u !== v && dist[u][v] !== INF){\n          next[u][v] = v;\n        } else {\n          next[u][v] = null;\n        }\n      }\n    }\n    k = 0;\n    i = 0;\n    j = 0;\n    running = true;\n    stepped = false;\n    logDiv.textContent = '';\n  }\n\n  // Render distance matrix as table\n  function renderDistanceMatrix(distMatrix, highlight=null) {\n    // highlight: {k,i,j} - highlight current k,i,j indices if provided\n    const table = document.createElement('table');\n    const headerRow = document.createElement('tr');\n    const emptyTh = document.createElement('th');\n    emptyTh.textContent = '';\n    headerRow.appendChild(emptyTh);\n    for(let col=0; col<n; col++){\n      const th = document.createElement('th');\n      th.textContent = col;\n      headerRow.appendChild(th);\n    }\n    table.appendChild(headerRow);\n\n    for(let row=0; row<n; row++){\n      const tr = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = row;\n      tr.appendChild(rowHeader);\n      for(let col=0; col<n; col++){\n        const td = document.createElement('td');\n        const val = distMatrix[row][col];\n        td.textContent = val === INF ? '∞' : val.toFixed(2).replace(/\\.00$/, '');\n        if(highlight){\n          if(row === highlight.i && col === highlight.j) {\n            td.style.backgroundColor = '#ffd54f'; // yellow highlight for current element\n            td.style.fontWeight = 'bold';\n          } else if(row === highlight.k || col === highlight.k){\n            td.style.backgroundColor = '#e1f5fe'; // light blue for k-th row/col\n          }\n        }\n        tr.appendChild(td);\n      }\n      table.appendChild(tr);\n    }\n    distanceMatrixDiv.innerHTML = '';\n    distanceMatrixDiv.appendChild(table);\n  }\n\n  // Log messages with automatic scroll\n  function log(message) {\n    logDiv.textContent += message + '\\n';\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Floyd-Warshall step\n  function floydWarshallStep() {\n    if(!running) return false;\n\n    if(k >= n){\n      running = false;\n      log('Algorithm completed.');\n      stepBtn.disabled = true;\n      resetBtn.disabled = false;\n      return false; // algo ended\n    }\n\n    // Explain what is being processed\n    if(j >= n){\n      j = 0;\n      i++;\n    }\n    if(i >= n){\n      i = 0;\n      k++;\n      if(k >= n){\n        running = false;\n        log('Algorithm completed.');\n        stepBtn.disabled = true;\n        resetBtn.disabled = false;\n        renderDistanceMatrix(dist);\n        drawGraph(nodesPositions, graph, dist, k-1, -1, -1);\n        return false;\n      }\n      log(`\\n==> Considering intermediate vertex k = ${k}`);\n    }\n    // Before update, save old value\n    const oldDist = dist[i][j];\n    const proposedDist = dist[i][k] + dist[k][j];\n    if(proposedDist < dist[i][j]){\n      log(`Update dist[${i}][${j}]: ${oldDist === INF ? '∞' : oldDist} > dist[${i}][${k}] + dist[${k}][${j}] = ${(dist[i][k] === INF ? '∞' : dist[i][k])} + ${(dist[k][j] === INF ? '∞' : dist[k][j])} = ${proposedDist.toFixed(2)}`);\n      dist[i][j] = proposedDist;\n      next[i][j] = next[i][k];\n    } else {\n      if(oldDist !== proposedDist && proposedDist !== INF)\n        log(`No update for dist[${i}][${j}]: current = ${oldDist === INF ? '∞' : oldDist}, proposed = ${proposedDist.toFixed(2)}`);\n    }\n\n    renderDistanceMatrix(dist, {k,k,i,j});\n    drawGraph(nodesPositions, graph, dist, k, i, j);\n\n    j++;\n    return true;\n  }\n\n  // Reconstruct path from u to v using next matrix\n  function reconstructPath(u, v) {\n    if(next[u][v] === null) return [];\n    const path = [u];\n    while(u !== v) {\n      u = next[u][v];\n      if(u === null) return [];\n      path.push(u);\n    }\n    return path;\n  }\n\n  // Draw graph using canvas\n  // Show nodes in circle + edges + highlight of relevant edges\n  // k: intermediate vertex index\n  // i,j: current indices to highlight edge i->j or path segments\n  function drawGraph(positions, graph, distMatrix, k, i, j) {\n    const W = canvas.width;\n    const H = canvas.height;\n    ctx.clearRect(0, 0, W, H);\n\n    const radius = 18;\n    const arrowSize = 8;\n\n    // Helper to draw arrow between points\n    function drawArrow(fromX, fromY, toX, toY, color = 'black', width=1, dashed=false){\n      const angle = Math.atan2(toY - fromY, toX - fromX);\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      ctx.lineWidth = width;\n      if(dashed){\n        ctx.setLineDash([5, 5]);\n      } else {\n        ctx.setLineDash([]);\n      }\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      // shorten arrow length by radius*1.1 to not overlap node circle\n      const len = Math.hypot(toX-fromX, toY-fromY);\n      const newToX = fromX + (len - radius*1.1) * Math.cos(angle);\n      const newToY = fromY + (len - radius*1.1) * Math.sin(angle);\n      ctx.lineTo(newToX, newToY);\n      ctx.stroke();\n\n      // Arrowhead\n      ctx.beginPath();\n      ctx.moveTo(newToX, newToY);\n      ctx.lineTo(newToX - arrowSize * Math.cos(angle - Math.PI / 6), newToY - arrowSize * Math.sin(angle - Math.PI / 6));\n      ctx.lineTo(newToX - arrowSize * Math.cos(angle + Math.PI / 6), newToY - arrowSize * Math.sin(angle + Math.PI / 6));\n      ctx.closePath();\n      ctx.fill();\n      ctx.setLineDash([]);\n    }\n\n    // Draw edges\n    for(let u=0; u<n; u++) {\n      for(let v=0; v<n; v++) {\n        if(graph[u][v] !== INF && u !== v) {\n          // Decide style for edge\n          let color = '#bbb';\n          let width = 1;\n          let dashed = false;\n\n          // Highlight current i->j edge in yellow\n          if (u === i && v === j) {\n            color = '#fbc02d'; // amber yellow\n            width = 3;\n          }\n          // Highlight edges used in shortest path involving node k?\n          if(k >= 0 && (u === k || v === k)) {\n            if(color === '#fbc02d') color = '#ff6f00'; // stronger orange if both\n            else color = '#ff9800'; // orange\n            width = Math.max(width, 2);\n          }\n\n          drawArrow(positions[u].x, positions[u].y, positions[v].x, positions[v].y, color, width, dashed);\n\n          // Draw weight near the middle of the edge\n          const mx = (positions[u].x + positions[v].x) / 2;\n          const my = (positions[u].y + positions[v].y) / 2;\n          ctx.font = '12px Arial';\n          ctx.fillStyle = '#222';\n          ctx.strokeStyle = 'white';\n          ctx.lineWidth = 3;\n          ctx.textBaseline = 'middle';\n          ctx.textAlign = 'center';\n\n          // Shadow for text\n          ctx.strokeText(graph[u][v] === INF ? '∞' : graph[u][v].toFixed(2).replace(/\\.00$/,''), mx, my);\n          ctx.fillText(graph[u][v] === INF ? '∞' : graph[u][v].toFixed(2).replace(/\\.00$/,''), mx, my);\n        }\n      }\n    }\n\n    // Draw nodes\n    for(let u=0; u<n; u++) {\n      const pos = positions[u];\n      ctx.beginPath();\n      // Highlight node k in blue\n      if(k === u){\n        ctx.fillStyle = '#2196f3';\n      } else {\n        ctx.fillStyle = '#90caf9';\n      }\n      ctx.strokeStyle = '#1565c0';\n      ctx.lineWidth = 2;\n      ctx.shadowColor = 'rgba(0,0,0,0.2)';\n      ctx.shadowBlur = 4;\n      ctx.shadowOffsetX = 1;\n      ctx.shadowOffsetY = 1;\n      ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n      ctx.stroke();\n      // Write node label\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 14px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(u, pos.x, pos.y);\n    }\n\n  }\n\n  // Calculate node positions in circle\n  function calculateNodePositions(numNodes) {\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = Math.min(canvas.width, canvas.height) / 2 - 50;\n    const positions = [];\n    for(let idx=0; idx < numNodes; idx++){\n      const angle = (2 * Math.PI * idx) / numNodes - Math.PI/2; // start top\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      positions.push({x,y});\n    }\n    return positions;\n  }\n\n  // Event handlers\n  startBtn.addEventListener('click', () => {\n    try {\n      const input = graphInput.value;\n      const matrix = parseInput(input);\n      initialize(matrix);\n      nodesPositions = calculateNodePositions(n);\n      renderDistanceMatrix(dist);\n      drawGraph(nodesPositions, graph, dist, -1, -1, -1);\n      log(`Algorithm started with ${n} vertices.`);\n      startBtn.disabled = true;\n      stepBtn.disabled = false;\n      resetBtn.disabled = false;\n    } catch(e) {\n      alert('Error parsing matrix: ' + e.message);\n    }\n  });\n\n  stepBtn.addEventListener('click', () => {\n    if(running) {\n      let continued = floydWarshallStep();\n      if(!continued){\n        stepBtn.disabled = true;\n      }\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    distanceMatrixDiv.innerHTML = '';\n    logDiv.textContent = '';\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  });\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}