{
  "id": "6b014630-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:30:43.262Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n            line-height: 1.6;\n        }\n        h1, h2 {\n            color: #2c3e50;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .controls {\n            background-color: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .canvas-container {\n            background-color: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            display: flex;\n            justify-content: center;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: #fff;\n        }\n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 8px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            margin-right: 10px;\n            transition: background-color 0.3s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #95a5a6;\n            cursor: not-allowed;\n        }\n        .algorithm-steps {\n            background-color: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            height: 220px;\n            overflow-y: auto;\n        }\n        .step {\n            margin-bottom: 10px;\n            padding: 8px;\n            border-left: 3px solid #3498db;\n            background-color: #f8f9fa;\n        }\n        .node {\n            position: absolute;\n            width: 30px;\n            height: 30px;\n            background-color: #3498db;\n            color: white;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n        }\n        .explanation {\n            background-color: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .legend {\n            display: flex;\n            gap: 20px;\n            margin-top: 10px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n        }\n        .current-node {\n            background-color: #e74c3c;\n        }\n        .visited-node {\n            background-color: #2ecc71;\n        }\n        .mst-edge {\n            background-color: #2ecc71;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Prim's Algorithm Visualization</h1>\n        \n        <div class=\"explanation\">\n            <h2>What is Prim's Algorithm?</h2>\n            <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It starts with an arbitrary node and grows the spanning tree by adding the smallest edge that connects a node in the tree to a node outside the tree.</p>\n        </div>\n        \n        <div class=\"controls\">\n            <h2>Controls</h2>\n            <button id=\"generateGraph\">Generate New Graph</button>\n            <button id=\"startAlgorithm\">Start Algorithm</button>\n            <button id=\"stepAlgorithm\" disabled>Next Step</button>\n            <button id=\"resetAlgorithm\" disabled>Reset</button>\n            <div class=\"legend\">\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n                    <span>Unvisited Node</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>\n                    <span>Current Node</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                    <span>Visited Node / MST Edge</span>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n        </div>\n        \n        <div class=\"algorithm-steps\">\n            <h2>Algorithm Steps</h2>\n            <div id=\"stepsContainer\"></div>\n        </div>\n    </div>\n\n    <script>\n        // Canvas and context\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Control buttons\n        const generateGraphBtn = document.getElementById('generateGraph');\n        const startAlgorithmBtn = document.getElementById('startAlgorithm');\n        const stepAlgorithmBtn = document.getElementById('stepAlgorithm');\n        const resetAlgorithmBtn = document.getElementById('resetAlgorithm');\n        const stepsContainer = document.getElementById('stepsContainer');\n        \n        // Graph data\n        let nodes = [];\n        let edges = [];\n        let mstEdges = [];\n        let visited = [];\n        let currentStep = 0;\n        let algorithmRunning = false;\n        let animationId = null;\n        \n        // Generate a random graph\n        function generateRandomGraph() {\n            nodes = [];\n            edges = [];\n            mstEdges = [];\n            visited = [];\n            currentStep = 0;\n            stepsContainer.innerHTML = '';\n            \n            // Create 8 random nodes\n            for (let i = 0; i < 8; i++) {\n                // Ensure nodes are not too close to each other\n                let x, y, validPosition;\n                do {\n                    validPosition = true;\n                    x = 50 + Math.random() * 700;\n                    y = 50 + Math.random() * 400;\n                    \n                    // Check if this position is too close to existing nodes\n                    for (const node of nodes) {\n                        const dx = node.x - x;\n                        const dy = node.y - y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        if (distance < 80) {\n                            validPosition = false;\n                            break;\n                        }\n                    }\n                } while (!validPosition);\n                \n                nodes.push({ id: i, x: x, y: y });\n            }\n            \n            // Create edges - connect each node to a few others\n            for (let i = 0; i < nodes.length; i++) {\n                // Each node connects to 2-4 other nodes\n                const numConnections = 2 + Math.floor(Math.random() * 3);\n                const connected = new Set();\n                \n                // Ensure we don't connect to ourselves\n                connected.add(i);\n                \n                for (let j = 0; j < numConnections; j++) {\n                    let target;\n                    do {\n                        target = Math.floor(Math.random() * nodes.length);\n                    } while (connected.has(target));\n                    \n                    connected.add(target);\n                    \n                    // Calculate distance as weight\n                    const dx = nodes[i].x - nodes[target].x;\n                    const dy = nodes[i].y - nodes[target].y;\n                    const weight = Math.floor(Math.sqrt(dx * dx + dy * dy) / 10);\n                    \n                    edges.push({ \n                        from: i, \n                        to: target, \n                        weight: weight \n                    });\n                }\n            }\n            \n            // Remove duplicate edges (since we might have added both directions)\n            const uniqueEdges = [];\n            const edgeSet = new Set();\n            \n            for (const edge of edges) {\n                const key1 = `${edge.from}-${edge.to}`;\n                const key2 = `${edge.to}-${edge.from}`;\n                \n                if (!edgeSet.has(key1) && !edgeSet.has(key2)) {\n                    uniqueEdges.push(edge);\n                    edgeSet.add(key1);\n                    edgeSet.add(key2);\n                }\n            }\n            \n            edges = uniqueEdges;\n            drawGraph();\n        }\n        \n        // Draw the graph on canvas\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            for (const edge of edges) {\n                const fromNode = nodes[edge.from];\n                const toNode = nodes[edge.to];\n                \n                // Check if this edge is in MST\n                const isMSTEdge = mstEdges.some(e => \n                    (e.from === edge.from && e.to === edge.to) || \n                    (e.from === edge.to && e.to === edge.from)\n                );\n                \n                ctx.beginPath();\n                ctx.moveTo(fromNode.x, fromNode.y);\n                ctx.lineTo(toNode.x, toNode.y);\n                ctx.strokeStyle = isMSTEdge ? '#2ecc71' : '#bdc3c7';\n                ctx.lineWidth = isMSTEdge ? 3 : 1;\n                ctx.stroke();\n                \n                // Draw weight\n                const midX = (fromNode.x + toNode.x) / 2;\n                const midY = (fromNode.y + toNode.y) / 2;\n                \n                ctx.fillStyle = isMSTEdge ? '#2ecc71' : '#7f8c8d';\n                ctx.font = '12px Arial';\n                ctx.fillText(edge.weight, midX, midY);\n            }\n            \n            // Draw nodes\n            for (let i = 0; i < nodes.length; i++) {\n                const node = nodes[i];\n                \n                ctx.beginPath();\n                ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);\n                \n                // Color based on node state\n                if (visited.includes(i)) {\n                    ctx.fillStyle = '#2ecc71'; // Visited - green\n                } else if (i === currentStep && algorithmRunning) {\n                    ctx.fillStyle = '#e74c3c'; // Current - red\n                } else {\n                    ctx.fillStyle = '#3498db'; // Unvisited - blue\n                }\n                \n                ctx.fill();\n                ctx.strokeStyle = '#2c3e50';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw node ID\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 14px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(i, node.x, node.y);\n            }\n        }\n        \n        // Prim's Algorithm implementation\n        function primsAlgorithm() {\n            if (visited.length === 0) {\n                // Start with node 0\n                visited.push(0);\n                addStep(\"Started with node 0\");\n                return true;\n            }\n            \n            if (visited.length === nodes.length) {\n                addStep(\"Algorithm complete! Minimum spanning tree found.\");\n                algorithmRunning = false;\n                stepAlgorithmBtn.disabled = true;\n                startAlgorithmBtn.disabled = false;\n                return false;\n            }\n            \n            // Find the minimum edge connecting visited and unvisited nodes\n            let minEdge = null;\n            let minWeight = Infinity;\n            \n            for (const edge of edges) {\n                const fromVisited = visited.includes(edge.from);\n                const toVisited = visited.includes(edge.to);\n                \n                // Edge connects visited and unvisited\n                if ((fromVisited && !toVisited) || (!fromVisited && toVisited)) {\n                    if (edge.weight < minWeight) {\n                        minWeight = edge.weight;\n                        minEdge = edge;\n                    }\n                }\n            }\n            \n            if (minEdge) {\n                // Add the edge to MST\n                mstEdges.push(minEdge);\n                \n                // Add the new node to visited\n                const newNode = visited.includes(minEdge.from) ? minEdge.to : minEdge.from;\n                visited.push(newNode);\n                \n                addStep(`Added edge (${minEdge.from}, ${minEdge.to}) with weight ${minEdge.weight} to MST`);\n                addStep(`Added node ${newNode} to visited set`);\n                \n                return true;\n            }\n            \n            return false;\n        }\n        \n        // Add a step to the steps container\n        function addStep(description) {\n            const stepDiv = document.createElement('div');\n            stepDiv.className = 'step';\n            stepDiv.textContent = description;\n            stepsContainer.appendChild(stepDiv);\n            stepsContainer.scrollTop = stepsContainer.scrollHeight;\n        }\n        \n        // Step through the algorithm\n        function stepAlgorithm() {\n            if (primsAlgorithm()) {\n                drawGraph();\n            }\n        }\n        \n        // Run algorithm automatically\n        function runAlgorithm() {\n            if (algorithmRunning) {\n                if (primsAlgorithm()) {\n                    drawGraph();\n                    animationId = setTimeout(runAlgorithm, 1500);\n                } else {\n                    algorithmRunning = false;\n                    stepAlgorithmBtn.disabled = true;\n                    startAlgorithmBtn.disabled = false;\n                }\n            }\n        }\n        \n        // Event listeners\n        generateGraphBtn.addEventListener('click', () => {\n            generateRandomGraph();\n            startAlgorithmBtn.disabled = false;\n            stepAlgorithmBtn.disabled = false;\n            resetAlgorithmBtn.disabled = false;\n            algorithmRunning = false;\n            if (animationId) {\n                clearTimeout(animationId);\n            }\n        });\n        \n        startAlgorithmBtn.addEventListener('click', () => {\n            algorithmRunning = true;\n            startAlgorithmBtn.disabled = true;\n            stepAlgorithmBtn.disabled = true;\n            resetAlgorithmBtn.disabled = false;\n            runAlgorithm();\n        });\n        \n        stepAlgorithmBtn.addEventListener('click', () => {\n            if (!algorithmRunning) {\n                algorithmRunning = true;\n                startAlgorithmBtn.disabled = true;\n                resetAlgorithmBtn.disabled = false;\n            }\n            stepAlgorithm();\n        });\n        \n        resetAlgorithmBtn.addEventListener('click', () => {\n            mstEdges = [];\n            visited = [];\n            currentStep = 0;\n            algorithmRunning = false;\n            stepsContainer.innerHTML = '';\n            startAlgorithmBtn.disabled = false;\n            stepAlgorithmBtn.disabled = false;\n            resetAlgorithmBtn.disabled = true;\n            \n            if (animationId) {\n                clearTimeout(animationId);\n            }\n            \n            drawGraph();\n        });\n        \n        // Initialize\n        generateRandomGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}