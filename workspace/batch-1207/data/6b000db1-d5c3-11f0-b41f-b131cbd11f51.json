{
  "id": "6b000db1-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:30:32.624Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Graph Visualization - Directed & Undirected</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            padding: 20px;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            color: #333;\n        }\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n            overflow: hidden;\n        }\n        header {\n            background: #2c3e50;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }\n        h1 {\n            margin-bottom: 10px;\n        }\n        .description {\n            font-size: 1.1rem;\n            margin-bottom: 20px;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            padding: 20px;\n            background: #ecf0f1;\n            border-bottom: 1px solid #bdc3c7;\n        }\n        button {\n            padding: 10px 20px;\n            border: none;\n            border-radius: 5px;\n            background: #3498db;\n            color: white;\n            font-size: 1rem;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n        button:hover {\n            background: #2980b9;\n            transform: translateY(-2px);\n        }\n        button.active {\n            background: #e74c3c;\n        }\n        .graph-types {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 20px;\n            padding: 20px;\n        }\n        .graph-type {\n            background: #f8f9fa;\n            border-radius: 10px;\n            padding: 15px;\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n        }\n        .canvas-container {\n            display: flex;\n            justify-content: center;\n            padding: 20px;\n        }\n        canvas {\n            border: 1px solid #bdc3c7;\n            border-radius: 10px;\n            background: #f8f9fa;\n        }\n        .info-panel {\n            padding: 20px;\n            background: #f8f9fa;\n            border-top: 1px solid #bdc3c7;\n        }\n        .details {\n            display: none;\n            margin-top: 15px;\n            padding: 15px;\n            background: white;\n            border-radius: 5px;\n            border-left: 4px solid #3498db;\n        }\n        .details.active {\n            display: block;\n        }\n        .graph-item {\n            margin-bottom: 10px;\n            padding: 10px;\n            background: white;\n            border-radius: 5px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n        .graph-item:hover {\n            background: #e3f2fd;\n        }\n        footer {\n            text-align: center;\n            padding: 20px;\n            background: #2c3e50;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Graph Visualization: Directed & Undirected</h1>\n            <p class=\"description\">A visualization tool to understand the differences between directed and undirected graphs.</p>\n        </header>\n        \n        <div class=\"controls\">\n            <button id=\"directedBtn\">Directed Graph</button>\n            <button id=\"undirectedBtn\">Undirected Graph</button>\n            <button id=\"generateBtn\">Generate New Graph</button>\n            <button id=\"clearBtn\">Clear Graph</button>\n        </div>\n        \n        <div class=\"graph-types\">\n            <div class=\"graph-type\">\n                <h2>Directed Graph</h2>\n                <p>A directed graph (or digraph) is a set of vertices connected by edges, where the edges have a direction associated with them.</p>\n                <ul>\n                    <li>Edges have direction (from one vertex to another)</li>\n                    <li>Represented by arrows</li>\n                    <li>Relationships are asymmetric</li>\n                    <li>Examples: Web pages with hyperlinks, social media followers</li>\n                </ul>\n            </div>\n            \n            <div class=\"graph-type\">\n                <h2>Undirected Graph</h2>\n                <p>An undirected graph is a set of vertices connected by edges, where the edges have no direction.</p>\n                <ul>\n                    <li>Edges have no direction (bidirectional)</li>\n                    <li>Represented by simple lines</li>\n                    <li>Relationships are symmetric</li>\n                    <li>Examples: Facebook friends, road networks</li>\n                </ul>\n            </div>\n        </div>\n        \n        <div class=\"canvas-container\">\n            <canvas id=\"graphCanvas\" width=\"800\" height=\"500\"></canvas>\n        </div>\n        \n        <div class=\"info-panel\">\n            <h3>Graph Information</h3>\n            <p id=\"graphInfo\">Select a graph type to see information.</p>\n            <div id=\"vertexDetails\" class=\"details\"></div>\n            <div id=\"edgeDetails\" class=\"details\"></div>\n        </div>\n        \n        <footer>\n            <p>Graph Theory Visualization | Directed & Undirected Graphs</p>\n        </footer>\n    </div>\n\n    <script>\n        // Canvas and context\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Graph state variables\n        let vertices = [];\n        let edges = [];\n        let isDirected = true;\n        let selectedVertex = null;\n        \n        // Initialize the graph\n        function init() {\n            // Set default graph type\n            document.getElementById('directedBtn').classList.add('active');\n            \n            // Generate initial graph\n            generateRandomGraph();\n            \n            // Add event listeners\n            document.getElementById('directedBtn').addEventListener('click', () => {\n                setGraphType(true);\n                document.getElementById('directedBtn').classList.add('active');\n                document.getElementById('undirectedBtn').classList.remove('active');\n            });\n            \n            document.getElementById('undirectedBtn').addEventListener('click', () => {\n                setGraphType(false);\n                document.getElementById('undirectedBtn').classList.add('active');\n                document.getElementById('directedBtn').classList.remove('active');\n            });\n            \n            document.getElementById('generateBtn').addEventListener('click', generateRandomGraph);\n            document.getElementById('clearBtn').addEventListener('click', clearGraph);\n            \n            canvas.addEventListener('click', handleCanvasClick);\n            \n            // Display initial information\n            updateGraphInfo();\n        }\n        \n        // Set graph type (directed or undirected)\n        function setGraphType(directed) {\n            isDirected = directed;\n            redrawGraph();\n            updateGraphInfo();\n        }\n        \n        // Generate a random graph\n        function generateRandomGraph() {\n            vertices = [];\n            edges = [];\n            \n            // Create vertices\n            const vertexCount = Math.floor(Math.random() * 8) + 3; // 3 to 10 vertices\n            for (let i = 0; i < vertexCount; i++) {\n                const x = 50 + Math.random() * (canvas.width - 100);\n                const y = 50 + Math.random() * (canvas.height - 100);\n                vertices.push({ id: i, x: x, y: y, label: String.fromCharCode(65 + i) });\n            }\n            \n            // Create edges\n            const edgeCount = Math.floor(Math.random() * (vertexCount * 2)) + vertexCount;\n            for (let i = 0; i < edgeCount; i++) {\n                const from = Math.floor(Math.random() * vertexCount);\n                let to = Math.floor(Math.random() * vertexCount);\n                \n                // Ensure we don't have self-loops for this example\n                while (to === from) {\n                    to = Math.floor(Math.random() * vertexCount);\n                }\n                \n                // Check if edge already exists\n                const edgeExists = edges.some(edge => \n                    (edge.from === from && edge.to === to) || \n                    (!isDirected && edge.from === to && edge.to === from)\n                );\n                \n                if (!edgeExists) {\n                    edges.push({ from: from, to: to, weight: Math.floor(Math.random() * 10) + 1 });\n                }\n            }\n            \n            redrawGraph();\n            updateGraphInfo();\n        }\n        \n        // Clear the graph\n        function clearGraph() {\n            vertices = [];\n            edges = [];\n            redrawGraph();\n            updateGraphInfo();\n        }\n        \n        // Handle canvas click\n        function handleCanvasClick(event) {\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            \n            // Check if a vertex was clicked\n            for (let i = 0; i < vertices.length; i++) {\n                const vertex = vertices[i];\n                const distance = Math.sqrt((x - vertex.x) ** 2 + (y - vertex.y) ** 2);\n                \n                if (distance <= 20) { // Vertex radius is 20\n                    selectedVertex = vertex;\n                    showVertexDetails(vertex);\n                    redrawGraph();\n                    return;\n                }\n            }\n            \n            // If no vertex was clicked, clear selection\n            selectedVertex = null;\n            document.getElementById('vertexDetails').classList.remove('active');\n            document.getElementById('edgeDetails').classList.remove('active');\n            redrawGraph();\n        }\n        \n        // Show vertex details\n        function showVertexDetails(vertex) {\n            const vertexDetails = document.getElementById('vertexDetails');\n            const edgeDetails = document.getElementById('edgeDetails');\n            \n            // Find edges connected to this vertex\n            const connectedEdges = edges.filter(edge => \n                edge.from === vertex.id || edge.to === vertex.id\n            );\n            \n            vertexDetails.innerHTML = `\n                <h4>Vertex ${vertex.label}</h4>\n                <p>ID: ${vertex.id}</p>\n                <p>Position: (${Math.round(vertex.x)}, ${Math.round(vertex.y)})</p>\n                <p>Degree: ${connectedEdges.length}</p>\n            `;\n            \n            edgeDetails.innerHTML = `\n                <h4>Connected Edges</h4>\n                <ul>\n                    ${connectedEdges.map(edge => {\n                        const fromVertex = vertices[edge.from];\n                        const toVertex = vertices[edge.to];\n                        return `<li>${fromVertex.label} ${isDirected ? '→' : '—'} ${toVertex.label} (Weight: ${edge.weight})</li>`;\n                    }).join('')}\n                </ul>\n            `;\n            \n            vertexDetails.classList.add('active');\n            edgeDetails.classList.add('active');\n        }\n        \n        // Update graph information display\n        function updateGraphInfo() {\n            const graphInfo = document.getElementById('graphInfo');\n            graphInfo.textContent = `\n                Graph Type: ${isDirected ? 'Directed' : 'Undirected'} | \n                Vertices: ${vertices.length} | \n                Edges: ${edges.length} |\n                Density: ${calculateDensity().toFixed(2)}\n            `;\n        }\n        \n        // Calculate graph density\n        function calculateDensity() {\n            const n = vertices.length;\n            if (n <= 1) return 0;\n            \n            const maxEdges = isDirected ? n * (n - 1) : n * (n - 1) / 2;\n            return edges.length / maxEdges;\n        }\n        \n        // Draw the graph\n        function redrawGraph() {\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            edges.forEach(edge => {\n                const fromVertex = vertices[edge.from];\n                const toVertex = vertices[edge.to];\n                \n                drawEdge(fromVertex, toVertex, edge.weight, isDirected);\n            });\n            \n            // Draw vertices\n            vertices.forEach(vertex => {\n                drawVertex(vertex, vertex === selectedVertex);\n            });\n        }\n        \n        // Draw a vertex\n        function drawVertex(vertex, isSelected) {\n            ctx.beginPath();\n            ctx.arc(vertex.x, vertex.y, 20, 0, Math.PI * 2);\n            ctx.fillStyle = isSelected ? '#e74c3c' : '#3498db';\n            ctx.fill();\n            ctx.strokeStyle = '#2c3e50';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            \n            // Draw label\n            ctx.font = '16px Arial';\n            ctx.fillStyle = 'white';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(vertex.label, vertex.x, vertex.y);\n        }\n        \n        // Draw an edge\n        function drawEdge(fromVertex, toVertex, weight, isDirected) {\n            // Calculate angle between vertices\n            const angle = Math.atan2(toVertex.y - fromVertex.y, toVertex.x - fromVertex.x);\n            const startX = fromVertex.x + 20 * Math.cos(angle);\n            const startY = fromVertex.y + 20 * Math.sin(angle);\n            const endX = toVertex.x - 20 * Math.cos(angle);\n            const endY = toVertex.y - 20 * Math.sin(angle);\n            \n            // Draw line\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.strokeStyle = '#2c3e50';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            \n            // Draw arrow for directed graphs\n            if (isDirected) {\n                const arrowLength = 10;\n                const arrowAngle = Math.PI / 6;\n                \n                ctx.beginPath();\n                ctx.moveTo(endX, endY);\n                ctx.lineTo(\n                    endX - arrowLength * Math.cos(angle - arrowAngle),\n                    endY - arrowLength * Math.sin(angle - arrowAngle)\n                );\n                ctx.lineTo(\n                    endX - arrowLength * Math.cos(angle + arrowAngle),\n                    endY - arrowLength * Math.sin(angle + arrowAngle)\n                );\n                ctx.closePath();\n                ctx.fillStyle = '#2c3e50';\n                ctx.fill();\n            }\n            \n            // Draw weight\n            const midX = (fromVertex.x + toVertex.x) / 2;\n            const midY = (fromVertex.y + toVertex.y) / 2;\n            \n            ctx.font = '12px Arial';\n            ctx.fillStyle = '#e74c3c';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(weight, midX, midY);\n        }\n        \n        // Initialize the application\n        window.onload = init;\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}