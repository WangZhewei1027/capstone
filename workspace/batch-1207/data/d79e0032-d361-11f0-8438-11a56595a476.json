{
  "id": "d79e0032-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:13.818Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Nearest Neighbors (KNN) Demonstration</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #fafafa;\n  }\n  h1 {\n    margin: 1rem 0 0.5rem 0;\n  }\n  #container {\n    display: flex;\n    margin: 1rem;\n  }\n  #canvas {\n    border: 1px solid #ccc;\n    background: white;\n    cursor: crosshair;\n  }\n  #controls {\n    margin-left: 20px;\n    max-width: 300px;\n  }\n  label {\n    display: block;\n    margin: 10px 0 5px 0;\n  }\n  input, select, button {\n    width: 100%;\n    padding: 5px;\n    margin-bottom: 10px;\n    font-size: 1rem;\n  }\n  #info {\n    font-size: 0.9rem;\n    margin-top: 10px;\n    max-width: 480px;\n    line-height: 1.3;\n  }\n  .legend {\n    margin-top: 15px;\n  }\n  .legend-item {\n    display: flex;\n    align-items: center;\n    margin: 5px 0;\n  }\n  .color-box {\n    width: 20px;\n    height: 20px;\n    margin-right: 8px;\n    border: 1px solid #555;\n  }\n  #instructions {\n    max-width: 600px;\n    margin-bottom: 10px;\n    font-size: 0.9rem;\n    color: #333;\n  }\n  #resetButton {\n    background-color: #d9534f;\n    border: none;\n    color: white;\n    cursor: pointer;\n  }\n  #resetButton:hover {\n    background-color: #c9302c;\n  }\n</style>\n</head>\n<body>\n<h1>K-Nearest Neighbors (KNN) Interactive Demo</h1>\n<div id=\"instructions\">\n  <strong>Instructions:</strong> Click on the canvas to add training points.<br>\n  Choose a label before adding points, then add multiple points for that class.<br>\n  After adding points, click on the canvas at any location to classify that point.<br>\n  Adjust <em>K</em> to change the number of neighbors considered.<br>\n  Use the \"Reset\" button to clear all points.\n</div>\n<div id=\"container\">\n  <canvas id=\"canvas\" width=\"480\" height=\"480\"></canvas>\n  <div id=\"controls\">\n    <label for=\"labelSelect\">Select Label (Class) to Add:</label>\n    <select id=\"labelSelect\">\n      <option value=\"A\" selected>A</option>\n      <option value=\"B\">B</option>\n      <option value=\"C\">C</option>\n    </select>\n\n    <label for=\"kInput\">Set K (Number of Neighbors):</label>\n    <input type=\"number\" id=\"kInput\" min=\"1\" max=\"20\" value=\"3\" />\n\n    <button id=\"resetButton\">Reset All Points</button>\n\n    <div id=\"info\">\n      <p><strong>Last classified point info:</strong></p>\n      <div id=\"classificationResult\">No classification done yet.</div>\n    </div>\n\n    <div class=\"legend\">\n      <strong>Legend:</strong>\n      <div class=\"legend-item\">\n        <div class=\"color-box\" style=\"background:#e41a1c;\"></div> Label A\n      </div>\n      <div class=\"legend-item\">\n        <div class=\"color-box\" style=\"background:#377eb8;\"></div> Label B\n      </div>\n      <div class=\"legend-item\">\n        <div class=\"color-box\" style=\"background:#4daf4a;\"></div> Label C\n      </div>\n      <div class=\"legend-item\">\n        <canvas id=\"knnPointLegend\" width=\"20\" height=\"20\" style=\"border:1px solid #555;\"></canvas>\n        &nbsp;Classified Point\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const labelSelect = document.getElementById(\"labelSelect\");\n  const kInput = document.getElementById(\"kInput\");\n  const resetButton = document.getElementById(\"resetButton\");\n  const classificationResult = document.getElementById(\"classificationResult\");\n  const knnPointLegend = document.getElementById(\"knnPointLegend\").getContext(\"2d\");\n\n  // Colors for classes\n  const COLORS = {\n    A: \"#e41a1c\", // red-ish\n    B: \"#377eb8\", // blue\n    C: \"#4daf4a\", // green\n  };\n\n  // Data structure to hold training points: {x, y, label}\n  const trainingPoints = [];\n\n  // Last classified point and neighbors\n  let lastClassified = null;\n\n  // Utility - draw a circle\n  function drawCircle(x, y, radius, color, fill = true, lineWidth = 1) {\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    if (fill) {\n      ctx.fillStyle = color;\n      ctx.fill();\n    } else {\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    }\n  }\n\n  // Clear canvas background\n  function clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // draw grid lines\n    drawGrid();\n  }\n\n  // Draw grid for reference\n  function drawGrid() {\n    const step = 40;\n    ctx.strokeStyle = \"#ddd\";\n    ctx.lineWidth = 1;\n    for (let x = step; x < canvas.width; x += step) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvas.height);\n      ctx.stroke();\n    }\n    for (let y = step; y < canvas.height; y += step) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvas.width, y);\n      ctx.stroke();\n    }\n  }\n\n  // Draw all training points\n  function drawTrainingPoints() {\n    for (const pt of trainingPoints) {\n      drawCircle(pt.x, pt.y, 6, COLORS[pt.label]);\n    }\n  }\n\n  // Draw classified point\n  // Highlight neighbors with lines and rings\n  function drawClassifiedPoint(classified, neighbors) {\n    if (!classified) return;\n    const { x, y, label } = classified;\n\n    // Draw neighbors lines and rings\n    neighbors.forEach(n => {\n      // line to neighbor\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(n.x, n.y);\n      ctx.strokeStyle = COLORS[n.label];\n      ctx.lineWidth = 1;\n      ctx.setLineDash([5, 5]);\n      ctx.stroke();\n      ctx.setLineDash([]);\n\n      // circle around neighbor bigger than normal (highlight)\n      drawCircle(n.x, n.y, 10, COLORS[n.label], false, 2);\n    });\n\n    // Draw classified point with a distinct style (bigger, black border)\n    ctx.beginPath();\n    ctx.arc(x, y, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = COLORS[label];\n    ctx.fill();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = \"#222\";\n    ctx.stroke();\n  }\n\n  // Euclidean distance\n  function distance(p1, p2) {\n    return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n  }\n\n  // KNN Classification\n  // Returns {label, neighbors}\n  function knnClassify(point, k) {\n    if (trainingPoints.length === 0) return null;\n    // Compute distances to all training points\n    const distances = trainingPoints.map(pt => ({\n      point: pt,\n      dist: distance(point, pt),\n    }));\n    // Sort by distance ascending\n    distances.sort((a, b) => a.dist - b.dist);\n    // Take first k neighbors\n    const neighbors = distances.slice(0, k).map(d => d.point);\n\n    // Count labels from neighbors\n    const counts = {};\n    for (const n of neighbors) {\n      counts[n.label] = (counts[n.label] || 0) + 1;\n    }\n    // Find the label with max count\n    let maxCount = 0;\n    let chosenLabel = null;\n    for (const label in counts) {\n      if (counts[label] > maxCount) {\n        maxCount = counts[label];\n        chosenLabel = label;\n      }\n    }\n    return { label: chosenLabel, neighbors };\n  }\n\n  // Redraw all\n  function redraw() {\n    clearCanvas();\n    drawTrainingPoints();\n    drawClassifiedPoint(lastClassified, lastClassified ? lastClassified.neighbors : []);\n  }\n\n  // Handle canvas click\n  // If holding Shift: classify point\n  // Else: add training point of current label\n  canvas.addEventListener(\"click\", e => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // We'll use normal click to add point for training\n    // But click while pressing Ctrl or Alt will classify instead for demo\n    // For simplicity here: normal click adds training point\n    // Right click and Shift key click classify? Right click is complex on context menu\n    // Let's say: simply normal click adds training point\n    // Double click classifies point (to avoid modifier keys confusion)\n\n    // But double click will be handled separately\n\n    if (e.detail === 1) {\n      // single click: add training point\n      const label = labelSelect.value;\n      trainingPoints.push({ x, y, label });\n      lastClassified = null;\n      classificationResult.textContent = `Added training point at (${x.toFixed(1)}, ${y.toFixed(1)}) with label \"${label}\".`;\n      redraw();\n    }\n  });\n\n  canvas.addEventListener(\"dblclick\", e => {\n    // Double click classifies point\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    if (trainingPoints.length === 0) {\n      classificationResult.textContent = \"No training points - cannot classify.\";\n      return;\n    }\n\n    const k = Math.min(parseInt(kInput.value, 10) || 3, trainingPoints.length);\n    const classified = knnClassify({ x, y }, k);\n    if (!classified) {\n      classificationResult.textContent = \"Classification failed.\";\n      return;\n    }\n    lastClassified = { x, y, label: classified.label, neighbors: classified.neighbors };\n\n    // Show info\n    let neighborsInfo = classified.neighbors.map((n, i) => {\n      const dist = distance({x,y}, n).toFixed(2);\n      return `${i+1}. (${n.x.toFixed(1)}, ${n.y.toFixed(1)}) Label: ${n.label} Distance: ${dist}`;\n    }).join(\"<br>\");\n\n    classificationResult.innerHTML =\n      `Classified point at (${x.toFixed(1)}, ${y.toFixed(1)}) as <strong>${classified.label}</strong> using k=${k}.<br>` +\n      `<br><strong>Neighbors considered:</strong><br>${neighborsInfo}`;\n\n    redraw();\n  });\n\n  // Reset button\n  resetButton.addEventListener(\"click\", () => {\n    trainingPoints.length = 0;\n    lastClassified = null;\n    classificationResult.textContent = \"All points reset.\";\n    redraw();\n  });\n\n  // Update drawing when k changes (optional)\n  kInput.addEventListener(\"change\", () => {\n    if (lastClassified) {\n      const k = Math.min(parseInt(kInput.value, 10) || 3, trainingPoints.length);\n      const classified = knnClassify({ x: lastClassified.x, y: lastClassified.y }, k);\n      if (classified) {\n        lastClassified.label = classified.label;\n        lastClassified.neighbors = classified.neighbors;\n        classificationResult.innerHTML =\n          `Classified point at (${lastClassified.x.toFixed(1)}, ${lastClassified.y.toFixed(1)}) as <strong>${lastClassified.label}</strong> using k=${k}.<br>` +\n          `<br><strong>Neighbors considered:</strong><br>` +\n          classified.neighbors.map((n, i) => {\n            const dist = distance({x: lastClassified.x, y: lastClassified.y}, n).toFixed(2);\n            return `${i+1}. (${n.x.toFixed(1)}, ${n.y.toFixed(1)}) Label: ${n.label} Distance: ${dist}`;\n          }).join(\"<br>\");\n      }\n      redraw();\n    }\n  });\n\n  // Initial draw\n  clearCanvas();\n\n  // Draw KNN point legend\n  function drawKnnLegend() {\n    const cx = 10, cy = 10;\n    knnPointLegend.clearRect(0, 0, 20, 20);\n    knnPointLegend.beginPath();\n    knnPointLegend.arc(cx, cy, 8, 0, 2 * Math.PI);\n    knnPointLegend.fillStyle = \"#e41a1c\";\n    knnPointLegend.fill();\n    knnPointLegend.lineWidth = 2;\n    knnPointLegend.strokeStyle = \"#222\";\n    knnPointLegend.stroke();\n  }\n  drawKnnLegend();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}