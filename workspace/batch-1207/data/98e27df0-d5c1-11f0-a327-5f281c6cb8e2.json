{
  "id": "98e27df0-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:18:16.114Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Prim's Algorithm Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --muted:#94a3b8;\n    --accent:#3b82f6;\n    --accent-2:#fb923c;\n    --good:#10b981;\n    --danger:#ef4444;\n    --card:#071029;\n    --glass: rgba(255,255,255,0.03);\n  }\n  html,body{height:100%;margin:0;padding:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n  body{background:linear-gradient(180deg,var(--bg),#071225);color:#e6eef8;}\n  .container{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100vh;}\n  .left{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;display:flex;flex-direction:column;align-items:stretch;}\n  .canvas-wrap{flex:1;border-radius:8px;background:var(--card);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;}\n  canvas{background:transparent;display:block;max-width:100%;max-height:100%;}\n  .hint{position:absolute;left:10px;top:10px;background:var(--glass);padding:8px 10px;border-radius:8px;color:var(--muted);font-size:13px}\n  .right{width:380px;display:flex;flex-direction:column;gap:12px;}\n  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;min-height:80px}\n  .controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}\n  label{font-size:13px;color:var(--muted);min-width:110px}\n  input[type=range]{flex:1}\n  .btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer}\n  .btn.primary{background:linear-gradient(180deg,var(--accent),#2563eb);color:white;border:none}\n  .btn.warn{background:linear-gradient(180deg,var(--accent-2),#ef7a2a);color:white;border:none}\n  .small{font-size:13px;color:var(--muted)}\n  .info{display:flex;gap:8px;flex-wrap:wrap}\n  .stat{background:var(--glass);padding:8px;border-radius:8px;min-width:120px}\n  .pq, .log{max-height:200px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;font-size:13px;color:var(--muted)}\n  .pq-item{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px}\n  .pq-weight{font-weight:600;color:white;padding:2px 6px;border-radius:6px;background:rgba(0,0,0,0.25)}\n  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n  .legend .item{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:13px}\n  .swatch{width:18px;height:10px;border-radius:4px;display:inline-block}\n  .pseudocode{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;font-size:13px}\n  .pseudocode div{padding:4px 6px;border-radius:6px}\n  .pseudocode .highlight{background:linear-gradient(90deg, rgba(59,130,246,0.12), rgba(59,130,246,0.06));border-left:3px solid rgba(59,130,246,0.9);color:white}\n  .footer{font-size:13px;color:var(--muted);margin-top:6px}\n  .node-label{font-size:12px}\n  .small-muted{font-size:12px;color:var(--muted)}\n  .top-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}\n  .controls .btn-row{display:flex;gap:8px}\n  .controls select{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:8px}\n  .credits{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}\n  .node-click-hint{position:absolute;right:10px;top:10px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted);font-size:13px}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"left\">\n    <div class=\"top-row\">\n      <div style=\"display:flex;flex-direction:column\">\n        <div style=\"font-weight:600\">Prim's Algorithm — Minimum Spanning Tree</div>\n        <div class=\"small-muted\">Click a node to choose start. Step through or autoplay.</div>\n      </div>\n      <div style=\"display:flex;gap:8px;align-items:center\">\n        <div class=\"small-muted\">Nodes:</div>\n        <div id=\"nodeCountDisplay\" class=\"small-muted\">8</div>\n      </div>\n    </div>\n    <div class=\"canvas-wrap\" id=\"canvasWrap\">\n      <div class=\"hint\" id=\"hint\">Click a node to set start • Step through Prim's algorithm</div>\n      <canvas id=\"graphCanvas\" width=\"900\" height=\"700\"></canvas>\n      <div class=\"node-click-hint\">Start node: <b id=\"startLabel\">None</b></div>\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"panel controls\">\n      <div class=\"row\">\n        <label for=\"nodesRange\">Nodes</label>\n        <input id=\"nodesRange\" type=\"range\" min=\"4\" max=\"18\" value=\"8\">\n        <div style=\"width:36px;text-align:right\" id=\"nodesVal\">8</div>\n      </div>\n      <div class=\"row\">\n        <label for=\"densityRange\">Edge density</label>\n        <input id=\"densityRange\" type=\"range\" min=\"10\" max=\"90\" value=\"45\">\n        <div style=\"width:36px;text-align:right\" id=\"densityVal\">45%</div>\n      </div>\n      <div class=\"row\">\n        <label for=\"maxW\">Max weight</label>\n        <input id=\"maxW\" type=\"range\" min=\"5\" max=\"100\" value=\"40\">\n        <div style=\"width:36px;text-align:right\" id=\"maxWVal\">40</div>\n      </div>\n      <div class=\"row\">\n        <label>Generate</label>\n        <div style=\"display:flex;gap:8px\">\n          <button class=\"btn primary\" id=\"regenBtn\">Generate Graph</button>\n          <button class=\"btn\" id=\"randomStartBtn\">Random Start</button>\n        </div>\n      </div>\n\n      <div style=\"height:8px\"></div>\n\n      <div class=\"row\">\n        <label>Algorithm</label>\n        <div class=\"btn-row\">\n          <button class=\"btn primary\" id=\"stepBtn\">Step</button>\n          <button class=\"btn\" id=\"runBtn\">Auto Run</button>\n          <button class=\"btn warn\" id=\"resetAlgBtn\">Reset</button>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <label for=\"speedRange\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"2000\" value=\"600\">\n        <div style=\"width:56px;text-align:right\" id=\"speedVal\">600ms</div>\n      </div>\n      <div style=\"height:6px\"></div>\n      <div style=\"display:flex;gap:8px;align-items:center\">\n        <div class=\"small-muted\">Priority Queue</div>\n        <div style=\"flex:1\"></div>\n        <div class=\"small-muted\">Total MST Weight:</div>\n        <div style=\"min-width:50px;text-align:right;font-weight:700\" id=\"mstWeight\">0</div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">\n        <div style=\"font-weight:600\">Priority Queue (min-first)</div>\n        <div class=\"small-muted\">Items: <span id=\"pqSize\">0</span></div>\n      </div>\n      <div class=\"pq\" id=\"pqBox\"></div>\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"swatch\" style=\"background:linear-gradient(90deg,var(--accent),#1e40af)\"></span> MST edge</div>\n        <div class=\"item\"><span class=\"swatch\" style=\"background:linear-gradient(90deg,var(--accent-2),#fb7b2f)\"></span> Frontier (in PQ)</div>\n        <div class=\"item\"><span class=\"swatch\" style=\"background:#ef4444\"></span> Considered (popped)</div>\n        <div class=\"item\"><span class=\"swatch\" style=\"background:rgba(255,255,255,0.06)\"></span> Ignored / removed</div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"font-weight:600;margin-bottom:8px\">Pseudocode</div>\n      <div class=\"pseudocode\" id=\"pseudocode\">\n        <div data-line=\"0\">1. Choose a start vertex S. Mark visited[S] = true</div>\n        <div data-line=\"1\">2. Insert all edges incident to S into a min-priority queue PQ (by weight)</div>\n        <div data-line=\"2\">3. While PQ not empty and not all vertices visited:</div>\n        <div data-line=\"3\">&nbsp;&nbsp;&nbsp;a) e = extract-min(PQ)  (edge with smallest weight)</div>\n        <div data-line=\"4\">&nbsp;&nbsp;&nbsp;b) If e connects visited to unvisited vertex v:</div>\n        <div data-line=\"5\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add e to MST; mark v visited; insert edges incident to v into PQ</div>\n        <div data-line=\"6\">&nbsp;&nbsp;&nbsp;c) Else: discard e</div>\n        <div data-line=\"7\">4. Return MST when all vertices are visited</div>\n      </div>\n    </div>\n\n    <div class=\"panel\" style=\"padding:10px\">\n      <div style=\"display:flex;gap:8px;align-items:center;margin-bottom:8px\">\n        <div class=\"stat\"><div class=\"small-muted\">Visited</div><div id=\"visitedCount\" style=\"font-weight:700\">0</div></div>\n        <div class=\"stat\"><div class=\"small-muted\">Edges in MST</div><div id=\"mstCount\" style=\"font-weight:700\">0</div></div>\n        <div class=\"stat\"><div class=\"small-muted\">Steps</div><div id=\"stepsTaken\" style=\"font-weight:700\">0</div></div>\n      </div>\n      <div class=\"log\" id=\"logBox\" style=\"max-height:120px\"></div>\n    </div>\n\n    <div class=\"credits panel\" style=\"text-align:center;font-size:12px\">\n      Interactive visualization of Prim's greedy MST algorithm. Click nodes to choose a start vertex. Edges labeled with weights.\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Canvas and graph rendering\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const wrap = document.getElementById('canvasWrap');\n\n  // UI elements\n  const nodesRange = document.getElementById('nodesRange');\n  const densityRange = document.getElementById('densityRange');\n  const nodesVal = document.getElementById('nodesVal');\n  const densityVal = document.getElementById('densityVal');\n  const maxW = document.getElementById('maxW');\n  const maxWVal = document.getElementById('maxWVal');\n  const regenBtn = document.getElementById('regenBtn');\n  const randomStartBtn = document.getElementById('randomStartBtn');\n  const startLabel = document.getElementById('startLabel');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const resetAlgBtn = document.getElementById('resetAlgBtn');\n  const speedRange = document.getElementById('speedRange');\n  const speedVal = document.getElementById('speedVal');\n  const pqBox = document.getElementById('pqBox');\n  const pqSize = document.getElementById('pqSize');\n  const mstWeightEl = document.getElementById('mstWeight');\n  const visitedCountEl = document.getElementById('visitedCount');\n  const mstCountEl = document.getElementById('mstCount');\n  const stepsTakenEl = document.getElementById('stepsTaken');\n  const logBox = document.getElementById('logBox');\n  const pseudocode = document.getElementById('pseudocode');\n  const nodeCountDisplay = document.getElementById('nodeCountDisplay');\n\n  const hint = document.getElementById('hint');\n\n  // State\n  let W=40;\n  let N=8;\n  let density=0.45;\n  let nodes=[], edges=[], adj=[];\n  let edgeIdCounter=0;\n\n  // Prim state\n  let startNode = null;\n  let visited = [];\n  let visitedCount = 0;\n  let pq = []; // array of edge ids (in PQ)\n  let stepsTaken = 0;\n  let mstEdgeIds = new Set();\n  let totalMstWeight = 0;\n  let lastPoppedEdge = null; // edge id currently popped and under consideration\n  let intervalHandle = null;\n  let running=false;\n  let finished=false;\n\n  function resizeCanvas(){\n    const r = wrap.getBoundingClientRect();\n    canvas.width = Math.floor(r.width - 24);\n    canvas.height = Math.floor(r.height - 24);\n    draw();\n  }\n  window.addEventListener('resize', resizeCanvas);\n\n  // Utility\n  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }\n  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }\n\n  function ensureConnectedGraph(){\n    // Guarantee connected graph by creating a random spanning tree first\n    // then add extra edges according to density\n    edges = [];\n    edgeIdCounter = 0;\n    adj = Array.from({length:N}, ()=>[]);\n    // create nodes positions on circle\n    nodes = [];\n    const cx = canvas.width/2;\n    const cy = canvas.height/2;\n    const radius = Math.min(canvas.width, canvas.height) * 0.38;\n    for(let i=0;i<N;i++){\n      const angle = (i/N) * Math.PI*2 - Math.PI/2;\n      const jitter = 0.6 + Math.random()*0.8;\n      const x = cx + Math.cos(angle)*radius*jitter;\n      const y = cy + Math.sin(angle)*radius*jitter;\n      nodes.push({id:i,x,y});\n    }\n\n    // Build random spanning tree\n    const perm = shuffle(Array.from({length:N}, (_,i)=>i));\n    for(let i=1;i<N;i++){\n      const u = perm[i];\n      const v = perm[randInt(0,i-1)];\n      addEdge(u,v,randInt(1,W));\n    }\n    // Add random extra edges according to density\n    for(let u=0;u<N;u++){\n      for(let v=u+1;v<N;v++){\n        if(edgeExists(u,v)) continue;\n        if(Math.random() < density) addEdge(u,v,randInt(1,W));\n      }\n    }\n    // Ensure all nodes have at least degree 1 (should be true due to spanning tree)\n  }\n\n  function edgeExists(u,v){\n    return adj[u].some(eid => {\n      const e = edges[eid];\n      return (e.u===u && e.v===v) || (e.u===v && e.v===u);\n    });\n  }\n\n  function addEdge(u,v,w){\n    const eid = edgeIdCounter++;\n    const edge = {id:eid,u,v,w,inPQ:false,removed:false,inMST:false,considered:false};\n    edges.push(edge);\n    adj[u].push(eid);\n    adj[v].push(eid);\n  }\n\n  function regenGraph(){\n    N = parseInt(nodesRange.value);\n    nodeCountDisplay.textContent = N;\n    W = parseInt(maxW.value);\n    density = parseInt(densityRange.value)/100;\n    nodesVal.textContent = N;\n    densityVal.textContent = (density*100|0)+'%';\n    maxWVal.textContent = W;\n    ensureConnectedGraph();\n    resetAlgorithmState(true);\n    resizeCanvas();\n    draw();\n  }\n\n  function resetAlgorithmState(hard=false){\n    // resets algorithm state but preserves graph unless hard true\n    startNode = null;\n    startLabel.textContent = 'None';\n    visited = Array.from({length:N}, ()=>false);\n    visitedCount = 0;\n    pq = [];\n    stepsTaken = 0;\n    mstEdgeIds = new Set();\n    totalMstWeight = 0;\n    lastPoppedEdge = null;\n    running = false;\n    finished = false;\n    clearInterval(intervalHandle);\n    intervalHandle = null;\n    runBtn.textContent = 'Auto Run';\n    // reset edge properties\n    for(const e of edges){\n      e.inPQ = false;\n      e.removed = false;\n      e.inMST = false;\n      e.considered = false;\n    }\n    updateStats();\n    logBox.innerHTML = '<div class=\"small-muted\">Algorithm reset. Choose a start node or press Random Start.</div>';\n    highlightPseudo(null);\n    draw();\n  }\n\n  function startWith(nodeIndex){\n    resetAlgorithmState(false);\n    startNode = nodeIndex;\n    startLabel.textContent = 'V' + nodeIndex;\n    // Initialize as first step but don't push edges yet until step pressed - to highlight initialization separately\n    // We'll treat the first Step as initialization: mark visited[start] = true and push edges\n    log(`Start node set to V${nodeIndex}. Press Step to initialize.`);\n    draw();\n  }\n\n  function initializePrim(){\n    if(startNode === null) {\n      log('Choose a start node first.');\n      return false;\n    }\n    if(visited[startNode]) return false;\n    visited[startNode] = true;\n    visitedCount = 1;\n    // push incident edges\n    for(const eid of adj[startNode]){\n      const e = edges[eid];\n      if(!e.removed && !e.inPQ){\n        e.inPQ = true;\n        pq.push(eid);\n      }\n    }\n    sortPQ();\n    highlightPseudo(1);\n    log(`Initialized at V${startNode}. Inserted ${adj[startNode].length} incident edges into PQ.`);\n    updateStats();\n    draw();\n    return true;\n  }\n\n  function sortPQ(){\n    pq.sort((a,b)=> edges[a].w - edges[b].w || (edges[a].id - edges[b].id));\n  }\n\n  function popPQ(){\n    if(pq.length===0) return null;\n    sortPQ();\n    const eid = pq.shift();\n    edges[eid].inPQ = false;\n    return eid;\n  }\n\n  function step(){\n    if(finished){\n      log('Algorithm finished.');\n      return;\n    }\n    // If not initialized (start node not visited), initialize\n    if(startNode === null){\n      log('Choose a start node (click a node) or pick Random Start.');\n      return;\n    }\n    if(!visited[startNode]){\n      // initialization step\n      initializePrim();\n      stepsTaken++;\n      highlightPseudo(2);\n      updateStats();\n      return;\n    }\n\n    // If lastPoppedEdge is null => need to pop one\n    if(lastPoppedEdge === null){\n      if(pq.length === 0){\n        finished = true;\n        highlightPseudo(7); // done\n        log('PQ empty. Algorithm complete.');\n        updateStats();\n        draw();\n        return;\n      }\n      // Pop one\n      const eid = popPQ();\n      if(eid===null){\n        finished=true;\n        log('PQ empty. Algorithm complete.');\n        highlightPseudo(7);\n        updateStats();\n        draw();\n        return;\n      }\n      lastPoppedEdge = eid;\n      edges[eid].considered = true;\n      stepsTaken++;\n      highlightPseudo(3);\n      log(`Consider edge e${eid} (V${edges[eid].u} - V${edges[eid].v}, w=${edges[eid].w})`);\n      updateStats();\n      draw();\n      return;\n    } else {\n      // We have an edge under consideration -> decide accept/discard\n      const eid = lastPoppedEdge;\n      const e = edges[eid];\n      const u = e.u, v = e.v;\n      const uVis = visited[u], vVis = visited[v];\n\n      if(uVis && vVis){\n        // discard\n        e.removed = true;\n        e.considered = false;\n        lastPoppedEdge = null;\n        stepsTaken++;\n        highlightPseudo(6);\n        log(`Discarded e${eid} — both endpoints already visited.`);\n        updateStats();\n        draw();\n        // continue later\n        return;\n      } else {\n        // Accept edge into MST\n        e.inMST = true;\n        e.removed = true;\n        e.considered = false;\n        mstEdgeIds.add(eid);\n        totalMstWeight += e.w;\n        // find new vertex\n        let newV = uVis ? v : u;\n        visited[newV] = true;\n        visitedCount++;\n        // push incident edges of newV\n        let pushed=0;\n        for(const ne of adj[newV]){\n          const edgeN = edges[ne];\n          if(!edgeN.removed && !edgeN.inPQ && !edgeN.inMST){\n            // Only push edges that connect to unvisited vertices maybe; but PQ often holds edges incident to visited nodes that reach unvisited nodes.\n            // However pushing all ensures availability; we still check validity at pop.\n            edgeN.inPQ = true;\n            pq.push(ne);\n            pushed++;\n          }\n        }\n        sortPQ();\n        lastPoppedEdge = null;\n        stepsTaken++;\n        highlightPseudo(4);\n        log(`Accepted e${eid} into MST. New vertex: V${newV}. Inserted ${pushed} incident edges.`);\n        updateStats();\n        draw();\n        if(visitedCount === N){\n          finished = true;\n          highlightPseudo(7);\n          log('All vertices visited. MST complete.');\n          draw();\n        }\n        return;\n      }\n    }\n  }\n\n  function startAutoRun(){\n    if(finished){ log('Already finished. Reset to run again.'); return; }\n    if(startNode === null){ log('Choose a start node first.'); return; }\n    if(running){\n      // stop\n      clearInterval(intervalHandle);\n      running=false;\n      runBtn.textContent = 'Auto Run';\n      return;\n    }\n    running=true;\n    runBtn.textContent = 'Pause';\n    const delay = parseInt(speedRange.value);\n    intervalHandle = setInterval(()=>{\n      if(!running) return;\n      step();\n      if(finished){\n        clearInterval(intervalHandle);\n        running=false;\n        runBtn.textContent = 'Auto Run';\n      }\n    }, delay);\n  }\n\n  function resetAlgorithm(){\n    resetAlgorithmState(false);\n  }\n\n  function log(msg){\n    const el = document.createElement('div');\n    el.textContent = `${stepsTaken>0?('['+stepsTaken+'] '):''}${msg}`;\n    logBox.prepend(el);\n  }\n\n  function updateStats(){\n    pqSize.textContent = pq.length;\n    mstWeightEl.textContent = totalMstWeight;\n    visitedCountEl.textContent = visitedCount;\n    mstCountEl.textContent = mstEdgeIds.size;\n    stepsTakenEl.textContent = stepsTaken;\n  }\n\n  function highlightPseudo(lineIndex){\n    const lines = pseudocode.querySelectorAll('[data-line]');\n    lines.forEach(div => div.classList.remove('highlight'));\n    if(lineIndex === null) return;\n    const el = pseudocode.querySelector('[data-line=\"'+lineIndex+'\"]');\n    if(el) el.classList.add('highlight');\n  }\n\n  // Drawing functions\n  function draw(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // edges\n    for(const e of edges){\n      drawEdge(e);\n    }\n    // nodes\n    for(const n of nodes){\n      drawNode(n);\n    }\n  }\n\n  function drawEdge(e){\n    const u = nodes[e.u], v = nodes[e.v];\n    const x1 = u.x, y1 = u.y, x2 = v.x, y2 = v.y;\n    // color logic\n    let color = 'rgba(200,200,200,0.15)';\n    let width = 2;\n    if(e.inMST) { color = 'linear'; }\n    if(e.considered) { color = '#ef4444'; width = 4; }\n    else if(e.inMST) { color = '#3b82f6'; width = 4; }\n    else if(e.inPQ) { color = '#fb923c'; width = 3; }\n    else if(e.removed) { color = 'rgba(255,255,255,0.06)'; width = 2; }\n\n    ctx.beginPath();\n    ctx.moveTo(x1,y1);\n    ctx.lineTo(x2,y2);\n    ctx.lineWidth = width;\n    if(e.inMST){\n      // gradient for MST\n      const g = ctx.createLinearGradient(x1,y1,x2,y2);\n      g.addColorStop(0, '#60a5fa');\n      g.addColorStop(1, '#1e3a8a');\n      ctx.strokeStyle = g;\n    } else {\n      ctx.strokeStyle = color;\n    }\n    ctx.stroke();\n\n    // weight label at midpoint with small background\n    const mx = (x1+x2)/2;\n    const my = (y1+y2)/2;\n    ctx.font = \"12px ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto\";\n    const txt = String(e.w);\n    const metrics = ctx.measureText(txt);\n    const w = metrics.width + 12;\n    const h = 18;\n    // draw small rounded rect\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(0,0,0,0.6)';\n    roundRect(ctx, mx - w/2, my - h/2, w, h, 6, true, false);\n    // weight text\n    ctx.fillStyle = '#eaf2ff';\n    ctx.fillText(txt, mx - metrics.width/2, my + 4);\n    // If considered, add label\n    if(e.considered){\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(239,68,68,0.14)';\n      roundRect(ctx, mx - w/2 - 2, my - h/2 - 2, w+4, h+4, 8, true, false);\n    }\n  }\n\n  function drawNode(n){\n    const r = 18;\n    const isStart = (startNode === n.id);\n    const vis = visited[n.id];\n    // node circle\n    ctx.beginPath();\n    ctx.arc(n.x,n.y,r,0,Math.PI*2);\n    if(isStart && !vis){\n      ctx.fillStyle = 'rgba(99,102,241,0.14)';\n      ctx.strokeStyle = '#6366f1';\n    } else if(vis){\n      ctx.fillStyle = 'rgba(16,185,129,0.12)';\n      ctx.strokeStyle = '#10b981';\n    } else {\n      ctx.fillStyle = 'rgba(255,255,255,0.02)';\n      ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    }\n    ctx.lineWidth = 2;\n    ctx.fill();\n    ctx.stroke();\n\n    // label circle inside\n    ctx.beginPath();\n    ctx.arc(n.x,n.y,8,0,Math.PI*2);\n    if(vis) ctx.fillStyle = '#10b981';\n    else if(isStart) ctx.fillStyle = '#6366f1';\n    else ctx.fillStyle = '#1e293b';\n    ctx.fill();\n\n    // node id text\n    ctx.fillStyle = '#e6eef8';\n    ctx.font = '12px ui-sans-serif, system-ui';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('V'+n.id, n.x, n.y);\n\n    // hoverable region is same - we detect clicks separately using distance\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke){\n    if (typeof stroke === 'undefined') stroke = true;\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y,   x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x,   y+h, r);\n    ctx.arcTo(x,   y+h, x,   y,   r);\n    ctx.arcTo(x,   y,   x+w, y,   r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Canvas interaction: click to choose start\n  canvas.addEventListener('click', (ev)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    // find node clicked (within radius)\n    for(const n of nodes){\n      const dx = x - n.x, dy = y - n.y;\n      if(Math.sqrt(dx*dx+dy*dy) < 22){\n        startWith(n.id);\n        draw();\n        return;\n      }\n    }\n  });\n\n  // UI events\n  nodesRange.addEventListener('input', ()=>{\n    nodesVal.textContent = nodesRange.value;\n    nodeCountDisplay.textContent = nodesRange.value;\n  });\n  nodesRange.addEventListener('change', regenGraph);\n  densityRange.addEventListener('input', ()=>{\n    densityVal.textContent = densityRange.value + '%';\n  });\n  densityRange.addEventListener('change', regenGraph);\n  maxW.addEventListener('input', ()=>{ maxWVal.textContent = maxW.value; });\n  maxW.addEventListener('change', regenGraph);\n\n  regenBtn.addEventListener('click', regenGraph);\n  randomStartBtn.addEventListener('click', ()=>{\n    if(nodes.length===0) return;\n    const r = randInt(0, N-1);\n    startWith(r);\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(running){\n      clearInterval(intervalHandle);\n      running=false;\n      runBtn.textContent='Auto Run';\n    }\n    step();\n  });\n\n  runBtn.addEventListener('click', ()=>{\n    startAutoRun();\n  });\n\n  resetAlgBtn.addEventListener('click', ()=>{\n    resetAlgorithm();\n  });\n\n  speedRange.addEventListener('input', ()=>{\n    speedVal.textContent = speedRange.value + 'ms';\n  });\n\n  // PQ box rendering\n  function renderPQ(){\n    pqBox.innerHTML = '';\n    // show entries with weight and endpoints\n    // We'll show edges in pq sorted\n    const pqSorted = pq.slice().sort((a,b)=>edges[a].w - edges[b].w);\n    for(const eid of pqSorted){\n      const e = edges[eid];\n      const div = document.createElement('div');\n      div.className = 'pq-item';\n      const left = document.createElement('div');\n      left.textContent = `e${eid}: V${e.u} - V${e.v}`;\n      left.style.color = 'var(--muted)';\n      const right = document.createElement('div');\n      right.className = 'pq-weight';\n      right.textContent = e.w;\n      div.appendChild(left);\n      div.appendChild(right);\n      pqBox.appendChild(div);\n    }\n    pqSize.textContent = pqSorted.length;\n  }\n\n  // Periodic draw update to show PQ & stats\n  function tick(){\n    renderPQ();\n    updateStats();\n    draw();\n    requestAnimationFrame(tick);\n  }\n\n  // Initial setup\n  nodesRange.value = N;\n  nodesVal.textContent = N;\n  densityRange.value = 45;\n  densityVal.textContent = '45%';\n  maxW.value = W;\n  maxWVal.textContent = W;\n  speedVal.textContent = speedRange.value + 'ms';\n  nodeCountDisplay.textContent = N;\n\n  // Kick off\n  window.addEventListener('load', ()=>{\n    regenGraph();\n    resizeCanvas();\n    requestAnimationFrame(tick);\n  });\n\n  // Expose some for debugging\n  window._primDemo = {\n    step, startAutoRun, regenGraph, resetAlgorithm\n  };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}