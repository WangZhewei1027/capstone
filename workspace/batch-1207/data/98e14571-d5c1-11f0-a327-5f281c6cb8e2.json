{
  "id": "98e14571-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:41.308Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Red-Black Tree Visualizer</title>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 0; padding: 0; display: flex; height: 100vh; }\n  #sidebar { width: 360px; padding: 16px; box-sizing: border-box; border-right: 1px solid #ddd; overflow: auto; background: #fafafa; }\n  #main { flex: 1; display: flex; flex-direction: column; }\n  h1 { font-size: 18px; margin: 4px 0 12px; }\n  p { margin: 8px 0; color: #333; font-size: 13px; }\n  label { font-size: 13px; display:block; margin-top:8px; }\n  input[type=\"number\"] { width: 140px; padding:6px; font-size:14px;}\n  button { padding: 8px 10px; margin:6px 6px 6px 0; font-size:13px; }\n  .controls { margin-top:8px; }\n  #svgwrap { flex: 1; position: relative; }\n  svg { width: 100%; height: 100%; background: linear-gradient(#fff, #fbfbfb); }\n  .legend { font-size: 13px; margin-top:12px; background:#fff;padding:8px;border-radius:6px;border:1px solid #eee; }\n  .small { font-size:12px; color:#555; }\n  .code { font-family: monospace; background:#f7f7f7; padding:6px; border-radius:4px; display:inline-block; font-size:12px;}\n  #message { margin-top:8px; font-size:13px; min-height:20px; color:#333; }\n  .footer { padding:8px; font-size:12px; color:#666; border-top:1px solid #eee; background:#fafafa; }\n  .btn-primary { background:#007bff; color:white; border: none; border-radius:4px; }\n  .btn-danger { background:#dc3545; color:white; border:none; border-radius:4px; }\n  .btn-ghost { background:transparent; border:1px solid #ddd; border-radius:4px; color:#333;}\n  .status { font-size:12px; color:#444; margin-top:6px; }\n  .control-row { display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap; }\n  input[type=\"range\"] { width:140px; }\n</style>\n</head>\n<body>\n  <div id=\"sidebar\">\n    <h1>Red-Black Tree Visualizer</h1>\n    <p class=\"small\">\n      This interactive demo implements a Red-Black Tree (RBT). You can insert and delete integer keys,\n      step through the fix-up operations (rotations and recolorings), and play an animation of the algorithm.\n    </p>\n\n    <label>Key (integer)</label>\n    <div class=\"control-row\">\n      <input type=\"number\" id=\"keyInput\" value=\"50\">\n      <button id=\"insertBtn\" class=\"btn-primary\">Insert</button>\n      <button id=\"deleteBtn\" class=\"btn-danger\">Delete</button>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"randBtn\" class=\"btn-ghost\">Insert Random</button>\n      <button id=\"bulkBtn\" class=\"btn-ghost\">Insert Sample</button>\n      <button id=\"clearBtn\" class=\"btn-ghost\">Clear</button>\n    </div>\n\n    <div style=\"margin-top:10px;\">\n      <label>Animation controls</label>\n      <div class=\"control-row\">\n        <button id=\"stepBack\">⟲ Prev</button>\n        <button id=\"playPause\">▶ Play</button>\n        <button id=\"stepForward\">Next ⟳</button>\n        <label style=\"margin-left:6px;\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"0.2\" max=\"2.5\" step=\"0.1\" value=\"1\">\n      </div>\n      <div id=\"message\" class=\"small\"></div>\n    </div>\n\n    <div class=\"legend\">\n      <div style=\"display:flex;align-items:center;gap:8px;margin-bottom:6px;\">\n        <div style=\"width:18px;height:18px;border-radius:50%;background:#d33;\"></div><div>Red node</div>\n      </div>\n      <div style=\"display:flex;align-items:center;gap:8px;\">\n        <div style=\"width:18px;height:18px;border-radius:50%;background:#111;border:2px solid #444;\"></div><div>Black node</div>\n      </div>\n      <p class=\"small\" style=\"margin-top:8px;\">\n        Highlights during animation:\n        <ul style=\"margin:6px 0 0 18px;padding:0;\">\n          <li>Yellow ring: node(s) currently considered</li>\n          <li>Blue ring: rotation target</li>\n        </ul>\n      </p>\n    </div>\n\n    <div style=\"margin-top:12px;\">\n      <b>Notes</b>\n      <p class=\"small\">\n        This demo uses the classic CLRS algorithms: insert with color fix-ups and rotations; deletion with transplant and fix-up.\n        Duplicate keys are not allowed. Use small trees to follow the steps.\n      </p>\n    </div>\n\n    <div class=\"footer\">\n      Implementation: JavaScript (single-file). Visual layout computed by in-order spacing and depth.\n    </div>\n  </div>\n\n  <div id=\"main\">\n    <div id=\"svgwrap\">\n      <svg id=\"canvas\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n    </div>\n  </div>\n\n<script>\n/*\n  Red-Black Tree visualizer (single-file).\n  - Supports insertion and deletion (CLRS algorithms)\n  - Records snapshots during fixup operations for step-by-step animation\n  - Visualizes with SVG: nodes, edges, colors, highlights\n*/\n\n(function(){\n  // --- Utility ---\n  function el(id){ return document.getElementById(id); }\n  function uidGen(){ let n=1; return ()=> n++; }\n  const genUid = uidGen();\n\n  // --- Colors ---\n  const RED = 'red';\n  const BLACK = 'black';\n\n  // --- Node constructor ---\n  function Node(key, color, nil){\n    this.key = key;\n    this.color = color || RED;\n    this.left = nil;\n    this.right = nil;\n    this.parent = nil;\n    this.uid = genUid();\n  }\n\n  // --- RBT Class ---\n  function RBTree(snapshotter){\n    // sentinel NIL node (shared)\n    this.NIL = { color: BLACK, left: null, right: null, parent: null, uid: 0, isNil: true };\n    this.root = this.NIL;\n    this.snapshotter = snapshotter; // function to call with message/highlights\n  }\n\n  RBTree.prototype.leftRotate = function(x){\n    const y = x.right;\n    // rotate\n    x.right = y.left;\n    if (y.left !== this.NIL) y.left.parent = x;\n    y.parent = x.parent;\n    if (x.parent === this.NIL) this.root = y;\n    else if (x === x.parent.left) x.parent.left = y;\n    else x.parent.right = y;\n    y.left = x;\n    x.parent = y;\n    // snapshot: rotation happened\n    this.snapshotter('Left rotation at node ' + x.key, { rotate: [x.uid, y.uid], highlight: [x.uid, y.uid], type: 'rotate' });\n  };\n\n  RBTree.prototype.rightRotate = function(y){\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== this.NIL) x.right.parent = y;\n    x.parent = y.parent;\n    if (y.parent === this.NIL) this.root = x;\n    else if (y === y.parent.right) y.parent.right = x;\n    else y.parent.left = x;\n    x.right = y;\n    y.parent = x;\n    this.snapshotter('Right rotation at node ' + y.key, { rotate: [y.uid, x.uid], highlight: [y.uid, x.uid], type: 'rotate' });\n  };\n\n  RBTree.prototype.insert = function(key){\n    // normal BST insert\n    let z = new Node(key, RED, this.NIL);\n    z.left = this.NIL; z.right = this.NIL;\n    let y = this.NIL;\n    let x = this.root;\n    while (x !== this.NIL){\n      y = x;\n      if (z.key < x.key) x = x.left;\n      else x = x.right;\n    }\n    z.parent = y;\n    if (y === this.NIL) this.root = z;\n    else if (z.key < y.key) y.left = z;\n    else y.right = z;\n\n    this.snapshotter('Inserted ' + key + ' as red node', { highlight: [z.uid] });\n    this.insertFixup(z);\n  };\n\n  RBTree.prototype.insertFixup = function(z){\n    while (z.parent.color === RED){\n      if (z.parent === z.parent.parent.left){\n        let y = z.parent.parent.right;\n        // Case 1: uncle is red\n        if (y.color === RED){\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          this.snapshotter('Recolor: parent & uncle -> BLACK, grandparent -> RED', { highlight: [z.parent.uid, y.uid, z.parent.parent.uid] });\n          z = z.parent.parent;\n        } else {\n          // Case 2: z is right child\n          if (z === z.parent.right){\n            z = z.parent;\n            this.leftRotate(z);\n          }\n          // Case 3\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.snapshotter('Prepare to right rotate (case 3)', { highlight: [z.parent.uid, z.parent.parent.uid] });\n          this.rightRotate(z.parent.parent);\n        }\n      } else {\n        // symmetric\n        let y = z.parent.parent.left;\n        if (y.color === RED){\n          z.parent.color = BLACK;\n          y.color = BLACK;\n          z.parent.parent.color = RED;\n          this.snapshotter('Recolor: parent & uncle -> BLACK, grandparent -> RED (mirror)', { highlight: [z.parent.uid, y.uid, z.parent.parent.uid] });\n          z = z.parent.parent;\n        } else {\n          if (z === z.parent.left){\n            z = z.parent;\n            this.rightRotate(z);\n          }\n          z.parent.color = BLACK;\n          z.parent.parent.color = RED;\n          this.snapshotter('Prepare to left rotate (case 3 mirror)', { highlight: [z.parent.uid, z.parent.parent.uid] });\n          this.leftRotate(z.parent.parent);\n        }\n      }\n    }\n    this.root.color = BLACK;\n    this.snapshotter('Root recolored BLACK', { highlight: [this.root.uid] });\n  };\n\n  RBTree.prototype.transplant = function(u, v){\n    if (u.parent === this.NIL) this.root = v;\n    else if (u === u.parent.left) u.parent.left = v;\n    else u.parent.right = v;\n    v.parent = u.parent;\n  };\n\n  RBTree.prototype.minimum = function(x){\n    while (x.left !== this.NIL) x = x.left;\n    return x;\n  };\n\n  RBTree.prototype.delete = function(key){\n    // find node\n    let z = this.root;\n    while (z !== this.NIL && z.key !== key){\n      z = (key < z.key) ? z.left : z.right;\n    }\n    if (z === this.NIL){\n      this.snapshotter('Key ' + key + ' not found', {});\n      return false;\n    }\n    this.snapshotter('Deleting node ' + key, { highlight: [z.uid] });\n\n    let y = z;\n    const yOriginalColor = y.color;\n    let x;\n    if (z.left === this.NIL){\n      x = z.right;\n      this.transplant(z, z.right);\n    } else if (z.right === this.NIL){\n      x = z.left;\n      this.transplant(z, z.left);\n    } else {\n      y = this.minimum(z.right);\n      const oldYuid = y.uid;\n      let ycolorBefore = y.color;\n      x = y.right;\n      if (y.parent === z){\n        x.parent = y;\n      } else {\n        this.transplant(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.transplant(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n      y.color = z.color;\n      this.snapshotter('Replaced deleted node with successor ' + y.key, { highlight: [y.uid, z.uid] });\n      // Note: yOriginalColor was ycolorBefore\n      if (ycolorBefore === BLACK) {\n        this.deleteFixup(x);\n      }\n      return true;\n    }\n    if (yOriginalColor === BLACK){\n      this.deleteFixup(x);\n    }\n    return true;\n  };\n\n  RBTree.prototype.deleteFixup = function(x){\n    while (x !== this.root && x.color === BLACK){\n      if (x === x.parent.left){\n        let w = x.parent.right;\n        // Case 1\n        if (w.color === RED){\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.snapshotter('Delete fixup: case 1, rotate left', { highlight: [w.uid, x.parent.uid], type: 'rotate' });\n          this.leftRotate(x.parent);\n          w = x.parent.right;\n        }\n        if (w.left.color === BLACK && w.right.color === BLACK){\n          w.color = RED;\n          this.snapshotter('Delete fixup: case 2, recolor sibling to RED', { highlight: [w.uid] });\n          x = x.parent;\n        } else {\n          if (w.right.color === BLACK){\n            w.left.color = BLACK;\n            w.color = RED;\n            this.snapshotter('Delete fixup: case 3, rotate right sibling', { highlight: [w.uid, w.left.uid], type: 'rotate' });\n            this.rightRotate(w);\n            w = x.parent.right;\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.right.color = BLACK;\n          this.snapshotter('Delete fixup: case 4, rotate left parent', { highlight: [x.parent.uid, w.uid], type: 'rotate' });\n          this.leftRotate(x.parent);\n          x = this.root;\n        }\n      } else {\n        // mirror\n        let w = x.parent.left;\n        if (w.color === RED){\n          w.color = BLACK;\n          x.parent.color = RED;\n          this.snapshotter('Delete fixup (mirror): case 1, rotate right', { highlight: [w.uid, x.parent.uid], type: 'rotate' });\n          this.rightRotate(x.parent);\n          w = x.parent.left;\n        }\n        if (w.right.color === BLACK && w.left.color === BLACK){\n          w.color = RED;\n          this.snapshotter('Delete fixup (mirror): case 2, recolor sibling to RED', { highlight: [w.uid] });\n          x = x.parent;\n        } else {\n          if (w.left.color === BLACK){\n            w.right.color = BLACK;\n            w.color = RED;\n            this.snapshotter('Delete fixup (mirror): case 3, rotate left sibling', { highlight: [w.uid, w.right.uid], type: 'rotate' });\n            this.leftRotate(w);\n            w = x.parent.left;\n          }\n          w.color = x.parent.color;\n          x.parent.color = BLACK;\n          w.left.color = BLACK;\n          this.snapshotter('Delete fixup (mirror): case 4, rotate right parent', { highlight: [x.parent.uid, w.uid], type: 'rotate' });\n          this.rightRotate(x.parent);\n          x = this.root;\n        }\n      }\n    }\n    x.color = BLACK;\n    this.snapshotter('Finished delete fixup, recolor node BLACK', { highlight: [x.uid] });\n  };\n\n  // --- Snapshotting & Visualization data conversion ---\n  function makeSnapshotFunction(collectSnapshot){\n    return function(message, opts){\n      collectSnapshot(message || '', opts || {});\n    };\n  }\n\n  // Convert current tree to plain serializable object for snapshot\n  function serializeTree(root, NIL){\n    // We'll walk nodes and create shallow object copies with UIDs and key/color and relationships via uid references\n    const nodes = {};\n    function walk(n){\n      if (!n || n === NIL) return;\n      nodes[n.uid] = { uid: n.uid, key: n.key, color: n.color, left: (n.left===NIL?0:n.left.uid), right: (n.right===NIL?0:n.right.uid), parent: (n.parent===NIL?0:n.parent.uid) };\n      walk(n.left);\n      walk(n.right);\n    }\n    walk(root);\n    return { nodes: nodes, rootUid: root===NIL?0:root.uid };\n  }\n\n  // For rendering: compute x positions by in-order index and y by depth\n  function layoutFromSnapshot(snapshot){\n    const nodes = snapshot.nodes;\n    const rootUid = snapshot.rootUid;\n    const pos = {};\n    let xCounter = 0;\n    function inorder(u, depth){\n      if (!u || u===0) return;\n      const node = nodes[u];\n      if (!node) return;\n      inorder(node.left, depth+1);\n      xCounter++;\n      pos[u] = { xIndex: xCounter, depth: depth, key: node.key, color: node.color, uid: u, left: node.left, right: node.right, parent: node.parent };\n      inorder(node.right, depth+1);\n    }\n    inorder(rootUid, 0);\n    // compute pixel coordinates:\n    const spacingX = 60;\n    const spacingY = 80;\n    for (const k in pos){\n      pos[k].x = 40 + pos[k].xIndex * spacingX;\n      pos[k].y = 30 + pos[k].depth * spacingY;\n    }\n    return { positions: pos, rootUid: rootUid };\n  }\n\n  // --- Renderer ---\n  function Renderer(svgEl){\n    this.svg = svgEl;\n    this.width = 2000; this.height = 1000;\n    this.svg.setAttribute('viewBox', '0 0 ' + this.width + ' ' + this.height);\n  }\n\n  Renderer.prototype.clear = function(){\n    while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);\n  };\n\n  Renderer.prototype.drawSnapshot = function(snapshot, opts){\n    opts = opts || {};\n    this.clear();\n    const layout = layoutFromSnapshot(snapshot);\n    const pos = layout.positions;\n    // Compute bounding box to adjust viewbox if needed\n    let minX=Infinity, maxX=0, maxY=0;\n    for (const k in pos){ const p=pos[k]; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }\n    if (minX===Infinity){ // empty tree\n      // draw nothing, show message center\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n      t.setAttribute('x', this.width/2); t.setAttribute('y', this.height/2);\n      t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','16'); t.setAttribute('fill','#666'); t.textContent='(empty tree)';\n      g.appendChild(t); this.svg.appendChild(g);\n      return;\n    }\n    const margin = 40;\n    const vbX = Math.max(0, minX - margin);\n    const vbY = 0;\n    const vbW = Math.min(this.width, (maxX + margin) - vbX);\n    const vbH = Math.min(this.height, (maxY + margin) - vbY + 120);\n    this.svg.setAttribute('viewBox', vbX + ' ' + vbY + ' ' + vbW + ' ' + vbH);\n\n    // draw edges\n    for (const k in pos){\n      const p = pos[k];\n      if (p.left && pos[p.left]){\n        drawLine(this.svg, p.x, p.y, pos[p.left].x, pos[p.left].y);\n      }\n      if (p.right && pos[p.right]){\n        drawLine(this.svg, p.x, p.y, pos[p.right].x, pos[p.right].y);\n      }\n    }\n\n    // Draw nodes (so they overlay edges)\n    for (const k in pos){\n      const p = pos[k];\n      const isRed = (p.color === RED);\n      drawNode(this.svg, p.x, p.y, p.key, isRed, opts, p.uid);\n    }\n\n    // highlights (rings)\n    if (opts && opts.highlights){\n      opts.highlights.forEach(h => {\n        const p = pos[h];\n        if (p) drawRing(this.svg, p.x, p.y, h === opts.rotate ? '#17a2b8' : '#f1c40f');\n      });\n    }\n    // message\n    if (opts && opts.message){\n      const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n      t.setAttribute('x', vbX + 10); t.setAttribute('y', vbH - 10);\n      t.setAttribute('font-size','13'); t.setAttribute('fill','#333');\n      t.textContent = opts.message;\n      this.svg.appendChild(t);\n    }\n  };\n\n  function drawLine(svg, x1,y1,x2,y2){\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1', x1); line.setAttribute('y1', y1+14);\n    line.setAttribute('x2', x2); line.setAttribute('y2', y2-18);\n    line.setAttribute('stroke', '#888'); line.setAttribute('stroke-width','1.5');\n    svg.appendChild(line);\n  }\n\n  function drawNode(svg,x,y,key,isRed, opts, uid){\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform','translate(0,0)');\n    // circle\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('cx', x); circle.setAttribute('cy', y);\n    circle.setAttribute('r', 18);\n    circle.setAttribute('fill', isRed ? '#d33' : '#111');\n    circle.setAttribute('stroke', isRed ? '#a00' : '#444');\n    circle.setAttribute('stroke-width', isRed ? '2' : '3');\n    g.appendChild(circle);\n    // text\n    const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n    t.setAttribute('x', x); t.setAttribute('y', y+5);\n    t.setAttribute('text-anchor','middle');\n    t.setAttribute('font-size','12');\n    t.setAttribute('fill', isRed ? '#fff' : '#fff');\n    t.textContent = key;\n    g.appendChild(t);\n    // small uid (optional)\n    // append\n    svg.appendChild(g);\n  }\n\n  function drawRing(svg,x,y,color){\n    const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    ring.setAttribute('cx', x); ring.setAttribute('cy', y);\n    ring.setAttribute('r', 28);\n    ring.setAttribute('fill', 'none');\n    ring.setAttribute('stroke', color || '#f1c40f');\n    ring.setAttribute('stroke-width','4');\n    ring.setAttribute('stroke-opacity','0.9');\n    ring.setAttribute('stroke-linecap','round');\n    svg.appendChild(ring);\n  }\n\n  // --- Snapshot manager ---\n  function SnapshotManager(tree, renderer){\n    this.tree = tree;\n    this.renderer = renderer;\n    this.snapshots = []; // each: {treeSerialized, message, highlights:[], rotate?}\n    this.currentIndex = -1;\n  }\n\n  SnapshotManager.prototype.collect = function(message, opts){\n    const ser = serializeTree(this.tree.root, this.tree.NIL);\n    const highlights = (opts && opts.highlight) ? opts.highlight.slice() : [];\n    const rotate = (opts && opts.rotate) ? opts.rotate.slice() : null;\n    const snap = { tree: ser, message: message, highlights: highlights, rotate: (rotate?rotate[0]:null) || null, meta: opts.type||null };\n    this.snapshots.push(snap);\n    this.currentIndex = this.snapshots.length - 1;\n    this.renderCurrent();\n  };\n\n  SnapshotManager.prototype.reset = function(){\n    this.snapshots = [];\n    this.currentIndex = -1;\n    // initial empty snapshot\n    const ser = serializeTree(this.tree.root, this.tree.NIL);\n    this.snapshots.push({ tree: ser, message: 'Initial', highlights: [], rotate: null });\n    this.currentIndex = 0;\n    this.renderCurrent();\n  };\n\n  SnapshotManager.prototype.renderCurrent = function(){\n    if (this.currentIndex < 0 || this.currentIndex >= this.snapshots.length) return;\n    const snap = this.snapshots[this.currentIndex];\n    this.renderer.drawSnapshot(snap.tree, { message: snap.message, highlights: snap.highlights, rotate: snap.rotate });\n    updateMessage('Step ' + (this.currentIndex+1) + ' / ' + this.snapshots.length + ': ' + (snap.message||''));\n  };\n\n  SnapshotManager.prototype.step = function(delta){\n    if (this.snapshots.length===0) return;\n    this.currentIndex = Math.max(0, Math.min(this.snapshots.length-1, this.currentIndex + delta));\n    this.renderCurrent();\n  };\n\n  SnapshotManager.prototype.play = function(speed, onDone){\n    if (this.playTimer) { clearInterval(this.playTimer); this.playTimer = null; return; }\n    const interval = Math.max(200, 800 / speed);\n    this.playTimer = setInterval(() => {\n      if (this.currentIndex >= this.snapshots.length - 1){ clearInterval(this.playTimer); this.playTimer = null; if (onDone) onDone(); return; }\n      this.step(1);\n    }, interval);\n  };\n  SnapshotManager.prototype.stop = function(){ if (this.playTimer){ clearInterval(this.playTimer); this.playTimer=null; } };\n\n  // --- UI wiring ---\n  const svg = el('canvas');\n  const renderer = new Renderer(svg);\n  let snapshotManager, tree;\n\n  function init(){\n    snapshotManager = new SnapshotManager(null, renderer);\n    tree = new RBTree(makeSnapshotFunction((msg, opts)=> snapshotManager.collect(msg, opts)));\n    snapshotManager.tree = tree;\n    snapshotManager.reset();\n    attachHandlers();\n  }\n\n  function attachHandlers(){\n    el('insertBtn').addEventListener('click', ()=> {\n      const val = Number(el('keyInput').value);\n      if (!Number.isFinite(val)){ updateMessage('Enter a valid integer.'); return; }\n      // prevent duplicate\n      if (existsInTree(tree, val)){ updateMessage('Key ' + val + ' already exists.'); return; }\n      tree.insert(val);\n    });\n\n    el('deleteBtn').addEventListener('click', ()=> {\n      const val = Number(el('keyInput').value);\n      if (!Number.isFinite(val)){ updateMessage('Enter a valid integer.'); return; }\n      tree.delete(val);\n    });\n\n    el('randBtn').addEventListener('click', ()=> {\n      const val = Math.floor(Math.random()*90)+10;\n      if (existsInTree(tree, val)){ updateMessage('Random value existed, try again.'); return; }\n      el('keyInput').value = val;\n      tree.insert(val);\n    });\n\n    el('bulkBtn').addEventListener('click', ()=> {\n      const sample = [41, 38, 31, 12, 19, 8];\n      // clear then insert sample with small delay\n      tree = new RBTree(makeSnapshotFunction((msg, opts)=> snapshotManager.collect(msg, opts)));\n      snapshotManager.tree = tree;\n      snapshotManager.reset();\n      let idx = 0;\n      const insInterval = setInterval(()=>{\n        if (idx >= sample.length) { clearInterval(insInterval); return; }\n        const v = sample[idx++];\n        el('keyInput').value = v;\n        tree.insert(v);\n      }, 250);\n    });\n\n    el('clearBtn').addEventListener('click', ()=> {\n      tree = new RBTree(makeSnapshotFunction((msg, opts)=> snapshotManager.collect(msg, opts)));\n      snapshotManager.tree = tree;\n      snapshotManager.reset();\n    });\n\n    el('stepBack').addEventListener('click', ()=> { snapshotManager.step(-1); snapshotManager.stop(); el('playPause').textContent = '▶ Play'; });\n    el('stepForward').addEventListener('click', ()=> { snapshotManager.step(1); snapshotManager.stop(); el('playPause').textContent = '▶ Play'; });\n\n    let playing = false;\n    el('playPause').addEventListener('click', ()=> {\n      if (!playing){\n        playing = true;\n        el('playPause').textContent = '⏸ Pause';\n        snapshotManager.play(Number(el('speed').value), ()=> { playing=false; el('playPause').textContent='▶ Play'; });\n      } else {\n        playing = false;\n        el('playPause').textContent = '▶ Play';\n        snapshotManager.stop();\n      }\n    });\n\n    el('speed').addEventListener('input', ()=> {\n      // if playing, restart with new speed\n      // simplification: stop\n      snapshotManager.stop();\n      el('playPause').textContent = '▶ Play';\n    });\n  }\n\n  function existsInTree(tree, key){\n    let n = tree.root;\n    while (n !== tree.NIL){\n      if (n.key === key) return true;\n      n = key < n.key ? n.left : n.right;\n    }\n    return false;\n  }\n\n  function updateMessage(msg){\n    el('message').textContent = msg;\n  }\n\n  // initialize on load\n  init();\n\n  // initial sample hints\n  updateMessage('Ready. Try inserting 41, 38, 31, 12, 19, 8 (Sample).');\n\n})(); // end IIFE\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}