{
  "id": "98e2cc13-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:17:45.748Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Interactive Linear Regression Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root { --bg:#0f1724; --card:#0b1220; --muted:#9aa6b2; --accent:#34d399; --accent2:#60a5fa; color-scheme: dark; }\n    html,body { height:100%; margin:0; font-family: Inter, Arial, sans-serif; background: linear-gradient(180deg,#071022 0%, #071624 60%); color:#e6eef6; }\n    .app { display:flex; gap:18px; padding:18px; box-sizing:border-box; height:100%; }\n    .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); border-radius:10px; padding:12px; box-sizing:border-box; }\n    .left { flex:1; display:flex; flex-direction:column; gap:12px; min-width:420px; }\n    .canvas-wrap { background: #08121b; border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px; }\n    canvas { width:100%; height:360px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); border-radius:6px; cursor:crosshair; box-shadow: 0 6px 18px rgba(0,0,0,0.45) inset; }\n    .hint { color:var(--muted); font-size:13px; }\n    .right { width:380px; display:flex; flex-direction:column; gap:12px; }\n    .controls { display:flex; flex-direction:column; gap:10px; }\n    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    button, input[type=\"range\"], select, input[type=\"number\"], input[type=\"text\"] {\n      border-radius:8px; padding:8px 10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:#e6eef6; border:1px solid rgba(255,255,255,0.03);\n      font-size:13px;\n    }\n    button { cursor:pointer; }\n    .btn-primary { background:linear-gradient(90deg,var(--accent), var(--accent2)); border:0; color:#04202a; font-weight:600; }\n    .stat { background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; font-size:14px; }\n    label { font-size:13px; color:var(--muted); }\n    small { color:var(--muted); font-size:12px; }\n    .cost-plot { height:120px; width:100%; background:#06131b; border-radius:8px; padding:8px; box-sizing:border-box; }\n    .footer { font-size:12px; color:var(--muted); }\n    .inline { display:inline-flex; gap:8px; align-items:center; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left panel\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div>\n          <h2 style=\"margin:0 0 6px 0\">Linear Regression — Interactive</h2>\n          <div class=\"hint\">Click the plot to add data points. Use the controls to fit models, generate data & explore.</div>\n        </div>\n        <div class=\"stat\" id=\"dataCount\">Points: 0</div>\n      </div>\n\n      <div class=\"canvas-wrap panel\">\n        <canvas id=\"scatter\" width=\"800\" height=\"360\" title=\"Click to add points\"></canvas>\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div class=\"hint\">Left-click to add. Shift+click to add many (jitter). Right-click to remove last.</div>\n          <div class=\"hint\">Axes auto-scale</div>\n        </div>\n      </div>\n\n      <div style=\"display:flex; gap:12px; align-items:flex-start;\">\n        <div style=\"flex:1\" class=\"panel\">\n          <div style=\"font-weight:700\">Model Parameters</div>\n          <div style=\"margin-top:6px; display:flex; gap:8px; align-items:center;\">\n            <div class=\"stat\">slope (a): <span id=\"paramA\">—</span></div>\n            <div class=\"stat\">intercept (b): <span id=\"paramB\">—</span></div>\n          </div>\n          <div style=\"margin-top:8px; display:flex; gap:8px; align-items:center;\">\n            <div class=\"stat\">MSE: <span id=\"mse\">—</span></div>\n            <div class=\"stat\">R²: <span id=\"r2\">—</span></div>\n          </div>\n        </div>\n\n        <div style=\"width:260px\" class=\"panel\">\n          <div style=\"font-weight:700\">Prediction</div>\n          <div style=\"display:flex; gap:8px; margin-top:8px; align-items:center;\">\n            <input id=\"predX\" type=\"number\" step=\"any\" placeholder=\"x value\" style=\"flex:1\">\n            <button id=\"predictBtn\" class=\"btn-primary\">Predict</button>\n          </div>\n          <div style=\"margin-top:8px\" class=\"stat\">ŷ: <span id=\"predY\">—</span></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div style=\"font-weight:700; margin-bottom:6px;\">Cost (MSE) over GD iterations</div>\n        <canvas id=\"costCanvas\" width=\"800\" height=\"120\" class=\"cost-plot\"></canvas>\n      </div>\n      <div class=\"footer\">This demo shows Ordinary Least Squares (closed-form) and Gradient Descent. Try different learning rates and noise to see how GD behaves.</div>\n    </div>\n\n    <div class=\"right panel\">\n      <div style=\"font-weight:800; font-size:15px\">Controls</div>\n\n      <div class=\"controls\">\n        <div style=\"display:flex; gap:8px;\">\n          <button id=\"btnOLS\" class=\"btn-primary\" style=\"flex:1\">Fit OLS (closed form)</button>\n          <button id=\"btnReset\" title=\"Clear points\">Clear</button>\n        </div>\n\n        <div style=\"display:flex; gap:8px;\">\n          <button id=\"btnStartGD\" class=\"btn-primary\" style=\"flex:1\">Start Gradient Descent</button>\n          <button id=\"btnStopGD\">Stop GD</button>\n        </div>\n\n        <div class=\"panel\">\n          <div style=\"font-weight:700; margin-bottom:6px;\">Gradient Descent</div>\n          <div class=\"row\">\n            <label>Learning rate (α)</label>\n            <input id=\"lr\" type=\"number\" step=\"any\" value=\"0.01\" style=\"width:100px\">\n            <label>Iterations / second</label>\n            <input id=\"itersPerSec\" type=\"number\" step=\"1\" value=\"60\" style=\"width:80px\">\n          </div>\n          <div class=\"row\" style=\"margin-top:8px;\">\n            <label><input id=\"initZero\" type=\"checkbox\" checked> init a=b=0</label>\n            <label><input id=\"showResiduals\" type=\"checkbox\" checked> show residuals</label>\n          </div>\n        </div>\n\n        <div class=\"panel\">\n          <div style=\"font-weight:700; margin-bottom:6px;\">Generate Data</div>\n          <div class=\"row\">\n            <label>points</label><input id=\"genN\" type=\"number\" value=\"40\" style=\"width:80px\">\n          </div>\n          <div class=\"row\">\n            <label>slope (a)</label><input id=\"genA\" type=\"number\" step=\"any\" value=\"1.5\" style=\"width:100px\">\n            <label>intercept (b)</label><input id=\"genB\" type=\"number\" step=\"any\" value=\"0.5\" style=\"width:100px\">\n          </div>\n          <div class=\"row\" style=\"margin-top:6px;\">\n            <label>noise σ</label><input id=\"genNoise\" type=\"number\" step=\"any\" value=\"0.8\" style=\"width:100px\">\n            <button id=\"btnGen\" style=\"flex:1\">Generate</button>\n          </div>\n        </div>\n\n        <div class=\"panel\">\n          <div style=\"font-weight:700; margin-bottom:6px;\">Edit Points</div>\n          <div class=\"row\">\n            <button id=\"btnAddRand\">Add Random</button>\n            <button id=\"btnRemove\">Remove Last</button>\n          </div>\n          <small>Right-click canvas to remove last too.</small>\n        </div>\n\n        <div class=\"panel\">\n          <div style=\"font-weight:700; margin-bottom:6px;\">Tips</div>\n          <ul style=\"margin:6px 0 0 18px; color:var(--muted)\">\n            <li>OLS computes exact best-fit line when x values vary.</li>\n            <li>GD approximates by iteratively minimizing MSE.</li>\n            <li>If GD diverges, reduce learning rate.</li>\n          </ul>\n        </div>\n\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\nInteractive Linear Regression demo\n- Add points by clicking on canvas\n- Fit using OLS (closed-form) or Gradient Descent (animated)\n- See parameters, MSE and R², residuals, and cost plot\n*/\n\n// Data and model\nlet points = []; // {x,y}\nlet model = {a: NaN, b: NaN}; // y = a*x + b\nlet showResiduals = true;\n\n// Canvas and drawing\nconst scatter = document.getElementById('scatter');\nconst ctx = scatter.getContext('2d');\nconst costCanvas = document.getElementById('costCanvas');\nconst costCtx = costCanvas.getContext('2d');\n\nconst dataCount = document.getElementById('dataCount');\nconst paramA = document.getElementById('paramA');\nconst paramB = document.getElementById('paramB');\nconst mseEl = document.getElementById('mse');\nconst r2El = document.getElementById('r2');\nconst predX = document.getElementById('predX');\nconst predBtn = document.getElementById('predictBtn');\nconst predY = document.getElementById('predY');\n\nconst btnOLS = document.getElementById('btnOLS');\nconst btnReset = document.getElementById('btnReset');\nconst btnStartGD = document.getElementById('btnStartGD');\nconst btnStopGD = document.getElementById('btnStopGD');\nconst lrInput = document.getElementById('lr');\nconst itersPerSec = document.getElementById('itersPerSec');\nconst initZero = document.getElementById('initZero');\nconst showResidualsCheckbox = document.getElementById('showResiduals');\n\nconst btnGen = document.getElementById('btnGen');\nconst genN = document.getElementById('genN');\nconst genA = document.getElementById('genA');\nconst genB = document.getElementById('genB');\nconst genNoise = document.getElementById('genNoise');\n\nconst btnAddRand = document.getElementById('btnAddRand');\nconst btnRemove = document.getElementById('btnRemove');\n\nconst canvasRect = () => scatter.getBoundingClientRect();\n\n// coordinate mapping\nfunction computeBounds() {\n  if (points.length === 0) return {xMin:-1,xMax:1,yMin:-1,yMax:1};\n  let xs = points.map(p=>p.x), ys = points.map(p=>p.y);\n  let xMin = Math.min(...xs), xMax = Math.max(...xs);\n  let yMin = Math.min(...ys), yMax = Math.max(...ys);\n  // pad\n  let xPad = (xMax - xMin) * 0.12 || 1;\n  let yPad = (yMax - yMin) * 0.12 || 1;\n  return {xMin: xMin - xPad, xMax: xMax + xPad, yMin: yMin - yPad, yMax: yMax + yPad};\n}\nfunction toCanvas(pt) {\n  const rect = canvasRect();\n  const bounds = computeBounds();\n  const w = rect.width, h = rect.height;\n  const x = (pt.x - bounds.xMin) / (bounds.xMax - bounds.xMin) * w;\n  // invert y\n  const y = h - (pt.y - bounds.yMin) / (bounds.yMax - bounds.yMin) * h;\n  return {x,y};\n}\nfunction fromCanvas(clientX, clientY) {\n  const rect = canvasRect();\n  const bounds = computeBounds();\n  const w = rect.width, h = rect.height;\n  const x = (clientX - rect.left) / w * (bounds.xMax - bounds.xMin) + bounds.xMin;\n  const y = (h - (clientY - rect.top) / h * (bounds.yMax - bounds.yMin)) * 1.0;\n  const yReal = (y / 1.0) + bounds.yMin - 0; // adjust no-op\n  return {x: x, y: yReal};\n}\n\n// draw everything\nfunction draw() {\n  const rect = canvasRect();\n  ctx.clearRect(0,0,rect.width, rect.height);\n\n  // background grid\n  ctx.fillStyle = '#061522';\n  ctx.fillRect(0,0,rect.width, rect.height);\n\n  // axes and grid lines\n  const b = computeBounds();\n  drawGrid(b);\n\n  // draw points\n  for (let p of points) {\n    const c = toCanvas(p);\n    ctx.beginPath();\n    ctx.fillStyle = '#7dd3fc';\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.lineWidth = 1;\n    ctx.arc(c.x, c.y, 5, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n  }\n\n  // draw fitted line\n  if (!isNaN(model.a) && !isNaN(model.b)) {\n    drawLine(model.a, model.b);\n    // residuals\n    if (showResiduals) {\n      ctx.lineWidth = 1;\n      for (let p of points) {\n        const predicted = model.a * p.x + model.b;\n        const c1 = toCanvas(p);\n        const c2 = toCanvas({x: p.x, y: predicted});\n        ctx.beginPath();\n        ctx.moveTo(c1.x, c1.y);\n        ctx.lineTo(c2.x, c2.y);\n        ctx.strokeStyle = 'rgba(255,99,132,0.6)';\n        ctx.stroke();\n      }\n    }\n  }\n\n  // draw legend / info overlay\n  ctx.font = '12px Inter, Arial';\n  ctx.fillStyle = 'rgba(255,255,255,0.06)';\n  ctx.fillText('Click to add points. Right-click to remove last.', 10, 14);\n}\n\nfunction drawGrid(bounds) {\n  const rect = canvasRect();\n  const w = rect.width, h = rect.height;\n  // draw border\n  ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n  ctx.lineWidth = 1;\n  roundedRect(ctx, 0.5, 0.5, w-1, h-1, 6);\n  ctx.stroke();\n\n  // ticks\n  const nx = 6, ny = 5;\n  ctx.strokeStyle = 'rgba(255,255,255,0.02)';\n  ctx.fillStyle = 'rgba(255,255,255,0.08)';\n  ctx.font = '11px Inter, Arial';\n  const format = v => (Math.abs(v) < 1e-6 ? '0' : (Math.round(v*100)/100).toFixed(2));\n  for (let i=0;i<=nx;i++) {\n    let t = i/nx;\n    let x = t*w;\n    ctx.beginPath();\n    ctx.moveTo(x,0);\n    ctx.lineTo(x,h);\n    ctx.stroke();\n    let val = bounds.xMin + t*(bounds.xMax - bounds.xMin);\n    ctx.fillText(format(val), x+4, h-6);\n  }\n  for (let j=0;j<=ny;j++) {\n    let t = j/ny;\n    let y = t*h;\n    ctx.beginPath();\n    ctx.moveTo(0,y);\n    ctx.lineTo(w,y);\n    ctx.stroke();\n    let val = bounds.yMax - t*(bounds.yMax - bounds.yMin);\n    ctx.fillText(format(val), 6, y-6);\n  }\n}\n\nfunction roundedRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.arcTo(x + width, y, x + width, y + height, radius);\n  ctx.arcTo(x + width, y + height, x, y + height, radius);\n  ctx.arcTo(x, y + height, x, y, radius);\n  ctx.arcTo(x, y, x + width, y, radius);\n  ctx.closePath();\n}\n\n// draw line for y = a*x + b across canvas extents\nfunction drawLine(a,b) {\n  const rect = canvasRect();\n  const bounds = computeBounds();\n  const x1 = bounds.xMin;\n  const x2 = bounds.xMax;\n  const y1 = a*x1 + b;\n  const y2 = a*x2 + b;\n  const c1 = toCanvas({x:x1, y:y1});\n  const c2 = toCanvas({x:x2, y:y2});\n  // stroke\n  ctx.beginPath();\n  ctx.moveTo(c1.x, c1.y);\n  ctx.lineTo(c2.x, c2.y);\n  ctx.lineWidth = 2.5;\n  ctx.strokeStyle = 'rgba(99,102,241,0.95)';\n  ctx.stroke();\n  // shadow\n  ctx.beginPath();\n  ctx.moveTo(c1.x, c1.y);\n  ctx.lineTo(c2.x, c2.y);\n  ctx.lineWidth = 10;\n  ctx.strokeStyle = 'rgba(99,102,241,0.06)';\n  ctx.stroke();\n}\n\n// statistics and evaluation\nfunction computeMSE(a,b) {\n  if (points.length===0) return NaN;\n  let s=0;\n  for (let p of points) {\n    const e = p.y - (a*p.x + b);\n    s += e*e;\n  }\n  return s / points.length;\n}\nfunction computeR2(a,b) {\n  if (points.length===0) return NaN;\n  let meanY = points.reduce((s,p)=>s+p.y,0)/points.length;\n  let ssRes = 0, ssTot=0;\n  for (let p of points) {\n    ssRes += (p.y - (a*p.x + b))**2;\n    ssTot += (p.y - meanY)**2;\n  }\n  return 1 - ssRes / (ssTot || 1e-9);\n}\n\n// Ordinary Least Squares (closed form)\nfunction fitOLS() {\n  if (points.length === 0) return;\n  const n = points.length;\n  const meanX = points.reduce((s,p)=>s+p.x,0)/n;\n  const meanY = points.reduce((s,p)=>s+p.y,0)/n;\n  let num=0, den=0;\n  for (let p of points) {\n    num += (p.x - meanX)*(p.y - meanY);\n    den += (p.x - meanX)*(p.x - meanX);\n  }\n  let a = den===0 ? 0 : num/den;\n  let b = meanY - a*meanX;\n  model.a = a; model.b = b;\n  updateStats();\n  draw();\n}\n\n// Gradient Descent\nlet gdRunning = false;\nlet gdState = {a:0,b:0,iter:0,history:[]};\nlet lastTime = 0;\n\nfunction startGD() {\n  if (points.length === 0) return;\n  // init\n  gdState.iter = 0;\n  gdState.history = [];\n  gdState.a = initZero.checked ? 0 : (isNaN(model.a) ? 0 : model.a);\n  gdState.b = initZero.checked ? 0 : (isNaN(model.b) ? 0 : model.b);\n  gdRunning = true;\n  lastTime = performance.now();\n  requestAnimationFrame(gdStep);\n}\nfunction stopGD() {\n  gdRunning = false;\n}\n\nfunction gdStep(t) {\n  if (!gdRunning) return;\n  const stepsPerSec = Math.max(1, parseFloat(itersPerSec.value)||60);\n  const elapsed = t - lastTime;\n  const steps = Math.max(1, Math.floor(stepsPerSec * (elapsed/1000)));\n  lastTime = t;\n  const lr = parseFloat(lrInput.value) || 0.01;\n  const n = points.length;\n  for (let s=0;s<steps;s++) {\n    // compute gradients\n    let gradA = 0, gradB = 0;\n    for (let p of points) {\n      const pred = gdState.a * p.x + gdState.b;\n      const err = pred - p.y;\n      gradA += err * p.x;\n      gradB += err;\n    }\n    gradA = (2/n) * gradA;\n    gradB = (2/n) * gradB;\n    // update\n    gdState.a -= lr * gradA;\n    gdState.b -= lr * gradB;\n    gdState.iter++;\n    const mse = computeMSE(gdState.a, gdState.b);\n    gdState.history.push(mse);\n  }\n  model.a = gdState.a; model.b = gdState.b;\n  updateStats();\n  draw();\n  drawCostHistory(gdState.history);\n  // continue\n  requestAnimationFrame(gdStep);\n}\n\n// cost plot\nfunction drawCostHistory(history) {\n  const ctx2 = costCtx;\n  const w = costCanvas.width, h = costCanvas.height;\n  ctx2.clearRect(0,0,w,h);\n  ctx2.fillStyle = '#06131b';\n  ctx2.fillRect(0,0,w,h);\n  if (history.length === 0) {\n    ctx2.fillStyle = 'rgba(255,255,255,0.04)';\n    ctx2.font = '12px Inter, Arial';\n    ctx2.fillText('No cost history (run GD).', 10, 18);\n    return;\n  }\n  const maxC = Math.max(...history);\n  const minC = Math.min(...history);\n  ctx2.beginPath();\n  ctx2.strokeStyle = 'rgba(96,165,250,0.95)';\n  ctx2.lineWidth = 2;\n  for (let i=0;i<history.length;i++) {\n    const x = i/(history.length-1||1) * (w-10) + 5;\n    const t = (history[i]-minC) / ((maxC-minC) || 1);\n    const y = h - (t * (h-20) + 10);\n    if (i===0) ctx2.moveTo(x,y); else ctx2.lineTo(x,y);\n  }\n  ctx2.stroke();\n\n  ctx2.fillStyle = 'rgba(255,255,255,0.06)';\n  ctx2.font = '12px Inter, Arial';\n  ctx2.fillText('MSE: ' + history[history.length-1].toFixed(4), 10, 16);\n}\n\n// update UI stats\nfunction updateStats() {\n  dataCount.textContent = 'Points: ' + points.length;\n  paramA.textContent = isNaN(model.a) ? '—' : model.a.toFixed(4);\n  paramB.textContent = isNaN(model.b) ? '—' : model.b.toFixed(4);\n  const mse = (!isNaN(model.a) && !isNaN(model.b)) ? computeMSE(model.a, model.b) : NaN;\n  mseEl.textContent = isNaN(mse) ? '—' : mse.toFixed(4);\n  const r2 = (!isNaN(model.a) && !isNaN(model.b)) ? computeR2(model.a, model.b) : NaN;\n  r2El.textContent = isNaN(r2) ? '—' : r2.toFixed(4);\n}\n\n// interactions\nscatter.addEventListener('mousedown', (ev) => {\n  ev.preventDefault();\n  if (ev.button === 2 || ev.which === 3) { // right click: remove last\n    points.pop();\n    updateStats();\n    draw();\n    return;\n  }\n  const p = fromCanvas(ev.clientX, ev.clientY);\n  points.push(p);\n  // add shift-jitter to add many quickly\n  if (ev.shiftKey) {\n    for (let i=0;i<8;i++) {\n      points.push({x: p.x + (Math.random()-0.5)*(0.05*(computeBounds().xMax - computeBounds().xMin)), y: p.y + (Math.random()-0.5)*(0.05*(computeBounds().yMax - computeBounds().yMin))});\n    }\n  }\n  updateStats();\n  draw();\n});\nscatter.addEventListener('contextmenu', (ev)=> ev.preventDefault());\n\n// buttons\nbtnReset.addEventListener('click', ()=> {\n  points = [];\n  model = {a: NaN, b: NaN};\n  gdRunning = false;\n  gdState = {a:0,b:0,iter:0,history:[]};\n  updateStats();\n  draw();\n  drawCostHistory([]);\n});\nbtnOLS.addEventListener('click', ()=> {\n  fitOLS();\n});\nbtnStartGD.addEventListener('click', ()=> {\n  startGD();\n});\nbtnStopGD.addEventListener('click', ()=> {\n  stopGD();\n});\nshowResidualsCheckbox.addEventListener('change', ()=> {\n  showResiduals = showResidualsCheckbox.checked;\n  draw();\n});\n\n// prediction\npredBtn.addEventListener('click', ()=> {\n  const x = parseFloat(predX.value);\n  if (isNaN(x) || isNaN(model.a) || isNaN(model.b)) {\n    predY.textContent = '—';\n    return;\n  }\n  const yhat = model.a * x + model.b;\n  predY.textContent = yhat.toFixed(4);\n  // show temporary point\n  const c = toCanvas({x,y:yhat});\n  // draw highlight on canvas overlay\n  draw();\n  ctx.beginPath();\n  ctx.arc(c.x, c.y, 7, 0, Math.PI*2);\n  ctx.fillStyle = 'rgba(34,197,94,0.95)';\n  ctx.fill();\n});\n\n// generation\nbtnGen.addEventListener('click', ()=> {\n  const n = Math.max(1, parseInt(genN.value) || 40);\n  const a = parseFloat(genA.value) || 1;\n  const b = parseFloat(genB.value) || 0;\n  const sigma = Math.max(0, parseFloat(genNoise.value) || 0);\n  points = [];\n  for (let i=0;i<n;i++) {\n    const x = (Math.random()*2 - 1) * 6; // spread\n    const noise = gaussianRandom() * sigma;\n    const y = a*x + b + noise;\n    points.push({x,y});\n  }\n  model = {a: NaN, b: NaN};\n  updateStats();\n  draw();\n  drawCostHistory([]);\n});\n\n// add random / remove\nbtnAddRand.addEventListener('click', ()=> {\n  const bounds = computeBounds();\n  const x = bounds.xMin + Math.random() * (bounds.xMax - bounds.xMin);\n  const y = bounds.yMin + Math.random() * (bounds.yMax - bounds.yMin);\n  points.push({x,y});\n  updateStats();\n  draw();\n});\nbtnRemove.addEventListener('click', ()=> {\n  points.pop();\n  updateStats();\n  draw();\n});\n\n// utility: gaussian random (Box-Muller)\nfunction gaussianRandom() {\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random();\n  while(v === 0) v = Math.random();\n  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n}\n\n// initialize demo with a small dataset\n(function initDemo(){\n  // generate default\n  const n = 18;\n  const a = 1.5, b = 0.5, sigma = 1.0;\n  points = [];\n  for (let i=0;i<n;i++){\n    const x = -6 + i*(12/(n-1));\n    points.push({x: x, y: a*x + b + gaussianRandom()*sigma});\n  }\n  model = {a: NaN, b: NaN};\n  updateStats();\n  draw();\n  drawCostHistory([]);\n})();\n\n// avoid blurry canvas on high DPI\nfunction fixHiDPICanvas(canvas, ctx) {\n  const dpr = window.devicePixelRatio || 1;\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.round(rect.width * dpr);\n  canvas.height = Math.round(rect.height * dpr);\n  canvas.style.width = rect.width + \"px\";\n  canvas.style.height = rect.height + \"px\";\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n}\nfunction refreshCanvasSize() {\n  fixHiDPICanvas(scatter, ctx);\n  fixHiDPICanvas(costCanvas, costCtx);\n  draw();\n  drawCostHistory(gdState.history || []);\n}\nwindow.addEventListener('resize', refreshCanvasSize);\nrefreshCanvasSize();\n\n// animate small pulsing when GD is running (optional)\nsetInterval(()=> {\n  if (gdRunning) {\n    // flash a small indicator in top-right\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(99,102,241,0.14)';\n    ctx.arc(canvasRect().width - 18, 18, 8, 0, Math.PI*2);\n    ctx.fill();\n    ctx.restore();\n  }\n}, 500);\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}