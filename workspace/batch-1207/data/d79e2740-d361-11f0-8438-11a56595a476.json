{
  "id": "d79e2740-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:38.353Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    display:flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f0f0f0;\n  }\n  h1 {\n    margin: 1rem 0 0.5rem 0;\n  }\n  #canvas {\n    border: 1px solid #ccc;\n    background: white;\n    margin-top: 1rem;\n    cursor:pointer;\n  }\n  #controls {\n    margin: 1rem 0;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    gap: 1rem;\n    max-width: 600px;\n  }\n  #controls > * {\n    font-size: 1rem;\n  }\n  button {\n    cursor:pointer;\n    padding: 0.5rem 1rem;\n    border:none;\n    border-radius: 4px;\n    background-color: #007bff;\n    color: white;\n    transition: background-color 0.3s;\n  }\n  button:disabled {\n    background-color: #aaa;\n    cursor: default;\n  }\n  button:hover:not(:disabled) {\n    background-color: #0056b3;\n  }\n  label {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    user-select:none;\n  }\n  #instructions {\n    max-width: 600px;\n    text-align: center;\n    margin-bottom: 1rem;\n  }\n</style>\n</head>\n<body>\n<h1>K-Means Clustering Demo</h1>\n<div id=\"instructions\">\n  Click on the canvas to add points.<br/>\n  Choose number of clusters (K), then click \"Start Clustering\".<br/>\n  Watch how centroids update and points get colored by their cluster.<br/>\n  Use \"Next Step\" to advance iteration by iteration, or \"Run\" to finish.<br/>\n  \"Reset\" clears all points and clusters.\n</div>\n<div id=\"controls\">\n  <label>\n    Number of Clusters (K):\n    <input type=\"number\" id=\"kInput\" min=\"1\" max=\"10\" value=\"3\" />\n  </label>\n  <button id=\"startBtn\">Start Clustering</button>\n  <button id=\"nextBtn\" disabled>Next Step</button>\n  <button id=\"runBtn\" disabled>Run</button>\n  <button id=\"resetBtn\">Reset</button>\n</div>\n<canvas id=\"canvas\" width=\"600\" height=\"400\" title=\"Click to add points\"></canvas>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n\n  const kInput = document.getElementById('kInput');\n  const startBtn = document.getElementById('startBtn');\n  const nextBtn = document.getElementById('nextBtn');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const POINT_RADIUS = 5;\n  const CENTROID_RADIUS = 10;\n\n  let points = []; // {x, y, cluster}\n  let centroids = []; // {x, y}\n  let K = 3;\n  let clusteringStarted = false;\n\n  // Colors for clusters - extend if K > colors.length\n  const colors = [\n    '#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999','#66c2a5'\n  ];\n\n  function distanceSquared(p1, p2) {\n    return (p1.x - p2.x)**2 + (p1.y - p2.y)**2;\n  }\n\n  // Draw function to visualize points and centroids\n  function draw() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw points\n    for (const p of points) {\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI*2);\n      if (clusteringStarted && p.cluster !== null && p.cluster !== undefined) {\n        ctx.fillStyle = colors[p.cluster % colors.length];\n      } else {\n        ctx.fillStyle = '#333333';\n      }\n      ctx.fill();\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n\n    // Draw centroids\n    if (clusteringStarted) {\n      for (let i = 0; i < centroids.length; i++) {\n        const c = centroids[i];\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, CENTROID_RADIUS, 0, Math.PI*2);\n        ctx.fillStyle = colors[i % colors.length];\n        ctx.fill();\n        ctx.strokeStyle = '#000';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n\n        // Draw centroid label\n        ctx.fillStyle = '#000';\n        ctx.font = 'bold 14px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(i+1, c.x, c.y);\n      }\n    }\n  }\n\n  // Assign points to nearest centroid, returns true if any point changed cluster\n  function assignClusters() {\n    let changed = false;\n    for (const p of points) {\n      let minDist = Infinity;\n      let assigned = null;\n      for (let i = 0; i < centroids.length; i++) {\n        const dist = distanceSquared(p, centroids[i]);\n        if (dist < minDist) {\n          minDist = dist;\n          assigned = i;\n        }\n      }\n      if (p.cluster !== assigned) {\n        changed = true;\n        p.cluster = assigned;\n      }\n    }\n    return changed;\n  }\n\n  // Recalculate centroids as mean of their clusters, returns true if any centroid moved significantly\n  function updateCentroids() {\n    let moved = false;\n    const newCentroids = [];\n    for (let i = 0; i < K; i++) {\n      let clusterPoints = points.filter(p => p.cluster === i);\n      if (clusterPoints.length === 0) {\n        // If no points assigned to this cluster, keep centroid same position\n        newCentroids.push({...centroids[i]});\n        continue;\n      }\n      let sumX = 0, sumY = 0;\n      for (const p of clusterPoints) {\n        sumX += p.x;\n        sumY += p.y;\n      }\n      let newX = sumX / clusterPoints.length;\n      let newY = sumY / clusterPoints.length;\n      if (distanceSquared({x:newX,y:newY}, centroids[i]) > 1) {\n        moved = true;\n      }\n      newCentroids.push({x: newX, y: newY});\n    }\n    centroids = newCentroids;\n    return moved;\n  }\n\n  // Initialize centroids randomly from distinct points\n  function initializeCentroids() {\n    if (points.length < K) {\n      alert(`Add at least ${K} points before starting clustering.`);\n      return false;\n    }\n    const chosenIndexes = new Set();\n    while (chosenIndexes.size < K) {\n      const idx = Math.floor(Math.random() * points.length);\n      chosenIndexes.add(idx);\n    }\n    centroids = [];\n    for (const idx of chosenIndexes) {\n      // Copy point coords for centroid\n      centroids.push({x: points[idx].x, y: points[idx].y});\n    }\n    return true;\n  }\n\n  // Run one iteration of K-means: assign clusters and update centroids, return true if changed\n  function kMeansStep() {\n    const assignedChanged = assignClusters();\n    const centroidsMoved = updateCentroids();\n    return assignedChanged || centroidsMoved;\n  }\n\n  // State: whether clustering is converged\n  let converged = false;\n\n  // UI & Logic Handlers\n\n  canvas.addEventListener('click', e => {\n    if (clusteringStarted) return; // no adding points after start\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    points.push({x, y, cluster: null});\n    draw();\n  });\n\n  startBtn.addEventListener('click', () => {\n    K = parseInt(kInput.value, 10);\n    if (isNaN(K) || K < 1 || K > 10) {\n      alert('Number of clusters (K) must be between 1 and 10.');\n      return;\n    }\n    if (points.length < K) {\n      alert(`Need at least ${K} points to start clustering.`);\n      return;\n    }\n\n    if (!initializeCentroids()) return;\n\n    clusteringStarted = true;\n    converged = false;\n\n    // Assign clusters first time\n    assignClusters();\n    draw();\n\n    // Buttons enable/disable\n    kInput.disabled = true;\n    startBtn.disabled = true;\n    nextBtn.disabled = false;\n    runBtn.disabled = false;\n    resetBtn.disabled = false;\n  });\n\n  nextBtn.addEventListener('click', () => {\n    if (!clusteringStarted) return;\n    if (converged) return;\n\n    const changed = kMeansStep();\n    draw();\n\n    if (!changed) {\n      converged = true;\n      nextBtn.disabled = true;\n      runBtn.disabled = true;\n      alert('Converged! No more changes in clusters or centroids.');\n    }\n  });\n\n  runBtn.addEventListener('click', () => {\n    if (!clusteringStarted) return;\n\n    // Keep running until convergence\n    let iter = 0;\n    const maxIter = 100;\n    while(iter < maxIter) {\n      const changed = kMeansStep();\n      iter++;\n      if (!changed) {\n        converged = true;\n        break;\n      }\n    }\n    draw();\n    if (converged) {\n      alert(`Converged in ${iter} iterations!`);\n      nextBtn.disabled = true;\n      runBtn.disabled = true;\n    } else {\n      alert(`Stopped after max iterations (${maxIter}) without full convergence.`);\n    }\n  });\n\n  resetBtn.addEventListener('click', () => {\n    points = [];\n    centroids = [];\n    clusteringStarted = false;\n    converged = false;\n    kInput.disabled = false;\n    startBtn.disabled = false;\n    nextBtn.disabled = true;\n    runBtn.disabled = true;\n    draw();\n  });\n\n  // Initial draw\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}