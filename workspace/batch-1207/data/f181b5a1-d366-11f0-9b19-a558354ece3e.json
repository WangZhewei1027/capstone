{
  "id": "f181b5a1-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:48.224Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            padding: 20px;\n            color: #333;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 30px;\n            color: white;\n        }\n        \n        h1 {\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n        }\n        \n        .description {\n            font-size: 1.1rem;\n            max-width: 800px;\n            margin: 0 auto 20px;\n            line-height: 1.6;\n        }\n        \n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            margin-bottom: 30px;\n        }\n        \n        .controls {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            flex: 1;\n            min-width: 300px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n        }\n        \n        .visualization {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            flex: 2;\n            min-width: 300px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n            position: relative;\n        }\n        \n        .graph-container {\n            border: 2px solid #ddd;\n            border-radius: 8px;\n            height: 400px;\n            position: relative;\n            overflow: hidden;\n            background: #f9f9f9;\n        }\n        \n        .controls h2, .visualization h2 {\n            margin-bottom: 15px;\n            color: #5a4e8c;\n            border-bottom: 2px solid #eee;\n            padding-bottom: 10px;\n        }\n        \n        .form-group {\n            margin-bottom: 15px;\n        }\n        \n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: 600;\n        }\n        \n        input, select, button {\n            width: 100%;\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            font-size: 1rem;\n        }\n        \n        button {\n            background: #5a4e8c;\n            color: white;\n            border: none;\n            cursor: pointer;\n            transition: background 0.3s;\n            margin-top: 10px;\n        }\n        \n        button:hover {\n            background: #433a6b;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background: #5a4e8c;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            cursor: pointer;\n            z-index: 10;\n            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);\n            transition: all 0.3s;\n        }\n        \n        .node.start {\n            background: #4CAF50;\n        }\n        \n        .node.end {\n            background: #F44336;\n        }\n        \n        .node.visited {\n            background: #2196F3;\n        }\n        \n        .node.path {\n            background: #FFC107;\n        }\n        \n        .edge {\n            position: absolute;\n            height: 3px;\n            background: #888;\n            transform-origin: 0 0;\n            z-index: 5;\n        }\n        \n        .edge-weight {\n            position: absolute;\n            background: white;\n            padding: 2px 5px;\n            border-radius: 3px;\n            font-size: 0.8rem;\n            font-weight: bold;\n            z-index: 6;\n            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\n        }\n        \n        .results {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            margin-top: 20px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n        }\n        \n        .step-info {\n            margin-top: 15px;\n            padding: 10px;\n            background: #f5f5f5;\n            border-radius: 5px;\n            font-family: monospace;\n            white-space: pre-wrap;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .algorithm-explanation {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            margin-top: 20px;\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n        }\n        \n        .algorithm-explanation h2 {\n            color: #5a4e8c;\n            margin-bottom: 15px;\n            border-bottom: 2px solid #eee;\n            padding-bottom: 10px;\n        }\n        \n        .algorithm-explanation ol {\n            margin-left: 20px;\n            line-height: 1.6;\n        }\n        \n        .algorithm-explanation li {\n            margin-bottom: 10px;\n        }\n        \n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Dijkstra's Algorithm</h1>\n            <p class=\"description\">\n                Dijkstra's algorithm is a famous graph search algorithm that finds the shortest path between nodes in a graph.\n                It works for graphs with non-negative edge weights and is widely used in network routing protocols and GPS navigation systems.\n            </p>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"controls\">\n                <h2>Graph Controls</h2>\n                <div class=\"form-group\">\n                    <label for=\"startNode\">Start Node:</label>\n                    <select id=\"startNode\">\n                        <option value=\"A\">A</option>\n                        <option value=\"B\">B</option>\n                        <option value=\"C\">C</option>\n                        <option value=\"D\">D</option>\n                        <option value=\"E\">E</option>\n                        <option value=\"F\">F</option>\n                    </select>\n                </div>\n                \n                <div class=\"form-group\">\n                    <label for=\"endNode\">End Node:</label>\n                    <select id=\"endNode\">\n                        <option value=\"A\">A</option>\n                        <option value=\"B\">B</option>\n                        <option value=\"C\">C</option>\n                        <option value=\"D\">D</option>\n                        <option value=\"E\">E</option>\n                        <option value=\"F\">F</option>\n                    </select>\n                </div>\n                \n                <button id=\"runAlgorithm\">Run Dijkstra's Algorithm</button>\n                <button id=\"resetGraph\">Reset Graph</button>\n                \n                <div class=\"form-group\">\n                    <h3>Current Graph:</h3>\n                    <div id=\"graphRepresentation\">\n                        A-B:4, A-C:2, B-C:1, B-D:5, C-D:8, C-E:10, D-E:2, D-F:6, E-F:3\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"visualization\">\n                <h2>Graph Visualization</h2>\n                <div class=\"graph-container\" id=\"graphContainer\">\n                    <!-- Graph will be drawn here by JavaScript -->\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"results\">\n            <h2>Algorithm Results</h2>\n            <div id=\"pathResult\">Click \"Run Algorithm\" to find the shortest path.</div>\n            <div class=\"step-info\" id=\"stepInfo\"></div>\n        </div>\n        \n        <div class=\"algorithm-explanation\">\n            <h2>How Dijkstra's Algorithm Works</h2>\n            <ol>\n                <li>Initialize distances from the start node to all other nodes as infinity, except the start node itself (distance 0).</li>\n                <li>Create a set of unvisited nodes and add all nodes to it.</li>\n                <li>While there are unvisited nodes:\n                    <ul>\n                        <li>Select the unvisited node with the smallest known distance from the start node.</li>\n                        <li>For the current node, examine all unvisited neighbors and calculate their tentative distances.</li>\n                        <li>If the calculated distance is less than the known distance, update the shortest distance.</li>\n                        <li>Mark the current node as visited.</li>\n                    </ul>\n                </li>\n                <li>Once the destination node has been visited, the algorithm terminates.</li>\n                <li>The shortest path can be reconstructed by backtracking from the end node to the start node.</li>\n            </ol>\n            <p><strong>Time Complexity:</strong> O(V²) for a simple implementation, but can be improved to O(E + V log V) with a priority queue.</p>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        class Graph {\n            constructor() {\n                this.nodes = [];\n                this.edges = {};\n            }\n            \n            addNode(node) {\n                this.nodes.push(node);\n                this.edges[node] = {};\n            }\n            \n            addEdge(node1, node2, weight) {\n                this.edges[node1][node2] = weight;\n                this.edges[node2][node1] = weight;\n            }\n            \n            dijkstra(startNode, endNode) {\n                // Initialize distances and previous nodes\n                let distances = {};\n                let previous = {};\n                let unvisited = new Set(this.nodes);\n                \n                // Set initial distances to infinity, except start node\n                this.nodes.forEach(node => {\n                    distances[node] = node === startNode ? 0 : Infinity;\n                    previous[node] = null;\n                });\n                \n                let steps = [];\n                \n                while (unvisited.size > 0) {\n                    // Find unvisited node with smallest distance\n                    let currentNode = null;\n                    unvisited.forEach(node => {\n                        if (currentNode === null || distances[node] < distances[currentNode]) {\n                            currentNode = node;\n                        }\n                    });\n                    \n                    // If the smallest distance is infinity, remaining nodes are unreachable\n                    if (distances[currentNode] === Infinity) break;\n                    \n                    // If we reached the end node, we can stop\n                    if (currentNode === endNode) break;\n                    \n                    // Record current step\n                    let stepInfo = `Visiting node ${currentNode} (distance: ${distances[currentNode]})\\n`;\n                    stepInfo += `Neighbors: `;\n                    \n                    // Update distances to neighbors\n                    for (let neighbor in this.edges[currentNode]) {\n                        if (unvisited.has(neighbor)) {\n                            let distanceToNeighbor = distances[currentNode] + this.edges[currentNode][neighbor];\n                            stepInfo += `${neighbor} (current: ${distances[neighbor]}, new: ${distanceToNeighbor}) `;\n                            \n                            if (distanceToNeighbor < distances[neighbor]) {\n                                distances[neighbor] = distanceToNeighbor;\n                                previous[neighbor] = currentNode;\n                                stepInfo += `-> updated! `;\n                            }\n                        }\n                    }\n                    \n                    steps.push({\n                        currentNode: currentNode,\n                        distances: {...distances},\n                        previous: {...previous},\n                        info: stepInfo\n                    });\n                    \n                    // Mark current node as visited\n                    unvisited.delete(currentNode);\n                }\n                \n                // Reconstruct path\n                let path = [];\n                let currentNode = endNode;\n                \n                while (previous[currentNode] !== null) {\n                    path.unshift(currentNode);\n                    currentNode = previous[currentNode];\n                }\n                \n                if (path.length > 0 || startNode === endNode) {\n                    path.unshift(startNode);\n                }\n                \n                return {\n                    path: path,\n                    distance: distances[endNode],\n                    steps: steps\n                };\n            }\n        }\n        \n        // Initialize the graph with sample data\n        const graph = new Graph();\n        ['A', 'B', 'C', 'D', 'E', 'F'].forEach(node => graph.addNode(node));\n        \n        graph.addEdge('A', 'B', 4);\n        graph.addEdge('A', 'C', 2);\n        graph.addEdge('B', 'C', 1);\n        graph.addEdge('B', 'D', 5);\n        graph.addEdge('C', 'D', 8);\n        graph.addEdge('C', 'E', 10);\n        graph.addEdge('D', 'E', 2);\n        graph.addEdge('D', 'F', 6);\n        graph.addEdge('E', 'F', 3);\n        \n        // Node positions for visualization\n        const nodePositions = {\n            'A': { x: 100, y: 200 },\n            'B': { x: 250, y: 100 },\n            'C': { x: 250, y: 300 },\n            'D': { x: 400, y: 100 },\n            'E': { x: 400, y: 300 },\n            'F': { x: 550, y: 200 }\n        };\n        \n        // Draw the graph\n        function drawGraph() {\n            const container = document.getElementById('graphContainer');\n            container.innerHTML = '';\n            \n            // Draw edges\n            for (let node1 in graph.edges) {\n                for (let node2 in graph.edges[node1]) {\n                    // Avoid drawing duplicate edges\n                    if (node1 < node2) {\n                        const pos1 = nodePositions[node1];\n                        const pos2 = nodePositions[node2];\n                        \n                        // Calculate edge properties\n                        const dx = pos2.x - pos1.x;\n                        const dy = pos2.y - pos1.y;\n                        const length = Math.sqrt(dx * dx + dy * dy);\n                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n                        \n                        // Create edge element\n                        const edge = document.createElement('div');\n                        edge.className = 'edge';\n                        edge.style.width = `${length}px`;\n                        edge.style.left = `${pos1.x}px`;\n                        edge.style.top = `${pos1.y}px`;\n                        edge.style.transform = `rotate(${angle}deg)`;\n                        container.appendChild(edge);\n                        \n                        // Create weight label\n                        const weight = document.createElement('div');\n                        weight.className = 'edge-weight';\n                        weight.textContent = graph.edges[node1][node2];\n                        weight.style.left = `${(pos1.x + pos2.x) / 2 - 15}px`;\n                        weight.style.top = `${(pos1.y + pos2.y) / 2 - 10}px`;\n                        container.appendChild(weight);\n                    }\n                }\n            }\n            \n            // Draw nodes\n            for (let node in nodePositions) {\n                const pos = nodePositions[node];\n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node';\n                nodeElement.id = `node-${node}`;\n                nodeElement.textContent = node;\n                nodeElement.style.left = `${pos.x - 20}px`;\n                nodeElement.style.top = `${pos.y - 20}px`;\n                container.appendChild(nodeElement);\n            }\n        }\n        \n        // Highlight nodes based on algorithm state\n        function highlightNodes(path, visited, current) {\n            // Reset all nodes\n            document.querySelectorAll('.node').forEach(node => {\n                node.classList.remove('start', 'end', 'visited', 'path');\n            });\n            \n            // Highlight start and end nodes\n            const startNode = document.getElementById('node-' + path[0]);\n            const endNode = document.getElementById('node-' + path[path.length - 1]);\n            \n            if (startNode) startNode.classList.add('start');\n            if (endNode) endNode.classList.add('end');\n            \n            // Highlight visited nodes\n            visited.forEach(node => {\n                const nodeElement = document.getElementById('node-' + node);\n                if (nodeElement) nodeElement.classList.add('visited');\n            });\n            \n            // Highlight current node\n            if (current) {\n                const currentNode = document.getElementById('node-' + current);\n                if (currentNode) currentNode.classList.add('path');\n            }\n            \n            // Highlight path\n            path.forEach(node => {\n                const nodeElement = document.getElementById('node-' + node);\n                if (nodeElement) nodeElement.classList.add('path');\n            });\n        }\n        \n        // Animate the algorithm steps\n        function animateAlgorithm(steps, path, distance) {\n            let stepIndex = 0;\n            const visited = new Set();\n            const stepInfoElement = document.getElementById('stepInfo');\n            \n            function nextStep() {\n                if (stepIndex < steps.length) {\n                    const step = steps[stepIndex];\n                    visited.add(step.currentNode);\n                    \n                    highlightNodes(path, Array.from(visited), step.currentNode);\n                    stepInfoElement.textContent = step.info;\n                    \n                    stepIndex++;\n                    setTimeout(nextStep, 1500);\n                } else {\n                    // Algorithm complete\n                    highlightNodes(path, Array.from(visited));\n                    document.getElementById('pathResult').innerHTML = \n                        `<strong>Shortest Path:</strong> ${path.join(' → ')}<br><strong>Total Distance:</strong> ${distance}`;\n                }\n            }\n            \n            nextStep();\n        }\n        \n        // Initialize the page\n        document.addEventListener('DOMContentLoaded', function() {\n            drawGraph();\n            \n            // Set up event listeners\n            document.getElementById('runAlgorithm').addEventListener('click', function() {\n                const startNode = document.getElementById('startNode').value;\n                const endNode = document.getElementById('endNode').value;\n                \n                if (startNode === endNode) {\n                    document.getElementById('pathResult').textContent = 'Start and end nodes are the same.';\n                    return;\n                }\n                \n               "
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}