{
  "id": "6b000db0-d5c3-11f0-b41f-b131cbd11f51",
  "timestamp": "2025-12-10T12:31:08.340Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Heap Data Structure Visualization</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        \n        body {\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            margin-bottom: 10px;\n        }\n        \n        .subtitle {\n            color: #7f8c8d;\n            font-size: 1.2rem;\n        }\n        \n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            margin-bottom: 30px;\n        }\n        \n        .panel {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            flex: 1;\n            min-width: 300px;\n        }\n        \n        .controls {\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n            margin-bottom: 20px;\n        }\n        \n        input {\n            padding: 10px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            font-size: 16px;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        .heap-type-selector {\n            display: flex;\n            margin-bottom: 20px;\n            background-color: #ecf0f1;\n            border-radius: 4px;\n            padding: 5px;\n        }\n        \n        .heap-type-btn {\n            flex: 1;\n            text-align: center;\n            padding: 10px;\n            background: none;\n            border: none;\n            color: #7f8c8d;\n            cursor: pointer;\n            border-radius: 4px;\n        }\n        \n        .heap-type-btn.active {\n            background-color: #3498db;\n            color: white;\n        }\n        \n        .heap-visualization {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin-top: 20px;\n            min-height: 300px;\n            position: relative;\n        }\n        \n        .heap-level {\n            display: flex;\n            justify-content: center;\n            margin-bottom: 40px;\n        }\n        \n        .heap-node {\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            margin: 0 10px;\n            background-color: #3498db;\n            color: white;\n            position: relative;\n        }\n        \n        .heap-node.new {\n            animation: highlight 1s ease;\n            background-color: #e74c3c;\n        }\n        \n        @keyframes highlight {\n            0% { transform: scale(1); background-color: #e74c3c; }\n            50% { transform: scale(1.2); background-color: #f1c40f; }\n            100% { transform: scale(1); background-color: #3498db; }\n        }\n        \n        .heap-connection {\n            position: absolute;\n            background-color: #7f8c8d;\n            height: 2px;\n            transform-origin: 0 0;\n        }\n        \n        .operation-history {\n            max-height: 200px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            padding: 10px;\n            font-family: monospace;\n            font-size: 14px;\n            background-color: #f8f9fa;\n        }\n        \n        .explanation {\n            margin-top: 30px;\n            padding: 15px;\n            background-color: #e8f4f8;\n            border-radius: 8px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .explanation h3 {\n            margin-top: 0;\n            color: #2c3e50;\n        }\n        \n        @media (max-width: 768px) {\n            .container {\n                flex-direction: column;\n            }\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>Heap Data Structure Visualization</h1>\n        <p class=\"subtitle\">Min Heap and Max Heap Operations</p>\n    </header>\n    \n    <div class=\"container\">\n        <div class=\"panel\">\n            <h2>Heap Operations</h2>\n            \n            <div class=\"heap-type-selector\">\n                <button class=\"heap-type-btn active\" data-type=\"min\">Min Heap</button>\n                <button class=\"heap-type-btn\" data-type=\"max\">Max Heap</button>\n            </div>\n            \n            <div class=\"controls\">\n                <input type=\"number\" id=\"value-input\" placeholder=\"Enter a number\" min=\"-999\" max=\"999\">\n                <button id=\"insert-btn\">Insert Value</button>\n                <button id=\"extract-btn\">Extract Root</button>\n                <button id=\"clear-btn\">Clear Heap</button>\n                <button id=\"random-btn\">Generate Random Heap</button>\n            </div>\n            \n            <div class=\"operation-history\">\n                <h3>Operation History</h3>\n                <div id=\"history\"></div>\n            </div>\n        </div>\n        \n        <div class=\"panel\">\n            <h2>Heap Visualization</h2>\n            <div class=\"heap-visualization\" id=\"heap-container\">\n                <!-- Heap visualization will be generated here -->\n            </div>\n        </div>\n    </div>\n    \n    <div class=\"explanation\">\n        <h3>About Heaps</h3>\n        <p><strong>Min Heap:</strong> A complete binary tree where each node is smaller than or equal to its children. The smallest element is always at the root.</p>\n        <p><strong>Max Heap:</strong> A complete binary tree where each node is greater than or equal to its children. The largest element is always at the root.</p>\n        <p><strong>Operations:</strong></p>\n        <ul>\n            <li><strong>Insert:</strong> Add a new element to the heap and reorganize to maintain heap property</li>\n            <li><strong>Extract:</strong> Remove the root element and reorganize the heap</li>\n            <li><strong>Heapify:</strong> Process of converting a binary tree into a heap</li>\n        </ul>\n    </div>\n\n    <script>\n        class Heap {\n            constructor(type = 'min') {\n                this.type = type; // 'min' or 'max'\n                this.heap = [];\n            }\n            \n            // Get parent index of a node\n            parentIndex(index) {\n                return Math.floor((index - 1) / 2);\n            }\n            \n            // Get left child index of a node\n            leftChildIndex(index) {\n                return 2 * index + 1;\n            }\n            \n            // Get right child index of a node\n            rightChildIndex(index) {\n                return 2 * index + 2;\n            }\n            \n            // Check if a node has a parent\n            hasParent(index) {\n                return this.parentIndex(index) >= 0;\n            }\n            \n            // Check if a node has a left child\n            hasLeftChild(index) {\n                return this.leftChildIndex(index) < this.heap.length;\n            }\n            \n            // Check if a node has a right child\n            hasRightChild(index) {\n                return this.rightChildIndex(index) < this.heap.length;\n            }\n            \n            // Compare two elements based on heap type\n            compare(a, b) {\n                if (this.type === 'min') {\n                    return a < b;\n                } else {\n                    return a > b;\n                }\n            }\n            \n            // Swap two elements in the heap\n            swap(index1, index2) {\n                [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n            }\n            \n            // Insert a new value into the heap\n            insert(value) {\n                this.heap.push(value);\n                this.heapifyUp();\n            }\n            \n            // Extract the root element from the heap\n            extractRoot() {\n                if (this.heap.length === 0) return null;\n                \n                const root = this.heap[0];\n                this.heap[0] = this.heap[this.heap.length - 1];\n                this.heap.pop();\n                this.heapifyDown();\n                \n                return root;\n            }\n            \n            // Move the last element up to maintain heap property\n            heapifyUp() {\n                let index = this.heap.length - 1;\n                \n                while (this.hasParent(index) && \n                       this.compare(this.heap[index], this.heap[this.parentIndex(index)])) {\n                    this.swap(index, this.parentIndex(index));\n                    index = this.parentIndex(index);\n                }\n            }\n            \n            // Move the root element down to maintain heap property\n            heapifyDown() {\n                let index = 0;\n                \n                while (this.hasLeftChild(index)) {\n                    let childIndex = this.leftChildIndex(index);\n                    \n                    if (this.hasRightChild(index) && \n                        this.compare(this.heap[this.rightChildIndex(index)], this.heap[childIndex])) {\n                        childIndex = this.rightChildIndex(index);\n                    }\n                    \n                    if (this.compare(this.heap[index], this.heap[childIndex])) {\n                        break;\n                    } else {\n                        this.swap(index, childIndex);\n                    }\n                    \n                    index = childIndex;\n                }\n            }\n            \n            // Get the root value without removing it\n            peek() {\n                return this.heap.length > 0 ? this.heap[0] : null;\n            }\n            \n            // Get the size of the heap\n            size() {\n                return this.heap.length;\n            }\n            \n            // Check if the heap is empty\n            isEmpty() {\n                return this.heap.length === 0;\n            }\n            \n            // Clear the heap\n            clear() {\n                this.heap = [];\n            }\n        }\n\n        // DOM elements\n        const heapTypeBtns = document.querySelectorAll('.heap-type-btn');\n        const valueInput = document.getElementById('value-input');\n        const insertBtn = document.getElementById('insert-btn');\n        const extractBtn = document.getElementById('extract-btn');\n        const clearBtn = document.getElementById('clear-btn');\n        const randomBtn = document.getElementById('random-btn');\n        const heapContainer = document.getElementById('heap-container');\n        const historyDiv = document.getElementById('history');\n\n        // Initialize heap\n        let heap = new Heap('min');\n        let operationHistory = [];\n\n        // Update active heap type button\n        function updateHeapTypeButtons() {\n            heapTypeBtns.forEach(btn => {\n                if (btn.dataset.type === heap.type) {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n        }\n\n        // Add operation to history\n        function addToHistory(operation) {\n            const timestamp = new Date().toLocaleTimeString();\n            operationHistory.unshift(`${timestamp}: ${operation}`);\n            \n            // Keep only last 10 operations\n            if (operationHistory.length > 10) {\n                operationHistory.pop();\n            }\n            \n            // Update history display\n            historyDiv.innerHTML = operationHistory.map(op => `<div>${op}</div>`).join('');\n        }\n\n        // Visualize the heap\n        function visualizeHeap() {\n            heapContainer.innerHTML = '';\n            \n            if (heap.isEmpty()) {\n                heapContainer.innerHTML = '<p>Heap is empty</p>';\n                return;\n            }\n            \n            // Calculate the number of levels needed\n            const levels = Math.floor(Math.log2(heap.size())) + 1;\n            \n            // Create levels\n            let nodeIndex = 0;\n            for (let level = 0; level < levels; level++) {\n                const levelDiv = document.createElement('div');\n                levelDiv.className = 'heap-level';\n                \n                // Number of nodes at this level\n                const nodesInLevel = Math.min(Math.pow(2, level), heap.size() - nodeIndex);\n                \n                for (let i = 0; i < nodesInLevel; i++) {\n                    const node = document.createElement('div');\n                    node.className = 'heap-node';\n                    node.textContent = heap.heap[nodeIndex];\n                    node.dataset.index = nodeIndex;\n                    \n                    // Highlight newly added nodes\n                    if (nodeIndex === heap.size() - 1 && operationHistory[0] && \n                        operationHistory[0].includes('Inserted')) {\n                        node.classList.add('new');\n                    }\n                    \n                    levelDiv.appendChild(node);\n                    nodeIndex++;\n                }\n                \n                heapContainer.appendChild(levelDiv);\n            }\n            \n            // Draw connections between nodes\n            drawConnections();\n        }\n\n        // Draw connections between parent and child nodes\n        function drawConnections() {\n            for (let i = 0; i < heap.size(); i++) {\n                if (heap.hasLeftChild(i)) {\n                    drawConnection(i, heap.leftChildIndex(i));\n                }\n                \n                if (heap.hasRightChild(i)) {\n                    drawConnection(i, heap.rightChildIndex(i));\n                }\n            }\n        }\n\n        // Draw a connection between two nodes\n        function drawConnection(parentIndex, childIndex) {\n            const parentNode = document.querySelector(`.heap-node[data-index=\"${parentIndex}\"]`);\n            const childNode = document.querySelector(`.heap-node[data-index=\"${childIndex}\"]`);\n            \n            if (!parentNode || !childNode) return;\n            \n            const parentRect = parentNode.getBoundingClientRect();\n            const childRect = childNode.getBoundingClientRect();\n            const containerRect = heapContainer.getBoundingClientRect();\n            \n            const parentX = parentRect.left + parentRect.width / 2 - containerRect.left;\n            const parentY = parentRect.top + parentRect.height / 2 - containerRect.top;\n            const childX = childRect.left + childRect.width / 2 - containerRect.left;\n            const childY = childRect.top + childRect.height / 2 - containerRect.top;\n            \n            const length = Math.sqrt(Math.pow(childX - parentX, 2) + Math.pow(childY - parentY, 2));\n            const angle = Math.atan2(childY - parentY, childX - parentX) * 180 / Math.PI;\n            \n            const connection = document.createElement('div');\n            connection.className = 'heap-connection';\n            connection.style.width = `${length}px`;\n            connection.style.left = `${parentX}px`;\n            connection.style.top = `${parentY}px`;\n            connection.style.transform = `rotate(${angle}deg)`;\n            \n            heapContainer.appendChild(connection);\n        }\n\n        // Event listeners\n        heapTypeBtns.forEach(btn => {\n            btn.addEventListener('click', () => {\n                heap.type = btn.dataset.type;\n                updateHeapTypeButtons();\n                addToHistory(`Switched to ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);\n                visualizeHeap();\n            });\n        });\n\n        insertBtn.addEventListener('click', () => {\n            const value = parseInt(valueInput.value);\n            if (isNaN(value)) {\n                alert('Please enter a valid number');\n                return;\n            }\n            \n            heap.insert(value);\n            addToHistory(`Inserted ${value} into ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);\n            visualizeHeap();\n            valueInput.value = '';\n            valueInput.focus();\n        });\n\n        extractBtn.addEventListener('click', () => {\n            if (heap.isEmpty()) {\n                alert('Heap is empty');\n                return;\n            }\n            \n            const root = heap.extractRoot();\n            addToHistory(`Extracted root value ${root} from ${heap.type === 'min' ? 'Min' : 'Max'} Heap`);\n            visualizeHeap();\n        });\n\n        clearBtn.addEventListener('click', () => {\n            heap.clear();\n            addToHistory('Cleared heap');\n            visualizeHeap();\n        });\n\n        randomBtn.addEventListener('click', () => {\n            heap.clear();\n            const count = Math.floor(Math.random() * 10) + 5; // 5-14 nodes\n            \n            for (let i = 0; i < count; i++) {\n                heap.insert(Math.floor(Math.random() * 100));\n            }\n            \n            addToHistory(`Generated random ${heap.type === 'min' ? 'Min' : 'Max'} Heap with ${count} nodes`);\n            visualizeHeap();\n        });\n\n        // Allow pressing Enter to insert\n        valueInput.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                insertBtn.click();\n            }\n        });\n\n        // Initialize visualization\n        updateHeapTypeButtons();\n        visualizeHeap();\n        addToHistory('Started with Min Heap');\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}