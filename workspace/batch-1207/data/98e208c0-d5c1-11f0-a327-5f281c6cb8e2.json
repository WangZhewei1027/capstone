{
  "id": "98e208c0-d5c1-11f0-a327-5f281c6cb8e2",
  "timestamp": "2025-12-10T12:16:55.953Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Counting Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Counting Sort - Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --card:#071026;\n      --accent:#60a5fa;\n      --accent-2:#34d399;\n      --muted:#94a3b8;\n      --good:#10b981;\n      --danger:#fb7185;\n      --white:#e6eef6;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{\n      margin:0;\n      padding:20px;\n      background:linear-gradient(180deg,var(--bg),#071027 120%);\n      color:var(--white);\n      min-height:100vh;\n    }\n    .container{\n      max-width:1100px;\n      margin:0 auto;\n    }\n    header{\n      display:flex;\n      align-items:center;\n      gap:16px;\n    }\n    h1{margin:0;font-size:20px;}\n    p.lead{margin:6px 0 18px;color:var(--muted);font-size:13px;}\n    .controls{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      margin-bottom:16px;\n      align-items:center;\n    }\n    .card{\n      background:linear-gradient(180deg,var(--card),#071026 120%);\n      border-radius:10px;\n      padding:14px;\n      box-shadow:0 6px 20px rgba(2,6,23,0.6);\n    }\n    .card.small{padding:10px;}\n    label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px;}\n    input[type=\"text\"]{background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white);padding:8px;border-radius:8px;min-width:260px;}\n    button{\n      background:linear-gradient(180deg,var(--accent),#2b76d8);\n      color:white;border:0;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600;\n    }\n    button.secondary{background:linear-gradient(180deg,#7c8aa7,#56647e);font-weight:600;}\n    button.warn{background:linear-gradient(180deg,var(--danger),#d05a73);}\n    button:disabled{opacity:0.45;cursor:not-allowed}\n    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}\n    .array-visual {display:flex;gap:6px;flex-wrap:wrap;padding:12px;align-items:flex-end;min-height:120px;}\n    .box{\n      width:48px;height:48px;border-radius:8px;background:linear-gradient(180deg,#082033,#061526);display:flex;align-items:center;justify-content:center;\n      border:1px solid rgba(255,255,255,0.04);position:relative;color:var(--white);font-weight:700;\n      transition:transform 160ms ease, box-shadow 160ms ease, background 160ms;\n    }\n    .box.small{width:40px;height:40px;font-weight:600;}\n    .box.index{font-weight:600;font-size:12px;color:var(--muted);height:auto;padding:6px 10px;border-radius:999px;background:transparent;border:0;}\n    .box.active{transform:translateY(-8px);box-shadow:0 10px 30px rgba(80,144,255,0.18);background:linear-gradient(180deg,#1564ff,#103b9b);}\n    .box.countActive{transform:translateY(-8px);box-shadow:0 10px 30px rgba(52,211,153,0.12);background:linear-gradient(180deg,#34d399,#0f8564);}\n    .array-wrap{display:flex;flex-direction:column;gap:8px;}\n    .label-row{display:flex;gap:6px;align-items:center;}\n    .small-muted{font-size:12px;color:var(--muted)}\n    .legend{display:flex;gap:8px;align-items:center;}\n    .legend .sw{width:12px;height:12px;border-radius:3px;}\n    .sw.active{background:#1564ff}\n    .sw.count{background:#059669}\n    .visual-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px;}\n    .counts-row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}\n    .index-label{font-size:12px;color:var(--muted);text-align:center;margin-bottom:6px;}\n    .explain{margin-top:12px;color:var(--muted);font-size:13px;line-height:1.4}\n    .stats{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;}\n    .stat{background:linear-gradient(180deg,#081423,#071226);padding:8px 10px;border-radius:8px;font-size:13px;color:var(--muted)}\n    .controls .number{min-width:40px;}\n    .range-slider{display:flex;gap:8px;align-items:center}\n    .footer{margin-top:18px;color:var(--muted);font-size:13px}\n    pre.pseudocode{background:#061226;border-radius:8px;padding:10px;color:var(--muted);overflow:auto;font-size:13px}\n    @media (max-width:880px){\n      .visual-grid{grid-template-columns:1fr}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div>\n        <h1>Counting Sort - Interactive Visualization</h1>\n        <p class=\"lead\">Step through a stable counting sort on integer arrays. Supports negative values by shifting the counts range automatically.</p>\n      </div>\n    </header>\n\n    <div class=\"controls card\">\n      <div style=\"display:flex;gap:12px;flex-wrap:wrap;align-items:center\">\n        <div>\n          <label>Array (comma or space separated integers)</label>\n          <input id=\"arrInput\" type=\"text\" value=\"4, 2, -1, 3, 2, 4, 0, -1\" />\n        </div>\n\n        <div>\n          <label>Randomize</label>\n          <div class=\"row\">\n            <input id=\"randLen\" type=\"number\" min=\"1\" max=\"60\" value=\"8\" style=\"width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)\"/>\n            <input id=\"randMin\" type=\"number\" value=\"-2\" style=\"width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)\"/>\n            <input id=\"randMax\" type=\"number\" value=\"5\" style=\"width:70px;padding:8px;border-radius:8px;background:#061226;border:1px solid rgba(255,255,255,0.04);color:var(--white)\"/>\n            <button id=\"btnRandom\" class=\"secondary\">Generate</button>\n          </div>\n        </div>\n\n        <div>\n          <label>Animation speed (ms per step)</label>\n          <div class=\"range-slider\">\n            <input id=\"speed\" type=\"range\" min=\"10\" max=\"1000\" value=\"220\" />\n            <div class=\"small-muted\" id=\"speedLabel\">220 ms</div>\n          </div>\n        </div>\n\n        <div style=\"margin-left:auto\">\n          <label>Controls</label>\n          <div style=\"display:flex;gap:8px\">\n            <button id=\"btnStart\">Run</button>\n            <button id=\"btnPause\" class=\"secondary\" disabled>Pause</button>\n            <button id=\"btnStep\" class=\"secondary\">Step</button>\n            <button id=\"btnReset\" class=\"warn\">Reset</button>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"visual-grid\">\n      <div class=\"card\">\n        <div class=\"array-wrap\">\n          <div class=\"label-row\">\n            <div style=\"flex:1\">\n              <label>Input Array</label>\n              <div class=\"small-muted\">Left-to-right is the array order (index 0 .. n-1).</div>\n            </div>\n            <div class=\"legend\">\n              <div class=\"sw active\"></div><div class=\"small-muted\">Active element</div>\n              <div style=\"width:12px\"></div>\n              <div class=\"sw count\"></div><div class=\"small-muted\">Counts active</div>\n            </div>\n          </div>\n\n          <div id=\"inputArray\" class=\"array-visual card small\"></div>\n\n          <div class=\"stats\">\n            <div class=\"stat\">n = <span id=\"statN\">0</span></div>\n            <div class=\"stat\">min = <span id=\"statMin\">0</span></div>\n            <div class=\"stat\">max = <span id=\"statMax\">0</span></div>\n            <div class=\"stat\">range = <span id=\"statRange\">0</span></div>\n            <div class=\"stat\">stable = yes</div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div>\n          <label>Counts array (indices represent values)</label>\n          <div class=\"small-muted\">Index shown is actual value (shifted for negatives). Boxes show current counts / prefix sums during phases.</div>\n          <div id=\"countsWrap\" style=\"margin-top:12px;overflow:auto;padding-bottom:6px\">\n            <div id=\"countsIndices\" class=\"counts-row\"></div>\n            <div id=\"countsValues\" class=\"counts-row\" style=\"margin-top:8px\"></div>\n          </div>\n\n          <div style=\"margin-top:12px\">\n            <label>Output Array (sorted)</label>\n            <div id=\"outputArray\" class=\"array-visual card small\" style=\"min-height:60px\"></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"card\" style=\"margin-top:12px\">\n      <div style=\"display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start\">\n        <div style=\"flex:1;min-width:300px\">\n          <label>Explanation</label>\n          <div class=\"explain\">\n            Counting Sort sorts integers by counting how many of each value occur, then using prefix sums to compute positions. This demo:\n            <ol>\n              <li>Builds a counts array spanning min..max values (handles negatives by shifting).</li>\n              <li>Tallies occurrences for each input element.</li>\n              <li>Computes prefix sums (cumulative counts).</li>\n              <li>Places elements into the output array by iterating the input from right-to-left (stable).</li>\n            </ol>\n            The sort is stable because we fill the output using counts and iterate inputs from end to start.\n          </div>\n        </div>\n\n        <div style=\"min-width:320px\">\n          <label>Pseudocode (stable counting sort)</label>\n          <pre class=\"pseudocode\">\ncountingSort(A):\n  minVal = min(A)\n  k = max(A) - minVal + 1\n  counts = array of zeros size k\n  for x in A:\n    counts[x - minVal]++\n  for i in 1..k-1:\n    counts[i] += counts[i-1]\n  B = array of size len(A)\n  for i from len(A)-1 down to 0:\n    v = A[i]\n    counts[v - minVal]--\n    B[counts[v - minVal]] = v\n  return B\n          </pre>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      Tip: If the value range is very large, Counting Sort becomes inefficient in memory (counts size = range). This demo will prevent extremely large ranges.\n    </div>\n  </div>\n\n  <script>\n    // Interactive Counting Sort Demo\n    (function(){\n      const arrInput = document.getElementById('arrInput');\n      const btnRandom = document.getElementById('btnRandom');\n      const randLen = document.getElementById('randLen');\n      const randMin = document.getElementById('randMin');\n      const randMax = document.getElementById('randMax');\n      const btnStart = document.getElementById('btnStart');\n      const btnPause = document.getElementById('btnPause');\n      const btnStep = document.getElementById('btnStep');\n      const btnReset = document.getElementById('btnReset');\n      const speed = document.getElementById('speed');\n      const speedLabel = document.getElementById('speedLabel');\n\n      const inputArrayDiv = document.getElementById('inputArray');\n      const countsIndicesDiv = document.getElementById('countsIndices');\n      const countsValuesDiv = document.getElementById('countsValues');\n      const outputArrayDiv = document.getElementById('outputArray');\n\n      const statN = document.getElementById('statN');\n      const statMin = document.getElementById('statMin');\n      const statMax = document.getElementById('statMax');\n      const statRange = document.getElementById('statRange');\n\n      let baseState = { arr: [], min:0, max:0, range:0, counts:[], output:[] };\n      let gen = null;\n      let running = false;\n      let paused = false;\n      let currentStep = null;\n      let stepTimer = null;\n\n      const MAX_RANGE = 200; // don't allow crazy ranges for visualization\n\n      function parseArrayFromInput(){\n        const s = arrInput.value.trim();\n        if(!s) return [];\n        // split on comma or whitespace\n        const parts = s.split(/[\\s,]+/).filter(p => p.length);\n        const nums = parts.map(p => {\n          const n = Number(p);\n          return Number.isFinite(n) && Number.isInteger(n) ? n : NaN;\n        });\n        if (nums.some(isNaN)) {\n          alert('Please enter only integers (comma or space separated).');\n          return null;\n        }\n        return nums;\n      }\n\n      function renderAll(highlights = {}) {\n        // highlights: {inputIndex, countIndex, outputIndex, phase}\n        const arr = baseState.arr;\n        const counts = baseState.counts;\n        const output = baseState.output;\n        const min = baseState.min;\n        const max = baseState.max;\n        inputArrayDiv.innerHTML = '';\n        outputArrayDiv.innerHTML = '';\n\n        // Input array boxes\n        arr.forEach((v, i) => {\n          const b = document.createElement('div');\n          b.className = 'box';\n          if (highlights.inputIndex === i && highlights.phase === 'count') b.classList.add('active');\n          if (highlights.inputIndex === i && highlights.phase === 'place') b.classList.add('active');\n          b.textContent = v;\n          const idx = document.createElement('div');\n          idx.style.position = 'absolute';\n          idx.style.bottom = '-18px';\n          idx.style.fontSize = '11px';\n          idx.style.color = 'var(--muted)';\n          idx.textContent = 'i=' + i;\n          b.appendChild(idx);\n          inputArrayDiv.appendChild(b);\n        });\n\n        // counts indices row (show actual value labels)\n        countsIndicesDiv.innerHTML = '';\n        countsValuesDiv.innerHTML = '';\n        counts.forEach((c, j) => {\n          const valIndex = document.createElement('div');\n          valIndex.className = 'box index small';\n          valIndex.textContent = (j + min);\n          countsIndicesDiv.appendChild(valIndex);\n\n          const valBox = document.createElement('div');\n          valBox.className = 'box small';\n          if (highlights.countIndex === j && highlights.phase === 'count') {\n            valBox.classList.add('countActive');\n          }\n          if (highlights.countIndex === j && highlights.phase === 'prefix') {\n            valBox.classList.add('countActive');\n          }\n          if (highlights.countIndex === j && highlights.phase === 'place') {\n            // count being decremented to compute position\n            valBox.classList.add('countActive');\n          }\n          valBox.textContent = c;\n          const idx = document.createElement('div');\n          idx.style.position = 'absolute';\n          idx.style.bottom = '-18px';\n          idx.style.fontSize = '11px';\n          idx.style.color = 'var(--muted)';\n          idx.textContent = 'idx';\n          valBox.appendChild(idx);\n          countsValuesDiv.appendChild(valBox);\n        });\n\n        // Output boxes\n        output.forEach((v, i) => {\n          const b = document.createElement('div');\n          b.className = 'box';\n          if (v === null || typeof v === 'undefined') {\n            b.style.opacity = 0.18;\n            b.textContent = '';\n          } else {\n            b.textContent = v;\n          }\n          if (highlights.outputIndex === i && highlights.phase === 'place') {\n            b.classList.add('active');\n          }\n          const idx = document.createElement('div');\n          idx.style.position = 'absolute';\n          idx.style.bottom = '-18px';\n          idx.style.fontSize = '11px';\n          idx.style.color = 'var(--muted)';\n          idx.textContent = 'pos=' + i;\n          b.appendChild(idx);\n          outputArrayDiv.appendChild(b);\n        });\n\n        // stats\n        statN.textContent = arr.length;\n        statMin.textContent = baseState.arr.length ? baseState.min : '-';\n        statMax.textContent = baseState.arr.length ? baseState.max : '-';\n        statRange.textContent = baseState.arr.length ? baseState.range : '-';\n      }\n\n      // Generator that yields step-by-step actions\n      function* countingSortSteps(arr) {\n        if (!Array.isArray(arr)) return;\n        const n = arr.length;\n        if (n === 0) {\n          yield {phase:'done'};\n          return;\n        }\n        let minVal = Math.min(...arr);\n        let maxVal = Math.max(...arr);\n        let range = maxVal - minVal + 1;\n        if (range > MAX_RANGE) {\n          throw new Error(`Range too large for visualization (${range} > ${MAX_RANGE}). Choose a tighter range.`);\n        }\n        // init\n        const counts = new Array(range).fill(0);\n        const output = new Array(n).fill(null);\n\n        // expose initial\n        baseState.min = minVal;\n        baseState.max = maxVal;\n        baseState.range = range;\n        baseState.counts = counts;\n        baseState.output = output;\n        yield {phase:'init'};\n\n        // Tally counts\n        for (let i = 0; i < n; i++) {\n          const v = arr[i];\n          const idx = v - minVal;\n          // highlight input i and count idx\n          yield {phase:'count', inputIndex:i, countIndex: idx};\n          counts[idx] += 1;\n          // reflect update\n          baseState.counts = counts.slice();\n          yield {phase:'afterCount', inputIndex:i, countIndex: idx};\n        }\n\n        // Prefix sums (cumulative)\n        for (let j = 1; j < counts.length; j++) {\n          yield {phase:'prefix', countIndex: j};\n          counts[j] += counts[j-1];\n          baseState.counts = counts.slice();\n          yield {phase:'afterPrefix', countIndex: j};\n        }\n\n        // Place into output array, iterating input from right to left for stability\n        for (let i = n - 1; i >= 0; i--) {\n          const v = arr[i];\n          const idx = v - minVal;\n          yield {phase:'place', inputIndex:i, countIndex: idx};\n          counts[idx] -= 1;\n          const pos = counts[idx];\n          output[pos] = v;\n          baseState.counts = counts.slice();\n          baseState.output = output.slice();\n          yield {phase:'afterPlace', inputIndex:i, outputIndex: pos, countIndex: idx};\n        }\n\n        // done\n        yield {phase:'done'};\n      }\n\n      // Control logic for stepping and running\n      async function runAuto(){\n        if (!gen) return;\n        running = true;\n        paused = false;\n        updateButtons();\n        try {\n          while (true) {\n            const res = gen.next();\n            if (res.done) break;\n            const step = res.value;\n            applyStep(step);\n            if (step.phase === 'done') break;\n            await sleep(Number(speed.value));\n            if (paused) break;\n          }\n        } catch (err) {\n          alert('Error: ' + err.message);\n          running = false;\n          paused = true;\n        }\n        running = false;\n        updateButtons();\n      }\n\n      function stepOnce(){\n        if (!gen) return;\n        try {\n          const res = gen.next();\n          if (!res.done) {\n            applyStep(res.value);\n          } else {\n            applyStep({phase:'done'});\n          }\n        } catch (err) {\n          alert('Error: ' + err.message);\n          running = false;\n          paused = true;\n          updateButtons();\n        }\n      }\n\n      function applyStep(step){\n        // Update baseState and visuals according to yielded step.\n        currentStep = step;\n        const highlights = {\n          inputIndex: step.inputIndex,\n          countIndex: step.countIndex,\n          outputIndex: step.outputIndex,\n          phase: step.phase\n        };\n        // baseState has been updated inside generator for arrays; just render\n        renderAll(highlights);\n        // If done, collapse run state\n        if (step.phase === 'done') {\n          running = false;\n          paused = false;\n          updateButtons();\n        }\n      }\n\n      function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }\n\n      function updateButtons(){\n        btnStart.disabled = running || paused;\n        btnPause.disabled = !running;\n        btnStep.disabled = running;\n        btnReset.disabled = running;\n        arrInput.disabled = running;\n        btnRandom.disabled = running;\n        randLen.disabled = running;\n        randMin.disabled = running;\n        randMax.disabled = running;\n\n        if (running) {\n          btnStart.textContent = 'Running...';\n          btnPause.textContent = 'Pause';\n          btnPause.classList.remove('secondary');\n          btnPause.classList.add('warn');\n        } else {\n          btnStart.textContent = 'Run';\n          btnPause.classList.remove('warn');\n          btnPause.classList.add('secondary');\n        }\n      }\n\n      // Initialization and event wiring\n      btnRandom.addEventListener('click', () => {\n        const len = Math.max(1, Math.min(60, parseInt(randLen.value) || 8));\n        const lo = parseInt(randMin.value) || 0;\n        const hi = parseInt(randMax.value) || (lo + 5);\n        if (hi < lo) {\n          alert('randMax should be >= randMin');\n          return;\n        }\n        const out = [];\n        for (let i = 0; i < len; i++){\n          const v = Math.floor(Math.random() * (hi - lo + 1)) + lo;\n          out.push(v);\n        }\n        arrInput.value = out.join(', ');\n        prepareFromInput();\n      });\n\n      speed.addEventListener('input', () => {\n        speedLabel.textContent = speed.value + ' ms';\n      });\n\n      btnStart.addEventListener('click', async () => {\n        if (running) return;\n        if (paused) {\n          // resume\n          paused = false;\n          running = true;\n          updateButtons();\n          await runAuto();\n          return;\n        }\n        // fresh start\n        const parsed = parseArrayFromInput();\n        if (parsed === null) return;\n        const [ok, errMsg] = prepareFromParsed(parsed);\n        if (!ok) {\n          alert(errMsg);\n          return;\n        }\n        gen = countingSortSteps(baseState.arr.slice());\n        // kick off\n        await runAuto();\n      });\n\n      btnPause.addEventListener('click', () => {\n        if (!running) return;\n        paused = true;\n        running = false;\n        updateButtons();\n      });\n\n      btnStep.addEventListener('click', () => {\n        if (running) return;\n        const parsed = parseArrayFromInput();\n        if (!gen) {\n          // initialize generator if not present\n          if (parsed === null) return;\n          const [ok, errMsg] = prepareFromParsed(parsed);\n          if (!ok) {\n            alert(errMsg);\n            return;\n          }\n          gen = countingSortSteps(baseState.arr.slice());\n        }\n        stepOnce();\n      });\n\n      btnReset.addEventListener('click', () => {\n        running = false;\n        paused = false;\n        gen = null;\n        currentStep = null;\n        prepareFromInput();\n        updateButtons();\n      });\n\n      // Prepare state from input field and render initial visuals\n      function prepareFromInput(){\n        const parsed = parseArrayFromInput();\n        if (parsed === null) return;\n        const [ok, errMsg] = prepareFromParsed(parsed);\n        if (!ok) {\n          alert(errMsg);\n          return;\n        }\n        gen = null;\n        renderAll({});\n        updateButtons();\n      }\n\n      function prepareFromParsed(parsed){\n        if (!parsed) parsed = [];\n        // Validate range\n        if (parsed.length > 0) {\n          const minVal = Math.min(...parsed);\n          const maxVal = Math.max(...parsed);\n          const range = maxVal - minVal + 1;\n          if (range > MAX_RANGE) {\n            return [false, `The value range (${range}) is too large for visualization. Keep range <= ${MAX_RANGE}.`];\n          }\n          baseState.arr = parsed.slice();\n          baseState.min = minVal;\n          baseState.max = maxVal;\n          baseState.range = range;\n          baseState.counts = new Array(range).fill(0);\n          baseState.output = new Array(parsed.length).fill(null);\n        } else {\n          baseState.arr = [];\n          baseState.min = 0;\n          baseState.max = 0;\n          baseState.range = 0;\n          baseState.counts = [];\n          baseState.output = [];\n        }\n        return [true, null];\n      }\n\n      // On load, prepare initial example\n      prepareFromInput();\n\n      // Allow pressing Enter in the array input to reset visuals\n      arrInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          prepareFromInput();\n        }\n      });\n\n      // small helper: resize counts area if it's wide - already handled by overflow:auto\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Counting Sort"
    }
  ],
  "topic": "Counting Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}