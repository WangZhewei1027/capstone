{
  "id": "d7b4afc0-d5c2-11f0-9651-0f1ae31ac260",
  "timestamp": "2025-12-10T12:24:28.917Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Nearest Neighbors (KNN) Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 1rem;\n    background: #f0f4f8;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 1rem;\n    justify-content: center;\n    margin-top: 1rem;\n  }\n  #plot {\n    border: 1px solid #ccc;\n    background: white;\n  }\n  #controls {\n    max-width: 350px;\n  }\n  label {\n    display: block;\n    margin-top: 0.5rem;\n  }\n  input[type=\"number\"] {\n    width: 100%;\n    padding: 0.3rem;\n    font-size: 1rem;\n  }\n  button {\n    margin-top: 1rem;\n    padding: 0.6rem 1rem;\n    font-size: 1rem;\n    cursor: pointer;\n    background-color: #005bbb;\n    color: white;\n    border: none;\n    border-radius: 4px;\n  }\n  button:hover {\n    background-color: #004a99;\n  }\n  #info {\n    margin-top: 1rem;\n  }\n  #legend {\n    margin-top: 1rem;\n    font-size: 0.9rem;\n  }\n  .class0 {\n    color: #e63946;\n    font-weight: bold;\n  }\n  .class1 {\n    color: #1d3557;\n    font-weight: bold;\n  }\n  .class2 {\n    color: #2a9d8f;\n    font-weight: bold;\n  }\n  footer {\n    text-align: center;\n    margin-top: 3rem;\n    font-size: 0.9rem;\n    color: #666;\n  }\n</style>\n</head>\n<body>\n<h1>K-Nearest Neighbors (KNN) Demo</h1>\n<div id=\"container\">\n  <canvas id=\"plot\" width=\"500\" height=\"500\" aria-label=\"KNN plot\" role=\"img\"></canvas>\n  <div id=\"controls\" aria-live=\"polite\">\n    <label for=\"k\">Number of neighbors (k):</label>\n    <input type=\"number\" id=\"k\" value=\"3\" min=\"1\" max=\"15\" step=\"1\" />\n    <label for=\"numPoints\">Number of training points per class:</label>\n    <input type=\"number\" id=\"numPoints\" value=\"30\" min=\"5\" max=\"100\" step=\"1\" />\n    <button id=\"generateBtn\" aria-label=\"Generate new dataset and plot\">Generate New Dataset</button>\n    <button id=\"clearBtn\" aria-label=\"Clear test point\">Clear Test Point</button>\n    <div id=\"info\" aria-live=\"polite\"></div>\n    <div id=\"legend\">\n      Legend:<br />\n      <span class=\"class0\">● Class 0</span>, <span class=\"class1\">● Class 1</span>, <span class=\"class2\">● Class 2</span><br />\n      <span style=\"color:#000; font-style: italic;\">Click within the plot to classify a new point</span>\n    </div>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('plot');\n  const ctx = canvas.getContext('2d');\n  const kInput = document.getElementById('k');\n  const numPointsInput = document.getElementById('numPoints');\n  const generateBtn = document.getElementById('generateBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const infoDiv = document.getElementById('info');\n\n  const width = canvas.width;\n  const height = canvas.height;\n  const padding = 40;\n\n  // Three classes with distinct colors\n  const classes = [\n    { id: 0, color: '#e63946' },    // red\n    { id: 1, color: '#1d3557' },    // dark blue\n    { id: 2, color: '#2a9d8f' }     // teal\n  ];\n\n  // Store training data points: {x, y, class}\n  let trainingData = [];\n\n  // Store test point for classification: {x, y}\n  let testPoint = null;\n\n  // Scales coordinates [0,1] to canvas coords and reverse\n  function scaleX(x) {\n    return padding + x * (width - 2 * padding);\n  }\n  function scaleY(y) {\n    // Canvas Y is down, we want 0 at bottom, so invert\n    return height - padding - y * (height - 2 * padding);\n  }\n  function unscaleX(px) {\n    return (px - padding) / (width - 2 * padding);\n  }\n  function unscaleY(py) {\n    return (height - padding - py) / (height - 2 * padding);\n  }\n\n  // Generate training data clusters for each class\n  // Use 2D gaussian clusters around centers spread out in the unit square\n  function generateTrainingData(numPerClass) {\n    trainingData = [];\n    const centers = [\n      {x: 0.25, y: 0.25},\n      {x: 0.75, y: 0.25},\n      {x: 0.5, y: 0.75}\n    ];\n    const clusterStdDev = 0.08;\n\n    for(let cls of classes) {\n      for(let i=0; i<numPerClass; i++) {\n        let x, y;\n        do {\n          // Gaussian around center\n          x = centers[cls.id].x + randNormal() * clusterStdDev;\n          y = centers[cls.id].y + randNormal() * clusterStdDev;\n          // Clamp to [0,1]\n          x = Math.min(Math.max(x,0),1);\n          y = Math.min(Math.max(y,0),1);\n        } while(false); // no special rejection criteria\n        trainingData.push({x, y, class: cls.id});\n      }\n    }\n  }\n\n  // Box-Muller transform to get rand normal(0,1)\n  function randNormal() {\n    let u = 0, v = 0;\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n  }\n\n  // Draw axes and training points\n  function drawPlot() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw white background\n    ctx.fillStyle = 'white';\n    ctx.fillRect(padding, padding, width-2*padding, height-2*padding);\n\n    // Draw coordinate axes\n    ctx.strokeStyle = '#999';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    // X axis\n    ctx.moveTo(padding, height - padding);\n    ctx.lineTo(width - padding, height - padding);\n    // Y axis\n    ctx.moveTo(padding, padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.stroke();\n\n    // Axis labels\n    ctx.fillStyle = '#333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Feature 1', width/2, height - 10);\n    ctx.save();\n    ctx.translate(15, height/2);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText('Feature 2', 0, 0);\n    ctx.restore();\n\n    // Draw training points\n    for(let pt of trainingData) {\n      const cx = scaleX(pt.x);\n      const cy = scaleY(pt.y);\n      ctx.beginPath();\n      ctx.fillStyle = classes[pt.class].color;\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 1;\n      ctx.arc(cx, cy, 6, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n    }\n\n    // If test point exists draw it\n    if(testPoint) {\n      const cx = scaleX(testPoint.x);\n      const cy = scaleY(testPoint.y);\n      ctx.beginPath();\n      // Outline black bigger circle\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 3;\n      ctx.arc(cx, cy, 10, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      // Inner filled circle with predicted class color\n      ctx.beginPath();\n      ctx.fillStyle = classes[testPoint.class].color;\n      ctx.arc(cx, cy, 6, 0, 2*Math.PI);\n      ctx.fill();\n    }\n  }\n\n  // Compute distance squared between two points in feature space\n  function distSq(a,b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return dx*dx + dy*dy;\n  }\n\n  // KNN algorithm: classify test point given training data and k neighbors\n  // Return predicted class and neighbors\n  function knnClassify(testPt, k) {\n    // Compute distances to all training points\n    const distances = trainingData.map((pt, idx) => ({\n      idx,\n      dist: distSq(testPt, pt),\n      class: pt.class\n    }));\n\n    // Sort by distance ascending\n    distances.sort((a,b) => a.dist - b.dist);\n\n    // Take top k\n    const kNearest = distances.slice(0,k);\n\n    // Count class votes\n    const classVotes = {};\n    for(let vote of kNearest) {\n      classVotes[vote.class] = (classVotes[vote.class] || 0) + 1;\n    }\n\n    // Find class with max votes\n    let maxVotes = -1;\n    let predictedClass = null;\n    for(let cls in classVotes) {\n      if(classVotes[cls] > maxVotes) {\n        maxVotes = classVotes[cls];\n        predictedClass = Number(cls);\n      }\n    }\n\n    return {\n      predictedClass,\n      neighbors: kNearest\n    };\n  }\n\n  // Show detailed info about classification\n  function displayInfo(knnResult, testPt, k) {\n    if(!testPt) {\n      infoDiv.innerHTML = 'Click inside the plot area to classify a new point.';\n      return;\n    }\n    const {predictedClass, neighbors} = knnResult;\n\n    let html = `<strong>Test Point:</strong> (${testPt.x.toFixed(3)}, ${testPt.y.toFixed(3)})<br/>`;\n    html += `<strong>k:</strong> ${k}<br/>`;\n    html += `<strong>Predicted Class:</strong> <span style=\"color:${classes[predictedClass].color}; font-weight:bold;\">Class ${predictedClass}</span><br/><br/>`;\n    html += `<strong>Nearest Neighbors (sorted by distance):</strong><br/><table border=\"1\" cellpadding=\"3\" cellspacing=\"0\" style=\"border-collapse: collapse;\">\n      <thead><tr><th>#</th><th>Class</th><th>Distance</th></tr></thead><tbody>`;\n\n    neighbors.forEach((n, i) => {\n      html += `<tr>\n                 <td style=\"text-align:center;\">${i+1}</td>\n                 <td style=\"color:${classes[n.class].color}; font-weight:bold; text-align:center;\">${n.class}</td>\n                 <td style=\"text-align:right;\">${Math.sqrt(n.dist).toFixed(3)}</td>\n               </tr>`;\n    });\n    html += `</tbody></table>`;\n\n    infoDiv.innerHTML = html;\n  }\n\n  // On canvas click: classify point and redraw\n  function onCanvasClick(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const px = evt.clientX - rect.left;\n    const py = evt.clientY - rect.top;\n\n    // Only consider clicks inside plotting area\n    if(px < padding || px > width - padding || py < padding || py > height - padding) {\n      return;\n    }\n    const x = unscaleX(px);\n    const y = unscaleY(py);\n\n    testPoint = {x, y};\n    const k = parseInt(kInput.value, 10) || 3;\n\n    // classify\n    const knnResult = knnClassify(testPoint, k);\n    testPoint.class = knnResult.predictedClass;\n\n    drawPlot();\n    displayInfo(knnResult, testPoint, k);\n  }\n\n  function generateAndDraw() {\n    let numPerClass = parseInt(numPointsInput.value, 10);\n    if(isNaN(numPerClass) || numPerClass < 1) numPerClass = 30;\n\n    generateTrainingData(numPerClass);\n    testPoint = null;\n    drawPlot();\n    displayInfo(null, null);\n  }\n\n  // Clear test point and redraw\n  function clearTestPoint() {\n    testPoint = null;\n    drawPlot();\n    displayInfo(null, null);\n  }\n\n  // Initialize\n  generateAndDraw();\n\n  // Listeners\n  canvas.addEventListener('click', onCanvasClick);\n  generateBtn.addEventListener('click', generateAndDraw);\n  clearBtn.addEventListener('click', clearTestPoint);\n  kInput.addEventListener('change', () => {\n    // If test point present, re-classify with new k\n    if(testPoint){\n      const k = parseInt(kInput.value, 10) || 3;\n      const knnResult = knnClassify(testPoint, k);\n      testPoint.class = knnResult.predictedClass;\n      drawPlot();\n      displayInfo(knnResult, testPoint, k);\n    }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}