{
  "id": "f181dcb0-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:23:55.496Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "# Floyd-Warshall Algorithm Demonstration\n\nI've created an interactive visualization of the Floyd-Warshall algorithm that finds the shortest paths between all pairs of nodes in a weighted graph.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Floyd-Warshall Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        h1 {\n            color: #2c3e50;\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n        .graph-section, .control-section, .matrix-section, .steps-section {\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .canvas-container {\n            text-align: center;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            background-color: #fafafa;\n        }\n        .controls {\n            display: flex;\n            gap: 15px;\n            flex-wrap: wrap;\n            align-items: center;\n        }\n        button {\n            padding: 8px 16px;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        .matrix {\n            display: flex;\n            flex-direction: column;\n            gap: 5px;\n        }\n        .matrix-row {\n            display: flex;\n            gap: 5px;\n            justify-content: center;\n        }\n        .matrix-cell {\n            width: 40px;\n            height: 40px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border: 1px solid #ddd;\n            background-color: #f8f9fa;\n            font-weight: bold;\n        }\n        .matrix-cell.current {\n            background-color: #3498db;\n            color: white;\n        }\n        .matrix-cell.updated {\n            background-color: #2ecc71;\n            color: white;\n        }\n        .steps {\n            max-height: 200px;\n            overflow-y: auto;\n            padding: 10px;\n            border: 1px solid #eee;\n            border-radius: 4px;\n            background-color: #f8f9fa;\n        }\n        .instruction {\n            margin-bottom: 10px;\n            text-align: center;\n            font-style: italic;\n            color: #7f8c8d;\n        }\n        label {\n            margin-right: 5px;\n        }\n        input[type=\"number\"] {\n            width: 60px;\n            padding: 5px;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        .legend {\n            display: flex;\n            gap: 15px;\n            justify-content: center;\n            margin-top: 10px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 3px;\n        }\n    </style>\n</head>\n<body>\n    <h1>Floyd-Warshall Algorithm Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"graph-section\">\n            <div class=\"instruction\">Click on the canvas to add nodes. Click and drag between nodes to add edges. Right-click on edges to set weights.</div>\n            <div class=\"canvas-container\">\n                <canvas id=\"graphCanvas\" width=\"800\" height=\"400\"></canvas>\n            </div>\n        </div>\n        \n        <div class=\"control-section\">\n            <div class=\"controls\">\n                <button id=\"resetBtn\">Reset Graph</button>\n                <button id=\"generateBtn\">Generate Random Graph</button>\n                <button id=\"runBtn\">Run Algorithm</button>\n                <button id=\"stepBtn\" disabled>Step Forward</button>\n                <button id=\"resetAlgoBtn\" disabled>Reset Algorithm</button>\n                <div>\n                    <label for=\"speedControl\">Speed:</label>\n                    <input type=\"number\" id=\"speedControl\" min=\"1\" max=\"10\" value=\"5\">\n                </div>\n            </div>\n            \n            <div class=\"legend\">\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #3498db;\"></div>\n                    <span>Current node being considered</span>\n                </div>\n                <div class=\"legend-item\">\n                    <div class=\"legend-color\" style=\"background-color: #2ecc71;\"></div>\n                    <span>Updated distance</span>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"matrix-section\">\n            <h3>Distance Matrix</h3>\n            <div id=\"matrixContainer\" class=\"matrix\">\n                <!-- Matrix will be generated here -->\n            </div>\n        </div>\n        \n        <div class=\"steps-section\">\n            <h3>Algorithm Steps</h3>\n            <div id=\"stepsContainer\" class=\"steps\">\n                <!-- Steps will be added here -->\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph and algorithm state\n        let nodes = [];\n        let edges = [];\n        let isRunning = false;\n        let stepInterval = null;\n        let currentStep = 0;\n        let distanceMatrix = [];\n        let pathMatrix = [];\n        let algorithmState = null;\n\n        // DOM elements\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        const resetBtn = document.getElementById('resetBtn');\n        const generateBtn = document.getElementById('generateBtn');\n        const runBtn = document.getElementById('runBtn');\n        const stepBtn = document.getElementById('stepBtn');\n        const resetAlgoBtn = document.getElementById('resetAlgoBtn');\n        const speedControl = document.getElementById('speedControl');\n        const matrixContainer = document.getElementById('matrixContainer');\n        const stepsContainer = document.getElementById('stepsContainer');\n\n        // Initialize with a simple graph\n        initializeDefaultGraph();\n\n        // Event listeners\n        resetBtn.addEventListener('click', resetGraph);\n        generateBtn.addEventListener('click', generateRandomGraph);\n        runBtn.addEventListener('click', toggleAlgorithm);\n        stepBtn.addEventListener('click', stepAlgorithm);\n        resetAlgoBtn.addEventListener('click', resetAlgorithm);\n\n        // Canvas event listeners for graph creation\n        canvas.addEventListener('click', handleCanvasClick);\n        canvas.addEventListener('contextmenu', handleCanvasRightClick);\n        canvas.addEventListener('mousedown', startEdgeCreation);\n        canvas.addEventListener('mousemove', updateEdgeCreation);\n        canvas.addEventListener('mouseup', finishEdgeCreation);\n\n        // Initialize the graph with some nodes and edges\n        function initializeDefaultGraph() {\n            resetGraph();\n            \n            // Add some default nodes\n            addNode(200, 150);\n            addNode(400, 150);\n            addNode(300, 300);\n            addNode(600, 200);\n            \n            // Add some default edges\n            addEdge(0, 1, 4);\n            addEdge(0, 2, 5);\n            addEdge(1, 2, 1);\n            addEdge(1, 3, 3);\n            addEdge(2, 3, 2);\n            \n            drawGraph();\n            initializeAlgorithm();\n        }\n\n        // Reset the graph to empty\n        function resetGraph() {\n            nodes = [];\n            edges = [];\n            resetAlgorithm();\n            drawGraph();\n        }\n\n        // Generate a random graph\n        function generateRandomGraph() {\n            resetGraph();\n            \n            // Add 5-8 random nodes\n            const nodeCount = Math.floor(Math.random() * 4) + 5;\n            for (let i = 0; i < nodeCount; i++) {\n                const x = 100 + Math.random() * 600;\n                const y = 100 + Math.random() * 200;\n                addNode(x, y);\n            }\n            \n            // Add random edges (about 1.5 edges per node on average)\n            for (let i = 0; i < nodeCount; i++) {\n                for (let j = i + 1; j < nodeCount; j++) {\n                    if (Math.random() < 0.4) { // 40% chance of having an edge\n                        const weight = Math.floor(Math.random() * 10) + 1;\n                        addEdge(i, j, weight);\n                    }\n                }\n            }\n            \n            drawGraph();\n            initializeAlgorithm();\n        }\n\n        // Add a node to the graph\n        function addNode(x, y) {\n            nodes.push({ x, y, id: nodes.length });\n        }\n\n        // Add an edge to the graph\n        function addEdge(from, to, weight) {\n            // Check if edge already exists\n            if (!edges.some(edge => \n                (edge.from === from && edge.to === to) || \n                (edge.from === to && edge.to === from))) {\n                edges.push({ from, to, weight });\n            }\n        }\n\n        // Draw the graph on the canvas\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw edges\n            edges.forEach(edge => {\n                const fromNode = nodes[edge.from];\n                const toNode = nodes[edge.to];\n                \n                // Draw line\n                ctx.beginPath();\n                ctx.moveTo(fromNode.x, fromNode.y);\n                ctx.lineTo(toNode.x, toNode.y);\n                ctx.strokeStyle = '#34495e';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw weight\n                const midX = (fromNode.x + toNode.x) / 2;\n                const midY = (fromNode.y + toNode.y) / 2;\n                ctx.fillStyle = '#34495e';\n                ctx.font = '14px Arial';\n                ctx.fillText(edge.weight, midX + 10, midY - 10);\n            });\n            \n            // Draw nodes\n            nodes.forEach((node, index) => {\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);\n                ctx.fillStyle = '#3498db';\n                ctx.fill();\n                ctx.strokeStyle = '#2980b9';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Draw node label\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 16px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(String.fromCharCode(65 + index), node.x, node.y);\n            });\n        }\n\n        // Handle canvas clicks for adding nodes\n        function handleCanvasClick(e) {\n            if (isRunning) return;\n            \n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            // Check if click is on an existing node\n            const clickedNode = nodes.findIndex(node => \n                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);\n            \n            if (clickedNode === -1) {\n                // Add new node\n                addNode(x, y);\n                drawGraph();\n                initializeAlgorithm();\n            }\n        }\n\n        // Handle canvas right-clicks for setting edge weights\n        function handleCanvasRightClick(e) {\n            e.preventDefault();\n            if (isRunning) return;\n            \n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            // Find if click is near an edge\n            for (let i = 0; i < edges.length; i++) {\n                const edge = edges[i];\n                const fromNode = nodes[edge.from];\n                const toNode = nodes[edge.to];\n                \n                // Calculate distance from point to line segment\n                const A = { x: fromNode.x, y: fromNode.y };\n                const B = { x: toNode.x, y: toNode.y };\n                const P = { x, y };\n                \n                const distance = pointToLineDistance(A, B, P);\n                \n                if (distance < 15) {\n                    const newWeight = prompt(`Enter new weight for edge ${String.fromCharCode(65 + edge.from)}-${String.fromCharCode(65 + edge.to)}:`, edge.weight);\n                    if (newWeight !== null && !isNaN(newWeight) && newWeight !== '') {\n                        edge.weight = parseInt(newWeight);\n                        drawGraph();\n                        initializeAlgorithm();\n                    }\n                    break;\n                }\n            }\n        }\n\n        // Calculate distance from point to line segment\n        function pointToLineDistance(A, B, P) {\n            const AB = { x: B.x - A.x, y: B.y - A.y };\n            const AP = { x: P.x - A.x, y: P.y - A.y };\n            \n            const ab2 = AB.x * AB.x + AB.y * AB.y;\n            const ap_ab = AP.x * AB.x + AP.y * AB.y;\n            \n            let t = ap_ab / ab2;\n            t = Math.max(0, Math.min(1, t));\n            \n            const closest = {\n                x: A.x + AB.x * t,\n                y: A.y + AB.y * t\n            };\n            \n            return Math.sqrt((P.x - closest.x) ** 2 + (P.y - closest.y) ** 2);\n        }\n\n        // Edge creation variables\n        let isCreatingEdge = false;\n        let edgeStartNode = null;\n        let mouseX = 0;\n        let mouseY = 0;\n\n        // Start creating an edge\n        function startEdgeCreation(e) {\n            if (isRunning) return;\n            \n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            // Check if click is on a node\n            const clickedNode = nodes.findIndex(node => \n                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);\n            \n            if (clickedNode !== -1) {\n                isCreatingEdge = true;\n                edgeStartNode = clickedNode;\n                mouseX = x;\n                mouseY = y;\n            }\n        }\n\n        // Update edge creation while mouse is moving\n        function updateEdgeCreation(e) {\n            if (!isCreatingEdge) return;\n            \n            const rect = canvas.getBoundingClientRect();\n            mouseX = e.clientX - rect.left;\n            mouseY = e.clientY - rect.top;\n            \n            drawGraph();\n            \n            // Draw temporary edge\n            const startNode = nodes[edgeStartNode];\n            ctx.beginPath();\n            ctx.moveTo(startNode.x, startNode.y);\n            ctx.lineTo(mouseX, mouseY);\n            ctx.strokeStyle = '#e74c3c';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n        }\n\n        // Finish creating an edge\n        function finishEdgeCreation(e) {\n            if (!isCreatingEdge) return;\n            \n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            \n            // Check if release is on a node\n            const clickedNode = nodes.findIndex(node => \n                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);\n            \n            if (clickedNode !== -1 && clickedNode !== edgeStartNode) {\n                const weight = prompt(`Enter weight for edge ${String.fromCharCode(65 + edgeStartNode)}-${String.fromCharCode(65 + clickedNode)}:`, \"1\");\n                if (weight !== null && !isNaN(weight) && weight !== '') {\n                    addEdge(edgeStartNode, clickedNode, parseInt(weight));\n                }\n            }\n            \n            isCreatingEdge = false;\n            edgeStartNode = null;\n            drawGraph();\n            initializeAlgorithm();\n        }\n\n        // Initialize the Floyd-Warshall algorithm\n        function initializeAlgorithm() {\n            const n = nodes.length;\n            \n            // Initialize distance matrix with Infinity for unconnected nodes\n            distanceMatrix = Array(n).fill().map(() => Array(n).fill(Infinity));\n            pathMatrix = Array(n).fill().map(() => Array(n).fill(null));\n            \n            // Set diagonal to 0\n            for (let i = 0; i < n; i++) {\n                distanceMatrix[i][i] = 0;\n                pathMatrix[i][i] = i;\n            }\n            \n            // Set known edge weights\n            edges.forEach(edge => {\n                distanceMatrix[edge.from][edge.to] = edge.weight;\n                distanceMatrix[edge.to][edge.from] = edge.weight;\n                pathMatrix[edge.from][edge.to] = edge.to;\n                pathMatrix[edge.to][edge.from] = edge.from;\n            });\n            \n            // Reset algorithm state\n            algorithmState = {\n                k: 0,\n                i: 0,\n                j: 0,\n                n: n\n            };\n            \n            currentStep = 0;\n            updateMatrixDisplay();\n            updateStepsContainer(\"Algorithm initialized. Click 'Run Algorithm' to start.\");\n            enableAlgorithmControls(false);\n        }\n\n        // Run one step of the Floyd-Warshall algorithm\n        function stepAlgorithm() {\n            if (!algorithmState || algorithmState.k >= algorithmState.n) {\n                isRunning = false;\n                enableAlgorithmControls(false);\n                updateStepsContainer(\"Algorithm completed! All shortest paths found.\");\n                return;\n            }\n            \n            const { k, i, j, n } = algorithmState;\n            currentStep++;\n            \n            // Update step description\n            let stepDescription = `Step ${currentStep}: Checking path from ${String.fromCharCode(65 + i)} to ${String.fromCharCode(65 + j)} via ${String.fromCharCode(65 + k)}. `;\n            \n            // Check if we can get a shorter path via node k\n            const viaK = distanceMatrix[i][k] + distanceMatrix[k][j];\n            \n            if ("
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}