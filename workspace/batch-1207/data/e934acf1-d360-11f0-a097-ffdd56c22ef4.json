{
  "id": "e934acf1-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:21.330Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Recursion Explorer — Interactive Demonstrations</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #6dd3ff;\n      --muted: #97a0b8;\n      --success: #8be28b;\n      --danger: #ff8b8b;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body { height:100%; margin:0; font-family: Inter, Roboto, -apple-system, \"Segoe UI\", \"Helvetica Neue\", Arial; background: linear-gradient(180deg,#071226 0%, #061826 60%, #081322 100%); color: #e6eef6; }\n    .wrap { max-width:1100px; margin:28px auto; padding:24px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 10px 30px rgba(2,6,23,0.7); }\n    h1 { margin:0 0 8px 0; font-weight:600; color:var(--accent); }\n    p.lead { margin:0 0 18px 0; color:var(--muted); }\n    .grid { display:grid; grid-template-columns: 1fr; gap:18px; }\n    @media(min-width:980px){ .grid { grid-template-columns: 420px 1fr; } }\n    .card { background:var(--panel); border-radius:10px; padding:12px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }\n    input[type=\"number\"], input[type=\"range\"], select { background:var(--glass); border:1px solid rgba(255,255,255,0.03); color: #e6eef6; padding:8px 10px; border-radius:8px; outline:none; }\n    button { background: linear-gradient(180deg,#2b6b8a,#1d4b63); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }\n    button.secondary { background: linear-gradient(180deg,#2b2f3b,#13141a); color:var(--muted); }\n    .small { font-size:13px; padding:6px 8px; }\n    .stack-area { min-height:120px; display:flex; align-items:flex-end; justify-content:center; gap:10px; padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent); border-radius:8px; overflow:auto; }\n    .frame { min-width:120px; max-width:220px; padding:8px 10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); box-shadow: 0 8px 16px rgba(0,0,0,0.5); font-size:13px; }\n    .frame .fn { color:var(--accent); font-weight:600; }\n    .frame .args { color:var(--muted); font-size:12px; margin-top:6px; }\n    .frame .ret { margin-top:8px; font-weight:700; color:var(--success); font-size:13px; }\n    .events { max-height:240px; overflow:auto; padding:8px; border-radius:8px; background:rgba(255,255,255,0.01); font-family:monospace; font-size:13px; color:var(--muted); }\n    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n    .split { display:flex; gap:12px; align-items:flex-start; }\n    .col { flex:1; }\n    canvas { width:100%; height:420px; display:block; background: linear-gradient(180deg,#021018,#06202b); border-radius:8px; border:1px solid rgba(255,255,255,0.03); }\n    .footer { margin-top:12px; color:var(--muted); font-size:13px; }\n    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px; }\n    .legend { display:flex; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; flex-wrap:wrap;}\n    .legend .dot { width:10px;height:10px;border-radius:50%; display:inline-block; }\n    .dot.call { background:#6dd3ff; } .dot.return { background:#8be28b; } .dot.work { background:#ffb86b; }\n    pre.code { background: rgba(255,255,255,0.02); padding:10px; border-radius:8px; overflow:auto; font-size:13px; color:#dff7ff; }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <h1>Recursion Explorer</h1>\n    <p class=\"lead\">Interactive demonstrations to explain recursion: see how recursive calls are stacked and returned, compare naive vs memoized recursion, and visualize a recursive fractal tree. Use small inputs to keep traces readable.</p>\n\n    <div class=\"grid\">\n      <!-- Left Column: Controls -->\n      <div class=\"col\">\n        <div class=\"card\">\n          <h3 style=\"margin:0 0 8px 0;\">Factorial — Call Stack Trace</h3>\n          <div class=\"controls\">\n            <label>n <input id=\"factN\" type=\"number\" min=\"0\" max=\"12\" value=\"6\" style=\"width:80px;\"></label>\n            <label>Speed <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"400\"></label>\n            <button id=\"runFact\" class=\"small\">Run Trace</button>\n            <button id=\"runFactInstant\" class=\"small secondary\">Compute Only</button>\n          </div>\n          <div class=\"stack-area card\" id=\"stackArea\" style=\"min-height:140px;\"></div>\n          <div class=\"row\">\n            <div style=\"flex:1\"><div class=\"events\" id=\"factEvents\">Call/return events will appear here.</div></div>\n          </div>\n          <div class=\"legend\">\n            <span class=\"dot call\"></span> enter / push\n            <span class=\"dot return\"></span> return / pop\n            <span class=\"dot work\"></span> work / multiplication\n          </div>\n        </div>\n\n        <div style=\"height:14px;\"></div>\n\n        <div class=\"card\">\n          <h3 style=\"margin:0 0 8px 0;\">Fibonacci — Naive vs Memoized</h3>\n          <div class=\"controls\">\n            <label>n <input id=\"fibN\" type=\"number\" min=\"0\" max=\"35\" value=\"10\" style=\"width:90px;\"></label>\n            <button id=\"runFib\" class=\"small\">Compare</button>\n          </div>\n          <div style=\"display:flex; gap:8px; align-items:center; margin-top:8px;\">\n            <div style=\"flex:1;\">\n              <div class=\"card\">\n                <div style=\"font-size:13px; color:var(--muted)\">Naive recursion</div>\n                <div id=\"fibNaive\" style=\"font-size:18px; font-weight:700; margin-top:6px;\">—</div>\n                <div style=\"color:var(--muted); font-size:13px; margin-top:6px;\" id=\"fibNaiveCalls\">Calls: —</div>\n              </div>\n            </div>\n            <div style=\"flex:1;\">\n              <div class=\"card\">\n                <div style=\"font-size:13px; color:var(--muted)\">Memoized recursion</div>\n                <div id=\"fibMemo\" style=\"font-size:18px; font-weight:700; margin-top:6px;\">—</div>\n                <div style=\"color:var(--muted); font-size:13px; margin-top:6px;\" id=\"fibMemoCalls\">Calls: —</div>\n              </div>\n            </div>\n          </div>\n          <div style=\"margin-top:8px;\">\n            <div class=\"small\" style=\"color:var(--muted)\">Tip: naive recursion calls grow exponentially; memoization caches results to avoid repeated work.</div>\n          </div>\n        </div>\n\n        <div style=\"height:14px;\"></div>\n\n        <div class=\"card\">\n          <h3 style=\"margin:0 0 8px 0;\">Short explanation</h3>\n          <p style=\"margin:0; color:var(--muted); font-size:14px;\">Recursion is when a function calls itself. Every recursive call creates a new stack frame (its own parameters and local variables). To stop infinite recursion you need a base case. Trace helps illustrate pushes (enter) and pops (return).</p>\n        </div>\n      </div>\n\n      <!-- Right Column: Visualization -->\n      <div class=\"col\">\n        <div class=\"card\">\n          <h3 style=\"margin:0 0 8px 0;\">Fractal Tree — Visual recursive drawing</h3>\n          <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n            <label>Depth <input id=\"treeDepth\" type=\"range\" min=\"0\" max=\"12\" value=\"9\" style=\"width:180px;\"></label>\n            <span class=\"badge\" id=\"treeDepthLabel\">9</span>\n            <label style=\"margin-left:auto\">Angle <input id=\"angle\" type=\"range\" min=\"10\" max=\"60\" value=\"22\" style=\"width:150px;\"></label>\n            <span class=\"badge\" id=\"angleLabel\">22°</span>\n            <button id=\"drawTree\" class=\"small\">Redraw</button>\n          </div>\n          <canvas id=\"treeCanvas\" width=\"800\" height=\"420\"></canvas>\n          <div class=\"footer\">Recursive drawing: the function draws a trunk then calls itself for branches until depth reaches zero (base case).</div>\n        </div>\n\n        <div style=\"height:14px;\"></div>\n\n        <div class=\"card\">\n          <h3 style=\"margin:0 0 8px 0;\">Factorial Code (recursive)</h3>\n          <pre class=\"code\" id=\"codeSample\">\nfunction factorial(n) {\n  if (n <= 1) return 1;   // base case\n  return n * factorial(n - 1); // recursive case\n}\n          </pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Utilities & DOM\n    const byId = id => document.getElementById(id);\n    const stackArea = byId('stackArea');\n    const factEvents = byId('factEvents');\n    const runFact = byId('runFact');\n    const runFactInstant = byId('runFactInstant');\n    const factN = byId('factN');\n    const speedRange = byId('speed');\n\n    // Tracer collects enter/return events during actual recursion.\n    function makeTracer() {\n      let events = [];\n      let stackSize = 0;\n      return {\n        enter(fn, args) {\n          events.push({type:'enter', fn, args: JSON.parse(JSON.stringify(args)), stackSize});\n          stackSize++;\n        },\n        exit(fn, args, ret) {\n          stackSize = Math.max(0, stackSize - 1);\n          events.push({type:'return', fn, args: JSON.parse(JSON.stringify(args)), ret, stackSize});\n        },\n        getEvents() { return events; },\n        clear() { events = []; stackSize = 0; }\n      };\n    }\n\n    // Recursive factorial that uses tracer\n    function tracedFactorial(n, tracer) {\n      tracer.enter('factorial', {n});\n      if (n <= 1) {\n        tracer.exit('factorial', {n}, 1);\n        return 1;\n      }\n      const sub = tracedFactorial(n - 1, tracer);\n      const res = n * sub;\n      tracer.exit('factorial', {n}, res);\n      return res;\n    }\n\n    // Animation: play events with visual stack frames\n    async function animateEvents(events, speedMs) {\n      // Clear UI\n      stackArea.innerHTML = '';\n      factEvents.innerHTML = '';\n      const frames = []; // maps to DOM elements representing stack frames, index is depth\n      for (let i = 0; i < events.length; i++) {\n        const ev = events[i];\n        const line = document.createElement('div');\n        line.textContent = (ev.type === 'enter' ? '→ enter ' : '← return ') + ev.fn + '(' + (ev.args && ev.args.n !== undefined ? ev.args.n : '') + ')' + (ev.type === 'return' ? ' = ' + ev.ret : '');\n        line.style.opacity = '0.95';\n        factEvents.appendChild(line);\n        factEvents.scrollTop = factEvents.scrollHeight;\n\n        if (ev.type === 'enter') {\n          // create frame at ev.stackSize index\n          const frame = document.createElement('div');\n          frame.className = 'frame';\n          frame.dataset.depth = ev.stackSize;\n          frame.innerHTML = '<div class=\"fn\">' + ev.fn + '</div>' +\n                            '<div class=\"args\">n = ' + ev.args.n + '</div>' +\n                            '<div class=\"ret\" style=\"visibility:hidden;\">ret</div>';\n          // append to stackArea (we place frames left-to-right as stack bottom->top)\n          stackArea.appendChild(frame);\n          frames.push(frame);\n          await sleep(speedMs);\n        } else if (ev.type === 'return') {\n          // annotate the top frame then remove it shortly after\n          // find the last frame with matching depth\n          const topFrame = frames[frames.length - 1];\n          if (topFrame) {\n            const retDiv = topFrame.querySelector('.ret');\n            retDiv.textContent = 'return = ' + ev.ret;\n            retDiv.style.visibility = 'visible';\n            // highlight quickly\n            topFrame.style.boxShadow = '0 12px 20px rgba(139,226,139,0.12)';\n            await sleep(speedMs * 0.9);\n            // pop\n            stackArea.removeChild(topFrame);\n            frames.pop();\n            await sleep(speedMs * 0.1);\n          } else {\n            // fallback small pause\n            await sleep(speedMs);\n          }\n        }\n      }\n      // final note\n      const done = document.createElement('div');\n      done.style.color = 'var(--muted)';\n      done.style.padding = '8px';\n      done.textContent = 'Trace finished. Final result shown above on last return event.';\n      factEvents.appendChild(done);\n      factEvents.scrollTop = factEvents.scrollHeight;\n    }\n\n    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }\n\n    runFact.addEventListener('click', async () => {\n      const n = Math.max(0, Math.min(12, parseInt(factN.value || 0)));\n      const tracer = makeTracer();\n      try {\n        // Build trace synchronously\n        tracedFactorial(n, tracer);\n      } catch (e) {\n        alert('Error during recursion: ' + e);\n        return;\n      }\n      const events = tracer.getEvents();\n      // Clear display\n      factEvents.innerHTML = '';\n      stackArea.innerHTML = '';\n      const sp = Math.max(40, parseInt(speedRange.value || 400));\n      await animateEvents(events, sp);\n    });\n\n    runFactInstant.addEventListener('click', () => {\n      const n = Math.max(0, Math.min(100000, parseInt(factN.value || 0)));\n      // compute without tracer, fast\n      try {\n        const res = (function f(x){ if (x<=1) return 1; return x * f(x-1); })(n);\n        factEvents.innerHTML = 'factorial(' + n + ') = ' + res;\n        stackArea.innerHTML = '<div class=\"frame\"><div class=\"fn\">result</div><div class=\"args\">n = '+n+'</div><div class=\"ret\" style=\"visibility:visible;\">'+res+'</div></div>';\n      } catch (e) {\n        factEvents.innerHTML = 'Error: recursion might be too deep';\n      }\n    });\n\n    // Fibonacci comparison: count calls & compute value\n    byId('runFib').addEventListener('click', () => {\n      const n = Math.max(0, Math.min(35, parseInt(byId('fibN').value || 0)));\n      // naive recursion with call counting\n      let callsNaive = 0;\n      function fibNaive(k) {\n        callsNaive++;\n        if (k <= 1) return k;\n        return fibNaive(k-1) + fibNaive(k-2);\n      }\n      // memoized\n      let callsMemo = 0;\n      const mem = {};\n      function fibMemo(k) {\n        callsMemo++;\n        if (k <= 1) return k;\n        if (mem[k] !== undefined) return mem[k];\n        mem[k] = fibMemo(k-1) + fibMemo(k-2);\n        return mem[k];\n      }\n\n      // run (naive might be slow for n > ~35; we clamp)\n      const t0 = performance.now();\n      const valNaive = fibNaive(n);\n      const t1 = performance.now();\n      const timeNaive = (t1 - t0).toFixed(2);\n\n      const t2 = performance.now();\n      const valMemo = fibMemo(n);\n      const t3 = performance.now();\n      const timeMemo = (t3 - t2).toFixed(2);\n\n      byId('fibNaive').textContent = (valNaive === undefined ? '—' : valNaive) + '  (' + timeNaive + ' ms)';\n      byId('fibNaiveCalls').textContent = 'Calls: ' + callsNaive;\n      byId('fibMemo').textContent = valMemo + '  (' + timeMemo + ' ms)';\n      byId('fibMemoCalls').textContent = 'Calls: ' + callsMemo + (mem ? '  (cache hits reduced work)' : '');\n    });\n\n    // Fractal tree drawing\n    const canvas = byId('treeCanvas');\n    const ctx = canvas.getContext('2d');\n    function resizeCanvasToDisplaySize(canvas) {\n      const ratio = window.devicePixelRatio || 1;\n      const w = canvas.clientWidth * ratio;\n      const h = canvas.clientHeight * ratio;\n      if (canvas.width !== w || canvas.height !== h) {\n        canvas.width = w;\n        canvas.height = h;\n      }\n    }\n    function drawTree(depth, angleDeg) {\n      resizeCanvasToDisplaySize(canvas);\n      ctx.clearRect(0,0,canvas.width, canvas.height);\n      ctx.save();\n      // Start in middle bottom\n      ctx.translate(canvas.width / 2, canvas.height - 20);\n      // Initial trunk\n      const trunk = Math.min(canvas.height / 4, 220);\n      // recursive draw\n      function drawBranch(len, depthLeft) {\n        // base case\n        if (depthLeft <= 0 || len < 2) {\n          // draw a leaf dot\n          ctx.beginPath();\n          ctx.fillStyle = '#8be28b';\n          ctx.arc(0, 0, 2.2, 0, Math.PI * 2);\n          ctx.fill();\n          return;\n        }\n        // draw trunk segment\n        ctx.lineWidth = Math.max(1, depthLeft * 0.9);\n        ctx.strokeStyle = depthLeft > 2 ? '#f1c27d' : '#b4e6a8';\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(0, -len);\n        ctx.stroke();\n\n        // move to end\n        ctx.translate(0, -len);\n\n        // right branch\n        ctx.save();\n        ctx.rotate((angleDeg * Math.PI / 180) * (0.9 + Math.sin(depthLeft) * 0.03));\n        drawBranch(len * (0.68 - (depthLeft*0.006)), depthLeft - 1);\n        ctx.restore();\n\n        // left branch\n        ctx.save();\n        ctx.rotate((-angleDeg * Math.PI / 180) * (0.9 + Math.cos(depthLeft) * 0.03));\n        drawBranch(len * (0.68 - (depthLeft*0.006)), depthLeft - 1);\n        ctx.restore();\n\n        // occasionally draw a middle branch\n        if (depthLeft % 3 === 0) {\n          ctx.save();\n          ctx.rotate((Math.random() - 0.5) * 0.2);\n          drawBranch(len * 0.5, depthLeft - 2);\n          ctx.restore();\n        }\n\n        // move back\n        ctx.translate(0, len);\n      }\n\n      drawBranch(trunk, depth);\n      ctx.restore();\n    }\n\n    // initial draw\n    function updateTreeLabels() {\n      byId('treeDepthLabel').textContent = byId('treeDepth').value;\n      byId('angleLabel').textContent = byId('angle').value + '°';\n    }\n    byId('treeDepth').addEventListener('input', updateTreeLabels);\n    byId('angle').addEventListener('input', updateTreeLabels);\n\n    byId('drawTree').addEventListener('click', () => {\n      const d = Math.max(0, Math.min(14, parseInt(byId('treeDepth').value || 0)));\n      const a = Math.max(0, Math.min(90, parseInt(byId('angle').value || 20)));\n      updateTreeLabels();\n      drawTree(d, a);\n    });\n\n    window.addEventListener('load', () => {\n      updateTreeLabels();\n      drawTree(parseInt(byId('treeDepth').value || 9), parseInt(byId('angle').value || 22));\n    });\n\n    window.addEventListener('resize', () => {\n      // redraw on resize\n      drawTree(parseInt(byId('treeDepth').value || 9), parseInt(byId('angle').value || 22));\n    });\n\n    // Helpful: show small demo by default (run factorial trace once)\n    (function initialDemo(){\n      // slight delay so UI shows\n      setTimeout(() => {\n        runFact.click();\n      }, 350);\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}