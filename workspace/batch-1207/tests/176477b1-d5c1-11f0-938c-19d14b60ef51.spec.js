import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/batch-1207/html/176477b1-d5c1-11f0-938c-19d14b60ef51.html';

/**
 * Page Object for the Huffman Coding Visualization page.
 * Encapsulates common interactions and queries.
 */
class HuffmanPage {
  /**
   * @param {import('@playwright/test').Page} page
   */
  constructor(page) {
    this.page = page;
    this.input = page.locator('#inputString');
    this.generateButton = page.locator('button[onclick="generateHuffmanTree()"]');
    this.output = page.locator('#output');
  }

  async navigate() {
    await this.page.goto(APP_URL);
  }

  async setInput(value) {
    await this.input.fill(value);
  }

  async clickGenerate() {
    await this.generateButton.click();
  }

  async getOutputInnerHTML() {
    return this.output.evaluate((el) => el.innerHTML);
  }

  async getOutputText() {
    return this.output.innerText();
  }

  async getCodeParagraphs() {
    return this.output.locator('p');
  }

  async getHeader() {
    return this.output.locator('h2');
  }

  async getNodeElements() {
    // nodes created by displayHuffmanTree() have class 'node' in returned HTML strings
    return this.output.locator('.node');
  }
}

test.describe('Huffman Coding Visualization â€” FSM and UI tests', () => {
  // Arrays to collect console messages and page errors for each test
  let consoleMessages;
  let pageErrors;

  test.beforeEach(async ({ page }) => {
    consoleMessages = [];
    pageErrors = [];

    // Collect console messages
    page.on('console', (msg) => {
      consoleMessages.push({
        type: msg.type(),
        text: msg.text(),
      });
    });

    // Collect uncaught exceptions from the page
    page.on('pageerror', (err) => {
      // err is an Error object
      pageErrors.push({
        name: err.name,
        message: err.message,
        stack: err.stack,
      });
    });

    // Create page object and navigate
    const hp = new HuffmanPage(page);
    await hp.navigate();
  });

  test.afterEach(async ({ page }) => {
    // Ensure listeners are removed after tests (Playwright removes page listeners when page is closed,
    // but being explicit in case of reuse)
    page.removeAllListeners('console');
    page.removeAllListeners('pageerror');
  });

  test('Idle state: initial render displays input, button and empty output', async ({ page }) => {
    // This test validates the S0_Idle state entry actions (renderPage) and evidence elements.
    const hp = new HuffmanPage(page);

    // Verify input is present with correct placeholder
    await expect(hp.input).toBeVisible();
    await expect(hp.input).toHaveAttribute('placeholder', 'Enter a string here');

    // Verify generate button is present
    await expect(hp.generateButton).toBeVisible();
    await expect(hp.generateButton).toHaveText('Generate Huffman Tree');

    // Verify output container exists and is initially empty
    await expect(hp.output).toBeVisible();
    const initialOutputHTML = await hp.getOutputInnerHTML();
    expect(initialOutputHTML.trim()).toBe('', 'Expected output to be empty on initial render');

    // Assert that no uncaught page errors were emitted during initial load
    expect(pageErrors.length).toBe(0);
    // Also assert there are no fatal console errors like SyntaxError in initial load
    const syntaxErrors = consoleMessages.filter((m) => /SyntaxError/.test(m.text));
    expect(syntaxErrors.length).toBe(0);
  });

  test('Transition: Generate Huffman Tree with normal input -> displays character codes and tree HTML', async ({ page }) => {
    // This test drives the main transition from S0_Idle -> S1_TreeGenerated by clicking the button.
    // It validates generateHuffmanTree() executes and the UI is updated accordingly.
    const hp = new HuffmanPage(page);

    // Provide a typical input string with multiple characters and frequencies
    await hp.setInput('aabbc');

    // Click the generate button and wait briefly for DOM updates
    await hp.clickGenerate();

    // Check that the "Character Codes:" header is present in output
    const header = hp.getHeader();
    await expect(header).toBeVisible();
    await expect(header).toHaveText('Character Codes:');

    // There should be a paragraph entry per distinct character (a, b, c) => 3
    const paragraphs = hp.getCodeParagraphs();
    await expect(paragraphs).toHaveCount(3);

    // Validate that each expected character appears in the codes list
    const text = await hp.getOutputText();
    expect(text).toContain('a:');
    expect(text).toContain('b:');
    expect(text).toContain('c:');

    // Verify that tree HTML was appended and contains at least one node element
    const nodes = hp.getNodeElements();
    await expect(nodes.first()).toBeVisible();

    // Inspect collected console messages and page errors.
    // We assert there were no SyntaxError console messages.
    const syntaxErrors = consoleMessages.filter((m) => /SyntaxError/.test(m.text));
    expect(syntaxErrors.length).toBe(0);

    // If any page errors occurred, assert their types are Error subclasses and include helpful diagnostics.
    // We do not forcibly fail the test solely because of a console warning, but we do assert that
    // any captured pageErrors have name and message properties.
    for (const err of pageErrors) {
      expect(err.name).toBeTruthy();
      expect(err.message).toBeTruthy();
    }
  });

  test('Edge case: empty input should render header only and not throw uncaught exceptions', async ({ page }) => {
    // This test validates behavior when input is empty string (edge case)
    const hp = new HuffmanPage(page);

    await hp.setInput('');
    await hp.clickGenerate();

    // Header should exist but there should be zero code paragraphs
    const header = hp.getHeader();
    await expect(header).toBeVisible();
    await expect(header).toHaveText('Character Codes:');

    const paragraphs = hp.getCodeParagraphs();
    await expect(paragraphs).toHaveCount(0);

    // Tree may be absent when no characters provided; ensure no crash occurred
    // Assert that there were no uncaught page errors (TypeError/ReferenceError) during this interaction
    expect(pageErrors.length).toBe(0);

    // Also ensure console does not contain immediate TypeError/ReferenceError messages
    const runtimeErrors = consoleMessages.filter((m) => /(TypeError|ReferenceError)/.test(m.text));
    expect(runtimeErrors.length).toBe(0);
  });

  test('Edge case: single character input produces a code entry (possibly empty code) and stable DOM', async ({ page }) => {
    // This test uses a single repeated character input to validate handling of single-node Huffman tree.
    const hp = new HuffmanPage(page);

    await hp.setInput('aaaa');
    await hp.clickGenerate();

    // Should show header and one paragraph for character 'a'
    const header = hp.getHeader();
    await expect(header).toBeVisible();
    await expect(header).toHaveText('Character Codes:');

    const paragraphs = hp.getCodeParagraphs();
    await expect(paragraphs).toHaveCount(1);

    // The paragraph should contain 'a:' even if code is empty string
    const paragraphText = await paragraphs.nth(0).innerText();
    expect(paragraphText.startsWith('a:')).toBe(true);

    // There should be no uncaught page errors for this valid input
    expect(pageErrors.length).toBe(0);
  });

  test('Robustness: observe console and page errors during repeated interactions', async ({ page }) => {
    // This test performs multiple generate actions to surface any intermittent errors and
    // asserts that errors, if any, are captured and reported for analysis.
    const hp = new HuffmanPage(page);

    // Sequence of inputs to exercise different branches
    const inputs = ['abc', '', 'aaabbbccc', 'x', 'aabbc'];

    for (const val of inputs) {
      await hp.setInput(val);
      await hp.clickGenerate();

      // Small wait to allow DOM updates to settle
      await page.waitForTimeout(100);
    }

    // After multiple interactions, assert that there were no SyntaxErrors in console
    const syntaxErrors = consoleMessages.filter((m) => /SyntaxError/.test(m.text));
    expect(syntaxErrors.length).toBe(0);

    // If pageErrors occurred, make assertions about their structure (they should be Error objects)
    for (const err of pageErrors) {
      // Ensure we got an error name and message (this documents unexpected runtime failures)
      expect(typeof err.name).toBe('string');
      expect(err.name.length).toBeGreaterThan(0);
      expect(typeof err.message).toBe('string');
    }

    // For visibility in test results, assert that either no page errors happened OR at least one captured error
    // This assertion will always pass; it's mainly to ensure pageErrors is a defined array for diagnostics.
    expect(Array.isArray(pageErrors)).toBe(true);
  });
});