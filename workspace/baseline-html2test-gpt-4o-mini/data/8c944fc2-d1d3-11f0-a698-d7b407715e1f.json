{
  "id": "8c944fc2-d1d3-11f0-a698-d7b407715e1f",
  "timestamp": "2025-12-05T12:12:04.794Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-4o-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        canvas {\n            border: 1px solid #000;\n        }\n        #inputGraph {\n            width: 300px;\n            height: 100px;\n            margin-bottom: 20px;\n        }\n        #output {\n            margin-top: 20px;\n            white-space: pre;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Topological Sort Visualization</h1>\n<p>Enter directed graph edges (e.g., \"A->B, B->C, A->C\"):</p>\n<input type=\"text\" id=\"inputGraph\" placeholder=\"Enter edges\"/>\n<button id=\"sortButton\">Perform Topological Sort</button>\n\n<canvas id=\"graphCanvas\" width=\"500\" height=\"400\"></canvas>\n\n<h2>Sorted Order:</h2>\n<pre id=\"output\"></pre>\n\n<script>\n    document.getElementById('sortButton').onclick = function() {\n        const input = document.getElementById('inputGraph').value;\n        const edges = input.split(',').map(edge => edge.trim());\n        const graph = {};\n        const indegree = {};\n        \n        // Build graph and indegree\n        edges.forEach(edge => {\n            const [u, v] = edge.split('->').map(node => node.trim());\n            if (!graph[u]) graph[u] = [];\n            graph[u].push(v);\n            indegree[v] = (indegree[v] || 0) + 1;\n            indegree[u] = indegree[u] || 0; \n        });\n\n        // Kahn's algorithm for topological sort\n        const queue = [];\n        for (let node in indegree) {\n            if (indegree[node] === 0) {\n                queue.push(node);\n            }\n        }\n\n        const sortedOrder = [];\n        while (queue.length) {\n            const node = queue.shift();\n            sortedOrder.push(node);\n\n            for (let neighbor of (graph[node] || [])) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] === 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        // Display sorted order\n        document.getElementById('output').innerText = sortedOrder.join(' -> ');\n\n        // Draw graph\n        drawGraph(graph);\n    };\n\n    function drawGraph(graph) {\n        const canvas = document.getElementById('graphCanvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        const positions = {};\n        const nodes = Object.keys(graph);\n        const radius = 20;\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const angleStep = (2 * Math.PI) / nodes.length;\n\n        let angle = 0;\n        nodes.forEach((node, index) => {\n            const x = centerX + Math.cos(angle) * 100;\n            const y = centerY + Math.sin(angle) * 100;\n            positions[node] = { x, y };\n            angle += angleStep;\n        });\n\n        // Draw edges\n        for (let u in graph) {\n            const { x: startX, y: startY } = positions[u];\n            graph[u].forEach(v => {\n                const { x: endX, y: endY } = positions[v];\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n                ctx.fillText('->', (startX + endX) / 2, (startY + endY) / 2 - 3);\n            });\n        }\n\n        // Draw nodes\n        for (let node in positions) {\n            const { x, y } = positions[node];\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n            ctx.fillStyle = 'lightblue';\n            ctx.fill();\n            ctx.stroke();\n            ctx.fillStyle = 'black';\n            ctx.fillText(node, x - 5, y + 5);\n        }\n    }\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}