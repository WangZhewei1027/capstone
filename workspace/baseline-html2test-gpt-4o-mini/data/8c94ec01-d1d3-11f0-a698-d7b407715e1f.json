{
  "id": "8c94ec01-d1d3-11f0-a698-d7b407715e1f",
  "timestamp": "2025-12-05T12:12:08.866Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-4o-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Nearest Neighbors (KNN) Demo</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n        }\n        #canvas {\n            border: 1px solid #ccc;\n            cursor: pointer;\n        }\n        .legend {\n            margin-top: 20px;\n        }\n        .point {\n            width: 30px;\n            height: 30px;\n            border-radius: 50%;\n            display: inline-block;\n            margin-right: 10px;\n        }\n        .red { background-color: red; }\n        .blue { background-color: blue; }\n    </style>\n</head>\n<body>\n\n<h1>K-Nearest Neighbors (KNN) Visualization</h1>\n<canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n<div class=\"legend\">\n    <div class=\"point red\"></div> Class A\n    <div class=\"point blue\"></div> Class B\n</div>\n<script>\n    const canvas = document.getElementById(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    const dataPoints = [];\n    const k = 3;\n\n    // Generate synthetic data points\n    function generateData() {\n        for (let i = 0; i < 50; i++) {\n            const x = Math.random() * 600;\n            const y = Math.random() * 400;\n            const classType = Math.random() > 0.5 ? 'A' : 'B';\n            dataPoints.push({ x, y, class: classType });\n        }\n    }\n\n    function drawPoints() {\n        dataPoints.forEach(point => {\n            ctx.fillStyle = point.class === 'A' ? 'red' : 'blue';\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n            ctx.fill();\n        });\n    }\n\n    function getDistance(pointA, pointB) {\n        return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n    }\n\n    function classifyPoint(newPoint) {\n        const distances = dataPoints.map(point => ({\n            point: point,\n            distance: getDistance(point, newPoint)\n        }));\n        \n        distances.sort((a, b) => a.distance - b.distance);\n        \n        const neighbors = distances.slice(0, k);\n        const votes = {};\n        \n        neighbors.forEach(neighbor => {\n            votes[neighbor.point.class] = (votes[neighbor.point.class] || 0) + 1;\n        });\n        \n        return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);\n    }\n\n    canvas.addEventListener(\"click\", (e) => {\n        const rect = canvas.getBoundingClientRect();\n        const newPoint = {\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n        };\n        \n        const classification = classifyPoint(newPoint);\n        \n        ctx.fillStyle = classification === 'A' ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)';\n        ctx.beginPath();\n        ctx.arc(newPoint.x, newPoint.y, 10, 0, Math.PI * 2);\n        ctx.fill();\n        \n        alert(`The new point is classified as Class ${classification}`);\n    });\n\n    generateData();\n    drawPoints();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}