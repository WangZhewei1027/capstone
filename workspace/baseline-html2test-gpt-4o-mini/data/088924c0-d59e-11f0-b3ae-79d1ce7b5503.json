{
  "id": "088924c0-d59e-11f0-b3ae-79d1ce7b5503",
  "timestamp": "2025-12-10T07:59:39.926Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        #graph {\n            margin-top: 20px;\n        }\n        ul {\n            list-style-type: none;\n            padding: 0;\n        }\n        li {\n            margin: 5px 0;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Topological Sort Visualization</h1>\n<p>Enter the graph as a list of edges. For example: A→B, A→C, B→D, C→D</p>\n<textarea id=\"edgesInput\" rows=\"4\" style=\"width: 100%;\"></textarea><br>\n<button onclick=\"performTopologicalSort()\">Sort</button>\n\n<h2>Topological Order:</h2>\n<div id=\"result\"></div>\n\n<script>\n    function performTopologicalSort() {\n        const input = document.getElementById('edgesInput').value.trim();\n        const edges = input.split(',').map(edge => edge.trim().split('→'));\n        \n        // Create adjacency list\n        const graph = {};\n        const inDegree = {};\n        \n        edges.forEach(([from, to]) => {\n            if (!(from in graph)) graph[from] = [];\n            graph[from].push(to);\n            \n            inDegree[from] = (inDegree[from] || 0);\n            inDegree[to] = (inDegree[to] || 0) + 1;\n        });\n\n        // Topological sort using Kahn's algorithm\n        const queue = [];\n        for (const node in inDegree) {\n            if (inDegree[node] === 0) {\n                queue.push(node);\n            }\n        }\n\n        const topologicalOrder = [];\n        \n        while (queue.length) {\n            const node = queue.shift();\n            topologicalOrder.push(node);\n            if (graph[node]) {\n                for (const neighbor of graph[node]) {\n                    inDegree[neighbor]--;\n                    if (inDegree[neighbor] === 0) {\n                        queue.push(neighbor);\n                    }\n                }\n            }\n        }\n\n        // Check if topological sorting is possible (if there's a cycle)\n        if (topologicalOrder.length !== Object.keys(inDegree).length) {\n            document.getElementById('result').innerText = 'The graph has a cycle, topological sorting not possible.';\n        } else {\n            document.getElementById('result').innerText = topologicalOrder.join(' → ');\n        }\n    }\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}