{
  "id": "0888fdc2-d59e-11f0-b3ae-79d1ce7b5503",
  "timestamp": "2025-12-10T08:00:11.368Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body { font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 20px; }\n        canvas { border: 1px solid #000; margin-top: 20px; }\n        #controls { margin-bottom: 20px; }\n        #result { margin-top: 20px; }\n    </style>\n</head>\n<body>\n    <h1>Prim's Algorithm Visualization</h1>\n    <div id=\"controls\">\n        <button id=\"run\">Run Prim's Algorithm</button>\n        <button id=\"reset\">Reset</button>\n    </div>\n    <canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n    <div id=\"result\"></div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        // Define a simple graph (nodes and edges with weights)\n        const graph = {\n            0: { 1: 2, 3: 6 },\n            1: { 0: 2, 2: 3, 3: 8, 4: 5 },\n            2: { 1: 3, 4: 7 },\n            3: { 0: 6, 1: 8, 4: 9 },\n            4: { 1: 5, 2: 7, 3: 9 }\n        };\n\n        const nodes = [{x: 50, y: 100}, {x: 150, y: 50}, {x: 250, y: 150}, {x: 350, y: 100}, {x: 450, y: 200}];\n        const edges = [];\n\n        // Function to draw the graph\n        function drawGraph(treeEdges) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n            // Draw edges\n            for (const edge of edges) {\n                ctx.beginPath();\n                ctx.moveTo(nodes[edge[0]].x, nodes[edge[0]].y);\n                ctx.lineTo(nodes[edge[1]].x, nodes[edge[1]].y);\n                ctx.strokeStyle = 'grey';\n                ctx.stroke();\n                ctx.closePath();\n            }\n\n            // Draw the tree edges\n            for (const edge of treeEdges) {\n                ctx.beginPath();\n                ctx.moveTo(nodes[edge[0]].x, nodes[edge[0]].y);\n                ctx.lineTo(nodes[edge[1]].x, nodes[edge[1]].y);\n                ctx.strokeStyle = 'green';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                ctx.closePath();\n            }\n\n            // Draw nodes\n            nodes.forEach((node, index) => {\n                ctx.beginPath();\n                ctx.arc(node.x, node.y, 10, 0, Math.PI * 2, true);\n                ctx.fillStyle = 'blue';\n                ctx.fill();\n                ctx.strokeStyle = 'black';\n                ctx.stroke();\n                ctx.closePath();\n                ctx.fillStyle = 'black';\n                ctx.fillText(index, node.x - 5, node.y + 3);\n            });\n        }\n\n        // Prim's Algorithm implementation\n        function primAlgorithm() {\n            const totalNodes = Object.keys(graph).length;\n            const visited = Array(totalNodes).fill(false);\n            const treeEdges = [];\n            const minHeap = [[0, -1]]; // [weight, node]\n\n            while (minHeap.length > 0) {\n                // Sort and pop the minimum weight edge\n                minHeap.sort((a, b) => a[0] - b[0]);\n                const [weight, node] = minHeap.shift();\n\n                // If this node is already visited, continue\n                if (visited[node]) continue;\n                visited[node] = true;\n\n                // If this is not the starting node, track the edge\n                if (node !== -1) {\n                    treeEdges.push([node, minHeap[0][1]]);\n                }\n\n                // Add all adjacent edges\n                for (const neighbor in graph[node]) {\n                    if (!visited[neighbor]) {\n                        minHeap.push([graph[node][neighbor], neighbor]);\n                    }\n                }\n            }\n\n            return treeEdges;\n        }\n\n        // Event Listeners\n        document.getElementById('run').addEventListener('click', () => {\n            edges.length = 0;\n            for (const node in graph) {\n                for (const neighbor in graph[node]) {\n                    edges.push([node, neighbor]);\n                }\n            }\n            const treeEdges = primAlgorithm();\n            drawGraph(treeEdges);\n            document.getElementById('result').textContent = `Minimum Spanning Tree Edges: ${JSON.stringify(treeEdges)}`;\n        });\n\n        document.getElementById('reset').addEventListener('click', () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            document.getElementById('result').textContent = '';\n        });\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}