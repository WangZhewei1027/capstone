{
  "id": "7e8af3b3-d59e-11f0-89ab-2f71529652ac",
  "timestamp": "2025-12-10T08:03:37.498Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f0f0f0;\n            margin: 0;\n            padding: 20px;\n            text-align: center;\n        }\n        #canvas {\n            border: 1px solid #ccc;\n            background-color: white;\n            margin: 20px auto;\n            width: 600px;\n            height: 400px;\n        }\n        button {\n            padding: 10px 20px;\n            font-size: 16px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n    <h1>Kruskal's Algorithm Visualization</h1>\n    <canvas id=\"canvas\"></canvas>\n    <button onclick=\"runKruskal()\">Run Kruskal's Algorithm</button>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        const vertices = [\n            { x: 100, y: 100 },\n            { x: 400, y: 100 },\n            { x: 250, y: 300 },\n            { x: 150, y: 200 },\n            { x: 350, y: 200 }\n        ];\n\n        const edges = [\n            { from: 0, to: 1, weight: 10 },\n            { from: 0, to: 3, weight: 15 },\n            { from: 1, to: 2, weight: 10 },\n            { from: 1, to: 4, weight: 30 },\n            { from: 2, to: 4, weight: 20 },\n            { from: 3, to: 2, weight: 25 },\n            { from: 3, to: 4, weight: 40 }\n        ];\n\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            edges.forEach(edge => {\n                ctx.beginPath();\n                ctx.moveTo(vertices[edge.from].x, vertices[edge.from].y);\n                ctx.lineTo(vertices[edge.to].x, vertices[edge.to].y);\n                ctx.strokeStyle = '#ccc';\n                ctx.stroke();\n                ctx.font = '12px Arial';\n                ctx.fillText(edge.weight, (vertices[edge.from].x + vertices[edge.to].x) / 2, (vertices[edge.from].y + vertices[edge.to].y) / 2);\n            });\n            vertices.forEach((vertex, index) => {\n                ctx.fillStyle = 'blue';\n                ctx.beginPath();\n                ctx.arc(vertex.x, vertex.y, 10, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.fillStyle = 'black';\n                ctx.fillText(`v${index}`, vertex.x - 5, vertex.y - 15);\n            });\n        }\n\n        function find(parent, i) {\n            if (parent[i] === i) {\n                return i;\n            }\n            return find(parent, parent[i]);\n        }\n\n        function union(parent, rank, x, y) {\n            const xroot = find(parent, x);\n            const yroot = find(parent, y);\n            if (rank[xroot] < rank[yroot]) {\n                parent[xroot] = yroot;\n            } else if (rank[xroot] > rank[yroot]) {\n                parent[yroot] = xroot;\n            } else {\n                parent[yroot] = xroot;\n                rank[xroot]++;\n            }\n        }\n\n        function runKruskal() {\n            const sortedEdges = edges.sort((a, b) => a.weight - b.weight);\n            const parent = [];\n            const rank = [];\n            const mst = [];\n\n            for (let v = 0; v < vertices.length; v++) {\n                parent[v] = v;\n                rank[v] = 0;\n            }\n\n            for (const edge of sortedEdges) {\n                const { from, to } = edge;\n                const x = find(parent, from);\n                const y = find(parent, to);\n                if (x !== y) {\n                    mst.push(edge);\n                    union(parent, rank, x, y);\n                }\n            }\n\n            drawMST(mst);\n        }\n\n        function drawMST(mst) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            mst.forEach(edge => {\n                ctx.beginPath();\n                ctx.moveTo(vertices[edge.from].x, vertices[edge.from].y);\n                ctx.lineTo(vertices[edge.to].x, vertices[edge.to].y);\n                ctx.strokeStyle = 'green';\n                ctx.lineWidth = 3;\n                ctx.stroke();\n            });\n            drawGraph();\n        }\n\n        drawGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}