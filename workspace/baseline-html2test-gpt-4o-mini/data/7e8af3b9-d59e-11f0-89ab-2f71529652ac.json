{
  "id": "7e8af3b9-d59e-11f0-89ab-2f71529652ac",
  "timestamp": "2025-12-10T08:03:41.202Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Huffman Coding",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Huffman Coding Demo</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            padding: 20px;\n            background-color: #f4f4f4;\n        }\n        #output {\n            margin-top: 20px;\n            padding: 10px;\n            background-color: #fff;\n            border: 1px solid #ccc;\n        }\n    </style>\n</head>\n<body>\n\n<h2>Huffman Coding Demonstration</h2>\n<p>Enter text to see Huffman coding in action:</p>\n<textarea id=\"inputText\" rows=\"4\" cols=\"50\" placeholder=\"Enter text here...\"></textarea>\n<br>\n<button onclick=\"generateHuffmanCode()\">Generate Huffman Code</button>\n<div id=\"output\"></div>\n\n<script>\n    class Node {\n        constructor(data, freq) {\n            this.data = data;\n            this.freq = freq;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    class MinHeap {\n        constructor() {\n            this.heap = [];\n        }\n\n        insert(node) {\n            this.heap.push(node);\n            this.bubbleUp();\n        }\n\n        bubbleUp() {\n            let index = this.heap.length - 1;\n            while (index > 0) {\n                const parentIndex = Math.floor((index - 1) / 2);\n                if (this.heap[index].freq >= this.heap[parentIndex].freq) break;\n                [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n                index = parentIndex;\n            }\n        }\n\n        extractMin() {\n            const minNode = this.heap[0];\n            const end = this.heap.pop();\n            if (this.heap.length > 0) {\n                this.heap[0] = end;\n                this.siftDown();\n            }\n            return minNode;\n        }\n\n        siftDown() {\n            let index = 0;\n            const length = this.heap.length;\n            const element = this.heap[0];\n\n            while (true) {\n                let leftChildIndex = 2 * index + 1;\n                let rightChildIndex = 2 * index + 2;\n                let leftChild, rightChild;\n                let swap = null;\n\n                if (leftChildIndex < length) {\n                    leftChild = this.heap[leftChildIndex];\n                    if (leftChild.freq < element.freq) {\n                        swap = leftChildIndex;\n                    }\n                }\n                if (rightChildIndex < length) {\n                    rightChild = this.heap[rightChildIndex];\n                    if ((swap === null && rightChild.freq < element.freq) || \n                        (swap !== null && rightChild.freq < leftChild.freq)) {\n                        swap = rightChildIndex;\n                    }\n                }\n\n                if (swap === null) break;\n\n                this.heap[index] = this.heap[swap];\n                this.heap[swap] = element;\n                index = swap;\n            }\n        }\n\n        size() {\n            return this.heap.length;\n        }\n    }\n\n    function buildHuffmanTree(text) {\n        const freqMap = {};\n        for (const char of text) {\n            freqMap[char] = (freqMap[char] || 0) + 1;\n        }\n\n        const minHeap = new MinHeap();\n        for (const key in freqMap) {\n            minHeap.insert(new Node(key, freqMap[key]));\n        }\n\n        while (minHeap.size() > 1) {\n            const left = minHeap.extractMin();\n            const right = minHeap.extractMin();\n            const newNode = new Node(null, left.freq + right.freq);\n            newNode.left = left;\n            newNode.right = right;\n            minHeap.insert(newNode);\n        }\n\n        return minHeap.extractMin();\n    }\n\n    function generateCodes(node, prefix, codes) {\n        if (node) {\n            if (node.data !== null) {\n                codes[node.data] = prefix;\n            }\n            generateCodes(node.left, prefix + '0', codes);\n            generateCodes(node.right, prefix + '1', codes);\n        }\n    }\n\n    function generateHuffmanCode() {\n        const text = document.getElementById(\"inputText\").value.trim();\n        if (text.length === 0) {\n            document.getElementById(\"output\").innerText = \"Please enter some text.\";\n            return;\n        }\n        \n        const huffmanTree = buildHuffmanTree(text);\n        const codes = {};\n        generateCodes(huffmanTree, '', codes);\n        \n        let encodedText = '';\n        for (const char of text) {\n            encodedText += codes[char];\n        }\n\n        let outputHtml = '<h3>Huffman Codes:</h3><pre>' + JSON.stringify(codes, null, 2) + '</pre>';\n        outputHtml += '<h3>Encoded Text:</h3><pre>' + encodedText + '</pre>';\n        document.getElementById(\"output\").innerHTML = outputHtml;\n    }\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Huffman Coding"
    }
  ],
  "topic": "Huffman Coding",
  "hasFSM": false,
  "hasTest": true
}