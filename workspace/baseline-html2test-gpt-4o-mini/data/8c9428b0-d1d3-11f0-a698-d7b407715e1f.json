{
  "id": "8c9428b0-d1d3-11f0-a698-d7b407715e1f",
  "timestamp": "2025-12-05T12:12:22.675Z",
  "type": "html-to-test",
  "htmlModel": "gpt-4o-mini",
  "playwrightModel": "gpt-4o-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 100vh;\n        }\n        canvas {\n            border: 1px solid #000;\n            margin-bottom: 20px;\n        }\n        button {\n            padding: 10px 20px;\n            font-size: 16px;\n            margin: 5px;\n        }\n        #controls {\n            display: flex;\n            justify-content: center;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"600\" height=\"600\"></canvas>\n    <div id=\"controls\">\n        <button onclick=\"runDijkstra()\">Run Dijkstra's Algorithm</button>\n        <button onclick=\"resetCanvas()\">Reset</button>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        const nodes = [];\n        const edges = [];\n        const numNodes = 10;\n\n        class Node {\n            constructor(x, y, id) {\n                this.x = x;\n                this.y = y;\n                this.id = id;\n                this.adjacent = [];\n                this.distance = Infinity;\n                this.previous = null;\n                this.visited = false;\n            }\n\n            draw() {\n                ctx.fillStyle = this.visited ? 'red' : 'blue';\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.fillStyle = 'white';\n                ctx.fillText(this.id, this.x - 5, this.y + 5);\n            }\n        }\n\n        class Edge {\n            constructor(from, to, weight) {\n                this.from = from;\n                this.to = to;\n                this.weight = weight;\n            }\n\n            draw() {\n                ctx.beginPath();\n                ctx.moveTo(this.from.x, this.from.y);\n                ctx.lineTo(this.to.x, this.to.y);\n                ctx.stroke();\n                const midX = (this.from.x + this.to.x) / 2;\n                const midY = (this.from.y + this.to.y) / 2;\n                ctx.fillText(this.weight, midX, midY);\n            }\n        }\n\n        function createGraph() {\n            for (let i = 0; i < numNodes; i++) {\n                const x = Math.random() * (canvas.width - 40) + 20;\n                const y = Math.random() * (canvas.height - 40) + 20;\n                nodes.push(new Node(x, y, i));\n            }\n            for (let i = 0; i < numNodes; i++) {\n                for (let j = 0; j < numNodes; j++) {\n                    if (i !== j) {\n                        const weight = Math.floor(Math.random() * 10) + 1;\n                        edges.push(new Edge(nodes[i], nodes[j], weight));\n                        nodes[i].adjacent.push({ node: nodes[j], weight: weight });\n                    }\n                }\n            }\n        }\n\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            edges.forEach(edge => edge.draw());\n            nodes.forEach(node => node.draw());\n        }\n\n        function runDijkstra() {\n            const startNode = nodes[0];\n            const endNode = nodes[nodes.length - 1];\n            startNode.distance = 0;\n\n            const unvisited = [...nodes];\n\n            while (unvisited.length > 0) {\n                unvisited.sort((a, b) => a.distance - b.distance);\n                const currentNode = unvisited.shift();\n                currentNode.visited = true;\n\n                if (currentNode === endNode) {\n                    break;\n                }\n\n                currentNode.adjacent.forEach(neighbor => {\n                    if (!neighbor.node.visited) {\n                        const newDist = currentNode.distance + neighbor.weight;\n                        if (newDist < neighbor.node.distance) {\n                            neighbor.node.distance = newDist;\n                            neighbor.node.previous = currentNode;\n                        }\n                    }\n                });\n                drawGraph();\n            }\n            drawPath(endNode);\n        }\n\n        function drawPath(endNode) {\n            ctx.strokeStyle = 'green';\n            let currentNode = endNode;\n            while (currentNode) {\n                if (currentNode.previous) {\n                    ctx.beginPath();\n                    ctx.moveTo(currentNode.x, currentNode.y);\n                    ctx.lineTo(currentNode.previous.x, currentNode.previous.y);\n                    ctx.stroke();\n                }\n                currentNode = currentNode.previous;\n            }\n        }\n\n        function resetCanvas() {\n            nodes.length = 0;\n            edges.length = 0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            createGraph();\n            drawGraph();\n        }\n\n        createGraph();\n        drawGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}