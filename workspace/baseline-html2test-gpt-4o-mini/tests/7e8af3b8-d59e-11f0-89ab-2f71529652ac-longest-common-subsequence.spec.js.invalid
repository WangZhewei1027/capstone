import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/baseline-html2test-gpt-4o-mini/html/7e8af3b8-d59e-11f0-89ab-2f71529652ac.html';

// Page Object for the LCS application
class LCSPage {
  /**
   * @param {import('@playwright/test').Page} page
   */
  constructor(page) {
    this.page = page;
    this.input1 = page.locator('#string1');
    this.input2 = page.locator('#string2');
    this.calculateButton = page.locator('button', { hasText: 'Calculate LCS' });
    this.result = page.locator('#lcsResult');
    this.label1 = page.locator('label[for="string1"]');
    this.label2 = page.locator('label[for="string2"]');
  }

  async goto() {
    await this.page.goto(APP_URL);
  }

  async enterStrings(s1, s2) {
    await this.input1.fill(s1);
    await this.input2.fill(s2);
  }

  async clickCalculate() {
    await this.calculateButton.click();
  }

  async getResultText() {
    return (await this.result.textContent())?.trim() ?? '';
  }
}

test.describe('Longest Common Subsequence App - UI and behavior', () => {
  // Capture console and page errors for each test
  test.beforeEach(async ({ page }) => {
    // No setup here beyond navigation in each test; console/pageerror handlers are attached per test below.
  });

  // Test initial page load and default state
  test('Initial page load: inputs and button visible, result area empty', async ({ page }) => {
    // Listen for console errors and page errors
    const consoleErrors = [];
    const pageErrors = [];
    page.on('console', msg => {
      if (msg.type() === 'error') consoleErrors.push(msg.text());
    });
    page.on('pageerror', err => pageErrors.push(err.message));

    const app = new LCSPage(page);
    await app.goto();

    // Verify inputs and button are visible and empty
    await expect(app.input1).toBeVisible();
    await expect(app.input2).toBeVisible();
    await expect(app.calculateButton).toBeVisible();
    await expect(app.input1).toHaveValue('');
    await expect(app.input2).toHaveValue('');

    // Result area should be present and initially empty or contain no LCS text
    await expect(app.result).toBeVisible();
    const initialText = await app.getResultText();
    expect(initialText).toBe(''); // should be blank on load

    // Verify labels are associated with inputs for basic accessibility
    await expect(app.label1).toBeVisible();
    await expect(app.label2).toBeVisible();
    expect(await app.label1.getAttribute('for')).toBe('string1');
    expect(await app.label2.getAttribute('for')).toBe('string2');

    // Assert no console errors or page errors occurred during load
    expect(consoleErrors).toEqual([]);
    expect(pageErrors).toEqual([]);
  });

  // Test simple known cases for correctness
  test.describe('Functional correctness of LCS computation', () => {
    test('Computes LCS for two non-empty strings (AGGTAB, GXTXAYB -> GTAB)', async ({ page }) => {
      // Capture console & page errors
      const consoleErrors1 = [];
      const pageErrors1 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app1 = new LCSPage(page);
      await app.goto();

      // Enter two strings and calculate
      await app.enterStrings('AGGTAB', 'GXTXAYB');
      await app.clickCalculate();

      // Verify the result text contains the expected LCS produced by the algorithm
      const resultText = await app.getResultText();
      // The page displays: "Longest Common Subsequence: <lcs>"
      expect(resultText).toBe('Longest Common Subsequence: GTAB');

      // No console or page errors should occur
      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });

    test('Computes LCS when one string is empty -> empty LCS', async ({ page }) => {
      const consoleErrors2 = [];
      const pageErrors2 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app2 = new LCSPage(page);
      await app.goto();

      await app.enterStrings('', 'NONEMPTY');
      await app.clickCalculate();

      const resultText1 = await app.getResultText();
      expect(resultText).toBe('Longest Common Subsequence: '); // empty LCS

      // Reverse: first non-empty, second empty
      await app.enterStrings('NONEMPTY', '');
      await app.clickCalculate();
      const resultText2 = await app.getResultText();
      expect(resultText2).toBe('Longest Common Subsequence: ');

      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });

    test('Computes LCS for strings with no common subsequence -> empty', async ({ page }) {
      const consoleErrors3 = [];
      const pageErrors3 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app3 = new LCSPage(page);
      await app.goto();

      await app.enterStrings('ABC', 'DEF');
      await app.clickCalculate();

      const resultText2 = await app.getResultText();
      expect(resultText).toBe('Longest Common Subsequence: ');

      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });

    test('Computes LCS for simple nested subsequence (ABC, AC -> AC)', async ({ page }) {
      const consoleErrors4 = [];
      const pageErrors4 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app4 = new LCSPage(page);
      await app.goto();

      await app.enterStrings('ABC', 'AC');
      await app.clickCalculate();

      const resultText3 = await app.getResultText();
      expect(resultText).toBe('Longest Common Subsequence: AC');

      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });
  });

  // Test UI behavior and edge scenarios
  test.describe('UI interactions and edge cases', () => {
    test('Multiple consecutive calculations update result correctly', async ({ page }) => {
      const consoleErrors5 = [];
      const pageErrors5 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app5 = new LCSPage(page);
      await app.goto();

      // First calculation
      await app.enterStrings('ABCDEF', 'ACEF');
      await app.clickCalculate();
      expect(await app.getResultText()).toBe('Longest Common Subsequence: ACEF');

      // Change inputs and calculate again
      await app.enterStrings('12345', '135');
      await app.clickCalculate();
      expect(await app.getResultText()).toBe('Longest Common Subsequence: 135');

      // Clear inputs and calculate -> empty result
      await app.enterStrings('', '');
      await app.clickCalculate();
      expect(await app.getResultText()).toBe('Longest Common Subsequence: ');

      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });

    test('Whitespace and special characters are treated literally', async ({ page }) => {
      const consoleErrors6 = [];
      const pageErrors6 = [];
      page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
      page.on('pageerror', err => pageErrors.push(err.message));

      const app6 = new LCSPage(page);
      await app.goto();

      // Spaces matter
      await app.enterStrings('a b c', ' abc');
      await app.clickCalculate();
      // The LCS algorithm treats spaces as characters; expected LCS may be ' abc' or ' a c' depending on alignment.
      // We assert that the result contains the prefix text and is a string (non-null). We also assert visible update.
      const result = await app.getResultText();
      expect(result.startsWith('Longest Common Subsequence:')).toBe(true);
      // ensure the result element updated and is visible
      await expect(app.result).toBeVisible();

      expect(consoleErrors).toEqual([]);
      expect(pageErrors).toEqual([]);
    });
  });

  // Final check: nothing unexpected logged to console or thrown as page errors during various interactions
  test('No runtime console errors or page errors during typical usage', async ({ page }) => {
    const consoleErrors7 = [];
    const pageErrors7 = [];
    page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });
    page.on('pageerror', err => pageErrors.push(err.message));

    const app7 = new LCSPage(page);
    await app.goto();

    // Perform a set of typical interactions
    await app.enterStrings('HELLO', 'HELLO');
    await app.clickCalculate();
    expect(await app.getResultText()).toBe('Longest Common Subsequence: HELLO');

    await app.enterStrings('XMJYAUZ', 'MZJAWXU');
    await app.clickCalculate();
    // Expect some LCS to be present in result text (algorithm deterministically produces one)
    const r = await app.getResultText();
    expect(r.startsWith('Longest Common Subsequence:')).toBe(true);

    // Assert that no console errors (TypeError/ReferenceError/SyntaxError) or page errors were observed
    expect(consoleErrors, `Console error messages were found: ${consoleErrors.join(' | ')}`).toEqual([]);
    expect(pageErrors, `Page errors were found: ${pageErrors.join(' | ')}`).toEqual([]);
  });
});