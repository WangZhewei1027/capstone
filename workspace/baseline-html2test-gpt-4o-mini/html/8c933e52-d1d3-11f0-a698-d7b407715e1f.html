<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find (Disjoint Set) Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        #unionFind {
            margin-top: 20px;
        }
        .set {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
        }
        .selected {
            background-color: lightblue;
        }
    </style>
</head>
<body>

<h1>Union-Find (Disjoint Set) Visualization</h1>
<p>Select two sets and click "Union" to connect them.</p>

<div id="sets">
    <div class="set" data-id="0">Set 0</div>
    <div class="set" data-id="1">Set 1</div>
    <div class="set" data-id="2">Set 2</div>
    <div class="set" data-id="3">Set 3</div>
    <div class="set" data-id="4">Set 4</div>
</div>

<button id="unionBtn" disabled>Union</button>

<div id="unionFind"></div>

<script>
    class UnionFind {
        constructor(size) {
            this.parent = Array.from({length: size}, (_, i) => i);
            this.rank = Array(size).fill(1);
        }

        find(x) {
            if (this.parent[x] !== x) {
                this.parent[x] = this.find(this.parent[x]); // Path compression
            }
            return this.parent[x];
        }

        union(x, y) {
            const rootX = this.find(x);
            const rootY = this.find(y);

            if (rootX !== rootY) {
                // Union by rank
                if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
            }
        }
    }

    const uf = new UnionFind(5);
    let selected = [];
    
    const sets = document.querySelectorAll('.set');
    const unionBtn = document.getElementById('unionBtn');

    sets.forEach(set => {
        set.addEventListener('click', () => {
            const id = +set.dataset.id;
            if (selected.includes(id)) {
                set.classList.remove('selected');
                selected = selected.filter(s => s !== id);
            } else if (selected.length < 2) {
                set.classList.add('selected');
                selected.push(id);
            }
            
            unionBtn.disabled = selected.length < 2;
        });
    });

    unionBtn.addEventListener('click', () => {
        uf.union(selected[0], selected[1]);
        renderSets();
        selected = [];
        sets.forEach(set => set.classList.remove('selected'));
        unionBtn.disabled = true;
    });

    function renderSets() {
        const grouped = {};
        for (let i = 0; i < uf.parent.length; i++) {
            const root = uf.find(i);
            if (!grouped[root]) grouped[root] = [];
            grouped[root].push(i);
        }

        let output = "<h2>Current Sets:</h2>";

        for (const group in grouped) {
            output += `<div>Set: ${grouped[group].join(', ')}</div>`;
        }

        document.getElementById('unionFind').innerHTML = output;
    }
    
    renderSets();
</script>

</body>
</html>