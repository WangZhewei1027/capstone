<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        canvas {
            border: 1px solid #000;
        }
        #inputGraph {
            width: 300px;
            height: 100px;
            margin-bottom: 20px;
        }
        #output {
            margin-top: 20px;
            white-space: pre;
        }
    </style>
</head>
<body>

<h1>Topological Sort Visualization</h1>
<p>Enter directed graph edges (e.g., "A->B, B->C, A->C"):</p>
<input type="text" id="inputGraph" placeholder="Enter edges"/>
<button id="sortButton">Perform Topological Sort</button>

<canvas id="graphCanvas" width="500" height="400"></canvas>

<h2>Sorted Order:</h2>
<pre id="output"></pre>

<script>
    document.getElementById('sortButton').onclick = function() {
        const input = document.getElementById('inputGraph').value;
        const edges = input.split(',').map(edge => edge.trim());
        const graph = {};
        const indegree = {};
        
        // Build graph and indegree
        edges.forEach(edge => {
            const [u, v] = edge.split('->').map(node => node.trim());
            if (!graph[u]) graph[u] = [];
            graph[u].push(v);
            indegree[v] = (indegree[v] || 0) + 1;
            indegree[u] = indegree[u] || 0; 
        });

        // Kahn's algorithm for topological sort
        const queue = [];
        for (let node in indegree) {
            if (indegree[node] === 0) {
                queue.push(node);
            }
        }

        const sortedOrder = [];
        while (queue.length) {
            const node = queue.shift();
            sortedOrder.push(node);

            for (let neighbor of (graph[node] || [])) {
                indegree[neighbor]--;
                if (indegree[neighbor] === 0) {
                    queue.push(neighbor);
                }
            }
        }

        // Display sorted order
        document.getElementById('output').innerText = sortedOrder.join(' -> ');

        // Draw graph
        drawGraph(graph);
    };

    function drawGraph(graph) {
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const positions = {};
        const nodes = Object.keys(graph);
        const radius = 20;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const angleStep = (2 * Math.PI) / nodes.length;

        let angle = 0;
        nodes.forEach((node, index) => {
            const x = centerX + Math.cos(angle) * 100;
            const y = centerY + Math.sin(angle) * 100;
            positions[node] = { x, y };
            angle += angleStep;
        });

        // Draw edges
        for (let u in graph) {
            const { x: startX, y: startY } = positions[u];
            graph[u].forEach(v => {
                const { x: endX, y: endY } = positions[v];
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.fillText('->', (startX + endX) / 2, (startY + endY) / 2 - 3);
            });
        }

        // Draw nodes
        for (let node in positions) {
            const { x, y } = positions[node];
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'lightblue';
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.fillText(node, x - 5, y + 5);
        }
    }
</script>
</body>
</html>