<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f4f4f4;
        }
        #graph {
            margin: 20px auto;
            width: 80%;
            height: 300px;
            border: 1px solid #ccc;
        }
        #start, #end, #result {
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>Dijkstra's Algorithm Visualization</h1>
    <div id="graph"></div>
    <input type="number" id="start" placeholder="Start Node (0 to 5)" min="0" max="5" />
    <input type="number" id="end" placeholder="End Node (0 to 5)" min="0" max="5" />
    <button onclick="runDijkstra()">Run Dijkstra</button>
    <div id="result"></div>

    <script>
        const graph = {
            0: {1: 7, 2: 9, 5: 14},
            1: {0: 7, 2: 10, 3: 15},
            2: {0: 9, 1: 10, 3: 11, 5: 2},
            3: {1: 15, 2: 11, 4: 6},
            4: {3: 6, 5: 9},
            5: {0: 14, 2: 2, 4: 9}
        };

        function runDijkstra() {
            const startNode = parseInt(document.getElementById('start').value);
            const endNode = parseInt(document.getElementById('end').value);
            const resultDiv = document.getElementById('result');

            if (isNaN(startNode) || isNaN(endNode) || startNode < 0 || startNode > 5 || endNode < 0 || endNode > 5) {
                resultDiv.innerHTML = "Please enter valid node numbers (0 to 5).";
                return;
            }

            const distances = {};
            const visited = {};
            const previous = {};

            for (let node in graph) {
                distances[node] = Infinity;
                visited[node] = false;
                previous[node] = null;
            }
            distances[startNode] = 0;

            while (true) {
                let minDistanceNode = null;

                for (let node in distances) {
                    if (!visited[node] && (minDistanceNode === null || distances[node] < distances[minDistanceNode])) {
                        minDistanceNode = node;
                    }
                }

                if (minDistanceNode === null || distances[minDistanceNode] === Infinity) {
                    break; 
                }

                visited[minDistanceNode] = true;

                for (let neighbor in graph[minDistanceNode]) {
                    const distance = graph[minDistanceNode][neighbor];
                    const totalDistance = distances[minDistanceNode] + distance;

                    if (totalDistance < distances[neighbor]) {
                        distances[neighbor] = totalDistance;
                        previous[neighbor] = minDistanceNode;
                    }
                }
            }

            let path = [];
            let currentNode = endNode;
            while (currentNode !== null) {
                path.unshift(currentNode);
                currentNode = previous[currentNode];
            }

            resultDiv.innerHTML = distances[endNode] === Infinity 
                ? "No path found." 
                : "Shortest path: " + path.join(" -> ") + " (Distance: " + distances[endNode] + ")";
        }
    </script>
</body>
</html>