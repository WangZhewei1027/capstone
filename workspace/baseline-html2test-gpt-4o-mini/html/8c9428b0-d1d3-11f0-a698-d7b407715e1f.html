<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid #000;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
        }
        #controls {
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="controls">
        <button onclick="runDijkstra()">Run Dijkstra's Algorithm</button>
        <button onclick="resetCanvas()">Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const nodes = [];
        const edges = [];
        const numNodes = 10;

        class Node {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.adjacent = [];
                this.distance = Infinity;
                this.previous = null;
                this.visited = false;
            }

            draw() {
                ctx.fillStyle = this.visited ? 'red' : 'blue';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.fillText(this.id, this.x - 5, this.y + 5);
            }
        }

        class Edge {
            constructor(from, to, weight) {
                this.from = from;
                this.to = to;
                this.weight = weight;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.from.x, this.from.y);
                ctx.lineTo(this.to.x, this.to.y);
                ctx.stroke();
                const midX = (this.from.x + this.to.x) / 2;
                const midY = (this.from.y + this.to.y) / 2;
                ctx.fillText(this.weight, midX, midY);
            }
        }

        function createGraph() {
            for (let i = 0; i < numNodes; i++) {
                const x = Math.random() * (canvas.width - 40) + 20;
                const y = Math.random() * (canvas.height - 40) + 20;
                nodes.push(new Node(x, y, i));
            }
            for (let i = 0; i < numNodes; i++) {
                for (let j = 0; j < numNodes; j++) {
                    if (i !== j) {
                        const weight = Math.floor(Math.random() * 10) + 1;
                        edges.push(new Edge(nodes[i], nodes[j], weight));
                        nodes[i].adjacent.push({ node: nodes[j], weight: weight });
                    }
                }
            }
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            edges.forEach(edge => edge.draw());
            nodes.forEach(node => node.draw());
        }

        function runDijkstra() {
            const startNode = nodes[0];
            const endNode = nodes[nodes.length - 1];
            startNode.distance = 0;

            const unvisited = [...nodes];

            while (unvisited.length > 0) {
                unvisited.sort((a, b) => a.distance - b.distance);
                const currentNode = unvisited.shift();
                currentNode.visited = true;

                if (currentNode === endNode) {
                    break;
                }

                currentNode.adjacent.forEach(neighbor => {
                    if (!neighbor.node.visited) {
                        const newDist = currentNode.distance + neighbor.weight;
                        if (newDist < neighbor.node.distance) {
                            neighbor.node.distance = newDist;
                            neighbor.node.previous = currentNode;
                        }
                    }
                });
                drawGraph();
            }
            drawPath(endNode);
        }

        function drawPath(endNode) {
            ctx.strokeStyle = 'green';
            let currentNode = endNode;
            while (currentNode) {
                if (currentNode.previous) {
                    ctx.beginPath();
                    ctx.moveTo(currentNode.x, currentNode.y);
                    ctx.lineTo(currentNode.previous.x, currentNode.previous.y);
                    ctx.stroke();
                }
                currentNode = currentNode.previous;
            }
        }

        function resetCanvas() {
            nodes.length = 0;
            edges.length = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            createGraph();
            drawGraph();
        }

        createGraph();
        drawGraph();
    </script>
</body>
</html>