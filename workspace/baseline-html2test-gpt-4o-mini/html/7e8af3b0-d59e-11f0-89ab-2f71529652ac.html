<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra’s Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 50px;
        }
        #graph {
            display: flex;
            justify-content: center;
        }
        .node {
            width: 50px;
            height: 50px;
            border: 1px solid #000;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin: 20px;
            background-color: #eee;
        }
        .edge {
            position: absolute;
            width: 100px;
            height: 5px;
            background-color: #000;
            transform-origin: top left;
        }
        .edge.hidden {
            display: none;
        }
        #result {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Dijkstra’s Algorithm Visualization</h1>
    <div id="graph"></div>
    <button onclick="runDijkstra()">Run Dijkstra's Algorithm</button>
    <div id="result"></div>

    <script>
        const nodes = [
            { id: 1, edges: [{ to: 2, weight: 1 }, { to: 3, weight: 4 }] },
            { id: 2, edges: [{ to: 1, weight: 1 }, { to: 3, weight: 2 }, { to: 4, weight: 5 }] },
            { id: 3, edges: [{ to: 1, weight: 4 }, { to: 2, weight: 2 }, { to: 4, weight: 1 }] },
            { id: 4, edges: [{ to: 2, weight: 5 }, { to: 3, weight: 1 }] }
        ];

        const graphElement = document.getElementById('graph');

        function drawGraph() {
            nodes.forEach(node => {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.innerText = node.id;
                nodeElement.style.left = `${(node.id - 1) * 100}px`;
                nodeElement.style.top = '50px';
                
                graphElement.appendChild(nodeElement);

                node.edges.forEach(edge => {
                    const targetNode = nodes.find(n => n.id === edge.to);
                    if (targetNode) {
                        const edgeElement = document.createElement('div');
                        edgeElement.className = 'edge';
                        edgeElement.style.width = `${Math.abs(edge.to - node.id) * 100}px`;
                        edgeElement.style.transform = `rotate(${Math.atan2(0, 100) * (180/Math.PI)}deg)`;
                        edgeElement.style.top = '35px';
                        edgeElement.style.left = `${(node.id - 1) * 100 + 25}px`;

                        graphElement.appendChild(edgeElement);
                    }
                });
            });
        }

        async function runDijkstra() {
            const resultElement = document.getElementById('result');
            resultElement.innerText = '';

            const distances = {};
            const visited = new Set();
            const previous = {};
            const queue = [];

            nodes.forEach(node => {
                distances[node.id] = Infinity;
                previous[node.id] = null;
                queue.push(node.id);
            });
            distances[1] = 0;

            while (queue.length > 0) {
                let currentNode = queue.reduce((minNode, node) => 
                    distances[node] < distances[minNode] ? node : minNode
                );

                if (distances[currentNode] === Infinity) break;

                visited.add(currentNode);
                queue.splice(queue.indexOf(currentNode), 1);

                for (let edge of nodes.find(n => n.id === currentNode).edges) {
                    if (!visited.has(edge.to)) {
                        let alt = distances[currentNode] + edge.weight;
                        if (alt < distances[edge.to]) {
                            distances[edge.to] = alt;
                            previous[edge.to] = currentNode;
                        }
                    }
                }

                resultElement.innerText += `Current Node: ${currentNode}, Distance: ${distances[currentNode]}\n`;
                
                await new Promise(resolve => setTimeout(resolve, 1000)); // Optional delay to visualize
            }

            resultElement.innerText += '\nFinal Distances:\n';
            for (let nodeId in distances) {
                resultElement.innerText += `Node: ${nodeId}, Distance: ${distances[nodeId]}\n`;
            }
        }

        drawGraph();
    </script>
</body>
</html>