<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search (BFS) Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
        }
        canvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        #controls {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startBFS">Start BFS</button>
    </div>
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');

        const graph = {
            // Graph represented as an adjacency list
            A: ['B', 'C'],
            B: ['D', 'E'],
            C: ['F'],
            D: [],
            E: ['F'],
            F: []
        };

        const nodePositions = {
            A: { x: 100, y: 100 },
            B: { x: 200, y: 200 },
            C: { x: 200, y: 50 },
            D: { x: 300, y: 250 },
            E: { x: 300, y: 150 },
            F: { x: 400, y: 100 }
        };

        function drawGraph(bfsOrder) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000';
            Object.keys(nodePositions).forEach(node => {
                context.beginPath();
                context.arc(nodePositions[node].x, nodePositions[node].y, 20, 0, Math.PI * 2);
                context.fill();
                
                context.fillStyle = '#fff';
                context.fillText(node, nodePositions[node].x - 5, nodePositions[node].y + 5);
                context.fillStyle = '#000';
                
                if (bfsOrder.includes(node)) {
                    context.fillStyle = '#0f0';  // Color for visited nodes
                    context.beginPath();
                    context.arc(nodePositions[node].x, nodePositions[node].y, 20, 0, Math.PI * 2);
                    context.fill();
                }
            });

            context.strokeStyle = '#000';
            Object.keys(graph).forEach(node => {
                graph[node].forEach(neighbor => {
                    context.beginPath();
                    context.moveTo(nodePositions[node].x, nodePositions[node].y);
                    context.lineTo(nodePositions[neighbor].x, nodePositions[neighbor].y);
                    context.stroke();
                });
            });
        }

        function bfs(startNode) {
            const queue = [startNode];
            const visited = new Set();
            const bfsOrder = [];

            while (queue.length > 0) {
                const currentNode = queue.shift();
                if (!visited.has(currentNode)) {
                    visited.add(currentNode);
                    bfsOrder.push(currentNode);
                    queue.push(...graph[currentNode]);
                }
            }
            return bfsOrder;
        }

        document.getElementById('startBFS').addEventListener('click', () => {
            const bfsOrder = bfs('A');
            drawGraph(bfsOrder);
        });
    </script>
</body>
</html>