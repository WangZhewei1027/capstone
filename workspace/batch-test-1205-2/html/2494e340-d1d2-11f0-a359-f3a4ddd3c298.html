<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #000;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="resetGraph()">Reset Graph</button>
        <button onclick="startPrim()">Start Prim's Algorithm</button>
    </div>
    <canvas id="canvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let vertices = [];
        let edges = [];
        let running = false;
        let selected = [];
        let mst = [];

        class Vertex {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
            }
        }

        class Edge {
            constructor(start, end, weight) {
                this.start = start;
                this.end = end;
                this.weight = weight;
            }
        }

        function resetGraph() {
            vertices = [];
            edges = [];
            selected = [];
            mst = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawVertices();
            drawEdges();
        }

        function drawVertices() {
            for (let vertex of vertices) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.fillText(vertex.id, vertex.x - 5, vertex.y + 5);
            }
        }

        function drawEdges() {
            for (let edge of edges) {
                ctx.beginPath();
                ctx.moveTo(edge.start.x, edge.start.y);
                ctx.lineTo(edge.end.x, edge.end.y);
                ctx.strokeStyle = 'gray';
                ctx.stroke();
            }
        }

        function addVertex(x, y) {
            const id = vertices.length;
            vertices.push(new Vertex(x, y, id));
            for (let vertex of vertices) {
                if (vertex !== vertices[id]) {
                    const weight = Math.floor(Math.random() * 10) + 1; // random weight
                    edges.push(new Edge(vertices[id], vertex, weight));
                }
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEdges();
            drawVertices();
        }

        function startPrim() {
            if (running || vertices.length === 0) return;
            running = true;
            selected.push(vertices[0]); // start from the first vertex
            animPrim();
        }

        async function animPrim() {
            while (running && selected.length < vertices.length) {
                let minEdge = null;

                for (let s of selected) {
                    for (let edge of edges) {
                        if ((edge.start === s || edge.end === s) && !selected.includes(edge.start) && !selected.includes(edge.end)) {
                            if (!minEdge || edge.weight < minEdge.weight) {
                                minEdge = edge;
                            }
                        }
                    }
                }

                if (minEdge) {
                    mst.push(minEdge); // add the edge to MST
                    selected.push(minEdge.start === selected[0] ? minEdge.end : minEdge.start); // add new vertex
                    drawMST();
                }

                await new Promise(r => setTimeout(r, 500)); // delay for visibility
            }
            running = false;
        }

        function drawMST() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEdges();
            ctx.strokeStyle = 'green';
            for (let edge of mst) {
                ctx.beginPath();
                ctx.moveTo(edge.start.x, edge.start.y);
                ctx.lineTo(edge.end.x, edge.end.y);
                ctx.stroke();
            }
            drawVertices();
        }

        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            addVertex(x, y);
        });

    </script>
</body>
</html>