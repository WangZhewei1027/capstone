{
  "id": "2494e340-d1d2-11f0-a359-f3a4ddd3c298",
  "timestamp": "2025-12-05T12:02:25.630Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Prim's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            margin: 0;\n            background-color: #f0f0f0;\n        }\n        canvas {\n            border: 1px solid #000;\n        }\n        #controls {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"controls\">\n        <button onclick=\"resetGraph()\">Reset Graph</button>\n        <button onclick=\"startPrim()\">Start Prim's Algorithm</button>\n    </div>\n    <canvas id=\"canvas\" width=\"600\" height=\"600\"></canvas>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        let vertices = [];\n        let edges = [];\n        let running = false;\n        let selected = [];\n        let mst = [];\n\n        class Vertex {\n            constructor(x, y, id) {\n                this.x = x;\n                this.y = y;\n                this.id = id;\n            }\n        }\n\n        class Edge {\n            constructor(start, end, weight) {\n                this.start = start;\n                this.end = end;\n                this.weight = weight;\n            }\n        }\n\n        function resetGraph() {\n            vertices = [];\n            edges = [];\n            selected = [];\n            mst = [];\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawVertices();\n            drawEdges();\n        }\n\n        function drawVertices() {\n            for (let vertex of vertices) {\n                ctx.fillStyle = 'black';\n                ctx.beginPath();\n                ctx.arc(vertex.x, vertex.y, 10, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.fillStyle = 'white';\n                ctx.fillText(vertex.id, vertex.x - 5, vertex.y + 5);\n            }\n        }\n\n        function drawEdges() {\n            for (let edge of edges) {\n                ctx.beginPath();\n                ctx.moveTo(edge.start.x, edge.start.y);\n                ctx.lineTo(edge.end.x, edge.end.y);\n                ctx.strokeStyle = 'gray';\n                ctx.stroke();\n            }\n        }\n\n        function addVertex(x, y) {\n            const id = vertices.length;\n            vertices.push(new Vertex(x, y, id));\n            for (let vertex of vertices) {\n                if (vertex !== vertices[id]) {\n                    const weight = Math.floor(Math.random() * 10) + 1; // random weight\n                    edges.push(new Edge(vertices[id], vertex, weight));\n                }\n            }\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawEdges();\n            drawVertices();\n        }\n\n        function startPrim() {\n            if (running || vertices.length === 0) return;\n            running = true;\n            selected.push(vertices[0]); // start from the first vertex\n            animPrim();\n        }\n\n        async function animPrim() {\n            while (running && selected.length < vertices.length) {\n                let minEdge = null;\n\n                for (let s of selected) {\n                    for (let edge of edges) {\n                        if ((edge.start === s || edge.end === s) && !selected.includes(edge.start) && !selected.includes(edge.end)) {\n                            if (!minEdge || edge.weight < minEdge.weight) {\n                                minEdge = edge;\n                            }\n                        }\n                    }\n                }\n\n                if (minEdge) {\n                    mst.push(minEdge); // add the edge to MST\n                    selected.push(minEdge.start === selected[0] ? minEdge.end : minEdge.start); // add new vertex\n                    drawMST();\n                }\n\n                await new Promise(r => setTimeout(r, 500)); // delay for visibility\n            }\n            running = false;\n        }\n\n        function drawMST() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawEdges();\n            ctx.strokeStyle = 'green';\n            for (let edge of mst) {\n                ctx.beginPath();\n                ctx.moveTo(edge.start.x, edge.start.y);\n                ctx.lineTo(edge.end.x, edge.end.y);\n                ctx.stroke();\n            }\n            drawVertices();\n        }\n\n        canvas.addEventListener('click', function(event) {\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            addVertex(x, y);\n        });\n\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}