{
  "id": "2493aac1-d1d2-11f0-a359-f3a4ddd3c298",
  "timestamp": "2025-12-05T12:02:58.589Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Min/Max Heap Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        #heap-container {\n            margin-top: 20px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        .heap-node {\n            border: 1px solid #333;\n            border-radius: 4px;\n            padding: 10px 15px;\n            margin: 5px;\n            display: inline-block;\n            background-color: #f0f0f0;\n            font-weight: bold;\n        }\n        .heap-row {\n            display: flex;\n            justify-content: center;\n        }\n        button {\n            margin: 5px;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>Min/Max Heap Visualization</h1>\n    <input type=\"number\" id=\"value\" placeholder=\"Enter a number\" />\n    <button onclick=\"insertMinHeap()\">Insert to Min Heap</button>\n    <button onclick=\"insertMaxHeap()\">Insert to Max Heap</button>\n    <button onclick=\"deleteMinHeap()\">Delete Min from Min Heap</button>\n    <button onclick=\"deleteMaxHeap()\">Delete Max from Max Heap</button>\n\n    <h2>Min Heap</h2>\n    <div id=\"min-heap-container\" class=\"heap-container\"></div>\n\n    <h2>Max Heap</h2>\n    <div id=\"max-heap-container\" class=\"heap-container\"></div>\n\n    <script>\n        class MinHeap {\n            constructor() {\n                this.heap = [];\n            }\n\n            insert(val) {\n                this.heap.push(val);\n                this.bubbleUp();\n                this.render();\n            }\n\n            bubbleUp() {\n                let index = this.heap.length - 1;\n                while (index > 0) {\n                    const element = this.heap[index];\n                    const parentIndex = Math.floor((index - 1) / 2);\n                    const parent = this.heap[parentIndex];\n\n                    if (element >= parent) break;\n\n                    this.heap[index] = parent;\n                    this.heap[parentIndex] = element;\n                    index = parentIndex;\n                }\n            }\n\n            delete() {\n                const min = this.heap[0];\n                const end = this.heap.pop();\n                if (this.heap.length > 0) {\n                    this.heap[0] = end;\n                    this.sinkDown();\n                }\n                this.render();\n                return min;\n            }\n\n            sinkDown() {\n                let index = 0;\n                const length = this.heap.length;\n                const element = this.heap[0];\n\n                while (true) {\n                    let leftChildIndex = 2 * index + 1;\n                    let rightChildIndex = 2 * index + 2;\n                    let leftChild, rightChild;\n                    let swap = null;\n\n                    if (leftChildIndex < length) {\n                        leftChild = this.heap[leftChildIndex];\n                        if (leftChild < element) {\n                            swap = leftChildIndex;\n                        }\n                    }\n\n                    if (rightChildIndex < length) {\n                        rightChild = this.heap[rightChildIndex];\n                        if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) {\n                            swap = rightChildIndex;\n                        }\n                    }\n\n                    if (swap === null) break;\n\n                    this.heap[index] = this.heap[swap];\n                    this.heap[swap] = element;\n                    index = swap;\n                }\n            }\n\n            render() {\n                const container = document.getElementById('min-heap-container');\n                container.innerHTML = '';\n                this.visualizeHeap(container, this.heap);\n            }\n\n            visualizeHeap(container, heap, index = 0, level = 0) {\n                if (index < heap.length) {\n                    const row = document.createElement('div');\n                    row.className = 'heap-row';\n                    this.visualizeHeap(container, heap, 2 * index + 1, level + 1);\n                    const node = document.createElement('div');\n                    node.className = 'heap-node';\n                    node.textContent = heap[index];\n                    row.appendChild(node);\n                    this.visualizeHeap(container, heap, 2 * index + 2, level + 1);\n                    container.appendChild(row);\n                }\n            }\n        }\n\n        class MaxHeap {\n            constructor() {\n                this.heap = [];\n            }\n\n            insert(val) {\n                this.heap.push(val);\n                this.bubbleUp();\n                this.render();\n            }\n\n            bubbleUp() {\n                let index = this.heap.length - 1;\n                while (index > 0) {\n                    const element = this.heap[index];\n                    const parentIndex = Math.floor((index - 1) / 2);\n                    const parent = this.heap[parentIndex];\n\n                    if (element <= parent) break;\n\n                    this.heap[index] = parent;\n                    this.heap[parentIndex] = element;\n                    index = parentIndex;\n                }\n            }\n\n            delete() {\n                const max = this.heap[0];\n                const end = this.heap.pop();\n                if (this.heap.length > 0) {\n                    this.heap[0] = end;\n                    this.sinkDown();\n                }\n                this.render();\n                return max;\n            }\n\n            sinkDown() {\n                let index = 0;\n                const length = this.heap.length;\n                const element = this.heap[0];\n\n                while (true) {\n                    let leftChildIndex = 2 * index + 1;\n                    let rightChildIndex = 2 * index + 2;\n                    let leftChild, rightChild;\n                    let swap = null;\n\n                    if (leftChildIndex < length) {\n                        leftChild = this.heap[leftChildIndex];\n                        if (leftChild > element) {\n                            swap = leftChildIndex;\n                        }\n                    }\n\n                    if (rightChildIndex < length) {\n                        rightChild = this.heap[rightChildIndex];\n                        if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) {\n                            swap = rightChildIndex;\n                        }\n                    }\n\n                    if (swap === null) break;\n\n                    this.heap[index] = this.heap[swap];\n                    this.heap[swap] = element;\n                    index = swap;\n                }\n            }\n\n            render() {\n                const container = document.getElementById('max-heap-container');\n                container.innerHTML = '';\n                this.visualizeHeap(container, this.heap);\n            }\n\n            visualizeHeap(container, heap, index = 0, level = 0) {\n                if (index < heap.length) {\n                    const row = document.createElement('div');\n                    row.className = 'heap-row';\n                    this.visualizeHeap(container, heap, 2 * index + 1, level + 1);\n                    const node = document.createElement('div');\n                    node.className = 'heap-node';\n                    node.textContent = heap[index];\n                    row.appendChild(node);\n                    this.visualizeHeap(container, heap, 2 * index + 2, level + 1);\n                    container.appendChild(row);\n                }\n            }\n        }\n\n        const minHeap = new MinHeap();\n        const maxHeap = new MaxHeap();\n\n        function insertMinHeap() {\n            const value = parseInt(document.getElementById('value').value);\n            if (!isNaN(value)) {\n                minHeap.insert(value);\n            }\n            document.getElementById('value').value = '';\n        }\n\n        function insertMaxHeap() {\n            const value = parseInt(document.getElementById('value').value);\n            if (!isNaN(value)) {\n                maxHeap.insert(value);\n            }\n            document.getElementById('value').value = '';\n        }\n\n        function deleteMinHeap() {\n            minHeap.delete();\n        }\n\n        function deleteMaxHeap() {\n            maxHeap.delete();\n        }\n    </script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}