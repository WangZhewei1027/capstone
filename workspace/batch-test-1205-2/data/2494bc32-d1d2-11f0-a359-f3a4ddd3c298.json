{
  "id": "2494bc32-d1d2-11f0-a359-f3a4ddd3c298",
  "timestamp": "2025-12-05T12:02:15.698Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background-color: #f4f4f4;\n        }\n        table {\n            width: 50%;\n            margin-top: 20px;\n            border-collapse: collapse;\n        }\n        table, th, td {\n            border: 1px solid #ccc;\n        }\n        th, td {\n            padding: 8px;\n            text-align: center;\n        }\n        th {\n            background-color: #eee;\n        }\n        #canvas {\n            border: 1px solid #000;\n        }\n    </style>\n</head>\n<body>\n\n<h2>Kruskal's Algorithm Visualization</h2>\n<p>This demo visualizes Kruskal's algorithm for finding the Minimum Spanning Tree (MST) of a graph.</p>\n<canvas id=\"canvas\" width=\"800\" height=\"400\"></canvas>\n\n<h3>Edge List</h3>\n<table id=\"edgeTable\">\n    <thead>\n        <tr>\n            <th>Edge</th>\n            <th>Weight</th>\n            <th>Action</th>\n        </tr>\n    </thead>\n    <tbody>\n        <!-- Edges will be populated here -->\n    </tbody>\n</table>\n\n<button onclick=\"runKruskal()\">Run Kruskal's Algorithm</button>\n\n<script>\n    const edges = [\n        {start: 0, end: 1, weight: 10},\n        {start: 0, end: 2, weight: 6},\n        {start: 0, end: 3, weight: 5},\n        {start: 1, end: 3, weight: 15},\n        {start: 2, end: 3, weight: 4},\n    ];\n\n    const parent = [];\n    const rank = [];\n    const selectedEdges = [];\n\n    function initializeDisjointSet(n) {\n        for (let i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    function find(v) {\n        if (parent[v] !== v) {\n            parent[v] = find(parent[v]);\n        }\n        return parent[v];\n    }\n\n    function union(u, v) {\n        const rootU = find(u);\n        const rootV = find(v);\n        if (rootU !== rootV) {\n            if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else {\n                parent[rootV] = rootU;\n                rank[rootU]++;\n            }\n        }\n    }\n\n    function runKruskal() {\n        const sortedEdges = edges.slice().sort((a, b) => a.weight - b.weight);\n        const n = sortedEdges.length;\n\n        initializeDisjointSet(4); // There are 4 vertices (0 to 3)\n\n        for (let edge of sortedEdges) {\n            const {start, end, weight} = edge;\n            if (find(start) !== find(end)) {\n                union(start, end);\n                selectedEdges.push(edge);\n                addEdgeToTable(edge);\n            }\n        }\n\n        drawGraph();\n    }\n\n    function addEdgeToTable(edge) {\n        const tableBody = document.querySelector(\"#edgeTable tbody\");\n        const row = document.createElement(\"tr\");\n        row.innerHTML = `<td>${edge.start}-${edge.end}</td><td>${edge.weight}</td><td>Included</td>`;\n        tableBody.appendChild(row);\n    }\n\n    function drawGraph() {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        const positions = [\n            {x: 100, y: 100}, // Vertex 0\n            {x: 300, y: 50},  // Vertex 1\n            {x: 300, y: 150}, // Vertex 2\n            {x: 500, y: 100}, // Vertex 3\n        ];\n\n        ctx.fillStyle = 'black';\n        positions.forEach((pos, index) => {\n            ctx.beginPath();\n            ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.fillStyle = 'white';\n            ctx.fillText(index, pos.x - 5, pos.y + 5);\n            ctx.fillStyle = 'black';\n        });\n\n        selectedEdges.forEach(edge => {\n            ctx.beginPath();\n            ctx.moveTo(positions[edge.start].x, positions[edge.start].y);\n            ctx.lineTo(positions[edge.end].x, positions[edge.end].y);\n            ctx.strokeStyle = 'blue';\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n        });\n    }\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}