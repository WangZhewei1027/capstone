<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bubble Sort Visualizer</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#4ec5a6;
    --muted:#9aa6b2;
    --danger:#ff6b6b;
    --good:#7ce39a;
    --bar:#6b9bd6;
    --bar-compare:#f6c85f;
    --bar-swap:#ff8f66;
    --bar-sorted:#7ce39a;
    font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", "Helvetica", "Arial", sans-serif;
  }
  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(180deg, #081022 0%, #07111b 60%);
    color:#e6eef6;
  }
  .app{
    max-width:1000px;
    margin:28px auto;
    padding:18px;
  }
  header{
    display:flex;
    gap:12px;
    align-items:center;
    margin-bottom:12px;
  }
  h1{
    font-size:20px;
    margin:0;
    color:var(--accent);
  }
  p.lead{
    margin:0;
    color:var(--muted);
    font-size:13px;
  }
  .controls{
    display:flex;
    gap:12px;
    align-items:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .col{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  label{
    font-size:12px;
    color:var(--muted);
  }
  .row{
    display:flex;
    gap:8px;
    align-items:center;
  }
  input[type=range]{ width:160px; }
  input[type=number]{ width:64px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.05); background:transparent; color:inherit; }
  button{
    background:linear-gradient(180deg,var(--panel), #051223);
    color:var(--accent);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  button.secondary{
    background:transparent;
    color:var(--muted);
    border:1px dashed rgba(255,255,255,0.03);
  }
  button:disabled{ opacity:0.5; cursor:not-allowed; }
  .visual{
    margin-top:14px;
    display:flex;
    gap:12px;
    align-items:flex-end;
    height:360px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
    border-radius:8px;
    padding:16px;
    border:1px solid rgba(255,255,255,0.02);
    overflow:hidden;
  }
  .bar{
    flex:1 1 auto;
    margin:0 2px;
    background:var(--bar);
    border-radius:6px 6px 2px 2px;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    color:rgba(255,255,255,0.85);
    font-size:11px;
    box-shadow:0 2px 6px rgba(2,6,23,0.6) inset;
    transition: background 140ms linear, transform 120ms ease;
    position:relative;
  }
  .bar .val{
    transform:translateY(-6px);
    padding:4px 6px;
    background:rgba(0,0,0,0.15);
    border-radius:6px;
    font-size:11px;
    display:inline-block;
  }
  .bar.compare{ background:var(--bar-compare); color:#072027; }
  .bar.swap{ background:var(--bar-swap); color:#200e03; transform:scale(1.02); }
  .bar.sorted{ background:var(--bar-sorted); color:#042b12; }
  .status{
    margin-top:12px;
    display:flex;
    gap:12px;
    align-items:center;
    font-size:13px;
    color:var(--muted);
  }
  .badge{
    background:rgba(255,255,255,0.02);
    border-radius:6px;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,0.015);
  }
  .pseudocode{
    margin-top:12px;
    padding:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.006));
    border-radius:8px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    font-size:13px;
    color:var(--muted);
    border:1px solid rgba(255,255,255,0.02);
  }
  .pseudocode .line{
    padding:4px 6px;
    border-radius:4px;
  }
  .pseudocode .current{
    background:linear-gradient(90deg, rgba(78,197,166,0.08), rgba(110,170,200,0.03));
    color:var(--accent);
    font-weight:700;
    box-shadow:0 2px 10px rgba(78,197,166,0.04) inset;
  }
  footer{
    margin-top:18px;
    color:var(--muted);
    font-size:13px;
  }
  @media (max-width:880px){
    .visual{ height:260px; }
    .controls{flex-wrap:wrap;}
    header{flex-direction:column; align-items:flex-start; gap:6px;}
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="Bubble sort visualizer">
  <header>
    <div>
      <h1>Bubble Sort Visualizer</h1>
      <p class="lead">See how bubble sort compares and swaps values step-by-step. Try different speeds, sizes and the optimized version.</p>
    </div>
  </header>

  <div class="controls" id="controls">
    <div class="col">
      <label for="size">Array size</label>
      <div class="row">
        <input id="size" type="range" min="5" max="80" value="30" />
        <input id="sizeNum" type="number" min="5" max="80" value="30" />
      </div>
    </div>

    <div class="col">
      <label for="speed">Speed (ms per step)</label>
      <div class="row">
        <input id="speed" type="range" min="5" max="800" value="100" />
        <input id="speedNum" type="number" min="5" max="800" value="100" />
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;">
      <label style="font-size:12px;color:var(--muted);margin-right:6px;">
        <input id="ascending" type="checkbox" checked /> Ascending
      </label>
      <label style="font-size:12px;color:var(--muted);margin-right:6px;">
        <input id="optimized" type="checkbox" checked /> Optimized (early exit)
      </label>
    </div>

    <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
      <button id="randomize">Randomize</button>
      <button id="start">Start</button>
      <button id="step" class="secondary">Step</button>
      <button id="pause" class="secondary" disabled>Pause</button>
      <button id="reset" class="secondary">Reset</button>
    </div>
  </div>

  <div class="visual" id="visual" aria-live="polite" aria-label="Array visualization"></div>

  <div class="status" aria-hidden="false">
    <div class="badge">Comparisons: <strong id="comp">0</strong></div>
    <div class="badge">Swaps: <strong id="swp">0</strong></div>
    <div class="badge">Pass: <strong id="pass">0</strong></div>
    <div class="badge">Current indices: <strong id="idx">-</strong></div>
    <div class="badge">State: <strong id="state">idle</strong></div>
  </div>

  <div class="pseudocode" aria-hidden="true">
    <div class="line" id="line1">for i from 0 to n-1</div>
    <div class="line" id="line2" style="margin-left:12px">for j from 0 to n-i-2</div>
    <div class="line" id="line3" style="margin-left:24px">if A[j] > A[j+1]</div>
    <div class="line" id="line4" style="margin-left:36px">swap A[j] and A[j+1]</div>
    <div class="line" id="line5" style="margin-left:24px">end if</div>
    <div class="line" id="line6" style="margin-left:12px">end for</div>
    <div class="line" id="line7">end for</div>
    <div class="line" id="opt" style="margin-top:6px; font-size:12px; color:var(--muted)">
      Optimized version: track if any swap occurred in a pass; if none, array is already sorted.
    </div>
  </div>

  <footer>
    Tip: Press "Step" to advance one comparison or swap, "Start" to animate continuously, "Pause" to stop. Try the optimized toggle to see early exit behavior.
  </footer>
</div>

<script>
(function(){
  // DOM references
  const visual = document.getElementById('visual');
  const sizeRange = document.getElementById('size');
  const sizeNum = document.getElementById('sizeNum');
  const speedRange = document.getElementById('speed');
  const speedNum = document.getElementById('speedNum');
  const randomizeBtn = document.getElementById('randomize');
  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const stepBtn = document.getElementById('step');
  const resetBtn = document.getElementById('reset');
  const ascendingChk = document.getElementById('ascending');
  const optimizedChk = document.getElementById('optimized');

  const compEl = document.getElementById('comp');
  const swpEl = document.getElementById('swp');
  const passEl = document.getElementById('pass');
  const idxEl = document.getElementById('idx');
  const stateEl = document.getElementById('state');

  const codeLines = {
    1: document.getElementById('line1'),
    2: document.getElementById('line2'),
    3: document.getElementById('line3'),
    4: document.getElementById('line4'),
    5: document.getElementById('line5'),
    6: document.getElementById('line6'),
    7: document.getElementById('line7'),
  };

  // State
  let array = [];
  let bars = [];
  let generator = null;
  let running = false;
  let stepping = false;
  let comparisons = 0;
  let swaps = 0;
  let passCount = 0;
  let currentDelay = Number(speedRange.value);
  let lastAction = null;

  // Sync range and number inputs
  sizeRange.addEventListener('input', () => {
    sizeNum.value = sizeRange.value;
  });
  sizeNum.addEventListener('change', () => {
    let v = Number(sizeNum.value) || 10;
    v = Math.max(5, Math.min(80, v));
    sizeNum.value = v;
    sizeRange.value = v;
  });

  speedRange.addEventListener('input', () => {
    speedNum.value = speedRange.value;
    currentDelay = Number(speedRange.value);
  });
  speedNum.addEventListener('change', () => {
    let v = Number(speedNum.value) || 100;
    v = Math.max(5, Math.min(800, v));
    speedNum.value = v;
    speedRange.value = v;
    currentDelay = v;
  });

  // Utilities
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function createArray(n){
    const arr = [];
    for(let i=0;i<n;i++){
      arr.push(randInt(5, 400));
    }
    return arr;
  }

  function renderArray(){
    visual.innerHTML = '';
    bars = [];
    const n = array.length;
    for(let i=0;i<n;i++){
      const b = document.createElement('div');
      b.className = 'bar';
      b.style.height = (array[i] / 420 * 100) + '%';
      b.style.flexBasis = `${100 / n}%`;
      const val = document.createElement('div');
      val.className = 'val';
      val.textContent = array[i];
      b.appendChild(val);
      visual.appendChild(b);
      bars.push(b);
    }
  }

  function highlight(indices = [], cls = 'compare'){
    // reset non-sorted bars from previous highlights except sorted ones
    bars.forEach(b => {
      if(!b.classList.contains('sorted')){
        b.classList.remove('compare','swap');
      }
    });
    indices.forEach(i => {
      if(bars[i]){
        bars[i].classList.add(cls);
      }
    });
  }

  function markSorted(upto){
    // when a pass completes, elements after n-becomes sorted; fullscreen mark
    for(let i=upto;i<bars.length;i++){
      bars[i].classList.add('sorted');
      bars[i].classList.remove('compare','swap');
    }
  }

  function swapVisual(i,j){
    // swap heights and texts
    const tmpH = bars[i].style.height;
    const tmpT = bars[i].textContent;
    bars[i].style.height = bars[j].style.height;
    bars[i].textContent = bars[j].textContent;
    // ensure value inside .val is updated
    const vi = bars[i].querySelector('.val');
    const vj = bars[j].querySelector('.val');
    if(vi && vj){
      const t = vi.textContent;
      vi.textContent = vj.textContent;
      vj.textContent = t;
    }
  }

  function resetStats(){
    comparisons = 0;
    swaps = 0;
    passCount = 0;
    compEl.textContent = comparisons;
    swpEl.textContent = swaps;
    passEl.textContent = passCount;
    idxEl.textContent = '-';
    stateEl.textContent = 'idle';
    clearCodeHighlight();
  }

  function clearCodeHighlight(){
    for(let k in codeLines){
      codeLines[k].classList.remove('current');
    }
  }

  // Pseudocode highlight convenience
  function setCodeLine(n){
    clearCodeHighlight();
    if(codeLines[n]) codeLines[n].classList.add('current');
  }

  // Generator that yields actions describing the bubble sort steps
  function* bubbleSortGenerator(arr, ascending=true, optimized=true){
    const n = arr.length;
    for(let i=0;i<n;i++){
      let swappedThisPass = false;
      setCodeLine(1);
      // inner loop from 0 to n-i-2 inclusive
      for(let j=0;j<n-i-1;j++){
        setCodeLine(2);
        // compare A[j] and A[j+1]
        setCodeLine(3);
        yield {type:'compare', i:j, j:j+1};
        if(ascending ? (arr[j] > arr[j+1]) : (arr[j] < arr[j+1])){
          // swap
          setCodeLine(4);
          yield {type:'swap', i:j, j:j+1};
          const tmp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = tmp;
          swappedThisPass = true;
        } else {
          // no swap, just continue
          yield {type:'no-swap', i:j, j:j+1};
        }
      }
      passCount++;
      yield {type:'passEnd', pass:passCount, sortedStart: n - i - 1};
      if(optimized && !swappedThisPass){
        // early exit
        yield {type:'done', early:true};
        return;
      }
    }
    yield {type:'done', early:false};
  }

  // Runner to consume generator with play/pause controls
  let consumePromise = null;
  async function consumeGenerator(gen){
    running = true;
    updateControls();
    stateEl.textContent = 'running';
    try{
      while(true){
        if(!running){
          // paused
          stateEl.textContent = 'paused';
          return;
        }
        const {value, done} = gen.next();
        if(done) break;
        await handleAction(value);
        // wait using currentDelay unless stepping single-step
        if(stepping){
          // After one action, pause
          stepping = false;
          running = false;
          updateControls();
          stateEl.textContent = 'paused';
          return;
        } else {
          await sleep(currentDelay);
        }
      }
    } catch(e){
      console.error(e);
    } finally {
      // when finished, mark remaining as sorted
      markSorted(0);
      clearCodeHighlight();
      stateEl.textContent = 'finished';
      running = false;
      updateControls();
    }
  }

  async function handleAction(action){
    if(!action) return;
    switch(action.type){
      case 'compare':
        comparisons++;
        compEl.textContent = comparisons;
        idxEl.textContent = `${action.i}, ${action.j}`;
        // highlight comparing bars
        highlight([action.i, action.j], 'compare');
        setCodeLine(3);
        break;
      case 'no-swap':
        // small visual to show compare without swap
        idxEl.textContent = `${action.i}, ${action.j}`;
        highlight([action.i, action.j], 'compare');
        break;
      case 'swap':
        swaps++;
        swpEl.textContent = swaps;
        idxEl.textContent = `${action.i}, ${action.j}`;
        // show swap
        highlight([action.i, action.j], 'swap');
        // swap values in visual
        swapVisual(action.i, action.j);
        break;
      case 'passEnd':
        passEl.textContent = action.pass;
        idxEl.textContent = '-';
        // elements from sortedStart to end are sorted
        markSorted(action.sortedStart);
        setCodeLine(6);
        break;
      case 'done':
        if(action.early){
          // show note possibly
        }
        break;
      default:
        break;
    }
  }

  // helpers
  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function updateControls(){
    // disable/enable controls depending on running
    sizeRange.disabled = running;
    sizeNum.disabled = running;
    randomizeBtn.disabled = running;
    ascendingChk.disabled = running;
    optimizedChk.disabled = running;
    stepBtn.disabled = running && !stepping; // step allowed if not running (except stepping case)
    startBtn.disabled = running;
    pauseBtn.disabled = !running;
    resetBtn.disabled = running;
  }

  // Button handlers
  randomizeBtn.addEventListener('click', () => {
    const n = Number(sizeRange.value);
    array = createArray(n);
    renderArray();
    resetStats();
  });

  startBtn.addEventListener('click', () => {
    if(running) return;
    // if generator not initialized or finished, (re)create it from current array snapshot
    if(!generator){
      // copy array
      const arrCopy = array.slice();
      generator = bubbleSortGenerator(arrCopy, ascendingChk.checked, optimizedChk.checked);
    }
    running = true;
    stepping = false;
    updateControls();
    consumeGenerator(generator);
  });

  pauseBtn.addEventListener('click', () => {
    running = false;
    updateControls();
  });

  stepBtn.addEventListener('click', () => {
    if(running) return;
    // if generator not initialized, create a new one with copy of current state
    if(!generator){
      const arrCopy = array.slice();
      generator = bubbleSortGenerator(arrCopy, ascendingChk.checked, optimizedChk.checked);
    }
    stepping = true;
    running = true;
    updateControls();
    // consume just one action
    consumeGenerator(generator);
  });

  resetBtn.addEventListener('click', () => {
    // reset to fresh random array and clear generator & stats
    const n = Number(sizeRange.value);
    array = createArray(n);
    renderArray();
    generator = null;
    running = false;
    stepping = false;
    markSorted(bars.length); // none sorted
    resetStats();
    updateControls();
  });

  // Initialize
  (function init(){
    const n = Number(sizeRange.value);
    array = createArray(n);
    renderArray();
    resetStats();
    updateControls();
    sizeNum.value = sizeRange.value;
    speedNum.value = speedRange.value;
    // connect size number input to re-generate quickly when changed
    sizeNum.addEventListener('input', () => {
      sizeRange.value = sizeNum.value;
    });
    sizeNum.addEventListener('change', () => {
      const v = Number(sizeNum.value);
      sizeRange.value = v;
      // regenerate
      array = createArray(v);
      renderArray();
      generator = null;
      resetStats();
      updateControls();
    });
    // speed changes update delay variable
    speedRange.addEventListener('input', () => {
      currentDelay = Number(speedRange.value);
    });
    // update speedNum changes
    speedNum.addEventListener('change', () => {
      currentDelay = Number(speedNum.value);
    });

    // Allow clicking a bar to highlight and optionally change value (for experimentation)
    visual.addEventListener('click', (e) => {
      const bar = e.target.closest('.bar');
      if(!bar) return;
      // find index
      const idx = Array.prototype.indexOf.call(visual.children, bar);
      alert('Bar index ' + idx + ' value ' + array[idx] + '\nYou can randomize/reset to change.');
    });

    // small convenience: pressing Space toggles start/pause
    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space'){
        e.preventDefault();
        if(running){
          pauseBtn.click();
        } else {
          startBtn.click();
        }
      }
    });

  })();

  // Keep generator null when array changed or options toggled
  ascendingChk.addEventListener('change', () => { generator = null; resetStats(); });
  optimizedChk.addEventListener('change', () => { generator = null; resetStats(); });

})();
</script>
</body>
</html>