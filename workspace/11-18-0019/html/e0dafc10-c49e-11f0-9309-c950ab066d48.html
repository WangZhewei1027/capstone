<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Visualization & Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f0f0;
  }
  h1 {
    text-align: center;
  }
  #controls {
    margin-bottom: 15px;
    text-align: center;
  }
  input[type=number] {
    width: 80px;
    padding: 5px;
    font-size: 16px;
  }
  button {
    padding: 7px 15px;
    font-size: 16px;
    margin-left: 5px;
    cursor: pointer;
  }
  #output {
    margin-top: 10px;
    min-height: 24px;
    font-weight: bold;
    text-align: center;
  }
  #tree {
    margin-top: 20px;
    overflow-x: auto;
    padding: 10px;
    background: white;
    border-radius: 5px;
    border: 1px solid #ccc;
    min-height: 300px;
  }
  /* Tree styling */
  .node {
    display: inline-block;
    position: relative;
    vertical-align: top;
    text-align: center;
  }
  .node .circle {
    display: inline-block;
    width: 40px;
    height: 40px;
    line-height: 40px;
    background: #3498db;
    border-radius: 50%;
    color: white;
    font-weight: bold;
    margin: 0 auto;
    border: 3px solid #2980b9;
    box-sizing: border-box;
    transition: background-color 0.3s, border-color 0.3s;
  }
  .node.highlight .circle {
    background: #e74c3c;
    border-color: #c0392b;
  }
  .children {
    margin-top: 20px;
    white-space: nowrap;
  }
  /* Connectors */
  .connector {
    position: absolute;
    width: 20px;
    height: 20px;
    top: 38px;
  }
  .connector.left {
    border-left: 3px solid #555;
    border-bottom: 3px solid #555;
    border-radius: 0 0 0 0;
    left: 0;
  }
  .connector.right {
    border-right: 3px solid #555;
    border-bottom: 3px solid #555;
    right: 0;
  }

  #traversalButtons button {
    margin: 0 5px;
  }
  #traversalResult {
    margin-top: 10px;
    text-align: center;
    font-size: 1.1em;
  }
</style>
</head>
<body>
<h1>Binary Search Tree (BST) Visualization & Demo</h1>

<div id="controls">
  <input type="number" id="inputValue" placeholder="Enter value" />
  <button id="insertBtn">Insert</button>
  <button id="searchBtn">Search</button>
  <button id="deleteBtn">Delete</button>
  <button id="clearBtn" title="Clear the whole tree" style="background:#e67e22; color:white;">Clear Tree</button>
</div>

<div id="traversalButtons" style="text-align:center; margin-bottom:10px;">
  <button id="inOrderBtn" title="Show In-Order Traversal">In-Order</button>
  <button id="preOrderBtn" title="Show Pre-Order Traversal">Pre-Order</button>
  <button id="postOrderBtn" title="Show Post-Order Traversal">Post-Order</button>
  <button id="levelOrderBtn" title="Show Level-Order Traversal">Level-Order</button>
</div>

<div id="traversalResult"></div>

<div id="output"></div>
<div id="tree"></div>

<script>
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
  }

  class BST {
    constructor() {
      this.root = null;
    }

    insert(value) {
      const newNode = new Node(value);
      if (!this.root) {
        this.root = newNode;
        return true;
      }
      let current = this.root;
      while (true) {
        if (value === current.value) {
          return false; // duplicates not allowed
        }
        if (value < current.value) {
          if (!current.left) {
            current.left = newNode;
            return true;
          }
          current = current.left;
        } else {
          if (!current.right) {
            current.right = newNode;
            return true;
          }
          current = current.right;
        }
      }
    }

    search(value) {
      let current = this.root;
      while (current) {
        if (value === current.value) return true;
        if (value < current.value) current = current.left;
        else current = current.right;
      }
      return false;
    }

    delete(value) {
      this.root = this._deleteRec(this.root, value);
    }

    _deleteRec(root, value) {
      if (root === null) return root;

      if (value < root.value) {
        root.left = this._deleteRec(root.left, value);
      } else if (value > root.value) {
        root.right = this._deleteRec(root.right, value);
      } else {
        // Node found
        if (!root.left) return root.right;
        else if (!root.right) return root.left;

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        root.value = this._minValue(root.right);
        root.right = this._deleteRec(root.right, root.value);
      }
      return root;
    }

    _minValue(node) {
      let current = node;
      while (current.left) current = current.left;
      return current.value;
    }

    inOrder() {
      const result = [];
      this._inOrderRec(this.root, result);
      return result;
    }

    _inOrderRec(node, res) {
      if (!node) return;
      this._inOrderRec(node.left, res);
      res.push(node.value);
      this._inOrderRec(node.right, res);
    }

    preOrder() {
      const result = [];
      this._preOrderRec(this.root, result);
      return result;
    }

    _preOrderRec(node, res) {
      if (!node) return;
      res.push(node.value);
      this._preOrderRec(node.left, res);
      this._preOrderRec(node.right, res);
    }

    postOrder() {
      const result = [];
      this._postOrderRec(this.root, result);
      return result;
    }

    _postOrderRec(node, res) {
      if (!node) return;
      this._postOrderRec(node.left, res);
      this._postOrderRec(node.right, res);
      res.push(node.value);
    }

    levelOrder() {
      const result = [];
      if (!this.root) return result;
      const queue = [this.root];
      while (queue.length) {
        const node = queue.shift();
        result.push(node.value);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      return result;
    }
  }

  // Visualization code
  const treeContainer = document.getElementById('tree');
  const output = document.getElementById('output');
  const traversalResult = document.getElementById('traversalResult');
  const bst = new BST();

  function createNodeElement(node) {
    if (!node) return null;

    const el = document.createElement('div');
    el.className = 'node';

    const circle = document.createElement('div');
    circle.className = 'circle';
    circle.textContent = node.value;
    el.appendChild(circle);

    if (node.left || node.right) {
      const childrenDiv = document.createElement('div');
      childrenDiv.className = 'children';

      if (node.left) {
        const leftEl = createNodeElement(node.left);
        leftEl.style.position = 'relative';
        const connectorLeft = document.createElement('div');
        connectorLeft.className = 'connector left';
        leftEl.appendChild(connectorLeft);
        childrenDiv.appendChild(leftEl);
      } else {
        // Placeholder to keep branches aligned
        const emptyLeft = document.createElement('div');
        emptyLeft.className = 'node';
        emptyLeft.style.width = '40px';
        childrenDiv.appendChild(emptyLeft);
      }

      if (node.right) {
        const rightEl = createNodeElement(node.right);
        rightEl.style.position = 'relative';
        const connectorRight = document.createElement('div');
        connectorRight.className = 'connector right';
        rightEl.appendChild(connectorRight);
        childrenDiv.appendChild(rightEl);
      } else {
        // Placeholder
        const emptyRight = document.createElement('div');
        emptyRight.className = 'node';
        emptyRight.style.width = '40px';
        childrenDiv.appendChild(emptyRight);
      }

      el.appendChild(childrenDiv);
    }

    return el;
  }

  function render() {
    treeContainer.innerHTML = '';
    if (!bst.root) {
      treeContainer.textContent = 'Tree is empty.';
      return;
    }
    const treeEl = createNodeElement(bst.root);
    treeContainer.appendChild(treeEl);
  }

  function showMessage(msg, isError = false) {
    output.textContent = msg;
    output.style.color = isError ? 'crimson' : 'green';
  }

  function highlightSearchPath(value) {
    // Highlights the path as we search for value
    let current = bst.root;
    const highlights = [];

    function clearHighlights() {
      highlights.forEach(el => el.classList.remove('highlight'));
    }

    clearHighlights();

    if (!current) return;

    // Gather all node circle divs in order to highlight them
    const allCircles = Array.from(treeContainer.querySelectorAll('.circle'));

    function findNodeElementByValue(val) {
      return allCircles.find(el => el.textContent == val);
    }

    let interval;
    let found = false;

    let index = 0;
    const pathNodes = [];

    while(current) {
      pathNodes.push(current.value);
      if (value === current.value) {
        found = true;
        break;
      }
      if (value < current.value) current = current.left;
      else current = current.right;
    }

    let i = 0;
    (function highlightStep() {
      if (i > 0) {
        const prevEl = findNodeElementByValue(pathNodes[i-1]);
        if (prevEl) prevEl.parentElement.classList.remove('highlight');
      }
      if (i < pathNodes.length) {
        const el = findNodeElementByValue(pathNodes[i]);
        if (el) el.parentElement.classList.add('highlight');
        i++;
        setTimeout(highlightStep, 700);
      } else {
        // Final message
        if (found) {
          showMessage(`Value ${value} found in the tree.`);
        } else {
          showMessage(`Value ${value} not found in the tree.`, true);
        }
        setTimeout(() => {
          // Remove highlights after a moment
          pathNodes.forEach(val => {
            const el = findNodeElementByValue(val);
            if (el) el.parentElement.classList.remove('highlight');
          });
        }, 1500);
      }
    })();
  }

  document.getElementById('insertBtn').addEventListener('click', () => {
    const val = parseInt(document.getElementById('inputValue').value);
    traversalResult.textContent = '';
    if (isNaN(val)) {
      showMessage('Please enter a valid number to insert.', true);
      return;
    }
    if (bst.insert(val)) {
      showMessage(`Inserted ${val} into the tree.`);
      render();
    } else {
      showMessage(`Value ${val} already exists in the tree. Duplicates not allowed.`, true);
    }
  });

  document.getElementById('searchBtn').addEventListener('click', () => {
    const val = parseInt(document.getElementById('inputValue').value);
    traversalResult.textContent = '';
    if (isNaN(val)) {
      showMessage('Please enter a valid number to search.', true);
      return;
    }
    if (!bst.root) {
      showMessage('Tree is empty.', true);
      return;
    }
    showMessage(`Searching for ${val}...`);
    highlightSearchPath(val);
  });

  document.getElementById('deleteBtn').addEventListener('click', () => {
    const val = parseInt(document.getElementById('inputValue').value);
    traversalResult.textContent = '';
    if (isNaN(val)) {
      showMessage('Please enter a valid number to delete.', true);
      return;
    }
    if (!bst.search(val)) {
      showMessage(`Value ${val} not found in the tree. Cannot delete.`, true);
      return;
    }
    bst.delete(val);
    showMessage(`Deleted ${val} from the tree.`);
    render();
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    bst.root = null;
    traversalResult.textContent = '';
    render();
    showMessage('Cleared the tree.');
  });

  document.getElementById('inOrderBtn').addEventListener('click', () => {
    if (!bst.root) {
      traversalResult.textContent = 'Tree is empty.';
      return;
    }
    const result = bst.inOrder();
    traversalResult.textContent = 'In-Order Traversal: ' + result.join(', ');
  });

  document.getElementById('preOrderBtn').addEventListener('click', () => {
    if (!bst.root) {
      traversalResult.textContent = 'Tree is empty.';
      return;
    }
    const result = bst.preOrder();
    traversalResult.textContent = 'Pre-Order Traversal: ' + result.join(', ');
  });

  document.getElementById('postOrderBtn').addEventListener('click', () => {
    if (!bst.root) {
      traversalResult.textContent = 'Tree is empty.';
      return;
    }
    const result = bst.postOrder();
    traversalResult.textContent = 'Post-Order Traversal: ' + result.join(', ');
  });

  document.getElementById('levelOrderBtn').addEventListener('click', () => {
    if (!bst.root) {
      traversalResult.textContent = 'Tree is empty.';
      return;
    }
    const result = bst.levelOrder();
    traversalResult.textContent = 'Level-Order Traversal: ' + result.join(', ');
  });

  // On enter on input runs insert by default
  document.getElementById('inputValue').addEventListener('keydown', e => {
    if(e.key === 'Enter') {
      document.getElementById('insertBtn').click();
    }
  });

  // Initial render
  render();
</script>
</body>
</html>