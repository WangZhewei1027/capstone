[
  {
    "id": "e0dafc10-c49e-11f0-9309-c950ab066d48",
    "timestamp": "2025-11-18T16:55:00.977Z",
    "model": "gpt-3.5-turbo",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Search Tree (BST) Visualization & Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #controls {\n    margin-bottom: 15px;\n    text-align: center;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 5px;\n    font-size: 16px;\n  }\n  button {\n    padding: 7px 15px;\n    font-size: 16px;\n    margin-left: 5px;\n    cursor: pointer;\n  }\n  #output {\n    margin-top: 10px;\n    min-height: 24px;\n    font-weight: bold;\n    text-align: center;\n  }\n  #tree {\n    margin-top: 20px;\n    overflow-x: auto;\n    padding: 10px;\n    background: white;\n    border-radius: 5px;\n    border: 1px solid #ccc;\n    min-height: 300px;\n  }\n  /* Tree styling */\n  .node {\n    display: inline-block;\n    position: relative;\n    vertical-align: top;\n    text-align: center;\n  }\n  .node .circle {\n    display: inline-block;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    background: #3498db;\n    border-radius: 50%;\n    color: white;\n    font-weight: bold;\n    margin: 0 auto;\n    border: 3px solid #2980b9;\n    box-sizing: border-box;\n    transition: background-color 0.3s, border-color 0.3s;\n  }\n  .node.highlight .circle {\n    background: #e74c3c;\n    border-color: #c0392b;\n  }\n  .children {\n    margin-top: 20px;\n    white-space: nowrap;\n  }\n  /* Connectors */\n  .connector {\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    top: 38px;\n  }\n  .connector.left {\n    border-left: 3px solid #555;\n    border-bottom: 3px solid #555;\n    border-radius: 0 0 0 0;\n    left: 0;\n  }\n  .connector.right {\n    border-right: 3px solid #555;\n    border-bottom: 3px solid #555;\n    right: 0;\n  }\n\n  #traversalButtons button {\n    margin: 0 5px;\n  }\n  #traversalResult {\n    margin-top: 10px;\n    text-align: center;\n    font-size: 1.1em;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Search Tree (BST) Visualization & Demo</h1>\n\n<div id=\"controls\">\n  <input type=\"number\" id=\"inputValue\" placeholder=\"Enter value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"searchBtn\">Search</button>\n  <button id=\"deleteBtn\">Delete</button>\n  <button id=\"clearBtn\" title=\"Clear the whole tree\" style=\"background:#e67e22; color:white;\">Clear Tree</button>\n</div>\n\n<div id=\"traversalButtons\" style=\"text-align:center; margin-bottom:10px;\">\n  <button id=\"inOrderBtn\" title=\"Show In-Order Traversal\">In-Order</button>\n  <button id=\"preOrderBtn\" title=\"Show Pre-Order Traversal\">Pre-Order</button>\n  <button id=\"postOrderBtn\" title=\"Show Post-Order Traversal\">Post-Order</button>\n  <button id=\"levelOrderBtn\" title=\"Show Level-Order Traversal\">Level-Order</button>\n</div>\n\n<div id=\"traversalResult\"></div>\n\n<div id=\"output\"></div>\n<div id=\"tree\"></div>\n\n<script>\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      const newNode = new Node(value);\n      if (!this.root) {\n        this.root = newNode;\n        return true;\n      }\n      let current = this.root;\n      while (true) {\n        if (value === current.value) {\n          return false; // duplicates not allowed\n        }\n        if (value < current.value) {\n          if (!current.left) {\n            current.left = newNode;\n            return true;\n          }\n          current = current.left;\n        } else {\n          if (!current.right) {\n            current.right = newNode;\n            return true;\n          }\n          current = current.right;\n        }\n      }\n    }\n\n    search(value) {\n      let current = this.root;\n      while (current) {\n        if (value === current.value) return true;\n        if (value < current.value) current = current.left;\n        else current = current.right;\n      }\n      return false;\n    }\n\n    delete(value) {\n      this.root = this._deleteRec(this.root, value);\n    }\n\n    _deleteRec(root, value) {\n      if (root === null) return root;\n\n      if (value < root.value) {\n        root.left = this._deleteRec(root.left, value);\n      } else if (value > root.value) {\n        root.right = this._deleteRec(root.right, value);\n      } else {\n        // Node found\n        if (!root.left) return root.right;\n        else if (!root.right) return root.left;\n\n        // Node with two children: Get the inorder successor (smallest in the right subtree)\n        root.value = this._minValue(root.right);\n        root.right = this._deleteRec(root.right, root.value);\n      }\n      return root;\n    }\n\n    _minValue(node) {\n      let current = node;\n      while (current.left) current = current.left;\n      return current.value;\n    }\n\n    inOrder() {\n      const result = [];\n      this._inOrderRec(this.root, result);\n      return result;\n    }\n\n    _inOrderRec(node, res) {\n      if (!node) return;\n      this._inOrderRec(node.left, res);\n      res.push(node.value);\n      this._inOrderRec(node.right, res);\n    }\n\n    preOrder() {\n      const result = [];\n      this._preOrderRec(this.root, result);\n      return result;\n    }\n\n    _preOrderRec(node, res) {\n      if (!node) return;\n      res.push(node.value);\n      this._preOrderRec(node.left, res);\n      this._preOrderRec(node.right, res);\n    }\n\n    postOrder() {\n      const result = [];\n      this._postOrderRec(this.root, result);\n      return result;\n    }\n\n    _postOrderRec(node, res) {\n      if (!node) return;\n      this._postOrderRec(node.left, res);\n      this._postOrderRec(node.right, res);\n      res.push(node.value);\n    }\n\n    levelOrder() {\n      const result = [];\n      if (!this.root) return result;\n      const queue = [this.root];\n      while (queue.length) {\n        const node = queue.shift();\n        result.push(node.value);\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n      }\n      return result;\n    }\n  }\n\n  // Visualization code\n  const treeContainer = document.getElementById('tree');\n  const output = document.getElementById('output');\n  const traversalResult = document.getElementById('traversalResult');\n  const bst = new BST();\n\n  function createNodeElement(node) {\n    if (!node) return null;\n\n    const el = document.createElement('div');\n    el.className = 'node';\n\n    const circle = document.createElement('div');\n    circle.className = 'circle';\n    circle.textContent = node.value;\n    el.appendChild(circle);\n\n    if (node.left || node.right) {\n      const childrenDiv = document.createElement('div');\n      childrenDiv.className = 'children';\n\n      if (node.left) {\n        const leftEl = createNodeElement(node.left);\n        leftEl.style.position = 'relative';\n        const connectorLeft = document.createElement('div');\n        connectorLeft.className = 'connector left';\n        leftEl.appendChild(connectorLeft);\n        childrenDiv.appendChild(leftEl);\n      } else {\n        // Placeholder to keep branches aligned\n        const emptyLeft = document.createElement('div');\n        emptyLeft.className = 'node';\n        emptyLeft.style.width = '40px';\n        childrenDiv.appendChild(emptyLeft);\n      }\n\n      if (node.right) {\n        const rightEl = createNodeElement(node.right);\n        rightEl.style.position = 'relative';\n        const connectorRight = document.createElement('div');\n        connectorRight.className = 'connector right';\n        rightEl.appendChild(connectorRight);\n        childrenDiv.appendChild(rightEl);\n      } else {\n        // Placeholder\n        const emptyRight = document.createElement('div');\n        emptyRight.className = 'node';\n        emptyRight.style.width = '40px';\n        childrenDiv.appendChild(emptyRight);\n      }\n\n      el.appendChild(childrenDiv);\n    }\n\n    return el;\n  }\n\n  function render() {\n    treeContainer.innerHTML = '';\n    if (!bst.root) {\n      treeContainer.textContent = 'Tree is empty.';\n      return;\n    }\n    const treeEl = createNodeElement(bst.root);\n    treeContainer.appendChild(treeEl);\n  }\n\n  function showMessage(msg, isError = false) {\n    output.textContent = msg;\n    output.style.color = isError ? 'crimson' : 'green';\n  }\n\n  function highlightSearchPath(value) {\n    // Highlights the path as we search for value\n    let current = bst.root;\n    const highlights = [];\n\n    function clearHighlights() {\n      highlights.forEach(el => el.classList.remove('highlight'));\n    }\n\n    clearHighlights();\n\n    if (!current) return;\n\n    // Gather all node circle divs in order to highlight them\n    const allCircles = Array.from(treeContainer.querySelectorAll('.circle'));\n\n    function findNodeElementByValue(val) {\n      return allCircles.find(el => el.textContent == val);\n    }\n\n    let interval;\n    let found = false;\n\n    let index = 0;\n    const pathNodes = [];\n\n    while(current) {\n      pathNodes.push(current.value);\n      if (value === current.value) {\n        found = true;\n        break;\n      }\n      if (value < current.value) current = current.left;\n      else current = current.right;\n    }\n\n    let i = 0;\n    (function highlightStep() {\n      if (i > 0) {\n        const prevEl = findNodeElementByValue(pathNodes[i-1]);\n        if (prevEl) prevEl.parentElement.classList.remove('highlight');\n      }\n      if (i < pathNodes.length) {\n        const el = findNodeElementByValue(pathNodes[i]);\n        if (el) el.parentElement.classList.add('highlight');\n        i++;\n        setTimeout(highlightStep, 700);\n      } else {\n        // Final message\n        if (found) {\n          showMessage(`Value ${value} found in the tree.`);\n        } else {\n          showMessage(`Value ${value} not found in the tree.`, true);\n        }\n        setTimeout(() => {\n          // Remove highlights after a moment\n          pathNodes.forEach(val => {\n            const el = findNodeElementByValue(val);\n            if (el) el.parentElement.classList.remove('highlight');\n          });\n        }, 1500);\n      }\n    })();\n  }\n\n  document.getElementById('insertBtn').addEventListener('click', () => {\n    const val = parseInt(document.getElementById('inputValue').value);\n    traversalResult.textContent = '';\n    if (isNaN(val)) {\n      showMessage('Please enter a valid number to insert.', true);\n      return;\n    }\n    if (bst.insert(val)) {\n      showMessage(`Inserted ${val} into the tree.`);\n      render();\n    } else {\n      showMessage(`Value ${val} already exists in the tree. Duplicates not allowed.`, true);\n    }\n  });\n\n  document.getElementById('searchBtn').addEventListener('click', () => {\n    const val = parseInt(document.getElementById('inputValue').value);\n    traversalResult.textContent = '';\n    if (isNaN(val)) {\n      showMessage('Please enter a valid number to search.', true);\n      return;\n    }\n    if (!bst.root) {\n      showMessage('Tree is empty.', true);\n      return;\n    }\n    showMessage(`Searching for ${val}...`);\n    highlightSearchPath(val);\n  });\n\n  document.getElementById('deleteBtn').addEventListener('click', () => {\n    const val = parseInt(document.getElementById('inputValue').value);\n    traversalResult.textContent = '';\n    if (isNaN(val)) {\n      showMessage('Please enter a valid number to delete.', true);\n      return;\n    }\n    if (!bst.search(val)) {\n      showMessage(`Value ${val} not found in the tree. Cannot delete.`, true);\n      return;\n    }\n    bst.delete(val);\n    showMessage(`Deleted ${val} from the tree.`);\n    render();\n  });\n\n  document.getElementById('clearBtn').addEventListener('click', () => {\n    bst.root = null;\n    traversalResult.textContent = '';\n    render();\n    showMessage('Cleared the tree.');\n  });\n\n  document.getElementById('inOrderBtn').addEventListener('click', () => {\n    if (!bst.root) {\n      traversalResult.textContent = 'Tree is empty.';\n      return;\n    }\n    const result = bst.inOrder();\n    traversalResult.textContent = 'In-Order Traversal: ' + result.join(', ');\n  });\n\n  document.getElementById('preOrderBtn').addEventListener('click', () => {\n    if (!bst.root) {\n      traversalResult.textContent = 'Tree is empty.';\n      return;\n    }\n    const result = bst.preOrder();\n    traversalResult.textContent = 'Pre-Order Traversal: ' + result.join(', ');\n  });\n\n  document.getElementById('postOrderBtn').addEventListener('click', () => {\n    if (!bst.root) {\n      traversalResult.textContent = 'Tree is empty.';\n      return;\n    }\n    const result = bst.postOrder();\n    traversalResult.textContent = 'Post-Order Traversal: ' + result.join(', ');\n  });\n\n  document.getElementById('levelOrderBtn').addEventListener('click', () => {\n    if (!bst.root) {\n      traversalResult.textContent = 'Tree is empty.';\n      return;\n    }\n    const result = bst.levelOrder();\n    traversalResult.textContent = 'Level-Order Traversal: ' + result.join(', ');\n  });\n\n  // On enter on input runs insert by default\n  document.getElementById('inputValue').addEventListener('keydown', e => {\n    if(e.key === 'Enter') {\n      document.getElementById('insertBtn').click();\n    }\n  });\n\n  // Initial render\n  render();\n</script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "evaluation": {
      "score": null,
      "notes": ""
    }
  }
]