<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Exploration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }
        article {
            flex-basis: 60%;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        aside {
            flex-basis: 35%;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.8em;
        }
        .button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        #result {
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

<header>
    <h1>K-Nearest Neighbors (KNN) Exploration</h1>
</header>

<section>
    <article>
        <h2>What is KNN?</h2>
        <p>K-Nearest Neighbors (KNN) is a simple, yet powerful algorithm used for classification and regression tasks. It works by finding the 'K' closest training data points in the feature space and making predictions based on them.</p>

        <h3>How does it work?</h3>
        <ol>
            <li>Choose the number of neighbors (K).</li>
            <li>Calculate the distance between the new data point and all training points.</li>
            <li>Sort the distances and select the K nearest neighbors.</li>
            <li>For classification, perform a majority vote among the K neighbors. For regression, take the average of their values.</li>
        </ol>

        <h3>Interactive Visualization</h3>
        <canvas id="knnCanvas" width="400" height="400" style="border:1px solid #d3d3d3;"></canvas>
        <div id="result"></div>
        <button class="button" id="classifyButton">Classify Point</button>
    </article>

    <aside>
        <h2>Set Parameters</h2>
        <label for="kValue">Choose K (number of neighbors):</label>
        <input type="number" id="kValue" value="3" min="1" max="10">
        <h3>Data Points</h3>
        <dl>
            <dt>Green Points:</dt>
            <dd>Class 1</dd>
            <dt>Red Points:</dt>
            <dd>Class 2</dd>
        </dl>
        <h3>Instructions</h3>
        <p>Click on the canvas to place a new point, and then click on "Classify Point". Observe the results based on your K value.</p>
    </aside>
</section>

<footer>
    <p>&copy; 2023 KNN Interactive Exploration. All rights reserved.</p>
</footer>

<script>
    const canvas = document.getElementById('knnCanvas');
    const ctx = canvas.getContext('2d');
    const kValueInput = document.getElementById('kValue');
    const resultDiv = document.getElementById('result');

    const greenPoints = [
        { x: 50, y: 50 },
        { x: 60, y: 70 },
        { x: 55, y: 80 },
        { x: 80, y: 55 },
    ];

    const redPoints = [
        { x: 200, y: 200 },
        { x: 210, y: 220 },
        { x: 220, y: 210 },
        { x: 230, y: 230 },
    ];

    function drawPoints() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'green';
        greenPoints.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.fillStyle = 'red';
        redPoints.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function classifyPoint(x, y) {
        const k = parseInt(kValueInput.value);
        const distances = [];

        const allPoints = greenPoints.map(p => ({...p, class: 'Green'})).concat(redPoints.map(p => ({...p, class: 'Red'})));

        allPoints.forEach(point => {
            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
            distances.push({ point: point, distance: distance });
        });

        distances.sort((a, b) => a.distance - b.distance);
        
        const neighbors = distances.slice(0, k);
        const classVotes = {};

        neighbors.forEach(neighbor => {
            const cls = neighbor.point.class;
            classVotes[cls] = (classVotes[cls] || 0) + 1;
        });

        const predictedClass = Object.keys(classVotes).reduce((a, b) => classVotes[a] > classVotes[b] ? a : b);
        return predictedClass;
    }

    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const predictedClass = classifyPoint(x, y);
        resultDiv.textContent = `Predicted Class: ${predictedClass}`;
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
    });

    document.getElementById('classifyButton').addEventListener('click', () => {
        const lastClick = ctx.lastClick;
        if (lastClick) {
            const predictedClass = classifyPoint(lastClick.x, lastClick.y);
            resultDiv.textContent = `Predicted Class: ${predictedClass}`;
        }
    });

    drawPoints();
</script>
</body>
</html>