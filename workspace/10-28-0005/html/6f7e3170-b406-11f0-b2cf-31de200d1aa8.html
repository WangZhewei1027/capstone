<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bubble Sort Visual Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --safe-pad: 24px;
      --gap: 16px;
      --bar-gap: 8px;
      --bg: #0f172a;           /* slate-900 */
      --panel: #111827;        /* gray-900 */
      --text: #e5e7eb;         /* gray-200 */
      --muted: #94a3b8;        /* slate-400 */
      --accent: #22c55e;       /* green-500 */
      --accent-2: #60a5fa;     /* blue-400 */
      --alert: #f97316;        /* orange-500 */
      --danger: #ef4444;       /* red-500 */
      --bar: #3b82f6;          /* blue-500 */
      --bar-compare: #f59e0b;  /* amber-500 */
      --bar-swap: #ef4444;     /* red-500 */
      --bar-settled: #22c55e;  /* green-500 */
      --anim-duration: 450ms;  /* default animation speed */
      --radius: 10px;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      background: linear-gradient(180deg, #0b1222 0%, #0f172a 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.35;
    }

    .safe {
      padding: var(--safe-pad);
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      margin-bottom: 16px;
    }
    h1 {
      font-size: 1.75rem;
      margin: 0 0 8px 0;
      letter-spacing: 0.2px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .main {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: var(--gap);
    }
    @media (max-width: 900px) {
      .main {
        grid-template-columns: 1fr;
      }
    }

    .viz-card, .control-card {
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.15);
      border-radius: var(--radius);
      padding: 16px;
      backdrop-filter: blur(6px);
    }

    .viz-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .legend i {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 3px;
      margin-right: 6px;
    }
    .legend-item {
      font-size: 0.9rem;
      color: var(--muted);
      display: flex;
      align-items: center;
    }

    /* Visualization area */
    .viz {
      position: relative;
      width: 100%;
      height: 360px;
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.12), rgba(148, 163, 184, 0.06));
      border: 1px dashed rgba(148, 163, 184, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .bars {
      position: absolute;
      inset: 16px;
    }

    .bar {
      position: absolute;
      bottom: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      border-radius: 6px 6px 0 0;
      background: var(--bar);
      color: #0b1222;
      font-weight: 600;
      text-shadow: 0 1px 0 rgba(255,255,255,0.3);
      transition: transform var(--anim-duration) ease, height var(--anim-duration) ease, background-color 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 8px 14px rgba(59, 130, 246, 0.15);
      will-change: transform, height;
    }
    .bar-label {
      background: rgba(255, 255, 255, 0.9);
      color: #0b1222;
      padding: 4px 6px;
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 0.85rem;
      user-select: none;
      pointer-events: none;
    }

    .bar.comparing {
      background: var(--bar-compare);
      animation: pulse 0.6s ease-in-out infinite alternate;
      box-shadow: 0 10px 18px rgba(245, 158, 11, 0.25);
    }
    .bar.swapped {
      background: var(--bar-swap);
      box-shadow: 0 10px 18px rgba(239, 68, 68, 0.28);
    }
    .bar.settled {
      background: linear-gradient(180deg, #22c55e, #16a34a);
      box-shadow: 0 10px 18px rgba(34, 197, 94, 0.28);
    }

    @keyframes pulse {
      from { filter: brightness(1); }
      to { filter: brightness(1.15); }
    }

    /* Pointer above current comparison */
    .pointer {
      position: absolute;
      top: 0;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform var(--anim-duration) ease;
      pointer-events: none;
    }
    .pointer .brace {
      width: 80px;
      height: 16px;
      border: 3px solid var(--accent-2);
      border-top: none;
      border-radius: 0 0 10px 10px;
      filter: drop-shadow(0 2px 4px rgba(96, 165, 250, 0.35));
    }
    .pointer .label {
      margin-left: 10px;
      color: var(--muted);
      font-size: 0.85rem;
      background: rgba(17, 24, 39, 0.7);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .group-title {
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
    }

    button, .field, select, input[type="range"] {
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(17, 24, 39, 0.75);
      color: var(--text);
    }

    button {
      padding: 12px 16px;
      min-height: 44px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s ease, transform 0.02s ease;
    }
    button:hover { background: rgba(17,24,39,0.9); }
    button:active { transform: translateY(1px); }
    button.primary { background: linear-gradient(180deg, #2563eb, #1d4ed8); border-color: transparent; }
    button.warning { background: linear-gradient(180deg, #f59e0b, #d97706); border-color: transparent; }
    button.success { background: linear-gradient(180deg, #22c55e, #16a34a); border-color: transparent; }
    button.muted { color: var(--muted); }

    .field {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      min-height: 44px;
      width: 100%;
    }
    .field input[type="text"] {
      flex: 1;
      min-width: 240px;
      border: none;
      outline: none;
      background: transparent;
      color: var(--text);
      font-size: 0.95rem;
    }
    .field .hint {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .range-row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: var(--gap);
    }
    input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--accent-2);
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(96, 165, 250, 0.35);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px; height: 20px; background: var(--accent-2); border-radius: 50%; cursor: pointer;
    }

    .narration {
      font-size: 0.95rem;
      color: var(--text);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(17, 24, 39, 0.6);
    }
    .narration .line {
      margin-bottom: 8px;
    }
    .narration .sub {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--gap);
    }
    .stat {
      background: rgba(17, 24, 39, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }
    .stat .value {
      font-size: 1.25rem;
      font-weight: 700;
    }
    .stat .label {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .footer-note {
      margin-top: 12px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    /* Accessibility focus */
    :focus-visible {
      outline: 3px solid #38bdf8;
      outline-offset: 2px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="safe">
    <header role="banner">
      <h1 aria-label="Bubble Sort Visual Lab">Bubble Sort Visual Lab</h1>
      <p class="subtitle">Learn bubble sort via adjacent comparisons, swaps, and passesâ€”with real-time narration and animation.</p>
    </header>

    <div class="main" role="main">
      <!-- Visualization Card -->
      <section class="viz-card" aria-labelledby="viz-title">
        <div class="viz-header">
          <h2 id="viz-title" style="margin:0; font-size:1.2rem;">Visualization</h2>
          <div class="legend" aria-label="legend">
            <div class="legend-item"><i style="background: var(--bar);"></i>Value</div>
            <div class="legend-item"><i style="background: var(--bar-compare);"></i>Comparing</div>
            <div class="legend-item"><i style="background: var(--bar-swap);"></i>Swapped</div>
            <div class="legend-item"><i style="background: var(--bar-settled);"></i>Settled</div>
          </div>
        </div>

        <div class="viz" id="viz" aria-live="polite" aria-label="Bubble sort bars area">
          <div class="bars" id="bars"></div>
          <div class="pointer" id="pointer" aria-hidden="true">
            <div class="brace"></div>
            <div class="label">Comparing j & j+1</div>
          </div>
        </div>
      </section>

      <!-- Controls and Narration -->
      <aside class="control-card" aria-labelledby="controls-title">
        <h2 id="controls-title" style="margin:0 0 8px 0; font-size:1.2rem;">Controls</h2>
        <div class="controls">

          <!-- Data Setup -->
          <div>
            <div class="group-title">Data</div>
            <div class="row" role="group" aria-label="Array input and generation">
              <div class="field" aria-label="Array input field">
                <span class="hint">List (comma-separated):</span>
                <input id="arrayInput" type="text" placeholder="e.g., 5, 1, 4, 2, 8">
                <button id="applyInputBtn" class="primary" aria-label="Apply array">Apply</button>
              </div>
              <div class="row">
                <label class="field" for="sizeSlider" aria-label="Size slider">
                  <span class="hint">Size</span>
                  <input id="sizeSlider" type="range" min="5" max="30" value="12" />
                  <span id="sizeVal" class="hint">12</span>
                </label>
                <label class="field" for="patternSelect" aria-label="Pattern select">
                  <span class="hint">Pattern</span>
                  <select id="patternSelect">
                    <option value="random">Random</option>
                    <option value="nearly">Nearly Sorted</option>
                    <option value="reversed">Reversed</option>
                  </select>
                </label>
                <label class="field" for="dupToggle" aria-label="Duplicates toggle">
                  <input id="dupToggle" type="checkbox" />
                  <span class="hint">Allow duplicates</span>
                </label>
                <button id="shuffleBtn" class="warning" aria-label="Shuffle array">Shuffle</button>
                <button id="resetBtn" class="muted" aria-label="Reset array">Reset</button>
              </div>
            </div>
          </div>

          <!-- Sorting Controls -->
          <div>
            <div class="group-title">Sorting</div>
            <div class="row" role="group" aria-label="Sorting controls">
              <button id="stepBtn" class="primary" aria-label="Step">Step</button>
              <button id="playBtn" class="success" aria-label="Play or Pause">Play</button>
              <label class="field" for="speedSlider" aria-label="Speed slider">
                <span class="hint">Speed</span>
                <input id="speedSlider" type="range" min="150" max="1200" value="450" />
                <span id="speedVal" class="hint">450 ms</span>
              </label>
              <label class="field" for="earlyToggle" aria-label="Early exit toggle">
                <input id="earlyToggle" type="checkbox" checked />
                <span class="hint">Early exit (stop when no swaps in a pass)</span>
              </label>
            </div>
          </div>

          <!-- Narration and Stats -->
          <div class="narration" aria-live="polite">
            <div class="line" id="narrationMain">Ready. Enter data or press Shuffle to begin.</div>
            <div class="sub" id="narrationSub">Bubble sort compares adjacent elements and swaps if out of order. Largest element settles at the end each pass.</div>
          </div>

          <div class="stats" role="group" aria-label="Stats">
            <div class="stat">
              <div class="value" id="passesVal">0</div>
              <div class="label">Passes</div>
            </div>
            <div class="stat">
              <div class="value" id="comparisonsVal">0</div>
              <div class="label">Comparisons</div>
            </div>
            <div class="stat">
              <div class="value" id="swapsVal">0</div>
              <div class="label">Swaps</div>
            </div>
          </div>

          <div class="footer-note">
            Tips: Space â†’ Play/Pause, Enter â†’ Step, R â†’ Reset, S â†’ Shuffle. Bubble sort complexity: best-case O(n) with early exit; typical/worst-case O(nÂ²).
          </div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    // Bubble Sort Visual Lab (Vanilla JS)
    // State
    const barsEl = document.getElementById('bars');
    const vizEl = document.getElementById('viz');
    const pointerEl = document.getElementById('pointer');

    const arrayInput = document.getElementById('arrayInput');
    const applyInputBtn = document.getElementById('applyInputBtn');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeVal = document.getElementById('sizeVal');
    const patternSelect = document.getElementById('patternSelect');
    const dupToggle = document.getElementById('dupToggle');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const stepBtn = document.getElementById('stepBtn');
    const playBtn = document.getElementById('playBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedVal = document.getElementById('speedVal');
    const earlyToggle = document.getElementById('earlyToggle');

    const narrationMain = document.getElementById('narrationMain');
    const narrationSub = document.getElementById('narrationSub');
    const passesVal = document.getElementById('passesVal');
    const comparisonsVal = document.getElementById('comparisonsVal');
    const swapsVal = document.getElementById('swapsVal');

    let initialArray = [];
    let array = [];
    let bars = []; // DOM elements referencing array positions
    let playing = false;
    let autoplayTimer = null;
    let speedMs = parseInt(speedSlider.value, 10);

    // Bubble sort indices
    let iPass = 0;        // pass index
    let jIndex = 0;       // compare index within pass
    let swappedInPass = false;
    let settledCount = 0; // number of settled items from the end

    // Stats
    let comparisons = 0;
    let swaps = 0;

    // Layout calculation
    function getLayoutMetrics() {
      const rect = barsEl.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const n = array.length;
      const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-gap')) || 8;
      const barWidth = Math.max(12, Math.floor((width - gap * (n - 1)) / n));
      const positions = [];
      for (let k = 0; k < n; k++) {
        const x = k * (barWidth + gap);
        positions.push(x);
      }
      const maxVal = Math.max(...array);
      return { width, height, barWidth, gap, positions, maxVal };
    }

    function renderBars(initial = false) {
      barsEl.innerHTML = '';
      bars = [];
      const { height, barWidth, positions, maxVal } = getLayoutMetrics();

      for (let idx = 0; idx < array.length; idx++) {
        const val = array[idx];
        const h = Math.max(24, Math.round((val / maxVal) * (height - 30))); // leave room for label
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.width = barWidth + 'px';
        bar.style.height = h + 'px';
        bar.style.transform = `translateX(${positions[idx]}px)`;
        bar.setAttribute('role', 'img');
        bar.setAttribute('aria-label', `Value ${val} at position ${idx}`);

        const label = document.createElement('div');
        label.className = 'bar-label';
        label.textContent = String(val);

        bar.appendChild(label);
        barsEl.appendChild(bar);
        bars.push(bar);
      }
      updatePointerPosition();
      if (initial) {
        narrationMain.textContent = 'Ready. Enter data or press Shuffle to begin.';
        narrationSub.textContent = 'Bubble sort compares adjacent elements and swaps if out of order. Largest element settles at the end each pass.';
      }
    }

    function updateBarPositions(animated = true) {
      const { barWidth, positions, maxVal, height } = getLayoutMetrics();
      bars.forEach((bar, idx) => {
        const val = array[idx];
        const h = Math.max(24, Math.round((val / maxVal) * (height - 30)));
        bar.style.width = barWidth + 'px';
        bar.style.height = h + 'px';
        const transform = `translateX(${positions[idx]}px)`;
        if (animated) {
          bar.style.transform = transform;
        } else {
          bar.style.transition = 'none';
          bar.style.transform = transform;
          // force reflow then restore transition
          void bar.offsetWidth;
          bar.style.transition = '';
        }
      });
      updatePointerPosition();
    }

    function updatePointerPosition() {
      if (array.length < 2) {
        pointerEl.style.transform = 'translateX(0px)';
        return;
      }
      const { barWidth, gap, positions } = getLayoutMetrics();
      const j = Math.min(jIndex, array.length - 2 - settledCount);
      const leftX = positions[j];
      const rightX = positions[j + 1];
      const centerX = (leftX + rightX + barWidth) / 2;
      pointerEl.style.transform = `translateX(${centerX - 40}px)`; // center brace (80px wide)
    }

    function setAnimationSpeed(ms) {
      speedMs = ms;
      document.documentElement.style.setProperty('--anim-duration', `${ms}ms`);
      speedVal.textContent = `${ms} ms`;
    }

    function setStats() {
      passesVal.textContent = String(iPass);
      comparisonsVal.textContent = String(comparisons);
      swapsVal.textContent = String(swaps);
    }

    function clearHighlights() {
      bars.forEach(bar => {
        bar.classList.remove('comparing', 'swapped');
      });
    }

    function markSettled() {
      const idx = array.length - 1 - settledCount;
      if (idx >= 0) {
        bars[idx].classList.add('settled');
      }
    }

    function unmarkAllSettled() {
      bars.forEach(bar => bar.classList.remove('settled'));
    }

    function resetSortState() {
      iPass = 0;
      jIndex = 0;
      swappedInPass = false;
      settledCount = 0;
      comparisons = 0;
      swaps = 0;
      setStats();
      clearHighlights();
      unmarkAllSettled();
      narrationMain.textContent = 'Reset. Press Step or Play to start bubble sort.';
      narrationSub.textContent = 'Pass 0: start at j = 0. Compare adjacent elements and swap if needed.';
      updatePointerPosition();
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateArray(size, pattern, allowDuplicates) {
      let arr = [];
      const maxVal = Math.max(10, size * 5);
      const set = new Set();
      for (let i = 0; i < size; i++) {
        let v = randomInt(1, maxVal);
        if (!allowDuplicates) {
          while (set.has(v)) v = randomInt(1, maxVal);
          set.add(v);
        }
        arr.push(v);
      }
      if (pattern === 'nearly') {
        arr.sort((a, b) => a - b);
        const swaps = Math.max(1, Math.floor(size / 6));
        for (let s = 0; s < swaps; s++) {
          const a = randomInt(0, size - 2);
          const b = a + 1;
          [arr[a], arr[b]] = [arr[b], arr[a]];
        }
      } else if (pattern === 'reversed') {
        arr.sort((a, b) => b - a);
      }
      return arr;
    }

    function applyArrayInput() {
      const text = arrayInput.value.trim();
      if (!text) {
        narrationMain.textContent = 'Input is empty. Provide comma-separated integers.';
        narrationSub.textContent = 'Example: 5, 1, 4, 2, 8';
        return;
      }
      const parts = text.split(',').map(s => s.trim()).filter(s => s.length > 0);
      const parsed = [];
      for (let p of parts) {
        const num = parseInt(p, 10);
        if (isNaN(num)) {
          narrationMain.textContent = `Invalid entry "${p}". Only integers are allowed.`;
          narrationSub.textContent = 'Try: 3, 9, 1, 4';
          return;
        }
        const bounded = Math.max(1, Math.min(999, num));
        parsed.push(bounded);
      }
      initialArray = parsed.slice();
      array = parsed.slice();
      resetSortState();
      renderBars();
    }

    function shuffleCurrent() {
      if (array.length === 0) {
        narrationMain.textContent = 'No data yet. Use the controls to create an array.';
        return;
      }
      const arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      initialArray = arr.slice();
      array = arr.slice();
      resetSortState();
      renderBars();
      narrationMain.textContent = 'Shuffled array. Largest elements will bubble to the end each pass.';
      narrationSub.textContent = 'Step or Play to begin.';
    }

    function resetToInitial() {
      if (initialArray.length === 0) {
        narrationMain.textContent = 'Nothing to reset. Generate or apply an array first.';
        return;
      }
      array = initialArray.slice();
      resetSortState();
      renderBars();
    }

    function isSorted(arr = array) {
      for (let k = 0; k < arr.length - 1; k++) {
        if (arr[k] > arr[k + 1]) return false;
      }
      return true;
    }

    function endIfSorted() {
      if (isSorted()) {
        playing = false;
        playBtn.textContent = 'Play';
        narrationMain.textContent = 'Sorted! Bubble sort complete.';
        narrationSub.textContent = `Passes: ${iPass}, Comparisons: ${comparisons}, Swaps: ${swaps}.`;
        clearHighlights();
        unmarkAllSettled();
        // mark all as settled for visual completeness
        bars.forEach(bar => bar.classList.add('settled'));
        stopAutoplay();
        return true;
      }
      return false;
    }

    function stepOnce() {
      if (array.length < 2) return;

      // If end of pass reached, evaluate early-exit and setup new pass
      const lastCompareIndex = array.length - 2 - settledCount;
      if (jIndex > lastCompareIndex) {
        // End of current pass
        markSettled();
        settledCount += 1;
        iPass += 1;
        setStats();

        if (!swappedInPass && earlyToggle.checked) {
          narrationMain.textContent = `End of pass ${iPass}: no swaps â†’ early exit (already sorted).`;
          narrationSub.textContent = 'Optimization stops bubble sort when a pass performs no swaps.';
          endIfSorted();
          return;
        } else {
          narrationMain.textContent = `End of pass ${iPass}. The largest remaining element has settled at the end.`;
          narrationSub.textContent = 'Starting next pass from j = 0.';
        }
        swappedInPass = false;
        jIndex = 0;

        if (endIfSorted()) return;
      }

      // Compare adjacent elements
      const j = jIndex;
      const a = array[j];
      const b = array[j + 1];
      clearHighlights();
      bars[j].classList.add('comparing');
      bars[j + 1].classList.add('comparing');
      updatePointerPosition();

      comparisons += 1;
      setStats();

      if (a > b) {
        narrationMain.textContent = `Comparing ${a} and ${b} â†’ swap (since ${a} > ${b}).`;
        narrationSub.textContent = 'Bubble sort swaps adjacent out-of-order elements.';
        swaps += 1;
        setStats();

        // Perform swap in data
        [array[j], array[j + 1]] = [array[j + 1], array[j]];

        // Animate swap by updating positions
        bars[j].classList.remove('comparing'); // will shift index after swap
        bars[j + 1].classList.remove('comparing');

        // Swap DOM references to keep them mapped to data indices
        [bars[j], bars[j + 1]] = [bars[j + 1], bars[j]];
        bars[j].classList.add('swapped');
        bars[j + 1].classList.add('swapped');

        updateBarPositions(true);
        swappedInPass = true;
      } else {
        narrationMain.textContent = `Comparing ${a} and ${b} â†’ keep (since ${a} â‰¤ ${b}).`;
        narrationSub.textContent = 'No swap, move to the next adjacent pair.';
      }

      jIndex += 1;

      // If everything is sorted, allow graceful completion
      if (settledCount === array.length - 1) {
        endIfSorted();
      }
    }

    function startAutoplay() {
      stopAutoplay(); // ensure no duplicate timers
      playing = true;
      playBtn.textContent = 'Pause';
      const tick = () => {
        stepOnce();
        if (playing) {
          autoplayTimer = setTimeout(tick, speedMs + 60);
        }
      };
      autoplayTimer = setTimeout(tick, 80);
    }

    function stopAutoplay() {
      playing = false;
      playBtn.textContent = 'Play';
      if (autoplayTimer) {
        clearTimeout(autoplayTimer);
        autoplayTimer = null;
      }
    }

    // Event wiring
    applyInputBtn.addEventListener('click', applyArrayInput);
    arrayInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        applyArrayInput();
      }
    });

    sizeSlider.addEventListener('input', () => {
      sizeVal.textContent = sizeSlider.value;
    });
    patternSelect.addEventListener('change', () => {
      // No immediate render; used by Shuffle
    });

    shuffleBtn.addEventListener('click', () => {
      const newArr = generateArray(parseInt(sizeSlider.value, 10), patternSelect.value, dupToggle.checked);
      initialArray = newArr.slice();
      array = newArr.slice();
      resetSortState();
      renderBars();
      narrationMain.textContent = 'New array generated.';
      narrationSub.textContent = 'Press Step to observe adjacent comparisons and swaps.';
    });

    resetBtn.addEventListener('click', resetToInitial);

    stepBtn.addEventListener('click', () => {
      stopAutoplay(); // ensure step is discrete
      stepOnce();
    });

    playBtn.addEventListener('click', () => {
      if (playing) stopAutoplay(); else startAutoplay();
    });

    speedSlider.addEventListener('input', () => {
      setAnimationSpeed(parseInt(speedSlider.value, 10));
    });

    window.addEventListener('resize', () => {
      updateBarPositions(false);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        resetToInitial();
      } else if (e.key.toLowerCase() === 's') {
        shuffleBtn.click();
      } else if (e.key === ' ') {
        e.preventDefault();
        playBtn.click();
      } else if (e.key === 'Enter') {
        stepBtn.click();
      }
    });

    // Initialize
    (function init() {
      setAnimationSpeed(speedMs);
      initialArray = generateArray(parseInt(sizeSlider.value, 10), 'random', false);
      array = initialArray.slice();
      renderBars(true);
      resetSortState();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Bubble Sort Visual Lab",
  "description": "Finite state machine for an interactive bubble sort visualization with data setup, step-by-step and autoplay sorting, visual states (comparing/swapping/settled), stats, and completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "init_app",
      "on": {
        "INIT": "idle"
      }
    },
    {
      "name": "idle",
      "on": {
        "APPLY_INPUT_CLICK": "applying_input",
        "ARRAY_INPUT_ENTER": "applying_input",
        "SHUFFLE_CLICK": "generating",
        "KEY_S": "generating",
        "RESET_CLICK": "resetting",
        "KEY_R": "resetting",
        "STEP_CLICK": "pass_check",
        "KEY_ENTER": "pass_check",
        "PLAY_CLICK": "playing",
        "KEY_SPACE": "playing",
        "SPEED_CHANGE": "idle",
        "SIZE_CHANGE": "idle",
        "PATTERN_CHANGE": "idle",
        "DUP_TOGGLE_CHANGE": "idle",
        "RESIZE": "idle"
      }
    },
    {
      "name": "applying_input",
      "onEnter": "apply_input_array",
      "on": {
        "INPUT_INVALID": "input_error",
        "INPUT_APPLIED": "idle"
      }
    },
    {
      "name": "input_error",
      "onEnter": "show_input_error",
      "on": {
        "APPLY_INPUT_CLICK": "applying_input",
        "ARRAY_INPUT_ENTER": "applying_input",
        "SHUFFLE_CLICK": "generating",
        "KEY_S": "generating",
        "RESET_CLICK": "resetting",
        "KEY_R": "resetting"
      }
    },
    {
      "name": "generating",
      "onEnter": "generate_and_render_array",
      "on": {
        "DATA_READY": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "reset_to_initial_and_render",
      "on": {
        "DATA_READY": "idle",
        "RESET_NO_DATA": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_autoplay",
      "onExit": "stop_autoplay",
      "on": {
        "PLAY_CLICK": "idle",
        "KEY_SPACE": "idle",
        "AUTOPLAY_TICK": "pass_check",
        "STEP_CLICK": "pass_check",
        "KEY_ENTER": "pass_check",
        "RESET_CLICK": "resetting",
        "KEY_R": "resetting",
        "SHUFFLE_CLICK": "generating",
        "KEY_S": "generating",
        "APPLY_INPUT_CLICK": "applying_input",
        "ARRAY_INPUT_ENTER": "applying_input",
        "SPEED_CHANGE": "playing",
        "RESIZE": "playing"
      }
    },
    {
      "name": "pass_check",
      "onEnter": "check_pass_boundary",
      "on": {
        "ARRAY_SORTED": "done",
        "PASS_ENDED_AND_EARLY_EXIT": "early_exit",
        "PASS_ENDED_CONTINUE": "comparing",
        "PASS_NOT_ENDED": "comparing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_comparison_and_update_stats",
      "on": {
        "NEEDS_SWAP": "swapping",
        "NO_SWAP": "step_finalize"
      }
    },
    {
      "name": "swapping",
      "onEnter": "perform_swap_and_update",
      "on": {
        "SWAP_DONE": "step_finalize"
      }
    },
    {
      "name": "step_finalize",
      "onEnter": "increment_index_and_check_complete",
      "on": {
        "ARRAY_SORTED": "done",
        "STEP_CONTINUE_AUTOPLAY": "playing",
        "STEP_CONTINUE_PAUSED": "idle"
      }
    },
    {
      "name": "early_exit",
      "onEnter": "early_exit_and_finalize",
      "on": {
        "NEXT": "done"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sorted",
      "on": {
        "APPLY_INPUT_CLICK": "applying_input",
        "ARRAY_INPUT_ENTER": "applying_input",
        "SHUFFLE_CLICK": "generating",
        "KEY_S": "generating",
        "RESET_CLICK": "resetting",
        "KEY_R": "resetting",
        "PLAY_CLICK": "playing",
        "KEY_SPACE": "playing",
        "STEP_CLICK": "pass_check",
        "KEY_ENTER": "pass_check"
      }
    }
  ],
  "events": [
    "INIT",
    "APPLY_INPUT_CLICK",
    "ARRAY_INPUT_ENTER",
    "INPUT_INVALID",
    "INPUT_APPLIED",
    "SHUFFLE_CLICK",
    "KEY_S",
    "RESET_CLICK",
    "KEY_R",
    "STEP_CLICK",
    "KEY_ENTER",
    "PLAY_CLICK",
    "KEY_SPACE",
    "AUTOPLAY_TICK",
    "SPEED_CHANGE",
    "SIZE_CHANGE",
    "PATTERN_CHANGE",
    "DUP_TOGGLE_CHANGE",
    "RESIZE",
    "PASS_ENDED_AND_EARLY_EXIT",
    "PASS_ENDED_CONTINUE",
    "PASS_NOT_ENDED",
    "NEEDS_SWAP",
    "NO_SWAP",
    "SWAP_DONE",
    "STEP_CONTINUE_AUTOPLAY",
    "STEP_CONTINUE_PAUSED",
    "ARRAY_SORTED",
    "DATA_READY",
    "RESET_NO_DATA",
    "NEXT"
  ],
  "notes": "Implementation mapping and details: 1) init_app: called at boot; mirrors init(): setAnimationSpeed(speedMs), initialArray = generateArray(sizeSlider.value, 'random', false), array copy, renderBars(true), resetSortState(). Transition to idle occurs immediately. 2) apply_input_array: mirrors applyArrayInput(); parses arrayInput, validates ints; on invalid -> INPUT_INVALID (narrationMain shows error); on success -> array and initialArray updated, resetSortState(), renderBars(), then INPUT_APPLIED. 3) generate_and_render_array: mirrors shuffleBtn click handler; uses sizeSlider, patternSelect, dupToggle; sets initialArray/array, resetSortState(), renderBars(); sets narration; then DATA_READY. 4) reset_to_initial_and_render: mirrors resetToInitial(); if initialArray empty -> RESET_NO_DATA (shows narration); else set array to initialArray, resetSortState(), renderBars(); then DATA_READY. 5) playing mode: start_autoplay calls startAutoplay(); schedules repeated AUTOPLAY_TICK events that trigger a single sort step; stop_autoplay cancels timer and sets play button to 'Play'. Spacebar toggles play/pause; Enter triggers single step. 6) pass_check/check_pass_boundary: corresponds to the 'end of pass' block at the start of stepOnce(); if jIndex > lastCompareIndex: markSettled(), settledCount++, iPass++, setStats(); if (!swappedInPass && earlyToggle.checked) -> PASS_ENDED_AND_EARLY_EXIT; else swappedInPass=false; jIndex=0; if endIfSorted() then ARRAY_SORTED; otherwise PASS_ENDED_CONTINUE. If not end of pass -> PASS_NOT_ENDED. Note: In the real code, pass-end handling happens within stepOnce and then proceeds to comparison in the same step if not early-exiting. Modeling it as a separate state clarifies the flow. 7) comparing/highlight_comparison_and_update_stats: mirrors the comparison part of stepOnce(): clearHighlights(); add 'comparing' to bars[j] and bars[j+1]; updatePointerPosition(); comparisons++ and setStats(); if array[j] > array[j+1] -> NEEDS_SWAP else NO_SWAP. 8) swapping/perform_swap_and_update: mirrors swap path in stepOnce(): narration for swap, swaps++, setStats(); swap data array values; remove 'comparing' from the two bars; swap DOM bar references; add 'swapped' classes; updateBarPositions(true); set swappedInPass=true; then SWAP_DONE. 9) step_finalize/increment_index_and_check_complete: mirrors the tail of stepOnce(): jIndex += 1; if (settledCount === array.length - 1) -> ARRAY_SORTED (endIfSorted()); else transition either STEP_CONTINUE_AUTOPLAY (if the step was triggered by AUTOPLAY_TICK and playing remains true) or STEP_CONTINUE_PAUSED (if triggered by STEP_CLICK). In code, this routing depends on the 'playing' boolean; represent as two events. 10) early_exit_and_finalize: shows narration about early exit and calls endIfSorted(); then NEXT to done. 11) finalize_sorted: mirrors endIfSorted(): playing=false, playBtn 'Play', narration indicates completion and stats, clearHighlights(), unmarkAllSettled(), add 'settled' to all bars, stopAutoplay(). 12) Visual states: 'comparing' and 'swapped' are realized via CSS classes on bars; 'settled' marks end-of-pass and final completion. clearHighlights() removes 'comparing' and 'swapped' at the start of the next comparison step. 13) Controls: speed slider emits SPEED_CHANGE (setAnimationSpeed and CSS --anim-duration); size/pattern/duplicates do not change data until SHUFFLE_CLICK; RESIZE triggers updateBarPositions(false) without a state change. 14) Keyboard shortcuts: Space -> PLAY_CLICK; Enter in array input -> ARRAY_INPUT_ENTER (apply input); Enter globally -> STEP_CLICK; R -> RESET_CLICK; S -> SHUFFLE_CLICK. 15) Pointer follows jIndex via updatePointerPosition() each render/update. 16) The FSM models micro-phases of a single step; in the real code these occur within one function call (stepOnce) and the visible end-of-step state is either comparing or swapped. The transitions STEP_CONTINUE_AUTOPLAY vs STEP_CONTINUE_PAUSED depend on the 'playing' flag at the time of the step."
}
  </script>
</body>
</html>