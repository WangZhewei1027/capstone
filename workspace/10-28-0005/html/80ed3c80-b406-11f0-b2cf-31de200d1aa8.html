<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort: Adjacent Swaps in Action</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #0f1320;
      --panel: #151a2b;
      --panel-2: #10162a;
      --text: #e7ecf3;
      --muted: #a8b3c7;
      --accent: #4cc9f0;
      --accent-2: #f72585;
      --good: #4ade80;
      --warn: #fbbf24;
      --bad: #ef4444;
      --focus: #93c5fd;
      --gap: 16px;
      --safe: 24px;
      --bar: #7c3aed;
      --bar-muted: #5b21b6;
      --bar-compare: #f59e0b;
      --bar-sorted: #10b981;
      --bar-locked: #0ea5e9;
      --anim-ms: 420ms;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      background: radial-gradient(1200px 800px at 20% -10%, #1a2037 0%, #0f1320 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.45;
    }
    .page{
      padding: var(--safe);
      max-width: 1200px;
      margin: 0 auto;
    }
    h1, h2, h3{
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    p{ margin: 0 0 10px; color: var(--muted); }
    .tag{
      display: inline-block;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
      background: #1f2541;
      color: var(--muted);
      margin-right: 8px;
    }
    .grid{
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 24px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent 60%) , var(--panel);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
    }
    .panel-title{
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .viz-wrap{
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .viz{
      position: relative;
      height: 300px;
      border-radius: 12px;
      background: linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02)), var(--panel-2);
      border: 1px solid rgba(255,255,255,0.06);
      overflow: hidden;
    }
    .axis{
      position: absolute;
      left: 0; right: 0; bottom: 32px;
      height: 2px;
      background: rgba(255,255,255,0.08);
    }
    .bar{
      position: absolute;
      bottom: 34px;
      width: 40px;
      background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(0,0,0,0.1)), var(--bar);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px 6px 0 0;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      transition: left var(--anim-ms) ease, height var(--anim-ms) ease, background-color 200ms ease, transform 150ms ease;
      outline: none;
    }
    .bar:focus-visible{
      box-shadow: 0 0 0 3px var(--focus), 0 6px 16px rgba(0,0,0,0.35);
    }
    .bar .value{
      position: absolute;
      bottom: -28px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text);
      font-size: 12px;
      background: rgba(0,0,0,0.35);
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .bar.compare{
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.08)), var(--bar-compare);
      outline: 2px dashed rgba(255,255,255,0.2);
      outline-offset: -3px;
    }
    .bar.swap{
      animation: pulse 420ms ease;
    }
    @keyframes pulse{
      0% { transform: translateY(0) scale(1); }
      50%{ transform: translateY(-6px) scale(1.02); }
      100%{ transform: translateY(0) scale(1); }
    }
    .bar.locked{
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.08)), var(--bar-locked);
    }
    .bar.sorted{
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.08)), var(--bar-sorted);
    }
    .legend{
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      color: var(--muted);
      font-size: 12px;
    }
    .legend .dot{
      width: 12px; height: 12px; border-radius: 3px; display: inline-block; margin-right: 6px;
    }
    .stats{
      display: grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap: 12px;
      font-size: 13px;
      color: var(--muted);
    }
    @media (max-width: 520px){
      .stats { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    .stat{
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 8px 10px;
      border-radius: 10px;
    }
    .controls{
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .row{
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }
    .row.cols-2{ grid-template-columns: 1fr 1fr; }
    .row.cols-3{ grid-template-columns: 1fr 1fr 1fr; }
    .row.inline{
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
    }
    label{ font-size: 13px; color: var(--muted); display: block; margin-bottom: 6px; }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    input[type="text"], input[type="number"]{
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.08);
      color: var(--text);
    }
    fieldset{
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px 12px;
      min-width: 0;
    }
    fieldset legend{ font-size: 12px; color: var(--muted); padding: 0 6px; }
    .opt{ display: flex; align-items: center; gap: 10px; }
    .opt input{ accent-color: var(--accent); }
    button{
      background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(0,0,0,0.15));
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 80ms ease, background-color 120ms ease, border-color 120ms ease;
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0); }
    button:disabled{ opacity: 0.5; cursor: not-allowed; }
    .btn-primary{
      background: linear-gradient(180deg, rgba(76,201,240,0.25), rgba(15,19,32,0.2));
      border-color: rgba(76,201,240,0.5);
    }
    .btn-danger{
      background: linear-gradient(180deg, rgba(247,37,133,0.25), rgba(15,19,32,0.2));
      border-color: rgba(247,37,133,0.5);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(255,255,255,0.06);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
    }
    .code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      color: #e8f1ff;
      font-size: 13px;
    }
    .pseudo{
      list-style: decimal inside;
      margin: 0; padding: 8px 12px;
      display: grid;
      gap: 6px;
    }
    .pseudo li{
      padding: 6px 8px;
      border-radius: 8px;
    }
    .pseudo li.active{
      background: rgba(76,201,240,0.15);
      border: 1px solid rgba(76,201,240,0.4);
    }
    .announce{
      position: absolute;
      left: -9999px;
      width: 1px; height: 1px; overflow: hidden;
    }
    .note{ color: var(--muted); font-size: 12px; }
    .section{
      margin-top: 24px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 16px;
    }
    details{ border-radius: 10px; }
    details summary{
      cursor: pointer;
      padding: 8px 0;
      color: var(--text);
      font-weight: 600;
    }
    .sr-only{
      position: absolute; width: 1px; height: 1px; padding:0; margin:-1px; overflow: hidden; clip: rect(0,0,0,0); border:0;
    }
    @media (prefers-reduced-motion: reduce){
      .bar{ transition: none !important; }
      .bar.swap{ animation: none !important; }
    }
  </style>
</head>
<body>
  <div class="page" aria-describedby="page-desc">
    <header style="margin-bottom: 16px;">
      <div class="tag">Interactive Module</div>
      <h1 id="concept-title">Bubble Sort: Adjacent Swaps in Action</h1>
      <p id="page-desc">Experiment with Bubble Sort by comparing and swapping adjacent bars. Step through the algorithm, watch animated swaps, and observe early exit optimization.</p>
    </header>

    <div class="grid">
      <!-- Visualization + Stats -->
      <section class="panel viz-wrap" aria-labelledby="viz-title">
        <div class="panel-title">
          <h2 id="viz-title">Array Visualization</h2>
          <div class="legend" aria-label="Legend">
            <span><span class="dot" style="background: var(--bar);"></span>unsorted</span>
            <span><span class="dot" style="background: var(--bar-compare);"></span>comparing</span>
            <span><span class="dot" style="background: var(--bar-locked);"></span>end-of-pass locked</span>
            <span><span class="dot" style="background: var(--bar-sorted);"></span>fully sorted</span>
          </div>
        </div>
        <div class="viz" id="viz" role="application" aria-label="Bubble sort visualization" tabindex="0">
          <div class="axis"></div>
          <div id="aria" class="announce" role="status" aria-live="polite"></div>
        </div>
        <div class="stats" aria-label="Statistics">
          <div class="stat"><strong>Pass</strong><div id="stat-pass">0</div></div>
          <div class="stat"><strong>i</strong><div id="stat-i">0</div></div>
          <div class="stat"><strong>j</strong><div id="stat-j">0</div></div>
          <div class="stat"><strong>Comparisons</strong><div id="stat-comp">0</div></div>
          <div class="stat"><strong>Swaps</strong><div id="stat-swaps">0</div></div>
        </div>
        <div class="panel" style="padding:12px;">
          <div class="panel-title">
            <h3 style="font-size: 16px;">Pseudocode</h3>
            <span class="note">Highlighted line = current step</span>
          </div>
          <div class="code">
            <ol class="pseudo" id="pseudo">
              <li data-line="1">for i = 0 to n - 1:</li>
              <li data-line="2">  swapped = false</li>
              <li data-line="3">  for j = 0 to n - 2 - i:</li>
              <li data-line="4">    if needsSwap(a[j], a[j+1]):</li>
              <li data-line="5">      swap(a[j], a[j+1])</li>
              <li data-line="6">      swapped = true</li>
              <li data-line="7">  if earlyExit and swapped == false: break</li>
            </ol>
          </div>
          <p id="explain" style="margin-top:8px;">Load an array and press Play or Step to begin.</p>
        </div>
      </section>

      <!-- Controls -->
      <aside class="panel controls" aria-labelledby="controls-title">
        <h2 id="controls-title" style="margin-bottom: 4px;">Controls</h2>

        <div class="row cols-2" role="group" aria-label="Dataset size">
          <div>
            <label for="sizeRange">Size: <span id="sizeLabel">8</span></label>
            <input id="sizeRange" type="range" min="3" max="20" step="1" value="8" aria-describedby="sizeHelp" />
            <div id="sizeHelp" class="note">Choose number of elements (3–20).</div>
          </div>
          <div class="row inline" style="align-items: end;">
            <button id="btnRandom" class="btn-primary" title="Generate random dataset">Random</button>
            <button id="btnReverse" title="Generate reversed dataset">Reversed</button>
            <button id="btnNearly" title="Generate nearly sorted dataset">Nearly Sorted</button>
          </div>
        </div>

        <div class="row" role="group" aria-label="Custom values">
          <div>
            <label for="valuesText">Values (comma-separated 1–99)</label>
            <input id="valuesText" type="text" placeholder="e.g., 5,2,9,1,5,6" />
          </div>
          <div class="row inline">
            <button id="btnLoad" title="Load provided values">Load</button>
            <button id="btnShuffle" title="Shuffle current values">Shuffle</button>
            <button id="btnReset" class="btn-danger" title="Reset algorithm pointers">Reset</button>
          </div>
        </div>

        <div class="row cols-2" role="group" aria-label="Options">
          <fieldset>
            <legend>Order</legend>
            <label class="opt"><input type="radio" name="order" id="ordAsc" value="asc" checked /> Ascending</label>
            <label class="opt"><input type="radio" name="order" id="ordDesc" value="desc" /> Descending</label>
          </fieldset>
          <fieldset>
            <legend>Behavior</legend>
            <label class="opt"><input type="checkbox" id="optEarly" checked /> Early exit optimization</label>
            <label class="opt"><input type="checkbox" id="optInstant" /> Instant compare (no pause before swap)</label>
          </fieldset>
        </div>

        <div class="row cols-2" role="group" aria-label="Playback and speed">
          <div>
            <label for="speedRange">Speed</label>
            <input id="speedRange" type="range" min="0" max="100" value="50" />
            <div class="note">Left = slower steps, Right = faster.</div>
          </div>
          <div class="row inline" style="align-items: end;">
            <button id="btnPlay" class="btn-primary" title="Play or pause (Space)">Play</button>
            <button id="btnStep" title="Step one comparison (S)">Step</button>
            <button id="btnPass" title="Complete one full pass">Step Pass</button>
          </div>
        </div>

        <div class="panel" style="padding:12px;">
          <h3 style="font-size: 16px; margin-bottom: 8px;">Keyboard</h3>
          <p class="note">
            <span class="kbd">Space</span> Play/Pause
            • <span class="kbd">S</span> Step
            • <span class="kbd">R</span> Reset
            • <span class="kbd">G</span> Random
            • <span class="kbd">D</span> Toggle order
            • <span class="kbd">O</span> Toggle early exit
          </p>
        </div>

      </aside>
    </div>

    <!-- Learning Objective -->
    <section class="section" aria-labelledby="obj-title">
      <h2 id="obj-title">Learning Objective</h2>
      <ul>
        <li>See how Bubble Sort compares and swaps adjacent elements to move extremes toward the end of the array each pass.</li>
        <li>Understand the role of the outer pass (i), inner index (j), and the early exit optimization when a pass makes no swaps.</li>
        <li>Relate animated actions to pseudocode lines and key counters (comparisons, swaps).</li>
      </ul>
    </section>

    <!-- Interaction Design -->
    <section class="section" aria-labelledby="interaction-title">
      <h2 id="interaction-title">Interaction Design</h2>
      <ul>
        <li>Click Play to run automatically. Pause any time. Use Step to execute one comparison at a time. Step Pass completes the current pass.</li>
        <li>Bars being compared highlight in amber; if they need swapping, they pulse and slide to new positions.</li>
        <li>At the end of each pass, the last element becomes locked (blue) showing the sorted tail growing from the right. When fully sorted, all bars turn green.</li>
        <li>Adjust speed, order (ascending/descending), and early exit optimization. Load custom values or generate random, reversed, or nearly sorted datasets.</li>
        <li>Pseudocode highlights the current line so users can map actions to code.</li>
      </ul>
    </section>

    <!-- Layout Description -->
    <section class="section" aria-labelledby="layout-title">
      <h2 id="layout-title">Layout Description</h2>
      <ul>
        <li>Safe margins: 24 px around the viewport provided by the page container.</li>
        <li>Two-column layout on wider screens: visualization and stats on the left, controls on the right. On narrow screens, sections stack vertically for focus and clarity.</li>
        <li>Minimum spacing: at least 16 px between interactive elements via consistent grid gaps and inline gaps.</li>
        <li>Accessibility: semantic headings; labeled controls; ARIA live region narrates steps; keyboard shortcuts; visible focus states; respects reduced motion preferences.</li>
      </ul>
    </section>
  </div>

  <script>
    // State
    const viz = document.getElementById('viz');
    const aria = document.getElementById('aria');

    // Stats
    const statPass = document.getElementById('stat-pass');
    const statI = document.getElementById('stat-i');
    const statJ = document.getElementById('stat-j');
    const statComp = document.getElementById('stat-comp');
    const statSwaps = document.getElementById('stat-swaps');

    // Controls
    const sizeRange = document.getElementById('sizeRange');
    const sizeLabel = document.getElementById('sizeLabel');
    const btnRandom = document.getElementById('btnRandom');
    const btnReverse = document.getElementById('btnReverse');
    const btnNearly = document.getElementById('btnNearly');
    const valuesText = document.getElementById('valuesText');
    const btnLoad = document.getElementById('btnLoad');
    const btnShuffle = document.getElementById('btnShuffle');
    const btnReset = document.getElementById('btnReset');

    const ordAsc = document.getElementById('ordAsc');
    const ordDesc = document.getElementById('ordDesc');
    const optEarly = document.getElementById('optEarly');
    const optInstant = document.getElementById('optInstant');

    const speedRange = document.getElementById('speedRange');

    const btnPlay = document.getElementById('btnPlay');
    const btnStep = document.getElementById('btnStep');
    const btnPass = document.getElementById('btnPass');

    const pseudo = document.getElementById('pseudo');
    const explain = document.getElementById('explain');

    // Data + algorithm pointers
    let arr = []; // [{value, el}]
    let iPass = 0, jIndex = 0, comparisons = 0, swaps = 0, passCount = 0;
    let swappedThisPass = false;
    let playing = false;
    let busy = false;
    let done = false;

    // Layout metrics
    function metrics(){
      const n = arr.length;
      const w = viz.clientWidth;
      const insets = 16; // small inset from edges
      const usable = Math.max(0, w - insets * 2);
      const slot = usable / Math.max(1, n);
      const barWidth = Math.max(18, Math.min(44, slot * 0.7));
      const leftOffset = (w - (slot * n)) / 2; // center within viz
      return { n, w, slot, barWidth, leftOffset, height: viz.clientHeight - 60 };
    }

    function computeLeftAt(idx){
      const m = metrics();
      return m.leftOffset + idx * m.slot + (m.slot - m.barWidth) / 2;
    }

    function updateBarPositions(animate = true){
      const m = metrics();
      if(!animate){
        arr.forEach(b => b.el.style.transition = 'none');
      }
      arr.forEach((b, idx) => {
        b.el.style.width = `${m.barWidth}px`;
        b.el.style.left = `${computeLeftAt(idx)}px`;
        const maxVal = Math.max(...arr.map(x => x.value), 1);
        const h = Math.max(8, Math.round((b.value / maxVal) * m.height));
        b.el.style.height = `${h}px`;
        b.el.style.setProperty('--anim-ms', getAnimMS() + 'ms');
      });
      if(!animate){
        requestAnimationFrame(() => {
          arr.forEach(b => b.el.style.transition = '');
        });
      }
    }

    function clearBars(){
      [...viz.querySelectorAll('.bar')].forEach(b => b.remove());
    }

    function createBars(values){
      clearBars();
      arr = values.map(v => {
        const el = document.createElement('div');
        el.className = 'bar';
        el.tabIndex = 0;
        el.setAttribute('role', 'button');
        el.setAttribute('title', 'Click to edit value');
        el.addEventListener('click', () => editValueInline(el));
        const label = document.createElement('div');
        label.className = 'value';
        label.textContent = String(v);
        el.appendChild(label);
        viz.appendChild(el);
        return { value: v, el };
      });
      updateBarPositions(false);
      announce('Array loaded with ' + arr.length + ' elements.');
    }

    function editValueInline(el){
      if(busy) return;
      const idx = arr.findIndex(x => x.el === el);
      if(idx < 0) return;
      const curr = arr[idx].value;
      const input = document.createElement('input');
      input.type = 'number';
      input.min = '1'; input.max = '99';
      input.value = curr;
      input.className = 'value';
      input.style.background = '#0b1224';
      input.style.color = 'white';
      input.style.border = '1px solid rgba(255,255,255,0.2)';
      input.style.width = '44px';
      input.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){ input.blur(); }
        if(e.key === 'Escape'){ cancel(); }
      });
      input.addEventListener('blur', () => {
        const v = parseInt(input.value, 10);
        if(Number.isFinite(v) && v >= 1 && v <= 99){
          arr[idx].value = v;
          arr[idx].el.querySelector('.value').textContent = String(v);
          updateBarPositions(true);
        }
        input.replaceWith(makeValueLabel(arr[idx].value));
      });

      function cancel(){
        input.replaceWith(makeValueLabel(curr));
      }
      el.querySelector('.value').replaceWith(input);
      input.focus();
      input.select();
    }

    function makeValueLabel(v){
      const label = document.createElement('div');
      label.className = 'value';
      label.textContent = String(v);
      return label;
    }

    function resetAlgorithm(){
      iPass = 0; jIndex = 0; swappedThisPass = false;
      comparisons = 0; swaps = 0; passCount = 0; done = false;
      arr.forEach(b => b.el.classList.remove('compare', 'swap', 'locked', 'sorted'));
      updateStats();
      setPseudo(1);
      explain.textContent = 'Pointers reset. Press Play or Step to begin.';
    }

    function updateStats(){
      statPass.textContent = String(passCount);
      statI.textContent = String(iPass);
      statJ.textContent = String(jIndex);
      statComp.textContent = String(comparisons);
      statSwaps.textContent = String(swaps);
    }

    function setPseudo(line){
      [...pseudo.children].forEach(li => li.classList.toggle('active', li.getAttribute('data-line') == String(line)));
    }

    function comparator(a, b){
      const desc = ordDesc.checked;
      return desc ? (a < b) : (a > b);
    }

    function highlightCompare(j){
      arr.forEach(b => b.el.classList.remove('compare'));
      if(j >= 0 && j < arr.length - 1){
        arr[j].el.classList.add('compare');
        arr[j+1].el.classList.add('compare');
      }
    }

    function clearCompare(){
      arr.forEach(b => b.el.classList.remove('compare'));
    }

    function lockEndOfPass(){
      // lock the last element of current pass
      const idx = arr.length - 1 - iPass;
      if(idx >= 0 && idx < arr.length){
        arr[idx].el.classList.add('locked');
      }
    }

    function finalizeSorted(){
      arr.forEach(b => {
        b.el.classList.remove('locked', 'compare');
        b.el.classList.add('sorted');
      });
      announce('Array sorted.');
    }

    function getAnimMS(){
      // Map speed slider (0..100) to ms per step (slower to faster)
      const v = parseInt(speedRange.value, 10); // 0 slow .. 100 fast
      const minMs = 120, maxMs = 900;
      const ms = Math.round(maxMs - (v / 100) * (maxMs - minMs));
      return ms;
    }

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    async function animateSwap(j){
      // Mark swap visually, set left positions for all (only two will move)
      arr[j].el.classList.add('swap');
      arr[j+1].el.classList.add('swap');

      // Swap logical
      const tmp = arr[j];
      arr[j] = arr[j+1];
      arr[j+1] = tmp;

      // Reposition
      updateBarPositions(true);

      // Wait for transition to complete
      const ms = getAnimMS();
      await sleep(ms + 20);

      arr[j].el.classList.remove('swap');
      arr[j+1].el.classList.remove('swap');
    }

    async function stepOnce(){
      if(busy || done) return;
      busy = true;

      const n = arr.length;
      if(n <= 1){
        busy = false;
        done = true;
        return;
      }
      // Outer loop init lines
      if(jIndex === 0){
        if(iPass === 0 && passCount === 0){
          setPseudo(1);
          explain.textContent = 'Outer loop begins at i = 0.';
        }
        setPseudo(2);
        swappedThisPass = false;
        if(!optInstant.checked) await sleep(80);
      }

      if(jIndex <= n - 2 - iPass){
        setPseudo(3);
        updateStats();
        await sleep(10);

        // Compare a[j] and a[j+1]
        setPseudo(4);
        highlightCompare(jIndex);
        comparisons++;
        updateStats();
        const a = arr[jIndex].value;
        const b = arr[jIndex + 1].value;
        const needsSwap = comparator(a, b);

        explain.textContent = needsSwap
          ? `Compare ${a} and ${b}: swap needed.`
          : `Compare ${a} and ${b}: in correct order.`;
        announce(`Compare positions ${jIndex} and ${jIndex+1}. ${needsSwap ? 'Swap' : 'No swap'}.`);

        if(needsSwap){
          // swap
          setPseudo(5);
          await animateSwap(jIndex);
          swaps++;
          swappedThisPass = true;
          arr[jIndex].el.querySelector('.value').textContent = String(arr[jIndex].value);
          arr[jIndex+1].el.querySelector('.value').textContent = String(arr[jIndex+1].value);
          setPseudo(6);
          updateStats();
        }
        // Move inner index forward
        jIndex++;
        statJ.textContent = String(jIndex);
        clearCompare();

        // End of inner loop?
        if(jIndex > n - 2 - iPass){
          passCount++;
          lockEndOfPass();
          updateStats();

          // Early exit?
          if(optEarly.checked && !swappedThisPass){
            setPseudo(7);
            explain.textContent = 'No swaps this pass; early exit. Array is sorted.';
            done = true;
            finalizeSorted();
            busy = false;
            return;
          }
          // Next pass
          iPass++;
          jIndex = 0;
          explain.textContent = `Pass complete. Next pass i = ${iPass}.`;
          updateStats();

          if(iPass >= n - 1){
            done = true;
            finalizeSorted();
            busy = false;
            return;
          }
        }
      } else {
        // Should not normally hit here due to above handling
        iPass++;
        jIndex = 0;
      }
      busy = false;
      setPseudo(jIndex === 0 ? 2 : 4);
    }

    async function playLoop(){
      if(playing) return; // prevent double loops
      playing = true;
      btnPlay.textContent = 'Pause';
      while(playing && !done){
        await stepOnce();
        if(done) break;
        const ms = getAnimMS();
        await sleep(Math.max(40, ms * (optInstant.checked ? 0.6 : 1)));
      }
      if(done){
        btnPlay.textContent = 'Play';
        playing = false;
      }
    }

    function pause(){
      playing = false;
      btnPlay.textContent = 'Play';
    }

    async function stepPass(){
      if(done) return;
      pause();
      const targetPass = passCount + 1;
      while(!done && passCount < targetPass){
        await stepOnce();
      }
    }

    // Dataset helpers
    function randomArray(n){
      const a = Array.from({length: n}, () => Math.floor(1 + Math.random() * 99));
      return a;
    }
    function reversedArray(n){
      const a = Array.from({length: n}, (_, i) => n - i);
      const scale = 99 / n;
      return a.map(v => Math.max(1, Math.min(99, Math.round(v * scale))));
    }
    function nearlySortedArray(n){
      const base = Array.from({length: n}, (_, i) => Math.round((i+1) * (99/n)));
      // introduce a few random adjacent swaps
      for(let k=0; k<Math.max(1, Math.floor(n/4)); k++){
        const i = Math.floor(Math.random() * (n-1));
        [base[i], base[i+1]] = [base[i+1], base[i]];
      }
      return base;
    }
    function shuffleInPlace(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function loadValuesFromInput(){
      const raw = valuesText.value.trim();
      if(!raw){
        alert('Please enter comma-separated numbers between 1 and 99.');
        return;
      }
      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
      const vals = parts.map(x => parseInt(x, 10));
      if(!vals.length || vals.some(v => !Number.isFinite(v) || v < 1 || v > 99)){
        alert('All values must be integers between 1 and 99.');
        return;
      }
      createBars(vals);
      sizeRange.value = String(vals.length);
      sizeLabel.textContent = String(vals.length);
      resetAlgorithm();
    }

    // Announce to screen readers
    function announce(msg){
      aria.textContent = msg;
    }

    // Event wiring
    sizeRange.addEventListener('input', () => {
      sizeLabel.textContent = sizeRange.value;
    });
    sizeRange.addEventListener('change', () => {
      const n = parseInt(sizeRange.value, 10);
      createBars(randomArray(n));
      resetAlgorithm();
    });
    btnRandom.addEventListener('click', () => {
      createBars(randomArray(parseInt(sizeRange.value, 10)));
      resetAlgorithm();
    });
    btnReverse.addEventListener('click', () => {
      createBars(reversedArray(parseInt(sizeRange.value, 10)));
      resetAlgorithm();
    });
    btnNearly.addEventListener('click', () => {
      createBars(nearlySortedArray(parseInt(sizeRange.value, 10)));
      resetAlgorithm();
    });
    btnLoad.addEventListener('click', loadValuesFromInput);
    btnShuffle.addEventListener('click', () => {
      const vals = arr.map(x => x.value);
      shuffleInPlace(vals);
      createBars(vals);
      resetAlgorithm();
    });
    btnReset.addEventListener('click', () => {
      pause();
      resetAlgorithm();
    });

    btnPlay.addEventListener('click', () => {
      if(playing) { pause(); }
      else { playLoop(); }
    });
    btnStep.addEventListener('click', () => { pause(); stepOnce(); });
    btnPass.addEventListener('click', () => { stepPass(); });

    ordAsc.addEventListener('change', () => { resetAlgorithm(); });
    ordDesc.addEventListener('change', () => { resetAlgorithm(); });
    optEarly.addEventListener('change', () => {
      announce('Early exit ' + (optEarly.checked ? 'enabled' : 'disabled'));
    });
    optInstant.addEventListener('change', () => {
      announce('Instant compare ' + (optInstant.checked ? 'enabled' : 'disabled'));
    });

    speedRange.addEventListener('input', () => {
      const ms = getAnimMS();
      document.documentElement.style.setProperty('--anim-ms', ms + 'ms');
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if(['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
      if(e.key === ' '){
        e.preventDefault();
        if(playing) pause(); else playLoop();
      } else if(e.key.toLowerCase() === 's'){
        e.preventDefault();
        pause(); stepOnce();
      } else if(e.key.toLowerCase() === 'r'){
        e.preventDefault();
        pause(); resetAlgorithm();
      } else if(e.key.toLowerCase() === 'g'){
        e.preventDefault();
        createBars(randomArray(parseInt(sizeRange.value, 10)));
        resetAlgorithm();
      } else if(e.key.toLowerCase() === 'd'){
        e.preventDefault();
        ordDesc.checked = !ordDesc.checked;
        ordAsc.checked = !ordDesc.checked;
        resetAlgorithm();
      } else if(e.key.toLowerCase() === 'o'){
        e.preventDefault();
        optEarly.checked = !optEarly.checked;
        announce('Early exit ' + (optEarly.checked ? 'enabled' : 'disabled'));
      }
    });

    // Resize handling to keep positions correct
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => updateBarPositions(false), 50);
    });

    // Initialize
    function init(){
      const defaultN = parseInt(sizeRange.value, 10);
      createBars(randomArray(defaultN));
      resetAlgorithm();
    }
    init();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a bubble sort visualization app capturing dataset loading, playback (play/pause), single-step and pass-step execution, comparison/swap animations, pass locking, editing values, and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "resetAlgorithm",
      "on": {
        "INIT": "idle",
        "CLICK_PLAY": "playing",
        "KEY_SPACE": "playing",
        "CLICK_STEP": "comparing",
        "KEY_S": "comparing",
        "CLICK_STEP_PASS": "stepping_pass",
        "CLICK_RESET": "resetting",
        "KEY_R": "resetting",
        "SIZE_CHANGE": "loading_dataset",
        "CLICK_RANDOM": "loading_dataset",
        "CLICK_REVERSE": "loading_dataset",
        "CLICK_NEARLY": "loading_dataset",
        "CLICK_LOAD_VALUES": "loading_dataset",
        "CLICK_SHUFFLE": "loading_dataset",
        "CHANGE_ORDER_ASC": "resetting",
        "CHANGE_ORDER_DESC": "resetting",
        "KEY_D_TOGGLE_ORDER": "resetting",
        "TOGGLE_EARLY_EXIT": "idle",
        "KEY_O_TOGGLE_EARLY_EXIT": "idle",
        "TOGGLE_INSTANT_COMPARE": "idle",
        "SPEED_CHANGE": "idle",
        "RESIZE": "idle",
        "CLICK_BAR_EDIT": "editing_value"
      }
    },
    {
      "name": "paused",
      "onEnter": "pause",
      "on": {
        "CLICK_PLAY": "playing",
        "KEY_SPACE": "playing",
        "CLICK_STEP": "comparing",
        "KEY_S": "comparing",
        "CLICK_STEP_PASS": "stepping_pass",
        "CLICK_RESET": "resetting",
        "KEY_R": "resetting",
        "SIZE_CHANGE": "loading_dataset",
        "CLICK_RANDOM": "loading_dataset",
        "CLICK_REVERSE": "loading_dataset",
        "CLICK_NEARLY": "loading_dataset",
        "CLICK_LOAD_VALUES": "loading_dataset",
        "CLICK_SHUFFLE": "loading_dataset",
        "CHANGE_ORDER_ASC": "resetting",
        "CHANGE_ORDER_DESC": "resetting",
        "KEY_D_TOGGLE_ORDER": "resetting",
        "TOGGLE_EARLY_EXIT": "paused",
        "KEY_O_TOGGLE_EARLY_EXIT": "paused",
        "TOGGLE_INSTANT_COMPARE": "paused",
        "SPEED_CHANGE": "paused",
        "RESIZE": "paused",
        "CLICK_BAR_EDIT": "editing_value"
      }
    },
    {
      "name": "playing",
      "onEnter": "playLoop",
      "onExit": "pause",
      "on": {
        "CLICK_PLAY": "paused",
        "KEY_SPACE": "paused",
        "CLICK_STEP": "comparing",
        "KEY_S": "comparing",
        "CLICK_STEP_PASS": "stepping_pass",
        "CLICK_RESET": "resetting",
        "KEY_R": "resetting",
        "SIZE_CHANGE": "loading_dataset",
        "CLICK_RANDOM": "loading_dataset",
        "CLICK_REVERSE": "loading_dataset",
        "CLICK_NEARLY": "loading_dataset",
        "CLICK_LOAD_VALUES": "loading_dataset",
        "CLICK_SHUFFLE": "loading_dataset",
        "CHANGE_ORDER_ASC": "resetting",
        "CHANGE_ORDER_DESC": "resetting",
        "KEY_D_TOGGLE_ORDER": "resetting",
        "TOGGLE_EARLY_EXIT": "playing",
        "KEY_O_TOGGLE_EARLY_EXIT": "playing",
        "TOGGLE_INSTANT_COMPARE": "playing",
        "SPEED_CHANGE": "playing",
        "RESIZE": "playing",
        "ALGORITHM_COMPLETE": "done",
        "CLICK_BAR_EDIT": "editing_value"
      }
    },
    {
      "name": "comparing",
      "onEnter": "setPseudo",
      "onExit": "clearCompare",
      "on": {
        "NEEDS_SWAP": "swapping",
        "NO_SWAP_AUTO_CONTINUE": "playing",
        "NO_SWAP_STEP_COMPLETE": "paused",
        "END_OF_PASS": "pass_locking"
      }
    },
    {
      "name": "swapping",
      "onEnter": "animateSwap",
      "on": {
        "SWAP_ANIMATION_DONE_AUTO": "playing",
        "SWAP_ANIMATION_DONE_STEP": "paused",
        "END_OF_PASS": "pass_locking"
      }
    },
    {
      "name": "pass_locking",
      "onEnter": "lockEndOfPass",
      "on": {
        "EARLY_EXIT_TRIGGERED": "done",
        "ALL_SORTED": "done",
        "NEXT_PASS": "next_pass"
      }
    },
    {
      "name": "next_pass",
      "onEnter": "updateStats",
      "on": {
        "AUTO_CONTINUE": "playing",
        "STEP_COMPLETE": "paused"
      }
    },
    {
      "name": "stepping_pass",
      "onEnter": "stepPass",
      "on": {
        "PASS_COMPLETED": "paused",
        "ALGORITHM_COMPLETE": "done"
      }
    },
    {
      "name": "loading_dataset",
      "onEnter": "createBars",
      "onExit": "resetAlgorithm",
      "on": {
        "LOAD_COMPLETE": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "resetAlgorithm",
      "on": {
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "editing_value",
      "onEnter": "editValueInline",
      "onExit": "updateBarPositions",
      "on": {
        "EDIT_BLUR_COMMIT": "paused",
        "EDIT_ESCAPE_CANCEL": "paused"
      }
    },
    {
      "name": "done",
      "onEnter": "finalizeSorted",
      "on": {
        "CLICK_RESET": "resetting",
        "KEY_R": "resetting",
        "SIZE_CHANGE": "loading_dataset",
        "CLICK_RANDOM": "loading_dataset",
        "CLICK_REVERSE": "loading_dataset",
        "CLICK_NEARLY": "loading_dataset",
        "CLICK_LOAD_VALUES": "loading_dataset",
        "CLICK_SHUFFLE": "loading_dataset",
        "CHANGE_ORDER_ASC": "resetting",
        "CHANGE_ORDER_DESC": "resetting",
        "KEY_D_TOGGLE_ORDER": "resetting",
        "CLICK_PLAY": "done",
        "KEY_SPACE": "done",
        "CLICK_BAR_EDIT": "editing_value",
        "TOGGLE_EARLY_EXIT": "done",
        "KEY_O_TOGGLE_EARLY_EXIT": "done",
        "TOGGLE_INSTANT_COMPARE": "done",
        "SPEED_CHANGE": "done",
        "RESIZE": "done"
      }
    }
  ],
  "events": [
    "INIT",
    "CLICK_PLAY",
    "KEY_SPACE",
    "CLICK_STEP",
    "KEY_S",
    "CLICK_STEP_PASS",
    "CLICK_RESET",
    "KEY_R",
    "SIZE_CHANGE",
    "CLICK_RANDOM",
    "CLICK_REVERSE",
    "CLICK_NEARLY",
    "CLICK_LOAD_VALUES",
    "CLICK_SHUFFLE",
    "CHANGE_ORDER_ASC",
    "CHANGE_ORDER_DESC",
    "KEY_D_TOGGLE_ORDER",
    "TOGGLE_EARLY_EXIT",
    "KEY_O_TOGGLE_EARLY_EXIT",
    "TOGGLE_INSTANT_COMPARE",
    "SPEED_CHANGE",
    "RESIZE",
    "CLICK_BAR_EDIT",
    "EDIT_BLUR_COMMIT",
    "EDIT_ESCAPE_CANCEL",
    "NEEDS_SWAP",
    "NO_SWAP_AUTO_CONTINUE",
    "NO_SWAP_STEP_COMPLETE",
    "SWAP_ANIMATION_DONE_AUTO",
    "SWAP_ANIMATION_DONE_STEP",
    "END_OF_PASS",
    "EARLY_EXIT_TRIGGERED",
    "NEXT_PASS",
    "AUTO_CONTINUE",
    "STEP_COMPLETE",
    "PASS_COMPLETED",
    "ALGORITHM_COMPLETE",
    "LOAD_COMPLETE",
    "RESET_DONE"
  ],
  "notes": "Overview: The app initializes by creating a random dataset and resetting algorithm pointers. Playback flow is governed by flags playing (auto-run loop), busy (guards against concurrent step), and done (completion). States 'idle' and 'paused' are user-facing rest states where stepping and dataset/option changes can occur. 'playing' runs the playLoop which repeatedly calls stepOnce until paused or done. Algorithmic micro-states: 'comparing' highlights adjacent bars and updates counters (setPseudo(4), highlightCompare, announce). If comparator returns true, transition to 'swapping' (animateSwap pulse + reposition). After each inner step, jIndex advances and clearCompare runs on exit. When jIndex exceeds the bound (n - 2 - iPass), 'pass_locking' locks the last element (blue). If earlyExit is enabled and no swaps occurred in the pass, 'EARLY_EXIT_TRIGGERED' transitions to 'done' via finalizeSorted. Otherwise, 'next_pass' sets up the next outer loop iteration. 'stepping_pass' runs a full pass in a paused mode by looping stepOnce until passCount increases or the algorithm completes. 'loading_dataset' covers all dataset actions (random, reversed, nearly sorted, load custom, shuffle, size change) and immediately resets pointers; it returns to 'idle' when load is complete. 'resetting' wraps resetAlgorithm for reset and order toggling. 'editing_value' allows inline editing of a bar's value (blocked while busy); blur commits validate and update value + positions, Escape cancels. Completion: 'done' finalizes visuals (all bars green) and prevents meaningful play-loop continuation; play toggles will immediately return to 'done'. Visual cues: comparing adds 'compare' class; swapping adds 'swap' animation; pass locking adds 'locked'; final completion adds 'sorted'. Speed changes adjust '--anim-ms' via getAnimMS; optInstant reduces delays; optEarly toggles early exit logic without resetting. Many events self-loop (no state change) to reflect settings updates and resize. Conditions: From 'comparing' and 'swapping', transitions diverge into 'playing' vs 'paused' based on whether user initiated a single step or the auto-play loop triggered the comparison. The app uses asynchronous delays (sleep) based on speedRange and optInstant settings."
}
  </script>
</body>
</html>