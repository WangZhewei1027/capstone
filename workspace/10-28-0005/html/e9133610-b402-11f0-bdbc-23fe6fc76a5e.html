<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bubble Sort — Interactive Visual Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #0f1420;
      --surface: #161d2e;
      --panel: #1b2439;
      --text: #e8ecf7;
      --muted: #b7c0d8;
      --accent: #62d2a2;
      --accent-2: #7aa7ff;
      --compare-a: #ff7a7a;
      --compare-b: #ffd37a;
      --swap: #ffcc66;
      --sorted: #78e08f;
      --focus: #fff389;
      --warn: #ff9369;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.45;
    }

    main.module {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1, h2, h3 {
      margin: 0 0 12px 0;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    p {
      margin: 0 0 12px 0;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 24px;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--surface);
      border: 1px solid #233052;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 12px 24px rgba(0,0,0,0.25);
    }

    .meta {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .meta .block + .block {
      margin-top: 4px;
    }

    .subtle {
      color: var(--muted);
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-end;
      margin-bottom: 16px;
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 140px;
      flex: 1 1 140px;
    }

    label {
      font-size: 14px;
      color: var(--muted);
    }

    input[type="number"],
    input[type="text"],
    select {
      background: var(--panel);
      border: 1px solid #314066;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 8px;
      outline: none;
      transition: border-color 120ms ease, box-shadow 120ms ease;
    }

    input[type="range"] {
      width: 100%;
    }

    input:focus, select:focus {
      border-color: var(--accent-2);
      box-shadow: 0 0 0 3px rgba(122, 167, 255, 0.25);
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid #314066;
      border-radius: 8px;
      min-height: 44px;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 16px;
    }

    button {
      background: var(--accent-2);
      color: #0b1220;
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      min-height: 44px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }

    button.secondary {
      background: #2a3553;
      color: var(--text);
      border: 1px solid #3a4a77;
    }

    button.warn {
      background: var(--warn);
      color: #1a1000;
    }

    button:focus-visible {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
    }

    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    /* Visualization */
    .viz {
      background: var(--panel);
      border: 1px solid #314066;
      border-radius: 12px;
      padding: 16px;
    }

    .bar-area {
      position: relative;
      height: 260px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border-radius: 8px;
      overflow: hidden;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 40px; /* will be overridden dynamically */
      height: 100px; /* from value */
      background: #4A70C5;
      border-radius: 6px 6px 0 0;
      border: 1px solid #20305b;
      transition: left 300ms ease, height 300ms ease, background-color 200ms ease, transform 200ms ease, box-shadow 200ms ease;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #eaf1ff;
      font-weight: 600;
      user-select: none;
    }

    .bar .label {
      font-size: 13px;
      padding: 6px 0;
      width: 100%;
      text-align: center;
      background: rgba(0,0,0,0.2);
      border-radius: 6px 6px 0 0;
    }

    .bar.compare-a {
      background: var(--compare-a);
      box-shadow: 0 10px 20px rgba(255, 122, 122, 0.35);
    }

    .bar.compare-b {
      background: var(--compare-b);
      box-shadow: 0 10px 20px rgba(255, 211, 122, 0.35);
    }

    .bar.swap {
      animation: bubble 250ms ease;
      box-shadow: 0 12px 22px rgba(255, 204, 102, 0.35);
    }

    @keyframes bubble {
      0%   { transform: translateY(0); }
      40%  { transform: translateY(-10px); }
      100% { transform: translateY(0); }
    }

    .bar.sorted-tail {
      background: var(--sorted);
      border-color: #2f7a57;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      color: var(--muted);
      font-size: 14px;
    }

    .legend .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
    }

    /* Status */
    .status {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }

    .stat {
      background: var(--panel);
      border: 1px solid #314066;
      border-radius: 8px;
      padding: 12px;
    }

    .stat .value {
      font-size: 22px;
      font-weight: 700;
    }

    .stat .label {
      font-size: 13px;
      color: var(--muted);
    }

    .narration {
      background: var(--panel);
      border: 1px solid #314066;
      border-radius: 8px;
      padding: 12px;
      min-height: 48px;
    }

    .code {
      background: #12182a;
      border: 1px solid #2a375e;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, Menlo, Consolas, "SF Mono", monospace;
      font-size: 13px;
      color: #dbe6ff;
      margin-top: 12px;
      white-space: pre;
      overflow-x: auto;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
    }

    /* Safe area for the page */
    @supports (padding: env(safe-area-inset-top)) {
      main.module {
        padding-left: calc(24px + env(safe-area-inset-left));
        padding-right: calc(24px + env(safe-area-inset-right));
        padding-top: calc(24px + env(safe-area-inset-top));
        padding-bottom: calc(24px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <main class="module" aria-labelledby="title">
    <h1 id="title">Bubble Sort — Visual, Step-by-Step Interaction</h1>

    <div class="grid">
      <!-- Left: Design Plan and Explanations -->
      <section class="card meta" aria-label="Module overview">
        <div class="block">
          <h2>Concept Title</h2>
          <p class="subtle">Bubble Sort: adjacent comparisons and swaps to move the largest element to the end on each pass.</p>
        </div>

        <div class="block">
          <h2>Learning Objective</h2>
          <p>After interacting, you will be able to:</p>
          <ul>
            <li>Explain how bubble sort compares adjacent elements and swaps out-of-order pairs.</li>
            <li>Observe why each pass “bubbles” the largest remaining item to the end, growing a sorted tail.</li>
            <li>Relate steps, passes, comparisons, and swaps to algorithmic complexity and the early-exit optimization.</li>
          </ul>
        </div>

        <div class="block">
          <h2>Interaction Design</h2>
          <p>Use controls to generate data, set sort direction, and choose optimized mode. Press Play to watch animated comparisons and swaps. Step performs a single comparison; Step Pass advances to the end of the current pass. The visualization provides:</p>
          <ul>
            <li>Animated highlight of the two elements being compared.</li>
            <li>Swap animation when elements are out of order.</li>
            <li>Green highlight of the sorted tail after each pass.</li>
            <li>Live narration of the current comparison and decision.</li>
          </ul>
          <p>Keyboard shortcuts: Space toggles play/pause; Enter performs one step; Esc resets.</p>
        </div>

        <div class="block">
          <h2>Layout Description</h2>
          <p>The page uses a two-column layout on wide screens and stacks on narrow screens. The safe-area margin is 24 px on all sides. Interactive elements maintain at least 16 px spacing. The right column holds the interactive module with controls above the visualization, followed by status and narration for clear focus and balance.</p>
          <p>Accessibility features include labeled controls, focus outlines, color contrast, and a live region announcing comparisons/swaps.</p>
        </div>
      </section>

      <!-- Right: Interactive Module -->
      <section class="card" aria-label="Bubble sort interactive module">
        <h2>Hands-on Bubble Sort Playground</h2>

        <div class="controls" role="group" aria-label="Configuration controls">
          <div class="control">
            <label for="size">Array size</label>
            <input id="size" type="number" min="5" max="30" value="10" aria-describedby="sizeHelp">
            <div id="sizeHelp" class="sr-only">Choose from 5 to 30 elements.</div>
          </div>

          <div class="control">
            <label for="order">Order</label>
            <select id="order" aria-label="Sort order">
              <option value="asc" selected>Ascending (small → big)</option>
              <option value="desc">Descending (big → small)</option>
            </select>
          </div>

          <div class="control">
            <label for="speed">Speed</label>
            <input id="speed" type="range" min="0" max="100" value="50" aria-valuemin="0" aria-valuemax="100" aria-valuenow="50" aria-label="Animation speed">
          </div>

          <div class="control">
            <div class="checkbox-row">
              <input id="optimized" type="checkbox" aria-label="Enable early exit">
              <label for="optimized">Optimized early exit (stop when pass has no swaps)</label>
            </div>
          </div>

          <div class="control">
            <label>&nbsp;</label>
            <button id="generate" class="secondary" aria-label="Generate random data">Generate Random</button>
          </div>
        </div>

        <div class="actions" role="group" aria-label="Sorting actions">
          <button id="play" aria-pressed="false" aria-label="Play or pause sorting">Play</button>
          <button id="step" class="secondary" aria-label="Step one comparison">Step</button>
          <button id="pass" class="secondary" aria-label="Advance one pass">Step Pass</button>
          <button id="reset" class="warn" aria-label="Reset to initial unsorted array">Reset</button>
        </div>

        <div class="viz" aria-live="off">
          <div class="bar-area" id="barArea" role="img" aria-label="Bar chart showing array values"></div>

          <div class="legend" aria-hidden="true">
            <span><span class="dot" style="background: var(--compare-a);"></span>Compare A</span>
            <span><span class="dot" style="background: var(--compare-b);"></span>Compare B</span>
            <span><span class="dot" style="background: var(--sorted);"></span>Sorted tail</span>
          </div>

          <div class="status">
            <div class="stat">
              <div class="value" id="passes">0</div>
              <div class="label">Passes completed</div>
            </div>
            <div class="stat">
              <div class="value" id="comparisons">0</div>
              <div class="label">Comparisons</div>
            </div>
            <div class="stat">
              <div class="value" id="swaps">0</div>
              <div class="label">Swaps</div>
            </div>
            <div class="stat">
              <div class="value" id="length">0</div>
              <div class="label">Array length</div>
            </div>
          </div>

          <div class="narration" id="narration" aria-live="polite">
            Ready. Generate or press Play to begin bubble sort.
          </div>

          <div class="code" aria-label="Pseudocode">
bubbleSort(A):
  repeat for pass = 0 to n-2:
    swapped = false
    for i = 0 to n-2-pass:
      if outOfOrder(A[i], A[i+1]):
        swap(A[i], A[i+1])
        swapped = true
    if optimized and not swapped:
      break
          </div>
        </div>

        <div id="live" class="sr-only" aria-live="polite"></div>
      </section>
    </div>
  </main>

  <script>
    (function() {
      // State
      const barArea = document.getElementById('barArea');
      const sizeInput = document.getElementById('size');
      const orderSelect = document.getElementById('order');
      const speedInput = document.getElementById('speed');
      const optimizedCheckbox = document.getElementById('optimized');
      const generateBtn = document.getElementById('generate');
      const playBtn = document.getElementById('play');
      const stepBtn = document.getElementById('step');
      const passBtn = document.getElementById('pass');
      const resetBtn = document.getElementById('reset');

      const narration = document.getElementById('narration');
      const live = document.getElementById('live');

      const passesEl = document.getElementById('passes');
      const compsEl = document.getElementById('comparisons');
      const swapsEl = document.getElementById('swaps');
      const lengthEl = document.getElementById('length');

      let arr = [];
      let originalArr = [];
      let playing = false;
      let busy = false;
      let pass = 0;
      let i = 0;
      let comparisons = 0;
      let swaps = 0;
      let swappedInPass = false;
      let sortedTailStart = Number.POSITIVE_INFINITY; // index where sorted tail begins (n - pass)

      // Parameters
      function stepDuration() {
        const val = +speedInput.value; // 0..100
        // Map to 1400ms (slow) -> 200ms (fast)
        return Math.round(1400 - (val / 100) * 1200);
      }

      function inOrder(a, b) {
        const dir = orderSelect.value;
        return dir === 'asc' ? a <= b : a >= b;
      }

      // Initialize
      initArray(+sizeInput.value);
      renderBars();
      updateStats();
      announce("Module ready. Use Play, Step, or Step Pass.");

      // Events
      window.addEventListener('resize', positionBars);
      sizeInput.addEventListener('change', () => {
        clampSize();
        stop();
        initArray(+sizeInput.value);
        renderBars();
        updateStats();
        setNarration("Array size changed. Ready.");
      });

      orderSelect.addEventListener('change', () => {
        stop();
        // Changing order does not mutate data; just affects comparisons.
        setNarration("Order set to " + (orderSelect.value === 'asc' ? "ascending." : "descending."));
      });

      speedInput.addEventListener('input', () => {
        speedInput.setAttribute('aria-valuenow', speedInput.value);
      });

      optimizedCheckbox.addEventListener('change', () => {
        setNarration(optimizedCheckbox.checked ?
          "Early exit enabled. Sorting stops when a pass has zero swaps." :
          "Early exit disabled. All passes will run.");
      });

      generateBtn.addEventListener('click', () => {
        stop();
        initArray(+sizeInput.value, true);
        renderBars();
        updateStats();
        setNarration("Generated a new random array.");
      });

      playBtn.addEventListener('click', togglePlay);
      stepBtn.addEventListener('click', () => { stepOnce(); });
      passBtn.addEventListener('click', () => { stepPass(); });
      resetBtn.addEventListener('click', () => { reset(); });

      // Keyboard accessibility
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ') {
          e.preventDefault();
          togglePlay();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          stepOnce();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          reset();
        }
      });

      // Core logic
      function clampSize() {
        let v = +sizeInput.value;
        if (Number.isNaN(v)) v = 10;
        v = Math.min(30, Math.max(5, v));
        sizeInput.value = v;
      }

      function initArray(n, randomize = true) {
        arr = new Array(n).fill(0).map(() => randomInt(8, 99));
        if (!randomize) {
          // Keep the original order if requested; here we always randomize on init
        }
        originalArr = arr.slice();
        resetStateCounters();
      }

      function resetStateCounters() {
        playing = false;
        busy = false;
        pass = 0;
        i = 0;
        comparisons = 0;
        swaps = 0;
        swappedInPass = false;
        sortedTailStart = arr.length; // none sorted at start
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
        enableControls(true);
      }

      function renderBars() {
        barArea.innerHTML = '';
        const n = arr.length;
        lengthEl.textContent = String(n);

        const dims = computeBarLayout(n);
        arr.forEach((val, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('data-index', String(idx));
          bar.setAttribute('aria-label', `Index ${idx}, value ${val}`);
          bar.style.height = `${mapHeight(val)}px`;
          bar.style.left = `${dims.positions[idx]}px`;
          bar.style.width = `${dims.width}px`;

          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = String(val);
          bar.appendChild(label);

          barArea.appendChild(bar);
        });

        highlightSortedTail();
      }

      function positionBars() {
        const n = arr.length;
        const dims = computeBarLayout(n);
        const bars = Array.from(barArea.querySelectorAll('.bar'));
        bars.forEach((bar, idx) => {
          bar.style.left = `${dims.positions[idx]}px`;
          bar.style.width = `${dims.width}px`;
          const val = arr[idx];
          bar.style.height = `${mapHeight(val)}px`;
          bar.querySelector('.label').textContent = String(val);
        });
      }

      function computeBarLayout(n) {
        const areaW = barArea.clientWidth;
        const gap = Math.max(6, Math.floor(areaW / n * 0.08));
        const width = Math.max(18, Math.floor((areaW - gap * (n - 1)) / n));
        let positions = new Array(n).fill(0);
        for (let k = 0; k < n; k++) {
          positions[k] = k * (width + gap);
        }
        return { width, positions };
      }

      function mapHeight(val) {
        // Scale values to [40px..240px]
        const minH = 40;
        const maxH = 240;
        const minV = 0;
        const maxV = 100;
        const h = minH + (val - minV) * (maxH - minH) / (maxV - minV);
        return Math.round(h);
      }

      function setNarration(text) {
        narration.textContent = text;
        announce(text);
      }

      function updateStats() {
        passesEl.textContent = String(pass);
        compsEl.textContent = String(comparisons);
        swapsEl.textContent = String(swaps);
      }

      function announce(msg) {
        // Screen reader live region
        live.textContent = msg;
      }

      function togglePlay() {
        if (busy) return;
        if (isSorted()) {
          setNarration("Array already sorted.");
          return;
        }
        playing = !playing;
        playBtn.textContent = playing ? 'Pause' : 'Play';
        playBtn.setAttribute('aria-pressed', playing ? 'true' : 'false');
        enableControls(!playing);
        // Allow changing speed/order while playing
        speedInput.disabled = false;
        orderSelect.disabled = false;

        if (playing) {
          loop();
        }
      }

      function stop() {
        playing = false;
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
        enableControls(true);
      }

      function enableControls(enabled) {
        // Maintain accessible spacing; disable relevant interactive controls during play
        stepBtn.disabled = !enabled;
        passBtn.disabled = !enabled;
        generateBtn.disabled = !enabled;
        sizeInput.disabled = !enabled;
        optimizedCheckbox.disabled = !enabled;
        resetBtn.disabled = !enabled;
      }

      function isSorted() {
        const dir = orderSelect.value;
        for (let k = 0; k < arr.length - 1; k++) {
          if (dir === 'asc') {
            if (arr[k] > arr[k + 1]) return false;
          } else {
            if (arr[k] < arr[k + 1]) return false;
          }
        }
        return true;
      }

      function loop() {
        if (!playing) return;
        stepOnce().then(() => {
          if (playing) {
            setTimeout(loop, stepDuration() * 0.2); // small gap between steps
          }
        });
      }

      async function stepOnce() {
        if (busy) return;
        busy = true;

        const n = arr.length;
        const endIdx = n - 1 - pass;

        if (i > endIdx - 1) {
          // End of pass
          sortedTailStart = n - pass;
          highlightSortedTail();

          if (optimizedCheckbox.checked && !swappedInPass) {
            // Early exit
            pass++;
            updateStats();
            setNarration("No swaps in last pass. Early exit: array is sorted.");
            stop();
            busy = false;
            return;
          }

          pass++;
          updateStats();
          swappedInPass = false;
          i = 0;
          highlightSortedTail();
          setNarration(`Pass ${pass} complete. Sorted tail grows from index ${n - pass} to end.`);
          await delay(stepDuration() * 0.4);
        }

        if (pass >= n - 1) {
          // Done
          sortedTailStart = 0;
          highlightSortedTail();
          setNarration("Sorting complete.");
          stop();
          busy = false;
          return;
        }

        // Compare i and i+1
        const a = arr[i];
        const b = arr[i + 1];
        const bars = getBars();
        const barA = bars[i];
        const barB = bars[i + 1];

        setCompareHighlight(barA, barB, true);
        setNarration(`Compare indices ${i} and ${i + 1}: ${a} vs ${b}.`);
        comparisons++;
        updateStats();

        await delay(stepDuration() * 0.5);

        if (!inOrder(a, b)) {
          // Swap
          setNarration(`Swap needed: ${a} and ${b} are out of order.`);
          swapValues(i, i + 1);
          swaps++;
          swappedInPass = true;
          updateStats();
          // Animate positions
          barA.classList.add('swap');
          barB.classList.add('swap');
          positionBars();
          await delay(280);
          barA.classList.remove('swap');
          barB.classList.remove('swap');
        } else {
          setNarration(`No swap: ${a} and ${b} are in order.`);
        }

        await delay(stepDuration() * 0.2);
        setCompareHighlight(barA, barB, false);
        i++;

        busy = false;
      }

      async function stepPass() {
        if (busy) return;
        let startPass = pass;
        while (startPass === pass && pass < arr.length - 1) {
          await stepOnce();
          // If early exit was triggered, break
          if (optimizedCheckbox.checked && !playing && isSorted()) break;
        }
      }

      function reset() {
        stop();
        arr = originalArr.slice();
        resetStateCounters();
        renderBars();
        updateStats();
        setNarration("Reset to initial unsorted order.");
      }

      function swapValues(aIndex, bIndex) {
        const tmp = arr[aIndex];
        arr[aIndex] = arr[bIndex];
        arr[bIndex] = tmp;
      }

      function setCompareHighlight(barA, barB, on) {
        if (!barA || !barB) return;
        if (on) {
          barA.classList.add('compare-a');
          barB.classList.add('compare-b');
          announce(`Comparing index ${i} and ${i + 1}.`);
        } else {
          barA.classList.remove('compare-a');
          barB.classList.remove('compare-b');
        }
      }

      function highlightSortedTail() {
        const bars = getBars();
        const n = arr.length;
        for (let k = 0; k < n; k++) {
          if (k >= n - pass) {
            bars[k]?.classList.add('sorted-tail');
          } else {
            bars[k]?.classList.remove('sorted-tail');
          }
        }
      }

      function getBars() {
        return Array.from(barArea.querySelectorAll('.bar'));
      }

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function delay(ms) {
        return new Promise(res => setTimeout(res, ms));
      }
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application — Bubble Sort Visualizer",
  "description": "Finite state machine for an interactive, step-by-step bubble sort visualization with play/pause, single-step, and pass-step controls, including visual compare/swap animations, sorted-tail highlighting, and narration.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "init_module",
      "on": {
        "INIT_DONE": "idle"
      }
    },
    {
      "name": "idle",
      "onEnter": "enable_controls",
      "on": {
        "TOGGLE_PLAY": "playing",
        "SPACE_PRESS": "playing",
        "STEP_CLICK": "step_precheck",
        "ENTER_PRESS": "step_precheck",
        "PASS_CLICK": "stepping_pass",
        "RESET_CLICK": "resetting",
        "ESC_PRESS": "resetting",
        "GENERATE_CLICK": "generating",
        "SIZE_CHANGE": "generating",
        "ORDER_CHANGE": "order_updated",
        "SPEED_INPUT": "idle",
        "WINDOW_RESIZE": "idle"
      }
    },
    {
      "name": "paused",
      "onEnter": "set_paused_ui",
      "on": {
        "TOGGLE_PLAY": "playing",
        "SPACE_PRESS": "playing",
        "STEP_CLICK": "step_precheck",
        "ENTER_PRESS": "step_precheck",
        "PASS_CLICK": "stepping_pass",
        "RESET_CLICK": "resetting",
        "ESC_PRESS": "resetting",
        "GENERATE_CLICK": "generating",
        "SIZE_CHANGE": "generating",
        "ORDER_CHANGE": "paused",
        "SPEED_INPUT": "paused",
        "WINDOW_RESIZE": "paused"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_playing",
      "on": {
        "TOGGLE_PLAY": "paused",
        "SPACE_PRESS": "paused",
        "AUTO_STEP": "step_precheck",
        "GENERATE_CLICK": "generating",
        "SIZE_CHANGE": "generating",
        "RESET_CLICK": "resetting",
        "ESC_PRESS": "resetting",
        "ORDER_CHANGE": "playing",
        "SPEED_INPUT": "playing",
        "SORT_COMPLETE": "done",
        "EARLY_EXIT": "done",
        "WINDOW_RESIZE": "playing"
      }
    },
    {
      "name": "generating",
      "onEnter": "generate_array_and_render",
      "on": {
        "GENERATION_DONE": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "reset_to_original",
      "on": {
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "order_updated",
      "onEnter": "narrate_order_changed",
      "on": {
        "ORDER_CHANGE_HANDLED": "idle"
      }
    },
    {
      "name": "stepping_pass",
      "onEnter": "prepare_pass_mode",
      "on": {
        "START_PASS_STEP": "step_precheck",
        "STEP_DONE_CONTINUE_PASS": "step_precheck",
        "PASS_COMPLETED_TO_IDLE": "idle",
        "EARLY_EXIT": "done",
        "SORT_COMPLETE": "done"
      }
    },
    {
      "name": "step_precheck",
      "onEnter": "enter_step_and_check_pass",
      "on": {
        "END_OF_PASS": "pass_handling",
        "PROCEED_TO_COMPARE": "comparing",
        "SORT_COMPLETE": "done"
      }
    },
    {
      "name": "pass_handling",
      "onEnter": "handle_pass_end",
      "on": {
        "EARLY_EXIT": "done",
        "SORT_COMPLETE": "done",
        "PASS_INCREMENTED": "comparing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_and_narrate_compare",
      "on": {
        "SWAP_NEEDED": "swapping",
        "NO_SWAP_NEEDED": "no_swap"
      }
    },
    {
      "name": "swapping",
      "onEnter": "perform_swap_and_animate",
      "on": {
        "SWAP_ANIM_DONE": "step_cooldown"
      }
    },
    {
      "name": "no_swap",
      "onEnter": "narrate_no_swap",
      "on": {
        "NO_SWAP_HANDLED": "step_cooldown"
      }
    },
    {
      "name": "step_cooldown",
      "onEnter": "finalize_step_and_clear_highlights",
      "on": {
        "STEP_DONE_CONTINUE_PLAY": "playing",
        "STEP_DONE_RETURN_IDLE": "idle",
        "STEP_DONE_CONTINUE_PASS": "stepping_pass"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sorted",
      "on": {
        "GENERATE_CLICK": "generating",
        "SIZE_CHANGE": "generating",
        "RESET_CLICK": "resetting",
        "ESC_PRESS": "resetting",
        "TOGGLE_PLAY": "done",
        "SPACE_PRESS": "done",
        "STEP_CLICK": "done",
        "ENTER_PRESS": "done",
        "PASS_CLICK": "done",
        "ORDER_CHANGE": "done",
        "SPEED_INPUT": "done",
        "WINDOW_RESIZE": "done"
      }
    }
  ],
  "events": [
    "INIT",
    "INIT_DONE",
    "TOGGLE_PLAY",
    "SPACE_PRESS",
    "STEP_CLICK",
    "ENTER_PRESS",
    "PASS_CLICK",
    "RESET_CLICK",
    "ESC_PRESS",
    "GENERATE_CLICK",
    "SIZE_CHANGE",
    "ORDER_CHANGE",
    "ORDER_CHANGE_HANDLED",
    "SPEED_INPUT",
    "WINDOW_RESIZE",
    "AUTO_STEP",
    "START_PASS_STEP",
    "END_OF_PASS",
    "PROCEED_TO_COMPARE",
    "PASS_INCREMENTED",
    "EARLY_EXIT",
    "SORT_COMPLETE",
    "SWAP_NEEDED",
    "NO_SWAP_NEEDED",
    "SWAP_ANIM_DONE",
    "NO_SWAP_HANDLED",
    "STEP_DONE_CONTINUE_PLAY",
    "STEP_DONE_RETURN_IDLE",
    "STEP_DONE_CONTINUE_PASS",
    "PASS_COMPLETED_TO_IDLE",
    "GENERATION_DONE",
    "RESET_DONE"
  ],
  "notes": "Mapping to code: initializing.init_module runs initArray(size), renderBars(), updateStats(), and announce(). idle is the ready state (playing=false, busy=false) with controls enabled; it transitions to playing via Play button or Space. paused is functionally like idle after toggling Play off during playback; onEnter set_paused_ui should mirror stop(): set play button text to 'Play', aria-pressed=false, and enable controls. playing.onEnter start_playing should toggle play button to 'Pause', set aria-pressed=true, disable step/pass/generate/size/optimized/reset (but keep speed and order enabled), and start the loop() that emits AUTO_STEP repeatedly with a small inter-step delay based on stepDuration(). During a step, busy=true prevents re-entry; user inputs are effectively ignored. step_precheck.enter_step_and_check_pass corresponds to the top of stepOnce(): compute endIdx=n-1-pass and branch to END_OF_PASS (if i>endIdx-1) or PROCEED_TO_COMPARE. pass_handling.handle_pass_end performs sorted-tail highlight (highlightSortedTail), then either: (a) EARLY_EXIT when optimized is enabled and no swaps occurred in the pass (sets narration and stops), (b) PASS_INCREMENTED when a normal pass completes (increment pass, reset i=0, swappedInPass=false, highlight tail again, set narration, await a short delay), or (c) SORT_COMPLETE if pass >= n-1 after increment (sets entire tail and stops). comparing.highlight_and_narrate_compare sets compare highlights on the two bars, narrates 'Compare i and i+1', increments comparisons, then after a delay determines SWAP_NEEDED vs NO_SWAP_NEEDED using inOrder(). swapping.perform_swap_and_animate calls swapValues(), increments swaps and sets swappedInPass=true, adds 'swap' animation classes to both bars, calls positionBars(), waits ~280ms, and removes the classes. no_swap.narrate_no_swap sets narration for in-order case. step_cooldown.finalize_step_and_clear_highlights waits a short delay, removes compare highlights, increments i, sets busy=false, and emits one of: STEP_DONE_CONTINUE_PLAY (returns to playing; loop() schedules the next AUTO_STEP), STEP_DONE_RETURN_IDLE (when the user performed a single Step), or STEP_DONE_CONTINUE_PASS (when Step Pass is active). stepping_pass represents the while-loop in stepPass(): it repeatedly routes through step_precheck/comparing/swapping/step_cooldown until either PASS_COMPLETED_TO_IDLE (end of the current pass), EARLY_EXIT, or SORT_COMPLETE. generating.generate_array_and_render maps to stop(), initArray(size, true), renderBars(), updateStats(), and narration 'Generated...' before GENERATION_DONE -> idle. resetting.reset_to_original maps to stop(), arr=originalArr.slice(), resetStateCounters(), renderBars(), updateStats(), narration 'Reset...' then RESET_DONE -> idle. order change does not alter data; it updates narration and affects future comparisons; it is allowed during playing. speed input updates aria-valuenow and the stepDuration used by future steps; allowed during playing. Window resize calls positionBars() but does not change state. Pressing Play when already sorted narrates 'Array already sorted' and stays in done. Visual feedback states captured here are comparing (highlight), swapping (animated), pass_handling (sorted-tail highlight), and done (all green tail). Controls are disabled during playing (except speed/order) and while busy=true during animations."
}
  </script>
</body>
</html>