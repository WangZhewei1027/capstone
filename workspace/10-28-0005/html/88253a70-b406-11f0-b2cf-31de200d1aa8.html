<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bubble Sort — Interactive Tutor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --safe-margin:24px;
      --gap:16px;
      --bg:#0f172a;          /* slate-900 */
      --panel:#111827;       /* gray-900 */
      --panel-2:#0b1222;     /* deeper slate */
      --txt:#e5e7eb;         /* gray-200 */
      --muted:#cbd5e1;       /* slate-300 */
      --accent:#60a5fa;      /* sky-400 */
      --accent-2:#fbbf24;    /* amber-400 */
      --danger:#f87171;      /* red-400 */
      --success:#34d399;     /* emerald-400 */
      --sorted:#22c55e;      /* green-500 */
      --focus:#f59e0b;       /* amber-500 */
      --border:#1f2937;      /* gray-800 */
      --code-bg:#0a1020;
      --shadow:0 10px 24px rgba(0,0,0,0.35);
      --radius:12px;
      --btn-radius:10px;
      --bar-radius:6px;
      --bar-gap:4px;
      --bar-min-width:18px;
      --bar-max-width:60px;
      --bar-pad:8px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --transition-fast: 200ms ease;
      --transition-med: 360ms cubic-bezier(.2,.8,.2,1);
    }
    *{box-sizing:border-box}
    html, body{
      height:100%;
      background:linear-gradient(180deg, #0b1222 0%, #0f172a 100%);
      color:var(--txt);
      font-family:var(--font);
      line-height:1.4;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:var(--safe-margin);
    }
    h1{
      margin:0 0 8px 0;
      font-size:clamp(22px, 3.2vw, 34px);
      letter-spacing:.2px;
    }
    p.lead{
      margin:0 0 16px 0;
      color:var(--muted);
      font-size:clamp(14px, 2.2vw, 16px);
    }

    /* Panels and layout */
    .panel{
      background:linear-gradient(180deg, var(--panel) 0, var(--panel-2) 100%);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
    }
    .controls{
      display:grid;
      gap:var(--gap);
      grid-template-columns:1fr;
      padding:16px;
    }
    @media (min-width: 860px){
      .controls{
        grid-template-columns: 1.1fr 1fr 1fr;
        align-items:start;
      }
    }
    fieldset{
      border:none;
      margin:0;
      padding:0;
      min-width:0;
    }
    legend{
      font-weight:600;
      margin-bottom:8px;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:center;
    }
    label{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
    }
    input[type="text"]{
      width:100%;
      padding:10px 12px;
      background:#0a1020;
      color:var(--txt);
      border:1px solid var(--border);
      border-radius:10px;
      outline:none;
      transition:border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    input[type="text"]:focus{
      border-color:var(--focus);
      box-shadow:0 0 0 3px rgba(245, 158, 11, .2);
    }
    .btn{
      appearance:none;
      border:none;
      padding:10px 14px;
      border-radius:var(--btn-radius);
      color:#0b1222;
      background:var(--accent);
      font-weight:600;
      cursor:pointer;
      transition:transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
      box-shadow:0 8px 16px rgba(96,165,250,.25);
    }
    .btn.secondary{
      background:#1f2937;
      color:var(--txt);
      box-shadow:none;
      border:1px solid var(--border);
    }
    .btn.warn{
      background:var(--danger);
      color:#0b1222;
      box-shadow:0 8px 16px rgba(248,113,113,.25);
    }
    .btn:disabled{
      opacity:.6;
      cursor:not-allowed;
      transform:none !important;
      box-shadow:none;
    }
    .btn:active{
      transform:translateY(1px) scale(.99);
      filter:brightness(.98);
    }
    .inline{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    .stack{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .split{
      display:grid;
      gap:var(--gap);
      margin-top:var(--gap);
      grid-template-columns:1fr;
    }
    @media (min-width: 980px){
      .split{
        grid-template-columns:1.3fr .9fr;
      }
    }

    /* Visualizer */
    .viz{
      padding:16px;
    }
    .viz-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
      margin-bottom:12px;
      flex-wrap:wrap;
    }
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
    }
    .legend .key{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .swatch{
      width:14px;height:14px;border-radius:4px;border:1px solid var(--border);
    }
    .swatch.compare{ background:var(--accent-2); }
    .swatch.swap{ background:var(--danger); }
    .swatch.sorted{ background:var(--sorted); }

    .chart{
      position:relative;
      height:320px;
      padding:var(--bar-pad);
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
      border:1px dashed #1e293b;
      overflow:hidden;
    }
    .bar{
      position:absolute;
      bottom:0;
      width:40px;
      min-width:var(--bar-min-width);
      max-width:var(--bar-max-width);
      background:linear-gradient(180deg, #3b82f6, #1d4ed8);
      border:1px solid rgba(255,255,255,.06);
      border-radius:var(--bar-radius);
      box-shadow:0 10px 18px rgba(29,78,216,.25);
      transform:translateX(0);
      transition:transform var(--transition-med), height var(--transition-med), filter var(--transition-fast);
    }
    .bar .label{
      position:absolute;
      top:-22px;
      left:50%;
      transform:translateX(-50%);
      font-size:12px;
      color:var(--muted);
      background:#0a1020;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--border);
      box-shadow:0 6px 12px rgba(0,0,0,.2);
      user-select:none;
      pointer-events:none;
    }
    .bar.compare{
      background:linear-gradient(180deg, #f59e0b, #b45309);
      box-shadow:0 10px 18px rgba(245,158,11,.25);
      z-index:2;
    }
    .bar.swap{
      background:linear-gradient(180deg, #ef4444, #b91c1c);
      box-shadow:0 10px 18px rgba(239,68,68,.28);
      z-index:3;
    }
    .bar.sorted{
      background:linear-gradient(180deg, #22c55e, #15803d);
      box-shadow:0 10px 18px rgba(34,197,94,.25);
      filter:saturate(1.15);
    }
    .tail-guide{
      position:absolute;
      right:0;
      top:0;
      bottom:0;
      width:0;
      background:repeating-linear-gradient(
        45deg,
        rgba(34,197,94,.12),
        rgba(34,197,94,.12) 10px,
        rgba(34,197,94,.18) 10px,
        rgba(34,197,94,.18) 20px
      );
      border-left:1px dashed rgba(34,197,94,.35);
      pointer-events:none;
      transition:width var(--transition-med);
    }

    /* Pseudocode */
    .code{
      padding:16px;
    }
    pre{
      margin:0;
      background:var(--code-bg);
      color:var(--txt);
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      font-family:var(--mono);
      font-size:13px;
      line-height:1.45;
      overflow:auto;
      max-height:360px;
    }
    .line{
      display:block;
      padding:3px 6px;
      border-left:3px solid transparent;
      border-radius:6px;
      margin-left:0;
    }
    .line .num{
      opacity:.5;
      width:24px;
      display:inline-block;
      user-select:none;
    }
    .line.active{
      background:rgba(96,165,250,.12);
      border-left-color:var(--accent);
    }
    .note{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
    }

    /* Status bar */
    .status{
      margin-top:var(--gap);
      padding:12px 16px;
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      align-items:center;
      justify-content:space-between;
    }
    .metrics{
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      font-size:14px;
      color:var(--muted);
    }
    .metrics .chip{
      background:#0a1020;
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      color:var(--txt);
      font-weight:600;
    }
    .aria-live{
      position:absolute;
      left:-9999px;
      height:1px;width:1px;overflow:hidden;
    }

    /* Details sections for plan */
    details{
      margin-top:var(--gap);
      border:1px solid var(--border);
      border-radius:10px;
      background:linear-gradient(180deg, #0b1328, #0a1020);
    }
    summary{
      cursor:pointer;
      padding:12px 14px;
      outline:none;
      list-style:none;
      user-select:none;
      font-weight:600;
    }
    details[open] summary{
      border-bottom:1px solid var(--border);
    }
    details .content{
      padding:12px 14px 16px 14px;
      color:var(--muted);
      font-size:14px;
    }

    /* Sliders and checkboxes */
    .slider{
      appearance:none;
      width:100%;
      height:8px;
      border-radius:999px;
      background:#1f2937;
      outline:none;
      border:1px solid var(--border);
    }
    .slider::-webkit-slider-thumb{
      appearance:none;
      width:18px;height:18px;border-radius:50%;
      background:var(--accent);
      border:2px solid #082541;
      box-shadow:0 6px 12px rgba(96,165,250,.35);
      cursor:pointer;
    }
    .check{
      display:flex;align-items:center;gap:10px;
    }
    .check input[type="checkbox"]{
      width:18px;height:18px;accent-color:var(--accent);
    }

    /* Focus visibility */
    .btn:focus-visible, input:focus-visible, .slider:focus-visible{
      outline:2px solid var(--focus);
      outline-offset:2px;
    }

    /* Responsive stack for controls rows */
    .row > *{ flex:1 1 auto; min-width:150px; }
  </style>
</head>
<body>
  <main>
    <!-- Concept Title -->
    <h1>Bubble Sort — Interactive Tutor</h1>

    <!-- Learning Objective -->
    <p class="lead">
      Learning objective: Understand how Bubble Sort repeatedly compares adjacent elements, swaps when out of order,
      and grows a sorted tail after each pass. Experience the algorithm step-by-step, visualize comparisons and swaps,
      and see when early-exit optimization stops the process.
    </p>

    <!-- Controls -->
    <section class="panel controls" aria-label="Controls">
      <fieldset>
        <legend>Data</legend>
        <div class="stack">
          <div>
            <label for="arrInput">Array (comma-separated integers)</label>
            <div class="row">
              <input id="arrInput" type="text" inputmode="numeric" aria-label="Array input" placeholder="e.g., 5, 2, 9, 1, 5, 6" />
              <button id="applyBtn" class="btn secondary" title="Apply typed array" aria-label="Apply typed array">Apply</button>
            </div>
          </div>
          <div class="row">
            <div style="min-width:200px;">
              <label for="sizeRange">Size: <span id="sizeLabel">8</span></label>
              <input id="sizeRange" class="slider" type="range" min="5" max="20" value="8" aria-label="Array size" />
            </div>
            <button id="shuffleBtn" class="btn secondary" title="Shuffle array" aria-label="Shuffle array">Shuffle</button>
            <button id="resetBtn" class="btn secondary" title="Reset to initial" aria-label="Reset">Reset</button>
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Execution</legend>
        <div class="stack">
          <div class="inline">
            <button id="playBtn" class="btn" aria-label="Play">Play</button>
            <button id="pauseBtn" class="btn secondary" aria-label="Pause">Pause</button>
            <button id="stepBtn" class="btn" aria-label="Step one operation">Step</button>
            <button id="passBtn" class="btn" aria-label="Run one full pass">Run 1 Pass</button>
          </div>
          <div>
            <label for="speedRange">Speed: <span id="speedLabel">1.0×</span></label>
            <input id="speedRange" class="slider" type="range" min="0.25" max="2" step="0.25" value="1" aria-label="Animation speed" />
          </div>
        </div>
      </fieldset>

      <fieldset>
        <legend>Options</legend>
        <div class="stack">
          <div class="check">
            <input id="explainChk" type="checkbox" checked />
            <label for="explainChk">Show explanations</label>
          </div>
          <div class="check">
            <input id="reducedChk" type="checkbox" />
            <label for="reducedChk">Reduce motion (no animation)</label>
          </div>
          <div class="check">
            <input id="earlyExitChk" type="checkbox" checked />
            <label for="earlyExitChk">Early exit if no swaps in a pass</label>
          </div>
        </div>
      </fieldset>
    </section>

    <!-- Visual + Code Split -->
    <section class="split">
      <!-- Visualizer -->
      <div class="panel viz" aria-label="Bubble sort visualizer">
        <div class="viz-header">
          <div class="legend" aria-hidden="true">
            <span class="key"><span class="swatch compare"></span> Comparing</span>
            <span class="key"><span class="swatch swap"></span> Swapping</span>
            <span class="key"><span class="swatch sorted"></span> Sorted tail</span>
          </div>
          <div id="explain" class="note" role="status" aria-live="polite"></div>
        </div>
        <div class="chart" id="chart" aria-label="Bar chart of array values">
          <div class="tail-guide" id="tailGuide" aria-hidden="true"></div>
        </div>
      </div>

      <!-- Pseudocode -->
      <div class="panel code" aria-label="Pseudocode">
        <pre aria-label="Bubble sort pseudocode">
<span id="L1" class="line"><span class="num">1</span> function bubbleSort(a):</span>
<span id="L2" class="line"><span class="num">2</span>   n = length(a)</span>
<span id="L3" class="line"><span class="num">3</span>   for i = 0 to n - 1:</span>
<span id="L4" class="line"><span class="num">4</span>     swapped = false</span>
<span id="L5" class="line"><span class="num">5</span>     for j = 0 to n - 2 - i:</span>
<span id="L6" class="line"><span class="num">6</span>       if a[j] > a[j+1]:</span>
<span id="L7" class="line"><span class="num">7</span>         swap(a[j], a[j+1])</span>
<span id="L8" class="line"><span class="num">8</span>         swapped = true</span>
<span id="L9" class="line"><span class="num">9</span>     if not swapped: break</span>
<span id="L10" class="line"><span class="num">10</span>  return a</span>
        </pre>
        <div class="note">
          Highlight shows the current step. The green shaded area in the chart marks the sorted tail after each pass.
        </div>
      </div>
    </section>

    <!-- Status -->
    <section class="panel status" aria-label="Status">
      <div class="metrics" role="group" aria-label="Metrics">
        <div class="chip">Pass: <span id="passCount">0</span></div>
        <div class="chip">Comparison: <span id="compCount">0</span></div>
        <div class="chip">Swap: <span id="swapCount">0</span></div>
      </div>
      <div class="note">Tip: Use Step to observe a single comparison (and swap if needed).</div>
    </section>

    <!-- Interaction Design -->
    <details>
      <summary>Interaction Design</summary>
      <div class="content">
        - Input: Type a comma-separated array, change its size, or shuffle. Press Apply to load your custom data.
        - Controls: Play runs comparisons continuously; Pause stops; Step performs one comparison (with swap if needed); Run 1 Pass advances until the end of the current outer pass.
        - Visual feedback: Bars being compared turn amber; when swapping, they turn red and slide to new positions. The rightmost green region is the sorted tail that grows each pass. Pseudocode highlights the current line, and the explanation text describes what is happening.
        - Speed and motion: Adjust speed from 0.25× to 2×. Reduce motion disables animation for accessibility.
        - Early exit: When enabled, the algorithm stops as soon as a pass completes with no swaps (array already sorted), illustrating the optimization.
      </div>
    </details>

    <!-- Layout Description -->
    <details>
      <summary>Layout Description</summary>
      <div class="content">
        - Safe margins: 24 px padding around the main container. All panels use internal padding with a minimum 16 px gap between interactive elements and sections.
        - Structure: Title and learning objective at the top. Below, a three-column control panel (stacks to one column on small screens). The main area splits into the visualizer (left) and pseudocode (right), stacking vertically on narrow viewports. A status bar sits below with counters and a brief tip.
        - Clarity: The chart area is large and central to maintain focus. Pseudocode highlighting mirrors visual actions. Controls group data, execution, and options to reduce cognitive load.
        - Accessibility: Buttons have labels and focus styles; colors are high-contrast and paired with position/outline cues. Live region updates explanations. The reduced motion option respects user preferences. All components are keyboard navigable.
      </div>
    </details>

    <div class="aria-live" aria-live="polite" id="live"></div>
  </main>

  <script>
    (function(){
      // Utility
      const $ = (sel, el = document) => el.querySelector(sel);
      const $$ = (sel, el = document) => Array.from(el.querySelectorAll(sel));

      // Elements
      const chart = $('#chart');
      const explain = $('#explain');
      const tailGuide = $('#tailGuide');
      const arrInput = $('#arrInput');
      const applyBtn = $('#applyBtn');
      const sizeRange = $('#sizeRange');
      const sizeLabel = $('#sizeLabel');
      const shuffleBtn = $('#shuffleBtn');
      const resetBtn = $('#resetBtn');
      const playBtn = $('#playBtn');
      const pauseBtn = $('#pauseBtn');
      const stepBtn = $('#stepBtn');
      const passBtn = $('#passBtn');
      const speedRange = $('#speedRange');
      const speedLabel = $('#speedLabel');
      const reducedChk = $('#reducedChk');
      const explainChk = $('#explainChk');
      const earlyExitChk = $('#earlyExitChk');
      const passCountEl = $('#passCount');
      const compCountEl = $('#compCount');
      const swapCountEl = $('#swapCount');
      const live = $('#live');

      const codeLines = {
        1: $('#L1'), 2: $('#L2'), 3: $('#L3'), 4: $('#L4'), 5: $('#L5'),
        6: $('#L6'), 7: $('#L7'), 8: $('#L8'), 9: $('#L9'), 10: $('#L10')
      };

      // State
      let initialArray = [];
      let items = []; // [{id, value, el}]
      let maxValue = 100;

      // Algorithm state
      let iPass = 0;
      let jIdx = 0;
      let swappedThisPass = false;
      let running = false;
      let runPassMode = false;
      let comparisons = 0;
      let swaps = 0;
      let speed = parseFloat(speedRange.value); // multiplier
      let reducedMotion = false;
      let earlyExit = true;
      let animationMsBase = 700; // base duration in ms
      let stepTimer = null;

      // Initialize
      function init(){
        // Seed array
        const size = parseInt(sizeRange.value, 10);
        initialArray = makeRandomArray(size);
        loadArray(initialArray, true);
        bindEvents();
        updateSpeed();
        updateExplain('Ready. Enter your own array or press Play.');
      }

      function bindEvents(){
        window.addEventListener('resize', layoutBars);

        applyBtn.addEventListener('click', onApply);
        shuffleBtn.addEventListener('click', onShuffle);
        resetBtn.addEventListener('click', onReset);

        sizeRange.addEventListener('input', () => {
          sizeLabel.textContent = sizeRange.value;
        });
        sizeRange.addEventListener('change', onSizeChange);

        playBtn.addEventListener('click', play);
        pauseBtn.addEventListener('click', pause);
        stepBtn.addEventListener('click', step);
        passBtn.addEventListener('click', runOnePass);

        speedRange.addEventListener('input', updateSpeed);
        reducedChk.addEventListener('change', () => {
          reducedMotion = reducedChk.checked;
          layoutBars(true);
        });
        explainChk.addEventListener('change', () => {});
        earlyExitChk.addEventListener('change', () => {
          earlyExit = earlyExitChk.checked;
        });
      }

      // Array helpers
      function makeRandomArray(n){
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(randInt(5, maxValue));
        }
        return arr;
      }
      function randInt(min, max){
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function onSizeChange(){
        const n = parseInt(sizeRange.value, 10);
        const arr = makeRandomArray(n);
        initialArray = arr.slice();
        loadArray(arr, true);
        announce(`Array size set to ${n}. New random values generated.`);
      }

      function onShuffle(){
        if(running) return;
        const arr = items.map(it => it.value);
        arr.sort(() => Math.random() - 0.5);
        loadArray(arr, false);
        announce('Array shuffled.');
      }

      function onReset(){
        if(running) return;
        loadArray(initialArray.slice(), true);
        announce('Reset to initial array.');
      }

      function onApply(){
        if(running) return;
        const arr = parseArray(arrInput.value);
        if(!arr || arr.length < 1){
          updateExplain('Please enter integers separated by commas. Example: 5, 2, 9, 1');
          return;
        }
        if(arr.length > 60){
          updateExplain('For clarity, please enter 60 values or fewer.');
          return;
        }
        // Update size slider display but do not trigger change event
        sizeRange.value = String(arr.length);
        sizeLabel.textContent = String(arr.length);
        initialArray = arr.slice();
        loadArray(arr, true);
        announce('Applied custom array.');
      }

      function parseArray(text){
        if(!text) return null;
        const parts = text.split(/[,\s]+/).filter(Boolean);
        const nums = parts.map(p => Number(p));
        if(nums.some(n => !Number.isFinite(n))) return null;
        return nums.map(n => Math.floor(n));
      }

      // Rendering
      function loadArray(values, resetState){
        // Stop any running
        pause();

        // Clear chart
        chart.querySelectorAll('.bar').forEach(b => b.remove());
        items = values.map((v, idx) => {
          const el = document.createElement('div');
          el.className = 'bar';
          el.setAttribute('role', 'img');
          el.setAttribute('aria-label', `Value ${v}`);
          const lab = document.createElement('div');
          lab.className = 'label';
          lab.textContent = String(v);
          el.appendChild(lab);
          chart.appendChild(el);
          return { id: idx + '-' + Date.now(), value: v, el };
        });

        maxValue = Math.max(1, ...values);

        if(resetState){
          iPass = 0;
          jIdx = 0;
          swappedThisPass = false;
          comparisons = 0;
          swaps = 0;
        }

        updateCounters();
        clearBarStates();
        layoutBars(true);
        updateTailGuide();
        // Prefill input
        arrInput.value = values.join(', ');
        // Code highlight reset
        setActiveLines([1,2,3,4]);
        if(resetState){
          updateExplain('Array loaded. Press Step to see the first comparison, or Play to run.');
        }
        enableDataEditing(true);
      }

      function enableDataEditing(enable){
        // Guard: disable inputs while running
        arrInput.disabled = !enable;
        applyBtn.disabled = !enable;
        shuffleBtn.disabled = !enable;
        resetBtn.disabled = !enable;
        sizeRange.disabled = !enable;
      }

      function layoutBars(skipAnim){
        const n = items.length;
        const pad = 8;
        const chartWidth = chart.clientWidth - pad * 2;
        const step = chartWidth / Math.max(1, n);
        const barWidth = Math.max(Math.min(step - varPx('--bar-gap', 4), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-max-width')) || 60), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-min-width')) || 18);
        const startX = (chart.clientWidth - (barWidth * n)) / 2;

        items.forEach((it, idx) => {
          const h = Math.max(8, Math.round((it.value / maxValue) * (chart.clientHeight - 60))); // padding for labels
          it.el.style.height = `${h}px`;
          it.el.style.width = `${barWidth}px`;
          it.el.style.transform = `translateX(${Math.round(startX + idx * barWidth)}px)`;
          if(reducedMotion || skipAnim){
            it.el.style.transitionDuration = '0ms';
          } else {
            const dur = Math.round(animationMsBase / speed);
            it.el.style.transitionDuration = `${dur}ms`;
          }
        });
      }

      function varPx(name, fallback=0){
        const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return v.endsWith('px') ? parseFloat(v) : fallback;
      }

      function clearBarStates(){
        items.forEach(it => it.el.classList.remove('compare','swap','sorted'));
      }

      function markSortedTail(){
        const n = items.length;
        const tail = iPass; // after i passes, last i are sorted
        items.forEach((it, idx) => {
          if(idx >= n - tail) it.el.classList.add('sorted');
          else it.el.classList.remove('sorted');
        });
      }

      function updateTailGuide(){
        const n = items.length;
        const tail = iPass;
        const w = chart.clientWidth;
        const widthPx = Math.max(0, Math.round((tail / Math.max(1, n)) * w));
        tailGuide.style.width = `${widthPx}px`;
      }

      function setActiveLines(nums){
        // Reset
        Object.values(codeLines).forEach(el => el.classList.remove('active'));
        nums.forEach(n => codeLines[n]?.classList.add('active'));
      }

      function updateCounters(){
        passCountEl.textContent = String(iPass);
        compCountEl.textContent = String(comparisons);
        swapCountEl.textContent = String(swaps);
      }

      function updateExplain(text){
        if(!explainChk.checked) { explain.textContent = ''; return; }
        explain.textContent = text;
        live.textContent = text;
      }

      function announce(text){
        live.textContent = text;
      }

      // Execution
      function canCompare(){
        const n = items.length;
        return iPass < n && jIdx <= n - 2 - iPass;
      }

      function play(){
        if(running) return;
        running = true;
        runPassMode = false;
        enableDataEditing(false);
        loop();
        updateExplain('Running. Press Pause to stop.');
      }

      function pause(){
        running = false;
        runPassMode = false;
        if(stepTimer) { clearTimeout(stepTimer); stepTimer = null; }
        enableDataEditing(true);
        updateExplain('Paused.');
      }

      function runOnePass(){
        if(running) return;
        running = true;
        runPassMode = true;
        enableDataEditing(false);
        loop();
        updateExplain('Running one full pass...');
      }

      function step(){
        if(running) return;
        executeOneStep();
      }

      function loop(){
        if(!running) return;
        const stepDur = reducedMotion ? 0 : Math.max(120, Math.round(animationMsBase / speed));
        executeOneStep();
        stepTimer = setTimeout(loop, stepDur + 80);
      }

      function executeOneStep(){
        const n = items.length;

        // If pass or array complete
        if(iPass >= n - 1){
          finalizeSorted();
          return;
        }

        // If j beyond range, end pass
        if(jIdx > n - 2 - iPass){
          // End pass
          iPass += 1;
          markSortedTail();
          updateTailGuide();
          updateCounters();
          setActiveLines([9]); // if not swapped -> break (conceptually deciding to continue or break)
          if(earlyExit && !swappedThisPass){
            finalizeSorted(true);
            return;
          }
          // Prepare next pass
          swappedThisPass = false;
          jIdx = 0;
          setActiveLines([3,4,5]); // next pass begins
          updateExplain(`Pass ${iPass} complete. Sorted tail length is now ${iPass}.`);
          if(runPassMode){
            // If only one pass requested, stop running here
            running = false;
            runPassMode = false;
            enableDataEditing(true);
            updateExplain(`Completed 1 pass. ${iPass} element(s) fixed at the end.`);
          }
          return;
        }

        // Compare j and j+1
        const a = items[jIdx];
        const b = items[jIdx + 1];
        highlightCompare(jIdx);
        comparisons += 1;
        updateCounters();
        setActiveLines([5,6]);

        const needSwap = a.value > b.value;
        const msg = needSwap
          ? `Compare indices ${jIdx} and ${jIdx+1}: ${a.value} > ${b.value} ⇒ swap.`
          : `Compare indices ${jIdx} and ${jIdx+1}: ${a.value} ≤ ${b.value} ⇒ keep order.`;
        updateExplain(msg);

        if(needSwap){
          // Swap visuals
          a.el.classList.add('swap');
          b.el.classList.add('swap');
          performSwap(jIdx, jIdx + 1);
          swaps += 1;
          swappedThisPass = true;
          updateCounters();
          setActiveLines([7,8]);
          // After swap, advance j
          jIdx += 1;
        } else {
          // No swap, just advance
          jIdx += 1;
        }
      }

      function highlightCompare(idx){
        clearBarStates();
        const a = items[idx];
        const b = items[idx+1];
        a.el.classList.add('compare');
        b.el.classList.add('compare');
        markSortedTail();
      }

      function performSwap(i, j){
        // Swap items in array
        const tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
        // Re-layout to animate to new positions
        layoutBars(false);
        // Clear swap markers after animation
        const dur = reducedMotion ? 0 : Math.max(120, Math.round(animationMsBase / speed));
        setTimeout(() => {
          items[i]?.el.classList.remove('swap');
          items[j]?.el.classList.remove('swap');
        }, dur + 30);
      }

      function finalizeSorted(early=false){
        running = false;
        enableDataEditing(true);
        iPass = items.length - 1;
        markSortedTail();
        updateTailGuide();
        clearBarStates();
        items.forEach(it => it.el.classList.add('sorted'));
        setActiveLines([10]);
        if(early){
          updateExplain(`No swaps in last pass — array is already sorted. Finished early after ${comparisons} comparisons.`);
        } else {
          updateExplain(`Finished sorting after ${iPass} passes, ${comparisons} comparisons, ${swaps} swaps.`);
        }
        announce('Sorting complete.');
      }

      function updateSpeed(){
        speed = parseFloat(speedRange.value);
        speedLabel.textContent = `${speed.toFixed(2).replace(/\.00$/,'')}×`.replace('.00','');
        layoutBars(true);
      }

      // Start
      init();

    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a Bubble Sort interactive tutor. It models data loading, playback modes (play, pause, run one pass, step), algorithm micro-states (comparing, swapping, pass completion), visual feedback, and completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "init_app",
      "onExit": "none",
      "on": {
        "INIT_COMPLETE": "idle"
      }
    },
    {
      "name": "idle",
      "onEnter": "enable_editing_and_show_ready",
      "onExit": "none",
      "on": {
        "APPLY_CLICK": "loading_array",
        "SHUFFLE_CLICK": "loading_array",
        "RESET_CLICK": "loading_array",
        "SIZE_CHANGE": "loading_array",
        "PLAY_CLICK": "playing",
        "PASS_CLICK": "pass_running",
        "STEP_CLICK": "comparing",
        "SPEED_INPUT": "idle",
        "REDUCED_MOTION_TOGGLE": "idle",
        "EXPLAIN_TOGGLE": "idle",
        "WINDOW_RESIZE": "idle",
        "ARRAY_COMPLETE": "done"
      }
    },
    {
      "name": "loading_array",
      "onEnter": "load_array",
      "onExit": "none",
      "on": {
        "LOAD_COMPLETE": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_auto_run",
      "onExit": "stop_auto_run_and_enable_editing",
      "on": {
        "STEP_TIMER_TICK": "comparing",
        "PAUSE_CLICK": "paused",
        "WINDOW_RESIZE": "playing",
        "SPEED_INPUT": "playing",
        "REDUCED_MOTION_TOGGLE": "playing",
        "ARRAY_COMPLETE": "done",
        "EARLY_EXIT_COMPLETE": "done"
      }
    },
    {
      "name": "pass_running",
      "onEnter": "start_auto_run_one_pass",
      "onExit": "stop_auto_run_and_enable_editing",
      "on": {
        "STEP_TIMER_TICK": "comparing",
        "PAUSE_CLICK": "paused",
        "ARRAY_COMPLETE": "done",
        "EARLY_EXIT_COMPLETE": "done",
        "PASS_COMPLETE": "idle"
      }
    },
    {
      "name": "paused",
      "onEnter": "pause_execution",
      "onExit": "none",
      "on": {
        "PLAY_CLICK": "playing",
        "PASS_CLICK": "pass_running",
        "STEP_CLICK": "comparing",
        "APPLY_CLICK": "loading_array",
        "SHUFFLE_CLICK": "loading_array",
        "RESET_CLICK": "loading_array",
        "SIZE_CHANGE": "loading_array"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_compare",
      "onExit": "none",
      "on": {
        "SWAP_NEEDED": "swapping",
        "NO_SWAP": "advance_index",
        "PASS_BOUNDARY": "pass_complete",
        "ARRAY_COMPLETE": "done",
        "ADVANCE_INDEX_AUTO": "playing",
        "ADVANCE_INDEX_STEP": "idle"
      }
    },
    {
      "name": "swapping",
      "onEnter": "perform_swap",
      "onExit": "none",
      "on": {
        "SWAP_ANIMATION_COMPLETE_AUTO": "playing",
        "SWAP_ANIMATION_COMPLETE_STEP": "idle",
        "PASS_BOUNDARY": "pass_complete",
        "ARRAY_COMPLETE": "done"
      }
    },
    {
      "name": "pass_complete",
      "onEnter": "complete_pass",
      "onExit": "none",
      "on": {
        "EARLY_EXIT_COMPLETE": "done",
        "CONTINUE_AUTOPLAY": "playing",
        "STOP_AFTER_ONE_PASS": "idle"
      }
    },
    {
      "name": "advance_index",
      "onEnter": "advance_inner_index",
      "onExit": "none",
      "on": {
        "PASS_BOUNDARY": "pass_complete",
        "ARRAY_COMPLETE": "done",
        "ADVANCE_INDEX_AUTO": "playing",
        "ADVANCE_INDEX_STEP": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sorted",
      "onExit": "none",
      "on": {
        "APPLY_CLICK": "loading_array",
        "SHUFFLE_CLICK": "loading_array",
        "RESET_CLICK": "loading_array",
        "SIZE_CHANGE": "loading_array",
        "PLAY_CLICK": "playing"
      }
    }
  ],
  "events": [
    "INIT_COMPLETE",
    "APPLY_CLICK",
    "SHUFFLE_CLICK",
    "RESET_CLICK",
    "SIZE_INPUT",
    "SIZE_CHANGE",
    "PLAY_CLICK",
    "PAUSE_CLICK",
    "STEP_CLICK",
    "PASS_CLICK",
    "SPEED_INPUT",
    "REDUCED_MOTION_TOGGLE",
    "EXPLAIN_TOGGLE",
    "EARLY_EXIT_TOGGLE",
    "WINDOW_RESIZE",
    "LOAD_COMPLETE",
    "STEP_TIMER_TICK",
    "SWAP_NEEDED",
    "NO_SWAP",
    "ADVANCE_INDEX",
    "ADVANCE_INDEX_AUTO",
    "ADVANCE_INDEX_STEP",
    "SWAP_ANIMATION_COMPLETE_AUTO",
    "SWAP_ANIMATION_COMPLETE_STEP",
    "PASS_BOUNDARY",
    "PASS_COMPLETE",
    "CONTINUE_AUTOPLAY",
    "STOP_AFTER_ONE_PASS",
    "ARRAY_COMPLETE",
    "EARLY_EXIT_COMPLETE"
  ],
  "notes": "Mapping to code: init_app corresponds to init(), which seeds a random array, binds events, sets speed, and explains 'Ready'. load_array calls pause(), rebuilds bars for the provided values, optionally resets algorithm indices/counters (resetState=true for Apply/Reset/Size change; false for Shuffle), clears visual states, lays out bars, updates tail guide, highlights pseudocode lines [1,2,3,4], and enables data editing. start_auto_run and start_auto_run_one_pass correspond to play() and runOnePass(), respectively: they set running=true, disable data editing, set runPassMode accordingly, and start loop() which schedules STEP_TIMER_TICKs based on speed and reduced motion. pause_execution corresponds to pause(): running=false, runPassMode=false, step timer cleared, editing enabled, and explanation 'Paused'. comparing state mirrors highlightCompare(): clearBarStates, add 'compare' class to two bars, markSortedTail, setActiveLines([5,6]), increment comparisons and update counters, and explanation of comparison. perform_swap mirrors performSwap(): swap items, layoutBars(false) to animate, add 'swap' class to both bars, increment swaps, set swappedThisPass=true, setActiveLines([7,8]); a timer clears swap classes after animation duration, which emits SWAP_ANIMATION_COMPLETE_* depending on mode. advance_inner_index increments jIdx; in auto modes (playing/pass_running) the next STEP_TIMER_TICK will re-enter comparing; in step mode, control returns to idle immediately (ADVANCE_INDEX_STEP). pass_complete mirrors end-of-pass logic in executeOneStep(): iPass+=1, markSortedTail, updateTailGuide, updateCounters, setActiveLines([9]), and explanation 'Pass complete'. If earlyExitChk is on and swappedThisPass==false, EARLY_EXIT_COMPLETE triggers finalize_sorted(true). Otherwise, swap flag resets and jIdx=0; if runPassMode is true, STOP_AFTER_ONE_PASS returns to idle; else CONTINUE_AUTOPLAY stays in playing. finalize_sorted corresponds to finalizeSorted(early?): running=false, editing enabled, iPass set to n-1, markSortedTail, updateTailGuide, clearBarStates, add 'sorted' to all bars, setActiveLines([10]), explanation of completion (early or full), and announce 'Sorting complete.' Guards/dispatch: The app uses running and runPassMode booleans to decide whether to continue automatically or stop after one pass. Events ADVANCE_INDEX_AUTO vs ADVANCE_INDEX_STEP and SWAP_ANIMATION_COMPLETE_AUTO vs SWAP_ANIMATION_COMPLETE_STEP should be dispatched based on these flags. PASS_BOUNDARY is when jIdx exceeds n-2-iPass, checked at the start of executeOneStep; ARRAY_COMPLETE is when iPass >= n-1. Settings changes (SPEED_INPUT, REDUCED_MOTION_TOGGLE, EXPLAIN_TOGGLE, EARLY_EXIT_TOGGLE, WINDOW_RESIZE) do not change execution state; they update speed/reducedMotion/explain/earlyExit and trigger layout or message updates as self-loops on the current state. Data-editing actions are disabled during playing/pass_running via enableDataEditing(false). Visual feedback states (compare/swap/sorted) are controlled via CSS classes .compare, .swap, .sorted. The tail guide width updates each pass to reflect sorted tail length."
}
  </script>
</body>
</html>