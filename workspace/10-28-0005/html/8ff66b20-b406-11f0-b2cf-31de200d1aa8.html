<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Sort Interactive Module</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #131a22;
      --text: #e6edf3;
      --muted: #9fb2c8;
      --accent: #4fc3f7;
      --accent2: #ffb74d;
      --swap: #e57373;
      --ok: #81c784;
      --focus: #91c9ff;
      --gap: 16px;
      --margin: 24px;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    .container {
      padding: var(--margin);
      max-width: 1100px;
      margin: 0 auto;
    }
    h1, h2 {
      margin: 0 0 8px 0;
      line-height: 1.2;
    }
    p { margin: 0 0 12px 0; color: var(--muted); }
    .section {
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .small { font-size: 0.95rem; }
    ul { margin: 0; padding-left: 18px; }
    a { color: var(--accent); }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: flex-end;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }
    .control.inline { min-width: auto; }
    label { font-weight: 600; }
    input[type="text"], input[type="number"], input[type="range"], select {
      background: #0e1520;
      color: var(--text);
      border: 1px solid #2b3a4c;
      border-radius: 8px;
      padding: 10px 12px;
    }
    input[type="range"] { padding: 0; height: 32px; }
    button {
      appearance: none;
      background: #203041;
      color: var(--text);
      border: 1px solid #2b3a4c;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover { background: #273c50; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    button.primary { background: #2a4b63; border-color: #3a5f7a; }
    button.primary:hover { background: #315973; }
    .checkbox { display: flex; align-items: center; gap: 8px; }

    .viz {
      position: relative;
      background: #0e1520;
      border: 1px solid #2b3a4c;
      border-radius: 12px;
      height: 280px;
      padding: 12px;
      overflow: hidden;
    }
    .bar-area {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .bar {
      position: absolute;
      bottom: 0;
      background: #355e7a;
      border-radius: 8px 8px 0 0;
      transition: left 320ms ease, background-color 160ms ease;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }
    .bar span {
      position: absolute;
      bottom: -24px;
      font-weight: 700;
      color: var(--text);
    }
    .bar.compare { background: var(--accent2); }
    .bar.swap { background: var(--swap); }
    .bar.sorted { background: var(--ok); }
    .bar.dragging { opacity: 0.8; outline: 2px dashed var(--accent); }
    .bar:focus-visible { outline: 3px solid var(--focus); outline-offset: 2px; }
    @keyframes pulse {
      0% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }
    .bar.pulse { animation: pulse 140ms ease; }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 8px;
    }
    .metric {
      background: #0e1520;
      border: 1px solid #2b3a4c;
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 120px;
    }
    .metric strong { display: block; font-size: 0.9rem; color: var(--muted); }
    .metric .value { font-size: 1.2rem; font-weight: 700; }

    .annotation {
      margin-top: 8px;
      color: var(--muted);
    }
    footer {
      margin-top: 16px;
      color: var(--muted);
    }
    @media (max-width: 640px) {
      .control { min-width: 100%; }
      .viz { height: 240px; }
    }
    .visually-hidden {
      position: absolute !important;
      height: 1px; width: 1px; overflow: hidden;
      clip: rect(1px,1px,1px,1px); white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <section class="section">
      <h1>Bubble Sort — See comparisons bubble the largest to the end</h1>

      <div class="small">
        <h2>Learning Objective</h2>
        <p>After interacting, you will be able to:</p>
        <ul>
          <li>Explain how bubble sort compares adjacent items and swaps when out of order.</li>
          <li>Describe passes, comparisons, and the sorted boundary that grows from the right.</li>
          <li>Step through the algorithm to observe when swaps occur and why early exit optimization works.</li>
        </ul>

        <h2>Interaction Design</h2>
        <ul>
          <li>Type numbers or randomize to create an array. Drag bars to rearrange values before sorting.</li>
          <li>Press Play to auto-run bubble sort; use Step to advance one comparison at a time. Bars animate:
            compared pairs highlight amber; swaps slide horizontally; the rightmost sorted region turns green at the end of each pass.</li>
          <li>Toggle Early Exit to stop when a full pass makes no swaps. Adjust speed; Pause to reflect; Reset any time.</li>
          <li>Keyboard: Space toggles Play/Pause, Enter performs a Step. Screen reader users hear status updates for comparisons and swaps.</li>
        </ul>

        <h2>Layout Description</h2>
        <ul>
          <li>Safe area padding is 24 px on all sides; interactive controls use a 16 px gap for clear spacing.</li>
          <li>Top section presents title and objectives. Below, the control panel sits above the visualization. Metrics appear under the visualization.</li>
          <li>Responsive: controls wrap on small screens; bars scale to container width and height. Accessible labels, focus outlines, and ARIA live status are provided.</li>
        </ul>
      </div>
    </section>

    <section class="section" aria-label="Bubble sort interactive module">
      <div class="controls" aria-label="Controls">
        <div class="control" style="flex:1 1 260px;">
          <label for="numbersInput">Numbers (comma-separated, 3–12 items, values -99–99)</label>
          <input id="numbersInput" type="text" value="9, 4, 7, 3, 1, 5" aria-describedby="numbersHelp" />
          <div id="numbersHelp" class="status">Example: 9,4,7,3,1,5. You can also drag bars to reorder before sorting.</div>
        </div>

        <div class="control inline">
          <label class="visually-hidden" for="loadBtn">Load Numbers</label>
          <button id="loadBtn" class="primary">Load Numbers</button>
        </div>

        <div class="control inline">
          <label class="visually-hidden" for="randomBtn">Randomize</label>
          <button id="randomBtn">Randomize</button>
        </div>

        <div class="control" style="min-width:240px;">
          <label for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="1" max="5" value="3" aria-valuetext="Speed: medium" />
        </div>

        <div class="control inline">
          <label class="visually-hidden" for="playBtn">Play</label>
          <button id="playBtn" class="primary">Play</button>
        </div>

        <div class="control inline">
          <label class="visually-hidden" for="stepBtn">Step</label>
          <button id="stepBtn">Step</button>
        </div>

        <div class="control inline">
          <label class="visually-hidden" for="resetBtn">Reset</label>
          <button id="resetBtn">Reset</button>
        </div>

        <div class="control inline">
          <div class="checkbox">
            <input id="earlyExit" type="checkbox" checked />
            <label for="earlyExit">Early Exit Optimization</label>
          </div>
        </div>
      </div>

      <div class="viz" aria-label="Visualization">
        <div class="bar-area" id="barArea" role="list" aria-label="Array bars"></div>
      </div>

      <div class="metrics" aria-label="Metrics">
        <div class="metric">
          <strong>Pass</strong>
          <div class="value" id="passCount">0</div>
        </div>
        <div class="metric">
          <strong>Comparison</strong>
          <div class="value" id="compCount">0</div>
        </div>
        <div class="metric">
          <strong>Swaps</strong>
          <div class="value" id="swapCount">0</div>
        </div>
        <div class="metric">
          <strong>Sorted boundary</strong>
          <div class="value" id="sortedBoundary">None</div>
        </div>
      </div>

      <div class="annotation" id="annotation">
        Tip: Click Play or press Space to watch values bubble to the end. Use Step to examine each comparison.
      </div>

      <div id="liveStatus" class="visually-hidden" aria-live="polite" aria-atomic="true"></div>
    </section>

    <footer class="section">
      Controls maintain at least 16 px spacing; the page uses a 24 px safe margin. This module demonstrates only bubble sort.
    </footer>
  </div>

  <script>
    (function() {
      const barArea = document.getElementById('barArea');
      const numbersInput = document.getElementById('numbersInput');
      const loadBtn = document.getElementById('loadBtn');
      const randomBtn = document.getElementById('randomBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedRange = document.getElementById('speedRange');
      const earlyExitChk = document.getElementById('earlyExit');

      const passCountEl = document.getElementById('passCount');
      const compCountEl = document.getElementById('compCount');
      const swapCountEl = document.getElementById('swapCount');
      const sortedBoundaryEl = document.getElementById('sortedBoundary');
      const annotationEl = document.getElementById('annotation');
      const liveStatus = document.getElementById('liveStatus');

      let data = [9, 4, 7, 3, 1, 5];
      let bars = [];
      let isSorting = false;
      let isAuto = false;
      let autoTimer = null;
      let speedMs = 450;
      let n = 0;

      // bubble sort state
      let iPass = 0;
      let jComp = 0;
      let swappedInPass = false;

      let comparisons = 0;
      let swaps = 0;

      function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

      function parseInput(str) {
        const parts = str.split(/[\s,]+/).filter(Boolean);
        if (parts.length < 3 || parts.length > 12) {
          return { error: 'Please enter between 3 and 12 numbers.' };
        }
        const nums = [];
        for (let p of parts) {
          if (!/^-?\d+$/.test(p)) return { error: 'Use integers only (e.g., 9,4,7,3,1).' };
          const v = parseInt(p, 10);
          if (Math.abs(v) > 99) return { error: 'Values should be between -99 and 99.' };
          nums.push(v);
        }
        return { nums };
      }

      function randomArray() {
        const len = Math.floor(Math.random() * 6) + 6; // 6-11
        const arr = [];
        for (let k = 0; k < len; k++) {
          arr.push(Math.floor(Math.random() * 95) + 5); // 5-99
        }
        return arr;
      }

      function announce(msg) { liveStatus.textContent = msg; }

      function resetState() {
        isSorting = false;
        isAuto = false;
        clearInterval(autoTimer);
        autoTimer = null;
        iPass = 0;
        jComp = 0;
        swappedInPass = false;
        comparisons = 0;
        swaps = 0;
        updateMetrics();
        playBtn.textContent = 'Play';
        annotationEl.textContent = 'Tip: Click Play or press Space to watch values bubble to the end. Use Step to examine each comparison.';
        enableControls(true);
        bars.forEach(b => b.classList.remove('compare', 'swap', 'sorted', 'dragging'));
        updateSortedBoundary();
      }

      function enableControls(enabled) {
        numbersInput.disabled = !enabled;
        loadBtn.disabled = !enabled;
        randomBtn.disabled = !enabled;
        resetBtn.disabled = false;
      }

      function initData(arr) {
        data = arr.slice();
        n = data.length;
        renderBars();
        layoutBars();
        resetState();
      }

      function valueToHeight(val) {
        const absMax = Math.max(...data.map(v => Math.abs(v))) || 1;
        const pct = Math.abs(val) / absMax;
        const maxHeight = barArea.clientHeight - 32;
        const h = clamp(Math.floor(maxHeight * (0.2 + 0.8 * pct)), 24, maxHeight);
        return h;
      }

      function renderBars() {
        barArea.innerHTML = '';
        bars = [];
        for (let idx = 0; idx < data.length; idx++) {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role', 'listitem');
          bar.setAttribute('tabindex', '0');
          bar.dataset.index = idx;
          bar.draggable = true;

          const label = document.createElement('span');
          label.textContent = data[idx];
          bar.appendChild(label);

          barArea.appendChild(bar);
          bars.push(bar);

          bar.addEventListener('dragstart', dragStart);
          bar.addEventListener('dragend', dragEnd);
          bar.addEventListener('dragover', dragOver);
          bar.addEventListener('drop', dragDrop);

          bar.addEventListener('keydown', (e) => {
            if (!isSorting && (e.key === 'Enter' || e.key === ' ')) {
              e.preventDefault();
              editBarValue(bar);
            }
          });
          bar.addEventListener('click', () => { if (!isSorting) editBarValue(bar); });
        }
      }

      function editBarValue(bar) {
        const idx = parseInt(bar.dataset.index, 10);
        const current = data[idx];
        const newVal = prompt('Enter a new integer value for this bar (-99 to 99):', current);
        if (newVal === null) return;
        const parsed = parseInt(newVal, 10);
        if (Number.isNaN(parsed) || Math.abs(parsed) > 99) {
          alert('Invalid value. Please enter an integer between -99 and 99.');
          return;
        }
        data[idx] = parsed;
        bar.querySelector('span').textContent = parsed;
        layoutBars();
        resetState();
      }

      function layoutBars() {
        const areaWidth = barArea.clientWidth;
        const gap = 8;
        const barWidth = Math.max(24, Math.floor((areaWidth - gap * (n - 1)) / n));
        for (let i = 0; i < n; i++) {
          const bar = bars[i];
          const val = data[i];
          const left = i * (barWidth + gap);
          const height = valueToHeight(val);
          bar.style.width = barWidth + 'px';
          bar.style.left = left + 'px';
          bar.style.height = height + 'px';
          bar.querySelector('span').textContent = val;
        }
      }

      window.addEventListener('resize', layoutBars);

      // Drag-and-drop to reorder before sorting
      function dragStart(e) {
        if (isSorting) { e.preventDefault(); return; }
        const bar = e.currentTarget;
        bar.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', bar.dataset.index);
      }
      function dragEnd(e) {
        const bar = e.currentTarget;
        bar.classList.remove('dragging');
      }
      function dragOver(e) {
        if (isSorting) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }
      function dragDrop(e) {
        if (isSorting) return;
        e.preventDefault();
        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'), 10);
        const toIdx = parseInt(e.currentTarget.dataset.index, 10);
        if (fromIdx === toIdx || Number.isNaN(fromIdx) || Number.isNaN(toIdx)) return;
        const val = data[fromIdx];
        data.splice(fromIdx, 1);
        data.splice(toIdx, 0, val);
        initData(data);
      }

      // Sorting controls
      loadBtn.addEventListener('click', () => {
        const { nums, error } = parseInput(numbersInput.value);
        if (error) {
          annotationEl.textContent = error;
          announce(error);
          return;
        }
        initData(nums);
        annotationEl.textContent = 'Loaded numbers. Drag bars to adjust, then Play or Step through bubble sort.';
        announce('Numbers loaded.');
      });

      randomBtn.addEventListener('click', () => {
        const arr = randomArray();
        numbersInput.value = arr.join(', ');
        initData(arr);
        annotationEl.textContent = 'Randomized numbers. Press Play or Step to begin.';
        announce('Random array generated.');
      });

      resetBtn.addEventListener('click', () => {
        initData(data.slice());
        annotationEl.textContent = 'Reset. Array restored to current order; sorting state cleared.';
        announce('Reset complete.');
      });

      speedRange.addEventListener('input', () => {
        const level = parseInt(speedRange.value, 10);
        const map = { 1: 800, 2: 600, 3: 450, 4: 320, 5: 220 };
        speedMs = map[level] || 450;
        speedRange.setAttribute('aria-valuetext', 'Speed: ' + (['very slow','slow','medium','fast','very fast'][level-1]));
        if (isAuto) {
          clearInterval(autoTimer);
          autoTimer = setInterval(autoStep, speedMs + 160);
        }
      });

      playBtn.addEventListener('click', togglePlay);
      stepBtn.addEventListener('click', () => {
        if (!isSorting) startSorting();
        performStep();
      });

      document.addEventListener('keydown', (e) => {
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if (e.key === ' ') {
          e.preventDefault();
          togglePlay();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (!isSorting) startSorting();
          performStep();
        }
      });

      function togglePlay() {
        if (!isSorting) startSorting();
        isAuto = !isAuto;
        playBtn.textContent = isAuto ? 'Pause' : 'Play';
        if (isAuto) {
          autoTimer = setInterval(autoStep, speedMs + 160);
        } else {
          clearInterval(autoTimer);
        }
      }

      function startSorting() {
        isSorting = true;
        enableControls(false);
        annotationEl.textContent = 'Sorting in progress: comparing adjacent values and swapping if out of order.';
        announce('Bubble sort started.');
      }

      function autoStep() {
        if (!isSorting) return;
        const done = performStep();
        if (done) {
          clearInterval(autoTimer);
          isAuto = false;
          playBtn.textContent = 'Play';
        }
      }

      function performStep() {
        if (iPass >= n - 1) {
          finishSorting();
          return true;
        }

        if (jComp >= n - 1 - iPass) {
          const sortedIdx = n - 1 - iPass;
          for (let b = sortedIdx; b < n; b++) bars[b].classList.add('sorted');
          passCountEl.textContent = iPass + 1;
          if (earlyExitChk.checked && !swappedInPass) {
            annotationEl.textContent = 'Early exit: no swaps in the last pass, array is sorted.';
            announce('Early exit used.');
            finishSorting();
            return true;
          }
          swappedInPass = false;
          iPass++;
          jComp = 0;
          updateSortedBoundary();
          return false;
        }

        const a = data;
        const leftIdx = jComp;
        const rightIdx = jComp + 1;

        clearCompareSwap();
        bars[leftIdx].classList.add('compare');
        bars[rightIdx].classList.add('compare');

        const L = a[leftIdx];
        const R = a[rightIdx];
        comparisons++;
        compCountEl.textContent = comparisons;
        announce(`Compare positions ${leftIdx} and ${rightIdx}: ${L} vs ${R}.`);

        setTimeout(() => {
          if (L > R) {
            doSwap(leftIdx, rightIdx);
            swappedInPass = true;
          } else {
            bars[leftIdx].classList.add('pulse');
            bars[rightIdx].classList.add('pulse');
            setTimeout(() => {
              bars[leftIdx].classList.remove('pulse');
              bars[rightIdx].classList.remove('pulse');
            }, 140);
          }

          jComp++;
          updateSortedBoundary();

          setTimeout(clearCompareSwap, 140);
        }, 160);

        return false;
      }

      function clearCompareSwap() {
        bars.forEach(b => b.classList.remove('compare', 'swap'));
      }

      function doSwap(idxA, idxB) {
        const barA = bars[idxA];
        const barB = bars[idxB];
        barA.classList.add('swap');
        barB.classList.add('swap');

        const tmp = data[idxA];
        data[idxA] = data[idxB];
        data[idxB] = tmp;

        bars[idxA] = barB;
        bars[idxB] = barA;
        barA.dataset.index = idxB;
        barB.dataset.index = idxA;

        const areaWidth = barArea.clientWidth;
        const gap = 8;
        const barWidth = Math.max(24, Math.floor((areaWidth - gap * (n - 1)) / n));
        const leftA = idxA * (barWidth + gap);
        const leftB = idxB * (barWidth + gap);
        barA.style.left = leftB + 'px';
        barB.style.left = leftA + 'px';

        swaps++;
        swapCountEl.textContent = swaps;
        announce(`Swapped: ${data[idxB]} moved left, ${data[idxA]} moved right.`);
      }

      function finishSorting() {
        isSorting = false;
        isAuto = false;
        playBtn.textContent = 'Play';
        clearInterval(autoTimer);
        bars.forEach(b => b.classList.add('sorted'));
        annotationEl.textContent = 'Done! Each pass bubbled the largest item to the right. The array is sorted.';
        announce('Sorting complete.');
        enableControls(true);
      }

      function updateMetrics() {
        passCountEl.textContent = iPass;
        compCountEl.textContent = comparisons;
        swapCountEl.textContent = swaps;
        updateSortedBoundary();
      }
      function updateSortedBoundary() {
        if (iPass === 0) {
          sortedBoundaryEl.textContent = 'None';
        } else {
          sortedBoundaryEl.textContent = '≥ index ' + (n - iPass);
        }
      }

      initData(data);
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a Bubble Sort interactive module, covering array setup, drag/edit interactions, play/step sorting flow, visual comparison/swapping feedback, pass completion, early-exit behavior, and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "setupIdleUI",
      "on": {
        "LOAD_CLICK": "loading_numbers",
        "RANDOMIZE_CLICK": "randomizing",
        "RESET_CLICK": "resetting",
        "DRAG_START": "dragging",
        "EDIT_BAR": "editing_value",
        "PLAY_TOGGLE": "sorting_playing",
        "KEY_PLAY_TOGGLE": "sorting_playing",
        "STEP": "comparing",
        "KEY_STEP": "comparing",
        "SPEED_CHANGE": "idle",
        "EARLY_EXIT_TOGGLE": "idle",
        "RESIZE": "idle"
      }
    },
    {
      "name": "loading_numbers",
      "onEnter": "applyLoadNumbers",
      "on": {
        "LOAD_VALID": "idle",
        "LOAD_INVALID": "idle"
      }
    },
    {
      "name": "randomizing",
      "onEnter": "applyRandomize",
      "on": {
        "RANDOMIZE_DONE": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "applyReset",
      "on": {
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "addDraggingVisual",
      "onExit": "removeDraggingVisual",
      "on": {
        "DRAG_DROP": "idle",
        "DRAG_CANCEL": "idle"
      }
    },
    {
      "name": "editing_value",
      "onEnter": "applyEditValue",
      "on": {
        "EDIT_COMMIT": "idle",
        "EDIT_CANCEL": "idle"
      }
    },
    {
      "name": "sorting_playing",
      "onEnter": "beginSortingPlaying",
      "onExit": "stopAutoTimer",
      "on": {
        "AUTOSTEP_TICK": "comparing",
        "READY_FINISH": "done",
        "PLAY_TOGGLE": "sorting_paused",
        "KEY_PLAY_TOGGLE": "sorting_paused",
        "SPEED_CHANGE": "sorting_playing",
        "EARLY_EXIT_TOGGLE": "sorting_playing",
        "RESET_CLICK": "resetting",
        "RESIZE": "sorting_playing"
      }
    },
    {
      "name": "sorting_paused",
      "onEnter": "ensureSortingPaused",
      "on": {
        "STEP": "comparing",
        "KEY_STEP": "comparing",
        "READY_FINISH": "done",
        "PLAY_TOGGLE": "sorting_playing",
        "KEY_PLAY_TOGGLE": "sorting_playing",
        "SPEED_CHANGE": "sorting_paused",
        "EARLY_EXIT_TOGGLE": "sorting_paused",
        "RESET_CLICK": "resetting",
        "RESIZE": "sorting_paused"
      }
    },
    {
      "name": "comparing",
      "onEnter": "prepareComparison",
      "on": {
        "COMPARE_DECIDED_SWAP": "swapping",
        "COMPARE_DECIDED_NO_SWAP": "no_swap_feedback"
      }
    },
    {
      "name": "swapping",
      "onEnter": "performSwap",
      "on": {
        "ADVANCE": "advancing"
      }
    },
    {
      "name": "no_swap_feedback",
      "onEnter": "showNoSwapPulse",
      "on": {
        "ADVANCE": "advancing"
      }
    },
    {
      "name": "advancing",
      "onEnter": "advancePointer",
      "on": {
        "PASS_BOUNDARY_REACHED": "pass_complete",
        "ADVANCE_READY_AUTOPLAY": "sorting_playing",
        "ADVANCE_READY_PAUSED": "sorting_paused"
      }
    },
    {
      "name": "pass_complete",
      "onEnter": "completePassUpdate",
      "on": {
        "EARLY_EXIT_TRIGGER": "done",
        "CONTINUE_AUTOPLAY": "sorting_playing",
        "CONTINUE_MANUAL": "sorting_paused"
      }
    },
    {
      "name": "done",
      "onEnter": "completeSorting",
      "on": {
        "RESET_CLICK": "resetting",
        "LOAD_CLICK": "loading_numbers",
        "RANDOMIZE_CLICK": "randomizing",
        "DRAG_START": "dragging",
        "EDIT_BAR": "editing_value",
        "PLAY_TOGGLE": "sorting_playing",
        "KEY_PLAY_TOGGLE": "sorting_playing",
        "SPEED_CHANGE": "done",
        "EARLY_EXIT_TOGGLE": "done",
        "RESIZE": "done"
      }
    }
  ],
  "events": [
    "LOAD_CLICK",
    "LOAD_VALID",
    "LOAD_INVALID",
    "RANDOMIZE_CLICK",
    "RANDOMIZE_DONE",
    "RESET_CLICK",
    "RESET_DONE",
    "DRAG_START",
    "DRAG_DROP",
    "DRAG_CANCEL",
    "EDIT_BAR",
    "EDIT_COMMIT",
    "EDIT_CANCEL",
    "PLAY_TOGGLE",
    "KEY_PLAY_TOGGLE",
    "STEP",
    "KEY_STEP",
    "AUTOSTEP_TICK",
    "SPEED_CHANGE",
    "EARLY_EXIT_TOGGLE",
    "RESIZE",
    "READY_FINISH",
    "COMPARE_DECIDED_SWAP",
    "COMPARE_DECIDED_NO_SWAP",
    "ADVANCE",
    "PASS_BOUNDARY_REACHED",
    "ADVANCE_READY_AUTOPLAY",
    "ADVANCE_READY_PAUSED",
    "CONTINUE_AUTOPLAY",
    "CONTINUE_MANUAL",
    "EARLY_EXIT_TRIGGER"
  ],
  "notes": "State/action mappings to implementation:\n- setupIdleUI: mirrors resetState(), which clears sorting flags, updates metrics, enables controls, sets annotation to the tip, removes compare/swap/sorted/dragging classes, updates sorted boundary, play button 'Play'. Entered after initData() and after any load/randomize/reset/edit completes.\n- applyLoadNumbers: handles Load Numbers button. Calls parseInput() on numbersInput; on validation error, sets annotation and announces error then emit LOAD_INVALID; on success, initData(nums), sets annotation 'Loaded numbers...' and announces 'Numbers loaded.', then emit LOAD_VALID.\n- applyRandomize: creates random array with randomArray(), updates input field, calls initData(arr), sets annotation and announces 'Random array generated.', then emit RANDOMIZE_DONE.\n- applyReset: calls initData(data.slice()) to restore current order and clear sorting state, sets annotation 'Reset...' and announces 'Reset complete.', then emit RESET_DONE.\n- addDraggingVisual/removeDraggingVisual: add/remove 'dragging' class on the dragged bar; on DRAG_DROP, reorder data by splicing and call initData(data) to re-render and return to idle. Dragging is disabled while sorting (isSorting check prevents handlers).\n- applyEditValue: prompts user to edit a bar value (editBarValue()), validates (-99..99), updates data, bar label, calls layoutBars(), and then resetState(); either commits (EDIT_COMMIT) or cancels (EDIT_CANCEL) and returns to idle.\n- beginSortingPlaying: if first time this session (!isSorting), call startSorting() to set isSorting true, disable controls, set annotation 'Sorting in progress...' and announce 'Bubble sort started.'; set isAuto true, update play button to 'Pause', and start autoTimer at (speedMs + 160). SPEED_CHANGE while playing resets the interval accordingly.\n- stopAutoTimer: clears autoTimer; used when leaving sorting_playing (e.g., pause or reset).\n- ensureSortingPaused: represents sorting active (isSorting true) with auto-run paused (isAuto false). In practice, reached after toggling pause or after completing a step when not auto-running; play button shows 'Play'.\n- prepareComparison: performs one comparison step preface from performStep(): clears prior compare/swap classes (clearCompareSwap), highlights the two bars (add 'compare'), increments comparisons and updates compCount, and announces 'Compare positions i and j: L vs R.'. After ~160ms, decide: if L>R emit COMPARE_DECIDED_SWAP; else emit COMPARE_DECIDED_NO_SWAP.\n- performSwap: executes doSwap(idxA, idxB): applies 'swap' classes, swaps data and bars, animates left positions, increments swap counter and announces swap, and marks swappedInPass=true. Immediately emit ADVANCE (no need to wait for CSS transition end; code continues without it).\n- showNoSwapPulse: adds 'pulse' animation to both bars for visual feedback, schedules removal after 140ms. Immediately emit ADVANCE.\n- advancePointer: increments jComp, calls updateSortedBoundary(), schedules clearCompareSwap() after ~140ms. If jComp >= n-1-iPass emit PASS_BOUNDARY_REACHED; else emit ADVANCE_READY_AUTOPLAY if isAuto, or ADVANCE_READY_PAUSED if manual.\n- completePassUpdate: at pass boundary (jComp >= n-1-iPass), marks rightmost region [n-1-iPass .. n-1] as 'sorted', updates passCount. If earlyExit is enabled and swappedInPass==false, sets annotation 'Early exit...' and announces, then emit EARLY_EXIT_TRIGGER. Otherwise resets swappedInPass=false, increments iPass++, resets jComp=0, updates boundary; then emit CONTINUE_AUTOPLAY if isAuto else CONTINUE_MANUAL.\n- completeSorting: mirrors finishSorting(): sets isSorting=false and isAuto=false, clears autoTimer, sets play button 'Play', adds 'sorted' class to all bars, enables controls, sets completion annotation and announces 'Sorting complete.'.\n- Global/UI behaviors: RESIZE triggers layoutBars() but does not change states (self-transitions). SPEED_CHANGE updates speedMs; if in sorting_playing, the interval is restarted with new delay. EARLY_EXIT_TOGGLE is a configuration toggle stored in checkbox; it does not change state but affects pass-complete decisions.\n- Keyboard: Space triggers PLAY_TOGGLE; Enter triggers STEP. If focus is in an input/textarea, these are ignored by code.\n- Done detection: If iPass >= n-1 at the start of a step, performStep() calls finishSorting() immediately. This is modeled with READY_FINISH from sorting_playing/sorting_paused to done.\n- Visual feedback states: 'comparing' applies amber highlight; 'swapping' applies red and moves bars; 'no_swap_feedback' pulses bars; 'pass_complete' marks right boundary green; 'done' marks all bars green. Duration hints: compare decision delayed ~160ms; pulse clears after ~140ms; swap left-position CSS transitions are 320ms but logic advances without waiting."
}
  </script>
</body>
</html>