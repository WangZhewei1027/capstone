<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Interactive Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bar-gap: 12px;
      --bar-border-radius: 6px;
      --bg: #0f172a;
      --panel: #111827;
      --card: #1f2937;
      --text: #f9fafb;
      --muted: #cbd5e1;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --warn: #f97316;
      --danger: #ef4444;
      --compare: #fde047;
      --focus: #a78bfa;
    }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
    }
    body {
      margin: 0;
      padding: var(--safe-margin);
      box-sizing: border-box;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    header {
      margin-bottom: 16px;
    }
    h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      line-height: 1.2;
    }
    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }
    .card {
      background: var(--card);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 1px 0 rgba(255,255,255,0.04), 0 24px 64px rgba(0,0,0,0.3);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: flex-end;
      margin-bottom: var(--gap);
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 220px;
      flex: 1;
    }
    label {
      font-size: 13px;
      color: var(--muted);
    }
    input[type="text"] {
      background: var(--panel);
      color: var(--text);
      border: 1px solid #374151;
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
    }
    input[type="text"]:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.25);
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }
    button {
      background: #334155;
      color: var(--text);
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover {
      background: #3b4a61;
    }
    button:active {
      transform: translateY(1px);
    }
    button:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    .btn-primary {
      background: var(--accent);
      color: #0b1020;
    }
    .btn-primary:hover {
      background: #4f92ee;
    }
    .btn-danger {
      background: var(--danger);
    }
    .btn-danger:hover {
      background: #d83d3d;
    }
    .btn-secondary {
      background: #374151;
    }
    .inline {
      display: flex;
      gap: var(--gap);
      align-items: center;
    }
    .slider-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    input[type="range"] {
      width: 180px;
      accent-color: var(--accent);
    }
    .checkbox-group {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 14px;
    }
    .viz {
      margin-top: var(--gap);
    }
    .bars {
      position: relative;
      height: 280px;
      background: var(--panel);
      border: 1px solid #374151;
      border-radius: 12px;
      overflow: hidden;
    }
    .bar {
      position: absolute;
      bottom: 36px;
      left: 0;
      transform: translateX(0);
      transition: transform var(--move-duration, 300ms) ease, filter 120ms ease;
      width: var(--bar-width, 60px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .bar-rect {
      width: 100%;
      background: #3b82f6;
      border-radius: var(--bar-border-radius);
      height: var(--bar-height, 80px);
      transition: height 220ms ease, background 120ms ease, transform 200ms ease;
      box-shadow: inset 0 -6px 0 rgba(255,255,255,0.08);
    }
    .bar-label {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      user-select: none;
    }
    .bar.compare .bar-rect {
      background: var(--compare);
      filter: drop-shadow(0 0 8px rgba(253, 224, 71, 0.4));
    }
    .bar.swap .bar-rect {
      background: var(--danger);
      filter: drop-shadow(0 0 8px rgba(239, 68, 68, 0.45));
    }
    .bar.sorted .bar-rect {
      background: var(--accent-2);
      filter: none;
      opacity: 0.9;
    }
    .legend {
      display: flex;
      gap: 24px;
      align-items: center;
      padding: 10px 12px;
      color: var(--muted);
      font-size: 13px;
    }
    .legend-item {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .pill {
      width: 18px;
      height: 10px;
      border-radius: 6px;
      display: inline-block;
      background: #3b82f6;
    }
    .pill.compare { background: var(--compare); }
    .pill.swap { background: var(--danger); }
    .pill.sorted { background: var(--accent-2); }

    .status {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: var(--gap);
      margin-top: var(--gap);
    }
    .status-item {
      background: var(--panel);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 12px;
      font-size: 14px;
      color: var(--muted);
    }
    .status-item strong {
      display: block;
      color: var(--text);
      font-size: 16px;
      margin-bottom: 6px;
    }
    .assist {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }
    .sr-live {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }

    details {
      margin-top: 24px;
      background: var(--panel);
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 12px 16px;
    }
    summary {
      cursor: pointer;
      font-weight: 600;
    }
    .info-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .info-block h3 {
      margin: 0 0 6px 0;
      font-size: 18px;
    }
    .info-block p, .info-block ul {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }
    .info-block ul {
      padding-left: 18px;
    }

    @media (min-width: 860px) {
      .info-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Keep at least 16px spacing between interactive elements */
    .controls .control-group,
    .controls .button-row,
    .controls .inline {
      margin-bottom: 0; /* gap handles spacing */
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <h1>Bubble Sort Interactive Lab</h1>
      <div class="subtitle">Explore adjacent comparisons, swaps, and the pass-by-pass "bubbling" effect with visual feedback.</div>
    </header>

    <section class="card" aria-label="Interactive Bubble Sort Module">
      <div class="controls" aria-label="Controls">
        <div class="control-group">
          <label for="dataInput">Data (numbers separated by commas or spaces)</label>
          <input id="dataInput" type="text" placeholder="e.g., 5, 3, 8, 1, 4, 7, 2, 6" aria-label="Enter numbers to sort" />
        </div>
        <div class="button-row" role="group" aria-label="Data actions">
          <button id="setDataBtn" class="btn-primary">Set Data</button>
          <button id="randomBtn" class="btn-secondary">Randomize</button>
          <button id="shuffleBtn" class="btn-secondary">Shuffle</button>
          <button id="resetBtn" class="btn-danger">Reset</button>
        </div>
        <div class="inline">
          <div class="slider-group" aria-label="Animation speed">
            <label for="speedRange">Speed</label>
            <input id="speedRange" type="range" min="0.25" max="2.5" step="0.25" value="1" />
            <span id="speedLabel" aria-live="polite">1.0×</span>
          </div>
          <div class="checkbox-group">
            <input id="earlyExit" type="checkbox" />
            <label for="earlyExit">Early exit optimization</label>
          </div>
        </div>
        <div class="button-row" role="group" aria-label="Playback controls">
          <button id="stepBtn" class="btn-primary">Step</button>
          <button id="playBtn">Play</button>
          <button id="pauseBtn">Pause</button>
        </div>
      </div>

      <div class="viz">
        <div class="legend" aria-hidden="false">
          <span class="legend-item"><span class="pill"></span> Default</span>
          <span class="legend-item"><span class="pill compare"></span> Comparing</span>
          <span class="legend-item"><span class="pill swap"></span> Swapping</span>
          <span class="legend-item"><span class="pill sorted"></span> Sorted zone</span>
        </div>
        <div id="bars" class="bars" aria-label="Bar visualization of array"></div>
        <div class="assist">Tip: Press Space to Play/Pause, and S to Step. The rightmost green region grows each pass—largest elements settle there.</div>
      </div>

      <div class="status" aria-label="Sorting status">
        <div class="status-item">
          <strong>Current Pass</strong>
          <div>Pass <span id="passNum">0</span> of <span id="passTotal">0</span></div>
        </div>
        <div class="status-item">
          <strong>Comparing Indices</strong>
          <div><span id="compareIndices">–</span></div>
        </div>
        <div class="status-item">
          <strong>Comparisons</strong>
          <div id="comparisonCount">0</div>
        </div>
        <div class="status-item">
          <strong>Swaps</strong>
          <div id="swapCount">0</div>
        </div>
        <div class="status-item">
          <strong>Array</strong>
          <div id="arrayText">[]</div>
        </div>
      </div>
      <div id="live" class="sr-live" aria-live="polite"></div>
    </section>

    <details>
      <summary>About this module</summary>
      <div class="info-grid">
        <div class="info-block">
          <h3>Concept Title</h3>
          <p>Bubble Sort: Adjacent comparisons and swaps across passes.</p>
        </div>
        <div class="info-block">
          <h3>Learning Objective</h3>
          <p>After interacting, you should be able to:
          </p>
          <ul>
            <li>Describe how bubble sort repeatedly compares adjacent elements, swapping when needed.</li>
            <li>Explain why the largest unsorted element moves to the end each pass.</li>
            <li>Recognize the early-exit optimization when a pass performs no swaps.</li>
          </ul>
        </div>
        <div class="info-block">
          <h3>Interaction Design</h3>
          <p>
            Type custom numbers or randomize/shuffle the list. Use Step to run one comparison (with swap if needed) or Play to animate continuously at your chosen speed. Current pairs glow yellow (compare), swaps flash red, and the rightmost sorted zone turns green at the end of each pass. Status panels update live with indices, pass counts, comparisons, and swaps. Keyboard shortcuts: Space to Play/Pause, S to Step.
          </p>
        </div>
        <div class="info-block">
          <h3>Layout Description</h3>
          <p>
            The page maintains 24 px safe margins. Controls are grouped with at least 16 px spacing between interactive elements. The bar visualization sits beneath controls for focus, with a concise legend and live status panels below. Elements are responsive; bars and text adjust to viewport width while preserving accessibility (focus styles, ARIA labels, and live announcements).
          </p>
        </div>
      </div>
    </details>
  </div>

  <script>
    // Utility
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => document.querySelectorAll(sel);
    const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

    // DOM refs
    const barsEl = $("#bars");
    const dataInput = $("#dataInput");
    const setDataBtn = $("#setDataBtn");
    const randomBtn = $("#randomBtn");
    const shuffleBtn = $("#shuffleBtn");
    const resetBtn = $("#resetBtn");
    const speedRange = $("#speedRange");
    const speedLabel = $("#speedLabel");
    const earlyExitChk = $("#earlyExit");
    const stepBtn = $("#stepBtn");
    const playBtn = $("#playBtn");
    const pauseBtn = $("#pauseBtn");

    const passNumEl = $("#passNum");
    const passTotalEl = $("#passTotal");
    const compareIndicesEl = $("#compareIndices");
    const comparisonCountEl = $("#comparisonCount");
    const swapCountEl = $("#swapCount");
    const arrayTextEl = $("#arrayText");
    const liveEl = $("#live");

    // Data model: array of { id, value }
    let nextId = 1;
    let initialArr = [];
    let arr = [];
    const barDomById = new Map();

    // Sorting state
    let state = {
      pass: 0,
      j: 0,
      comparisons: 0,
      swaps: 0,
      finished: false,
      swappedInPass: false
    };

    let playing = false;

    function parseInput(str) {
      const parts = str
        .trim()
        .replace(/,/g, " ")
        .split(/\s+/)
        .filter((p) => p.length);
      if (parts.length === 0) return [];
      const values = [];
      for (const p of parts) {
        const n = Number(p);
        if (!Number.isFinite(n)) return null;
        values.push(n);
      }
      return values;
    }

    function makeArr(values) {
      return values.map((v) => ({ id: nextId++, value: v }));
    }

    function randomValues() {
      const len = Math.floor(Math.random() * 6) + 6; // 6..11
      const vals = [];
      for (let i = 0; i < len; i++) {
        vals.push(Math.floor(Math.random() * 98) + 2); // 2..99
      }
      return vals;
    }

    function setInitialData(values) {
      initialArr = makeArr(values);
      arr = initialArr.map((x) => ({ ...x }));
      resetState();
      createOrSyncBars(true);
      announce("Data set. Ready to sort.");
    }

    function resetState() {
      state = {
        pass: 0,
        j: 0,
        comparisons: 0,
        swaps: 0,
        finished: false,
        swappedInPass: false
      };
      updateStatus();
      clearHighlights();
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Bars creation and layout
    function createOrSyncBars(recreate = false) {
      if (recreate) {
        barsEl.innerHTML = "";
        barDomById.clear();
        // Create persistent bar nodes for each item id
        for (const item of arr) {
          const bar = document.createElement("div");
          bar.className = "bar";
          bar.setAttribute("role", "button");
          bar.setAttribute("tabindex", "0");
          bar.setAttribute("aria-label", `Value ${item.value}`);
          bar.dataset.id = item.id;

          const rect = document.createElement("div");
          rect.className = "bar-rect";

          const label = document.createElement("div");
          label.className = "bar-label";
          label.textContent = String(item.value);

          bar.appendChild(rect);
          bar.appendChild(label);
          barsEl.appendChild(bar);
          barDomById.set(item.id, bar);

          // Optional focus/keyboard interactions: arrow keys change focus among bars
          bar.addEventListener("keydown", (e) => {
            if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
              e.preventDefault();
              const idx = arr.findIndex((x) => x.id === item.id);
              const nextIdx = Math.min(arr.length - 1, Math.max(0, idx + (e.key === "ArrowRight" ? 1 : -1)));
              const nextBar = barDomById.get(arr[nextIdx].id);
              nextBar?.focus();
            }
          });
        }
      } else {
        // Update labels if needed
        for (const item of arr) {
          const bar = barDomById.get(item.id);
          if (bar) {
            const label = bar.querySelector(".bar-label");
            if (label) label.textContent = String(item.value);
            bar.setAttribute("aria-label", `Value ${item.value}`);
          }
        }
      }
      layoutBars();
      updateSortedZone();
      updateStatus();
    }

    function layoutBars() {
      const containerWidth = barsEl.clientWidth;
      const containerHeight = barsEl.clientHeight - 36; // leave room for labels
      const n = arr.length;
      const gap = Math.max(8, Math.min(24, Math.floor(containerWidth / (n * 8))));
      const slot = containerWidth / n;
      const barWidth = Math.max(40, Math.min(84, slot - gap));

      const maxVal = Math.max(...arr.map((x) => Math.abs(x.value)), 1);
      const minRect = 30;
      const maxRect = Math.max(minRect + 60, containerHeight - 20);

      for (let i = 0; i < n; i++) {
        const item = arr[i];
        const bar = barDomById.get(item.id);
        if (!bar) continue;
        const x = i * slot + (slot - barWidth) / 2;
        const h = Math.round(minRect + (Math.abs(item.value) / maxVal) * (maxRect - minRect));

        bar.style.setProperty("--bar-width", `${barWidth}px`);
        bar.style.setProperty("--bar-height", `${h}px`);
        bar.style.transform = `translateX(${x}px)`;
        bar.style.setProperty("--move-duration", `${getMoveDuration()}ms`);
      }
    }

    function updateSortedZone() {
      const n = arr.length;
      const sortedStart = Math.max(0, n - state.pass);
      for (let i = 0; i < n; i++) {
        const bar = barDomById.get(arr[i].id);
        if (!bar) continue;
        bar.classList.toggle("sorted", i >= sortedStart && state.pass > 0);
      }
    }

    function clearHighlights() {
      for (const bar of barDomById.values()) {
        bar.classList.remove("compare", "swap");
      }
    }

    function highlightCompare(i) {
      clearHighlights();
      const ids = [arr[i]?.id, arr[i + 1]?.id];
      for (const id of ids) {
        const el = barDomById.get(id);
        if (el) el.classList.add("compare");
      }
    }

    function highlightSwap(i) {
      const ids = [arr[i]?.id, arr[i + 1]?.id];
      for (const id of ids) {
        const el = barDomById.get(id);
        if (el) el.classList.add("swap");
      }
    }

    function getSpeedMultiplier() {
      return Number(speedRange.value);
    }
    function getMoveDuration() {
      // Base 320ms scaled inversely by speed multiplier
      const m = getSpeedMultiplier();
      const dur = Math.round(320 / m);
      return Math.max(140, dur);
    }
    function getStepPause() {
      // Pause between compare and swap phases
      const m = getSpeedMultiplier();
      const base = 280;
      return Math.max(80, Math.round(base / m));
    }

    function updateStatus() {
      passNumEl.textContent = state.pass;
      passTotalEl.textContent = Math.max(0, arr.length - 1);
      comparisonCountEl.textContent = state.comparisons;
      swapCountEl.textContent = state.swaps;
      if (!state.finished) {
        const totalPairs = Math.max(0, arr.length - 1 - state.pass);
        const jText = totalPairs > 0 ? `${state.j} & ${state.j + 1}` : "–";
        compareIndicesEl.textContent = jText;
      } else {
        compareIndicesEl.textContent = "–";
      }
      arrayTextEl.textContent = `[${arr.map((x) => x.value).join(", ")}]`;
    }

    function announce(text) {
      liveEl.textContent = text;
    }

    async function stepOnce() {
      if (state.finished || arr.length < 2) return;
      const n = arr.length;
      const lastIndex = n - 1 - state.pass;
      if (state.j >= lastIndex) {
        // Pass complete
        if (earlyExitChk.checked && !state.swappedInPass) {
          state.finished = true;
          updateSortedZone(); // whole array sorted
          updateStatus();
          announce("No swaps in last pass. Early exit: array sorted.");
          return;
        }
        state.pass++;
        state.j = 0;
        state.swappedInPass = false;
        updateSortedZone();
        updateStatus();
        if (state.pass >= n - 1) {
          state.finished = true;
          updateSortedZone();
          updateStatus();
          announce("Sorting complete.");
          return;
        }
      }

      // Compare arr[j] and arr[j+1]
      highlightCompare(state.j);
      announce(`Comparing indices ${state.j} and ${state.j + 1}.`);
      state.comparisons++;
      updateStatus();

      await sleep(getStepPause());

      const a = arr[state.j].value;
      const b = arr[state.j + 1].value;

      if (a > b) {
        // Swap visuals
        highlightSwap(state.j);
        // Swap data
        [arr[state.j], arr[state.j + 1]] = [arr[state.j + 1], arr[state.j]];
        state.swaps++;
        state.swappedInPass = true;
        layoutBars(); // animate movement via transform transition
        announce(`Swap performed: ${a} > ${b}.`);
        updateStatus();
        await sleep(getMoveDuration());
      }

      clearHighlights();
      state.j++;
      updateStatus();
    }

    async function playLoop() {
      playing = true;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      stepBtn.disabled = true;
      while (playing && !state.finished) {
        await stepOnce();
        await sleep(Math.max(60, Math.round(getStepPause() * 0.6)));
      }
      if (state.finished) {
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        stepBtn.disabled = false;
      }
    }

    function pause() {
      playing = false;
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stepBtn.disabled = false;
      announce("Paused.");
    }

    function resetToInitial() {
      arr = initialArr.map((x) => ({ ...x }));
      pause();
      resetState();
      createOrSyncBars(false);
      announce("Reset to initial order.");
    }

    function onResize() {
      layoutBars();
    }

    // Event handlers
    setDataBtn.addEventListener("click", () => {
      const values = parseInput(dataInput.value);
      if (values === null || values.length === 0) {
        announce("Invalid input. Enter numbers separated by commas or spaces.");
        dataInput.focus();
        return;
      }
      setInitialData(values);
    });

    randomBtn.addEventListener("click", () => {
      const values = randomValues();
      dataInput.value = values.join(", ");
      setInitialData(values);
    });

    shuffleBtn.addEventListener("click", () => {
      shuffleArray(arr);
      pause();
      resetState();
      createOrSyncBars(false);
      announce("Shuffled current data.");
    });

    resetBtn.addEventListener("click", resetToInitial);

    speedRange.addEventListener("input", () => {
      const v = Number(speedRange.value).toFixed(2);
      speedLabel.textContent = `${Number(v).toFixed(2).replace(/\.00$/, ".0")}×`;
      layoutBars();
    });

    stepBtn.addEventListener("click", () => {
      pause();
      stepOnce();
    });

    playBtn.addEventListener("click", () => {
      if (!playing) playLoop();
    });

    pauseBtn.addEventListener("click", pause);

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.target && (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")) {
        return; // don't intercept typing
      }
      if (e.code === "Space") {
        e.preventDefault();
        if (playing) pause(); else playLoop();
      } else if (e.key.toLowerCase() === "s") {
        e.preventDefault();
        pause();
        stepOnce();
      }
    });

    window.addEventListener("resize", onResize);

    // Initialize with a default dataset
    const defaultVals = [5, 3, 8, 1, 4, 7, 2, 6];
    dataInput.value = defaultVals.join(", ");
    setInitialData(defaultVals);
    pauseBtn.disabled = true;
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for an interactive Bubble Sort lab covering data entry/reset, playback control (play/pause/step), visual compare/swap phases, pass boundary updates, and completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "loadDefaultDataset",
      "on": {
        "INIT_COMPLETED": "paused"
      }
    },
    {
      "name": "paused",
      "onEnter": "setControlsPaused",
      "on": {
        "SET_DATA_VALID": "paused",
        "SET_DATA_INVALID": "paused",
        "RANDOMIZE": "paused",
        "SHUFFLE": "paused",
        "RESET": "paused",
        "PLAY_CLICK": "playing_pass_check",
        "SPACE_TOGGLE_PLAY_PAUSE": "playing_pass_check",
        "STEP_CLICK": "stepping_pass_check",
        "KEY_STEP": "stepping_pass_check",
        "SPEED_CHANGE": "paused",
        "WINDOW_RESIZE": "paused",
        "EARLY_EXIT_TOGGLED": "paused",
        "BAR_FOCUS_LEFT": "paused",
        "BAR_FOCUS_RIGHT": "paused"
      }
    },
    {
      "name": "stepping_pass_check",
      "onEnter": "checkPassBoundaryAndUpdate",
      "on": {
        "PASS_COMPLETED_NO_SWAPS_EARLY_EXIT": "done",
        "SORTING_FINISHED": "done",
        "PASS_COMPLETED_MORE_REMAINING": "paused",
        "PASS_NOT_COMPLETE": "stepping_comparing"
      }
    },
    {
      "name": "stepping_comparing",
      "onEnter": "highlightCompareAndAnnounce",
      "on": {
        "AFTER_COMPARE_DELAY_AND_A_GT_B": "stepping_swapping",
        "AFTER_COMPARE_DELAY_AND_A_LE_B": "stepping_advance_pointer"
      }
    },
    {
      "name": "stepping_swapping",
      "onEnter": "swapBarsAnimateAndAnnounce",
      "onExit": "clearHighlights",
      "on": {
        "AFTER_SWAP_ANIMATION": "stepping_advance_pointer"
      }
    },
    {
      "name": "stepping_advance_pointer",
      "onEnter": "clearHighlightsAndAdvancePointer",
      "on": {
        "STEP_DONE": "paused"
      }
    },
    {
      "name": "playing_pass_check",
      "onEnter": "setControlsPlaying",
      "on": {
        "PAUSE_CLICK": "paused",
        "SPACE_TOGGLE_PLAY_PAUSE": "paused",
        "PASS_COMPLETED_NO_SWAPS_EARLY_EXIT": "done",
        "SORTING_FINISHED": "done",
        "PASS_NOT_COMPLETE": "playing_comparing",
        "PASS_COMPLETED_MORE_REMAINING": "playing_pass_check"
      }
    },
    {
      "name": "playing_comparing",
      "onEnter": "highlightCompareAndAnnounce",
      "on": {
        "PAUSE_CLICK": "paused",
        "SPACE_TOGGLE_PLAY_PAUSE": "paused",
        "AFTER_COMPARE_DELAY_AND_A_GT_B": "playing_swapping",
        "AFTER_COMPARE_DELAY_AND_A_LE_B": "playing_advance_pointer"
      }
    },
    {
      "name": "playing_swapping",
      "onEnter": "swapBarsAnimateAndAnnounce",
      "onExit": "clearHighlights",
      "on": {
        "PAUSE_CLICK": "paused",
        "SPACE_TOGGLE_PLAY_PAUSE": "paused",
        "AFTER_SWAP_ANIMATION": "playing_advance_pointer"
      }
    },
    {
      "name": "playing_advance_pointer",
      "onEnter": "clearHighlightsAndAdvancePointer",
      "on": {
        "PAUSE_CLICK": "paused",
        "SPACE_TOGGLE_PLAY_PAUSE": "paused",
        "WAIT_BETWEEN_AUTO_STEPS": "playing_pass_check"
      }
    },
    {
      "name": "done",
      "onEnter": "announceCompleteAndShowSorted",
      "on": {
        "SET_DATA_VALID": "paused",
        "RANDOMIZE": "paused",
        "SHUFFLE": "paused",
        "RESET": "paused",
        "SPEED_CHANGE": "done",
        "WINDOW_RESIZE": "done",
        "PLAY_CLICK": "done",
        "STEP_CLICK": "done",
        "KEY_STEP": "done",
        "SPACE_TOGGLE_PLAY_PAUSE": "done"
      }
    }
  ],
  "events": [
    "INIT_COMPLETED",
    "SET_DATA_VALID",
    "SET_DATA_INVALID",
    "RANDOMIZE",
    "SHUFFLE",
    "RESET",
    "PLAY_CLICK",
    "PAUSE_CLICK",
    "SPACE_TOGGLE_PLAY_PAUSE",
    "STEP_CLICK",
    "KEY_STEP",
    "SPEED_CHANGE",
    "WINDOW_RESIZE",
    "EARLY_EXIT_TOGGLED",
    "BAR_FOCUS_LEFT",
    "BAR_FOCUS_RIGHT",
    "PASS_NOT_COMPLETE",
    "PASS_COMPLETED_MORE_REMAINING",
    "PASS_COMPLETED_NO_SWAPS_EARLY_EXIT",
    "SORTING_FINISHED",
    "AFTER_COMPARE_DELAY_AND_A_GT_B",
    "AFTER_COMPARE_DELAY_AND_A_LE_B",
    "AFTER_SWAP_ANIMATION",
    "STEP_DONE",
    "WAIT_BETWEEN_AUTO_STEPS"
  ],
  "notes": "Mapping to code: initializing.loadDefaultDataset corresponds to setting default values, setInitialData(defaultVals), and initial UI setup. paused.setControlsPaused mirrors pause(): playing=false; playBtn.enabled=true; pauseBtn.disabled=true; stepBtn.enabled=true; clearHighlights; updateStatus. Playing states setControlsPlaying matches playLoop() entry: playing=true; playBtn.disabled=true; pauseBtn.disabled=false; stepBtn.disabled=true. The pass boundary logic is centralized in checkPassBoundaryAndUpdate: if j >= lastIndex then (a) if earlyExit checked and no swaps in the pass -> set finished=true, updateSortedZone(), updateStatus(), announce('No swaps...'), emit PASS_COMPLETED_NO_SWAPS_EARLY_EXIT; (b) else increment pass, reset j and swappedInPass, updateSortedZone(), updateStatus(), then if pass >= n-1 -> emit SORTING_FINISHED; else emit PASS_COMPLETED_MORE_REMAINING. highlightCompareAndAnnounce performs highlightCompare(j), increments comparisons, updateStatus(), and announce('Comparing indices i and i+1'), followed by a timed delay; its result emits AFTER_COMPARE_DELAY_AND_A_GT_B if a > b or AFTER_COMPARE_DELAY_AND_A_LE_B otherwise. swapBarsAnimateAndAnnounce corresponds to highlightSwap(j), swapping arr[j]/arr[j+1], increment swaps, set swappedInPass=true, layoutBars() (animated transform), announce('Swap performed...'), updateStatus(), then after move duration emits AFTER_SWAP_ANIMATION. clearHighlightsAndAdvancePointer clears compare/swap classes, increments j, updateStatus(), emitting STEP_DONE (for stepping) or WAIT_BETWEEN_AUTO_STEPS (for playing). In playing_advance_pointer and playing_pass_check, the loop timing between steps is represented by WAIT_BETWEEN_AUTO_STEPS. Data events: SET_DATA_VALID (Set Data with valid numbers), SET_DATA_INVALID (invalid/empty input -> announce error, remain paused), RANDOMIZE (generate random values and set), SHUFFLE (shuffle current arr then pause and reset counters), RESET (revert to initialArr, pause, reset counters). SPEED_CHANGE updates speed label and re-computes durations via layoutBars(); WINDOW_RESIZE triggers layoutBars(); both are modeled as self-transitions. Keyboard: Space toggles play/pause; S triggers step when paused. Arrow keys on bars only move focus (BAR_FOCUS_LEFT/RIGHT) and do not affect sorting state. Completion: done.announceCompleteAndShowSorted covers both normal completion and early exit; in the early-exit case, the specific message is already announced in pass check; sorted zone is rendered via updateSortedZone()."
}
  </script>
</body>
</html>