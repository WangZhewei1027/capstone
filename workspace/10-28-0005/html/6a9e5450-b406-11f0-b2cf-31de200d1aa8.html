<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort, Visualized and Explored</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --text: #e5e7eb;        /* gray-200 */
      --muted: #9ca3af;       /* gray-400 */
      --accent: #22c55e;      /* green-500 */
      --accent-dark: #16a34a; /* green-600 */
      --danger: #ef4444;      /* red-500 */
      --warning: #f59e0b;     /* amber-500 */
      --compare: #60a5fa;     /* blue-400 */
      --sortedTail: rgba(34, 197, 94, 0.15);
      --bar: #34d399;         /* emerald-400 */
      --bar-contrast: #064e3b;/* emerald-900 */
      --focus: #fbbf24;       /* amber-400 */
      --gap: 16px;
      --margin: 24px;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.35;
    }

    .page {
      padding: var(--margin);
      max-width: 1200px;
      margin: 0 auto;
    }

    .title {
      font-size: 1.75rem;
      font-weight: 700;
      margin: 0 0 8px 0;
    }

    .subtitle {
      color: var(--muted);
      margin: 0 0 24px 0;
    }

    .layout {
      display: flex;
      gap: 24px;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
      flex: 1 1 340px;
      min-width: 280px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .controls label {
      font-size: 0.95rem;
      margin-bottom: 4px;
      display: block;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }

    .row > * {
      flex: 0 1 auto;
    }

    input[type="text"], input[type="number"], input[type="range"], select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #1f2937; /* gray-800 */
      background: #0b1220;
      color: var(--text);
    }

    input[type="range"] {
      accent-color: var(--accent);
    }

    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #0b1220;
      color: var(--text);
      cursor: pointer;
    }
    button:hover { background: #0c1528; }
    button:active { transform: translateY(1px); }
    button:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .btn-primary {
      background: var(--accent);
      color: #082016;
      border-color: var(--accent-dark);
    }
    .btn-primary:hover { background: var(--accent-dark); }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: var(--gap);
      margin-top: 8px;
    }
    .stat {
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 8px;
      padding: 10px 12px;
    }
    .stat .label {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .stat .value {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .viz-wrapper {
      position: relative;
      min-height: 280px;
    }

    .viz {
      position: relative;
      height: 280px;
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 12px;
      overflow: hidden;
    }

    .sorted-tail {
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      width: 0;
      background: var(--sortedTail);
      pointer-events: none;
      transition: width 300ms ease;
    }

    .bars {
      position: absolute;
      inset: 8px 8px 8px 8px;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 40px;         /* initial, will be sized by JS */
      left: 0;             /* positioned by JS */
      height: 40px;        /* sized by JS based on value */
      background: var(--bar);
      color: var(--bar-contrast);
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 6px;
      font-weight: 700;
      transition: left 250ms ease, height 250ms ease, background 150ms ease, transform 250ms ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    }

    .bar.compare {
      background: var(--compare);
    }
    .bar.swap {
      background: var(--danger);
      transform: translateY(-4px);
    }
    .bar.finished {
      background: var(--accent);
    }

    .legend {
      margin-top: 12px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .status {
      margin-top: 10px;
      min-height: 22px;
      color: var(--text);
    }
    .status .ok { color: var(--accent); }
    .status .warn { color: var(--warning); }
    .status .err { color: var(--danger); }

    .note {
      margin-top: 24px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    @media (max-width: 760px) {
      .layout { flex-direction: column; }
      .viz { height: 320px; }
      .bars { inset: 8px; }
    }
  </style>
</head>
<body>
  <main class="page" role="main">
    <h1 class="title">Bubble Sort, Visualized and Explored</h1>
    <p class="subtitle">Step through adjacent comparisons, see swaps animate, and watch the largest values bubble to the end. Adjust speed, input your own numbers, and observe early termination.</p>

    <section class="layout" aria-label="Interactive bubble sort module">
      <!-- Controls Panel -->
      <section class="panel" aria-label="Controls">
        <div class="controls">
          <div>
            <label for="arrayInput">Array (comma-separated numbers)</label>
            <input id="arrayInput" type="text" value="5,3,8,1,4,7"
                   aria-describedby="arrayHelp" placeholder="e.g., 12, 3, 7, 1, 9" />
            <div id="arrayHelp" class="legend">Enter integers separated by commas. Example: 5, 3, 8, 1</div>
          </div>

          <div class="row">
            <button id="applyArray" class="btn-primary" aria-label="Apply custom array">Apply</button>
            <button id="randomArray" aria-label="Generate random array">Randomize</button>
            <label for="sizeInput" style="min-width: 120px;">Size</label>
            <input id="sizeInput" type="number" min="5" max="30" value="6" aria-label="Array size (5 to 30)" />
          </div>

          <div class="row">
            <button id="startPause" class="btn-primary" aria-label="Start or pause animation">Start</button>
            <button id="stepOnce" aria-label="Perform one comparison and possible swap">Step</button>
            <button id="reset" aria-label="Reset to initial array">Reset</button>
          </div>

          <div>
            <label for="speed">Speed</label>
            <input id="speed" type="range" min="0.25" max="2" step="0.25" value="1" aria-label="Animation speed" />
            <div class="legend">Lower = slower, higher = faster.</div>
          </div>

          <div class="stats" aria-label="Algorithm stats">
            <div class="stat">
              <div class="label">Pass</div>
              <div id="statPass" class="value">0</div>
            </div>
            <div class="stat">
              <div class="label">Comparisons</div>
              <div id="statComp" class="value">0</div>
            </div>
            <div class="stat">
              <div class="label">Swaps</div>
              <div id="statSwap" class="value">0</div>
            </div>
            <div class="stat">
              <div class="label">Length</div>
              <div id="statLen" class="value">0</div>
            </div>
          </div>

          <div class="status" aria-live="polite" id="narration">Ready.</div>
        </div>
      </section>

      <!-- Visualization Panel -->
      <section class="panel" aria-label="Visualization">
        <div class="viz-wrapper">
          <div class="viz" id="viz">
            <div class="sorted-tail" id="sortedTail"></div>
            <div class="bars" id="bars"></div>
          </div>

          <div class="legend">
            Legend:
            Compare = blue, Swap = red, Sorted tail (end) = green shade.
          </div>
          <div class="note">
            Bubble sort compares adjacent elements left-to-right. After each pass, the largest unsorted element has moved to the end. If a pass makes no swaps, the array is already sorted and we stop early.
          </div>
        </div>
      </section>
    </section>
  </main>

  <script>
    // Bubble sort interactive module (vanilla JS)
    (function() {
      const barsEl = document.getElementById('bars');
      const sortedTailEl = document.getElementById('sortedTail');
      const narrationEl = document.getElementById('narration');

      const arrayInput = document.getElementById('arrayInput');
      const applyBtn = document.getElementById('applyArray');
      const randomBtn = document.getElementById('randomArray');
      const sizeInput = document.getElementById('sizeInput');

      const startPauseBtn = document.getElementById('startPause');
      const stepBtn = document.getElementById('stepOnce');
      const resetBtn = document.getElementById('reset');

      const speedInput = document.getElementById('speed');

      const statPass = document.getElementById('statPass');
      const statComp = document.getElementById('statComp');
      const statSwap = document.getElementById('statSwap');
      const statLen  = document.getElementById('statLen');

      const state = {
        initial: [5,3,8,1,4,7],
        arr: [],
        i: 0,           // current pass index
        j: 0,           // current comparison index
        swappedInPass: false,
        comparisons: 0,
        swaps: 0,
        running: false,
        speed: 1,       // 1 = base speed, scaled
        timer: null,
        finished: false
      };

      // Utility: parse user input
      function parseArray(str) {
        const parts = str.split(',')
          .map(s => s.trim())
          .filter(s => s.length > 0);
        if (parts.length === 0) return null;
        const nums = [];
        for (let p of parts) {
          const n = Number(p);
          if (!Number.isFinite(n)) return null;
          nums.push(Math.round(n));
        }
        return nums;
      }

      function randomArray(len) {
        const out = [];
        for (let i=0; i<len; i++) {
          out.push(Math.floor(Math.random() * 99) + 1); // 1..99
        }
        return out;
      }

      // Visualization: layout bars with absolute positioning and animate left/height
      function renderBars(arr) {
        const n = arr.length;
        statLen.textContent = n;

        // Compute layout metrics
        const containerRect = barsEl.getBoundingClientRect();
        const width = containerRect.width || barsEl.clientWidth;
        const height = containerRect.height || barsEl.clientHeight;

        const gap = 8; // internal gap between bars
        const barWidth = Math.max(20, Math.floor((width - gap*(n-1)) / n));

        const maxVal = Math.max(...arr);
        const minBarHeight = 28;
        const scale = (height - 16 - minBarHeight) / Math.max(1, maxVal);

        // Create missing bars or update existing
        // Ensure we have exactly n .bar elements in order
        const existing = Array.from(barsEl.children);
        // Fast rebuild if length mismatch
        if (existing.length !== n) {
          barsEl.innerHTML = '';
        }

        for (let i=0; i<n; i++) {
          let bar = barsEl.children[i];
          if (!bar) {
            bar = document.createElement('div');
            bar.className = 'bar';
            bar.setAttribute('role', 'img');
            bar.setAttribute('aria-label', `Value ${arr[i]} at position ${i}`);
            barsEl.appendChild(bar);
          }
          const left = i * (barWidth + gap);
          const h = Math.round(minBarHeight + arr[i] * scale);
          bar.style.width = barWidth + 'px';
          bar.style.left = left + 'px';
          bar.style.height = h + 'px';
          bar.textContent = String(arr[i]);
          // Clear dynamic classes unless set by algorithm
          bar.classList.remove('compare', 'swap', 'finished');
        }

        // Update sorted tail indicator width (end segment shaded)
        const tailCount = state.i > 0 ? state.i : 0;
        const tailWidth = tailCount * (barWidth + gap);
        sortedTailEl.style.width = tailWidth + 'px';
      }

      // Highlight the current comparison pair
      function highlightPair(j) {
        const bars = barsEl.children;
        for (let b of bars) b.classList.remove('compare', 'swap');
        const a = bars[j];
        const b = bars[j+1];
        if (a && b) {
          a.classList.add('compare');
          b.classList.add('compare');
        }
      }

      function markSwap(j) {
        const a = barsEl.children[j];
        const b = barsEl.children[j+1];
        if (a && b) {
          a.classList.add('swap');
          b.classList.add('swap');
        }
      }

      function clearHighlights() {
        for (let b of barsEl.children) {
          b.classList.remove('compare', 'swap');
        }
      }

      function updateStats() {
        statPass.textContent = state.i;
        statComp.textContent = state.comparisons;
        statSwap.textContent = state.swaps;
      }

      function setNarration(msg, level='') {
        narrationEl.className = 'status ' + (level || '');
        narrationEl.textContent = msg;
      }

      function finish() {
        state.running = false;
        state.finished = true;
        clearTimeout(state.timer);
        // Mark all bars finished
        for (let b of barsEl.children) {
          b.classList.remove('compare', 'swap');
          b.classList.add('finished');
        }
        setNarration('Sorted! Bubble sort complete.', 'ok');
        startPauseBtn.textContent = 'Start';
      }

      function earlyExit() {
        setNarration('No swaps in last pass — array already sorted. Early exit.', 'ok');
      }

      // One algorithm step: compare adjacent and possibly swap
      function stepOnceInternal() {
        if (state.finished) return;
        const n = state.arr.length;
        // If j reached end-of-pass boundary, evaluate pass result
        if (state.j >= n - state.i - 1) {
          // End of pass
          if (!state.swappedInPass) {
            // Early termination
            earlyExit();
            finish();
            return;
          }
          state.i += 1;
          state.j = 0;
          state.swappedInPass = false;
          updateStats();
          renderBars(state.arr);
          // Update sorted tail shading
          setNarration(`Starting pass ${state.i}. Final ${state.i} elements are sorted and shaded.`);
          // If all passes done
          if (state.i >= n - 1) {
            finish();
          }
          return;
        }

        // Compare pair j and j+1
        highlightPair(state.j);
        const a = state.arr[state.j];
        const b = state.arr[state.j+1];
        setNarration(`Comparing positions ${state.j} and ${state.j+1}: ${a} vs ${b}`);

        // Simulate time for visual compare before acting
        const compareDelay = 300 / state.speed;
        const swapDelay = 350 / state.speed;

        state.timer = setTimeout(() => {
          state.comparisons += 1;

          if (a > b) {
            // Swap needed
            markSwap(state.j);
            setNarration(`Swapping ${a} and ${b} because ${a} > ${b}`, 'warn');
            // Perform swap in data
            const tmp = state.arr[state.j];
            state.arr[state.j] = state.arr[state.j+1];
            state.arr[state.j+1] = tmp;

            state.swaps += 1;
            state.swappedInPass = true;
            updateStats();

            // Re-render positions (this triggers animated left movement)
            renderBars(state.arr);

            // Clear marks after swap animation
            state.timer = setTimeout(() => {
              clearHighlights();
              state.j += 1;
              // Auto-advance loop if running
              if (state.running) {
                stepOnceInternal();
              }
            }, swapDelay);
          } else {
            // No swap
            setNarration(`No swap: ${a} ≤ ${b}.`);
            clearHighlights();
            state.j += 1;
            if (state.running) {
              stepOnceInternal();
            }
          }
        }, compareDelay);
      }

      function startOrPause() {
        if (state.finished && state.running === false) {
          // Restart not allowed without reset; clarify
          setNarration('Already finished. Press Reset to run again.', 'warn');
          return;
        }
        state.running = !state.running;
        startPauseBtn.textContent = state.running ? 'Pause' : 'Start';
        if (state.running) {
          stepOnceInternal();
        } else {
          clearTimeout(state.timer);
          setNarration('Paused.');
        }
      }

      function stepOnce() {
        if (state.finished) {
          setNarration('Already finished. Press Reset to run again.', 'warn');
          return;
        }
        if (state.running) {
          // Pause and step to ensure single action clarity
          state.running = false;
          startPauseBtn.textContent = 'Start';
          clearTimeout(state.timer);
        }
        stepOnceInternal();
      }

      function reset() {
        clearTimeout(state.timer);
        state.arr = state.initial.slice();
        state.i = 0;
        state.j = 0;
        state.swappedInPass = false;
        state.comparisons = 0;
        state.swaps = 0;
        state.running = false;
        state.finished = false;
        startPauseBtn.textContent = 'Start';
        updateStats();
        renderBars(state.arr);
        clearHighlights();
        setNarration('Ready.');
      }

      function applyArrayFromInput() {
        const parsed = parseArray(arrayInput.value);
        if (!parsed || parsed.length < 2) {
          setNarration('Please enter at least two valid numbers separated by commas.', 'err');
          return;
        }
        state.initial = parsed.slice();
        sizeInput.value = parsed.length;
        reset();
      }

      function randomizeArray() {
        const size = clampInt(Number(sizeInput.value), 5, 30);
        sizeInput.value = size;
        const arr = randomArray(size);
        arrayInput.value = arr.join(', ');
        state.initial = arr.slice();
        reset();
      }

      function clampInt(n, min, max) {
        if (!Number.isFinite(n)) return min;
        return Math.max(min, Math.min(max, Math.round(n)));
      }

      // Respond to speed changes (affects delays)
      function updateSpeed() {
        const val = Number(speedInput.value);
        state.speed = val;
      }

      // Wire up events
      applyBtn.addEventListener('click', applyArrayFromInput);
      randomBtn.addEventListener('click', randomizeArray);
      startPauseBtn.addEventListener('click', startOrPause);
      stepBtn.addEventListener('click', stepOnce);
      resetBtn.addEventListener('click', reset);
      speedInput.addEventListener('input', updateSpeed);
      sizeInput.addEventListener('change', () => {
        // Optional: just keep size synced; randomize uses it explicitly.
        const val = clampInt(Number(sizeInput.value), 5, 30);
        sizeInput.value = val;
      });

      // Keyboard accessibility: space/enter on focused buttons
      [applyBtn, randomBtn, startPauseBtn, stepBtn, resetBtn].forEach(btn => {
        btn.addEventListener('keyup', (e) => {
          if (e.key === 'Enter' || e.key === ' ') btn.click();
        });
      });

      // Initialize
      function init() {
        // Fill initial UI
        arrayInput.value = state.initial.join(', ');
        updateSpeed();
        renderBars(state.initial);
        state.arr = state.initial.slice();
        updateStats();
        setNarration('Ready.');
      }

      // On resize, re-render positions to keep bars aligned responsively
      window.addEventListener('resize', () => {
        renderBars(state.arr);
      });

      init();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a bubble sort visualization with start/pause, step, reset, input/apply, randomize, and speed controls. It models auto-play, manual stepping, animation phases (compare/swap), pass boundaries, and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "set_start_button_label_start",
      "on": {
        "CLICK_START": "compute_next_step_auto",
        "CLICK_STEP": "compute_next_step_step",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_APPLY_INVALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "idle",
        "SIZE_CHANGE": "idle",
        "RESIZE": "idle"
      }
    },
    {
      "name": "compute_next_step_auto",
      "onEnter": "check_pass_boundary_and_dispatch",
      "on": {
        "PASS_END_NO_SWAPS": "finished",
        "FINAL_PASS_COMPLETE": "finished",
        "PASS_END_WITH_SWAPS": "between_pass",
        "READY_TO_COMPARE": "playing_comparing",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "CLICK_PAUSE": "paused"
      }
    },
    {
      "name": "compute_next_step_step",
      "onEnter": "check_pass_boundary_and_dispatch",
      "on": {
        "PASS_END_NO_SWAPS": "finished",
        "FINAL_PASS_COMPLETE": "finished",
        "PASS_END_WITH_SWAPS": "between_pass",
        "READY_TO_COMPARE": "stepping_comparing",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "playing_comparing",
      "onEnter": "highlight_pair_and_schedule_compare_timer",
      "onExit": "noop",
      "on": {
        "TIMER_COMPARE_DONE_SWAP": "playing_swapping",
        "TIMER_COMPARE_DONE_NO_SWAP": "compute_next_step_auto",
        "CLICK_PAUSE": "paused",
        "CLICK_STEP": "compute_next_step_step",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "playing_comparing",
        "RESIZE": "playing_comparing"
      }
    },
    {
      "name": "playing_swapping",
      "onEnter": "mark_swap_swap_values_render_and_schedule_swap_timer",
      "on": {
        "TIMER_SWAP_ANIM_DONE": "compute_next_step_auto",
        "CLICK_PAUSE": "paused",
        "CLICK_STEP": "compute_next_step_step",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "playing_swapping",
        "RESIZE": "playing_swapping"
      }
    },
    {
      "name": "between_pass",
      "onEnter": "update_stats_render_and_announce_new_pass",
      "on": {
        "CLICK_PAUSE": "paused",
        "CLICK_START": "compute_next_step_auto",
        "CLICK_STEP": "compute_next_step_step",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "stepping_comparing",
      "onEnter": "highlight_pair_and_schedule_compare_timer",
      "on": {
        "TIMER_COMPARE_DONE_SWAP": "stepping_swapping",
        "TIMER_COMPARE_DONE_NO_SWAP": "idle",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "stepping_comparing",
        "RESIZE": "stepping_comparing"
      }
    },
    {
      "name": "stepping_swapping",
      "onEnter": "mark_swap_swap_values_render_and_schedule_swap_timer",
      "on": {
        "TIMER_SWAP_ANIM_DONE": "idle",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "stepping_swapping",
        "RESIZE": "stepping_swapping"
      }
    },
    {
      "name": "paused",
      "onEnter": "clear_timer_and_set_paused_message",
      "on": {
        "CLICK_START": "compute_next_step_auto",
        "CLICK_STEP": "compute_next_step_step",
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "SPEED_CHANGE": "paused",
        "SIZE_CHANGE": "paused",
        "RESIZE": "paused"
      }
    },
    {
      "name": "finished",
      "onEnter": "mark_bars_finished_and_announce_completion",
      "on": {
        "CLICK_RESET": "idle",
        "CLICK_APPLY_VALID": "idle",
        "CLICK_RANDOMIZE": "idle",
        "CLICK_START": "finished",
        "CLICK_STEP": "finished",
        "SPEED_CHANGE": "finished",
        "SIZE_CHANGE": "finished",
        "RESIZE": "finished"
      }
    }
  ],
  "events": [
    "INIT",
    "CLICK_START",
    "CLICK_PAUSE",
    "CLICK_STEP",
    "CLICK_RESET",
    "CLICK_APPLY_VALID",
    "CLICK_APPLY_INVALID",
    "CLICK_RANDOMIZE",
    "SPEED_CHANGE",
    "SIZE_CHANGE",
    "RESIZE",
    "READY_TO_COMPARE",
    "PASS_END_WITH_SWAPS",
    "PASS_END_NO_SWAPS",
    "FINAL_PASS_COMPLETE",
    "TIMER_COMPARE_DONE_SWAP",
    "TIMER_COMPARE_DONE_NO_SWAP",
    "TIMER_SWAP_ANIM_DONE"
  ],
  "notes": "Key mappings: Start/Pause is a single button; when it shows 'Start' it emits CLICK_START and sets running=true; when it shows 'Pause' it emits CLICK_PAUSE and sets running=false and clears any pending timer. Step always ensures running=false before performing one step. On every step invocation, the algorithm first checks if the current comparison index j has reached the pass boundary (j >= n - i - 1). If so, it either triggers PASS_END_NO_SWAPS (early exit) and goes to finished, or PASS_END_WITH_SWAPS to enter between_pass (announces next pass, updates stats and sorted-tail shading). Notably, auto-play does NOT automatically continue across pass boundaries; it halts in between_pass until the user clicks Pause->Start or Step to continue. Visual feedback: comparing states add 'compare' class to two bars; swapping states add 'swap' class, perform the in-array swap, update stats, re-render to animate positions, then clear highlights after the swap timer. Finished state adds 'finished' class to all bars and announces completion. Speed changes (SPEED_CHANGE) update delay scaling but do not change state. Resize (RESIZE) re-renders bar positions but does not change state. Apply (valid) and Randomize both reset the algorithm to the initial/selected array (transition to idle). Apply invalid does not change state; it only sets an error narration."
}
  </script>
</body>
</html>