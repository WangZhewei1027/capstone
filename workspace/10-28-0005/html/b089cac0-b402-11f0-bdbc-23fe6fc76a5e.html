<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Sort Interactive Module</title>
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --surface: #111827;     /* gray-900 */
      --panel: #1f2937;       /* gray-800 */
      --text: #f8fafc;        /* slate-50 */
      --muted: #cbd5e1;       /* slate-300 */
      --accent: #22c55e;      /* green-500 */
      --compare: #f59e0b;     /* amber-500 */
      --swap: #ef4444;        /* red-500 */
      --sorted: #38bdf8;      /* sky-400 */
      --focus: #a78bfa;       /* violet-400 */
      --warn: #fb7185;        /* rose-400 */
      --gap-16: 16px;
      --gap-24: 24px;
      --radius-8: 8px;
      --radius-12: 12px;
      --shadow-1: 0 6px 24px rgba(0,0,0,0.25);
      --swap-duration: 320ms;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f8fafc;        /* slate-50 */
        --surface: #ffffff;   /* white */
        --panel: #f1f5f9;     /* slate-100 */
        --text: #0f172a;      /* slate-900 */
        --muted: #475569;     /* slate-600 */
        --accent: #16a34a;    /* green-600 */
        --compare: #b45309;   /* amber-700 */
        --swap: #b91c1c;      /* red-700 */
        --sorted: #0284c7;    /* sky-600 */
        --focus: #7c3aed;     /* violet-600 */
        --warn: #be123c;      /* rose-700 */
      }
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
      line-height: 1.5;
    }

    body {
      margin: 0;
    }

    main.safe-area {
      padding: var(--gap-24);
      max-width: 1200px;
      margin: 0 auto;
    }

    h1, h2, h3 {
      margin: 0 0 8px 0;
    }

    p {
      margin: 0 0 12px 0;
      color: var(--muted);
    }

    .design-plan {
      background: var(--panel);
      border-radius: var(--radius-12);
      padding: var(--gap-24);
      box-shadow: var(--shadow-1);
      margin-bottom: var(--gap-24);
    }

    .design-plan ul {
      padding-left: 18px;
      margin: 8px 0 0 0;
    }
    .design-plan li {
      margin: 6px 0;
    }

    .module {
      background: var(--surface);
      border-radius: var(--radius-12);
      box-shadow: var(--shadow-1);
      padding: var(--gap-24);
    }

    .module-grid {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      gap: var(--gap-24);
    }

    @media (max-width: 900px) {
      .module-grid {
        grid-template-columns: 1fr;
      }
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap-16);
    }

    .controls .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap-16);
    }
    @media (max-width: 560px) {
      .controls .row {
        grid-template-columns: 1fr;
      }
    }

    .control-group {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    label {
      font-size: 14px;
      color: var(--muted);
    }

    input[type="text"],
    input[type="number"],
    input[type="range"],
    select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--focus) 35%, transparent);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap-16);
    }

    button {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      background: var(--panel);
      color: var(--text);
      cursor: pointer;
      transition: background 160ms ease, transform 100ms ease;
      min-height: 40px;
    }
    button:hover {
      background: color-mix(in oklab, var(--panel) 80%, var(--text) 20%);
    }
    button:active {
      transform: translateY(1px);
    }
    button:focus-visible {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }
    .primary {
      background: var(--accent);
      color: #0b1320;
      font-weight: 600;
    }
    .danger {
      background: var(--swap);
      color: #fff;
      font-weight: 600;
    }
    .secondary {
      background: var(--panel);
      border: 1px solid color-mix(in oklab, var(--panel) 60%, var(--text) 40%);
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: var(--panel);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .toggle input {
      transform: translateY(1px);
    }

    .viz {
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: var(--gap-16);
      min-height: 420px;
    }

    .viz-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap-16);
    }

    .status {
      display: grid;
      grid-template-columns: repeat(3, minmax(120px, 1fr));
      gap: var(--gap-16);
    }
    @media (max-width: 560px) {
      .status {
        grid-template-columns: 1fr 1fr;
      }
    }
    .stat {
      background: var(--panel);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .stat h4 {
      margin: 0 0 4px 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 500;
    }
    .stat .value {
      font-size: 18px;
      font-weight: 700;
    }

    .bars-wrap {
      background: var(--panel);
      border-radius: var(--radius-12);
      padding: 16px;
      position: relative;
    }

    .bars {
      position: relative;
      display: flex;
      align-items: flex-end;
      gap: 8px;
      height: 320px;
      overflow: hidden;
    }

    .bar {
      position: relative;
      flex: 1 1 0px;
      min-width: 24px;
      background: linear-gradient(180deg, color-mix(in oklab, var(--sorted) 15%, var(--accent) 85%), var(--accent));
      border-radius: 8px 8px 4px 4px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      transition: filter 200ms ease;
    }

    .bar .label {
      position: absolute;
      top: -24px;
      font-size: 12px;
      color: var(--text);
      background: rgba(0,0,0,0.25);
      padding: 4px 6px;
      border-radius: 6px;
      backdrop-filter: blur(2px);
    }

    .bar.comparing {
      outline: 3px solid var(--compare);
      outline-offset: 2px;
      filter: brightness(1.1);
      animation: pulse 420ms ease-in-out;
    }

    @keyframes pulse {
      0%   { transform: scale(1); }
      25%  { transform: scale(1.02); }
      50%  { transform: scale(1); }
      75%  { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    .bar.animating {
      will-change: transform;
      transition: transform var(--swap-duration) ease-in-out;
    }

    .bar.swapped {
      box-shadow: 0 0 0 3px var(--swap) inset;
    }

    .bar.sorted {
      background: linear-gradient(180deg, color-mix(in oklab, var(--sorted) 65%, var(--accent) 35%), var(--sorted));
      filter: saturate(1.2);
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      font-size: 13px;
      color: var(--muted);
    }
    .legend .swatch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .legend .box {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      background: var(--accent);
      outline: 2px solid transparent;
    }
    .legend .box.compare { outline-color: var(--compare); }
    .legend .box.swap { background: var(--swap); }
    .legend .box.sorted { background: var(--sorted); }

    .pseudocode {
      background: var(--panel);
      border-radius: var(--radius-12);
      padding: 12px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: var(--muted);
    }
    .pseudocode .line {
      padding: 6px 8px;
      border-radius: 8px;
    }
    .pseudocode .line.active {
      background: color-mix(in oklab, var(--focus) 22%, transparent);
      color: var(--text);
    }
    .pseudocode .line.dim {
      opacity: 0.75;
    }

    .sr-status {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
      clip-path: inset(50%);
    }

    .error {
      color: var(--warn);
      font-size: 13px;
      min-height: 18px;
    }

    .footer {
      margin-top: var(--gap-24);
      color: var(--muted);
      font-size: 14px;
    }

    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid color-mix(in oklab, var(--panel) 60%, var(--text) 40%);
      background: var(--panel);
      color: var(--text);
      font-weight: 600;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <main class="safe-area">
    <section class="design-plan" aria-labelledby="plan-title">
      <h2 id="plan-title">Interactive Design Plan</h2>

      <h3>Concept Title</h3>
      <p>Bubble Sort: Adjacent Comparisons and Passes</p>

      <h3>Learning Objective</h3>
      <ul>
        <li>Understand how bubble sort repeatedly compares adjacent elements and swaps them to “bubble” larger (or smaller) values toward the end (or start).</li>
        <li>Experience the algorithm step-by-step, observing passes, comparisons, swaps, and the early-exit optimization.</li>
        <li>Relate the visual process to pseudocode by seeing the currently active line highlighted.</li>
      </ul>

      <h3>Interaction Design</h3>
      <ul>
        <li>Typing: Enter a custom array in the input field using comma or space-separated numbers; click Load Array to start.</li>
        <li>Clicking:
          <ul>
            <li>Play/Pause animates comparisons and swaps automatically at the chosen speed.</li>
            <li>Step performs a single compare-and-optional-swap with visual highlighting.</li>
            <li>Randomize generates a new array of the selected size.</li>
            <li>Reset returns to the original unsorted array.</li>
            <li>Ascending/Descending changes the comparison direction; Early Exit enables the optimization.</li>
          </ul>
        </li>
        <li>Visual feedback:
          <ul>
            <li>Compared pair is outlined in amber; if swapped, bars slide into new positions with a smooth animation and a red accent.</li>
            <li>After each pass, the last sorted element gains a blue tint.</li>
            <li>Pseudocode lines highlight to match each phase (initialize, compare, swap, end of pass/early exit).</li>
            <li>Counters for comparisons and swaps update live; a status line describes the active operation.</li>
          </ul>
        </li>
        <li>Keyboard: Space toggles play/pause; S or Right Arrow steps; R resets; G randomizes.</li>
      </ul>

      <h3>Layout Description</h3>
      <ul>
        <li>Safe area margins: The main module is centered with 24 px padding on all viewport sides.</li>
        <li>Spatial organization: A two-column grid places controls on the left and visualization on the right; on narrow screens it stacks vertically for clarity.</li>
        <li>Controls: Labeled inputs and buttons use at least 16 px spacing; focus styles are visible and high contrast for accessibility.</li>
        <li>Visualization: Bars panel occupies generous vertical space, with a legend, status counters, and pseudocode beneath to maintain focus and balance.</li>
        <li>Responsiveness: The grid collapses smoothly; bars flex to available width. All interactive elements remain touch-friendly.</li>
        <li>Accessibility: Semantic labels, ARIA region labels, and an aria-live status are included. Focus rings and large tap targets enhance usability.</li>
      </ul>
    </section>

    <section class="module" role="region" aria-label="Bubble Sort Interactive Module">
      <div class="module-grid">
        <div class="controls" aria-label="Controls">
          <div class="control-group">
            <label for="arrayInput">Array (comma or space-separated)</label>
            <input id="arrayInput" type="text" placeholder="e.g., 7, 3, 9, 2, 5" aria-describedby="inputHelp" />
            <div id="inputHelp" class="error" aria-live="polite"></div>
            <div class="button-row">
              <button id="loadBtn" class="primary" title="Load the typed array">Load Array</button>
              <button id="resetBtn" class="secondary" title="Reset to original unsorted array">Reset</button>
            </div>
          </div>

          <div class="row">
            <div class="control-group">
              <label for="sizeRange">Random Size</label>
              <input id="sizeRange" type="range" min="3" max="20" value="10" />
              <div class="button-row">
                <button id="randomBtn" title="Generate a random array at the chosen size">Randomize</button>
              </div>
            </div>

            <div class="control-group">
              <label for="speedRange">Speed (ms per step)</label>
              <input id="speedRange" type="range" min="80" max="1200" value="420" />
              <div class="button-row">
                <span id="speedLabel" aria-live="polite">420 ms</span>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="control-group">
              <label for="orderSelect">Order</label>
              <select id="orderSelect" aria-label="Sort order">
                <option value="asc">Ascending (smallest to largest)</option>
                <option value="desc">Descending (largest to smallest)</option>
              </select>
            </div>

            <div class="control-group">
              <label class="toggle" for="earlyExit">
                <input id="earlyExit" type="checkbox" checked />
                <span>Early Exit Optimization</span>
              </label>
            </div>
          </div>

          <div class="button-row" aria-label="Playback Controls">
            <button id="playBtn" class="primary" title="Play or pause animation">Play</button>
            <button id="stepBtn" title="Perform a single step">Step</button>
            <button id="stopBtn" class="danger" title="Stop and mark as finished if possible">Stop</button>
          </div>

          <p class="footer">
            Keyboard: <span class="kbd">Space</span> Play/Pause • <span class="kbd">S</span> or <span class="kbd">→</span> Step • <span class="kbd">R</span> Reset • <span class="kbd">G</span> Randomize
          </p>
        </div>

        <div class="viz">
          <div class="viz-header">
            <h2>Bubble Sort Explorer</h2>
            <div class="legend" aria-label="Legend">
              <span class="swatch"><span class="box compare"></span> Comparing pair</span>
              <span class="swatch"><span class="box swap"></span> Swap</span>
              <span class="swatch"><span class="box sorted"></span> Sorted boundary</span>
            </div>
          </div>

          <div class="status" aria-label="Sort Status">
            <div class="stat"><h4>Pass</h4><div class="value" id="passStat">0</div></div>
            <div class="stat"><h4>Comparisons</h4><div class="value" id="compStat">0</div></div>
            <div class="stat"><h4>Swaps</h4><div class="value" id="swapStat">0</div></div>
          </div>

          <div class="bars-wrap" aria-label="Bars Visualization">
            <div id="bars" class="bars" role="list" aria-label="Array bars"></div>
            <div id="srStatus" class="sr-status" aria-live="polite"></div>
          </div>

          <div class="pseudocode" aria-label="Pseudocode">
            <div class="line dim" data-line="1">for end = n - 1 down to 1:</div>
            <div class="line dim" data-line="2">  swapped = false</div>
            <div class="line dim" data-line="3">  for i = 0 to end - 1:</div>
            <div class="line dim" data-line="4">    if order(a[i], a[i+1]) then</div>
            <div class="line dim" data-line="5">      swap(a[i], a[i+1])</div>
            <div class="line dim" data-line="6">      swapped = true</div>
            <div class="line dim" data-line="7">  if earlyExit and not swapped: break</div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    (function() {
      const barsEl = document.getElementById('bars');
      const srStatusEl = document.getElementById('srStatus');
      const loadBtn = document.getElementById('loadBtn');
      const resetBtn = document.getElementById('resetBtn');
      const randomBtn = document.getElementById('randomBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const stopBtn = document.getElementById('stopBtn');
      const arrayInput = document.getElementById('arrayInput');
      const inputHelp = document.getElementById('inputHelp');
      const sizeRange = document.getElementById('sizeRange');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const orderSelect = document.getElementById('orderSelect');
      const earlyExit = document.getElementById('earlyExit');

      const passStat = document.getElementById('passStat');
      const compStat = document.getElementById('compStat');
      const swapStat = document.getElementById('swapStat');

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const state = {
        arr: [],
        original: [],
        size: parseInt(sizeRange.value, 10),
        ascending: orderSelect.value === 'asc',
        earlyExit: earlyExit.checked,
        playing: false,
        passIndex: 0,          // 0-based pass count
        j: 0,                  // current inner index
        swappedThisPass: false,
        comparisons: 0,
        swaps: 0,
        speed: parseInt(speedRange.value, 10),
        finished: false,
        animating: false
      };

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

      function randomArray(size) {
        const out = [];
        for (let i = 0; i < size; i++) {
          out.push(Math.floor(Math.random() * 99) + 1);
        }
        return out;
      }

      function renderBars(arr) {
        barsEl.innerHTML = '';
        const maxVal = Math.max(...arr);
        arr.forEach((v, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role', 'listitem');
          bar.setAttribute('aria-label', `Index ${idx}, Value ${v}`);
          bar.style.height = `${clamp((v / maxVal) * 100, 4, 100)}%`;

          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = String(v);

          bar.appendChild(label);
          barsEl.appendChild(bar);
        });
      }

      function updateStats() {
        passStat.textContent = String(state.passIndex);
        compStat.textContent = String(state.comparisons);
        swapStat.textContent = String(state.swaps);
      }

      function clearHighlights() {
        [...barsEl.children].forEach(bar => {
          bar.classList.remove('comparing', 'swapped');
        });
      }

      function setSortedBoundary() {
        const endIdx = state.arr.length - 1 - state.passIndex;
        if (endIdx >= 0 && endIdx < barsEl.children.length) {
          barsEl.children[endIdx].classList.add('sorted');
        }
      }

      function resetSortedMarkers() {
        [...barsEl.children].forEach(bar => bar.classList.remove('sorted'));
      }

      function setPseudocodeActive(lines = []) {
        const all = document.querySelectorAll('.pseudocode .line');
        all.forEach(el => el.classList.remove('active'));
        lines.forEach(n => {
          const el = document.querySelector(`.pseudocode .line[data-line="${n}"]`);
          if (el) el.classList.add('active');
        });
      }

      function statusSpeak(text) {
        srStatusEl.textContent = text;
      }

      function parseArrayInput(text) {
        const parts = text.trim().split(/[\s,]+/).filter(Boolean);
        if (parts.length === 0) return { ok: false, error: 'Please enter at least one number.' };
        const nums = [];
        for (const p of parts) {
          const n = Number(p);
          if (!isFinite(n)) return { ok: false, error: `"${p}" is not a valid number.` };
          if (Math.abs(n) > 9999) return { ok: false, error: `Value ${n} is too large (limit 9999).` };
          nums.push(Math.round(n));
        }
        if (nums.length < 3 || nums.length > 20) {
          return { ok: false, error: `Please provide between 3 and 20 numbers (you provided ${nums.length}).` };
        }
        return { ok: true, value: nums };
      }

      function initArray(arr, fromUser = false) {
        state.arr = arr.slice();
        state.original = arr.slice();
        state.size = arr.length;
        resetAlgorithmState();
        renderBars(state.arr);
        resetSortedMarkers();
        updateStats();
        inputHelp.textContent = '';
        if (fromUser) arrayInput.value = arr.join(', ');
      }

      function resetAlgorithmState() {
        state.passIndex = 0;
        state.j = 0;
        state.swappedThisPass = false;
        state.comparisons = 0;
        state.swaps = 0;
        state.finished = false;
        state.animating = false;
        clearHighlights();
        setPseudocodeActive([1]);
        statusSpeak('Ready to start bubble sort. Press Play or Step.');
      }

      function shouldSwap(a, b) {
        return state.ascending ? a > b : a < b;
      }

      function getEndIndex() {
        return state.arr.length - 1 - state.passIndex;
      }

      function markComparing(j) {
        clearHighlights();
        const a = barsEl.children[j];
        const b = barsEl.children[j + 1];
        if (a && b) {
          a.classList.add('comparing');
          b.classList.add('comparing');
        }
      }

      function flipSwap(j) {
        return new Promise(resolve => {
          const a = barsEl.children[j];
          const b = barsEl.children[j + 1];
          if (!a || !b) { resolve(); return; }

          const aStart = a.getBoundingClientRect();
          const bStart = b.getBoundingClientRect();

          // Perform DOM swap
          a.before(b);

          const aEnd = a.getBoundingClientRect();
          const bEnd = b.getBoundingClientRect();

          const aDeltaX = aStart.left - aEnd.left;
          const bDeltaX = bStart.left - bEnd.left;

          // Apply FLIP transforms
          a.style.transform = `translateX(${aDeltaX}px)`;
          b.style.transform = `translateX(${bDeltaX}px)`;
          a.classList.add('animating', 'swapped');
          b.classList.add('animating', 'swapped');

          // Force reflow, then animate to final position
          void a.offsetWidth;
          void b.offsetWidth;

          const duration = prefersReducedMotion ? 1 : parseInt(getComputedStyle(document.documentElement).getPropertyValue('--swap-duration')) || 320;

          function onDone(e) {
            // Clean up after animation
            a.style.transform = '';
            b.style.transform = '';
            a.classList.remove('animating');
            b.classList.remove('animating');
            a.removeEventListener('transitionend', onDone);
            resolve();
          }

          a.addEventListener('transitionend', onDone);
          // Start animation
          requestAnimationFrame(() => {
            a.style.transform = 'translateX(0px)';
            b.style.transform = 'translateX(0px)';
          });
        });
      }

      async function performStep() {
        if (state.finished || state.animating) return;
        const end = getEndIndex();
        if (end <= 0) {
          finishAll();
          return;
        }

        setPseudocodeActive([3, 4]);
        const j = state.j;

        if (j >= end) {
          // End of pass
          setPseudocodeActive([7]);
          if (state.earlyExit && !state.swappedThisPass) {
            finishAll();
            return;
          }
          // Mark boundary as sorted
          setSortedBoundary();
          state.passIndex += 1;
          state.j = 0;
          state.swappedThisPass = false;
          updateStats();
          statusSpeak(`Pass ${state.passIndex} started.`);
          setPseudocodeActive([2]);
          return;
        }

        // Compare pair j and j+1
        const aVal = state.arr[j];
        const bVal = state.arr[j + 1];
        markComparing(j);
        state.comparisons += 1;
        updateStats();
        statusSpeak(`Comparing indices ${j} and ${j + 1}: ${aVal} and ${bVal}.`);

        if (shouldSwap(aVal, bVal)) {
          // Swap in data and animate bars
          setPseudocodeActive([5, 6]);
          state.animating = true;
          // Swap in data
          const tmp = state.arr[j];
          state.arr[j] = state.arr[j + 1];
          state.arr[j + 1] = tmp;
          state.swaps += 1;
          state.swappedThisPass = true;
          updateStats();
          await flipSwap(j);
          state.animating = false;
          clearHighlights();
        } else {
          // No swap; brief highlight remains
        }

        state.j += 1;
      }

      function finishAll() {
        state.finished = true;
        state.playing = false;
        playBtn.textContent = 'Play';
        setPseudocodeActive([1]);
        // Mark all as sorted
        [...barsEl.children].forEach(bar => bar.classList.add('sorted'));
        statusSpeak('Array sorted!');
      }

      function setSpeed(ms) {
        state.speed = ms;
        speedLabel.textContent = `${ms} ms`;
        const duration = Math.max(140, Math.floor(ms * 0.7));
        if (prefersReducedMotion) {
          document.documentElement.style.setProperty('--swap-duration', '1ms');
        } else {
          document.documentElement.style.setProperty('--swap-duration', `${duration}ms`);
        }
      }

      async function playLoop() {
        if (!state.playing) return;
        await performStep();
        if (!state.playing) return;
        setTimeout(playLoop, state.speed);
      }

      // Event handlers
      loadBtn.addEventListener('click', () => {
        const text = arrayInput.value;
        const res = parseArrayInput(text);
        if (!res.ok) {
          inputHelp.textContent = res.error;
          return;
        }
        initArray(res.value, true);
      });

      resetBtn.addEventListener('click', () => {
        arrayInput.value = state.original.join(', ');
        initArray(state.original.slice(), true);
      });

      randomBtn.addEventListener('click', () => {
        const size = parseInt(sizeRange.value, 10);
        const arr = randomArray(size);
        arrayInput.value = arr.join(', ');
        initArray(arr, true);
      });

      playBtn.addEventListener('click', () => {
        if (state.finished) {
          resetAlgorithmState();
          resetSortedMarkers();
        }
        state.playing = !state.playing;
        playBtn.textContent = state.playing ? 'Pause' : 'Play';
        if (state.playing) playLoop();
      });

      stepBtn.addEventListener('click', async () => {
        if (state.finished) return;
        await performStep();
      });

      stopBtn.addEventListener('click', () => {
        state.playing = false;
        playBtn.textContent = 'Play';
        finishAll();
      });

      orderSelect.addEventListener('change', () => {
        state.ascending = orderSelect.value === 'asc';
      });

      earlyExit.addEventListener('change', () => {
        state.earlyExit = earlyExit.checked;
      });

      speedRange.addEventListener('input', () => {
        setSpeed(parseInt(speedRange.value, 10));
      });

      document.addEventListener('keydown', (e) => {
        const tag = (e.target.tagName || '').toLowerCase();
        const typing = tag === 'input' || tag === 'textarea' || tag === 'select';
        if (typing) return;

        if (e.code === 'Space') {
          e.preventDefault();
          playBtn.click();
        } else if (e.key.toLowerCase() === 's' || e.code === 'ArrowRight') {
          e.preventDefault();
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'r') {
          e.preventDefault();
          resetBtn.click();
        } else if (e.key.toLowerCase() === 'g') {
          e.preventDefault();
          randomBtn.click();
        }
      });

      // Initialize
      setSpeed(state.speed);
      const initial = randomArray(state.size);
      arrayInput.value = initial.join(', ');
      initArray(initial, true);
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for a Bubble Sort interactive module covering array loading, playback control, stepwise execution, visual comparison/swapping animations, pass transitions, and completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "initialize_default_array_and_ui",
      "on": {
        "INIT_COMPLETE": "ready"
      }
    },
    {
      "name": "ready",
      "onEnter": "reset_algorithm_state_and_show_ready",
      "on": {
        "PLAY_TOGGLE": "playing",
        "STEP_COMPARE": "comparing",
        "STEP_END_OF_PASS": "pass_transition",
        "STEP_SORT_COMPLETE": "finished",
        "LOAD_ARRAY_SUCCESS": "ready",
        "RESET_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "STOP_CLICK": "finished",
        "ORDER_CHANGE": "ready",
        "EARLY_EXIT_TOGGLE": "ready",
        "SPEED_CHANGE": "ready"
      }
    },
    {
      "name": "paused",
      "onEnter": "set_play_button_to_play",
      "on": {
        "PLAY_TOGGLE": "playing",
        "STEP_COMPARE": "comparing",
        "STEP_END_OF_PASS": "pass_transition",
        "STEP_SORT_COMPLETE": "finished",
        "LOAD_ARRAY_SUCCESS": "ready",
        "RESET_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "STOP_CLICK": "finished",
        "ORDER_CHANGE": "paused",
        "EARLY_EXIT_TOGGLE": "paused",
        "SPEED_CHANGE": "paused"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_play_loop",
      "onExit": "stop_play_loop",
      "on": {
        "AUTO_STEP_COMPARE": "comparing",
        "AUTO_STEP_END_OF_PASS": "pass_transition",
        "AUTO_STEP_SORT_COMPLETE": "finished",
        "PLAY_TOGGLE": "paused",
        "STOP_CLICK": "finished",
        "LOAD_ARRAY_SUCCESS": "playing",
        "RESET_CLICK": "playing",
        "RANDOMIZE_CLICK": "playing",
        "ORDER_CHANGE": "playing",
        "EARLY_EXIT_TOGGLE": "playing",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_pair_and_update_stats",
      "on": {
        "NEEDS_SWAP": "swapping",
        "NO_SWAP_STEP_DONE_PLAY": "playing",
        "NO_SWAP_STEP_DONE_PAUSE": "paused"
      }
    },
    {
      "name": "swapping",
      "onEnter": "flip_swap_animation_and_update_stats",
      "onExit": "clear_highlights",
      "on": {
        "ANIMATION_END_PLAY": "playing",
        "ANIMATION_END_PAUSE": "paused"
      }
    },
    {
      "name": "pass_transition",
      "onEnter": "end_of_pass_update_and_mark_boundary",
      "on": {
        "EARLY_EXIT_BREAK": "finished",
        "PASS_CONTINUE_PLAY": "playing",
        "PASS_CONTINUE_PAUSE": "paused"
      }
    },
    {
      "name": "finished",
      "onEnter": "mark_all_sorted_and_announce",
      "on": {
        "PLAY_TOGGLE": "playing",
        "LOAD_ARRAY_SUCCESS": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "STOP_CLICK": "finished",
        "ORDER_CHANGE": "finished",
        "EARLY_EXIT_TOGGLE": "finished",
        "SPEED_CHANGE": "finished"
      }
    }
  ],
  "events": [
    "INIT_COMPLETE",
    "LOAD_ARRAY_SUCCESS",
    "LOAD_ARRAY_FAILURE",
    "RESET_CLICK",
    "RANDOMIZE_CLICK",
    "PLAY_TOGGLE",
    "STOP_CLICK",
    "STEP_COMPARE",
    "STEP_END_OF_PASS",
    "STEP_SORT_COMPLETE",
    "AUTO_STEP_COMPARE",
    "AUTO_STEP_END_OF_PASS",
    "AUTO_STEP_SORT_COMPLETE",
    "NEEDS_SWAP",
    "NO_SWAP_STEP_DONE_PLAY",
    "NO_SWAP_STEP_DONE_PAUSE",
    "ANIMATION_END_PLAY",
    "ANIMATION_END_PAUSE",
    "PASS_CONTINUE_PLAY",
    "PASS_CONTINUE_PAUSE",
    "EARLY_EXIT_BREAK",
    "ORDER_CHANGE",
    "EARLY_EXIT_TOGGLE",
    "SPEED_CHANGE"
  ],
  "notes": "Mapping to implementation: initializing occurs on page load (setSpeed + randomArray + initArray). ready is the idle/start state after any initialization, load, randomize, or reset; pseudocode line 1 is highlighted and SR status announces 'Ready'. paused is any non-playing mid-progress state; Play/Pause button toggles between playing and paused. playing sets state.playing = true, updates Play button text to 'Pause', and runs playLoop which emits AUTO_STEP_* events every state.speed ms. A user 'Step' in ready/paused emits STEP_* events. performStep behavior: (a) If end <= 0 emit STEP_SORT_COMPLETE/AUTO_STEP_SORT_COMPLETE, leading to finished. (b) If j >= end emit STEP_END_OF_PASS/AUTO_STEP_END_OF_PASS, transitioning to pass_transition. (c) Otherwise emit STEP_COMPARE/AUTO_STEP_COMPARE to enter comparing. In comparing, markComparing() occurs, comparisons++ and pseudocode lines [3,4] highlight; if shouldSwap() is true, emit NEEDS_SWAP; else emit NO_SWAP_STEP_DONE_{PLAY|PAUSE} depending on state.playing, which advances index and returns to playing or paused. In swapping, data is swapped, swaps++ and pseudocode lines [5,6] highlight; flipSwap() runs until transitionend and then emits ANIMATION_END_{PLAY|PAUSE} depending on state.playing. pass_transition highlights line [7], checks earlyExit; if no swaps this pass and earlyExit is enabled, emit EARLY_EXIT_BREAK to finished; otherwise mark boundary as sorted, increment pass, reset j, highlight line [2], and emit PASS_CONTINUE_{PLAY|PAUSE} depending on state.playing. finished sets state.finished = true, state.playing = false, highlights pseudocode line [1], announces 'Array sorted!', and marks all bars sorted. From finished, PLAY_TOGGLE triggers resetAlgorithmState() and resetSortedMarkers() before re-entering playing (as per click handler). LOAD_ARRAY_SUCCESS, RANDOMIZE_CLICK, and RESET_CLICK always (re)initialize the array (initArray) and lead to ready unless already in playing, in which case this FSM keeps state as playing with reinitialized data; in the actual code these events can occur during playing without stopping the loop. LOAD_ARRAY_FAILURE only updates the inline error message (inputHelp.textContent) and does not change the algorithmic state; thus it is listed as an event but intentionally has no transition in the states. ORDER_CHANGE, EARLY_EXIT_TOGGLE, and SPEED_CHANGE update configuration in place and do not change states. Keyboard shortcuts: Space -> PLAY_TOGGLE; S or ArrowRight -> STEP_*; R -> RESET_CLICK; G -> RANDOMIZE_CLICK."
}
  </script>
</body>
</html>