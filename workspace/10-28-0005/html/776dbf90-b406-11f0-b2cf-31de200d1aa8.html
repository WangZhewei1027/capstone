<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Interactive Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --surface: #0f172a; /* slate-900 */
      --panel: #111827;   /* gray-900 */
      --text: #e5e7eb;    /* gray-200 */
      --muted: #9ca3af;   /* gray-400 */
      --accent: #22c55e;  /* green-500 */
      --accent-2: #f59e0b;/* amber-500 */
      --danger: #ef4444;  /* red-500 */
      --focus: #93c5fd;   /* blue-300 */
      --bar: #60a5fa;     /* blue-400 */
      --bar-compare: #f59e0b;
      --bar-swap: #ef4444;
      --bar-sorted: #22c55e;
      --control-bg: #1f2937; /* gray-800 */
      --control-border: #374151; /* gray-700 */
      --ring: #3b82f6;
      --radius: 12px;
      --shadow: 0 6px 20px rgba(0,0,0,0.25);
      --transition: 220ms cubic-bezier(.2,.8,.2,1);
    }

    html, body {
      background: conic-gradient(from 180deg at 50% 100%, #0b1225, #0f172a 30%, #0f172a 70%, #0b1225);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 0;
    }

    .container {
      padding: var(--safe-margin);
      min-height: 100vh;
      box-sizing: border-box;
      display: grid;
      grid-template-rows: auto auto auto 1fr auto;
      gap: var(--gap);
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    header.card {
      padding: 24px;
    }

    header h1 {
      margin: 0 0 8px 0;
      font-size: 28px;
      letter-spacing: 0.2px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    .objective.card, .interaction.card, .layout.card {
      padding: 16px 24px;
    }
    .section-title {
      font-weight: 700;
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    .section-body {
      color: var(--muted);
      margin: 0;
    }
    .section-body ul {
      margin: 8px 0 0 20px;
    }

    .controls.card {
      padding: 16px;
      display: grid;
      gap: var(--gap);
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 220px;
      flex: 1 1 240px;
    }
    .control label {
      font-size: 13px;
      color: var(--muted);
    }
    input[type="text"], input[type="number"], input[type="range"], select {
      -webkit-appearance: none;
      appearance: none;
      background: var(--control-bg);
      border: 1px solid var(--control-border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      outline: none;
      transition: border var(--transition), box-shadow var(--transition);
    }
    input[type="range"] {
      padding: 0;
      height: 32px;
    }
    input:focus, select:focus {
      border-color: var(--ring);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }
    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
    }
    button {
      -webkit-appearance: none;
      appearance: none;
      background: linear-gradient(180deg, #2563eb, #1d4ed8);
      border: none;
      color: white;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 120ms ease, box-shadow 200ms ease, background 200ms;
      cursor: pointer;
      min-width: 120px;
    }
    button.secondary {
      background: linear-gradient(180deg, #374151, #1f2937);
      color: var(--text);
      border: 1px solid var(--control-border);
    }
    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.35);
    }
    button:active {
      transform: translateY(1px);
    }
    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .stage.card {
      padding: 16px;
      display: grid;
      gap: var(--gap);
    }
    .stage-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      flex-wrap: wrap;
    }
    .legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 13px;
    }
    .legend .dot {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend .dot::before {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    .dot.compare::before { background: var(--bar-compare); }
    .dot.swap::before { background: var(--bar-swap); }
    .dot.sorted::before { background: var(--bar-sorted); }

    .bars-wrap {
      position: relative;
      height: 280px;
      border: 1px dashed rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    }

    .bars {
      position: absolute;
      inset: 12px;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap: 8px;
      align-items: end;
    }

    .bar {
      position: relative;
      height: 20px; /* overridden dynamically */
      background: linear-gradient(180deg, #60a5fa, #3b82f6);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(59,130,246,0.35);
      transform: translateZ(0); /* enable GPU compositing */
      transition: transform var(--transition), background var(--transition), box-shadow var(--transition), outline var(--transition);
      outline: none;
    }
    .bar[draggable="true"] {
      cursor: grab;
    }
    .bar:active {
      cursor: grabbing;
    }
    .bar-label {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31,41,55,0.85);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 4px 6px;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text);
      white-space: nowrap;
      backdrop-filter: blur(3px);
      pointer-events: none;
    }
    .bar.compare {
      background: linear-gradient(180deg, var(--bar-compare), #f59e0b);
      box-shadow: 0 2px 12px rgba(245,158,11,0.45);
    }
    .bar.swap {
      background: linear-gradient(180deg, var(--bar-swap), #dc2626);
      box-shadow: 0 2px 12px rgba(239,68,68,0.45);
    }
    .bar.sorted {
      background: linear-gradient(180deg, var(--bar-sorted), #16a34a);
      box-shadow: 0 2px 12px rgba(34,197,94,0.45);
      opacity: 0.95;
    }
    .bar:focus-visible {
      box-shadow: 0 0 0 3px rgba(147,197,253,0.6);
    }

    .explain.card {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: var(--gap);
      padding: 16px;
    }
    @media (max-width: 900px) {
      .explain.card {
        grid-template-columns: 1fr;
      }
    }
    .callout {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
    }
    .callout h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .callout .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
      min-height: 84px;
      max-height: 140px;
      overflow: auto;
      padding-right: 6px;
    }
    .pseudo {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 13px;
      color: var(--text);
    }
    .pseudo .line {
      padding: 4px 6px;
      border-radius: 6px;
    }
    .pseudo .line.active {
      background: rgba(59,130,246,0.18);
      border-left: 3px solid var(--ring);
    }
    .pseudo .line.comment {
      color: var(--muted);
    }

    .footer.card {
      padding: 16px 24px;
      color: var(--muted);
      font-size: 13px;
    }

    /* Accessibility helper for live narration */
    .sr-only {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Concept Title -->
    <header class="card" role="banner">
      <h1>Bubble Sort: Compare, Swap, Repeat</h1>
      <p>An interactive, visual walkthrough of bubble sort — one comparison at a time.</p>
    </header>

    <!-- Learning Objective -->
    <section class="objective card" aria-labelledby="obj-title">
      <h2 id="obj-title" class="section-title">Learning Objective</h2>
      <div class="section-body">
        <ul>
          - Understand how bubble sort repeatedly compares adjacent elements and swaps out-of-order pairs.
          - See how completed passes “bubble” the largest remaining value to the end and grow the sorted region.
          - Experience the algorithm step-by-step and control speed, data, and progression (play/pause/step).
        </ul>
      </div>
    </section>

    <!-- Interaction Design -->
    <section class="interaction card" aria-labelledby="interaction-title">
      <h2 id="interaction-title" class="section-title">Interaction Design</h2>
      <div class="section-body">
        <ul>
          - Typing: Enter a comma-separated list of numbers or set the size and randomize to generate values.
          - Clicking: Use Play, Pause, Step, Reset to control the algorithm. Speed slider changes animation time.
          - Dragging: Rearrange bars before starting by dragging them; this helps create your own scenarios.
          - Visual feedback: Compared bars glow amber; swaps glow red and animate to new positions; after each pass, the sorted tail turns green.
          - Narration: The Explanation panel describes the current comparison/swaps and highlights matching pseudocode lines.
          - Keyboard: Space toggles play/pause; N steps; R randomizes for quick experimentation.
        </ul>
      </div>
    </section>

    <!-- Layout Description -->
    <section class="layout card" aria-labelledby="layout-title">
      <h2 id="layout-title" class="section-title">Layout Description</h2>
      <div class="section-body">
        <ul>
          - Safe area margins: 24 px padding around the entire viewport to keep content readable.
          - Organization: Title and goals at top, controls next, central stage for bars, explanation below, footer last.
          - Spacing: Minimum 16 px between interactive controls (buttons, inputs, sliders) to prevent mis-clicks.
          - Accessibility: High-contrast colors, focus rings, aria-live narration, keyboard shortcuts. Draggable bars are focusable for device compatibility.
          - Responsiveness: The bars scale to the container width; controls wrap as needed; explanation panel collapses to a single column on smaller screens.
        </ul>
      </div>
    </section>

    <!-- Controls -->
    <section class="controls card" aria-label="Controls">
      <div class="controls-row">
        <div class="control">
          <label for="listInput">Numbers (comma-separated)</label>
          <input id="listInput" type="text" value="7,3,9,1,5,2" aria-describedby="listHelp" />
          <small id="listHelp" style="color: var(--muted);">Example: 7, 3, 9, 1, 5, 2 (values 1–99)</small>
        </div>
        <div class="control">
          <label for="sizeInput">Size</label>
          <input id="sizeInput" type="number" min="3" max="20" value="6" />
        </div>
        <div class="control">
          <label for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="0.2" max="2" step="0.1" value="1" aria-label="Animation speed multiplier" />
        </div>
      </div>
      <div class="btn-row" role="group" aria-label="Action buttons">
        <button id="applyBtn" class="secondary" title="Apply typed list">Apply List</button>
        <button id="randomBtn" class="secondary" title="Randomize numbers">Randomize</button>
        <button id="playBtn" title="Start bubble sort (Space)">Play</button>
        <button id="pauseBtn" class="secondary" title="Pause bubble sort">Pause</button>
        <button id="stepBtn" class="secondary" title="Do next step (N)">Step</button>
        <button id="resetBtn" class="secondary" title="Reset">Reset</button>
      </div>
    </section>

    <!-- Stage -->
    <section class="stage card" aria-label="Sorting Stage">
      <div class="stage-top">
        <div class="legend" aria-hidden="true">
          <span class="dot compare">Compare</span>
          <span class="dot swap">Swap</span>
          <span class="dot sorted">Sorted tail</span>
        </div>
        <div id="statusText" style="color: var(--muted); font-size: 13px;">Ready.</div>
      </div>

      <div class="bars-wrap">
        <div id="bars" class="bars" aria-live="polite" aria-label="Array bars"></div>
      </div>
    </section>

    <!-- Explanation -->
    <section class="explain card" aria-label="Explanation and pseudocode">
      <div class="callout">
        <h3>Explanation</h3>
        <div id="explainLog" class="log" aria-live="polite">
          Use Play or Step to begin. The panel narrates each compare and swap, and passes.
        </div>
      </div>
      <div class="pseudo" aria-label="Bubble sort pseudocode">
        <div class="line comment">// Bubble Sort (optimized with early exit)</div>
        <div class="line" data-line="1">for pass from 0 to n-2:</div>
        <div class="line" data-line="2">  swapped = false</div>
        <div class="line" data-line="3">  for j from 0 to n-2-pass:</div>
        <div class="line" data-line="4">    compare A[j] and A[j+1]</div>
        <div class="line" data-line="5">    if A[j] &gt; A[j+1]:</div>
        <div class="line" data-line="6">      swap(A[j], A[j+1]); swapped = true</div>
        <div class="line" data-line="7">  if not swapped: break // already sorted</div>
        <div class="line" data-line="8">return A</div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="footer card">
      Keyboard shortcuts: Space = Play/Pause, N = Step, R = Randomize. Drag bars to rearrange before starting. This module focuses exclusively on bubble sort.
    </footer>
  </div>

  <!-- Live narration for screen readers -->
  <div id="srLive" class="sr-only" aria-live="assertive"></div>

  <script>
    // State
    const state = {
      arr: [],
      generator: null,
      playing: false,
      pass: 0,
      j: 0,
      speed: 1,
      sortedTail: 0,
      animMs: 500, // base animation (multiplied by speed)
      busy: false
    };

    // Elements
    const barsEl = document.getElementById('bars');
    const listInput = document.getElementById('listInput');
    const sizeInput = document.getElementById('sizeInput');
    const speedRange = document.getElementById('speedRange');
    const applyBtn = document.getElementById('applyBtn');
    const randomBtn = document.getElementById('randomBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stepBtn = document.getElementById('stepBtn');
    const resetBtn = document.getElementById('resetBtn');
    const explainLog = document.getElementById('explainLog');
    const statusText = document.getElementById('statusText');
    const srLive = document.getElementById('srLive');
    const pseudoLines = document.querySelectorAll('.pseudo .line');

    // Utility
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    function parseList(str) {
      const nums = str.split(/[, ]+/).filter(Boolean).map(v => clamp(parseInt(v, 10) || 0, 1, 99));
      return nums.slice(0, 30);
    }

    function randomArray(size) {
      const s = clamp(parseInt(size, 10) || 6, 3, 20);
      const out = [];
      for (let i = 0; i < s; i++) out.push(1 + Math.floor(Math.random() * 99));
      return out;
    }

    function clearExplain() {
      explainLog.textContent = '';
    }
    function logExplain(msg) {
      const line = document.createElement('div');
      line.textContent = msg;
      explainLog.appendChild(line);
      explainLog.scrollTop = explainLog.scrollHeight;
      srLive.textContent = msg;
    }

    function setStatus(msg) {
      statusText.textContent = msg;
    }

    function highlightPseudo(lines = []) {
      pseudoLines.forEach(el => {
        el.classList.toggle('active', lines.includes(el.dataset.line));
      });
    }

    // Bars rendering and FLIP swapping
    function renderBars(arr) {
      barsEl.innerHTML = '';
      const max = Math.max(...arr, 1);
      arr.forEach((val, idx) => {
        const wrap = document.createElement('div');
        wrap.className = 'bar';
        wrap.tabIndex = 0;
        wrap.setAttribute('draggable', 'true');
        wrap.dataset.index = String(idx);
        wrap.dataset.value = String(val);
        const pct = (val / max) * 100;
        wrap.style.height = `calc(${pct}% - 6px)`; // keep some breathing room
        const label = document.createElement('div');
        label.className = 'bar-label';
        label.textContent = String(val);
        wrap.appendChild(label);
        barsEl.appendChild(wrap);
      });
      attachDragHandlers();
    }

    function markSortedTail(tailCount) {
      const children = [...barsEl.children];
      children.forEach((el, i) => {
        el.classList.remove('sorted');
      });
      if (tailCount <= 0) return;
      const n = children.length;
      for (let i = n - tailCount; i < n; i++) {
        children[i]?.classList.add('sorted');
      }
    }

    function clearHighlights() {
      [...barsEl.children].forEach(el => el.classList.remove('compare', 'swap'));
      highlightPseudo([]);
    }

    function compareHighlight(j) {
      clearHighlights();
      const a = barsEl.children[j];
      const b = barsEl.children[j + 1];
      if (!a || !b) return;
      a.classList.add('compare');
      b.classList.add('compare');
      highlightPseudo(['4']);
    }

    function swapHighlight(j) {
      clearHighlights();
      const a = barsEl.children[j];
      const b = barsEl.children[j + 1];
      if (!a || !b) return;
      a.classList.add('swap');
      b.classList.add('swap');
      highlightPseudo(['6']);
    }

    async function animateSwap(j) {
      const a = barsEl.children[j];
      const b = barsEl.children[j + 1];
      if (!a || !b) return;

      const rectA1 = a.getBoundingClientRect();
      const rectB1 = b.getBoundingClientRect();

      // Swap DOM
      b.after(a);

      const rectA2 = a.getBoundingClientRect();
      const rectB2 = b.getBoundingClientRect();

      const dxA = rectA1.left - rectA2.left;
      const dxB = rectB1.left - rectB2.left;

      a.style.transform = `translateX(${dxA}px)`;
      b.style.transform = `translateX(${dxB}px)`;

      // Force reflow
      a.getBoundingClientRect();
      b.getBoundingClientRect();

      const duration = state.animMs / state.speed;
      a.style.transition = `transform ${duration}ms cubic-bezier(.2,.8,.2,1)`;
      b.style.transition = `transform ${duration}ms cubic-bezier(.2,.8,.2,1)`;
      a.style.transform = 'translateX(0)';
      b.style.transform = 'translateX(0)';

      await new Promise(res => setTimeout(res, duration));

      a.style.transition = '';
      b.style.transition = '';
    }

    // Bubble sort generator
    function* bubbleSortGenerator(a) {
      const n = a.length;
      for (let pass = 0; pass < n - 1; pass++) {
        let swapped = false;
        yield { type: 'passStart', pass };
        for (let j = 0; j < n - 1 - pass; j++) {
          yield { type: 'compare', j, j1: j + 1, pass };
          if (a[j] > a[j + 1]) {
            const tmp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = tmp;
            swapped = true;
            yield { type: 'swap', j, j1: j + 1, pass };
          } else {
            yield { type: 'noswap', j, j1: j + 1, pass };
          }
        }
        yield { type: 'passEnd', pass, swapped };
        if (!swapped) {
          yield { type: 'earlyExit', pass };
          break;
        }
      }
      yield { type: 'done' };
    }

    // Control flow
    async function runAuto() {
      if (!state.generator) return;
      state.playing = true;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      stepBtn.disabled = true;
      setStatus('Playing...');
      while (state.playing) {
        const cont = await doStep();
        if (!cont) break;
        await new Promise(res => setTimeout(res, 120 / state.speed)); // small delay between steps
      }
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stepBtn.disabled = false;
      setStatus('Paused.');
    }

    async function doStep() {
      if (!state.generator) return false;
      if (state.busy) return true;
      const next = state.generator.next();
      if (next.done) {
        clearHighlights();
        markSortedTail(state.arr.length);
        setStatus('Sorted!');
        logExplain('Done: array is fully sorted.');
        highlightPseudo(['8']);
        state.playing = false;
        return false;
      }
      const ev = next.value;
      switch (ev.type) {
        case 'passStart':
          clearHighlights();
          state.sortedTail = ev.pass;
          markSortedTail(ev.pass);
          highlightPseudo(['1','2','3']);
          logExplain(`Pass ${ev.pass + 1}: starting comparisons.`);
          setStatus(`Pass ${ev.pass + 1}`);
          break;
        case 'compare':
          compareHighlight(ev.j);
          logExplain(`Compare indices ${ev.j} and ${ev.j + 1} (${state.arr[ev.j]} vs ${state.arr[ev.j + 1]})`);
          setStatus(`Comparing ${ev.j} and ${ev.j + 1}`);
          break;
        case 'swap':
          swapHighlight(ev.j);
          logExplain(`Swap: ${state.arr[ev.j]} and ${state.arr[ev.j + 1]} were out of order.`);
          setStatus(`Swapping ${ev.j} and ${ev.j + 1}`);
          state.busy = true;
          await animateSwap(ev.j);
          state.busy = false;
          break;
        case 'noswap':
          logExplain(`No swap needed.`);
          setStatus(`No swap`);
          break;
        case 'passEnd':
          clearHighlights();
          const tail = ev.pass + 1;
          markSortedTail(tail);
          logExplain(`End of pass ${ev.pass + 1}: largest remaining value bubbled to position ${state.arr.length - tail}.`);
          setStatus(`Pass ${ev.pass + 1} complete`);
          highlightPseudo(['7']);
          break;
        case 'earlyExit':
          clearHighlights();
          markSortedTail(state.arr.length);
          logExplain(`Early exit: no swaps in last pass → array is already sorted.`);
          setStatus('Early exit: sorted');
          break;
        default:
          break;
      }
      return true;
    }

    // Drag-and-drop to rearrange before sorting
    function attachDragHandlers() {
      const bars = [...barsEl.children];
      bars.forEach(bar => {
        bar.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/plain', bar.dataset.index);
          bar.style.opacity = '0.8';
        });
        bar.addEventListener('dragend', () => {
          bar.style.opacity = '1';
        });
        bar.addEventListener('dragover', e => {
          e.preventDefault();
          bar.style.outline = `2px dashed ${getComputedStyle(document.documentElement).getPropertyValue('--ring')}`;
        });
        bar.addEventListener('dragleave', () => {
          bar.style.outline = '';
        });
        bar.addEventListener('drop', e => {
          e.preventDefault();
          bar.style.outline = '';
          const fromIdx = parseInt(e.dataTransfer.getData('text/plain'), 10);
          const toIdx = parseInt(bar.dataset.index, 10);
          if (Number.isInteger(fromIdx) && Number.isInteger(toIdx) && fromIdx !== toIdx) {
            const val = state.arr[fromIdx];
            state.arr.splice(fromIdx, 1);
            state.arr.splice(toIdx, 0, val);
            renderBars(state.arr);
            clearExplain();
            setStatus('Reordered by drag. Ready.');
          }
        });
      });
    }

    // Controls handlers
    function resetState(arr) {
      state.arr = arr.slice();
      state.generator = bubbleSortGenerator(state.arr.slice()); // generator works on a copy for logic, we animate DOM for swaps
      renderBars(state.arr);
      clearHighlights();
      markSortedTail(0);
      setStatus('Ready.');
      clearExplain();
      logExplain(`Array: [${state.arr.join(', ')}]`);
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stepBtn.disabled = false;
      state.playing = false;
    }

    function applyList() {
      const arr = parseList(listInput.value);
      if (arr.length < 3) {
        setStatus('Please provide at least 3 numbers (1–99).');
        return;
      }
      sizeInput.value = arr.length;
      resetState(arr);
    }

    function randomize() {
      const arr = randomArray(sizeInput.value);
      listInput.value = arr.join(', ');
      resetState(arr);
    }

    function resetAll() {
      resetState(parseList(listInput.value));
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT') return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (state.playing) {
          state.playing = false;
          setStatus('Paused.');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          stepBtn.disabled = false;
        } else {
          runAuto();
        }
      } else if (e.key.toLowerCase() === 'n') {
        e.preventDefault();
        doStep();
      } else if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        randomize();
      }
    });

    // Wire controls
    applyBtn.addEventListener('click', applyList);
    randomBtn.addEventListener('click', randomize);
    playBtn.addEventListener('click', runAuto);
    pauseBtn.addEventListener('click', () => {
      state.playing = false;
      setStatus('Paused.');
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stepBtn.disabled = false;
    });
    stepBtn.addEventListener('click', () => { doStep(); });
    resetBtn.addEventListener('click', resetAll);
    speedRange.addEventListener('input', () => {
      state.speed = parseFloat(speedRange.value) || 1;
      setStatus(`Speed: ${state.speed.toFixed(1)}x`);
    });

    // Init
    (function init() {
      state.speed = parseFloat(speedRange.value) || 1;
      const arr = parseList(listInput.value);
      resetState(arr);
      setStatus('Ready.');
      logExplain('Use controls to start. You can drag bars to reorder before playing.');
      highlightPseudo([]);
    })();

    // Resize handling to ensure labels remain readable
    window.addEventListener('resize', () => {
      // No special handling needed; bars are responsive.
    });
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for the Bubble Sort interactive module, covering user controls (play/pause/step/reset), drag-and-drop reordering, speed adjustments, and algorithm visualization phases (pass start, comparing, swapping, no-swap, pass end, early exit, done).",
  "states": [
    {
      "name": "ready",
      "onEnter": "SET_READY_UI",
      "on": {
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "KEY_RANDOMIZE_R": "ready",
        "PLAY_CLICK": "playing",
        "SPACE_TOGGLE_PLAY": "playing",
        "STEP_CLICK": "pass_start",
        "KEY_STEP_N": "pass_start",
        "BAR_DRAG_START": "dragging",
        "SPEED_CHANGE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "SET_PLAYING_TRUE_UPDATE_BUTTONS_AND_STATUS",
      "onExit": "SET_PLAYING_FALSE_UPDATE_BUTTONS_ON_EXIT",
      "on": {
        "PAUSE_CLICK": "paused",
        "SPACE_TOGGLE_PAUSE": "paused",
        "PASS_START": "pass_start",
        "COMPARE": "comparing",
        "SWAP": "swapping",
        "NO_SWAP": "no_swap",
        "PASS_END": "pass_end",
        "EARLY_EXIT": "early_exit",
        "DONE": "done",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "BAR_DRAG_START": "dragging",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "paused",
      "onEnter": "SET_PLAYING_FALSE_UPDATE_BUTTONS_AND_STATUS",
      "on": {
        "PLAY_CLICK": "playing",
        "SPACE_TOGGLE_PLAY": "playing",
        "PASS_START": "pass_start",
        "COMPARE": "comparing",
        "SWAP": "swapping",
        "NO_SWAP": "no_swap",
        "PASS_END": "pass_end",
        "EARLY_EXIT": "early_exit",
        "DONE": "done",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "BAR_DRAG_START": "dragging",
        "SPEED_CHANGE": "paused"
      }
    },
    {
      "name": "pass_start",
      "onEnter": "CLEAR_HIGHLIGHTS_MARK_SORTED_TAIL_START_AND_LOG",
      "on": {
        "COMPARE": "comparing",
        "EARLY_EXIT": "early_exit",
        "DONE": "done",
        "PAUSE_CLICK": "paused",
        "PLAY_CLICK": "playing",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "pass_start"
      }
    },
    {
      "name": "comparing",
      "onEnter": "HIGHLIGHT_COMPARE_AND_LOG",
      "on": {
        "SWAP": "swapping",
        "NO_SWAP": "no_swap",
        "DONE": "done",
        "PAUSE_CLICK": "paused",
        "PLAY_CLICK": "playing",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "comparing"
      }
    },
    {
      "name": "swapping",
      "onEnter": "HIGHLIGHT_SWAP_ANIMATE_AND_SET_BUSY",
      "onExit": "CLEAR_BUSY",
      "on": {
        "PASS_END": "pass_end",
        "COMPARE": "comparing",
        "DONE": "done",
        "EARLY_EXIT": "early_exit",
        "SWAP_ANIMATION_DONE": "playing",
        "PAUSE_CLICK": "paused",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "swapping"
      }
    },
    {
      "name": "no_swap",
      "onEnter": "LOG_NO_SWAP_SET_STATUS",
      "on": {
        "COMPARE": "comparing",
        "PASS_END": "pass_end",
        "DONE": "done",
        "PAUSE_CLICK": "paused",
        "PLAY_CLICK": "playing",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "no_swap"
      }
    },
    {
      "name": "pass_end",
      "onEnter": "CLEAR_HIGHLIGHTS_MARK_TAIL_AND_LOG",
      "on": {
        "PASS_START": "pass_start",
        "EARLY_EXIT": "early_exit",
        "DONE": "done",
        "PAUSE_CLICK": "paused",
        "PLAY_CLICK": "playing",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "pass_end"
      }
    },
    {
      "name": "early_exit",
      "onEnter": "CLEAR_HIGHLIGHTS_MARK_ALL_SORTED_AND_LOG",
      "on": {
        "DONE": "done",
        "PAUSE_CLICK": "paused",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "early_exit"
      }
    },
    {
      "name": "dragging",
      "onEnter": "DRAG_FEEDBACK_ON",
      "onExit": "DRAG_FEEDBACK_OFF",
      "on": {
        "BAR_DRAG_OVER": "dragging",
        "BAR_DRAG_LEAVE": "dragging",
        "BAR_DROP": "ready",
        "BAR_DRAG_END": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "SPEED_CHANGE": "dragging"
      }
    },
    {
      "name": "done",
      "onEnter": "CLEAR_HIGHLIGHTS_MARK_ALL_SORTED_LOG_DONE_STOP_PLAY",
      "on": {
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "PLAY_CLICK": "playing",
        "SPACE_TOGGLE_PLAY": "playing",
        "SPEED_CHANGE": "done"
      }
    }
  ],
  "events": [
    "APPLY_CLICK",
    "RANDOMIZE_CLICK",
    "RESET_CLICK",
    "PLAY_CLICK",
    "PAUSE_CLICK",
    "STEP_CLICK",
    "SPACE_TOGGLE_PLAY",
    "SPACE_TOGGLE_PAUSE",
    "KEY_STEP_N",
    "KEY_RANDOMIZE_R",
    "SPEED_CHANGE",
    "BAR_DRAG_START",
    "BAR_DRAG_OVER",
    "BAR_DRAG_LEAVE",
    "BAR_DROP",
    "BAR_DRAG_END",
    "PASS_START",
    "COMPARE",
    "SWAP",
    "NO_SWAP",
    "PASS_END",
    "EARLY_EXIT",
    "DONE",
    "SWAP_ANIMATION_DONE"
  ],
  "notes": "Modes: ready/playing/paused/done; Visualization phases: pass_start, comparing, swapping (with busy animation), no_swap, pass_end, early_exit. User actions: Apply List, Randomize, Reset reset to ready by calling resetState() (renders bars, clears highlights, marks sorted tail 0, sets status 'Ready.', logs array, and updates buttons). Play/Space (play) enters playing and runs runAuto() loop (enables Pause, disables Step, status 'Playing...'); Pause/Space (pause) enters paused (playing=false, Play enabled, Pause disabled, Step enabled, status 'Paused.'). Step (button or 'N') triggers doStep() once; that yields generator events (PASS_START, COMPARE, SWAP, NO_SWAP, PASS_END, EARLY_EXIT, DONE) which transition to corresponding visualization states. In swapping, busy=true is set and animateSwap(j) runs; upon completion (conceptual SWAP_ANIMATION_DONE), busy=false; subsequent generator events transition out to COMPARE or PASS_END. Dragging bars is available primarily when not auto-playing: BAR_DRAG_START enters dragging; BAR_DROP reorders state.arr, re-renders bars, clears explain, sets status 'Reordered by drag. Ready.' then transitions to ready. Speed slider input emits SPEED_CHANGE in any state and updates state.speed and status ('Speed: x.xx'), without changing state. Done: doStep sees next.done, clears highlights, marks entire array sorted, logs 'Done' and highlights pseudocode line 8, sets status 'Sorted!', playing=false. The runAuto loop then exits and buttons reflect paused state. Generator events are produced by doStep(), invoked either by runAuto() (auto ticks) or via Step; transitions here treat those yields as FSM events. Button enable/disable updates are captured in onEnter/onExit action names for playing/paused; visual feedback updates are captured in the onEnter action names for the algorithm phases."
}
  </script>
</body>
</html>