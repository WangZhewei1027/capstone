<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort — Adjacent Comparisons and Swaps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f172a;           /* slate-900 */
      --panel: #111827;        /* gray-900 */
      --text: #e5e7eb;         /* gray-200 */
      --muted: #9ca3af;        /* gray-400 */
      --accent: #22c55e;       /* green-500 */
      --accent-2: #60a5fa;     /* blue-400 */
      --warn: #f97316;         /* orange-500 */
      --danger: #ef4444;       /* red-500 */
      --focus: #a78bfa;        /* violet-400 */
      --node: #1f2937;         /* gray-800 */
      --node-border: #374151;  /* gray-700 */
      --highlight: rgba(96, 165, 250, 0.25);
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.5;
    }

    main {
      padding: var(--safe-margin);
      box-sizing: border-box;
      max-width: 1100px;
      margin: 0 auto;
    }

    h1, h2 {
      margin: 0 0 8px 0;
      line-height: 1.2;
    }

    h1 {
      font-size: 1.75rem;
    }

    h2 {
      font-size: 1.25rem;
    }

    p {
      margin: 0 0 12px 0;
      color: var(--muted);
    }

    .section {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    @media (min-width: 800px) {
      .controls {
        grid-template-columns: 2fr 1.5fr 1fr;
      }
    }

    .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: flex-end;
    }

    label {
      display: block;
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 6px;
    }

    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 8px;
      color: var(--text);
      outline: none;
    }

    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.2);
    }

    .inline {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #0b1220;
      color: var(--text);
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      background: #0d1528;
    }
    .btn:focus-visible {
      outline: none;
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.35);
    }
    .btn.primary {
      background: #0d1528;
      border-color: #253152;
    }
    .btn.success { border-color: var(--accent); color: var(--accent); }
    .btn.warn { border-color: var(--warn); color: var(--warn); }
    .btn.danger { border-color: var(--danger); color: var(--danger); }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .switch input {
      width: 44px;
      height: 24px;
      appearance: none;
      background: #111827;
      border: 1px solid #374151;
      border-radius: 12px;
      position: relative;
      cursor: pointer;
      outline: none;
      transition: background 160ms ease, border-color 160ms ease;
    }
    .switch input::after {
      content: "";
      width: 18px;
      height: 18px;
      background: #e5e7eb;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 160ms ease, background 160ms ease;
    }
    .switch input:checked {
      background: #153254;
      border-color: var(--accent-2);
    }
    .switch input:checked::after {
      background: var(--accent-2);
      transform: translateX(20px);
    }

    .visual {
      position: relative;
      overflow: hidden;
      padding: 20px;
      border-radius: 12px;
      background: radial-gradient(1200px 400px at 20% 0%, #0b1220 0%, #0a101b 40%, #091018 100%);
      border: 1px solid #1f2937;
    }

    .timeline {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }

    .timeline .badge {
      font-size: 0.85rem;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #0d1528;
      color: var(--muted);
    }

    /* List display area */
    .list-area {
      position: relative;
      min-height: 140px;
      border-radius: 12px;
      background: #0c1423;
      border: 1px dashed #233045;
      padding: 16px;
    }

    /* Bars representation */
    .bars {
      display: flex;
      align-items: flex-end;
      gap: 12px;
      height: 100%;
      min-height: 120px;
    }
    .bar {
      flex: 1 1 auto;
      min-width: 28px;
      background: linear-gradient(180deg, #1e293b, #0f172a);
      border: 1px solid #334155;
      border-radius: 6px;
      position: relative;
      transform-origin: bottom center;
      transition: background 160ms ease, border-color 160ms ease;
    }
    .bar.highlight {
      box-shadow: 0 0 0 6px var(--highlight);
      border-color: var(--accent-2);
      background: linear-gradient(180deg, #1f2d3f, #12203a);
    }
    .bar span {
      position: absolute;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.85rem;
      color: var(--muted);
    }

    /* Linked nodes representation */
    .nodes-wrap {
      position: relative;
      min-height: 120px;
    }
    .nodes {
      display: flex;
      align-items: center;
      gap: 24px;
      position: relative;
      z-index: 2;
    }
    .node {
      width: 60px;
      height: 60px;
      background: var(--node);
      border: 1px solid var(--node-border);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: background 160ms ease, border-color 160ms ease;
    }
    .node.highlight {
      box-shadow: 0 0 0 6px var(--highlight);
      border-color: var(--accent-2);
      background: #1b2435;
    }
    .node span {
      font-weight: 600;
    }
    .links {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    .links line {
      stroke: #334155;
      stroke-width: 2;
      marker-end: url(#arrow);
    }

    /* Explanation box */
    .explain {
      margin-top: 12px;
      padding: 12px;
      border-radius: 10px;
      background: #0b1220;
      border: 1px solid #1f2937;
      color: var(--text);
    }
    .explain strong { color: var(--accent-2); }
    .explain .ok { color: var(--accent); }
    .explain .warn { color: var(--warn); }
    .explain .danger { color: var(--danger); }

    /* Footer sections */
    .meta {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }
    @media (min-width: 900px) {
      .meta {
        grid-template-columns: 1fr 1fr;
      }
    }
    details {
      border: 1px solid #1f2937;
      border-radius: 12px;
      background: #0b1220;
      padding: 12px;
    }
    summary {
      cursor: pointer;
      font-weight: 600;
      margin-bottom: 8px;
      outline: none;
    }

    /* Utility and spacing */
    .sr-only {
      position: absolute;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0);
      white-space: nowrap; border: 0;
    }
    .spacer { height: 8px; }

    /* Keyboard hint chips */
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #263146;
      background: #0d1528;
      color: var(--muted);
      font-size: 0.85rem;
    }
    kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid #334155;
      background: #0c1423;
      color: var(--text);
      font-size: 0.8rem;
    }

    /* Playhead/step indicator */
    .status-line {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .status-pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #263146;
      background: #0d1528;
      color: var(--muted);
      font-size: 0.85rem;
    }

    /* Spacing between interactive elements guarantee */
    .controls .btn,
    .controls input,
    .controls select,
    .switch,
    .inline > * {
      margin-right: 0; /* rely on gap */
    }
  </style>
</head>
<body>
  <main>
    <section class="section" aria-labelledby="title">
      <h1 id="title">Bubble Sort — Adjacent Comparisons and Swaps</h1>
      <p>Interactively explore how bubble sort walks through adjacent pairs, swaps out-of-order neighbors, and completes passes until the list is sorted. Visualize the list as bars or as linked nodes; drive each comparison yourself or watch the algorithm run.</p>
    </section>

    <section class="section" aria-labelledby="objective">
      <h2 id="objective">Learning Objective</h2>
      <ul>
        <li>Understand that bubble sort repeatedly compares adjacent items and swaps when the left item is greater than the right.</li>
        <li>See how the largest elements "bubble" to the end after each pass and how the unsorted range shrinks.</li>
        <li>Experience the early exit optimization: if a pass makes no swaps, the list is already sorted.</li>
        <li>Practice making swap/no-swap decisions to reinforce the comparison rule.</li>
      </ul>
    </section>

    <section class="section controls" aria-label="Controls">
      <div class="control-group" aria-label="List Builder">
        <div style="flex: 2 1 260px;">
          <label for="numbers">Numbers (comma-separated)</label>
          <input id="numbers" type="text" value="7,3,9,2,5,8" aria-describedby="numbers-help" />
          <div id="numbers-help" class="sr-only">Enter integers separated by commas, e.g., 5,3,8,2.</div>
        </div>
        <div style="flex: 1 1 160px;">
          <label for="length">Random length</label>
          <input id="length" type="number" min="3" max="20" value="8" />
        </div>
        <div class="inline" role="group" aria-label="List actions" style="flex: 1 1 200px;">
          <button class="btn primary" id="apply">Apply</button>
          <button class="btn" id="random">Randomize</button>
          <button class="btn danger" id="reset">Reset</button>
        </div>
      </div>

      <div class="control-group" aria-label="Sorting Controls">
        <div style="flex: 1 1 180px;">
          <label for="representation">Representation</label>
          <select id="representation" aria-label="Representation style">
            <option value="bars">Bars (heights)</option>
            <option value="linked">Linked nodes</option>
          </select>
        </div>
        <div style="flex: 1 1 180px;">
          <label for="speed">Animation speed</label>
          <input id="speed" type="range" min="0.25" max="2" step="0.05" value="1" aria-label="Animation speed" />
          <div aria-hidden="true" id="speedLabel" class="muted">1.0x</div>
        </div>
        <div class="inline" role="group" aria-label="Run control buttons" style="flex: 1 1 300px;">
          <button class="btn success" id="play">Play</button>
          <button class="btn warn" id="step">Step</button>
          <button class="btn" id="pause">Pause</button>
        </div>
      </div>

      <div class="control-group" aria-label="Modes and options">
        <div class="switch" aria-label="Practice mode">
          <input id="practice" type="checkbox" role="switch" aria-checked="false" />
          <label for="practice">Practice mode (you decide swap vs no-swap)</label>
        </div>
        <div class="switch" aria-label="Early exit optimization">
          <input id="earlyExit" type="checkbox" role="switch" aria-checked="true" checked />
          <label for="earlyExit">Early exit when a pass has no swaps</label>
        </div>
        <div class="inline" role="group" aria-label="Practice decisions" style="flex: 1 1 320px;">
          <button class="btn success" id="decideSwap" disabled>Swap</button>
          <button class="btn" id="decideKeep" disabled>No Swap</button>
        </div>
        <div class="inline" role="group" aria-label="Keyboard hints">
          <div class="chip"><kbd>Space</kbd> Play/Pause</div>
          <div class="chip"><kbd>→</kbd> Step</div>
          <div class="chip"><kbd>S</kbd> Swap</div>
          <div class="chip"><kbd>N</kbd> No Swap</div>
        </div>
      </div>
    </section>

    <section class="section visual" aria-labelledby="visual">
      <div class="timeline" aria-live="polite">
        <div class="badge">Pass: <span id="passBadge">1</span></div>
        <div class="badge">Comparison: <span id="compBadge">1</span></div>
        <div class="badge">Unsorted range ends at index <span id="unsortedEnd">last</span></div>
      </div>

      <div class="list-area" id="listArea" aria-label="Sortable list visual">
        <div id="barsWrap" class="bars" hidden></div>
        <div id="nodesWrap" class="nodes-wrap" hidden>
          <svg class="links" id="linksSvg" aria-hidden="true"></svg>
          <div id="nodes" class="nodes"></div>
          <svg width="0" height="0" aria-hidden="true">
            <defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="userSpaceOnUse">
                <path d="M0,0 L6,3 L0,6" fill="#334155" />
              </marker>
            </defs>
          </svg>
        </div>
      </div>

      <div class="status-line" style="margin-top: 12px;">
        <div class="status-pill">Swapped this pass: <strong id="swappedFlag">No</strong></div>
        <div class="status-pill">State: <strong id="stateLabel">Ready</strong></div>
      </div>

      <div class="explain" id="explain" aria-live="polite">
        Ready. Click Step to highlight the next adjacent pair. If the left value is greater, bubble sort swaps them.
      </div>
    </section>

    <section class="section meta" aria-label="Module descriptions">
      <div>
        <h2>Interaction Design</h2>
        <ul>
          <li>Click Play to watch bubble sort run; Pause to stop; Step to advance one comparison at a time.</li>
          <li>Toggle Practice mode to make the decision for each highlighted pair: click Swap or No Swap. Immediate feedback shows whether your choice matches the rule.</li>
          <li>Switch between Bars (height proportional to value) and Linked nodes (boxes connected with arrows) to see the same process in two views.</li>
          <li>Adjust Animation speed to slow down or speed up comparisons and swaps.</li>
          <li>Early exit optimization ends the algorithm when a pass makes no swaps, reinforcing that the list is already sorted.</li>
          <li>Keyboard: Space toggles Play/Pause, Right Arrow performs Step, S triggers Swap, N triggers No Swap.</li>
        </ul>
      </div>
      <div>
        <h2>Layout Description</h2>
        <ul>
          <li>Safe area margins are 24 px on all sides. Controls are grouped into three responsive rows with at least 16 px spacing between inputs and buttons.</li>
          <li>The visual occupies a dedicated panel with the current pass and comparison indicators above the list area. Bars or nodes render in a single row with clear highlights for the active pair.</li>
          <li>An explanation box below the visual narrates each action, and status pills summarize the algorithm state and pass swap flag.</li>
          <li>The page is accessible: all controls use labels, the explanation and timeline use aria-live for updates, and contrast meets readability standards. The layout adapts to small screens by stacking control groups.</li>
        </ul>
      </div>
    </section>
  </main>

  <script>
    // Bubble Sort Interactive Module (vanilla JS)

    // State model for bubble sort
    const state = {
      arr: [],
      pass: 0,          // zero-based pass index
      i: 0,             // current comparison index (compare i and i+1)
      swappedInPass: false,
      unsortedEnd: null, // last index included in comparisons for current pass
      done: false,
      practiceMode: false,
      awaitingDecision: false,
      autoTimer: null,
      speed: 1,
      history: []
    };

    // Elements
    const numbersInput = document.getElementById('numbers');
    const lengthInput = document.getElementById('length');
    const applyBtn = document.getElementById('apply');
    const randomBtn = document.getElementById('random');
    const resetBtn = document.getElementById('reset');

    const representationSelect = document.getElementById('representation');
    const speedRange = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const playBtn = document.getElementById('play');
    const stepBtn = document.getElementById('step');
    const pauseBtn = document.getElementById('pause');

    const practiceSwitch = document.getElementById('practice');
    const earlyExitSwitch = document.getElementById('earlyExit');
    const decideSwapBtn = document.getElementById('decideSwap');
    const decideKeepBtn = document.getElementById('decideKeep');

    const passBadge = document.getElementById('passBadge');
    const compBadge = document.getElementById('compBadge');
    const unsortedEndBadge = document.getElementById('unsortedEnd');
    const swappedFlag = document.getElementById('swappedFlag');
    const stateLabel = document.getElementById('stateLabel');
    const explainBox = document.getElementById('explain');

    const barsWrap = document.getElementById('barsWrap');
    const nodesWrap = document.getElementById('nodesWrap');
    const nodesContainer = document.getElementById('nodes');
    const linksSvg = document.getElementById('linksSvg');

    const clamp = (min, val, max) => Math.max(min, Math.min(max, val));

    function parseNumbers(str) {
      const parts = str.split(/[, ]+/).filter(Boolean);
      const arr = parts.map(p => parseInt(p, 10)).filter(n => Number.isFinite(n));
      return arr.slice(0, 20); // cap length for clarity
    }

    function randomArray(len) {
      const L = clamp(3, len, 20);
      const arr = [];
      for (let i = 0; i < L; i++) {
        arr.push(Math.floor(Math.random() * 99) + 1);
      }
      return arr;
    }

    function resetState(arr) {
      state.arr = arr.slice();
      state.pass = 0;
      state.i = 0;
      state.swappedInPass = false;
      state.unsortedEnd = arr.length - 1;
      state.done = false;
      state.practiceMode = practiceSwitch.checked;
      state.awaitingDecision = false;
      state.history = [];
      clearTimer();
      updateUI();
      renderList(true);
      narrate("Ready. Click Step to highlight the next adjacent pair. If the left value is greater, bubble sort swaps them.");
    }

    function updateUI() {
      passBadge.textContent = (state.pass + 1);
      compBadge.textContent = state.i + 1;
      unsortedEndBadge.textContent = state.unsortedEnd;
      swappedFlag.textContent = state.swappedInPass ? "Yes" : "No";
      stateLabel.textContent = state.done ? "Sorted" : (state.awaitingDecision ? "Awaiting decision" : "Running/Ready");

      // Enable/disable practice decision buttons
      decideSwapBtn.disabled = !(state.practiceMode && state.awaitingDecision && !state.done);
      decideKeepBtn.disabled = !(state.practiceMode && state.awaitingDecision && !state.done);

      // View toggle
      const view = representationSelect.value;
      if (view === 'bars') {
        barsWrap.hidden = false;
        nodesWrap.hidden = true;
      } else {
        barsWrap.hidden = true;
        nodesWrap.hidden = false;
      }

      // Play/Pause buttons accessible labels
      playBtn.setAttribute('aria-disabled', state.autoTimer ? 'true' : 'false');
      pauseBtn.setAttribute('aria-disabled', state.autoTimer ? 'false' : 'true');
    }

    function clearTimer() {
      if (state.autoTimer) {
        clearInterval(state.autoTimer);
        state.autoTimer = null;
      }
    }

    function setSpeed(mult) {
      state.speed = mult;
      speedLabel.textContent = `${mult.toFixed(2)}x`;
      // If playing, adjust timer by restarting
      if (state.autoTimer) {
        clearTimer();
        play();
      }
    }

    // FLIP animation: animate reordering smoothly
    function flipAnimate(container, itemsBefore, itemsAfter, durationMs) {
      // Measure initial rects
      const firstRects = new Map();
      itemsBefore.forEach(el => {
        firstRects.set(el.dataset.key, el.getBoundingClientRect());
      });

      // Apply new order already present in DOM (itemsAfter)
      const lastRects = new Map();
      itemsAfter.forEach(el => {
        lastRects.set(el.dataset.key, el.getBoundingClientRect());
      });

      itemsAfter.forEach(el => {
        const key = el.dataset.key;
        const first = firstRects.get(key);
        const last = lastRects.get(key);
        if (!first || !last) return;
        const dx = first.left - last.left;
        const dy = first.top - last.top;
        el.style.transform = `translate(${dx}px, ${dy}px)`;
        el.style.transition = 'none';
      });

      requestAnimationFrame(() => {
        itemsAfter.forEach(el => {
          el.style.transition = `transform ${durationMs}ms ease`;
          el.style.transform = 'translate(0, 0)';
        });
      });

      // Cleanup after transition
      setTimeout(() => {
        itemsAfter.forEach(el => {
          el.style.transition = '';
          el.style.transform = '';
        });
        // Update links if in nodes view
        if (representationSelect.value === 'linked') {
          drawLinks();
        }
      }, durationMs + 20);
    }

    function renderList(initial = false) {
      const view = representationSelect.value;
      const len = state.arr.length;

      if (view === 'bars') {
        barsWrap.innerHTML = '';
        const maxVal = Math.max(...state.arr);
        const beforeItems = initial ? [] : Array.from(barsWrap.children);
        state.arr.forEach((val, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.dataset.key = `k${idx}-${val}-${Math.random().toString(36).slice(2,7)}`;
          const height = Math.max(20, Math.floor((val / maxVal) * 100) + 20);
          bar.style.height = `${height}px`;
          if (idx === state.i || idx === state.i + 1) {
            bar.classList.add('highlight');
          }
          const label = document.createElement('span');
          label.textContent = val;
          bar.appendChild(label);
          barsWrap.appendChild(bar);
        });
        if (!initial) {
          const afterItems = Array.from(barsWrap.children);
          const duration = Math.floor(240 / state.speed);
          flipAnimate(barsWrap, beforeItems, afterItems, duration);
        }
      } else {
        nodesContainer.innerHTML = '';
        const beforeItems = initial ? [] : Array.from(nodesContainer.children);
        state.arr.forEach((val, idx) => {
          const node = document.createElement('div');
          node.className = 'node';
          node.dataset.key = `k${idx}-${val}-${Math.random().toString(36).slice(2,7)}`;
          if (idx === state.i || idx === state.i + 1) {
            node.classList.add('highlight');
          }
          const span = document.createElement('span');
          span.textContent = val;
          node.appendChild(span);
          nodesContainer.appendChild(node);
        });
        if (!initial) {
          const afterItems = Array.from(nodesContainer.children);
          const duration = Math.floor(260 / state.speed);
          flipAnimate(nodesContainer, beforeItems, afterItems, duration);
        } else {
          drawLinks();
        }
        // Always redraw links after initial or when not animating
        if (initial) drawLinks();
      }
    }

    function drawLinks() {
      // Draw arrows between centers of nodes in order
      linksSvg.innerHTML = '';
      const nodes = Array.from(nodesContainer.children);
      const rectParent = nodesContainer.getBoundingClientRect();
      linksSvg.setAttribute('width', rectParent.width);
      linksSvg.setAttribute('height', rectParent.height);
      for (let i = 0; i < nodes.length - 1; i++) {
        const a = nodes[i].getBoundingClientRect();
        const b = nodes[i + 1].getBoundingClientRect();
        const ax = a.left - rectParent.left + a.width / 2;
        const ay = a.top - rectParent.top + a.height / 2;
        const bx = b.left - rectParent.left + b.width / 2;
        const by = b.top - rectParent.top + b.height / 2;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', ax + 30); // start near right edge of first node
        line.setAttribute('y1', ay);
        line.setAttribute('x2', bx - 30); // end near left edge of next node
        line.setAttribute('y2', by);
        linksSvg.appendChild(line);
      }
    }

    function narrate(msg) {
      explainBox.innerHTML = msg;
    }

    function stepComparison(auto = false) {
      if (state.done) {
        narrate('<strong>Completed!</strong> The list is sorted. Press Reset or Randomize to try again.');
        clearTimer();
        updateUI();
        return;
      }

      // If starting a new pass and reached unsortedEnd previously
      if (state.i >= state.unsortedEnd) {
        if (state.swappedInPass) {
          state.pass += 1;
          state.unsortedEnd -= 1;
          state.i = 0;
          state.swappedInPass = false;
          narrate(`Pass <strong>${state.pass}</strong> complete; largest value bubbled to index ${state.unsortedEnd + 1}. Starting next pass; comparisons go up to index ${state.unsortedEnd}.`);
          updateUI();
          renderList();
          return;
        } else {
          // Early exit or completion
          if (earlyExitSwitch.checked) {
            state.done = true;
            narrate('<span class="ok">No swaps in the last pass.</span> Early exit: the list is sorted.');
            updateUI();
            renderList();
            clearTimer();
            return;
          } else {
            // proceed to next pass anyway until pass reaches end
            state.pass += 1;
            state.unsortedEnd -= 1;
            state.i = 0;
            state.swappedInPass = false;
            if (state.unsortedEnd < 0) {
              state.done = true;
              narrate('<strong>Completed!</strong> The list is sorted.');
              updateUI();
              renderList();
              clearTimer();
              return;
            }
            narrate(`Starting pass <strong>${state.pass + 1}</strong>; comparisons up to index ${state.unsortedEnd}.`);
            updateUI();
            renderList();
            return;
          }
        }
      }

      // Highlight current pair
      updateUI();
      renderList();

      const left = state.arr[state.i];
      const right = state.arr[state.i + 1];
      const ruleHolds = left > right;

      if (state.practiceMode && !auto) {
        state.awaitingDecision = true;
        updateUI();
        narrate(`Compare adjacent: <strong>${left}</strong> and <strong>${right}</strong>. Should we swap? Rule: swap if left &gt; right.`);
        return; // wait for user decision
      } else {
        // auto or normal step: perform rule-based action
        if (ruleHolds) {
          // Swap
          const before = state.arr.slice();
          [state.arr[state.i], state.arr[state.i + 1]] = [state.arr[state.i + 1], state.arr[state.i]];
          const after = state.arr.slice();
          state.swappedInPass = true;
          narrate(`Left ${left} &gt; right ${right} → <span class="ok">swap</span>. The larger value moves right.`);
          state.i += 1;
          updateUI();
          renderList();
        } else {
          // No swap
          narrate(`Left ${left} ≤ right ${right} → <span class="warn">no swap</span>. Move to the next pair.`);
          state.i += 1;
          updateUI();
          renderList();
        }
      }
    }

    function decideSwapKeep(doSwap) {
      if (!state.awaitingDecision || state.done) return;
      const left = state.arr[state.i];
      const right = state.arr[state.i + 1];
      const shouldSwap = left > right;

      if (doSwap && shouldSwap) {
        [state.arr[state.i], state.arr[state.i + 1]] = [state.arr[state.i + 1], state.arr[state.i]];
        state.swappedInPass = true;
        narrate(`Correct: ${left} &gt; ${right}. <span class="ok">Swapped.</span>`);
      } else if (!doSwap && !shouldSwap) {
        narrate(`Correct: ${left} ≤ ${right}. <span class="ok">No swap.</span>`);
      } else if (doSwap && !shouldSwap) {
        narrate(`Not needed: ${left} ≤ ${right}. <span class="danger">Swapping would be incorrect.</span>`);
      } else {
        narrate(`Missed: ${left} &gt; ${right}. <span class="danger">We should have swapped.</span>`);
      }
      state.i += 1;
      state.awaitingDecision = false;
      updateUI();
      renderList();
    }

    function play() {
      if (state.done) return;
      clearTimer();
      const interval = clamp(100, Math.floor(600 / state.speed), 2000);
      state.autoTimer = setInterval(() => {
        if (state.practiceMode) {
          // In practice mode, still auto-step highlighting + waiting for decision
          if (!state.awaitingDecision) {
            stepComparison(true);
          }
        } else {
          stepComparison(true);
        }
      }, interval);
      stateLabel.textContent = 'Running';
      playBtn.disabled = true;
      pauseBtn.disabled = false;
    }

    function pause() {
      clearTimer();
      stateLabel.textContent = 'Paused';
      playBtn.disabled = false;
      pauseBtn.disabled = true;
    }

    // Event bindings
    applyBtn.addEventListener('click', () => {
      const arr = parseNumbers(numbersInput.value);
      if (arr.length < 3) {
        narrate('Please enter at least 3 numbers (e.g., 7,3,9,2,5).');
        return;
      }
      resetState(arr);
    });

    randomBtn.addEventListener('click', () => {
      const arr = randomArray(parseInt(lengthInput.value, 10));
      numbersInput.value = arr.join(',');
      resetState(arr);
    });

    resetBtn.addEventListener('click', () => {
      const arr = parseNumbers(numbersInput.value);
      if (arr.length < 3) {
        const def = [7,3,9,2,5,8];
        numbersInput.value = def.join(',');
        resetState(def);
      } else {
        resetState(arr);
      }
    });

    representationSelect.addEventListener('change', () => {
      updateUI();
      renderList(true);
      narrate(`View switched to ${representationSelect.value === 'bars' ? 'Bars' : 'Linked nodes'}. The bubble sort process remains the same.`);
    });

    speedRange.addEventListener('input', () => {
      setSpeed(parseFloat(speedRange.value));
    });

    playBtn.addEventListener('click', play);
    pauseBtn.addEventListener('click', pause);
    stepBtn.addEventListener('click', () => stepComparison(false));

    practiceSwitch.addEventListener('change', () => {
      state.practiceMode = practiceSwitch.checked;
      state.awaitingDecision = false;
      updateUI();
      narrate(state.practiceMode
        ? 'Practice mode ON. For each highlighted pair, choose Swap or No Swap.'
        : 'Practice mode OFF. Click Step or Play to watch bubble sort make decisions automatically.'
      );
    });

    decideSwapBtn.addEventListener('click', () => decideSwapKeep(true));
    decideKeepBtn.addEventListener('click', () => decideSwapKeep(false));

    earlyExitSwitch.addEventListener('change', () => {
      narrate(earlyExitSwitch.checked
        ? 'Early exit enabled: if a pass makes no swaps, the algorithm stops.'
        : 'Early exit disabled: bubble sort will complete all passes even if no swaps occur.'
      );
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return; // ignore when typing
      if (e.code === 'Space') {
        e.preventDefault();
        if (state.autoTimer) pause(); else play();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        stepComparison(false);
      } else if (e.key.toLowerCase() === 's') {
        e.preventDefault();
        decideSwapKeep(true);
      } else if (e.key.toLowerCase() === 'n') {
        e.preventDefault();
        decideSwapKeep(false);
      }
    });

    // Initial setup
    (function init() {
      const arr = parseNumbers(numbersInput.value);
      resetState(arr.length >= 3 ? arr : [7,3,9,2,5,8]);
      setSpeed(parseFloat(speedRange.value));
      updateUI();
    })();

    // Responsive links redraw on resize
    window.addEventListener('resize', () => {
      if (representationSelect.value === 'linked') drawLinks();
    });
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for an interactive bubble sort visualization with manual stepping, auto-run, practice decisions, animations, and view/speed controls.",
  "states": [
    {
      "name": "ready",
      "onEnter": "initialize_ready",
      "on": {
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "STEP_CLICK": "comparing",
        "KEY_RIGHT": "comparing",
        "PLAY_CLICK": "playing",
        "KEY_SPACE": "playing",
        "PRACTICE_TOGGLE_ON": "ready",
        "PRACTICE_TOGGLE_OFF": "ready",
        "REPRESENTATION_CHANGE": "ready",
        "SPEED_CHANGE": "ready",
        "EARLY_EXIT_ENABLE": "ready",
        "EARLY_EXIT_DISABLE": "ready",
        "RESIZE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_auto_timer",
      "onExit": "clear_timer",
      "on": {
        "AUTO_TICK": "comparing",
        "PAUSE_CLICK": "paused",
        "KEY_SPACE": "paused",
        "STEP_CLICK": "comparing",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "RESET_CLICK": "ready",
        "PRACTICE_TOGGLE_ON": "playing",
        "PRACTICE_TOGGLE_OFF": "playing",
        "SPEED_CHANGE": "playing",
        "REPRESENTATION_CHANGE": "playing",
        "EARLY_EXIT_ENABLE": "playing",
        "EARLY_EXIT_DISABLE": "playing",
        "RESIZE": "playing",
        "SORT_COMPLETE": "done",
        "EARLY_EXIT_TRIGGERED": "done"
      }
    },
    {
      "name": "paused",
      "onEnter": "pause_and_label",
      "on": {
        "PLAY_CLICK": "playing",
        "KEY_SPACE": "playing",
        "STEP_CLICK": "comparing",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "paused",
        "SPEED_CHANGE": "paused",
        "RESIZE": "paused"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_pair_and_render",
      "on": {
        "DECISION_REQUIRED": "awaiting_decision",
        "RULE_SWAP": "swapping",
        "RULE_NO_SWAP": "no_swap",
        "PASS_BOUNDARY_REACHED": "pass_check",
        "PAUSE_CLICK": "paused",
        "REPRESENTATION_CHANGE": "comparing",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready"
      }
    },
    {
      "name": "awaiting_decision",
      "onEnter": "prompt_user_decision",
      "on": {
        "DECIDE_SWAP_CLICK": "swapping",
        "KEY_S": "swapping",
        "DECIDE_KEEP_CLICK": "no_swap",
        "KEY_N": "no_swap",
        "PRACTICE_TOGGLE_OFF": "ready",
        "PAUSE_CLICK": "paused",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "awaiting_decision"
      }
    },
    {
      "name": "swapping",
      "onEnter": "apply_swap_and_render",
      "on": {
        "ANIMATION_DONE": "playing",
        "PAUSE_CLICK": "paused",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "swapping"
      }
    },
    {
      "name": "no_swap",
      "onEnter": "render_no_swap_feedback",
      "on": {
        "ANIMATION_DONE": "playing",
        "PAUSE_CLICK": "paused",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "no_swap"
      }
    },
    {
      "name": "pass_check",
      "onEnter": "evaluate_pass_end",
      "on": {
        "PASS_HAS_SWAPS": "pass_started",
        "PASS_NO_SWAPS": "pass_started",
        "EARLY_EXIT_TRIGGERED": "done",
        "SORT_COMPLETE": "done",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "pass_check"
      }
    },
    {
      "name": "pass_started",
      "onEnter": "initialize_next_pass",
      "on": {
        "AUTO_TICK": "comparing",
        "STEP_CLICK": "comparing",
        "PAUSE_CLICK": "paused",
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "pass_started"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sorted",
      "on": {
        "RESET_CLICK": "ready",
        "APPLY_CLICK": "ready",
        "RANDOMIZE_CLICK": "ready",
        "REPRESENTATION_CHANGE": "done",
        "PLAY_CLICK": "done",
        "STEP_CLICK": "done"
      }
    }
  ],
  "events": [
    "APPLY_CLICK",
    "RANDOMIZE_CLICK",
    "RESET_CLICK",
    "REPRESENTATION_CHANGE",
    "SPEED_CHANGE",
    "PLAY_CLICK",
    "PAUSE_CLICK",
    "STEP_CLICK",
    "PRACTICE_TOGGLE_ON",
    "PRACTICE_TOGGLE_OFF",
    "DECIDE_SWAP_CLICK",
    "DECIDE_KEEP_CLICK",
    "KEY_SPACE",
    "KEY_RIGHT",
    "KEY_S",
    "KEY_N",
    "AUTO_TICK",
    "DECISION_REQUIRED",
    "RULE_SWAP",
    "RULE_NO_SWAP",
    "ANIMATION_DONE",
    "PASS_BOUNDARY_REACHED",
    "PASS_HAS_SWAPS",
    "PASS_NO_SWAPS",
    "EARLY_EXIT_TRIGGERED",
    "SORT_COMPLETE",
    "RESIZE"
  ],
  "notes": "Operational overview: ready initializes the list, UI, and narration. From ready, users can Step (highlight a pair), Play (auto-run), toggle practice mode, change representation (bars/linked), or adjust speed. playing starts an interval timer (autoTimer) and on each AUTO_TICK performs one stepComparison. In practice mode, AUTO_TICK will highlight a pair and raise DECISION_REQUIRED, holding further ticks until a decision (Swap/No Swap) is made; pause clears the timer. comparing highlights the current adjacent pair and renders the view. If practice mode and manual step (or auto in practice), DECISION_REQUIRED transitions to awaiting_decision where Swap/No Swap inputs (buttons or keys S/N) are accepted with immediate feedback. Otherwise, the rule is evaluated: RULE_SWAP goes to swapping (perform swap, set swappedInPass = true, narrate; FLIP animation runs), RULE_NO_SWAP goes to no_swap (narrate; render). After animations complete (conceptual ANIMATION_DONE), control returns to playing if auto-run is active; in manual mode, control effectively returns to ready awaiting the next Step (this branching is implicitly handled by autoTimer presence, not explicitly modeled; mapping uses ANIMATION_DONE -> playing). pass_check is raised when a step occurs at or beyond unsortedEnd. If the pass had any swaps (PASS_HAS_SWAPS), initialize_next_pass increments pass, decrements unsortedEnd, resets i and swappedInPass, narrates, and returns to comparing on next Step or AUTO_TICK. If no swaps (PASS_NO_SWAPS) and early exit is enabled, EARLY_EXIT_TRIGGERED transitions to done; if early exit is disabled, the pass still advances (pass_started), and once unsortedEnd < 0, SORT_COMPLETE transitions to done. done narrates completion, clears any timers, and waits for Reset/Randomize/Apply to reinitialize. Representation changes and resize events re-render the current view but do not alter algorithmic state (mapped as self-transitions). Speed changes update speedLabel and, if playing, restart the timer. Keyboard shortcuts mirror button events: Space toggles Play/Pause; Right Arrow performs Step; S and N trigger Swap/No Swap decisions when in awaiting_decision. The FLIP animation is asynchronous; the FSM's ANIMATION_DONE event is conceptual to indicate when the animation finishes and control returns to the appropriate mode."
}
  </script>
</body>
</html>