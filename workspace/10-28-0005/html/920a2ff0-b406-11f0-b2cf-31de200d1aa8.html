<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Visual Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --text: #e5e7eb;        /* gray-200 */
      --muted: #9ca3af;       /* gray-400 */
      --accent: #22c55e;      /* green-500 */
      --accent-2: #06b6d4;    /* cyan-500 */
      --warn: #f59e0b;        /* amber-500 */
      --danger: #ef4444;      /* red-500 */
      --border: #374151;      /* gray-700 */
      --gap: 16px;            /* min spacing between interactive elements */
      --safe: 24px;           /* safe-area margin */
      --bar-gap: 12px;
      --bar-min-width: 28px;
      --bar-max-width: 64px;
      --vis-height: 280px;
      --transition: 320ms cubic-bezier(.2,.7,.2,1);
    }

    @media (prefers-reduced-motion: reduce) {
      :root {
        --transition: 0ms linear;
      }
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.5;
    }

    .safe {
      padding: var(--safe);
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-height: 100vh;
    }

    header h1 {
      margin: 0 0 8px 0;
      font-size: clamp(20px, 2.5vw, 28px);
      letter-spacing: 0.2px;
    }

    .objective {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    .vis-wrap {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Visualization container with absolute bars */
    .vis {
      position: relative;
      height: var(--vis-height);
      background: #0b1220;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 40px; /* will be updated responsively */
      height: 40px;
      background: #334155;  /* slate-700 */
      border-radius: 8px 8px 0 0;
      border: 1px solid #475569; /* slate-600 */
      transition: left var(--transition), height var(--transition), background var(--transition), transform var(--transition), border-color var(--transition);
    }

    .bar .label {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--muted);
      font-size: 12px;
      user-select: none;
      pointer-events: none;
    }

    .bar.comparing {
      background: #3b82f6; /* blue-500 */
      border-color: #60a5fa;
    }

    .bar.swapping {
      background: var(--danger);
      border-color: #fca5a5;
    }

    .bar.fixed {
      background: var(--accent);
      border-color: #86efac;
    }

    .vis-guides {
      position: absolute;
      right: 8px;
      bottom: 8px;
      color: var(--muted);
      font-size: 12px;
      background: rgba(255,255,255,0.04);
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }

    .controls .group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }

    button, input, label, select {
      font: inherit;
    }

    button {
      background: #1f2937; /* gray-800 */
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 14px;
      cursor: pointer;
    }

    button:hover {
      background: #243042;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .primary {
      background: #0ea5e9; /* sky-500 */
      border-color: #0284c7;
      color: #0b1322;
      font-weight: 600;
    }

    .primary:hover {
      background: #38bdf8;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #1f2937;
      cursor: pointer;
      user-select: none;
    }

    .toggle input {
      transform: translateY(1px);
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 260px;
      max-width: 560px;
      flex: 1;
    }

    .field input[type="text"] {
      background: #0b1322;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
    }

    .speed {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .speed input[type="range"] {
      width: 200px;
    }

    .status {
      display: grid;
      grid-template-columns: repeat(3, minmax(120px, 1fr));
      gap: var(--gap);
      margin-top: 8px;
    }

    .status .card {
      background: #0b1220;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
    }

    .status .label {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 4px;
    }

    .status .value {
      font-weight: 600;
      font-size: 16px;
    }

    details.module-notes {
      background: #0b1220;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
    }

    details.module-notes summary {
      cursor: pointer;
      font-weight: 600;
    }

    .notes-list {
      margin: 8px 0 0 0;
      padding-left: 18px;
      color: var(--muted);
    }

    /* focus visibility */
    :focus-visible {
      outline: 3px solid #38bdf8;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div class="safe" role="main">
    <header>
      <h1>Bubble Sort Visual Lab</h1>
      <p class="objective">Explore how adjacent comparisons and swaps bubble the largest element to the end on each pass.</p>
    </header>

    <!-- Visualization Panel -->
    <section class="panel vis-wrap" aria-label="Bubble sort interactive visualization">
      <div id="vis" class="vis" role="img" aria-label="Bar chart representing array values">
        <div class="vis-guides" aria-hidden="true">
          Comparing: blue · Swapping: red · Sorted: green
        </div>
      </div>

      <!-- Controls -->
      <div class="controls" aria-label="Controls">
        <div class="group" aria-label="Playback controls">
          <button id="playPauseBtn" class="primary" aria-label="Play or pause">Play</button>
          <button id="stepBtn" aria-label="Step one comparison">Step</button>
          <button id="resetBtn" aria-label="Reset to start state">Reset</button>
          <button id="shuffleBtn" aria-label="Shuffle array">Shuffle</button>
        </div>

        <div class="group speed" aria-label="Speed and options">
          <label for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="0" max="100" value="55" aria-valuemin="0" aria-valuemax="100" aria-valuenow="55" />
          <span id="speedVal" class="hint">1.0x</span>

          <label class="toggle" aria-label="Toggle early-exit optimization">
            <input id="optToggle" type="checkbox" checked />
            Early exit (stop when no swaps)
          </label>

          <label class="toggle" aria-label="Toggle reduced motion">
            <input id="motionToggle" type="checkbox" />
            Reduce motion
          </label>
        </div>

        <div class="field" aria-label="Custom array input">
          <label for="arrayInput">Custom array (comma-separated integers)</label>
          <input id="arrayInput" type="text" placeholder="e.g., 7, 3, 11, 2, 9" />
          <div class="hint">Press Enter to apply. Between 3 and 14 numbers recommended.</div>
        </div>
      </div>

      <!-- Status -->
      <div class="status" aria-live="polite">
        <div class="card">
          <div class="label">Pass (i)</div>
          <div id="passVal" class="value">0</div>
        </div>
        <div class="card">
          <div class="label">Inner index (j)</div>
          <div id="jVal" class="value">0</div>
        </div>
        <div class="card">
          <div class="label">Comparisons / Swaps</div>
          <div id="csVal" class="value">0 / 0</div>
        </div>
      </div>
    </section>

    <!-- Module Notes: includes required sections -->
    <details class="module-notes">
      <summary>Module Notes: Concept, Objectives, Interaction, Layout</summary>
      <ul class="notes-list">
        <li><strong>Concept Title</strong>: Bubble Sort — adjacent comparisons and swaps that bubble the largest value to the end each pass.</li>
        <li><strong>Learning Objective</strong>: Observe how pairwise comparisons drive swaps, see the “bubble” effect per pass, and understand early-exit optimization when no swaps occur.</li>
        <li><strong>Interaction Design</strong>: Shuffle or enter an array; Step through comparisons; Play/Pause with speed control; Toggle early-exit; bars highlight when compared and animate when swapped; sorted boundary turns green.</li>
        <li><strong>Layout Description</strong>: Safe area padding 24 px; clear central visualization; controls below with 16 px spacing; live status; responsive sizing; keyboard and screen-reader friendly.</li>
      </ul>
    </details>

    <footer class="hint">
      Shortcuts: Space = Play/Pause · N = Step · R = Reset · H = Shuffle
    </footer>
  </div>

  <script>
    (function () {
      // State
      let arr = [];
      let bars = [];
      let playing = false;
      let i = 0;
      let j = 0;
      let comparisons = 0;
      let swaps = 0;
      let swappedInPass = false;
      let earlyExit = true;
      let reduceMotion = false;

      // Elements
      const vis = document.getElementById('vis');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const speedRange = document.getElementById('speedRange');
      const speedVal = document.getElementById('speedVal');
      const optToggle = document.getElementById('optToggle');
      const motionToggle = document.getElementById('motionToggle');
      const arrayInput = document.getElementById('arrayInput');

      const passVal = document.getElementById('passVal');
      const jVal = document.getElementById('jVal');
      const csVal = document.getElementById('csVal');

      // Animation control
      let baseDurationMs = 600; // default base swap animation duration
      let compareHoldMs = 360;  // time to keep comparison highlight
      let isAnimating = false;

      function lerp(min, max, t) {
        return min + (max - min) * t;
      }

      function updateSpeedFromRange() {
        const t = Number(speedRange.value) / 100;
        // Map slider to duration scaling: faster at high values
        const duration = lerp(900, 220, t);
        baseDurationMs = Math.max(60, duration);
        compareHoldMs = Math.max(40, Math.floor(baseDurationMs * 0.6));
        const speedFactor = Math.round((900 / baseDurationMs) * 10) / 10;
        speedVal.textContent = speedFactor.toFixed(1) + 'x';
      }

      function applyMotionPreference() {
        reduceMotion = motionToggle.checked || window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        document.documentElement.style.setProperty('--transition', reduceMotion ? '0ms linear' : '320ms cubic-bezier(.2,.7,.2,1)');
      }

      // Layout calculations
      function computeBarMetrics(count) {
        const pad = 12;
        const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-gap'), 10) || 12;
        const visWidth = vis.clientWidth - pad * 2;
        const minW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-min-width'), 10) || 28;
        const maxW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-max-width'), 10) || 64;
        const rawW = (visWidth - gap * (count - 1)) / count;
        const width = Math.max(minW, Math.min(maxW, Math.floor(rawW)));
        const lefts = [];
        let x = Math.floor((vis.clientWidth - ((width * count) + gap * (count - 1))) / 2);
        for (let k = 0; k < count; k++) {
          lefts.push(x);
          x += width + gap;
        }
        return { width, lefts };
      }

      function createBars() {
        vis.innerHTML = '<div class="vis-guides" aria-hidden="true">Comparing: blue · Swapping: red · Sorted: green</div>';
        bars = [];
        const { width, lefts } = computeBarMetrics(arr.length);
        const max = Math.max(...arr, 1);
        for (let idx = 0; idx < arr.length; idx++) {
          const val = arr[idx];
          const h = Math.max(24, Math.round((val / max) * (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vis-height'), 10) - 36)));
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.left = lefts[idx] + 'px';
          bar.style.width = width + 'px';
          bar.style.height = h + 'px';
          bar.setAttribute('role', 'img');
          bar.setAttribute('aria-label', `Value ${val} at position ${idx + 1}`);
          bar.dataset.index = String(idx);
          bar.dataset.value = String(val);
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = String(val);
          bar.appendChild(label);
          vis.appendChild(bar);
          bars.push(bar);
        }
        updateSortedBoundaryVisuals();
      }

      function updateBarsPositions() {
        const { width, lefts } = computeBarMetrics(arr.length);
        const max = Math.max(...arr, 1);
        for (let idx = 0; idx < arr.length; idx++) {
          const bar = bars[idx];
          const val = arr[idx];
          const h = Math.max(24, Math.round((val / max) * (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vis-height'), 10) - 36)));
          bar.style.width = width + 'px';
          bar.style.left = lefts[idx] + 'px';
          bar.style.height = h + 'px';
          bar.dataset.index = String(idx);
          bar.dataset.value = String(val);
          bar.setAttribute('aria-label', `Value ${val} at position ${idx + 1}`);
          bar.querySelector('.label').textContent = String(val);
        }
        updateSortedBoundaryVisuals();
      }

      function markComparing(jIdx, on) {
        clearHighlights();
        if (jIdx < 0 || jIdx + 1 >= bars.length) return;
        bars[jIdx].classList.toggle('comparing', on);
        bars[jIdx + 1].classList.toggle('comparing', on);
      }

      function clearHighlights() {
        bars.forEach(b => {
          b.classList.remove('comparing', 'swapping');
        });
      }

      function updateSortedBoundaryVisuals() {
        // Mark the last i elements as fixed (sorted boundary from the end)
        const boundary = arr.length - i;
        bars.forEach((b, idx) => {
          const fixed = idx >= boundary;
          b.classList.toggle('fixed', fixed);
        });
      }

      function setStatus() {
        passVal.textContent = String(i);
        jVal.textContent = String(j);
        csVal.textContent = `${comparisons} / ${swaps}`;
      }

      function finished() {
        return i >= arr.length - 1;
      }

      function resetState(keepArray = true) {
        playing = false;
        playPauseBtn.textContent = 'Play';
        i = 0;
        j = 0;
        comparisons = 0;
        swaps = 0;
        swappedInPass = false;
        if (!keepArray) {
          // Shuffle new array
          arr = genRandomArray();
        }
        createBars();
        setStatus();
      }

      function genRandomArray() {
        const len = Math.floor(lerp(7, 12, Math.random()));
        const a = [];
        for (let k = 0; k < len; k++) {
          a.push(Math.floor(lerp(5, 99, Math.random())));
        }
        return a;
      }

      // Parsing custom input
      function parseArrayInput(text) {
        const parts = text.split(/[,\s]+/).filter(Boolean);
        if (parts.length < 3 || parts.length > 14) return null;
        const nums = parts.map(p => Number(p));
        if (nums.some(n => !Number.isFinite(n))) return null;
        // Clamp values for sensible bar heights
        const clamped = nums.map(n => Math.max(1, Math.min(999, Math.round(n))));
        return clamped;
      }

      // Core bubble sort step: one comparison (+ possible swap)
      async function bubbleStep() {
        if (finished()) return false;

        const boundary = arr.length - i - 1;
        if (j > boundary - 1) {
          // end of pass
          if (!swappedInPass && earlyExit) {
            i = arr.length - 1; // mark finished
            updateSortedBoundaryVisuals();
            setStatus();
            return false;
          }
          i++;
          j = 0;
          swappedInPass = false;
          updateSortedBoundaryVisuals();
          setStatus();
          if (finished()) return false;
        }

        // Compare arr[j] and arr[j+1]
        markComparing(j, true);
        comparisons++;
        setStatus();

        await wait(compareHoldMs);

        const needSwap = arr[j] > arr[j + 1];
        if (needSwap) {
          await animateSwap(j, j + 1);
          swaps++;
          swappedInPass = true;
          setStatus();
        } else {
          clearHighlights();
        }

        j++;
        setStatus();

        return true;
      }

      function wait(ms) {
        return new Promise(res => setTimeout(res, reduceMotion ? 0 : ms));
      }

      function animateSwap(aIdx, bIdx) {
        return new Promise((resolve) => {
          if (isAnimating) return resolve(); // guard
          isAnimating = true;

          const barA = bars[aIdx];
          const barB = bars[bIdx];
          barA.classList.remove('comparing');
          barB.classList.remove('comparing');
          barA.classList.add('swapping');
          barB.classList.add('swapping');

          // Compute current positions
          const { left: leftA } = barA.getBoundingClientRect();
          const { left: leftB } = barB.getBoundingClientRect();
          const delta = leftB - leftA;

          // Animate by swapping their "left" styles
          const styleLeftA = parseFloat(barA.style.left || '0');
          const styleLeftB = parseFloat(barB.style.left || '0');

          barA.style.left = styleLeftB + 'px';
          barB.style.left = styleLeftA + 'px';

          const duration = reduceMotion ? 0 : baseDurationMs;
          const doneA = new Promise(r => {
            barA.addEventListener('transitionend', r, { once: true });
            if (duration === 0) setTimeout(r, 0);
          });
          const doneB = new Promise(r => {
            barB.addEventListener('transitionend', r, { once: true });
            if (duration === 0) setTimeout(r, 0);
          });

          Promise.all([doneA, doneB]).then(() => {
            // Update array order and bars array
            const tmp = arr[aIdx];
            arr[aIdx] = arr[bIdx];
            arr[bIdx] = tmp;

            const tmpBar = bars[aIdx];
            bars[aIdx] = bars[bIdx];
            bars[bIdx] = tmpBar;

            // Recompute positions to match new indices
            updateBarsPositions();
            clearHighlights();

            isAnimating = false;
            resolve();
          });
        });
      }

      async function playLoop() {
        if (playing) return;
        playing = true;
        playPauseBtn.textContent = 'Pause';
        while (playing) {
          const ok = await bubbleStep();
          if (!ok) {
            playing = false;
            playPauseBtn.textContent = 'Play';
            break;
          }
          // pacing between steps
          await wait(Math.max(80, Math.floor(baseDurationMs * 0.25)));
        }
      }

      // Event bindings
      playPauseBtn.addEventListener('click', () => {
        if (playing) {
          playing = false;
          playPauseBtn.textContent = 'Play';
        } else {
          playLoop();
        }
      });

      stepBtn.addEventListener('click', async () => {
        if (isAnimating) return;
        const ok = await bubbleStep();
        if (!ok) {
          playing = false;
          playPauseBtn.textContent = 'Play';
        }
      });

      resetBtn.addEventListener('click', () => {
        resetState(true);
      });

      shuffleBtn.addEventListener('click', () => {
        arr = genRandomArray();
        resetState(true);
      });

      speedRange.addEventListener('input', () => {
        updateSpeedFromRange();
      });

      optToggle.addEventListener('change', () => {
        earlyExit = optToggle.checked;
      });

      motionToggle.addEventListener('change', () => {
        applyMotionPreference();
      });

      arrayInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const parsed = parseArrayInput(arrayInput.value);
          if (parsed) {
            arr = parsed;
            resetState(true);
          } else {
            arrayInput.setAttribute('aria-invalid', 'true');
            arrayInput.style.borderColor = '#ef4444';
            setTimeout(() => {
              arrayInput.removeAttribute('aria-invalid');
              arrayInput.style.borderColor = '';
            }, 1200);
          }
        }
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.code === 'Space') {
          e.preventDefault();
          playPauseBtn.click();
        } else if (e.key.toLowerCase() === 'n') {
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'r') {
          resetBtn.click();
        } else if (e.key.toLowerCase() === 'h') {
          shuffleBtn.click();
        }
      });

      // Resize handling
      window.addEventListener('resize', () => {
        updateBarsPositions();
      });

      // Initialize
      function init() {
        arr = genRandomArray();
        updateSpeedFromRange();
        applyMotionPreference();
        resetState(true);
      }

      init();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for a Bubble Sort visualizer with play/pause, step, reset/shuffle, speed, motion and early-exit options. It models user-control states and visual/animation phases of each sort step (comparing, swapping) and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "setPlayingFalseUI",
      "on": {
        "CLICK_PLAY": "playing",
        "CLICK_STEP": "comparing",
        "CLICK_RESET": "idle",
        "CLICK_SHUFFLE": "idle",
        "ENTER_VALID_ARRAY": "idle",
        "ENTER_INVALID_ARRAY": "input_error_feedback"
      }
    },
    {
      "name": "playing",
      "onEnter": "setPlayingTrueUI",
      "onExit": "setPlayingFalseUI",
      "on": {
        "CLICK_PAUSE": "idle",
        "NEXT_STEP_TICK": "comparing",
        "PASS_COMPLETED_EARLY_EXIT": "done",
        "FINISHED_NATURAL": "done"
      }
    },
    {
      "name": "comparing",
      "onEnter": "markComparingAndHold",
      "on": {
        "COMPARE_HOLD_DONE_NEED_SWAP_AUTO": "swapping",
        "COMPARE_HOLD_DONE_NO_SWAP_AUTO": "playing",
        "COMPARE_HOLD_DONE_NEED_SWAP_STEP": "swapping",
        "COMPARE_HOLD_DONE_NO_SWAP_STEP": "idle"
      }
    },
    {
      "name": "swapping",
      "onEnter": "animateSwap",
      "on": {
        "SWAP_ANIM_END_AUTO": "playing",
        "SWAP_ANIM_END_STEP": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "markAllSortedAndPauseUI",
      "on": {
        "CLICK_RESET": "idle",
        "CLICK_SHUFFLE": "idle",
        "ENTER_VALID_ARRAY": "idle",
        "CLICK_PLAY": "done"
      }
    },
    {
      "name": "input_error_feedback",
      "onEnter": "flashInvalidInput",
      "on": {
        "ERROR_TIMEOUT": "idle"
      }
    }
  ],
  "events": [
    "CLICK_PLAY",
    "CLICK_PAUSE",
    "CLICK_STEP",
    "CLICK_RESET",
    "CLICK_SHUFFLE",
    "ENTER_VALID_ARRAY",
    "ENTER_INVALID_ARRAY",
    "ERROR_TIMEOUT",
    "NEXT_STEP_TICK",
    "COMPARE_HOLD_DONE_NEED_SWAP_AUTO",
    "COMPARE_HOLD_DONE_NO_SWAP_AUTO",
    "COMPARE_HOLD_DONE_NEED_SWAP_STEP",
    "COMPARE_HOLD_DONE_NO_SWAP_STEP",
    "SWAP_ANIM_END_AUTO",
    "SWAP_ANIM_END_STEP",
    "PASS_COMPLETED_EARLY_EXIT",
    "FINISHED_NATURAL"
  ],
  "notes": "State semantics and code mapping:\n- idle: Paused/not auto-playing. UI shows Play on the button. In code, this corresponds to playing=false and playPauseBtn.textContent='Play'. Reset/Shuffle/Custom array events transition here with side-effects described below.\n- playing: Auto loop driven by playLoop(). On entering, playing=true and Play/Pause button shows 'Pause'. While in this state, the loop schedules NEXT_STEP_TICK (immediately at start and after each pacing delay) which triggers comparing. Clicking Pause triggers CLICK_PAUSE -> idle. If bubbleStep detects completion (i >= arr.length-1) or early-exit (no swaps in pass and earlyExit enabled), emit FINISHED_NATURAL or PASS_COMPLETED_EARLY_EXIT -> done.\n- comparing: Visual highlight of bars j and j+1 (markComparing(j,true)), comparisons++ and a timed hold (compareHoldMs). After hold, the branch is decided by data: needSwap = arr[j] > arr[j+1]. For auto mode, use COMPARE_HOLD_DONE_NEED_SWAP_AUTO -> swapping; COMPARE_HOLD_DONE_NO_SWAP_AUTO -> playing (the loop will schedule the next NEXT_STEP_TICK after pacing). For a single-step (CLICK_STEP from idle), use COMPARE_HOLD_DONE_NEED_SWAP_STEP -> swapping; COMPARE_HOLD_DONE_NO_SWAP_STEP -> idle.\n- swapping: Animate the swap of bars j and j+1 (animateSwap) with transitionend sync; after animation, swaps++, swappedInPass=true and visuals are cleared. For auto mode, SWAP_ANIM_END_AUTO -> playing; for step mode, SWAP_ANIM_END_STEP -> idle.\n- done: All elements marked fixed/green (i set so boundary marks all bars; updateSortedBoundaryVisuals()). Ensure playing=false and Play button reads 'Play'. Reset-related events leave done -> idle.\n- input_error_feedback: Brief visual feedback for invalid custom array input (aria-invalid, red border) lasting ~1200ms. After ERROR_TIMEOUT, return to idle without changing algorithm state.\n\nEnd-of-pass and completion logic:\n- At the start of each bubbleStep (invoked by NEXT_STEP_TICK in playing, or by CLICK_STEP), a pass boundary check runs. If j > arr.length - i - 2, the pass ends: if earlyExit is enabled and no swap occurred during the pass (swappedInPass=false), i is set to arr.length-1, visuals updated and the step returns false -> PASS_COMPLETED_EARLY_EXIT -> done. Otherwise, i++ and j=0 (updateSortedBoundaryVisuals and setStatus), then proceed if not finished.\n- FINISHED_NATURAL occurs when i >= arr.length - 1 after increments.\n\nSide-effects attached to events (not explicit in onEnter due to schema constraints):\n- CLICK_RESET: calls resetState(true) (keep current array, reset indices/counters, rebuild bars, clear highlights, update status), target state: idle.\n- CLICK_SHUFFLE: sets arr = genRandomArray(), then resetState(true), target state: idle.\n- ENTER_VALID_ARRAY: when user presses Enter with valid parsed numbers, sets arr to parsed, then resetState(true), target state: idle.\n- ENTER_INVALID_ARRAY: triggers input_error_feedback (aria-invalid + red border), then ERROR_TIMEOUT -> idle.\n\nPacing and animation timing:\n- In playing, after each successful bubbleStep returns true, playLoop waits a pacing delay (~max(80ms, baseDurationMs*0.25)) and then emits NEXT_STEP_TICK.\n- compareHoldMs is derived from speed slider and reduced-motion preference and governs the stay in comparing.\n- animateSwap duration uses baseDurationMs (or 0 when reduce motion).\n\nControls that do not change FSM state:\n- SPEED_CHANGE (speedRange input) updates baseDurationMs/compareHoldMs and UI speedVal; remains in current state.\n- TOGGLE_EARLY_EXIT updates earlyExit flag; remains in current state.\n- TOGGLE_REDUCED_MOTION updates CSS --transition and reduceMotion; remains in current state.\n- RESIZE recomputes and applies bar layout (updateBarsPositions); remains in current state.\n\nKeyboard shortcuts:\n- Space -> CLICK_PLAY/CLICK_PAUSE; N -> CLICK_STEP; R -> CLICK_RESET; H -> CLICK_SHUFFLE. These are equivalent to their respective button click events.\n\nAction name mapping to code:\n- setPlayingTrueUI: playing=true; playPauseBtn.textContent='Pause'.\n- setPlayingFalseUI: playing=false; playPauseBtn.textContent='Play'.\n- markComparingAndHold: markComparing(j,true); comparisons++; setStatus(); await wait(compareHoldMs).\n- animateSwap: perform swap animation of bars j and j+1; upon transitionend, update arr and bars order, swaps++, clear highlights, update positions/status.\n- markAllSortedAndPauseUI: ensure all bars marked .fixed via updateSortedBoundaryVisuals (i == arr.length-1), setStatus(), setPlayingFalseUI.\n- flashInvalidInput: set aria-invalid and red border on arrayInput for ~1200ms, then clear."
}
  </script>
</body>
</html>