<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Explorer — An Interactive, Single-Concept Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bar-color: #4f7cff;
      --bar-compare: #f6c453;
      --bar-sorted: #2bb673;
      --bar-idle: #9aa5b1;
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #22d3ee;
      --danger: #ef4444;
      --ok: #22c55e;
      --focus: #22d3ee;
      --border: #1f2937;
      --code-bg: #0b1220;
      --easing: cubic-bezier(.2,.8,.2,1);
      --swap-duration: 500ms;     /* adjusted by JS */
      --compare-duration: 300ms;  /* adjusted by JS */
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg: #f8fafc;
        --panel: #ffffff;
        --text: #0f172a;
        --muted: #475569;
        --border: #e2e8f0;
        --code-bg: #f1f5f9;
      }
    }
    @media (prefers-reduced-motion: reduce){
      :root{
        --swap-duration: 1ms;
        --compare-duration: 1ms;
      }
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.45;
    }
    a { color: var(--accent); }
    .container{
      padding: var(--safe-pad);
      max-width: 1200px;
      margin: 0 auto;
    }
    h1, h2, h3 { margin: 0 0 12px; line-height: 1.2; }
    p { margin: 0 0 12px; color: var(--muted); }
    ul { margin: 8px 0 16px 20px; color: var(--muted); }
    .module{
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 24px;
    }
    @media (max-width: 960px){
      .module{ grid-template-columns: 1fr; }
    }
    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }
    .panel + .panel{ margin-top: 16px; }
    .section{
      margin-bottom: 16px;
    }
    .controls{
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }
    .control-row{
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }
    .control-row > * { min-height: 40px; }
    fieldset{
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      min-width: 0;
    }
    legend{
      padding: 0 8px;
      color: var(--muted);
      font-size: 14px;
    }
    label{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--text);
    }
    input[type="text"]{
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 10px 12px;
      min-width: 240px;
    }
    input[type="range"]{
      width: 220px;
      accent-color: var(--accent);
    }
    .btn{
      background: #1f2937;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform .05s ease, background-color .2s var(--easing), border-color .2s var(--easing);
      user-select: none;
    }
    .btn:hover{ background: #222b3a; }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: var(--bar-color);
      border-color: transparent;
      color: white;
    }
    .btn.warning{
      background: #3a1f21;
      border-color: #512224;
      color: #ffd7d9;
    }
    .btn:focus-visible{
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }
    .viz{
      position: relative;
      height: 320px;
      display: flex;
      align-items: flex-end;
      gap: 8px;
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed var(--border);
      overflow: hidden;
    }
    @media (max-width: 480px){
      .viz{ height: 240px; }
    }
    .bar{
      flex: 1 1 0;
      background: linear-gradient(180deg, #6fa0ff, #4f7cff);
      border-radius: 6px 6px 0 0;
      position: relative;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      height: 20px;
      transition: transform var(--swap-duration) var(--easing), background-color var(--compare-duration) var(--easing), opacity .2s var(--easing);
      will-change: transform;
    }
    .bar .value{
      position: absolute;
      bottom: -24px;
      font-size: 12px;
      color: var(--text);
      background: transparent;
      padding: 2px 4px;
      border-radius: 4px;
      opacity: 0.9;
      user-select: none;
    }
    .bar.compare{
      background: linear-gradient(180deg, #ffd67e, #f6c453);
      outline: 2px solid #fcd34d;
      outline-offset: 0;
    }
    .bar.sorted{
      background: linear-gradient(180deg, #55d69d, #2bb673);
    }
    .index-row{
      display: flex;
      justify-content: space-between;
      gap: 8px;
      padding: 0 12px;
      margin-top: 12px;
      min-height: 22px;
    }
    .idx{
      flex: 1 1 0;
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      position: relative;
      user-select: none;
    }
    .idx.active{
      color: #fcd34d;
      font-weight: 600;
    }
    .idx.active::after{
      content: "↑";
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      color: #fcd34d;
      font-size: 12px;
    }
    .pseudocode{
      background: var(--code-bg);
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      overflow: auto;
      border: 1px solid var(--border);
    }
    .pseudocode ol{
      margin: 0;
      padding-left: 24px;
    }
    .pseudocode li{
      padding: 4px 6px;
      border-radius: 6px;
      color: var(--muted);
      white-space: pre;
    }
    .pseudocode li.active{
      background: rgba(34, 211, 238, 0.12);
      color: var(--text);
      outline: 1px dashed rgba(34,211,238,0.4);
    }
    .stats{
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }
    @media (max-width: 520px){
      .stats{ grid-template-columns: repeat(2, 1fr); }
    }
    .stat{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      text-align: center;
    }
    .stat .k{ font-size: 12px; color: var(--muted); }
    .stat .v{ font-size: 18px; font-weight: 700; }
    .narration{
      min-height: 24px;
      color: var(--muted);
    }
    .note{
      font-size: 13px;
      color: var(--muted);
    }
    .error{
      color: #fecaca;
    }
    .success{
      color: var(--ok);
    }
    .footer{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <main class="container">
    <header class="section">
      <h1>Bubble Sort Explorer</h1>
      <p>An interactive, single-concept module to learn how Bubble Sort works through step-by-step comparisons, swaps, and visual feedback.</p>
    </header>

    <section class="panel section" aria-labelledby="concept-title">
      <h2 id="concept-title">Concept Title</h2>
      <p>Bubble Sort: Adjacent comparisons and swaps that repeatedly move larger elements toward the end (like bubbles rising).</p>

      <h3>Learning Objective</h3>
      <ul>
        <li>Track how Bubble Sort compares adjacent pairs and swaps them when out of order.</li>
        <li>Understand the notion of passes, early-exit optimization, and the stability of the algorithm.</li>
        <li>Connect algorithm steps with visual states: compare, swap, end of pass, and completion.</li>
      </ul>

      <h3>Interaction Design</h3>
      <ul>
        <li>Type a list of numbers (comma-separated) or generate random data; press Apply or Randomize.</li>
        <li>Use Play/Pause to run automatically or Next Step to advance comparison by comparison.</li>
        <li>Toggle Early Exit to see how the algorithm can finish earlier when no swaps occur in a pass.</li>
        <li>Adjust Speed to control animation pace; observe colored highlights: yellow for comparison, green for sorted tail.</li>
        <li>Keyboard: Space = Play/Pause, → = Next Step, R = Reset. Narration announces each action for screen readers.</li>
      </ul>

      <h3>Layout Description</h3>
      <ul>
        <li>Safe area: 24 px margin padding around the entire module to avoid edge crowding.</li>
        <li>Left: Controls and visualization stacked in panels; Right: Pseudocode with live line highlighting and a stats panel.</li>
        <li>Controls use grouped fieldsets with at least 16 px gaps between interactive elements for comfortable targeting.</li>
        <li>Responsive: On narrow screens, the right column stacks below the visualization. Focus styles and aria-live narration support accessibility.</li>
      </ul>
    </section>

    <section class="module" aria-label="Bubble Sort Interactive Module">
      <div>
        <section class="panel">
          <div class="controls" aria-label="Input and Controls">
            <fieldset>
              <legend>Data</legend>
              <div class="control-row">
                <label for="arrayInput">Numbers (CSV)</label>
                <input id="arrayInput" type="text" placeholder="e.g., 8, 3, 5, 1, 9, 2" aria-describedby="arrayHelp" />
                <button class="btn" id="applyBtn" aria-label="Apply custom numbers">Apply</button>
              </div>
              <div id="arrayHelp" class="note">Enter 2–24 integers. Non-integers will be rounded. Extra spaces are okay.</div>
              <div class="control-row">
                <label for="sizeRange">Size <output id="sizeOut">8</output></label>
                <input id="sizeRange" type="range" min="2" max="24" value="8" />
                <button class="btn" id="randomBtn">Randomize</button>
                <button class="btn" id="nearlyBtn">Nearly Sorted</button>
                <button class="btn warning" id="resetBtn" title="Reset to starting order (unsorted)">Reset</button>
              </div>
              <div id="msg" class="note" role="status" aria-live="polite"></div>
            </fieldset>

            <fieldset>
              <legend>Algorithm</legend>
              <div class="control-row">
                <label><input type="checkbox" id="earlyExit" checked /> Early exit when no swaps in a pass</label>
                <label for="speedRange">Speed <output id="speedOut">1.0x</output></label>
                <input id="speedRange" type="range" min="25" max="200" value="100" />
              </div>
              <div class="control-row">
                <button class="btn primary" id="playBtn" aria-pressed="false">▶ Play</button>
                <button class="btn" id="stepBtn">Next Step</button>
              </div>
              <div class="narration" aria-live="polite" id="narration">Ready.</div>
            </fieldset>
          </div>
        </section>

        <section class="panel" aria-label="Visualization">
          <div class="viz" id="viz" role="img" aria-label="Array bars visualization"></div>
          <div class="index-row" id="indexRow" aria-hidden="true"></div>
          <div class="footer note">
            Colors: Yellow = comparing, Green = settled (sorted tail). Bars show values; pointers mark compared indices.
          </div>
        </section>
      </div>

      <div>
        <section class="panel" aria-label="Pseudocode">
          <h3>Pseudocode</h3>
          <div class="pseudocode">
            <ol id="code">
              <li data-line="1">for i from 0 to n-1:</li>
              <li data-line="2">  swapped ← false</li>
              <li data-line="3">  for j from 0 to n-2-i:</li>
              <li data-line="4">    if a[j] > a[j+1]:</li>
              <li data-line="5">      swap(a[j], a[j+1]); swapped ← true</li>
              <li data-line="6">  if earlyExit and swapped is false: break</li>
            </ol>
          </div>
        </section>

        <section class="panel" aria-label="Statistics">
          <h3>Stats</h3>
          <div class="stats">
            <div class="stat"><div class="k">Pass</div><div class="v" id="passStat">0</div></div>
            <div class="stat"><div class="k">Comparisons</div><div class="v" id="compStat">0</div></div>
            <div class="stat"><div class="k">Swaps</div><div class="v" id="swapStat">0</div></div>
            <div class="stat"><div class="k">Length</div><div class="v" id="lenStat">0</div></div>
          </div>
          <div class="footer">
            Bubble Sort is stable (equal items keep order) and has O(n²) worst-case time. Early exit makes best case O(n).
          </div>
        </section>
      </div>
    </section>
  </main>

  <script>
    (function(){
      'use strict';

      // DOM
      const viz = document.getElementById('viz');
      const indexRow = document.getElementById('indexRow');
      const code = document.getElementById('code');
      const passStat = document.getElementById('passStat');
      const compStat = document.getElementById('compStat');
      const swapStat = document.getElementById('swapStat');
      const lenStat  = document.getElementById('lenStat');
      const arrayInput = document.getElementById('arrayInput');
      const sizeRange = document.getElementById('sizeRange');
      const sizeOut = document.getElementById('sizeOut');
      const speedRange = document.getElementById('speedRange');
      const speedOut = document.getElementById('speedOut');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const applyBtn = document.getElementById('applyBtn');
      const randomBtn = document.getElementById('randomBtn');
      const nearlyBtn = document.getElementById('nearlyBtn');
      const earlyExitCheckbox = document.getElementById('earlyExit');
      const msg = document.getElementById('msg');
      const narration = document.getElementById('narration');

      // State
      let initialArray = [];
      let data = [];
      let i = 0;       // current pass index
      let j = 0;       // current inner index
      let swapped = false;
      let comparisons = 0;
      let swaps = 0;
      let running = false;
      let done = false;
      let n = 0;

      // Timing
      const baseSwap = 500;     // ms
      const baseCompare = 300;  // ms

      function speedFactor(){
        // Map 25..200 -> 0.25..2
        const v = Number(speedRange.value);
        return (v / 100);
      }
      function updateDurations(){
        const f = speedFactor();
        const swapMs = Math.max(50, baseSwap / f);
        const compareMs = Math.max(30, baseCompare / f);
        document.documentElement.style.setProperty('--swap-duration', `${swapMs}ms`);
        document.documentElement.style.setProperty('--compare-duration', `${compareMs}ms`);
        speedOut.textContent = `${f.toFixed(2)}x`;
      }

      // Utilities
      function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
      function clone(arr){ return arr.slice(); }

      function setMessage(text, type=''){
        msg.textContent = text;
        msg.className = 'note ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : '');
      }

      function announce(text){
        narration.textContent = text;
      }

      function resetState(toInitial = true){
        running = false;
        playBtn.textContent = '▶ Play';
        playBtn.setAttribute('aria-pressed', 'false');
        done = false;
        i = 0; j = 0; swapped = false;
        comparisons = 0; swaps = 0;
        if (toInitial) data = clone(initialArray);
        n = data.length;
        updateStats();
        renderBars();
        highlightSortedTail();
        clearCodeHighlight();
        announce('Ready.');
      }

      function updateStats(){
        passStat.textContent = i.toString();
        compStat.textContent = comparisons.toString();
        swapStat.textContent = swaps.toString();
        lenStat.textContent  = n.toString();
      }

      function parseArrayFromInput(text){
        const parts = text.split(',').map(s => s.trim()).filter(s => s.length > 0);
        const values = parts.map(v => {
          let num = Number(v);
          if (!Number.isFinite(num)) num = 0;
          return Math.round(num);
        });
        return values;
      }

      function randomArray(size){
        const arr = Array.from({length: size}, () => randInt(1, 99));
        return arr;
      }

      function nearlySortedArray(size){
        const arr = Array.from({length: size}, (_, k) => k+1);
        // swap two adjacent positions somewhere in the middle
        if (size >= 4){
          const pos = randInt(1, size - 2);
          [arr[pos], arr[pos+1]] = [arr[pos+1], arr[pos]];
        }
        // scale roughly to 1..99
        const scale = Math.max(1, Math.floor(99 / size));
        return arr.map(v => v * scale);
      }

      function renderBars(){
        viz.innerHTML = '';
        indexRow.innerHTML = '';
        if (data.length === 0) return;

        const maxVal = Math.max(...data);
        const minBarHeight = 12; // px
        const scale = v => (Math.max(0, v) / Math.max(1, maxVal)) * (viz.clientHeight - 40) + minBarHeight;

        data.forEach((v, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = `${scale(v)}px`;
          bar.setAttribute('aria-label', `Value ${v} at index ${idx}`);
          const val = document.createElement('span');
          val.className = 'value';
          val.textContent = String(v);
          bar.appendChild(val);
          viz.appendChild(bar);

          const idxLabel = document.createElement('div');
          idxLabel.className = 'idx';
          idxLabel.textContent = String(idx);
          indexRow.appendChild(idxLabel);
        });
      }

      function getBars(){ return Array.from(viz.children); }
      function getIndexLabels(){ return Array.from(indexRow.children); }

      function clearCompareHighlight(){
        getBars().forEach(b => b.classList.remove('compare'));
        getIndexLabels().forEach(l => l.classList.remove('active'));
      }

      function highlightCompare(a, b){
        const bars = getBars();
        const labels = getIndexLabels();
        bars[a]?.classList.add('compare');
        bars[b]?.classList.add('compare');
        labels[a]?.classList.add('active');
        labels[b]?.classList.add('active');
      }

      function highlightSortedTail(){
        // Mark last i elements as sorted (tail)
        const bars = getBars();
        bars.forEach(b => b.classList.remove('sorted'));
        for (let t = n - 1; t >= n - i; t--){
          if (t >= 0) bars[t]?.classList.add('sorted');
        }
      }

      function clearCodeHighlight(){
        code.querySelectorAll('li').forEach(li => li.classList.remove('active'));
      }
      function highlightLine(line){
        clearCodeHighlight();
        const li = code.querySelector(`li[data-line="${line}"]`);
        if (li) li.classList.add('active');
      }

      function swapInDOM(a, b){
        // FLIP animation for swapping two adjacent bars (a and b are indices, expected b=a+1)
        const barsBefore = getBars();
        const A = barsBefore[a];
        const B = barsBefore[b];
        if (!A || !B) return;

        const rectA = A.getBoundingClientRect();
        const rectB = B.getBoundingClientRect();
        // Swap nodes (place B before A)
        if (B.nextSibling === A){
          viz.insertBefore(A, B);
        } else {
          viz.insertBefore(B, A);
        }
        // After swap, measure new positions
        const barsAfter = getBars();
        const A2 = barsAfter[b]; // A moved to b
        const B2 = barsAfter[a]; // B moved to a
        const rectA2 = A2.getBoundingClientRect();
        const rectB2 = B2.getBoundingClientRect();

        const dxA = rectA.left - rectA2.left;
        const dxB = rectB.left - rectB2.left;

        // Apply inverse transform to start at old position
        A2.style.transform = `translateX(${dxA}px)`;
        B2.style.transform = `translateX(${dxB}px)`;

        // Force reflow
        A2.getBoundingClientRect();

        // Animate to new position
        A2.style.transform = '';
        B2.style.transform = '';
      }

      function sleep(ms){
        return new Promise(res => setTimeout(res, ms));
      }

      function isSorted(arr){
        for (let k=0;k<arr.length-1;k++){
          if (arr[k] > arr[k+1]) return false;
        }
        return true;
      }

      async function step(){
        if (done) return;
        updateStats();

        // End of pass?
        if (j >= n - 1 - i){
          highlightLine(6);
          if (earlyExitCheckbox.checked && swapped === false){
            // All sorted
            i = n - 1; // mark tail as sorted
            highlightSortedTail();
            done = true;
            announce('No swaps in pass. Early exit — array is sorted.');
            updateStats();
            stopRunningUI();
            return;
          }
          // Next pass
          i++;
          j = 0;
          swapped = false;
          highlightSortedTail();
          updateStats();
          if (i >= n - 1){
            // Done
            done = true;
            highlightSortedTail();
            announce('Completed all passes — array is sorted.');
            stopRunningUI();
            return;
          }
          highlightLine(2);
          await sleep(Math.max(40, baseCompare / speedFactor()));
          return;
        }

        // Compare a[j] and a[j+1]
        highlightLine(4);
        highlightCompare(j, j+1);
        comparisons++;
        updateStats();
        announce(`Comparing index ${j} (${data[j]}) and ${j+1} (${data[j+1]}).`);
        await sleep(Math.max(30, baseCompare / speedFactor()));

        if (data[j] > data[j+1]){
          // Swap with animation
          highlightLine(5);
          swaps++;
          swapped = true;
          // Update data first
          [data[j], data[j+1]] = [data[j+1], data[j]];

          // Swap DOM bars and also swap index labels to keep arrows aligned visually
          swapInDOM(j, j+1);
          // Swap index label placeholders for consistent width spacing (visual labels represent positions, not values)
          // We don't swap labels' text; indices remain 0..n-1 positions.

          await sleep(Math.max(50, baseSwap / speedFactor()));
          announce(`Swapped ${data[j]} and ${data[j+1]} (now at indices ${j} and ${j+1}).`);
        } else {
          announce(`No swap needed: ${data[j]} ≤ ${data[j+1]}.`);
        }

        // Clear compare state and advance
        clearCompareHighlight();
        j++;
      }

      async function playLoop(){
        if (done) return;
        running = true;
        playBtn.textContent = '⏸ Pause';
        playBtn.setAttribute('aria-pressed', 'true');
        stepBtn.disabled = true; // prevent double stepping during play
        while (running && !done){
          await step();
          // small pacing delay to avoid too-fast bursts at high speed
          await sleep(10);
        }
        stepBtn.disabled = false;
      }

      function stopRunningUI(){
        running = false;
        playBtn.textContent = '▶ Play';
        playBtn.setAttribute('aria-pressed', 'false');
        stepBtn.disabled = false;
      }

      // Event bindings
      playBtn.addEventListener('click', async () => {
        if (done){
          announce('Already sorted. Reset or change the array to run again.');
          return;
        }
        if (!running){
          playLoop();
        } else {
          running = false;
          stopRunningUI();
          announce('Paused.');
        }
      });

      stepBtn.addEventListener('click', async () => {
        if (done){
          announce('Already sorted. Reset or change the array to step again.');
          return;
        }
        if (running) return;
        await step();
      });

      resetBtn.addEventListener('click', () => {
        resetState(true);
        setMessage('Reset to starting order.', 'success');
      });

      randomBtn.addEventListener('click', () => {
        const size = Number(sizeRange.value);
        initialArray = randomArray(size);
        arrayInput.value = initialArray.join(', ');
        setMessage(`Randomized ${size} values.`, 'success');
        resetState(true);
      });

      nearlyBtn.addEventListener('click', () => {
        const size = Number(sizeRange.value);
        initialArray = nearlySortedArray(size);
        arrayInput.value = initialArray.join(', ');
        setMessage(`Generated a nearly sorted array of ${size}.`, 'success');
        resetState(true);
      });

      applyBtn.addEventListener('click', () => {
        const values = parseArrayFromInput(arrayInput.value);
        if (values.length < 2 || values.length > 24){
          setMessage('Please enter 2–24 numbers.', 'error');
          return;
        }
        initialArray = values;
        sizeRange.value = String(values.length);
        sizeOut.textContent = String(values.length);
        setMessage(`Applied ${values.length} values.`, 'success');
        resetState(true);
      });

      sizeRange.addEventListener('input', () => {
        sizeOut.textContent = sizeRange.value;
      });

      sizeRange.addEventListener('change', () => {
        // Regenerate random with new size but keep current input intact unless user clicks Randomize
        setMessage(`Size set to ${sizeRange.value}. Click Randomize or Nearly Sorted, or edit the list and Apply.`);
      });

      speedRange.addEventListener('input', updateDurations);

      // Keyboard shortcuts
      document.addEventListener('keydown', async (e) => {
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if (e.code === 'Space'){
          e.preventDefault();
          playBtn.click();
        } else if (e.key === 'ArrowRight'){
          e.preventDefault();
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'r'){
          e.preventDefault();
          resetBtn.click();
        }
      });

      // Initialize
      function init(){
        // Default values
        const defaultSize = Number(sizeRange.value);
        initialArray = randomArray(defaultSize);
        arrayInput.value = initialArray.join(', ');
        data = clone(initialArray);
        n = data.length;
        updateDurations();
        renderBars();
        highlightSortedTail();
        resetState(false);
        setMessage('Enter numbers and click Apply, or use Randomize/Nearly Sorted.', '');
      }

      init();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a Bubble Sort explorer that models user control modes (play/pause/step/reset/input), algorithm micro-states (compare, swap, pass transitions), visual feedback (highlights), and completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "init_module",
      "onExit": "none",
      "on": {
        "APP_LOADED": "ready"
      }
    },
    {
      "name": "ready",
      "onEnter": "reset_sort_state",
      "onExit": "none",
      "on": {
        "TOGGLE_PLAY": "playing",
        "NEXT_STEP": "check_pass_end",
        "APPLY_VALID": "ready",
        "APPLY_INVALID": "input_error",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "RESET": "ready",
        "SPEED_CHANGE": "ready",
        "SIZE_INPUT": "ready",
        "SIZE_CHANGE_NOTICE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_play_loop",
      "onExit": "stop_running_ui",
      "on": {
        "PAUSE": "paused",
        "AUTO_STEP": "check_pass_end",
        "DONE_REACHED": "done",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "paused",
      "onEnter": "announce_paused",
      "onExit": "none",
      "on": {
        "TOGGLE_PLAY": "playing",
        "NEXT_STEP": "check_pass_end",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "SPEED_CHANGE": "paused"
      }
    },
    {
      "name": "check_pass_end",
      "onEnter": "highlight_line_6_and_evaluate",
      "onExit": "none",
      "on": {
        "PASS_CONTINUES": "comparing",
        "PASS_ADVANCE": "pass_advance",
        "EARLY_EXIT_DONE": "done",
        "ALL_PASSES_COMPLETE": "done",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "PAUSE": "paused"
      }
    },
    {
      "name": "pass_advance",
      "onEnter": "advance_pass_and_highlight",
      "onExit": "none",
      "on": {
        "NEXT_COMPARISON": "comparing",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "PAUSE": "paused"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_compare_and_announce",
      "onExit": "clear_compare_highlight",
      "on": {
        "NEEDS_SWAP": "swapping",
        "NO_SWAP": "advancing_index",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "PAUSE": "paused"
      }
    },
    {
      "name": "swapping",
      "onEnter": "perform_swap_and_announce",
      "onExit": "none",
      "on": {
        "SWAP_DONE": "advancing_index",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "PAUSE": "paused"
      }
    },
    {
      "name": "advancing_index",
      "onEnter": "increment_inner_index",
      "onExit": "none",
      "on": {
        "AUTO_STEP": "check_pass_end",
        "NEXT_STEP": "check_pass_end",
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "PAUSE": "paused"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sorted_and_stop",
      "onExit": "none",
      "on": {
        "RESET": "ready",
        "APPLY_VALID": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready",
        "TOGGLE_PLAY": "done",
        "NEXT_STEP": "done"
      }
    },
    {
      "name": "input_error",
      "onEnter": "show_input_error",
      "onExit": "none",
      "on": {
        "FIX_INPUT": "ready",
        "APPLY_VALID": "ready",
        "RESET": "ready",
        "RANDOMIZE": "ready",
        "NEARLY_SORTED": "ready"
      }
    }
  ],
  "events": [
    "APP_LOADED",
    "TOGGLE_PLAY",
    "PAUSE",
    "NEXT_STEP",
    "AUTO_STEP",
    "RESET",
    "APPLY_VALID",
    "APPLY_INVALID",
    "RANDOMIZE",
    "NEARLY_SORTED",
    "SPEED_CHANGE",
    "SIZE_INPUT",
    "SIZE_CHANGE_NOTICE",
    "PASS_CONTINUES",
    "PASS_ADVANCE",
    "EARLY_EXIT_DONE",
    "ALL_PASSES_COMPLETE",
    "NEEDS_SWAP",
    "NO_SWAP",
    "SWAP_DONE",
    "DONE_REACHED",
    "FIX_INPUT"
  ],
  "notes": "Mapping to code: APP_LOADED occurs when init() runs on page load. 'ready' corresponds to resetState() with running=false, done=false, i=0, j=0; onEnter reset_sort_state should call updateStats(), renderBars(), highlightSortedTail(), clearCodeHighlight(), announce('Ready.'). TOGGLE_PLAY (button click or Space) calls playLoop(): 'playing' onEnter start_play_loop flips play button to Pause, sets running=true, disables stepBtn; 'AUTO_STEP' is the implicit loop tick that calls step(). PAUSE (click Play while running) stops the loop via stopRunningUI() and goes to 'paused' where narration announces 'Paused.'. NEXT_STEP (button or ArrowRight) invokes a single step from 'ready' or 'paused'. SPEED_CHANGE (speedRange input) invokes updateDurations() without changing the sorting state. SIZE_INPUT and SIZE_CHANGE_NOTICE occur on sizeRange input/change; they only update UI messages and outputs. APPLY_VALID, RANDOMIZE, NEARLY_SORTED all populate initialArray, update arrayInput, set a success message, and call resetState(true) -> 'ready'. APPLY_INVALID sets an error message without changing sort variables -> 'input_error'. Algorithm micro-states: 'check_pass_end' (step() pass-end block) highlights pseudocode line 6 and branches: EARLY_EXIT_DONE when earlyExitCheckbox.checked && swapped===false, which marks tail sorted, sets done=true, announces early exit, and calls stopRunningUI(); ALL_PASSES_COMPLETE when i>=n-1 after increment, marks sorted, announces completion, stops UI; PASS_ADVANCE when a new pass starts: i++ j=0 swapped=false, highlightSortedTail(), highlight pseudocode line 2, then NEXT_COMPARISON after a brief delay moves to 'comparing'. 'comparing' (line 4) highlights the compared bars/indices with yellow, increments comparisons, announces, waits compare duration, then either NEEDS_SWAP -> 'swapping' (line 5) where data and DOM are swapped via swapInDOM(), swaps++, swapped=true, waits swap duration, announces; or NO_SWAP -> 'advancing_index'. On exiting 'comparing' clearCompareHighlight() runs. 'advancing_index' clears compare state and j++ (modeled by increment_inner_index), then the next invocation (AUTO_STEP in play mode or NEXT_STEP in step mode) returns to 'check_pass_end'. 'done' sets done=true, highlights entire sorted tail, announces completion, and ensures UI is in Play state via stopRunningUI(); Play or Next while done leaves state unchanged but announces 'Already sorted...'. Keyboard shortcuts: Space -> TOGGLE_PLAY, ArrowRight -> NEXT_STEP, 'r' -> RESET. Visual states include sorted tail marking (highlightSortedTail) and code line highlighting (highlightLine). Animation timing is controlled via updateDurations() (speedRange) which sets CSS variables --swap-duration and --compare-duration."
}
  </script>
</body>
</html>