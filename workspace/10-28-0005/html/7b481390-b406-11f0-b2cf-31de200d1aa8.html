<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bubble Sort: Visual Passes and Swaps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f172a;          /* Slate-900 */
      --panel: #111827;       /* Gray-900 */
      --text: #e5e7eb;        /* Gray-200 */
      --muted: #cbd5e1;       /* Slate-300 */
      --accent: #38bdf8;      /* Sky-400 */
      --accent-2: #22c55e;    /* Green-500 */
      --compare: #f59e0b;     /* Amber-500 */
      --swap: #ef4444;        /* Red-500 */
      --suffix: rgba(34, 197, 94, 0.15);
      --focus: #fbbf24;       /* Amber-400 */
      --btn: #1f2937;         /* Gray-800 */
      --btn-hover: #374151;   /* Gray-700 */
      --border: #334155;      /* Slate-700 */
      --code-bg: #0b1220;
      --shadow: 0 8px 20px rgba(0,0,0,0.35);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.4;
    }

    .module {
      padding: var(--safe-padding);
      display: flex;
      flex-direction: column;
      gap: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    header h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    header p {
      margin: 8px 0 0 0;
      color: var(--muted);
      font-size: 14px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: var(--shadow);
    }

    .group-title {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 12px;
      letter-spacing: 0.2px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    input[type="number"],
    input[type="text"],
    select {
      background: #0c1324;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 120px;
      outline: none;
    }
    input[type="range"] {
      width: 180px;
    }

    button {
      background: var(--btn);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.05s ease;
    }
    button:hover { background: var(--btn-hover); }
    button:active { transform: scale(0.98); }
    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .primary {
      background: #0ea5e9;
      border-color: #0284c7;
    }
    .primary:hover {
      background: #38bdf8;
    }

    .main {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: var(--gap);
    }

    .viz-wrapper {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .viz-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: var(--gap);
    }
    .viz-header .legend {
      display: inline-flex;
      gap: 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .legend span {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }
    .legend b {
      width: 14px; height: 14px;
      border-radius: 3px;
      display: inline-block;
    }
    .legend .compare b { background: var(--compare); }
    .legend .swap b { background: var(--swap); }
    .legend .sorted b { background: var(--accent-2); opacity: 0.5; }

    .viz.panel {
      position: relative;
      height: 320px;
      overflow: hidden;
    }
    .bars {
      position: relative;
      height: 100%;
      width: 100%;
    }
    .suffix-mask {
      position: absolute;
      top: 0; right: 0; bottom: 0;
      width: 0;
      background: var(--suffix);
      transition: width 300ms ease;
      pointer-events: none;
    }

    .bar {
      position: absolute;
      bottom: 0;
      border-radius: 8px 8px 0 0;
      background: linear-gradient(180deg, #0ea5e9, #0369a1);
      border: 2px solid #0ea5e9;
      transition: left 300ms ease, height 200ms ease, box-shadow 150ms ease, transform 100ms ease;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #051320;
      font-weight: 700;
      padding-bottom: 6px;
      user-select: none;
      touch-action: none;
    }
    .bar:focus {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }
    .bar.comparing {
      box-shadow: 0 0 0 3px var(--compare);
      border-color: var(--compare);
    }
    .bar.swapping {
      box-shadow: 0 0 0 3px var(--swap);
      border-color: var(--swap);
    }
    .bar.sorted {
      background: linear-gradient(180deg, #22c55e, #15803d);
      border-color: #22c55e;
      color: #072511;
    }
    .bar.dragging {
      transform: translateY(-6px);
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
    }

    .side.panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .code {
      background: var(--code-bg);
      border-radius: 8px;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .code pre {
      margin: 0;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      color: var(--text);
      white-space: pre-wrap;
    }
    .code .line {
      display: block;
      padding: 4px 6px;
      border-radius: 6px;
    }
    .code .active {
      background: rgba(56, 189, 248, 0.18);
      border-left: 3px solid var(--accent);
    }

    .status {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 13px;
    }
    .status .box {
      background: #0c1324;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .status .box b {
      color: var(--muted);
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
      letter-spacing: 0.2px;
    }

    .tips {
      font-size: 13px;
      color: var(--muted);
    }

    /* Responsive */
    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
    }
    @media (max-width: 640px) {
      .controls { grid-template-columns: 1fr; }
      .viz.panel { height: 280px; }
      .status { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="module" role="main">
    <header>
      <h1>Bubble Sort: Visual Passes and Swaps</h1>
      <p>Explore adjacent comparisons, swapping, and the growing sorted suffixâ€”with step-by-step control and animated feedback.</p>
    </header>

    <section class="controls">
      <div class="panel" aria-label="Data controls">
        <div class="group-title">Data</div>
        <div class="row">
          <label for="size">
            Size
            <input id="size" type="number" min="5" max="20" value="10" aria-label="Array size">
          </label>
          <button id="randomBtn" aria-label="Generate random array">Randomize</button>
          <button id="shuffleBtn" aria-label="Shuffle current array">Shuffle</button>
          <label for="order">
            Order
            <select id="order" aria-label="Sort order">
              <option value="asc">Ascending</option>
              <option value="desc">Descending</option>
            </select>
          </label>
        </div>
        <div class="row">
          <label for="csv">
            Custom values (CSV)
            <input id="csv" type="text" placeholder="e.g., 4,1,9,3,7" aria-label="CSV values">
          </label>
          <button id="applyCsvBtn" aria-label="Apply CSV values">Apply</button>
          <button id="resetBtn" aria-label="Reset to initial arrangement">Reset</button>
        </div>
      </div>

      <div class="panel" aria-label="Playback controls">
        <div class="group-title">Playback</div>
        <div class="row">
          <button id="startBtn" class="primary" aria-label="Start sorting">Start</button>
          <button id="pauseBtn" aria-label="Pause sorting">Pause</button>
          <button id="stepBtn" aria-label="Step one comparison">Step</button>
          <button id="nextPassBtn" aria-label="Jump to next pass">Next Pass</button>
          <label for="speed">
            Speed
            <input id="speed" type="range" min="0" max="100" value="50" aria-label="Animation speed">
          </label>
        </div>
      </div>
    </section>

    <section class="main">
      <div class="viz-wrapper">
        <div class="viz-header">
          <div>
            <strong>Array Visualization</strong>
          </div>
          <div class="legend" aria-hidden="true">
            <span class="compare"><b></b> comparing</span>
            <span class="swap"><b></b> swapping</span>
            <span class="sorted"><b></b> sorted suffix</span>
          </div>
        </div>
        <div class="viz panel">
          <div class="bars" id="bars" aria-label="Bar chart representation of array"></div>
          <div class="suffix-mask" id="suffixMask" aria-hidden="true"></div>
        </div>
      </div>

      <aside class="side panel" aria-label="Algorithm and status">
        <div class="code" aria-label="Bubble sort pseudocode">
          <pre id="code">
<span class="line" data-line="1">1. function bubbleSort(A):</span>
<span class="line" data-line="2">2.   for pass from 0 to n-1:</span>
<span class="line" data-line="3">3.     swapped = false</span>
<span class="line" data-line="4">4.     for j from 0 to n-2-pass:</span>
<span class="line" data-line="5">5.       if needsSwap(A[j], A[j+1]):</span>
<span class="line" data-line="6">6.         swap(A[j], A[j+1]); swapped = true</span>
<span class="line" data-line="7">7.     if not swapped: break</span>
          </pre>
        </div>

        <div class="status" aria-live="polite" aria-atomic="true">
          <div class="box">
            <b>Progress</b>
            <div>Pass: <span id="passCount">0</span></div>
            <div>Inner index j: <span id="jIndex">-</span></div>
            <div>Array size: <span id="nSize">0</span></div>
          </div>
          <div class="box">
            <b>Metrics</b>
            <div>Comparisons: <span id="cmpCount">0</span></div>
            <div>Swaps: <span id="swpCount">0</span></div>
          </div>
          <div class="box" style="grid-column: span 2;">
            <b>Narration</b>
            <div id="narration">Ready.</div>
          </div>
        </div>
      </aside>
    </section>

    <section class="tips panel" aria-label="Tips">
      - Drag bars or use Left/Right arrows on a focused bar to reorder the starting array.
      - Step to see each comparison; swaps animate. The green area shows the sorted suffix growing after each pass.
      - Keyboard shortcuts: Space toggles start/pause; N steps; R resets.
    </section>
  </div>

  <script>
    // Utility: clamp
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // State
    const state = {
      values: [],
      initialValues: [],
      orderAsc: true,
      isRunning: false,
      speedMs: 500,
      pass: 0,
      j: 0,
      swappedInPass: false,
      comparisons: 0,
      swaps: 0,
      timer: null,
      layout: { barWidth: 0, gap: 8, scaleH: 2 },
    };

    // Elements
    const barsEl = document.getElementById('bars');
    const suffixMaskEl = document.getElementById('suffixMask');
    const sizeInput = document.getElementById('size');
    const orderSelect = document.getElementById('order');
    const csvInput = document.getElementById('csv');
    const applyCsvBtn = document.getElementById('applyCsvBtn');
    const randomBtn = document.getElementById('randomBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stepBtn = document.getElementById('stepBtn');
    const nextPassBtn = document.getElementById('nextPassBtn');
    const speedInput = document.getElementById('speed');

    const passCountEl = document.getElementById('passCount');
    const jIndexEl = document.getElementById('jIndex');
    const nSizeEl = document.getElementById('nSize');
    const cmpCountEl = document.getElementById('cmpCount');
    const swpCountEl = document.getElementById('swpCount');
    const narrationEl = document.getElementById('narration');
    const codePre = document.getElementById('code');

    // Build random values
    function randomValues(n) {
      const arr = [];
      for (let i = 0; i < n; i++) {
        arr.push(Math.floor(10 + Math.random() * 90)); // 10..99
      }
      return arr;
    }

    // Layout calculation
    function computeLayout() {
      const rect = barsEl.getBoundingClientRect();
      const n = state.values.length;
      const gap = state.layout.gap;
      const totalGap = gap * (n + 1);
      const barWidth = Math.max(16, Math.floor((rect.width - totalGap) / n));
      state.layout.barWidth = barWidth;
      const maxVal = Math.max(...state.values, 1);
      const scaleH = Math.max(2, Math.floor((rect.height - 24) / maxVal));
      state.layout.scaleH = scaleH;
    }

    // Render bars
    function renderBars() {
      barsEl.innerHTML = '';
      const n = state.values.length;
      nSizeEl.textContent = n;
      computeLayout();

      for (let i = 0; i < n; i++) {
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.setAttribute('tabindex', '0');
        bar.setAttribute('role', 'button');
        bar.setAttribute('aria-label', `Value ${state.values[i]}`);
        bar.dataset.index = i;
        bar.textContent = state.values[i];

        barsEl.appendChild(bar);
      }
      positionBars();
      addBarInteractions();
      updateSuffixMask();
    }

    // Position bars based on current state.values order
    function positionBars() {
      const n = state.values.length;
      const gap = state.layout.gap;
      const w = state.layout.barWidth;
      const scaleH = state.layout.scaleH;

      const rect = barsEl.getBoundingClientRect();
      for (let i = 0; i < n; i++) {
        const bar = barsEl.children[i];
        const left = gap + i * (w + gap);
        bar.style.left = `${left}px`;
        bar.style.width = `${w}px`;
        bar.style.height = `${Math.max(12, state.values[i] * scaleH)}px`;
      }
    }

    // Pseudocode highlighting
    function setActiveLine(lineNum) {
      const lines = codePre.querySelectorAll('.line');
      lines.forEach(l => l.classList.remove('active'));
      const target = codePre.querySelector(`.line[data-line="${lineNum}"]`);
      if (target) target.classList.add('active');
    }

    // Narration
    function narrate(text) {
      narrationEl.textContent = text;
    }

    // Update status counters
    function updateStatus() {
      passCountEl.textContent = state.pass;
      jIndexEl.textContent = state.pass >= state.values.length - 1 ? '-' : state.j;
      cmpCountEl.textContent = state.comparisons;
      swpCountEl.textContent = state.swaps;
    }

    // Update sorted suffix mask width
    function updateSuffixMask() {
      const n = state.values.length;
      const suffixLen = Math.min(state.pass, n);
      const w = state.layout.barWidth;
      const gap = state.layout.gap;
      const rect = barsEl.getBoundingClientRect();
      const suffixWidth = suffixLen * (w + gap);
      suffixMaskEl.style.width = `${suffixWidth}px`;
    }

    // Compare helper for order
    function needsSwap(a, b) {
      return state.orderAsc ? a > b : a < b;
    }

    // Highlight bars i and i+1 as comparing
    function highlightCompare(i) {
      clearHighlights();
      const barA = barsEl.children[i];
      const barB = barsEl.children[i + 1];
      barA.classList.add('comparing');
      barB.classList.add('comparing');
    }

    // Clear highlights
    function clearHighlights() {
      [...barsEl.children].forEach(b => {
        b.classList.remove('comparing', 'swapping');
      });
    }

    // Swap values at positions i and i+1 and animate
    function animateSwap(i) {
      return new Promise(resolve => {
        const a = barsEl.children[i];
        const b = barsEl.children[i + 1];
        a.classList.add('swapping');
        b.classList.add('swapping');

        // Swap values in state
        const tmp = state.values[i];
        state.values[i] = state.values[i + 1];
        state.values[i + 1] = tmp;

        // Update accessible labels and text
        a.textContent = state.values[i];
        a.setAttribute('aria-label', `Value ${state.values[i]}`);
        b.textContent = state.values[i + 1];
        b.setAttribute('aria-label', `Value ${state.values[i + 1]}`);

        // Reorder DOM children for accurate left positions
        // We will swap innerHTML/labels but keep DOM order consistent with indices.
        // Then just reposition all bars according to values.
        positionBars();

        // Wait for CSS transition on 'left'
        const onEnd = (e) => {
          if (e.propertyName === 'left') {
            a.removeEventListener('transitionend', onEnd);
            resolve();
          }
        };
        a.addEventListener('transitionend', onEnd);
      });
    }

    // Initialize sorting state
    function resetSortState() {
      state.pass = 0;
      state.j = 0;
      state.swappedInPass = false;
      state.comparisons = 0;
      state.swaps = 0;
      clearHighlights();
      updateStatus();
      updateSuffixMask();
      setActiveLine(1);
      narrate('Ready.');
    }

    // Step: one comparison (and possible swap)
    async function stepOnce() {
      const n = state.values.length;
      if (state.pass >= n - 1) {
        setActiveLine(1);
        narrate('Sorting complete.');
        return false;
      }

      // Enter inner loop if at start of pass
      if (state.j === 0) {
        setActiveLine(2);
        narrate(`Pass ${state.pass}: starting inner loop.`);
        await waitMs(0.5 * state.speedMs);
        setActiveLine(3);
        narrate('Reset swapped flag for this pass.');
        state.swappedInPass = false;
        await waitMs(0.4 * state.speedMs);
      }

      // Inner loop check
      setActiveLine(4);
      const maxJ = (n - 2) - state.pass;
      if (state.j > maxJ) {
        // End of inner loop: early exit check
        setActiveLine(7);
        if (!state.swappedInPass) {
          narrate('No swaps in this pass. Early exit: array is sorted.');
          // Mark remaining as sorted
          state.pass = n - 1;
          updateSuffixMask(); // full width
          updateStatus();
          return false;
        }
        // Completed pass; increment pass, reset j
        state.pass++;
        updateSuffixMask();
        narrate(`Pass complete. The largest (or smallest) has bubbled to index ${n - 1 - (state.pass - 1)}.`);
        state.j = 0;
        updateStatus();
        await waitMs(0.6 * state.speedMs);
        return true;
      }

      // Compare A[j] and A[j+1]
      highlightCompare(state.j);
      setActiveLine(5);
      state.comparisons++;
      updateStatus();

      const a = state.values[state.j];
      const b = state.values[state.j + 1];
      narrate(`Compare A[${state.j}]=${a} and A[${state.j + 1}]=${b}.`);

      await waitMs(0.6 * state.speedMs);

      if (needsSwap(a, b)) {
        setActiveLine(6);
        narrate(`Swap needed: ${a} and ${b} are out of order.`);
        state.swaps++;
        updateStatus();
        await animateSwap(state.j);
        state.swappedInPass = true;
        narrate(`Swapped. A[${state.j}]=${state.values[state.j]}, A[${state.j + 1}]=${state.values[state.j + 1]}.`);
      } else {
        narrate('No swap needed.');
      }

      clearHighlights();
      state.j++;
      updateStatus();
      return true;
    }

    // Auto-run
    function startAuto() {
      if (state.isRunning) return;
      state.isRunning = true;
      toggleButtons();
      runLoop();
    }

    async function runLoop() {
      while (state.isRunning) {
        const progressed = await stepOnce();
        if (!progressed) {
          // Completed sorting
          state.isRunning = false;
          toggleButtons();
          break;
        }
        await waitMs(0.3 * state.speedMs);
      }
    }

    function pauseAuto() {
      state.isRunning = false;
      toggleButtons();
    }

    // Next pass: step until inner loop ends
    async function nextPass() {
      if (state.isRunning) return;
      const targetPass = state.pass + 1;
      let guard = 0; // prevent infinite loop
      while (state.pass < targetPass && state.pass < state.values.length - 1 && guard < 1000) {
        guard++;
        const progressed = await stepOnce();
        if (!progressed) break;
        await waitMs(0.2 * state.speedMs);
      }
    }

    // Helpers
    function waitMs(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    function toggleButtons() {
      startBtn.disabled = state.isRunning || state.pass >= state.values.length - 1;
      pauseBtn.disabled = !state.isRunning;
      stepBtn.disabled = state.isRunning || state.pass >= state.values.length - 1;
      nextPassBtn.disabled = state.isRunning || state.pass >= state.values.length - 1;
    }

    // Drag and keyboard reorder
    function addBarInteractions() {
      const n = state.values.length;
      const gap = state.layout.gap;
      const w = state.layout.barWidth;
      const rect = barsEl.getBoundingClientRect();

      [...barsEl.children].forEach((bar, index) => {
        // Keyboard reorder
        bar.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            if (state.isRunning) return;
            const dir = e.key === 'ArrowLeft' ? -1 : 1;
            const newIdx = clamp(index + dir, 0, n - 1);
            if (newIdx !== index) {
              const val = state.values[index];
              state.values.splice(index, 1);
              state.values.splice(newIdx, 0, val);
              renderBars();
              resetSortState();
              narrate(`Moved value ${val} to index ${newIdx} via keyboard.`);
            }
          }
        });

        // Pointer drag
        bar.addEventListener('pointerdown', (e) => {
          if (state.isRunning) return;
          bar.setPointerCapture(e.pointerId);
          bar.classList.add('dragging');
          const startX = e.clientX;

          function onMove(ev) {
            const dx = ev.clientX - startX;
            // Compute target index
            const step = w + gap;
            let offsetIndex = Math.round(dx / step);
            let target = clamp(index + offsetIndex, 0, n - 1);
            // Visual hint: do nothing here, we commit on pointerup
          }

          function onUp(ev) {
            bar.classList.remove('dragging');
            bar.releasePointerCapture(ev.pointerId);
            bar.removeEventListener('pointermove', onMove);
            bar.removeEventListener('pointerup', onUp);

            const endX = ev.clientX;
            const dx = endX - startX;
            const step = w + gap;
            let offsetIndex = Math.round(dx / step);
            let target = clamp(index + offsetIndex, 0, n - 1);

            if (target !== index) {
              const val = state.values[index];
              state.values.splice(index, 1);
              state.values.splice(target, 0, val);
              renderBars();
              resetSortState();
              narrate(`Dragged value ${val} from index ${index} to ${target}.`);
            }
          }

          bar.addEventListener('pointermove', onMove);
          bar.addEventListener('pointerup', onUp);
        });
      });
    }

    // CSV parsing
    function parseCsvValues(text) {
      const parts = text.split(/[, ]+/).map(s => s.trim()).filter(Boolean);
      if (!parts.length) return null;
      const vals = parts.map(Number);
      if (vals.some(v => !Number.isFinite(v))) return null;
      // Normalize bounds 1..999
      const normalized = vals.map(v => clamp(Math.round(v), 1, 999));
      return normalized;
    }

    // Event bindings
    sizeInput.addEventListener('change', () => {
      const n = clamp(Number(sizeInput.value), Number(sizeInput.min), Number(sizeInput.max));
      sizeInput.value = n;
      state.values = randomValues(n);
      state.initialValues = [...state.values];
      renderBars();
      resetSortState();
      narrate(`Generated random array of size ${n}.`);
    });

    orderSelect.addEventListener('change', () => {
      state.orderAsc = orderSelect.value === 'asc';
      narrate(`Order set to ${state.orderAsc ? 'ascending' : 'descending'}.`);
    });

    randomBtn.addEventListener('click', () => {
      const n = clamp(Number(sizeInput.value), Number(sizeInput.min), Number(sizeInput.max));
      state.values = randomValues(n);
      state.initialValues = [...state.values];
      renderBars();
      resetSortState();
      narrate(`Randomized array.`);
    });

    shuffleBtn.addEventListener('click', () => {
      for (let i = state.values.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [state.values[i], state.values[j]] = [state.values[j], state.values[i]];
      }
      renderBars();
      resetSortState();
      narrate('Shuffled current array.');
    });

    applyCsvBtn.addEventListener('click', () => {
      const vals = parseCsvValues(csvInput.value);
      if (!vals || vals.length < 2) {
        narrate('Invalid CSV. Enter at least two numeric values.');
        return;
      }
      sizeInput.value = clamp(vals.length, Number(sizeInput.min), Number(sizeInput.max));
      state.values = vals.slice(0, Number(sizeInput.max));
      state.initialValues = [...state.values];
      renderBars();
      resetSortState();
      narrate('Applied custom values.');
    });

    resetBtn.addEventListener('click', () => {
      if (state.initialValues.length) {
        state.values = [...state.initialValues];
        renderBars();
        resetSortState();
        narrate('Reset to initial arrangement.');
      }
    });

    startBtn.addEventListener('click', startAuto);
    pauseBtn.addEventListener('click', pauseAuto);
    stepBtn.addEventListener('click', async () => {
      if (state.isRunning) return;
      await stepOnce();
    });
    nextPassBtn.addEventListener('click', nextPass);

    speedInput.addEventListener('input', () => {
      // Map 0..100 -> 800..150 ms (inverse)
      const v = Number(speedInput.value);
      state.speedMs = Math.round(800 - (v / 100) * 650);
      narrate(`Speed set to ${Math.round((800 - state.speedMs) / 6.5)}%.`);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', async (e) => {
      if (e.target && e.target.tagName && /INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (state.isRunning) pauseAuto(); else startAuto();
      } else if (e.key.toLowerCase() === 'n') {
        e.preventDefault();
        if (!state.isRunning) await stepOnce();
      } else if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        resetBtn.click();
      }
    });

    // Resize handling
    window.addEventListener('resize', () => {
      computeLayout();
      positionBars();
      updateSuffixMask();
    });

    // Init
    function init() {
      state.orderAsc = orderSelect.value === 'asc';
      state.values = randomValues(Number(sizeInput.value));
      state.initialValues = [...state.values];
      speedInput.dispatchEvent(new Event('input'));
      renderBars();
      resetSortState();
      toggleButtons();
    }
    init();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a bubble sort visualization that models data configuration, manual reordering, playback control, algorithmic animation states (comparing, swapping), pass transitions, and completion.",
  "states": [
    {
      "name": "ready",
      "onEnter": "render_and_reset",
      "on": {
        "CLICK_START": "running",
        "KEY_SPACE": "running",
        "CLICK_STEP": "pass_init",
        "KEY_N": "pass_init",
        "CLICK_NEXT_PASS": "next_pass",
        "CLICK_RANDOMIZE": "data_randomized",
        "CHANGE_SIZE": "data_randomized",
        "CLICK_SHUFFLE": "data_shuffled",
        "CLICK_RESET": "data_reset",
        "KEY_R": "data_reset",
        "CLICK_APPLY_CSV": "csv_applying",
        "CHANGE_ORDER": "order_changed",
        "INPUT_SPEED": "speed_adjusting",
        "RESIZE_WINDOW": "resizing",
        "BAR_POINTER_DOWN": "dragging_bar",
        "BAR_ARROW_LEFT": "keyboard_reorder",
        "BAR_ARROW_RIGHT": "keyboard_reorder"
      }
    },
    {
      "name": "running",
      "onEnter": "startAuto",
      "on": {
        "CLICK_PAUSE": "paused",
        "KEY_SPACE": "paused",
        "AUTO_TICK": "pass_init",
        "STEP_NO_PROGRESS": "done",
        "SORTING_COMPLETE": "done",
        "RESIZE_WINDOW": "resizing",
        "INPUT_SPEED": "speed_adjusting",
        "CLICK_RESET": "data_reset",
        "CLICK_RANDOMIZE": "data_randomized",
        "CLICK_SHUFFLE": "data_shuffled",
        "CLICK_APPLY_CSV": "csv_applying",
        "CHANGE_ORDER": "order_changed"
      }
    },
    {
      "name": "paused",
      "onEnter": "pauseAuto",
      "on": {
        "CLICK_START": "running",
        "KEY_SPACE": "running",
        "CLICK_STEP": "pass_init",
        "KEY_N": "pass_init",
        "CLICK_NEXT_PASS": "next_pass",
        "CLICK_RESET": "data_reset",
        "KEY_R": "data_reset",
        "CLICK_RANDOMIZE": "data_randomized",
        "CHANGE_SIZE": "data_randomized",
        "CLICK_SHUFFLE": "data_shuffled",
        "CLICK_APPLY_CSV": "csv_applying",
        "CHANGE_ORDER": "order_changed",
        "INPUT_SPEED": "speed_adjusting",
        "RESIZE_WINDOW": "resizing",
        "BAR_POINTER_DOWN": "dragging_bar",
        "BAR_ARROW_LEFT": "keyboard_reorder",
        "BAR_ARROW_RIGHT": "keyboard_reorder"
      }
    },
    {
      "name": "pass_init",
      "onEnter": "pass_init_setup",
      "on": {
        "PASS_INIT_DONE": "inner_loop_check"
      }
    },
    {
      "name": "inner_loop_check",
      "onEnter": "setActiveLine_4",
      "on": {
        "INNER_LOOP_END": "early_exit_check",
        "COMPARISON_READY": "comparing"
      }
    },
    {
      "name": "early_exit_check",
      "onEnter": "setActiveLine_7",
      "on": {
        "EARLY_EXIT_NO_SWAPS": "early_exit",
        "PASS_COMPLETED": "pass_complete"
      }
    },
    {
      "name": "early_exit",
      "onEnter": "apply_early_exit",
      "on": {
        "SORTING_COMPLETE": "done"
      }
    },
    {
      "name": "pass_complete",
      "onEnter": "complete_pass",
      "on": {
        "AUTO_RUNNING_CONTINUE": "running",
        "MANUAL_CONTINUE": "ready"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlightCompare_and_stats",
      "on": {
        "SWAP_NEEDED": "swapping",
        "NO_SWAP_NEEDED": "no_swap"
      }
    },
    {
      "name": "swapping",
      "onEnter": "swap_animation_and_stats",
      "onExit": "clearHighlights",
      "on": {
        "SWAP_ANIM_DONE": "advance_j"
      }
    },
    {
      "name": "no_swap",
      "onEnter": "narrate_no_swap",
      "onExit": "clearHighlights",
      "on": {
        "COMPARISON_DONE": "advance_j"
      }
    },
    {
      "name": "advance_j",
      "onEnter": "increment_j_and_update_status",
      "on": {
        "AUTO_RUNNING_CONTINUE": "running",
        "STEP_COMPLETE": "ready"
      }
    },
    {
      "name": "next_pass",
      "onEnter": "advance_to_next_pass",
      "on": {
        "PASS_COMPLETED": "ready",
        "EARLY_EXIT_NO_SWAPS": "early_exit",
        "SORTING_COMPLETE": "done"
      }
    },
    {
      "name": "dragging_bar",
      "onEnter": "start_drag",
      "on": {
        "BAR_POINTER_MOVE": "dragging_bar",
        "BAR_POINTER_UP": "reorder_commit"
      }
    },
    {
      "name": "reorder_commit",
      "onEnter": "commit_drag_reorder",
      "on": {
        "REORDER_DONE": "ready"
      }
    },
    {
      "name": "keyboard_reorder",
      "onEnter": "keyboard_reorder_action",
      "on": {
        "REORDER_DONE": "ready"
      }
    },
    {
      "name": "data_randomized",
      "onEnter": "randomize_values",
      "on": {
        "DATA_APPLIED": "ready"
      }
    },
    {
      "name": "data_shuffled",
      "onEnter": "shuffle_values",
      "on": {
        "DATA_APPLIED": "ready"
      }
    },
    {
      "name": "data_reset",
      "onEnter": "reset_to_initial_values",
      "on": {
        "DATA_APPLIED": "ready"
      }
    },
    {
      "name": "csv_applying",
      "onEnter": "apply_csv_values",
      "on": {
        "CSV_VALID": "ready",
        "CSV_INVALID": "csv_invalid_feedback"
      }
    },
    {
      "name": "csv_invalid_feedback",
      "onEnter": "narrate_invalid_csv",
      "on": {
        "DISMISS": "ready"
      }
    },
    {
      "name": "order_changed",
      "onEnter": "set_order",
      "on": {
        "ORDER_SET": "ready"
      }
    },
    {
      "name": "speed_adjusting",
      "onEnter": "set_speed",
      "on": {
        "SPEED_SET": "ready"
      }
    },
    {
      "name": "resizing",
      "onEnter": "recompute_layout",
      "on": {
        "RESIZE_DONE": "ready"
      }
    },
    {
      "name": "done",
      "onEnter": "narrate_complete",
      "on": {
        "CLICK_RESET": "data_reset",
        "CLICK_RANDOMIZE": "data_randomized",
        "CHANGE_SIZE": "data_randomized",
        "CLICK_SHUFFLE": "data_shuffled",
        "CLICK_APPLY_CSV": "csv_applying",
        "CHANGE_ORDER": "order_changed",
        "INPUT_SPEED": "speed_adjusting",
        "RESIZE_WINDOW": "resizing",
        "BAR_POINTER_DOWN": "dragging_bar",
        "BAR_ARROW_LEFT": "keyboard_reorder",
        "BAR_ARROW_RIGHT": "keyboard_reorder"
      }
    }
  ],
  "events": [
    "CLICK_START",
    "CLICK_PAUSE",
    "CLICK_STEP",
    "CLICK_NEXT_PASS",
    "CLICK_RANDOMIZE",
    "CLICK_SHUFFLE",
    "CLICK_RESET",
    "CLICK_APPLY_CSV",
    "CHANGE_SIZE",
    "CHANGE_ORDER",
    "INPUT_SPEED",
    "RESIZE_WINDOW",
    "KEY_SPACE",
    "KEY_N",
    "KEY_R",
    "BAR_POINTER_DOWN",
    "BAR_POINTER_MOVE",
    "BAR_POINTER_UP",
    "BAR_ARROW_LEFT",
    "BAR_ARROW_RIGHT",
    "AUTO_TICK",
    "PASS_INIT_DONE",
    "INNER_LOOP_END",
    "COMPARISON_READY",
    "SWAP_NEEDED",
    "NO_SWAP_NEEDED",
    "SWAP_ANIM_DONE",
    "COMPARISON_DONE",
    "AUTO_RUNNING_CONTINUE",
    "MANUAL_CONTINUE",
    "STEP_COMPLETE",
    "STEP_NO_PROGRESS",
    "PASS_COMPLETED",
    "EARLY_EXIT_NO_SWAPS",
    "SORTING_COMPLETE",
    "DATA_APPLIED",
    "CSV_VALID",
    "CSV_INVALID",
    "ORDER_SET",
    "SPEED_SET",
    "RESIZE_DONE",
    "REORDER_DONE",
    "DISMISS"
  ],
  "notes": "Mapping to code: render_and_reset = renderBars() + resetSortState() + toggleButtons(); startAuto = startAuto() which sets isRunning=true, disables/enables buttons via toggleButtons(), and begins runLoop(); pauseAuto = pauseAuto() which sets isRunning=false and calls toggleButtons(). pass_init_setup corresponds to the initial part of stepOnce() when j===0: setActiveLine(2), narrate('Pass ...'), wait, setActiveLine(3), swappedInPass=false, wait. setActiveLine_4 and setActiveLine_7 correspond to highlighting pseudocode lines 4 and 7. highlightCompare_and_stats wraps highlightCompare(j), setActiveLine(5), comparisons++, updateStatus(), narrate(), wait. swap_animation_and_stats wraps setActiveLine(6), narrate('Swap needed'), swaps++, updateStatus(), animateSwap(j), swappedInPass=true, narrate('Swapped ...'). increment_j_and_update_status is j++, updateStatus(). complete_pass increments pass, updates suffix mask and status, narrates pass completion, resets j=0, waits; subsequent continuation depends on isRunning: AUTO_RUNNING_CONTINUE (back to running) vs MANUAL_CONTINUE (back to ready). apply_early_exit sets pass=n-1, updateSuffixMask(), updateStatus(), narrate early exit; transitions to done via SORTING_COMPLETE. advance_to_next_pass models nextPass(): repeatedly calling stepOnce() until pass increments, or early exit; transitions via PASS_COMPLETED to ready or EARLY_EXIT_NO_SWAPS to early_exit -> done. start_drag / commit_drag_reorder / keyboard_reorder_action mirror pointer and keyboard reorder logic: splice values, renderBars(), resetSortState(), narrate. randomize_values, shuffle_values, reset_to_initial_values, apply_csv_values, set_order, set_speed, recompute_layout reflect the respective button/input handlers; each returns to ready via DATA_APPLIED/CSV_VALID/ORDER_SET/SPEED_SET/RESIZE_DONE. narrate_invalid_csv corresponds to narrate('Invalid CSV...'). narrate_complete corresponds to narrate('Sorting complete.') and disabling step/next via toggleButtons(); done state allows data reconfiguration and reordering. Guards: INNER_LOOP_END occurs when j > (n-2-pass); EARLY_EXIT_NO_SWAPS occurs when swappedInPass===false at inner-loop end; PASS_COMPLETED occurs when inner loop ends with swappedInPass===true; SORTING_COMPLETE occurs when pass >= n-1. Speed-dependent waits use state.speedMs and are applied in stepOnce() and auto runLoop. Button disabling/enabling is driven by toggleButtons() based on isRunning and completion (pass >= n-1). Resizing recomputes layout and repositions bars without changing algorithmic indices."
}
  </script>
</body>
</html>