<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort Interactive Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --text: #e5e7eb;        /* gray-200 */
      --muted: #9ca3af;       /* gray-400 */
      --accent: #22c55e;      /* green-500 */
      --accent-2: #06b6d4;    /* cyan-500 */
      --warn: #f59e0b;        /* amber-500 */
      --danger: #ef4444;      /* red-500 */
      --focus: #93c5fd;       /* blue-300 */
      --gap: 16px;
      --safe: 24px;
      --bar-base: #3b82f6;    /* blue-500 */
      --bar-compare: #f97316; /* orange-500 */
      --bar-sorted: #22c55e;  /* green-500 */
      --bar-idle: #64748b;    /* slate-500 */
    }

    html, body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.4;
    }

    .page {
      padding: var(--safe);
      max-width: 1100px;
      margin: 0 auto;
    }

    h1, h2, h3 {
      margin: 0 0 8px 0;
      font-weight: 700;
    }
    h1 { font-size: 24px; }
    h2 { font-size: 20px; }
    h3 { font-size: 18px; }

    p { margin: 0 0 8px 0; color: var(--muted); }

    .section {
      margin-bottom: 24px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 16px;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    @media (min-width: 860px) {
      .layout {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 24px;
      }
    }

    .viz-wrap {
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 16px;
    }

    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--gap);
      margin-bottom: 16px;
    }

    .bar-area {
      position: relative;
      height: 300px;
      border-radius: 8px;
      background: linear-gradient(to bottom, #0e1a2f, #0b1220);
      overflow: hidden;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 48px; /* will be resized responsively */
      background: var(--bar-base);
      border-radius: 8px 8px 0 0;
      transition: left var(--swap-ms, 450ms) ease, height 250ms ease, background-color 200ms ease, transform 200ms ease, opacity 200ms ease;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 6px;
      color: #eaf2ff;
      font-weight: 600;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }

    .bar.idle {
      background: var(--bar-idle);
    }
    .bar.comparing {
      background: var(--bar-compare);
      outline: 3px solid rgba(249, 115, 22, 0.35);
      transform: translateY(-4px);
    }
    .bar.sorted {
      background: var(--bar-sorted);
      outline: none;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
      margin-top: 12px;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #0a1426;
      border: 1px solid #1f2937;
      color: var(--muted);
      font-size: 13px;
    }
    .dot {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display: inline-block;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
    }

    button, .btn {
      appearance: none;
      border: 1px solid #253044;
      background: #0b182f;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 160ms ease, border-color 160ms ease, transform 80ms ease;
    }
    button:hover {
      background: #0f2141;
      border-color: #31415d;
    }
    button:active {
      transform: translateY(1px);
    }
    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .primary {
      background: #0d2e1f;
      border-color: #134e31;
    }
    .primary:hover {
      background: #11402a;
      border-color: #19613f;
    }
    .danger {
      background: #2a0e0e;
      border-color: #4a1a1a;
    }
    .danger:hover {
      background: #3a1313;
      border-color: #6a2626;
    }

    .control {
      display: grid;
      gap: 8px;
    }
    .control label {
      font-size: 13px;
      color: var(--muted);
    }
    input[type="text"], input[type="number"], input[type="range"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #253044;
      background: #0b182f;
      color: var(--text);
      outline: none;
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="range"]:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(147, 197, 253, 0.25);
    }
    input[type="range"] {
      padding: 6px 0;
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      user-select: none;
    }
    .toggle input {
      width: 22px;
      height: 22px;
      cursor: pointer;
    }

    .status {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }
    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }
    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      background: #0b182f;
      border: 1px solid #253044;
      font-size: 13px;
      color: var(--muted);
    }
    .live {
      min-height: 24px;
      color: var(--text);
    }

    .notes {
      margin-top: 24px;
    }
    .list {
      margin: 8px 0 0 0;
      padding-left: 18px;
      color: var(--muted);
    }
    .list li { margin: 6px 0; }

    /* Responsive bar width */
    @media (max-width: 600px) {
      .bar { width: 32px; }
      .bar-area { height: 240px; }
    }
    @media (min-width: 601px) and (max-width: 880px) {
      .bar { width: 40px; }
    }

    /* Focus visibility for keyboard users */
    :focus-visible {
      outline: 3px solid rgba(147, 197, 253, 0.45);
      outline-offset: 2px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="section">
      <h1>Bubble Sort: Adjacent Comparisons and Swaps</h1>
      <p>Learn how bubble sort repeatedly compares adjacent elements and “bubbles” the largest (or smallest) toward its correct end through successive passes.</p>
    </div>

    <div class="layout section">
      <div>
        <div class="panel controls-grid" role="group" aria-label="Controls for data and sorting">
          <div class="control">
            <label for="customInput">Custom values (comma-separated integers, 3–12 items, 1–99):</label>
            <div class="btn-row">
              <input id="customInput" type="text" aria-label="Custom values input" placeholder="e.g., 7, 3, 12, 4, 9" />
              <button id="applyCustomBtn" class="primary" aria-label="Apply custom values">Apply</button>
            </div>
          </div>

          <div class="btn-row">
            <div class="control" style="min-width: 220px;">
              <label for="sizeRange">Set size for random data:</label>
              <input id="sizeRange" type="range" min="3" max="12" step="1" value="7" aria-label="Size of data set" />
              <div class="badge">Size: <span id="sizeLabel">7</span></div>
            </div>
            <button id="randomBtn" aria-label="Generate random values">Randomize</button>
            <button id="resetBtn" class="danger" aria-label="Reset to original order">Reset</button>
          </div>

          <div class="btn-row">
            <button id="playPauseBtn" class="primary" aria-label="Play or pause bubble sort animation">Play</button>
            <button id="stepBtn" aria-label="Perform one bubble sort step">Step</button>
            <div class="control" style="min-width: 220px;">
              <label for="speedRange">Animation speed (0.5×–2×):</label>
              <input id="speedRange" type="range" min="0.5" max="2" step="0.1" value="1" aria-label="Animation speed" />
              <div class="badge">Speed: <span id="speedLabel">1.0×</span></div>
            </div>
            <label class="toggle" title="Stop early if a pass makes no swaps (still bubble sort)">
              <input id="optimizeToggle" type="checkbox" aria-label="Optimize with early exit" />
              Optimize pass (early exit)
            </label>
          </div>
        </div>

        <div class="notes panel">
          <h2>Learning Objective</h2>
          <p>After interacting, you should be able to:</p>
          <ul class="list">
            - Explain bubble sort as repeated adjacent comparisons and conditional swaps.
            - Identify the boundary of the unsorted region shrinking each pass.
            - Predict when a pass will perform no swaps and why that means the list is sorted.
          </ul>

          <h2>Interaction Design</h2>
          <ul class="list">
            - Clicking Play animates the algorithm; the current adjacent pair is highlighted. If out of order, you see a swap animation; otherwise, it moves to the next pair.
            - Clicking Step performs one compare (and swap if needed), letting you reason pair by pair.
            - Typing custom values and clicking Apply rebuilds the bars to explore different inputs.
            - The Optimize pass toggle demonstrates that bubble sort can stop early if a pass makes no swaps.
            - Keyboard: Space toggles play/pause. Right Arrow steps once. R resets to the original order. Screen reader announcements describe each comparison and swap.
          </ul>

          <h2>Layout Description</h2>
          <ul class="list">
            - A safe area of 24 px margins wraps the entire module for comfortable reading and touch targets.
            - Controls are grouped above the visualization with at least 16 px spacing between interactive elements.
            - The bar chart sits in a focused panel with high contrast and subtle outlines to keep attention on the current comparison.
            - Status badges and a live narration area sit below the chart for immediate feedback without clutter.
            - Responsive design: On narrow screens, controls stack vertically; bars shrink in width while remaining readable.
            - Accessibility: Clear focus styles, keyboard shortcuts, ARIA labels, and a polite live region ensure inclusive interaction.
          </ul>
        </div>
      </div>

      <div>
        <div class="viz-wrap" aria-label="Bubble sort visualization">
          <div class="viz-header">
            <div>
              <h2>Visualization</h2>
              <p>Adjacent pairs are highlighted; swaps animate. The unsorted boundary shrinks each pass.</p>
            </div>
            <div class="badge">Pass: <span id="passLabel">0</span> • Pair index: <span id="pairLabel">0</span></div>
          </div>

          <div id="barArea" class="bar-area" role="img" aria-label="Bars representing array values"></div>

          <div class="legend" aria-label="Legend">
            <span class="chip"><span class="dot" style="background: var(--bar-base);"></span> Unsorted</span>
            <span class="chip"><span class="dot" style="background: var(--bar-compare);"></span> Comparing</span>
            <span class="chip"><span class="dot" style="background: var(--bar-sorted);"></span> Sorted region</span>
          </div>

          <div class="status">
            <div class="status-row">
              <span class="badge">Array length: <span id="lenLabel">0</span></span>
              <span class="badge">Unsorted boundary (exclusive): <span id="boundaryLabel">0</span></span>
              <span class="badge">Swaps this pass: <span id="swapCountLabel">0</span></span>
            </div>
            <div id="announcer" class="live" aria-live="polite">Ready.</div>
          </div>
        </div>
      </div>
    </div>

    <div class="section panel">
      <h2>Concept Title</h2>
      <p>Bubble Sort: Step-by-step adjacent comparison and swap animation</p>
    </div>
  </div>

  <script>
    // Bubble Sort Interactive Module
    (function() {
      const barArea = document.getElementById('barArea');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const randomBtn = document.getElementById('randomBtn');
      const resetBtn = document.getElementById('resetBtn');
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const customInput = document.getElementById('customInput');
      const applyCustomBtn = document.getElementById('applyCustomBtn');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const optimizeToggle = document.getElementById('optimizeToggle');

      const passLabel = document.getElementById('passLabel');
      const pairLabel = document.getElementById('pairLabel');
      const lenLabel = document.getElementById('lenLabel');
      const boundaryLabel = document.getElementById('boundaryLabel');
      const swapCountLabel = document.getElementById('swapCountLabel');
      const announcer = document.getElementById('announcer');

      // State
      let original = [];
      let arr = [];
      let pass = 0;     // Number of completed passes
      let j = 0;        // Current pair index within a pass (compare j, j+1)
      let swapsThisPass = 0;
      let isPlaying = false;
      let speedMultiplier = 1; // 0.5x to 2x
      let barWidth = 48;       // Adjusted responsively
      let compareInProgress = false;

      // Utility: Random integer
      function randi(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Build initial data
      function generateRandom(size) {
        const values = [];
        for (let i = 0; i < size; i++) {
          values.push(randi(5, 95));
        }
        setData(values);
      }

      // Apply custom values
      function applyCustom(valuesStr) {
        const parts = valuesStr.split(',').map(s => s.trim()).filter(Boolean);
        if (parts.length < 3 || parts.length > 12) {
          say('Enter between 3 and 12 integers.');
          return;
        }
        const vals = [];
        for (const p of parts) {
          const num = Number(p);
          if (!Number.isInteger(num) || num < 1 || num > 99) {
            say('All values must be integers from 1 to 99.');
            return;
          }
          vals.push(num);
        }
        setData(vals);
      }

      // Set and render data
      function setData(values) {
        original = values.slice();
        arr = values.map((v, idx) => ({ value: v, id: idx })); // id stable
        pass = 0;
        j = 0;
        swapsThisPass = 0;
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        playPauseBtn.setAttribute('aria-pressed', 'false');
        sizeLabel.textContent = String(values.length);
        lenLabel.textContent = String(values.length);
        updateBoundaryLabel();
        swapCountLabel.textContent = '0';
        pairLabel.textContent = '0';
        say('Ready.');
        renderBars();
      }

      // Speak/announce status
      function say(text) {
        announcer.textContent = text;
      }

      // Render bars with positions based on current array order
      function renderBars() {
        barArea.innerHTML = '';
        const n = arr.length;
        adjustBarWidth(n);

        arr.forEach((item, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar idle';
          bar.setAttribute('data-id', item.id);
          bar.setAttribute('data-index', String(idx));
          bar.style.left = `${idx * (barWidth + 12)}px`; // 12px gutter
          bar.style.height = `${Math.max(12, item.value) * 2.2}px`; // Map value to height
          bar.textContent = item.value;
          // Mark sorted region at the end (right side) based on pass
          if (idx >= n - pass) {
            bar.classList.remove('idle');
            bar.classList.add('sorted');
          }
          barArea.appendChild(bar);
        });

        // Stretch area width to contain bars
        const totalWidth = n * barWidth + (n - 1) * 12;
        barArea.style.minWidth = totalWidth + 'px';

        updateLabels();
      }

      function adjustBarWidth(n) {
        // Responsive width depending on viewport and available width
        const maxW = barArea.clientWidth || barArea.offsetWidth || 600;
        const gutter = 12;
        const target = Math.max(28, Math.min(56, Math.floor((maxW - (n - 1) * gutter) / n)));
        barWidth = target;
        // Expose swap duration to CSS via variable
        const swapMs = Math.round(450 * speedMultiplier);
        barArea.style.setProperty('--swap-ms', `${swapMs}ms`);
      }

      // Update positions and classes after a change
      function updateBarPositions() {
        const n = arr.length;
        adjustBarWidth(n);
        const bars = barArea.querySelectorAll('.bar');
        bars.forEach((bar) => {
          const idx = Number(bar.getAttribute('data-index'));
          // Find current index of this bar's id in arr
          const id = Number(bar.getAttribute('data-id'));
          const currentIndex = arr.findIndex(it => it.id === id);
          bar.setAttribute('data-index', String(currentIndex));
          bar.style.left = `${currentIndex * (barWidth + 12)}px`;
          // Update sorted marking
          if (currentIndex >= n - pass) {
            bar.classList.remove('idle');
            bar.classList.remove('comparing');
            bar.classList.add('sorted');
          } else {
            if (!bar.classList.contains('comparing')) {
              bar.classList.remove('sorted');
              bar.classList.add('idle');
            }
          }
        });
        updateLabels();
      }

      // Labels for pass/pair/boundary
      function updateLabels() {
        passLabel.textContent = String(pass);
        pairLabel.textContent = String(j);
        updateBoundaryLabel();
      }

      function updateBoundaryLabel() {
        const boundaryExclusive = Math.max(0, arr.length - pass);
        boundaryLabel.textContent = String(boundaryExclusive);
      }

      // Highlight current pair
      function highlightPair(idx) {
        clearComparing();
        const a = barArea.querySelector(`.bar[data-index="${idx}"]`);
        const b = barArea.querySelector(`.bar[data-index="${idx+1}"]`);
        if (a) {
          a.classList.remove('idle');
          a.classList.add('comparing');
        }
        if (b) {
          b.classList.remove('idle');
          b.classList.add('comparing');
        }
      }

      function clearComparing() {
        const bars = barArea.querySelectorAll('.bar.comparing');
        bars.forEach(b => {
          b.classList.remove('comparing');
          const idx = Number(b.getAttribute('data-index'));
          if (idx < arr.length - pass) {
            b.classList.add('idle');
          } else {
            b.classList.add('sorted');
          }
        });
      }

      // Perform one bubble sort compare (and swap if needed)
      async function step() {
        if (compareInProgress) return;
        const n = arr.length;
        if (pass >= n - 1) {
          say('Sorted: all passes complete.');
          isPlaying = false;
          playPauseBtn.textContent = 'Play';
          return;
        }

        compareInProgress = true;

        // If j reaches boundary-1, finish pass
        const boundaryExclusive = n - pass;
        if (j >= boundaryExclusive - 1) {
          // End of pass: apply optimization if enabled
          if (optimizeToggle.checked && swapsThisPass === 0) {
            pass = n - 1; // Jump to done
            updateBarPositions();
            say('No swaps this pass. Early exit: array is sorted.');
            compareInProgress = false;
            isPlaying = false;
            playPauseBtn.textContent = 'Play';
            return;
          }
          pass += 1;
          swapsThisPass = 0;
          j = 0;
          updateBarPositions();
          say(`Pass ${pass} begins. Unsorted boundary now at index ${n - pass}.`);
          compareInProgress = false;
          // Continue automatically if playing
          if (isPlaying) step();
          return;
        }

        // Highlight pair j, j+1
        highlightPair(j);
        const leftVal = arr[j].value;
        const rightVal = arr[j+1].value;
        say(`Compare ${leftVal} and ${rightVal}. ${leftVal > rightVal ? 'Out of order: swap.' : 'In order: no swap.'}`);
        // Show compare highlight
        await wait(300 * speedMultiplier);

        // Swap if out of order
        if (leftVal > rightVal) {
          // Swap in data
          const tmp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = tmp;
          swapsThisPass += 1;
          swapCountLabel.textContent = String(swapsThisPass);
          // Animate positions
          updateBarPositions();
          await wait(Math.max(350, 450 * speedMultiplier));
        }

        clearComparing();
        j += 1;
        updateLabels();

        compareInProgress = false;

        // Continue automatically if playing
        if (isPlaying) step();
      }

      function wait(ms) {
        return new Promise(res => setTimeout(res, ms));
      }

      // Controls
      playPauseBtn.addEventListener('click', () => {
        isPlaying = !isPlaying;
        playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';
        playPauseBtn.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');
        if (isPlaying) step();
      });

      stepBtn.addEventListener('click', () => {
        step();
      });

      randomBtn.addEventListener('click', () => {
        generateRandom(Number(sizeRange.value));
      });

      resetBtn.addEventListener('click', () => {
        setData(original.slice());
      });

      sizeRange.addEventListener('input', () => {
        sizeLabel.textContent = sizeRange.value;
      });

      applyCustomBtn.addEventListener('click', () => {
        applyCustom(customInput.value);
      });

      customInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          applyCustom(customInput.value);
        }
      });

      speedRange.addEventListener('input', () => {
        speedMultiplier = Number(speedRange.value);
        speedLabel.textContent = `${speedMultiplier.toFixed(1)}×`;
        // Update CSS var for swap duration
        barArea.style.setProperty('--swap-ms', `${Math.round(450 * speedMultiplier)}ms`);
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if (e.code === 'Space') {
          e.preventDefault();
          playPauseBtn.click();
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'r') {
          e.preventDefault();
          resetBtn.click();
        }
      });

      // Initialize
      function init() {
        speedMultiplier = Number(speedRange.value);
        speedLabel.textContent = `${speedMultiplier.toFixed(1)}×`;
        generateRandom(Number(sizeRange.value));
        window.addEventListener('resize', () => {
          adjustBarWidth(arr.length);
          updateBarPositions();
        });
      }

      init();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a bubble sort interactive module covering data setup (random/custom/reset), play/pause control, manual stepping, comparison and swap animations, per-pass transitions with optional early exit optimization, and sorted completion.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "initialize_module",
      "on": {
        "INIT_COMPLETE": "paused"
      }
    },
    {
      "name": "paused",
      "onEnter": "set_play_false_update_button",
      "on": {
        "PLAY_TOGGLE": "playing",
        "STEP_REQUEST": "comparing",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error",
        "ALL_PASSES_DONE": "done"
      }
    },
    {
      "name": "playing",
      "onEnter": "set_play_true_update_button_start_autostep",
      "onExit": "set_play_false_update_button",
      "on": {
        "PLAY_TOGGLE": "paused",
        "STEP_REQUEST": "comparing",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error",
        "AUTO_CONTINUE": "comparing",
        "ALL_PASSES_DONE": "done"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_pair_and_announce",
      "on": {
        "SWAP_NEEDED": "swapping",
        "NO_SWAP": "advancing_pair",
        "PLAY_TOGGLE": "paused",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error"
      }
    },
    {
      "name": "swapping",
      "onEnter": "swap_elements_and_animate",
      "on": {
        "SWAP_ANIMATION_COMPLETE": "advancing_pair",
        "PLAY_TOGGLE": "paused",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error"
      }
    },
    {
      "name": "advancing_pair",
      "onEnter": "clear_highlight_increment_j_update_labels",
      "on": {
        "PASS_END": "pass_transition",
        "AUTO_CONTINUE": "comparing",
        "MANUAL_STEP_DONE": "paused",
        "PLAY_TOGGLE": "paused",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error"
      }
    },
    {
      "name": "pass_transition",
      "onEnter": "end_of_pass_update_or_early_exit_announce",
      "on": {
        "EARLY_EXIT": "done",
        "AUTO_CONTINUE": "comparing",
        "PAUSE": "paused",
        "RANDOMIZE": "rebuilding_data",
        "RESET": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "APPLY_CUSTOM_INVALID": "input_error"
      }
    },
    {
      "name": "rebuilding_data",
      "onEnter": "set_data_and_render_ready",
      "on": {
        "DATA_READY": "paused"
      }
    },
    {
      "name": "input_error",
      "onEnter": "announce_input_error",
      "on": {
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "RESET": "rebuilding_data",
        "RANDOMIZE": "rebuilding_data"
      }
    },
    {
      "name": "done",
      "onEnter": "announce_sorted_and_reset_play_button",
      "on": {
        "RESET": "rebuilding_data",
        "RANDOMIZE": "rebuilding_data",
        "APPLY_CUSTOM_VALID": "rebuilding_data",
        "PLAY_TOGGLE": "done",
        "STEP_REQUEST": "done"
      }
    }
  ],
  "events": [
    "INIT_COMPLETE",
    "PLAY_TOGGLE",
    "STEP_REQUEST",
    "RANDOMIZE",
    "RESET",
    "APPLY_CUSTOM_VALID",
    "APPLY_CUSTOM_INVALID",
    "AUTO_CONTINUE",
    "SWAP_NEEDED",
    "NO_SWAP",
    "SWAP_ANIMATION_COMPLETE",
    "PASS_END",
    "EARLY_EXIT",
    "DATA_READY",
    "ALL_PASSES_DONE",
    "MANUAL_STEP_DONE",
    "PAUSE",
    "SPEED_CHANGE",
    "SIZE_ADJUST",
    "OPTIMIZE_TOGGLE",
    "RESIZE"
  ],
  "notes": "Initialization sets speed from the slider and generates a random dataset based on sizeRange, then renders bars and announces 'Ready.' Keyboard shortcuts: Space emits PLAY_TOGGLE; ArrowRight emits STEP_REQUEST; 'R' emits RESET. Data rebuilding events (RANDOMIZE, RESET, APPLY_CUSTOM_VALID) all flow through rebuilding_data to reinitialize algorithm (pass=0, j=0, swapsThisPass=0, isPlaying=false), rerender bars, update labels, and set the play button to 'Play'. The comparing state highlights bars j and j+1 and announces the comparison; after a delay, it emits SWAP_NEEDED if arr[j].value > arr[j+1].value, else NO_SWAP. The swapping state swaps data elements, increments swapsThisPass, updates positions, and waits for the animation, then continues. The advancing_pair state clears compare highlight, increments j, and updates labels; it emits PASS_END when j reaches boundaryExclusive-1 (n-pass-1), otherwise emits AUTO_CONTINUE if isPlaying is true or MANUAL_STEP_DONE if not. The pass_transition state handles end-of-pass bookkeeping: if optimizeToggle is checked and swapsThisPass===0 it emits EARLY_EXIT to reach done; otherwise it increments pass, resets swapsThisPass and j, updates positions, announces the new pass, and then emits AUTO_CONTINUE to comparing if isPlaying, else PAUSE to paused. Completion occurs when pass >= n-1 (ALL_PASSES_DONE), or via EARLY_EXIT; on entering done, it announces completion and ensures play is off. PLAY_TOGGLE while comparing/swapping/advancing_pair takes effect after the current step finishes (compareInProgress guards reentry); the FSM models this by allowing PLAY_TOGGLE to target paused, with implementation deferring the transition until after the step. SPEED_CHANGE, SIZE_ADJUST, OPTIMIZE_TOGGLE, and RESIZE do not change state: SPEED_CHANGE updates speedMultiplier and CSS swap duration; SIZE_ADJUST updates the size label only; OPTIMIZE_TOGGLE flips a flag used in pass_transition; RESIZE triggers adjustBarWidth and updateBarPositions in-place. The announcer (ARIA live region) is updated on data setup, each comparison, swap outcome, pass start, early exit, and completion."
}
  </script>
</body>
</html>