<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bubble Sort: Adjacent Comparisons and Swaps</title>
<style>
  :root {
    --bg: #0f172a;           /* slate-900 */
    --panel: #111827;        /* gray-900 */
    --text: #e5e7eb;         /* gray-200 */
    --muted: #9ca3af;        /* gray-400 */
    --border: #1f2937;       /* gray-800 */

    --bar: #3b82f6;          /* blue-500 */
    --bar-label: #ffffff;
    --compare-a: #06b6d4;    /* cyan-500 */
    --compare-b: #a78bfa;    /* violet-400 */
    --swap: #f59e0b;         /* amber-500 */
    --sorted: #22c55e;       /* green-500 */
    --accent: #10b981;       /* emerald-500 */

    --focus: #f97316;        /* orange-500 */
    --gap: 16px;
    --safe: 24px;
  }

  html, body {
    background: var(--bg);
    color: var(--text);
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  .wrapper {
    padding: var(--safe);
    box-sizing: border-box;
    max-width: 1200px;
    margin: 0 auto;
  }

  h1 {
    margin: 0 0 8px 0;
    font-size: 24px;
    line-height: 1.3;
  }

  .subtitle {
    color: var(--muted);
    font-size: 14px;
    margin-bottom: 16px;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: var(--gap);
    align-items: flex-end;
    margin-bottom: 16px;
  }

  .group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 220px;
  }

  .group.inline {
    flex-direction: row;
    align-items: center;
    gap: var(--gap);
    min-width: auto;
  }

  label {
    font-size: 13px;
    color: var(--muted);
  }

  input[type="text"],
  input[type="number"],
  input[type="range"],
  select,
  button {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 14px;
    box-sizing: border-box;
    min-height: 40px;
  }

  input[type="range"] {
    padding: 6px 0;
    height: 40px;
  }

  button {
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  button:focus,
  input:focus,
  select:focus {
    outline: 2px solid var(--focus);
    outline-offset: 2px;
  }

  .vis-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
  }

  .vis-area {
    position: relative;
    height: 260px;
    overflow: hidden;
    border-radius: 8px;
    background: linear-gradient(180deg, #0b1329 0%, #0b1329 80%, #0a1125 100%);
  }

  .bars {
    position: relative;
    height: 100%;
  }

  .bar {
    position: absolute;
    bottom: 0;
    width: 40px; /* will be updated dynamically */
    background: var(--bar);
    border-radius: 8px 8px 0 0;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    transition: left 300ms cubic-bezier(.2,.7,.3,1), height 250ms ease, background-color 150ms ease, transform 250ms ease;
  }

  .bar.compare-a {
    background: var(--compare-a);
    box-shadow: 0 0 0 2px rgba(6,182,212,0.35) inset;
  }
  .bar.compare-b {
    background: var(--compare-b);
    box-shadow: 0 0 0 2px rgba(167,139,250,0.35) inset;
  }
  .bar.swapping {
    background: var(--swap);
    transform: translateY(-6px);
  }
  .bar.sorted {
    background: var(--sorted);
  }

  .bar .label {
    color: var(--bar-label);
    font-weight: 600;
    font-size: 12px;
    padding: 6px 0 8px;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 1px 2px rgba(0,0,0,0.4);
  }

  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 12px;
    font-size: 12px;
    color: var(--muted);
  }
  .legend .key {
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  .legend .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    border: 1px solid var(--border);
  }
  .legend .dot.compare-a { background: var(--compare-a); }
  .legend .dot.compare-b { background: var(--compare-b); }
  .legend .dot.swap { background: var(--swap); }
  .legend .dot.sorted { background: var(--sorted); }
  .legend .dot.base { background: var(--bar); }

  .status {
    margin-top: 16px;
    display: grid;
    gap: 8px;
    grid-template-columns: repeat(3, minmax(180px, 1fr));
  }
  .stat {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    min-height: 40px;
  }
  .stat strong {
    display: block;
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 4px;
  }
  .stat .value {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
  }

  .announce {
    margin-top: 16px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    font-size: 14px;
    min-height: 48px;
  }

  .footer-note {
    margin-top: 16px;
    font-size: 12px;
    color: var(--muted);
  }

  @media (max-width: 720px) {
    .status {
      grid-template-columns: 1fr 1fr;
    }
  }
  @media (max-width: 480px) {
    .status {
      grid-template-columns: 1fr;
    }
    .group { min-width: 100%; }
  }
</style>
</head>
<body>
  <div class="wrapper">
    <header>
      <h1>Bubble Sort: Adjacent Comparisons and Swaps</h1>
      <p class="subtitle">Bubble sort repeatedly compares adjacent elements and swaps them when out of order. Each pass pushes the largest (or smallest) remaining element to its final position.</p>
    </header>

    <section class="controls" aria-label="Controls">
      <div class="group">
        <label for="arrayInput">Custom array (comma-separated numbers)</label>
        <div style="display:flex; gap:16px;">
          <input id="arrayInput" type="text" placeholder="e.g., 5, 3, 8, 2, 9" aria-label="Custom array input" />
          <button id="applyArrayBtn" aria-label="Apply custom array">Apply</button>
        </div>
        <div id="arrayError" style="color:#fca5a5; font-size:12px; min-height: 16px;"></div>
      </div>

      <div class="group inline">
        <div>
          <label for="sizeSlider">Size</label>
          <input id="sizeSlider" type="range" min="5" max="20" step="1" value="10" aria-label="Array size" />
        </div>
        <div>
          <label for="speedSlider">Speed</label>
          <input id="speedSlider" type="range" min="0.3" max="3" step="0.1" value="1" aria-label="Animation speed" />
        </div>
        <div>
          <label for="orderSelect">Order</label>
          <select id="orderSelect" aria-label="Sort order">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </div>
      </div>

      <div class="group inline">
        <button id="playPauseBtn" aria-label="Play or pause sorting">Play</button>
        <button id="stepBtn" aria-label="Step one action">Step</button>
        <button id="resetBtn" aria-label="Reset to initial array">Reset</button>
        <button id="shuffleBtn" aria-label="Shuffle new random array">Shuffle</button>
      </div>
    </section>

    <section class="vis-panel" aria-label="Visualization">
      <div class="vis-area">
        <div id="bars" class="bars" role="img" aria-label="Array bars visualization"></div>
      </div>
      <div class="legend" aria-hidden="false">
        <span class="key"><span class="dot base"></span> Base</span>
        <span class="key"><span class="dot compare-a"></span> Compare A</span>
        <span class="key"><span class="dot compare-b"></span> Compare B</span>
        <span class="key"><span class="dot swap"></span> Swapping</span>
        <span class="key"><span class="dot sorted"></span> Sorted</span>
      </div>

      <div class="status">
        <div class="stat" aria-live="polite">
          <strong>Comparisons</strong>
          <div id="compCount" class="value">0</div>
        </div>
        <div class="stat" aria-live="polite">
          <strong>Swaps</strong>
          <div id="swapCount" class="value">0</div>
        </div>
        <div class="stat" aria-live="polite">
          <strong>Pass</strong>
          <div id="passCount" class="value">0</div>
        </div>
      </div>

      <div id="liveMsg" class="announce" aria-live="assertive">Ready. Enter an array or press Shuffle to begin.</div>
      <div class="footer-note">
        Keyboard shortcuts: Space = Play/Pause, S = Step, R = Reset, H = Shuffle.
      </div>
    </section>
  </div>

<script>
(() => {
  // State
  const barsContainer = document.getElementById('bars');
  const arrayInput = document.getElementById('arrayInput');
  const applyArrayBtn = document.getElementById('applyArrayBtn');
  const arrayError = document.getElementById('arrayError');
  const sizeSlider = document.getElementById('sizeSlider');
  const speedSlider = document.getElementById('speedSlider');
  const orderSelect = document.getElementById('orderSelect');

  const playPauseBtn = document.getElementById('playPauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');

  const compCountEl = document.getElementById('compCount');
  const swapCountEl = document.getElementById('swapCount');
  const passCountEl = document.getElementById('passCount');
  const liveMsg = document.getElementById('liveMsg');

  const BASE_COMPARE_MS = 600;
  const BASE_SWAP_MS = 420;
  const BASE_MARK_MS = 300;

  let initialArray = [];
  let dataArray = [];
  let bars = []; // [{el, value}]
  let gen = null;
  let running = false;
  let comparisons = 0;
  let swaps = 0;
  let pass = 0;
  let finished = false;

  // Utilities
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function parseArrayInput(str) {
    const parts = str.split(',').map(s => s.trim()).filter(Boolean);
    if (parts.length === 0) return null;
    const nums = [];
    for (const p of parts) {
      if (!/^-?\d+(\.\d+)?$/.test(p)) return null;
      const n = parseInt(p, 10);
      if (!Number.isFinite(n)) return null;
      if (Math.abs(n) > 9999) return null;
      nums.push(n);
      if (nums.length > 30) return null;
    }
    return nums;
  }

  function announce(msg) {
    liveMsg.textContent = msg;
  }

  function updateCounters() {
    compCountEl.textContent = String(comparisons);
    swapCountEl.textContent = String(swaps);
    passCountEl.textContent = String(pass);
  }

  function createRandomArray(size) {
    const arr = [];
    for (let i = 0; i < size; i++) {
      arr.push(randInt(1, 99));
    }
    return arr;
  }

  function maxValue(arr) {
    return arr.reduce((m, v) => Math.max(m, Math.abs(v)), 1);
  }

  function clearBars() {
    barsContainer.innerHTML = '';
    bars = [];
  }

  function renderBars(arr) {
    clearBars();
    const n = arr.length;
    // Compute dynamic sizes
    const containerWidth = barsContainer.clientWidth || barsContainer.getBoundingClientRect().width;
    const gap = 8;
    const minBarWidth = 28;
    const barWidth = Math.max(minBarWidth, Math.floor((containerWidth - gap * (n - 1)) / n));
    const maxH = barsContainer.clientHeight || 260;
    const maxVal = maxValue(arr);
    for (let i = 0; i < n; i++) {
      const value = arr[i];
      const el = document.createElement('div');
      el.className = 'bar';
      el.setAttribute('role', 'img');
      el.setAttribute('aria-label', `Value ${value}`);
      el.style.width = barWidth + 'px';
      const left = i * (barWidth + gap);
      el.style.left = left + 'px';
      const h = Math.max(40, Math.floor(40 + (Math.abs(value) / maxVal) * (maxH - 60)));
      el.style.height = h + 'px';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = String(value);
      el.appendChild(label);
      barsContainer.appendChild(el);
      bars.push({ el, value });
    }
  }

  function updatePositions() {
    // Reflow positions for all bars according to their index in the bars array
    const n = bars.length;
    const containerWidth = barsContainer.clientWidth || barsContainer.getBoundingClientRect().width;
    const gap = 8;
    const minBarWidth = 28;
    const barWidth = Math.max(minBarWidth, Math.floor((containerWidth - gap * (n - 1)) / n));
    for (let i = 0; i < n; i++) {
      const left = i * (barWidth + gap);
      const b = bars[i];
      b.el.style.width = barWidth + 'px';
      b.el.style.left = left + 'px';
    }
  }

  function updateHeights() {
    const maxH = barsContainer.clientHeight || 260;
    const maxVal = maxValue(bars.map(b => b.value));
    for (const b of bars) {
      const h = Math.max(40, Math.floor(40 + (Math.abs(b.value) / maxVal) * (maxH - 60)));
      b.el.style.height = h + 'px';
      b.el.querySelector('.label').textContent = String(b.value);
      b.el.setAttribute('aria-label', `Value ${b.value}`);
    }
  }

  function clearStyles() {
    for (const b of bars) {
      b.el.classList.remove('compare-a', 'compare-b', 'swapping');
    }
  }

  function markSortedIndex(idx) {
    const b = bars[idx];
    if (b) b.el.classList.add('sorted');
  }

  function clearSortedMarks() {
    for (const b of bars) {
      b.el.classList.remove('sorted');
    }
  }

  function* bubbleSteps(array, asc = true) {
    // Work on a copy to determine actions; visualization will apply swaps.
    const arr = array.slice();
    const n = arr.length;
    let localPass = 0;
    for (let pass = 0; pass < n - 1; pass++) {
      let swappedThisPass = false;
      localPass = pass + 1;
      for (let j = 0; j < n - 1 - pass; j++) {
        yield { type: 'compare', i: j, j: j + 1, pass: localPass, values: [arr[j], arr[j + 1]] };
        const outOfOrder = asc ? arr[j] > arr[j + 1] : arr[j] < arr[j + 1];
        if (outOfOrder) {
          // perform swap in local copy so subsequent compares use updated values
          const tmp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = tmp;
          yield { type: 'swap', i: j, j: j + 1, pass: localPass, values: [arr[j], arr[j + 1]] };
          swappedThisPass = true;
        }
      }
      yield { type: 'markSorted', index: n - 1 - pass, pass: localPass };
      if (!swappedThisPass) {
        // Remaining head is already sorted
        yield { type: 'finish', pass: localPass };
        break;
      }
    }
  }

  function resetCounters() {
    comparisons = 0;
    swaps = 0;
    pass = 0;
    updateCounters();
  }

  function resetToInitial() {
    running = false;
    finished = false;
    playPauseBtn.textContent = 'Play';
    clearSortedMarks();
    clearStyles();
    dataArray = initialArray.slice();
    renderBars(dataArray);
    gen = bubbleSteps(dataArray, orderSelect.value === 'asc');
    resetCounters();
    announce('Reset. Ready to sort.');
    enableControls(true);
  }

  function enableControls(enabled) {
    stepBtn.disabled = !enabled;
    resetBtn.disabled = false; // reset generally stays enabled
    shuffleBtn.disabled = !enabled;
    applyArrayBtn.disabled = !enabled;
    sizeSlider.disabled = !enabled;
    orderSelect.disabled = !enabled;
    arrayInput.disabled = !enabled;
  }

  function setRunning(isRun) {
    running = isRun;
    playPauseBtn.textContent = isRun ? 'Pause' : 'Play';
    stepBtn.disabled = isRun;
    shuffleBtn.disabled = isRun;
    applyArrayBtn.disabled = isRun;
    sizeSlider.disabled = isRun;
    orderSelect.disabled = isRun;
    arrayInput.disabled = isRun;
  }

  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  function getSpeedMultiplier() {
    const s = parseFloat(speedSlider.value || '1');
    return Math.max(0.3, Math.min(3, s));
  }

  async function processEvent(ev) {
    const speed = getSpeedMultiplier();
    if (ev.type === 'compare') {
      comparisons++;
      updateCounters();
      clearStyles();
      const a = bars[ev.i];
      const b = bars[ev.j];
      if (a && b) {
        a.el.classList.add('compare-a');
        b.el.classList.add('compare-b');
        announce(`Pass ${ev.pass}: Compare indices ${ev.i} (${a.value}) and ${ev.j} (${b.value}).`);
      }
      await delay(Math.floor(BASE_COMPARE_MS / speed));
    } else if (ev.type === 'swap') {
      swaps++;
      updateCounters();
      const i = ev.i;
      const j = ev.j;
      const leftBar = bars[i];
      const rightBar = bars[j];
      clearStyles();
      if (leftBar && rightBar) {
        leftBar.el.classList.add('swapping');
        rightBar.el.classList.add('swapping');
        announce(`Swap: Move ${leftBar.value} and ${rightBar.value}.`);
      }
      // Perform swap in bars array
      const tmp = bars[i];
      bars[i] = bars[j];
      bars[j] = tmp;
      // Also swap their values in dataArray for consistency
      const tval = dataArray[i];
      dataArray[i] = dataArray[j];
      dataArray[j] = tval;

      updatePositions();
      updateHeights();

      await delay(Math.floor(BASE_SWAP_MS / speed));
      clearStyles();
    } else if (ev.type === 'markSorted') {
      pass = ev.pass;
      updateCounters();
      markSortedIndex(ev.index);
      announce(`End of pass ${ev.pass}: index ${ev.index} is in final position.`);
      await delay(Math.floor(BASE_MARK_MS / speed));
    } else if (ev.type === 'finish') {
      pass = ev.pass;
      updateCounters();
      // Mark remaining as sorted if not already
      for (let k = 0; k < bars.length; k++) {
        bars[k].el.classList.add('sorted');
      }
      announce(`Array sorted after pass ${ev.pass}.`);
      finished = true;
      setRunning(false);
      enableControls(true);
    }
  }

  async function playLoop() {
    setRunning(true);
    while (running) {
      const { value, done } = gen.next();
      if (done) {
        finished = true;
        announce('Sorting complete.');
        setRunning(false);
        enableControls(true);
        break;
      }
      await processEvent(value);
      // Keep looping unless paused
    }
  }

  function initWithRandom(size) {
    initialArray = createRandomArray(size);
    resetToInitial();
  }

  // Event bindings
  applyArrayBtn.addEventListener('click', () => {
    const val = arrayInput.value.trim();
    arrayError.textContent = '';
    const arr = parseArrayInput(val);
    if (!arr) {
      arrayError.textContent = 'Invalid input. Use comma-separated integers (up to 30 values, abs â‰¤ 9999).';
      return;
    }
    initialArray = arr.slice();
    finished = false;
    resetToInitial();
  });

  sizeSlider.addEventListener('input', () => {
    // Live regenerate on size change only if not running
    if (running) return;
    const size = parseInt(sizeSlider.value, 10);
    initialArray = createRandomArray(size);
    resetToInitial();
  });

  orderSelect.addEventListener('change', () => {
    if (running) return;
    gen = bubbleSteps(dataArray, orderSelect.value === 'asc');
    clearSortedMarks();
    announce(`Order set to ${orderSelect.value === 'asc' ? 'ascending' : 'descending'}. Ready.`);
  });

  playPauseBtn.addEventListener('click', async () => {
    if (!running && finished) {
      // If finished, reset generator to allow replay
      gen = bubbleSteps(dataArray, orderSelect.value === 'asc');
      finished = false;
      clearSortedMarks();
      resetCounters();
    }
    if (running) {
      setRunning(false);
      announce('Paused.');
      return;
    }
    playLoop();
  });

  stepBtn.addEventListener('click', async () => {
    if (running) return;
    const { value, done } = gen.next();
    if (done) {
      finished = true;
      announce('Sorting complete.');
      return;
    }
    await processEvent(value);
  });

  resetBtn.addEventListener('click', () => {
    resetToInitial();
  });

  shuffleBtn.addEventListener('click', () => {
    if (running) return;
    const size = parseInt(sizeSlider.value || '10', 10);
    initialArray = createRandomArray(size);
    resetToInitial();
    announce('Shuffled a new random array.');
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') {
      e.preventDefault();
      playPauseBtn.click();
    } else if (e.key.toLowerCase() === 's') {
      e.preventDefault();
      stepBtn.click();
    } else if (e.key.toLowerCase() === 'r') {
      e.preventDefault();
      resetBtn.click();
    } else if (e.key.toLowerCase() === 'h') {
      e.preventDefault();
      shuffleBtn.click();
    }
  });

  // Handle resize for responsive bar positions
  window.addEventListener('resize', () => {
    updatePositions();
  });

  // Initialize
  initWithRandom(parseInt(sizeSlider.value || '10', 10));
  announce('Ready. Enter an array or press Shuffle to begin.');
})();
</script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for a bubble sort visualization with play/pause, step, reset, shuffle, order/size changes, and array input. It models user control states, animation/visual feedback states (compare, swap, mark sorted), and completion.",
  "states": [
    {
      "name": "ready",
      "onEnter": "renderBarsAndCreateGenerator",
      "on": {
        "PLAY": "playing",
        "STEP_COMPARE": "comparing",
        "STEP_SWAP": "swapping",
        "STEP_MARK_SORTED": "marking_sorted",
        "STEP_FINISH": "done",
        "APPLY_ARRAY_VALID": "resetting",
        "APPLY_ARRAY_INVALID": "input_error",
        "SIZE_CHANGE": "resetting",
        "ORDER_CHANGE": "ready",
        "RESET": "resetting",
        "SHUFFLE": "shuffling",
        "WINDOW_RESIZE": "ready"
      }
    },
    {
      "name": "input_error",
      "onEnter": "showArrayError",
      "onExit": "clearArrayError",
      "on": {
        "APPLY_ARRAY_VALID": "resetting",
        "APPLY_ARRAY_INVALID": "input_error",
        "RESET": "resetting",
        "SHUFFLE": "shuffling",
        "PLAY": "playing",
        "ORDER_CHANGE": "input_error",
        "WINDOW_RESIZE": "input_error"
      }
    },
    {
      "name": "resetting",
      "onEnter": "resetToInitial",
      "on": {
        "RESET_COMPLETE": "ready",
        "WINDOW_RESIZE": "resetting"
      }
    },
    {
      "name": "shuffling",
      "onEnter": "shuffleAndReset",
      "on": {
        "RESET_COMPLETE": "ready",
        "WINDOW_RESIZE": "shuffling"
      }
    },
    {
      "name": "playing",
      "onEnter": "setRunningTrue",
      "onExit": "setRunningFalse",
      "on": {
        "PAUSE": "paused",
        "COMPARE": "comparing",
        "SWAP": "swapping",
        "MARK_SORTED": "marking_sorted",
        "FINISH": "done",
        "RESET": "resetting",
        "ORDER_CHANGE": "playing",
        "SIZE_CHANGE": "playing",
        "WINDOW_RESIZE": "playing"
      }
    },
    {
      "name": "paused",
      "onEnter": "announcePaused",
      "on": {
        "PLAY": "playing",
        "STEP_COMPARE": "comparing",
        "STEP_SWAP": "swapping",
        "STEP_MARK_SORTED": "marking_sorted",
        "STEP_FINISH": "done",
        "RESET": "resetting",
        "SHUFFLE": "shuffling",
        "ORDER_CHANGE": "paused",
        "WINDOW_RESIZE": "paused"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlightCompare",
      "onExit": "clearStyles",
      "on": {
        "ANIMATION_COMPLETE_TO_PLAYING": "playing",
        "ANIMATION_COMPLETE_TO_READY": "ready",
        "ANIMATION_COMPLETE_TO_PAUSED": "paused",
        "PAUSE": "paused",
        "RESET": "resetting",
        "WINDOW_RESIZE": "comparing"
      }
    },
    {
      "name": "swapping",
      "onEnter": "performSwapVisual",
      "onExit": "clearStyles",
      "on": {
        "ANIMATION_COMPLETE_TO_PLAYING": "playing",
        "ANIMATION_COMPLETE_TO_READY": "ready",
        "ANIMATION_COMPLETE_TO_PAUSED": "paused",
        "PAUSE": "paused",
        "RESET": "resetting",
        "WINDOW_RESIZE": "swapping"
      }
    },
    {
      "name": "marking_sorted",
      "onEnter": "markSortedIndex",
      "on": {
        "ANIMATION_COMPLETE_TO_PLAYING": "playing",
        "ANIMATION_COMPLETE_TO_READY": "ready",
        "ANIMATION_COMPLETE_TO_PAUSED": "paused",
        "PAUSE": "paused",
        "RESET": "resetting",
        "WINDOW_RESIZE": "marking_sorted"
      }
    },
    {
      "name": "done",
      "onEnter": "markAllSorted",
      "on": {
        "PLAY": "playing",
        "RESET": "resetting",
        "ORDER_CHANGE": "ready",
        "SHUFFLE": "shuffling",
        "STEP": "done",
        "APPLY_ARRAY_VALID": "resetting",
        "WINDOW_RESIZE": "done"
      }
    }
  ],
  "events": [
    "PLAY",
    "PAUSE",
    "STEP",
    "STEP_COMPARE",
    "STEP_SWAP",
    "STEP_MARK_SORTED",
    "STEP_FINISH",
    "COMPARE",
    "SWAP",
    "MARK_SORTED",
    "FINISH",
    "RESET",
    "RESET_COMPLETE",
    "APPLY_ARRAY_VALID",
    "APPLY_ARRAY_INVALID",
    "SIZE_CHANGE",
    "ORDER_CHANGE",
    "SHUFFLE",
    "WINDOW_RESIZE",
    "ANIMATION_COMPLETE_TO_PLAYING",
    "ANIMATION_COMPLETE_TO_READY",
    "ANIMATION_COMPLETE_TO_PAUSED"
  ],
  "notes": "Implementation details and mapping to the code:\n- ready: Non-running baseline. After initialization or any reset/shuffle/valid apply, the app renders bars, creates a bubbleSteps generator for current array and order, resets counters, clears styling, and enables controls. The 'renderBarsAndCreateGenerator' bundles renderBars(dataArray), gen=bubbleSteps(...), resetCounters(), clearSortedMarks(), announce('Ready...'), enableControls(true).\n- input_error: Triggered when Apply is pressed with invalid text input; shows an error message (arrayError.textContent). Applying a valid array transitions to resetting.\n- resetting: Calls resetToInitial(), which sets running=false, finished=false, Play label to 'Play', clears styles and sorted marks, copies initialArray to dataArray, renders bars, recreates generator, resets counters, announces 'Reset. Ready to sort.', and enables controls. RESET_COMPLETE is an internal, immediate transition to ready once resetToInitial finishes.\n- shuffling: Creates a new random initialArray from the size slider and then calls resetToInitial(); announces 'Shuffled a new random array.' RESET_COMPLETE transitions to ready.\n- playing: Corresponds to running=true; controls (step, shuffle, apply, size, order, input) are disabled via setRunning(true). The play loop (playLoop) repeatedly pulls from gen.next() and dispatches visualization events COMPARE/SWAP/MARK_SORTED/FINISH. ORDER_CHANGE and SIZE_CHANGE while playing are ignored by handlers (early return), so state remains playing.\n- paused: running=false but not finished; Play resumes the loop; Step processes exactly one generator event without toggling running. ORDER_CHANGE while paused resets the generator to the current dataArray/order and clears sorted marks, staying paused.\n- comparing: Visual state during a comparison step. highlightCompare includes: increment comparisons, updateCounters(), clearStyles(), add 'compare-a'/'compare-b' classes to the two bars, announce(Compare...), and delay proportional to the speed slider. On exit, styles are cleared. After the delay, transition depends on context: ANIMATION_COMPLETE_TO_PLAYING (continuous play), ANIMATION_COMPLETE_TO_READY (single step from ready), or ANIMATION_COMPLETE_TO_PAUSED (single step from paused). Clicking Pause during the animation sets running=false; after the animation completes, the FSM should be in paused.\n- swapping: Visual state during a swap. performSwapVisual includes: increment swaps and updateCounters(), clearStyles(), add 'swapping' classes, announce(Swap...), swap bars and values in bars/dataArray, updatePositions(), updateHeights(), delay by speed, then clearStyles. Transition context mirrors 'comparing'.\n- marking_sorted: End-of-pass mark. markSortedIndex includes: set pass count, updateCounters(), mark the final index sorted, announce(End of pass...), and delay by speed. Transition context mirrors 'comparing'.\n- done: Finished sorting. markAllSorted includes: set pass count (if finishing event), mark all bars sorted, announce('Array sorted...'), set finished=true, setRunning(false), enableControls(true). From done, Play prepares replay by recreating the generator, clearing sorted marks, resetting counters, then enters playing. Step in done does nothing (stays done) per code. ORDER_CHANGE when done clears sorted marks and recreates the generator, moving to ready.\n- Keyboard shortcuts map to the same events: Space -> PLAY/PAUSE, S -> STEP (leading to STEP_* based on generator output), R -> RESET, H -> SHUFFLE.\n- WINDOW_RESIZE triggers updatePositions() and does not change state.\n- Guards: SIZE_CHANGE and ORDER_CHANGE are ignored during playing; Apply/Shuffle/Size/Order controls are disabled while playing by setRunning(true). When finished=true, clicking Play first reinitializes the generator and counters before starting playback.\n- Speed control affects delays in comparing, swapping, and marking_sorted via getSpeedMultiplier().\n- Generator events: COMPARE/SWAP/MARK_SORTED/FINISH originate from bubbleSteps() and drive visual states during playing; STEP_* variants represent the same transitions when a single step is requested while not running."
}
  </script>
</body>
</html>