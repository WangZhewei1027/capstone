<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort — Interactive Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Safe area and base */
    :root {
      --safe-margin: 24px;
      --gap: 8px;
      --control-gap: 16px;
      --accent: #2563eb;      /* blue */
      --accent-2: #10b981;    /* green */
      --warn: #ef4444;        /* red */
      --compare: #f59e0b;     /* amber */
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --text: #f8fafc;        /* slate-50 */
      --muted: #cbd5e1;       /* slate-300 */
      --bar: #60a5fa;         /* blue-300 */
      --bar-dup: #93c5fd;     /* blue-200 */
      --ring: #ffffff;
      --focus: #22d3ee;       /* cyan */
      --shadow: 0 10px 20px rgba(0,0,0,0.35);
      --radius: 12px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
    }
    body {
      margin: 0;
      padding: var(--safe-margin);
    }
    h1, h2, h3 {
      margin: 0 0 8px 0;
      line-height: 1.2;
    }
    p { margin: 0 0 10px 0; color: var(--muted); }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }

    /* Module header sections */
    .section {
      background: var(--panel);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .meta-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }
    @media (min-width: 880px) {
      .meta-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Interactive module layout */
    .module {
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 24px;
    }
    @media (max-width: 900px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    .visual-panel {
      background: #0b1220;
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      min-height: 380px;
    }

    .board {
      position: relative;
      flex: 1;
      background: linear-gradient(to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-radius: 10px;
      padding: 12px;
      overflow: hidden;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 12px;
      align-items: center;
    }
    .key {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 14px;
    }
    .swatch {
      width: 16px; height: 16px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
    }
    .swatch.compare { background: var(--compare); }
    .swatch.swap { background: var(--warn); }
    .swatch.settled { background: var(--accent-2); }

    /* Bars */
    .bars {
      position: relative;
      height: 260px;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 40px;           /* will be updated dynamically */
      left: 0px;             /* will be updated dynamically */
      border-radius: 8px 8px 0 0;
      background: var(--bar);
      border: 2px solid rgba(255,255,255,0.15);
      transition: left var(--anim, 320ms) cubic-bezier(.2,.8,.2,1), 
                  height var(--anim, 320ms) cubic-bezier(.2,.8,.2,1), 
                  transform 200ms ease;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
    }
    .bar.dup { background: var(--bar-dup); }
    .bar.compare {
      outline: 3px solid var(--compare);
      outline-offset: 2px;
      filter: brightness(1.05);
    }
    .bar.swap { outline: 3px solid var(--warn); outline-offset: 2px; }
    .bar.settled { background: var(--accent-2); border-color: rgba(255,255,255,0.25); }
    .bar:focus-visible {
      outline: 3px solid var(--focus);
      outline-offset: 3px;
    }
    .bar-label {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17,24,39,0.9);
      padding: 2px 8px;
      border-radius: 8px;
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      white-space: nowrap;
    }
    .bar-value {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 13px;
      font-weight: 700;
      color: #0b1220;
      text-shadow: 0 1px 0 rgba(255,255,255,0.6);
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--control-gap);
      margin-top: 16px;
      align-items: flex-start;
    }
    .controls .group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--control-gap);
    }

    button, input, select, label {
      font: inherit;
      color: var(--text);
    }
    button {
      background: var(--accent);
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
      transition: transform 80ms ease, background 150ms ease;
    }
    button.secondary { background: #374151; }
    button.warn { background: var(--warn); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button:hover:not(:disabled) { transform: translateY(-1px); }
    button:active:not(:disabled) { transform: translateY(0); }

    .input-set {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      background: #0e1626;
      padding: 12px;
      border-radius: 10px;
      box-shadow: var(--shadow);
    }
    .input-set label { color: var(--muted); font-size: 14px; }
    .text-input {
      background: #111827;
      border: 1px solid #2a3342;
      border-radius: 10px;
      padding: 10px;
      min-width: 280px;
    }
    .text-input::placeholder { color: #6b7280; }
    .slider {
      width: 180px;
      accent-color: var(--accent);
    }
    .checkbox {
      accent-color: var(--accent-2);
      width: 18px; height: 18px;
    }

    /* Sidebar / narration */
    .side-panel {
      background: var(--panel);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .stat {
      background: #0e1626;
      padding: 12px;
      border-radius: 10px;
    }
    .stat h4 { font-size: 13px; color: var(--muted); margin-bottom: 6px; }
    .stat .val { font-size: 20px; font-weight: 700; }

    .narration {
      background: #0e1626;
      border-radius: 10px;
      padding: 12px;
      min-height: 80px;
    }
    .narration h3 { font-size: 14px; color: var(--muted); }
    .narration p { font-size: 14px; color: var(--text); }

    .footer-note {
      font-size: 12px; color: var(--muted);
    }

    /* Accessibility helpers */
    .sr-only {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
      border: 0; padding: 0; margin: -1px;
    }
  </style>
</head>
<body>
  <main class="page" aria-labelledby="title">
    <header class="section" id="title">
      <h1>Bubble Sort — Adjacent Comparisons and Swaps</h1>
      <p>Explore bubble sort interactively: compare adjacent values, perform swaps, watch largest items “bubble” to the end on each pass, and understand the early-exit optimization.</p>
    </header>

    <section class="meta-grid">
      <article class="section" aria-labelledby="learning-objective">
        <h2 id="learning-objective">Learning Objective</h2>
        <p>After interacting with this module, you will be able to:</p>
        <ul>
          <li>Explain how bubble sort repeatedly compares and swaps adjacent elements.</li>
          <li>Recognize how each pass moves the largest remaining element to its final position.</li>
          <li>Use and understand the early-exit optimization (stop if a pass makes no swaps).</li>
          <li>Observe algorithmic counts (comparisons, swaps, passes) to reason about performance.</li>
        </ul>
      </article>

      <article class="section" aria-labelledby="interaction-design">
        <h2 id="interaction-design">Interaction Design</h2>
        <p>How you interact and what happens:</p>
        <ul>
          <li>Typing: Enter a custom list of numbers (comma-separated) to visualize different inputs.</li>
          <li>Clicking:
            <ul>
              <li>Step runs the next comparison (and a swap if needed), highlighting the pair.</li>
              <li>Play animates comparisons continuously; Pause stops the animation.</li>
              <li>Reset returns to your initial unsorted state.</li>
              <li>Randomize generates a new list based on the chosen size.</li>
              <li>Early Exit toggle enables/disables the optimization.</li>
              <li>Speed slider adjusts animation duration.</li>
            </ul>
          </li>
          <li>Visual Feedback:
            <ul>
              <li>Compared bars glow amber; swaps pulse red during movement.</li>
              <li>Positions settled at the end of a pass turn green.</li>
              <li>Narration explains each step in plain language and updates live.</li>
            </ul>
          </li>
          <li>Keyboard:
            <ul>
              <li>Space toggles Play/Pause.</li>
              <li>N performs a single Step.</li>
              <li>R resets to the unsorted array.</li>
            </ul>
          </li>
        </ul>
      </article>
    </section>

    <section class="section" aria-labelledby="layout-description">
      <h2 id="layout-description">Layout Description</h2>
      <p>The page uses a clear two-panel module layout:</p>
      <ul>
        <li>Left: Visual panel containing the legend, animated bar chart (the array), and controls.</li>
        <li>Right: Side panel with live stats and narration.</li>
      </ul>
      <p>Spatial organization and spacing:</p>
      <ul>
        <li>A safe area margin of 24 px is maintained around the viewport.</li>
        <li>Interactive controls (buttons, inputs, toggles) have at least 16 px spacing.</li>
        <li>The bar chart uses consistent gaps; compared pairs are visually emphasized without clutter.</li>
      </ul>
      <p>Accessibility and responsiveness:</p>
      <ul>
        <li>All controls are keyboard-accessible with visible focus rings.</li>
        <li>Narration is announced via an ARIA live region.</li>
        <li>Colors are paired with outlines to avoid reliance on color alone.</li>
        <li>The layout adapts to small screens by stacking the panels vertically.</li>
      </ul>
    </section>

    <!-- Interactive Module -->
    <section class="module" aria-label="Bubble Sort Interactive Module">
      <div class="visual-panel">
        <div class="legend" aria-hidden="true">
          <span class="key"><span class="swatch compare"></span>Comparing pair</span>
          <span class="key"><span class="swatch swap"></span>Swapping</span>
          <span class="key"><span class="swatch settled"></span>Settled this pass</span>
        </div>

        <div class="board">
          <div class="bars" id="bars" role="list" aria-label="Array visualization"></div>
        </div>

        <div class="controls" aria-label="Controls">
          <div class="group">
            <button id="btnPlay" aria-pressed="false">Play</button>
            <button id="btnStep" class="secondary">Step</button>
            <button id="btnReset" class="secondary">Reset</button>
            <button id="btnFinish" class="secondary">Finish</button>
          </div>
          <div class="group">
            <label for="speed">Speed</label>
            <input id="speed" class="slider" type="range" min="0.25" max="2.5" step="0.25" value="1" aria-label="Animation speed (0.25x to 2.5x)" />
            <span id="speedVal" aria-hidden="true">1.0×</span>
          </div>
          <div class="group input-set" style="gap: 12px;">
            <label for="numbers">Numbers</label>
            <input id="numbers" class="text-input" type="text" placeholder="e.g., 7, 3, 9, 2, 5" aria-label="Enter comma-separated numbers" />
            <button id="btnApply" class="secondary">Apply</button>
          </div>
          <div class="group">
            <label for="size">Size</label>
            <input id="size" class="slider" type="range" min="5" max="14" step="1" value="8" aria-label="Random array size" />
            <span id="sizeVal" aria-hidden="true">8</span>
            <button id="btnRandom">Randomize</button>
          </div>
          <div class="group">
            <label for="earlyExit" style="display:flex; align-items:center; gap:8px;">
              <input id="earlyExit" class="checkbox" type="checkbox" checked aria-checked="true" />
              Early Exit Optimization
            </label>
          </div>
        </div>
      </div>

      <aside class="side-panel" aria-label="Stats and Narration">
        <div class="stats" role="group" aria-label="Sort statistics">
          <div class="stat">
            <h4>Comparisons</h4>
            <div id="statComparisons" class="val">0</div>
          </div>
          <div class="stat">
            <h4>Swaps</h4>
            <div id="statSwaps" class="val">0</div>
          </div>
          <div class="stat">
            <h4>Pass</h4>
            <div id="statPass" class="val">0</div>
          </div>
          <div class="stat">
            <h4>Range</h4>
            <div id="statRange" class="val">0 → 0</div>
          </div>
        </div>

        <div class="narration" aria-live="polite" aria-atomic="true">
          <h3>Algorithm Narration</h3>
          <p id="narration">Enter numbers or randomize, then Step or Play to watch bubble sort compare adjacent items and swap when out of order.</p>
        </div>

        <p class="footer-note">
          Tip: Bubble sort is stable and simple, but typically inefficient (O(n²) comparisons). Use Step to see exactly how a largest element “bubbles” to the end of the array each pass.
        </p>
      </aside>
    </section>
  </main>

  <script>
    // Bubble Sort Interactive Module (vanilla JS, self-contained)
    (function() {
      const barsEl = document.getElementById('bars');
      const narrationEl = document.getElementById('narration');

      const btnPlay = document.getElementById('btnPlay');
      const btnStep = document.getElementById('btnStep');
      const btnReset = document.getElementById('btnReset');
      const btnRandom = document.getElementById('btnRandom');
      const btnApply = document.getElementById('btnApply');
      const btnFinish = document.getElementById('btnFinish');

      const speedEl = document.getElementById('speed');
      const speedValEl = document.getElementById('speedVal');
      const earlyExitEl = document.getElementById('earlyExit');
      const numbersEl = document.getElementById('numbers');
      const sizeEl = document.getElementById('size');
      const sizeValEl = document.getElementById('sizeVal');

      const statComparisons = document.getElementById('statComparisons');
      const statSwaps = document.getElementById('statSwaps');
      const statPass = document.getElementById('statPass');
      const statRange = document.getElementById('statRange');

      let items = [];             // array of { id, value, label }
      let initialItems = [];
      let playing = false;
      let animScale = 1.0;
      let state = null;

      function resetState() {
        state = {
          n: items.length,
          pass: 0,
          j: 0,
          comparisons: 0,
          swaps: 0,
          swappedInPass: false,
          settledFromRight: 0, // count of settled elements on right
          finished: false,
        };
        clearHighlights();
        updateStats();
        updateRange();
        setNarration('Ready. Press Step to compare the first adjacent pair.');
        renderBars(true);
      }

      function cloneItems(arr) {
        return arr.map(x => ({ id: x.id, value: x.value, label: x.label }));
      }

      function randomArray(n) {
        const arr = [];
        for (let i = 0; i < n; i++) {
          // Include occasional duplicates to hint stability
          const val = Math.floor(Math.random() * 9) + 1; // 1..9
          arr.push(val);
        }
        return arr;
      }

      function withLabels(values) {
        // Assign labels (A, B, C...) to items with the same value to suggest stability
        const counts = new Map();
        const res = [];
        let nextId = 1;
        for (const v of values) {
          const c = (counts.get(v) || 0) + 1;
          counts.set(v, c);
          const label = c > 1 ? String.fromCharCode(64 + c) : ''; // 2->B, 3->C
          res.push({ id: nextId++, value: v, label });
        }
        return res;
      }

      function renderBars(initial = false) {
        const n = items.length;
        barsEl.innerHTML = '';
        const rect = barsEl.getBoundingClientRect();
        const width = rect.width || barsEl.clientWidth || 700;
        const gap = 8;
        const barW = Math.max(28, Math.floor((width - gap * (n - 1)) / n));
        const maxVal = Math.max(...items.map(x => x.value)) || 1;
        const scaleH = (barsEl.clientHeight - 30) / maxVal;

        // Set a CSS variable to scale animation speed
        const dur = Math.round(320 / animScale);
        barsEl.style.setProperty('--anim', `${dur}ms`);

        items.forEach((item, idx) => {
          const left = idx * (barW + gap);
          const bar = document.createElement('button');
          bar.setAttribute('role', 'listitem');
          bar.className = 'bar' + (hasDuplicateLabel(item) ? ' dup' : '');
          bar.style.left = `${left}px`;
          bar.style.width = `${barW}px`;
          bar.style.height = `${Math.max(20, Math.round(item.value * scaleH))}px`;
          bar.dataset.index = String(idx);
          bar.dataset.id = String(item.id);
          bar.tabIndex = 0;
          bar.title = `Index ${idx}: ${item.value}${item.label ? ' (' + item.label + ')' : ''}`;

          const labelEl = document.createElement('span');
          labelEl.className = 'bar-label';
          labelEl.textContent = item.label ? `${item.value} ${item.label}` : String(item.value);

          const valEl = document.createElement('span');
          valEl.className = 'bar-value';
          valEl.textContent = String(item.value);

          bar.appendChild(labelEl);
          bar.appendChild(valEl);

          barsEl.appendChild(bar);
        });

        // Make compared/settled highlights consistent on initial render
        if (!initial) applyHighlightClasses();
      }

      function hasDuplicateLabel(item) {
        return !!item.label;
      }

      function updateStats() {
        statComparisons.textContent = String(state.comparisons);
        statSwaps.textContent = String(state.swaps);
        statPass.textContent = String(state.pass);
      }

      function updateRange() {
        const leftRange = 0;
        const rightRange = state.n - 1 - state.settledFromRight;
        statRange.textContent = `${leftRange} → ${Math.max(leftRange, rightRange)}`;
      }

      function setNarration(text) {
        narrationEl.textContent = text;
      }

      function clearHighlights() {
        barsEl.querySelectorAll('.bar').forEach(b => {
          b.classList.remove('compare', 'swap', 'settled');
        });
      }

      function applyHighlightClasses() {
        clearHighlights();
        const n = items.length;
        const compareIdx = state.j;
        const lastActiveIdx = n - 1 - state.settledFromRight;

        // Set settled class for the right settled segment
        for (let i = lastActiveIdx + 1; i < n; i++) {
          const bar = barsEl.children[i];
          if (bar) bar.classList.add('settled');
        }
        // Highlight current comparison pair
        const a = barsEl.children[compareIdx];
        const b = barsEl.children[compareIdx + 1];
        if (a && b && compareIdx < lastActiveIdx) {
          a.classList.add('compare');
          b.classList.add('compare');
        }
      }

      function parseInputNumbers(text) {
        const parts = text.split(/[\s,]+/).filter(Boolean);
        if (parts.length === 0) return null;
        const nums = [];
        for (const p of parts) {
          const n = Number(p);
          if (!Number.isFinite(n)) return null;
          nums.push(Math.round(n));
        }
        return nums;
      }

      function applyNumbersFromInput() {
        const nums = parseInputNumbers(numbersEl.value);
        if (!nums || nums.length < 2) {
          setNarration('Please enter at least two valid numbers (comma-separated).');
          return;
        }
        items = withLabels(nums);
        initialItems = cloneItems(items);
        resetState();
      }

      function randomize() {
        const n = Number(sizeEl.value);
        sizeValEl.textContent = String(n);
        items = withLabels(randomArray(n));
        initialItems = cloneItems(items);
        resetState();
        setNarration('Randomized array. Press Step to begin comparing adjacent elements.');
      }

      function resetToInitial() {
        items = cloneItems(initialItems);
        resetState();
        setNarration('Reset to the initial array. Press Step or Play to continue.');
      }

      function setSpeed() {
        animScale = Number(speedEl.value);
        speedValEl.textContent = `${animScale.toFixed(2).replace(/\.00/, '')}×`;
        // Re-render to ensure durations update
        renderBars(false);
      }

      function togglePlay() {
        playing = !playing;
        btnPlay.textContent = playing ? 'Pause' : 'Play';
        btnPlay.setAttribute('aria-pressed', playing ? 'true' : 'false');
        if (playing) autoRun();
      }

      function finishSort() {
        if (state.finished) return;
        playing = true;
        btnPlay.textContent = 'Pause';
        btnPlay.setAttribute('aria-pressed', 'true');
        // Increase speed temporarily
        const prevSpeed = animScale;
        animScale = 2.5;
        speedEl.value = String(animScale);
        speedValEl.textContent = `${animScale.toFixed(2)}×`;
        (async () => {
          while (!state.finished && playing) {
            await stepOnce();
            await sleep(30);
          }
          // Restore speed
          animScale = prevSpeed;
          speedEl.value = String(animScale);
          speedValEl.textContent = `${animScale.toFixed(2).replace(/\.00/, '')}×`;
          playing = false;
          btnPlay.textContent = 'Play';
          btnPlay.setAttribute('aria-pressed', 'false');
        })();
      }

      function sleep(ms) {
        return new Promise(res => setTimeout(res, ms));
      }

      async function autoRun() {
        while (playing && !state.finished) {
          await stepOnce();
          // Small delay between steps to keep rhythm
          await sleep(Math.max(60, 200 / animScale));
        }
      }

      async function stepOnce() {
        if (state.finished) return;

        const n = state.n;
        const lastActiveIdx = n - 1 - state.settledFromRight;

        // If current pass is beyond range, we are done
        if (lastActiveIdx <= 0) {
          finalizeSort();
          return;
        }

        // If j reached the last active pair, end pass
        if (state.j >= lastActiveIdx) {
          // End of pass: mark element at lastActiveIdx as settled
          state.settledFromRight += 1;
          applyHighlightClasses(); // will show settled on right side
          state.pass += 1;

          const noSwap = !state.swappedInPass;
          const msg = `End of pass ${state.pass}: position ${lastActiveIdx} is settled.`
                    + (earlyExitEl.checked && noSwap ? ' No swaps this pass — early exit.' : '');
          setNarration(msg);
          updateStats();
          updateRange();

          if (earlyExitEl.checked && noSwap) {
            finalizeSort();
            return;
          }
          // Prepare next pass
          state.j = 0;
          state.swappedInPass = false;
          applyHighlightClasses();
          await sleep(Math.max(120, 220 / animScale));
          return;
        }

        // Compare j and j+1
        applyHighlightClasses();
        const aIdx = state.j, bIdx = state.j + 1;
        const a = items[aIdx], b = items[bIdx];
        state.comparisons += 1;
        updateStats();
        setNarration(`Comparing positions ${aIdx} and ${bIdx}: ${a.value} vs ${b.value}.`)

        await sleep(Math.max(100, 160 / animScale));

        if (a.value > b.value) {
          // Swap needed
          setNarration(`Swap needed: ${a.value} > ${b.value}. Swapping adjacent items.`);
          await animateSwap(aIdx, bIdx);
          // Perform swap in array after animation
          [items[aIdx], items[bIdx]] = [items[bIdx], items[aIdx]];
          state.swaps += 1;
          state.swappedInPass = true;
          updateStats();
          state.j += 1;
        } else {
          // No swap
          setNarration(`No swap: ${a.value} ≤ ${b.value}.`);
          // Brief highlight then advance
          await sleep(Math.max(80, 140 / animScale));
          state.j += 1;
        }
        applyHighlightClasses();
      }

      function finalizeSort() {
        state.finished = true;
        applyHighlightClasses();
        setNarration('Sorted! All elements are in non-decreasing order.');
        playing = false;
        btnPlay.textContent = 'Play';
        btnPlay.setAttribute('aria-pressed', 'false');
      }

      async function animateSwap(i, j) {
        return new Promise(resolve => {
          const barA = barsEl.children[i];
          const barB = barsEl.children[j];
          if (!barA || !barB) return resolve();

          barA.classList.add('swap');
          barB.classList.add('swap');

          // Calculate left positions from style
          const leftA = parseFloat(barA.style.left || '0');
          const leftB = parseFloat(barB.style.left || '0');

          // Swap their left positions visually
          barA.style.left = `${leftB}px`;
          barB.style.left = `${leftA}px`;

          // When both transitions complete, cleanup
          let doneCount = 0;
          function done() {
            doneCount += 1;
            if (doneCount >= 2) {
              barA.classList.remove('swap');
              barB.classList.remove('swap');
              resolve();
            }
          }
          barA.addEventListener('transitionend', done, { once: true });
          barB.addEventListener('transitionend', done, { once: true });
        });
      }

      // Event wiring
      btnStep.addEventListener('click', () => {
        stepOnce();
      });
      btnPlay.addEventListener('click', () => togglePlay());
      btnReset.addEventListener('click', () => resetToInitial());
      btnRandom.addEventListener('click', () => randomize());
      btnApply.addEventListener('click', () => applyNumbersFromInput());
      btnFinish.addEventListener('click', () => finishSort());

      speedEl.addEventListener('input', setSpeed);
      sizeEl.addEventListener('input', () => {
        sizeValEl.textContent = String(sizeEl.value);
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if (e.code === 'Space') {
          e.preventDefault();
          togglePlay();
        } else if (e.key.toLowerCase() === 'n') {
          e.preventDefault();
          stepOnce();
        } else if (e.key.toLowerCase() === 'r') {
          e.preventDefault();
          resetToInitial();
        }
      });

      // Initialize
      (function init() {
        sizeValEl.textContent = String(sizeEl.value);
        setSpeed();
        items = withLabels(randomArray(Number(sizeEl.value)));
        initialItems = cloneItems(items);
        resetState();
        numbersEl.value = items.map(x => x.value).join(', ');
      })();

      // Responsiveness: re-render bars on window resize
      window.addEventListener('resize', () => {
        renderBars(false);
      });
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for a bubble sort interactive module covering user controls (Play/Pause, Step, Reset, Randomize, Apply, Finish), algorithm animation states (comparing, swapping, pass end), and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "await_next_action",
      "on": {
        "PLAY": "playing",
        "STEP": "comparing",
        "FINISH": "fast_forward",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "TOGGLE_EARLY_EXIT": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_auto_run",
      "onExit": "stop_auto_run",
      "on": {
        "PAUSE": "idle",
        "AUTO_STEP": "comparing",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "FINISH": "fast_forward"
      }
    },
    {
      "name": "fast_forward",
      "onEnter": "enable_high_speed_auto_run",
      "onExit": "restore_previous_speed_and_stop_auto_run",
      "on": {
        "PAUSE": "idle",
        "AUTO_STEP": "comparing",
        "COMPLETE_SORT": "done",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_compare_pair_and_update_stats_and_narrate_compare",
      "on": {
        "NEED_SWAP": "swapping",
        "NO_SWAP": "advancing",
        "REACHED_PASS_END": "pass_end",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "PAUSE": "idle",
        "FINISH": "fast_forward"
      }
    },
    {
      "name": "swapping",
      "onEnter": "animate_swap_adjacent_bars",
      "onExit": "clear_swap_highlight",
      "on": {
        "SWAP_ANIMATION_COMPLETE": "advancing",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "PAUSE": "idle",
        "FINISH": "fast_forward"
      }
    },
    {
      "name": "advancing",
      "onEnter": "increment_index_and_apply_highlights",
      "on": {
        "REACHED_PASS_END": "pass_end",
        "MORE_PAIRS_WHILE_PLAYING": "comparing",
        "MORE_PAIRS_WHILE_PAUSED": "idle",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "FINISH": "fast_forward",
        "PAUSE": "idle"
      }
    },
    {
      "name": "pass_end",
      "onEnter": "mark_rightmost_settled_increment_pass_update_range_and_narrate",
      "on": {
        "EARLY_EXIT": "done",
        "CONTINUE_PASS_WHILE_PLAYING": "comparing",
        "CONTINUE_PASS_WHILE_PAUSED": "idle",
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "FINISH": "fast_forward",
        "PAUSE": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_sort_and_update_ui",
      "on": {
        "RESET": "resetting",
        "RANDOMIZE": "randomizing",
        "APPLY_NUMBERS": "applying_input",
        "PLAY": "done",
        "STEP": "done",
        "FINISH": "done"
      }
    },
    {
      "name": "resetting",
      "onEnter": "reset_to_initial_items_and_reset_state_render_bars_update_stats_range_and_narrate",
      "on": {
        "AFTER_RESET": "idle"
      }
    },
    {
      "name": "randomizing",
      "onEnter": "generate_random_items_set_initial_reset_state_render_bars_update_stats_range_and_narrate",
      "on": {
        "AFTER_RANDOMIZE": "idle"
      }
    },
    {
      "name": "applying_input",
      "onEnter": "parse_and_apply_numbers_or_error",
      "on": {
        "APPLY_NUMBERS_VALID": "idle",
        "APPLY_NUMBERS_INVALID": "input_error"
      }
    },
    {
      "name": "input_error",
      "onEnter": "narrate_invalid_input",
      "on": {
        "APPLY_NUMBERS": "applying_input",
        "RANDOMIZE": "randomizing",
        "RESET": "resetting",
        "PLAY": "playing",
        "STEP": "comparing",
        "FINISH": "fast_forward"
      }
    }
  ],
  "events": [
    "INIT",
    "PLAY",
    "PAUSE",
    "STEP",
    "AUTO_STEP",
    "FINISH",
    "RESET",
    "RANDOMIZE",
    "APPLY_NUMBERS",
    "APPLY_NUMBERS_VALID",
    "APPLY_NUMBERS_INVALID",
    "NEED_SWAP",
    "NO_SWAP",
    "SWAP_ANIMATION_COMPLETE",
    "REACHED_PASS_END",
    "EARLY_EXIT",
    "CONTINUE_PASS_WHILE_PLAYING",
    "CONTINUE_PASS_WHILE_PAUSED",
    "MORE_PAIRS_WHILE_PLAYING",
    "MORE_PAIRS_WHILE_PAUSED",
    "COMPLETE_SORT",
    "AFTER_RESET",
    "AFTER_RANDOMIZE",
    "TOGGLE_EARLY_EXIT",
    "SPEED_CHANGE",
    "SIZE_CHANGE",
    "WINDOW_RESIZE"
  ],
  "notes": "Initial state is idle after INIT and resetState. User-triggered events come from: Play/Pause button or Space (PLAY/PAUSE), Step button or 'N' key (STEP), Reset button or 'R' key (RESET), Randomize button (RANDOMIZE), Apply button (APPLY_NUMBERS), Finish button (FINISH). Algorithm-side events: NEED_SWAP/NO_SWAP result from comparing values; SWAP_ANIMATION_COMPLETE fires after CSS transition in animateSwap; REACHED_PASS_END occurs when j reaches the last active index; EARLY_EXIT occurs at pass end when no swaps and the Early Exit checkbox is checked; COMPLETE_SORT triggers when all elements are settled or early exit finalizes. In playing, AUTO_STEP repeatedly drives transitions until paused or done; fast_forward is similar to playing but temporarily forces high speed and restores it on exit. Visual feedback is applied via applyHighlightClasses and CSS classes: compare (amber outline), swap (red outline during animation), settled (green at right after each pass). Speed changes (SPEED_CHANGE via slider) and window resizes (WINDOW_RESIZE) re-render bars and adjust animation durations but do not change FSM state; same for size slider changes (SIZE_CHANGE), which only update the displayed size until Randomize is used. Toggling the Early Exit checkbox (TOGGLE_EARLY_EXIT) affects branching at pass_end but does not change state by itself. Done state ignores Play/Step/Finish; only Reset/Randomize/Apply returns to idle with a fresh state."
}
  </script>
</body>
</html>