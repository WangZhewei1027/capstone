<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Sort — Hands-on Interactive Explorer</title>
  <style>
    :root {
      --bg: #0f172a;             /* slate-900 */
      --panel: #111827;          /* gray-900 */
      --panel-2: #0b1222;        /* darker bluish panel */
      --text: #e5e7eb;           /* gray-200 */
      --muted: #9ca3af;          /* gray-400 */
      --accent: #60a5fa;         /* blue-400 */
      --accent-strong: #3b82f6;  /* blue-500 */
      --good: #34d399;           /* green-400 */
      --warn: #fbbf24;           /* amber-400 */
      --danger: #fb7185;         /* rose-400 */
      --outline: #f59e0b;        /* amber-500 for focus */
      --gap: 16px;
      --radius: 12px;

      --swap-ms: 260ms;
      --compare-ms: 420ms;
      --highlight-ms: 220ms;
      --bar-gap: 8px;
      --bar-min-width: 24px;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f9fafb;
        --panel: #ffffff;
        --panel-2: #f3f4f6;
        --text: #111827;
        --muted: #4b5563;
        --accent: #2563eb;
        --accent-strong: #1d4ed8;
        --good: #059669;
        --warn: #d97706;
        --danger: #dc2626;
        --outline: #7c3aed;
      }
      body {
        color-scheme: light;
      }
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 24px; /* Safe area margins: 24 px on all sides */
      background: radial-gradient(1200px 600px at 10% 10%, rgba(99,102,241,0.08), transparent 55%),
                  radial-gradient(800px 500px at 90% 20%, rgba(56,189,248,0.08), transparent 60%),
                  var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.4;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      font-size: clamp(1.4rem, 1rem + 2vw, 2rem);
      margin: 0 0 8px 0;
      letter-spacing: 0.2px;
    }
    p.lead {
      margin: 0 0 16px;
      color: var(--muted);
    }

    /* Module layout */
    .module {
      display: grid;
      grid-template-columns: 1.7fr 1fr;
      gap: 24px;
      margin-top: 16px;
      align-items: start;
    }
    @media (max-width: 960px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
      padding: 16px;
    }

    .panel h2,
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      letter-spacing: 0.2px;
    }
    .panel h2 + p {
      margin-top: 0;
    }

    /* Visualization area */
    .viz {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .bars-wrap {
      position: relative;
      height: clamp(220px, 32vh, 360px);
      min-height: 200px;
      overflow: hidden;
      border-radius: calc(var(--radius) - 4px);
      background:
        linear-gradient(transparent 95%, rgba(255,255,255,0.06) 95%) 0 0/100% 20%,
        linear-gradient(transparent 75%, rgba(255,255,255,0.06) 75%) 0 0/100% 25%,
        linear-gradient(180deg, rgba(255,255,255,0.04), transparent);
      padding: 12px;
      border: 1px dashed rgba(255,255,255,0.08);
    }

    .bars {
      position: absolute;
      inset: 12px;
      display: flex;
      align-items: flex-end;
      gap: var(--bar-gap);
    }

    .bar {
      position: relative;
      flex: 1 1 auto;
      min-width: var(--bar-min-width);
      background: linear-gradient(180deg, rgba(99,102,241,0.9), rgba(56,189,248,0.9));
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 6px 6px 4px 4px;
      transition: filter var(--highlight-ms) ease, outline-color var(--highlight-ms) ease;
      outline: 2px solid transparent;
      outline-offset: 2px;
    }
    .bar .value {
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 2px 6px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      pointer-events: none;
      white-space: nowrap;
    }

    /* States */
    .bar.comparing {
      filter: saturate(1.4) drop-shadow(0 0 8px rgba(59,130,246,0.55));
      outline-color: var(--accent);
    }
    .bar.to-swap {
      filter: saturate(1.5) drop-shadow(0 0 10px rgba(251,113,133,0.6));
      outline-color: var(--danger);
      background: linear-gradient(180deg, rgba(251,113,133,0.95), rgba(249,115,22,0.9));
    }
    .bar.sorted {
      background: linear-gradient(180deg, rgba(52,211,153,0.95), rgba(16,185,129,0.9));
      border-color: rgba(16,185,129,0.6);
    }

    .bar.swapping {
      transition: transform var(--swap-ms) ease-in-out, filter var(--highlight-ms) ease;
      z-index: 2;
    }

    /* Guide legend */
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 16px;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .key {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .swatch {
      width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.14);
    }
    .swatch.compare { background: linear-gradient(180deg, rgba(99,102,241,0.8), rgba(56,189,248,0.8)); box-shadow: 0 0 0 2px rgba(59,130,246,0.3) inset; }
    .swatch.swap { background: linear-gradient(180deg, rgba(251,113,133,0.9), rgba(249,115,22,0.9)); }
    .swatch.sorted { background: linear-gradient(180deg, rgba(52,211,153,0.95), rgba(16,185,129,0.9)); }

    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: min(100%, 260px);
      flex: 1 1 240px;
    }

    label {
      font-size: 0.92rem;
      color: var(--muted);
      letter-spacing: 0.2px;
    }

    input[type="text"],
    input[type="number"],
    input[type="range"],
    button {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 10px 12px;
      min-height: 44px; /* touch target */
    }
    input[type="text"]::placeholder {
      color: #9aa2b1;
    }
    input[type="number"] {
      width: 120px;
    }
    input[type="range"] {
      height: 44px;
      padding: 0 6px;
      accent-color: var(--accent-strong);
    }

    button {
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, color 120ms ease;
    }
    button:active {
      transform: translateY(1px);
    }
    button:focus-visible,
    input:focus-visible {
      outline: 3px solid var(--outline);
      outline-offset: 2px;
    }
    .btn {
      background: linear-gradient(180deg, rgba(59,130,246,0.95), rgba(37,99,235,0.9));
      border: 1px solid rgba(99,102,241,0.5);
      color: white;
    }
    .btn.secondary {
      background: rgba(255,255,255,0.05);
    }

    .group {
      display: flex;
      flex-wrap: wrap;
      gap: 16px; /* Minimum spacing between controls */
    }

    .note {
      font-size: 0.88rem;
      color: var(--muted);
    }

    /* Pseudocode */
    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      background: rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px;
      line-height: 1.45;
    }
    .code .line {
      display: block;
      padding: 3px 8px;
      border-radius: 8px;
      color: var(--text);
      position: relative;
    }
    .code .line:not(:last-child) {
      margin-bottom: 4px;
    }
    .code .line[data-depth="1"] { padding-left: 20px; }
    .code .line[data-depth="2"] { padding-left: 36px; }
    .code .line[data-depth="3"] { padding-left: 52px; }

    .code .line.active {
      background: linear-gradient(90deg, rgba(59,130,246,0.18), transparent 70%);
      box-shadow: inset 2px 0 0 var(--accent-strong);
    }

    .kbd {
      font-family: ui-monospace, monospace;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 2px 6px;
      border-radius: 6px;
    }

    /* Info and sections */
    section {
      margin-top: 24px;
    }

    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0);
      border: 0;
      white-space: nowrap;
    }

    @media (prefers-reduced-motion: reduce) {
      :root {
        --swap-ms: 0ms;
        --compare-ms: 0ms;
        --highlight-ms: 0ms;
      }
      .bar, .bar.swapping {
        transition: none !important;
      }
    }
  </style>
</head>
<body>
  <a class="sr-only" href="#interactive">Skip to interactive module</a>
  <div class="container">
    <header>
      <h1>Bubble Sort — Hands-on Interactive Explorer</h1>
      <p class="lead">Compare neighbors, swap when needed, and watch the largest values “bubble” to the end.</p>
    </header>

    <main id="interactive" class="module" aria-label="Bubble sort interactive module">
      <!-- Visualization + legend -->
      <section class="panel viz" aria-labelledby="viz-title">
        <h2 id="viz-title">Live visualization</h2>

        <div class="bars-wrap" role="group" aria-label="Bars visualization area">
          <div id="bars" class="bars" aria-live="off" aria-atomic="false"></div>
        </div>

        <div class="legend" aria-hidden="true">
          <span class="key"><span class="swatch compare"></span>Comparing pair</span>
          <span class="key"><span class="swatch swap"></span>Swapping</span>
          <span class="key"><span class="swatch sorted"></span>Sorted boundary</span>
        </div>

        <div class="code" aria-labelledby="code-title">
          <h3 id="code-title" style="margin: 0 0 8px 0; font-size: 0.95rem; color: var(--muted);">Bubble sort pseudocode</h3>
          <code id="pseudo">
            <span class="line" data-line="1">for i from 0 to n-2:</span>
            <span class="line" data-line="2" data-depth="1">swapped = false</span>
            <span class="line" data-line="3" data-depth="1">for j from 0 to n-2-i:</span>
            <span class="line" data-line="4" data-depth="2">if a[j] > a[j+1]:</span>
            <span class="line" data-line="5" data-depth="3">swap(a[j], a[j+1])</span>
            <span class="line" data-line="6" data-depth="3">swapped = true</span>
            <span class="line" data-line="7" data-depth="1">if not swapped: break</span>
          </code>
        </div>

        <div id="status" class="note" aria-live="polite" aria-atomic="true">
          Ready. Press Play or Step to begin.
        </div>
      </section>

      <!-- Controls + inputs -->
      <aside class="panel controls" aria-label="Controls">
        <div class="row" role="group" aria-label="Sort controls" style="gap:16px;">
          <button id="playPause" class="btn" aria-pressed="false" title="Play/Pause (Space)">▶ Play</button>
          <button id="step" class="btn secondary" title="Step (→)">Step</button>
          <button id="reset" class="btn secondary" title="Reset (R)">Reset</button>
        </div>

        <div class="row" role="group" aria-label="Dataset controls">
          <div class="control">
            <label for="numbers">Custom numbers (2–12 values, 0–99), comma-separated</label>
            <div class="group">
              <input id="numbers" type="text" inputmode="numeric" placeholder="e.g., 5, 1, 4, 2, 8" aria-describedby="numbers-help" />
              <button id="apply" class="btn secondary">Apply</button>
            </div>
            <div id="numbers-help" class="note">You can also randomize below.</div>
          </div>
        </div>

        <div class="row" role="group" aria-label="Randomize options">
          <div class="control">
            <label for="count">Item count</label>
            <div class="group">
              <input id="count" type="number" min="3" max="12" step="1" value="8" aria-label="Number of items to generate" />
              <button id="randomize" class="btn secondary" title="Shuffle (S)">Randomize</button>
            </div>
          </div>
        </div>

        <div class="row" role="group" aria-label="Speed control and info">
          <div class="control">
            <label for="speed">Animation speed: <span id="speedLabel">1.0×</span></label>
            <input id="speed" type="range" min="0.25" max="2" step="0.25" value="1" />
          </div>
          <div class="control">
            <label>Keyboard shortcuts</label>
            <div class="note">
              <span class="kbd">Space</span> Play/Pause
              &nbsp; <span class="kbd">→</span> Step
              &nbsp; <span class="kbd">R</span> Reset
              &nbsp; <span class="kbd">S</span> Randomize
            </div>
          </div>
        </div>
      </aside>
    </main>

    <!-- Required sections -->
    <section class="panel" aria-labelledby="concept-title">
      <h2 id="concept-title">Concept Title</h2>
      <p>Bubble Sort: Visualizing adjacent comparisons and swaps to progressively move the largest elements to the end of the list.</p>
    </section>

    <section class="panel" aria-labelledby="learning-objective">
      <h2 id="learning-objective">Learning Objective</h2>
      <ul>
        - Understand how bubble sort repeatedly compares adjacent elements and swaps them if out of order.<br />
        - Recognize the “bubbling” effect: after each pass, the largest remaining element settles at the end (sorted boundary grows).<br />
        - Read the algorithm’s pseudocode and map each line to the live state of the visualization.<br />
        - Control the sorting process via step-by-step execution or continuous play, and observe the impact of swaps.
      </ul>
    </section>

    <section class="panel" aria-labelledby="interaction-design">
      <h2 id="interaction-design">Interaction Design</h2>
      <ul>
        - Clicking Play starts automated, animated comparisons and swaps; Pause halts it without losing progress. The Step button performs exactly one comparison/swap cycle.<br />
        - Type your own numbers or Randomize to generate a dataset; Reset returns to the unsorted starting state with the current dataset.<br />
        - When two bars are compared, they glow blue; if a swap is required, they turn warm (orange/rose) and slide past each other. Completed elements become green at the right boundary.<br />
        - A pseudocode panel highlights the current line corresponding to the algorithm’s state, reinforcing the mapping between code and behavior.<br />
        - Speed slider adjusts all timing; keyboard shortcuts provide accessible control. Screen reader announcements describe current comparisons and swaps.
      </ul>
    </section>

    <section class="panel" aria-labelledby="layout-desc">
      <h2 id="layout-desc">Layout Description</h2>
      <ul>
        - The page maintains 24 px safe-area margins on all sides; interactive elements have at least 16 px spacing between them.<br />
        - The module uses a two-column layout on larger screens: the visualization and pseudocode on the left; controls on the right. On small screens, these stack vertically for clarity and focus.<br />
        - The bars area is visually contained with clear legends and color-coded states (compare, swap, sorted). Labels above bars display exact values for readability and accessibility.<br />
        - Controls are grouped with labels for dataset, execution, and speed. All tappable elements meet a minimum 44 px touch target. Focus-visible outlines and ARIA live regions support accessibility.
      </ul>
    </section>

    <div id="live" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  </div>

  <script>
    (function () {
      const barsEl = document.getElementById('bars');
      const statusEl = document.getElementById('status');
      const liveEl = document.getElementById('live');

      const playBtn = document.getElementById('playPause');
      const stepBtn = document.getElementById('step');
      const resetBtn = document.getElementById('reset');
      const randomizeBtn = document.getElementById('randomize');
      const applyBtn = document.getElementById('apply');

      const numbersInput = document.getElementById('numbers');
      const countInput = document.getElementById('count');
      const speedInput = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');

      const pseudoEl = document.getElementById('pseudo');

      let arr = [];
      let initialArr = [];
      let i = 0; // pass
      let j = 0; // index in pass
      let swappedInPass = false;
      let playing = false;
      let done = false;
      let busy = false;
      let reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let speedScale = parseFloat(speedInput.value); // 0.25..2

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function announce(msg) {
        liveEl.textContent = msg;
        statusEl.textContent = msg;
      }

      function setSpeed(scale) {
        speedScale = scale;
        speedLabel.textContent = scale.toFixed(2).replace(/\.00$/, '') + '×';
        const swap = Math.max(80, 260 / scale);
        const compare = Math.max(60, 420 / scale);
        const highlight = Math.max(40, 220 / scale);
        document.documentElement.style.setProperty('--swap-ms', swap + 'ms');
        document.documentElement.style.setProperty('--compare-ms', compare + 'ms');
        document.documentElement.style.setProperty('--highlight-ms', highlight + 'ms');
      }

      function clearPseudoActive() {
        pseudoEl.querySelectorAll('.line').forEach(el => el.classList.remove('active'));
      }
      function markPseudo(line) {
        clearPseudoActive();
        const el = pseudoEl.querySelector(`.line[data-line="${line}"]`);
        if (el) el.classList.add('active');
      }

      function buildBars(data) {
        barsEl.innerHTML = '';
        const maxVal = Math.max(...data, 1);
        data.forEach((v, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role', 'img');
          bar.setAttribute('aria-label', `Index ${idx}, value ${v}`);
          const heightPct = Math.max(6, (v / maxVal) * 100);
          bar.style.height = heightPct + '%';

          const label = document.createElement('div');
          label.className = 'value';
          label.textContent = v;
          bar.appendChild(label);

          barsEl.appendChild(bar);
        });
      }

      function resetState(keepArray = true) {
        i = 0;
        j = 0;
        swappedInPass = false;
        done = false;
        busy = false;
        playing = false;
        playBtn.textContent = '▶ Play';
        playBtn.setAttribute('aria-pressed', 'false');
        barsEl.querySelectorAll('.bar').forEach(b => {
          b.classList.remove('sorted', 'comparing', 'to-swap', 'swapping');
          b.style.transform = '';
        });
        clearPseudoActive();
        announce('Ready. Press Play or Step to begin.');
        if (!keepArray) {
          arr = initialArr.slice();
          buildBars(arr);
        } else {
          // Remove sorted coloring if any
          barsEl.querySelectorAll('.bar').forEach(b => b.classList.remove('sorted'));
        }
      }

      function randomize() {
        const count = clamp(parseInt(countInput.value) || 8, 3, 12);
        countInput.value = count;
        const data = Array.from({ length: count }, () => randInt(1, 99));
        arr = data.slice();
        initialArr = data.slice();
        buildBars(arr);
        resetState(true);
        announce(`Randomized ${count} values.`);
      }

      function applyCustom() {
        const raw = numbersInput.value.trim();
        if (!raw) {
          announce('Please enter numbers separated by commas, or use Randomize.');
          return;
        }
        const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
        if (parts.length < 2 || parts.length > 12) {
          announce('Please enter between 2 and 12 values.');
          return;
        }
        const nums = [];
        for (const p of parts) {
          if (!/^-?\d+$/.test(p)) {
            announce('Only integer values allowed (0–99).');
            return;
          }
          const v = parseInt(p, 10);
          if (v < 0 || v > 99) {
            announce('Values must be between 0 and 99.');
            return;
          }
          nums.push(v);
        }
        arr = nums.slice();
        initialArr = nums.slice();
        buildBars(arr);
        resetState(true);
        countInput.value = nums.length;
        announce(`Loaded ${nums.length} custom values.`);
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function getBars() {
        return Array.from(barsEl.children);
      }

      function markSortedBoundary() {
        // Last element of current unsorted range becomes sorted (at the right)
        const bars = getBars();
        const idx = bars.length - 1 - (i - 1); // after incrementing i
        for (let k = idx; k < bars.length; k++) {
          bars[k]?.classList.add('sorted');
        }
      }

      function setCompareState(aIdx, bIdx, swap) {
        const bars = getBars();
        bars.forEach(b => b.classList.remove('comparing', 'to-swap'));
        const A = bars[aIdx];
        const B = bars[bIdx];
        if (!A || !B) return;
        A.classList.add('comparing');
        B.classList.add('comparing');
        if (swap) {
          A.classList.add('to-swap');
          B.classList.add('to-swap');
        }
      }

      function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
      }

      async function animateSwap(indexA, indexB) {
        const bars = getBars();
        const A = bars[indexA];
        const B = bars[indexB];
        if (!A || !B) return;

        if (reduceMotion) {
          // Swap DOM immediately
          if (A.nextSibling === B) {
            barsEl.insertBefore(B, A);
          } else {
            barsEl.insertBefore(A, B);
          }
          return;
        }

        const rectA = A.getBoundingClientRect();
        const rectB = B.getBoundingClientRect();
        const dxA = rectB.left - rectA.left;
        const dxB = rectA.left - rectB.left;

        A.classList.add('swapping');
        B.classList.add('swapping');
        A.style.transform = `translateX(${dxA}px)`;
        B.style.transform = `translateX(${dxB}px)`;

        await new Promise(resolve => {
          let doneCount = 0;
          const onEnd = () => {
            doneCount++;
            if (doneCount >= 2) {
              A.removeEventListener('transitionend', onEnd);
              B.removeEventListener('transitionend', onEnd);
              resolve();
            }
          };
          A.addEventListener('transitionend', onEnd);
          B.addEventListener('transitionend', onEnd);
        });

        // Swap DOM order
        if (A.nextSibling === B) {
          barsEl.insertBefore(B, A);
        } else if (B.nextSibling === A) {
          barsEl.insertBefore(A, B);
        }

        // Clean transforms after DOM swap so they snap into place
        requestAnimationFrame(() => {
          A.classList.remove('swapping');
          B.classList.remove('swapping');
          A.style.transform = '';
          B.style.transform = '';
        });
      }

      function highlightCompare(lineDelay = true) {
        markPseudo(3);
        return sleep(lineDelay ? parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--compare-ms')) : 0);
      }

      async function doOneStep() {
        if (busy || done) return;
        busy = true;

        const n = getBars().length;
        if (i >= n - 1) {
          done = true;
          getBars().forEach(b => b.classList.add('sorted'));
          markPseudo(7);
          announce('Done. Array is sorted.');
          busy = false;
          return;
        }

        // New pass initialization
        if (j === 0) {
          markPseudo(1);
          await sleep(30);
          markPseudo(2);
          swappedInPass = false;
        }

        if (j >= n - 1 - i) {
          // End of pass
          i++;
          j = 0;
          markSortedBoundary();
          if (!swappedInPass) {
            // Already sorted early exit
            done = true;
            getBars().forEach(b => b.classList.add('sorted'));
            markPseudo(7);
            announce('No swaps in last pass. Early exit: sorted.');
            busy = false;
            return;
          } else {
            markPseudo(1);
            busy = false;
            return; // Next step begins a new pass
          }
        }

        // Compare j and j+1
        markPseudo(3);
        const bars = getBars();
        const A = bars[j];
        const B = bars[j + 1];

        // Read numerical values from labels for accuracy with DOM
        const aVal = parseInt(A.querySelector('.value').textContent, 10);
        const bVal = parseInt(B.querySelector('.value').textContent, 10);

        setCompareState(j, j + 1, false);
        announce(`Comparing index ${j} (${aVal}) and ${j + 1} (${bVal}).`);
        await highlightCompare();

        // Branch: swap if needed
        markPseudo(4);
        const mustSwap = aVal > bVal;
        setCompareState(j, j + 1, mustSwap);

        if (mustSwap) {
          markPseudo(5);
          announce(`Swapping ${aVal} and ${bVal}.`);
          await animateSwap(j, j + 1);
          swappedInPass = true;
          markPseudo(6);
          // After swap, the element previously at j is now at j+1; for bubble sort we continue at next j
        } else {
          announce(`No swap needed for ${aVal} and ${bVal}.`);
        }

        // Clear compare markers (but not sorted)
        getBars().forEach(b => b.classList.remove('comparing', 'to-swap'));

        j++;
        busy = false;

        // If we're at end after increment, mark boundary in next step
        if (i >= n - 1) {
          done = true;
          getBars().forEach(b => b.classList.add('sorted'));
          markPseudo(7);
          announce('Done. Array is sorted.');
        }
      }

      async function run() {
        if (playing) return;
        playing = true;
        playBtn.textContent = '⏸ Pause';
        playBtn.setAttribute('aria-pressed', 'true');

        while (playing && !done) {
          await doOneStep();
          if (!playing || done) break;
          // Small pacing delay between steps
          const wait = Math.max(50, 260 / speedScale);
          await sleep(wait);
        }

        playing = false;
        playBtn.textContent = '▶ Play';
        playBtn.setAttribute('aria-pressed', 'false');
      }

      // Event wiring
      playBtn.addEventListener('click', async () => {
        if (done) {
          resetState(true);
        }
        if (playing) {
          playing = false;
          playBtn.textContent = '▶ Play';
          playBtn.setAttribute('aria-pressed', 'false');
          announce('Paused.');
        } else {
          run();
          announce('Playing.');
        }
      });

      stepBtn.addEventListener('click', async () => {
        if (playing) return; // prevent concurrent
        await doOneStep();
      });

      resetBtn.addEventListener('click', () => {
        resetState(true);
      });

      randomizeBtn.addEventListener('click', () => {
        randomize();
      });

      applyBtn.addEventListener('click', () => {
        applyCustom();
      });

      numbersInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          applyCustom();
        }
      });

      speedInput.addEventListener('input', () => {
        const val = parseFloat(speedInput.value);
        setSpeed(val);
      });

      document.addEventListener('keydown', (e) => {
        // Don't trigger shortcuts while typing in an input
        const tag = document.activeElement?.tagName?.toLowerCase();
        const typing = tag === 'input' || tag === 'textarea';
        if (typing) return;

        if (e.code === 'Space') {
          e.preventDefault();
          playBtn.click();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'r') {
          e.preventDefault();
          resetBtn.click();
        } else if (e.key.toLowerCase() === 's') {
          e.preventDefault();
          randomizeBtn.click();
        }
      });

      // Initialize
      setSpeed(speedScale);
      // Start with a random dataset
      randomize();
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Bubble Sort — Hands-on Interactive Explorer",
  "description": "Finite state machine capturing user controls, algorithm execution phases, visual/animation states, and completion for the bubble sort interactive web app.",
  "states": [
    {
      "name": "initializing",
      "onEnter": "init_app",
      "on": {
        "INIT_COMPLETE": "ready"
      }
    },
    {
      "name": "ready",
      "onEnter": "show_ready_status",
      "onExit": "clear_transient_ui",
      "on": {
        "TOGGLE_PLAY": "playing",
        "STEP": "pass_initializing",
        "RANDOMIZE": "dataset_randomizing",
        "APPLY_CUSTOM_VALID": "dataset_applying",
        "APPLY_CUSTOM_INVALID": "ready",
        "RESET": "resetting",
        "KEY_SPACE": "playing",
        "KEY_ARROW_RIGHT": "pass_initializing",
        "KEY_R": "resetting",
        "KEY_S": "dataset_randomizing",
        "SPEED_CHANGE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "start_autoplay",
      "onExit": "stop_autoplay",
      "on": {
        "AUTOPLAY_TICK": "pass_initializing",
        "TOGGLE_PLAY": "paused",
        "ALGORITHM_DONE": "done",
        "RESET": "resetting",
        "RANDOMIZE": "dataset_randomizing",
        "APPLY_CUSTOM_VALID": "dataset_applying",
        "KEY_SPACE": "paused",
        "KEY_R": "resetting",
        "KEY_S": "dataset_randomizing",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "paused",
      "onEnter": "announce_paused",
      "on": {
        "TOGGLE_PLAY": "playing",
        "STEP": "pass_initializing",
        "RESET": "resetting",
        "RANDOMIZE": "dataset_randomizing",
        "APPLY_CUSTOM_VALID": "dataset_applying",
        "APPLY_CUSTOM_INVALID": "paused",
        "KEY_SPACE": "playing",
        "KEY_ARROW_RIGHT": "pass_initializing",
        "KEY_R": "resetting",
        "KEY_S": "dataset_randomizing",
        "SPEED_CHANGE": "paused"
      }
    },
    {
      "name": "pass_initializing",
      "onEnter": "initialize_pass_if_needed",
      "on": {
        "ALGORITHM_DONE": "done",
        "PASS_INIT_DONE": "comparing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlight_compare",
      "onExit": "compare_phase_complete",
      "on": {
        "HIGHLIGHT_TIMEOUT": "checking_swap"
      }
    },
    {
      "name": "checking_swap",
      "onEnter": "check_swap_condition",
      "on": {
        "SWAP_DECISION_SWAP": "swapping",
        "SWAP_DECISION_NO_SWAP": "no_swap"
      }
    },
    {
      "name": "swapping",
      "onEnter": "perform_swap_animation",
      "onExit": "clear_swap_transform",
      "on": {
        "SWAP_ANIMATION_END": "step_cleanup"
      }
    },
    {
      "name": "no_swap",
      "onEnter": "announce_no_swap",
      "on": {
        "STEP_ADVANCE": "step_cleanup"
      }
    },
    {
      "name": "step_cleanup",
      "onEnter": "clear_compare_and_advance_index",
      "on": {
        "END_OF_PASS_NO_SWAPS": "done",
        "END_OF_PASS_WITH_SWAPS": "pass_completed",
        "CONTINUE": "ready",
        "ALGORITHM_DONE": "done"
      }
    },
    {
      "name": "pass_completed",
      "onEnter": "mark_sorted_boundary",
      "on": {
        "PASS_EARLY_EXIT": "done",
        "PASS_NEXT": "ready"
      }
    },
    {
      "name": "done",
      "onEnter": "finalize_done_state",
      "on": {
        "RESET": "resetting",
        "TOGGLE_PLAY": "resetting",
        "RANDOMIZE": "dataset_randomizing",
        "APPLY_CUSTOM_VALID": "dataset_applying",
        "APPLY_CUSTOM_INVALID": "done",
        "KEY_SPACE": "resetting",
        "KEY_R": "resetting",
        "KEY_S": "dataset_randomizing",
        "SPEED_CHANGE": "done"
      }
    },
    {
      "name": "dataset_randomizing",
      "onEnter": "randomize_dataset",
      "on": {
        "RANDOMIZE_COMPLETE": "ready"
      }
    },
    {
      "name": "dataset_applying",
      "onEnter": "apply_custom_dataset",
      "on": {
        "APPLY_COMPLETE": "ready",
        "APPLY_CUSTOM_INVALID": "ready"
      }
    },
    {
      "name": "resetting",
      "onEnter": "reset_to_ready",
      "on": {
        "RESET_COMPLETE": "ready"
      }
    }
  ],
  "events": [
    "INIT",
    "INIT_COMPLETE",
    "TOGGLE_PLAY",
    "PAUSE",
    "STEP",
    "AUTOPLAY_TICK",
    "HIGHLIGHT_TIMEOUT",
    "SWAP_DECISION_SWAP",
    "SWAP_DECISION_NO_SWAP",
    "SWAP_ANIMATION_END",
    "STEP_ADVANCE",
    "END_OF_PASS_WITH_SWAPS",
    "END_OF_PASS_NO_SWAPS",
    "PASS_INIT_DONE",
    "PASS_EARLY_EXIT",
    "PASS_NEXT",
    "ALGORITHM_DONE",
    "RESET",
    "RESET_COMPLETE",
    "RANDOMIZE",
    "RANDOMIZE_COMPLETE",
    "APPLY_CUSTOM_VALID",
    "APPLY_CUSTOM_INVALID",
    "APPLY_COMPLETE",
    "SPEED_CHANGE",
    "KEY_SPACE",
    "KEY_ARROW_RIGHT",
    "KEY_R",
    "KEY_S",
    "ENTER_KEY_ON_NUMBERS"
  ],
  "notes": "Mapping to code and UI:\n- init_app: setSpeed(...) then randomize() on load; INIT_COMPLETE transitions to ready.\n- show_ready_status: resetState(true) behavior (i=0, j=0, swappedInPass=false, playing=false, done=false, busy=false; clear bar classes; clear pseudo highlight; update Play button; announce 'Ready. Press Play or Step to begin.').\n- start_autoplay/stop_autoplay: run() enters a loop calling doOneStep(), updates Play/Pause button text and aria-pressed; stop_autoplay restores Play state.\n- initialize_pass_if_needed: only when j==0 of the current pass — markPseudo(1), small delay, markPseudo(2), swappedInPass=false; otherwise this is a quick no-op leading to comparing.\n- highlight_compare: markPseudo(3), setCompareState(j, j+1, false), announce current pair, wait compare-ms (HIGHLIGHT_TIMEOUT).\n- check_swap_condition: markPseudo(4), compute mustSwap (aVal > bVal), setCompareState(j, j+1, mustSwap). If true emit SWAP_DECISION_SWAP → swapping; else SWAP_DECISION_NO_SWAP → no_swap.\n- perform_swap_animation: markPseudo(5), announce swap, animateSwap(j, j+1). On animation end (transitionend) emit SWAP_ANIMATION_END. During animation, bars get class 'swapping' and transforms; clear_swap_transform removes those and resets transforms.\n- announce_no_swap: speak and status message 'No swap needed...'.\n- clear_compare_and_advance_index: remove 'comparing'/'to-swap' classes, increment j. Then branch: if j >= n-1-i, emit END_OF_PASS_*; if i >= n-1 after updates, emit ALGORITHM_DONE.\n- mark_sorted_boundary: color right-side bars with 'sorted' after i++/j=0. If swappedInPass is false, emit PASS_EARLY_EXIT → done (early exit); else emit PASS_NEXT → ready (next pass will start on next STEP/AUTOPLAY_TICK).\n- finalize_done_state: add 'sorted' to all bars, markPseudo(7), announce 'Done. Array is sorted.', ensure playing=false. In playing loop, ALGORITHM_DONE stops autoplay.\n- randomize_dataset: generate count values (3–12), buildBars(...), resetState(true), announce randomized.\n- apply_custom_dataset: validate text input (2–12 integers, 0–99), buildBars, resetState(true), update count input, announce loaded; on invalid input emit APPLY_CUSTOM_INVALID and remain in current non-playing state.\n- reset_to_ready: resetState(true) (preserve array, clear visuals), announce ready; then RESET_COMPLETE → ready.\n- Keyboard shortcuts: Space triggers TOGGLE_PLAY; ArrowRight triggers STEP; 'R' triggers RESET; 'S' triggers RANDOMIZE; Enter in numbers input triggers APPLY_CUSTOM_VALID/APPLY_CUSTOM_INVALID depending on validation (ENTER_KEY_ON_NUMBERS is a UI-level trigger mapped to apply logic).\n- Visual state classes: comparing → bars get 'comparing'; mustSwap → add 'to-swap'; swapping → add 'swapping' and transforms until SWAP_ANIMATION_END; sorted boundary grows via 'sorted' classes at right side; all bars 'sorted' when done.\n- Pseudocode panel highlights: lines 1,2 at pass init; line 3 during compare; line 4 for condition; line 5 during swap; line 6 to mark swapped flag; line 7 when done/early exit.\n- Speed changes: SPEED_CHANGE updates CSS variables for --swap-ms, --compare-ms, --highlight-ms via setSpeed(scale) and does not change state; applies in any state.\n- Concurrency guard: busy prevents concurrent doOneStep. When playing, autotick waits between steps. If prefers-reduced-motion is set, animateSwap bypasses transitions and reorders DOM immediately.\n- Play button while done: TOGGLE_PLAY first calls resetState(true) then starts run(), effectively transitioning done → resetting → ready → playing."
}
  </script>
</body>
</html>