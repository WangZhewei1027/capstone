<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort: Adjacent Comparisons and Swaps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --text: #1f2937;
      --muted: #4b5563;
      --border: #e5e7eb;
      --primary: #2563eb;
      --primary-contrast: #ffffff;
      --accent: #f59e0b;  /* comparing */
      --danger: #d0021b;  /* swapping */
      --success: #2da44e; /* sorted */
      --focus: #22c55e;
      --gap: 16px;
      --safe: 24px;

      --bar-default: #5b8def;
      --bar-text: #0b1021;

      --compare-duration: 500ms;
      --swap-duration: 600ms;
      --pass-delay: 400ms;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      padding: 0;
    }

    main {
      padding: var(--safe);
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 12px 0;
      font-size: 28px;
      line-height: 1.2;
    }

    .subtitle {
      color: var(--muted);
      margin-bottom: 24px;
    }

    /* Info panel sections */
    .info {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
      margin-bottom: 24px;
    }

    details.info-block {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 16px;
      background: #fafafa;
    }

    details.info-block summary {
      font-weight: 600;
      cursor: pointer;
      outline: none;
    }

    .info-content p, .info-content ul {
      margin: 8px 0;
    }

    .info-content ul {
      padding-left: 18px;
    }

    /* Layout */
    .module {
      display: grid;
      grid-template-columns: minmax(280px, 340px) 1fr;
      gap: 24px;
    }

    @media (max-width: 900px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    /* Controls panel */
    .panel {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      background: #fff;
    }

    .panel h2 {
      font-size: 18px;
      margin: 0 0 12px 0;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    label {
      display: block;
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    input[type="range"] {
      width: 100%;
    }

    input[type="text"], input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
    }

    input[type="text"]:focus, input[type="number"]:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
    }

    button {
      padding: 10px 14px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      min-height: 44px;
      min-width: 44px;
    }

    button.primary {
      background: var(--primary);
      color: var(--primary-contrast);
      border-color: var(--primary);
    }

    button:focus-visible {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }

    /* Visualization panel */
    .viz {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      background: #fff;
    }

    .viz-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      margin-bottom: 12px;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid var(--border);
    }
    .swatch-default { background: var(--bar-default); }
    .swatch-compare { background: var(--accent); }
    .swatch-swap { background: var(--danger); }
    .swatch-sorted { background: var(--success); }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 14px;
      color: var(--muted);
    }
    .stat {
      padding: 6px 8px;
      border-radius: 8px;
      background: #f7f7f7;
      border: 1px solid var(--border);
    }

    .bar-container {
      position: relative;
      width: 100%;
      height: 300px;
      border: 1px dashed var(--border);
      border-radius: 10px;
      overflow: hidden;
      background-image: linear-gradient(to bottom, rgba(0,0,0,0.03), rgba(0,0,0,0.01));
      margin-bottom: 12px;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: var(--bar-width, 48px);
      background: var(--bar-default);
      border-radius: 8px 8px 0 0;
      color: var(--bar-text);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      transform: translateX(0);
      transition:
        transform var(--swap-duration) ease-in-out,
        box-shadow var(--compare-duration) ease-in-out,
        background-color 200ms ease-in-out;
      user-select: none;
      outline: none;
    }

    .bar:focus-visible {
      box-shadow: 0 0 0 3px var(--focus);
    }

    .bar-label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: #0b1021;
      text-shadow: 0 1px 0 rgba(255,255,255,0.6);
    }

    .bar.comparing {
      background: var(--accent);
      box-shadow: 0 6px 16px rgba(245, 158, 11, 0.35);
    }

    .bar.swapping {
      background: var(--danger);
      box-shadow: 0 6px 16px rgba(208, 2, 27, 0.35);
    }

    .bar.sorted {
      background: var(--success);
      box-shadow: none;
      opacity: 0.9;
    }

    /* Pseudocode block */
    .code {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0b1021;
      color: #e6edf3;
      padding: 12px 16px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 14px;
      line-height: 1.5;
    }

    .code .line {
      padding: 2px 6px;
      border-radius: 6px;
    }

    .code .line.hl {
      background: rgba(37, 99, 235, 0.25);
      outline: 1px solid rgba(37, 99, 235, 0.6);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      margin-top: 8px;
    }

    /* Accessibility helpers */
    .sr-only {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body>
  <main>
    <h1>Bubble Sort: Adjacent Comparisons and Swaps</h1>
    <p class="subtitle">Interactively explore how Bubble Sort repeatedly compares and swaps adjacent elements, “bubbling” larger values to the end each pass.</p>

    <!-- Module sections required by the design plan -->
    <section class="info" aria-label="Module overview">
      <details class="info-block" open>
        <summary>Concept Title</summary>
        <div class="info-content">
          <p>Bubble Sort: Neighbor comparisons with pass-by-pass settling of the largest elements.</p>
        </div>
      </details>
      <details class="info-block" open>
        <summary>Learning Objective</summary>
        <div class="info-content">
          <ul>
            <li>See how Bubble Sort compares adjacent items and swaps them if out of order.</li>
            <li>Observe that after each pass, the largest unsorted element settles at the end.</li>
            <li>Experience the early-exit optimization: stop if a pass makes no swaps.</li>
          </ul>
        </div>
      </details>
      <details class="info-block">
        <summary>Interaction Design</summary>
        <div class="info-content">
          <ul>
            <li>Click Play/Pause to animate the algorithm. Bars being compared highlight in orange; swaps highlight in red and animate positions. The sorted tail turns green after each pass.</li>
            <li>Step executes one algorithmic step at a time for fine-grained control.</li>
            <li>Drag bars left/right or edit values to set your own array before sorting.</li>
            <li>Adjust Array Size and Speed sliders; Randomize generates new data.</li>
            <li>Toggle Pseudocode to see line-by-line highlights that match each action.</li>
            <li>Visual counters track comparisons, swaps, and passes in real time.</li>
          </ul>
          <p>Keyboard shortcuts: Space = Play/Pause, Right Arrow = Step, R = Randomize, S = Reset.</p>
        </div>
      </details>
      <details class="info-block">
        <summary>Layout Description</summary>
        <div class="info-content">
          <ul>
            <li>Safe area margins of 24 px around the viewport are maintained.</li>
            <li>Controls sit in a left panel; the visualization sits to the right. On smaller screens, they stack vertically for readability.</li>
            <li>Minimum spacing of 16 px is enforced between interactive elements to prevent misclicks.</li>
            <li>Accessible labels, focus outlines, and ARIA live announcements support screen readers and keyboard-only users.</li>
          </ul>
        </div>
      </details>
    </section>

    <section class="module" aria-label="Interactive bubble sort module">
      <!-- Controls -->
      <div class="panel" aria-labelledby="controls-title">
        <h2 id="controls-title">Controls</h2>
        <div class="controls">
          <div>
            <label for="size">Array Size: <span id="sizeValue">8</span></label>
            <input id="size" type="range" min="5" max="14" value="8" aria-valuemin="5" aria-valuemax="14" aria-valuenow="8" aria-label="Array size slider" />
          </div>

          <div class="btn-row" role="group" aria-label="Primary controls">
            <button id="randomize" class="primary" aria-label="Randomize array">Randomize</button>
            <button id="step" aria-label="Step once">Step</button>
            <button id="play" aria-label="Play or pause animation">Play</button>
            <button id="reset" aria-label="Reset sorting state">Reset</button>
          </div>

          <div>
            <label for="speed">Speed: <span id="speedValue">1.0×</span></label>
            <input id="speed" type="range" min="0.25" max="3" step="0.25" value="1" aria-valuemin="0.25" aria-valuemax="3" aria-valuenow="1" aria-label="Animation speed slider" />
          </div>

          <div>
            <label for="editValues">Edit Values (comma-separated)</label>
            <input id="editValues" type="text" placeholder="e.g., 5, 1, 9, 3, 7" aria-label="Edit array values as comma-separated numbers" />
            <div id="editHint" class="sr-only" aria-live="polite"></div>
          </div>

          <div class="toggle-row">
            <label for="showCode" style="margin:0;">Show Pseudocode</label>
            <input id="showCode" type="checkbox" aria-label="Toggle pseudocode visibility" />
          </div>
        </div>
      </div>

      <!-- Visualization -->
      <div class="viz" aria-labelledby="viz-title">
        <div class="viz-header">
          <h2 id="viz-title">Visualization</h2>
          <div class="legend" aria-hidden="true">
            <div class="legend-item"><span class="legend-swatch swatch-default"></span>Default</div>
            <div class="legend-item"><span class="legend-swatch swatch-compare"></span>Comparing</div>
            <div class="legend-item"><span class="legend-swatch swatch-swap"></span>Swapping</div>
            <div class="legend-item"><span class="legend-swatch swatch-sorted"></span>Sorted tail</div>
          </div>
        </div>

        <div class="stats" aria-live="polite">
          <div class="stat">Pass: <span id="passCount">0</span></div>
          <div class="stat">Comparisons: <span id="cmpCount">0</span></div>
          <div class="stat">Swaps: <span id="swapCount">0</span></div>
          <div class="stat">Status: <span id="statusText">Ready</span></div>
        </div>

        <div class="bar-container" id="barContainer" aria-label="Array bar chart"></div>

        <div id="liveAnnounce" class="sr-only" aria-live="polite"></div>

        <div id="codeBlock" class="code" style="display:none;" aria-label="Bubble sort pseudocode">
          <div class="line" data-line="1">1. function bubbleSort(A):</div>
          <div class="line" data-line="2">2.   for i from 0 to n − 2:</div>
          <div class="line" data-line="3">3.     swapped = false</div>
          <div class="line" data-line="4">4.     for j from 0 to n − i − 2:</div>
          <div class="line" data-line="5">5.       if A[j] > A[j + 1]:</div>
          <div class="line" data-line="6">6.         swap A[j], A[j + 1]</div>
          <div class="line" data-line="7">7.         swapped = true</div>
          <div class="line" data-line="8">8.     if swapped == false:</div>
          <div class="line" data-line="9">9.       break</div>
        </div>

        <p class="subtitle" style="margin-top:12px;">Tip: Drag bars to reorder before sorting. Use Space, Right Arrow, R, S for quick controls.</p>
      </div>
    </section>
  </main>

  <script>
    // State
    const barContainer = document.getElementById('barContainer');
    const sizeInput = document.getElementById('size');
    const sizeValue = document.getElementById('sizeValue');
    const randomizeBtn = document.getElementById('randomize');
    const stepBtn = document.getElementById('step');
    const playBtn = document.getElementById('play');
    const resetBtn = document.getElementById('reset');
    const speedInput = document.getElementById('speed');
    const speedValue = document.getElementById('speedValue');
    const editValuesInput = document.getElementById('editValues');
    const editHint = document.getElementById('editHint');

    const passCountEl = document.getElementById('passCount');
    const cmpCountEl = document.getElementById('cmpCount');
    const swapCountEl = document.getElementById('swapCount');
    const statusText = document.getElementById('statusText');
    const liveAnnounce = document.getElementById('liveAnnounce');

    const codeBlock = document.getElementById('codeBlock');
    const showCodeToggle = document.getElementById('showCode');

    // Visual/logic arrays
    let values = [];  // current values per bar id
    let order = [];   // current visual order: index -> barId
    let bars = [];    // DOM elements, index by barId

    // Sorting state
    let generator = null;
    let isPlaying = false;
    let pendingTimeout = null;
    let comparisons = 0;
    let swaps = 0;
    let passes = 0;

    // Speed control
    let speedFactor = 1.0; // 0.25 .. 3

    function announce(msg) {
      liveAnnounce.textContent = msg;
    }

    function setStatus(msg) {
      statusText.textContent = msg;
    }

    function clearTimeoutSafe() {
      if (pendingTimeout !== null) {
        clearTimeout(pendingTimeout);
        pendingTimeout = null;
      }
    }

    function resetCounters() {
      comparisons = 0;
      swaps = 0;
      passes = 0;
      passCountEl.textContent = '0';
      cmpCountEl.textContent = '0';
      swapCountEl.textContent = '0';
    }

    function updateCounters() {
      passCountEl.textContent = String(passes);
      cmpCountEl.textContent = String(comparisons);
      swapCountEl.textContent = String(swaps);
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function computeBarWidth(count) {
      const containerWidth = barContainer.clientWidth || barContainer.offsetWidth;
      const spacing = 12; // gap between bars
      // estimate width to fit count bars + spacing
      const totalSpacing = spacing * (count + 1);
      let w = Math.floor((containerWidth - totalSpacing) / count);
      w = Math.max(28, Math.min(w, 60));
      return { width: w, gap: spacing };
    }

    function renderBars(newValues) {
      // Clear previous animation timeouts
      clearTimeoutSafe();
      isPlaying = false;
      playBtn.textContent = 'Play';
      setStatus('Ready');

      // Reset counters and classes
      resetCounters();
      clearCodeHL();

      values = newValues.slice(); // copy
      const n = values.length;
      order = Array.from({ length: n }, (_, i) => i);

      // Clear DOM
      barContainer.innerHTML = '';
      bars = [];

      // Dimensions
      const { width, gap } = computeBarWidth(n);
      barContainer.style.setProperty('--bar-width', width + 'px');

      // Determine max for height scaling
      const maxVal = Math.max(...values, 1);
      const containerHeight = barContainer.clientHeight || 300;

      // Create bars
      for (let id = 0; id < n; id++) {
        const val = values[id];
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.setAttribute('tabindex', '0');
        bar.setAttribute('role', 'button');
        bar.setAttribute('aria-label', `Value ${val}. Drag to reorder. Use arrow keys to move.`);
        bar.draggable = true;

        const h = Math.round((val / maxVal) * (containerHeight - 30)) + 30; // min height
        bar.style.height = h + 'px';

        const label = document.createElement('div');
        label.className = 'bar-label';
        label.textContent = String(val);

        bar.appendChild(label);
        barContainer.appendChild(bar);
        bars.push(bar);

        // Drag & drop events
        bar.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', String(order.indexOf(id)));
          bar.classList.add('comparing'); // subtle feedback
        });
        bar.addEventListener('dragend', () => {
          bar.classList.remove('comparing');
        });
        bar.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        bar.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
          const toIndex = order.indexOf(id);
          if (!Number.isNaN(fromIndex) && fromIndex !== toIndex) {
            swapOrder(fromIndex, toIndex);
            syncGeneratorReset();
          }
        });

        // Keyboard reordering
        bar.addEventListener('keydown', (e) => {
          const idx = order.indexOf(id);
          if (e.key === 'ArrowLeft' && idx > 0) {
            e.preventDefault();
            swapOrder(idx, idx - 1);
            syncGeneratorReset();
          } else if (e.key === 'ArrowRight' && idx < order.length - 1) {
            e.preventDefault();
            swapOrder(idx, idx + 1);
            syncGeneratorReset();
          }
        });
      }

      // Position bars
      updatePositions(gap);
      // Update edit input to mirror values in current order
      editValuesInput.value = order.map(i => values[i]).join(', ');
    }

    function updatePositions(gapOverride = null) {
      const n = order.length;
      const { width, gap } = computeBarWidth(n);
      const g = gapOverride === null ? gap : gapOverride;

      for (let i = 0; i < n; i++) {
        const id = order[i];
        const x = i * (width + g) + g;
        bars[id].style.transform = `translateX(${x}px)`;
      }
    }

    function swapOrder(idxA, idxB) {
      // Swap order positions and animate
      const tmp = order[idxA];
      order[idxA] = order[idxB];
      order[idxB] = tmp;
      updatePositions();
      // Keep input synced
      editValuesInput.value = order.map(i => values[i]).join(', ');
    }

    function highlightBars(indices, className) {
      indices.forEach(i => {
        const id = order[i];
        bars[id].classList.add(className);
      });
    }

    function clearBarHighlights(indices, className) {
      indices.forEach(i => {
        const id = order[i];
        bars[id].classList.remove(className);
      });
    }

    function markSortedTail(lastIndex) {
      for (let i = lastIndex; i < order.length; i++) {
        const id = order[i];
        bars[id].classList.add('sorted');
      }
    }

    function clearSorted() {
      bars.forEach(bar => bar.classList.remove('sorted'));
    }

    function highlightCode(line) {
      clearCodeHL();
      const el = codeBlock.querySelector(`.line[data-line="${line}"]`);
      if (el) el.classList.add('hl');
    }

    function clearCodeHL() {
      codeBlock.querySelectorAll('.line').forEach(l => l.classList.remove('hl'));
    }

    function* bubbleSortGeneratorFromOrder() {
      const n = order.length;
      // We operate on a copy of values array reflecting the current order
      const A = order.map(id => values[id]);
      // Pseudocode lines highlighted during steps
      highlightCode(2);

      for (let i = 0; i < n - 1; i++) {
        let swappedFlag = false;
        passes = i + 1;
        updateCounters();

        highlightCode(3);
        yield { type: 'passStart', pass: i };

        highlightCode(4);
        for (let j = 0; j < n - i - 1; j++) {
          // Compare step
          yield { type: 'compare', j, k: j + 1 };

          if (A[j] > A[j + 1]) {
            // Swap values in A (logical)
            const tmp = A[j];
            A[j] = A[j + 1];
            A[j + 1] = tmp;
            swappedFlag = true;

            // Visual swap step
            highlightCode(6);
            yield { type: 'swap', j, k: j + 1 };
          }
        }

        // After pass, mark sorted tail (last element fixed)
        yield { type: 'passDone', sortedFrom: n - i - 1 };

        // Early exit if no swaps this pass
        highlightCode(8);
        if (!swappedFlag) {
          yield { type: 'earlyStop', pass: i };
          break;
        }
        highlightCode(2); // next outer iteration
      }

      // Done
      yield { type: 'done' };
    }

    function syncGeneratorReset() {
      // Stop any ongoing play and reset generator/counters
      clearTimeoutSafe();
      isPlaying = false;
      playBtn.textContent = 'Play';
      setStatus('Ready');
      resetCounters();
      clearSorted();
      clearCodeHL();
      generator = null;
    }

    async function handleStepEvent(evt) {
      switch (evt.type) {
        case 'passStart': {
          updateCounters();
          setStatus(`Pass ${passes} starting`);
          announce(`Pass ${passes} started`);
          highlightCode(4);
          await delayScaled('pass');
          break;
        }
        case 'compare': {
          comparisons++;
          updateCounters();
          setStatus(`Comparing positions ${evt.j} and ${evt.k}`);
          announce(`Comparing positions ${evt.j} and ${evt.k}`);
          highlightBars([evt.j, evt.k], 'comparing');
          highlightCode(5);
          await delayScaled('compare');
          clearBarHighlights([evt.j, evt.k], 'comparing');
          break;
        }
        case 'swap': {
          swaps++;
          updateCounters();
          setStatus(`Swapping positions ${evt.j} and ${evt.k}`);
          announce(`Swapped positions ${evt.j} and ${evt.k}`);
          highlightBars([evt.j, evt.k], 'swapping');
          // Perform visual swap by swapping order indices
          const idxA = evt.j;
          const idxB = evt.k;
          const tmp = order[idxA];
          order[idxA] = order[idxB];
          order[idxB] = tmp;
          updatePositions();
          await delayScaled('swap');
          clearBarHighlights([evt.j, evt.k], 'swapping');
          break;
        }
        case 'passDone': {
          setStatus(`Pass ${passes} done`);
          // Mark sorted tail starting at sortedFrom index
          markSortedTail(evt.sortedFrom);
          announce(`End of pass ${passes}. Element at index ${evt.sortedFrom} is in final position.`);
          await delayScaled('pass');
          break;
        }
        case 'earlyStop': {
          setStatus('Early stop: array is sorted');
          announce('Early stop. No swaps in last pass; array is sorted.');
          // Mark all as sorted
          markSortedTail(0);
          await delayScaled('pass');
          break;
        }
        case 'done': {
          setStatus('Done');
          announce('Sorting complete.');
          markSortedTail(0);
          isPlaying = false;
          playBtn.textContent = 'Play';
          break;
        }
      }
    }

    function delayScaled(type) {
      let base = 400;
      if (type === 'compare') base = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--compare-duration')) || 500;
      if (type === 'swap') base = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--swap-duration')) || 600;
      if (type === 'pass') base = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pass-delay')) || 400;
      const ms = Math.max(120, Math.round(base * (1 / speedFactor)));
      return new Promise(resolve => {
        pendingTimeout = setTimeout(() => {
          pendingTimeout = null;
          resolve();
        }, ms);
      });
    }

    async function stepOnce() {
      // Initialize generator if needed
      if (!generator) {
        generator = bubbleSortGeneratorFromOrder();
      }
      const { value: evt, done } = generator.next();
      if (done || !evt) {
        // Mark done
        await handleStepEvent({ type: 'done' });
        return;
      }
      await handleStepEvent(evt);
    }

    async function playLoop() {
      if (isPlaying) return;
      isPlaying = true;
      playBtn.textContent = 'Pause';
      setStatus('Playing');

      // Initialize generator if needed
      if (!generator) {
        generator = bubbleSortGeneratorFromOrder();
      }

      const run = async () => {
        if (!isPlaying) return;
        const { value: evt, done } = generator.next();
        if (done || !evt) {
          await handleStepEvent({ type: 'done' });
          return;
        }
        await handleStepEvent(evt);
        if (isPlaying) {
          pendingTimeout = setTimeout(run, 0);
        }
      };

      run();
    }

    function pausePlay() {
      isPlaying = false;
      clearTimeoutSafe();
      playBtn.textContent = 'Play';
      setStatus('Paused');
    }

    function resetSorting() {
      pausePlay();
      clearSorted();
      resetCounters();
      generator = null;
      setStatus('Ready');
      announce('Reset.');
      clearCodeHL();
    }

    function randomArray(n) {
      const arr = Array.from({ length: n }, () => randInt(10, 99));
      return arr;
    }

    function parseValuesInput(text) {
      const parts = text.split(',').map(s => s.trim()).filter(s => s.length > 0);
      const nums = parts.map(n => parseInt(n, 10)).filter(x => Number.isFinite(x));
      return nums;
    }

    function applyValuesFromInput() {
      const nums = parseValuesInput(editValuesInput.value);
      if (nums.length < 5 || nums.length > 14) {
        editHint.textContent = 'Enter 5 to 14 numbers.';
        return;
      }
      sizeInput.value = String(nums.length);
      sizeValue.textContent = String(nums.length);
      // Update speed ARIA
      sizeInput.setAttribute('aria-valuenow', String(nums.length));
      renderBars(nums);
      syncGeneratorReset();
      setStatus('Values updated');
      announce('Values updated from text input.');
    }

    // Events
    sizeInput.addEventListener('input', () => {
      const n = parseInt(sizeInput.value, 10);
      sizeValue.textContent = String(n);
      sizeInput.setAttribute('aria-valuenow', String(n));
      renderBars(randomArray(n));
      syncGeneratorReset();
    });

    randomizeBtn.addEventListener('click', () => {
      const n = parseInt(sizeInput.value, 10);
      renderBars(randomArray(n));
      syncGeneratorReset();
      setStatus('Randomized');
      announce('Array randomized.');
    });

    stepBtn.addEventListener('click', () => {
      stepOnce();
    });

    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        pausePlay();
      } else {
        playLoop();
      }
    });

    resetBtn.addEventListener('click', () => {
      resetSorting();
    });

    speedInput.addEventListener('input', () => {
      speedFactor = parseFloat(speedInput.value);
      speedValue.textContent = speedFactor.toFixed(2).replace(/\.00$/, '') + '×';
      speedInput.setAttribute('aria-valuenow', String(speedFactor));
    });

    editValuesInput.addEventListener('change', applyValuesFromInput);

    showCodeToggle.addEventListener('change', () => {
      codeBlock.style.display = showCodeToggle.checked ? 'block' : 'none';
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (isPlaying) pausePlay(); else playLoop();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        stepOnce();
      } else if (e.key.toLowerCase() === 'r') {
        const n = parseInt(sizeInput.value, 10);
        renderBars(randomArray(n));
        syncGeneratorReset();
      } else if (e.key.toLowerCase() === 's') {
        resetSorting();
      }
    });

    // Initial render
    window.addEventListener('resize', () => {
      // Recompute positions on resize for responsiveness
      updatePositions();
    });

    (function init() {
      speedFactor = parseFloat(speedInput.value);
      const n = parseInt(sizeInput.value, 10);
      renderBars(randomArray(n));
      setStatus('Ready');
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite state machine for a bubble sort visualization with play/pause/step controls, drag-and-drop/keyboard reordering, counters, and visual feedback (comparing, swapping, sorted tail).",
  "states": [
    {
      "name": "initializing",
      "onEnter": "initRender",
      "on": {
        "RENDER_COMPLETE": "ready"
      }
    },
    {
      "name": "ready",
      "onEnter": "setReadyUI",
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "RESET": "ready",
        "RANDOMIZE": "rendering",
        "SIZE_CHANGE": "rendering",
        "EDIT_VALUES_APPLY": "rendering",
        "EDIT_VALUES_INVALID": "ready",
        "SPEED_CHANGE": "ready",
        "TOGGLE_CODE": "ready",
        "RESIZE": "ready",
        "DRAG_START": "dragging",
        "KEY_LEFT_MOVE": "ready",
        "KEY_RIGHT_MOVE": "ready"
      }
    },
    {
      "name": "rendering",
      "onEnter": "renderBarsUpdate",
      "on": {
        "RENDER_COMPLETE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "playLoopStart",
      "onExit": "clearTimeoutSafe",
      "on": {
        "PAUSE": "paused",
        "RESET": "ready",
        "RANDOMIZE": "rendering",
        "SIZE_CHANGE": "rendering",
        "EDIT_VALUES_APPLY": "rendering",
        "DRAG_START": "dragging",
        "NEXT_EVENT_PASS_START": "pass_starting",
        "NEXT_EVENT_COMPARE": "comparing",
        "NEXT_EVENT_SWAP": "swapping",
        "NEXT_EVENT_PASS_DONE": "pass_done",
        "NEXT_EVENT_EARLY_STOP": "early_stop",
        "NEXT_EVENT_DONE": "done"
      }
    },
    {
      "name": "paused",
      "onEnter": "pausePlay",
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "RESET": "ready",
        "RANDOMIZE": "rendering",
        "SIZE_CHANGE": "rendering",
        "EDIT_VALUES_APPLY": "rendering",
        "DRAG_START": "dragging",
        "SPEED_CHANGE": "paused",
        "TOGGLE_CODE": "paused"
      }
    },
    {
      "name": "stepping",
      "onEnter": "stepOnceExec",
      "on": {
        "NEXT_EVENT_PASS_START": "pass_starting",
        "NEXT_EVENT_COMPARE": "comparing",
        "NEXT_EVENT_SWAP": "swapping",
        "NEXT_EVENT_PASS_DONE": "pass_done",
        "NEXT_EVENT_EARLY_STOP": "early_stop",
        "NEXT_EVENT_DONE": "done",
        "RESET": "ready",
        "RANDOMIZE": "rendering",
        "SIZE_CHANGE": "rendering",
        "EDIT_VALUES_APPLY": "rendering"
      }
    },
    {
      "name": "pass_starting",
      "onEnter": "handlePassStart",
      "on": {
        "DELAY_COMPLETE_PLAYING": "playing",
        "DELAY_COMPLETE_STEPPING": "ready"
      }
    },
    {
      "name": "comparing",
      "onEnter": "handleCompare",
      "onExit": "clearCompareHighlight",
      "on": {
        "DELAY_COMPLETE_PLAYING": "playing",
        "DELAY_COMPLETE_STEPPING": "ready"
      }
    },
    {
      "name": "swapping",
      "onEnter": "handleSwap",
      "onExit": "clearSwapHighlight",
      "on": {
        "DELAY_COMPLETE_PLAYING": "playing",
        "DELAY_COMPLETE_STEPPING": "ready"
      }
    },
    {
      "name": "pass_done",
      "onEnter": "handlePassDone",
      "on": {
        "DELAY_COMPLETE_PLAYING": "playing",
        "DELAY_COMPLETE_STEPPING": "ready"
      }
    },
    {
      "name": "early_stop",
      "onEnter": "handleEarlyStop",
      "on": {
        "DELAY_COMPLETE_PLAYING": "playing",
        "DELAY_COMPLETE_STEPPING": "ready"
      }
    },
    {
      "name": "done",
      "onEnter": "handleDone",
      "on": {
        "PLAY": "playing",
        "RESET": "ready",
        "RANDOMIZE": "rendering",
        "SIZE_CHANGE": "rendering",
        "EDIT_VALUES_APPLY": "rendering"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDragFeedback",
      "onExit": "endDragFeedback",
      "on": {
        "DRAG_DROP": "ready",
        "DRAG_END": "ready",
        "RESET": "ready"
      }
    }
  ],
  "events": [
    "INIT",
    "RENDER_COMPLETE",
    "PLAY",
    "PAUSE",
    "STEP",
    "RESET",
    "RANDOMIZE",
    "SIZE_CHANGE",
    "EDIT_VALUES_APPLY",
    "EDIT_VALUES_INVALID",
    "SPEED_CHANGE",
    "TOGGLE_CODE",
    "RESIZE",
    "DRAG_START",
    "DRAG_END",
    "DRAG_DROP",
    "KEY_LEFT_MOVE",
    "KEY_RIGHT_MOVE",
    "NEXT_EVENT_PASS_START",
    "NEXT_EVENT_COMPARE",
    "NEXT_EVENT_SWAP",
    "NEXT_EVENT_PASS_DONE",
    "NEXT_EVENT_EARLY_STOP",
    "NEXT_EVENT_DONE",
    "DELAY_COMPLETE_PLAYING",
    "DELAY_COMPLETE_STEPPING"
  ],
  "notes": "Mapping to implementation: initRender = initial render of random array (IIFE init() calling renderBars(randomArray(n)) and setStatus('Ready')). setReadyUI sets Ready status and Play button text; renderBarsUpdate encapsulates renderBars(...) and syncGeneratorReset() side-effects (isPlaying=false, clear timeouts, reset counters, clear highlights, update positions/input). playLoopStart = playLoop() (sets isPlaying=true, schedules generator run and sets 'Playing' status). pausePlay = pausePlay() (sets isPlaying=false, clears timeouts, sets 'Paused'). stepOnceExec = stepOnce() (initializes generator if needed, advances one event and calls handleStepEvent). handlePassStart, handleCompare, handleSwap, handlePassDone, handleEarlyStop, handleDone mirror handleStepEvent branching: they update counters/status/ARIA announcements, highlight pseudocode lines, add/remove CSS classes, perform visual swaps and mark the sorted tail, and await delayScaled('pass'/'compare'/'swap'). clearCompareHighlight / clearSwapHighlight remove 'comparing'/'swapping' classes from the involved bars. startDragFeedback / endDragFeedback refer to dragstart/dragend bar class toggling ('comparing' added/removed); DRAG_DROP swaps order indices and triggers syncGeneratorReset() via drop event; KEY_LEFT_MOVE / KEY_RIGHT_MOVE reorder bars via swapOrder(...) and syncGeneratorReset(). NEXT_EVENT_* events correspond to bubbleSortGeneratorFromOrder() yields: passStart, compare, swap, passDone, earlyStop, done. DELAY_COMPLETE_* separates where to return after each visual delay: when in playing mode, return to 'playing' loop; when stepping, return to 'ready'. RANDOMIZE, SIZE_CHANGE, EDIT_VALUES_APPLY route to 'rendering' which returns to 'ready' after render completes; RESET calls resetSorting() and goes to 'ready' from any state. SPEED_CHANGE adjusts speedFactor only (no state change); TOGGLE_CODE toggles codeBlock visibility only (orthogonal to sorting states); RESIZE recomputes positions only (no state change). The 'done' state marks all bars as sorted, sets 'Done' status, and ensures playing is stopped. Dragging while playing is allowed; a drop effectively resets the generator and returns to 'ready'. This FSM models the core sorting/animation/editor interactions; UI toggles (speed/code visibility) are treated as events with no core state transitions."
}
  </script>
</body>
</html>