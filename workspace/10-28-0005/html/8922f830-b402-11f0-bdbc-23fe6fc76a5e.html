<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bubble Sort — Interactive Module</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --radius: 10px;
      --bg: #0b0e12;
      --panel: #12161c;
      --text: #eaf0f6;
      --muted: #b7c3cf;
      --accent: #4da3ff;
      --accent-2: #1abc9c;
      --warn: #f7b500;
      --error: #ff6b6b;
      --bar: #5b7c99;
      --bar-contrast: #dbe8f3;
      --focus: #ffe27a;
      --shadow: 0 12px 28px rgba(0,0,0,0.45);
      --speed-scale: 1; /* higher = faster */
      --bar-transition: calc(280ms / var(--speed-scale));
      --swap-transition: calc(200ms / var(--speed-scale));
      --highlight-transition: calc(160ms / var(--speed-scale));
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
      line-height: 1.5;
    }

    .page {
      padding: var(--safe-margin);
      max-width: 1100px;
      margin: 0 auto;
    }

    h1, h2, h3 {
      margin: 0 0 8px 0;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    h1 { font-size: 26px; }
    h2 { font-size: 20px; color: var(--muted); }
    h3 { font-size: 16px; color: var(--muted); }

    p {
      margin: 0 0 12px 0;
      color: var(--muted);
    }

    ul {
      margin: 0 0 var(--gap) 0;
      padding-left: 18px;
      color: var(--muted);
    }

    .module {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .card {
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: var(--gap);
      align-items: center;
    }

    label {
      font-weight: 600;
      color: var(--text);
    }

    input[type="text"], input[type="number"], input[type="range"], select {
      background: #0f1318;
      border: 1px solid #1e2732;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 8px;
      outline: none;
      transition: border var(--highlight-transition);
    }

    input[type="text"]:focus, input[type="number"]:focus, input[type="range"]:focus, button:focus, select:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 2px rgba(255,226,122,0.25);
    }

    input[type="text"] {
      min-width: 260px;
      flex: 1;
    }

    input[type="range"] {
      width: 220px;
    }

    button {
      appearance: none;
      border: 1px solid #1e2732;
      background: #0f1318;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 80ms ease, background 140ms ease, border var(--highlight-transition);
    }

    button:hover {
      background: #151b22;
    }

    button.primary {
      background: var(--accent);
      border-color: #2f6eb6;
      color: #041324;
    }

    button.primary:hover {
      filter: brightness(1.08);
    }

    button.tinted {
      background: rgba(77,163,255,0.14);
      border-color: #2f6eb6;
    }

    button.success {
      background: var(--accent-2);
      border-color: #0f7e66;
      color: #04221c;
    }

    button.warn {
      background: rgba(247,181,0,0.16);
      border-color: #7c5a05;
      color: var(--text);
    }

    .visual {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    .board-wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .board-labels {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      font-size: 14px;
    }

    .board {
      position: relative;
      height: 320px;
      background: #0e1319;
      border: 1px solid #1e2732;
      border-radius: 12px;
      overflow: hidden;
    }

    .bar {
      position: absolute;
      bottom: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      width: 40px; /* will be overridden in JS */
      transform-origin: bottom center;
      background: var(--bar);
      color: var(--bar-contrast);
      border-radius: 8px 8px 0 0;
      transition:
        left var(--bar-transition) ease,
        height var(--highlight-transition) ease,
        transform var(--swap-transition) ease,
        background var(--highlight-transition) ease,
        box-shadow var(--highlight-transition) ease;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      touch-action: none;
    }

    .bar .value {
      font-weight: 700;
      font-size: 14px;
      margin-bottom: 8px;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
    }

    .bar:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .bar.compare {
      background: #2e4b6a;
      box-shadow: 0 0 0 2px var(--warn) inset;
    }

    .bar.swap {
      transform: translateY(-6px) scale(1.04);
      background: #3b5f84;
    }

    .bar.locked {
      background: var(--accent-2);
      color: #07261f;
      box-shadow: 0 0 0 2px rgba(26,188,156,0.5) inset, 0 8px 18px rgba(0,0,0,0.35);
    }

    .legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 13px;
      color: var(--muted);
    }
    .legend .swatch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .legend .dot {
      width: 18px; height: 18px; border-radius: 50%;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.08) inset;
    }
    .dot.compare { background: #2e4b6a; box-shadow: 0 0 0 2px var(--warn) inset; }
    .dot.swap { background: #3b5f84; }
    .dot.locked { background: var(--accent-2); }

    .status {
      display: grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: var(--gap);
    }

    .stat {
      background: #0f1318;
      border: 1px solid #1e2732;
      border-radius: 12px;
      padding: 12px;
    }
    .stat .big {
      font-size: 22px;
      font-weight: 800;
      color: var(--text);
    }
    .stat .label {
      font-size: 12px;
      color: var(--muted);
    }

    .aria-info {
      font-size: 13px;
      color: var(--muted);
    }

    .plan {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    details {
      border: 1px solid #1e2732;
      border-radius: 12px;
      padding: 12px;
      background: #0f1318;
    }

    details summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--text);
      outline: none;
    }

    /* Responsive tweaks */
    @media (min-width: 840px) {
      .module {
        grid-template-columns: 1.2fr 0.8fr;
      }
    }
    @media (max-width: 640px) {
      .status {
        grid-template-columns: 1fr;
      }
      input[type="range"] {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <main class="page" role="main" aria-label="Bubble Sort interactive module">
    <header style="margin-bottom: 16px;">
      <h1>Bubble Sort — Sorting by Adjacent Swaps</h1>
      <p>Manipulate the array and step through bubble sort to see how adjacent comparisons slowly “bubble” the largest elements to the end.</p>
    </header>

    <section class="module" aria-labelledby="module-title">
      <!-- Interactive area -->
      <div class="card visual" aria-label="Interactive bubble sort visual and controls">
        <h2 id="module-title">Interactive Module</h2>

        <div class="controls" aria-label="Controls">
          <div class="row" role="group" aria-label="Array input controls">
            <label for="arrayInput">Array (comma-separated):</label>
            <input id="arrayInput" type="text" inputmode="numeric"
                   aria-label="Array input field"
                   value="7, 3, 5, 2, 9, 1, 4" />
            <button id="loadBtn" class="primary" aria-label="Load array">Load</button>
            <button id="randomBtn" class="tinted" aria-label="Randomize array">Random</button>
            <label for="lenInput" class="visually-hidden" style="position:absolute;left:-9999px;">Random length</label>
            <input id="lenInput" type="number" min="3" max="12" value="8" aria-label="Random array length" title="Length (3–12)" style="width:110px;">
          </div>

          <div class="row" role="group" aria-label="Sort controls">
            <button id="stepBtn" class="primary" aria-label="Step one comparison">Step</button>
            <button id="passBtn" class="tinted" aria-label="Run one pass">Run Pass</button>
            <button id="playBtn" class="success" aria-label="Play or pause sorting">Play</button>
            <button id="resetBtn" class="warn" aria-label="Reset to initial">Reset</button>
            <div class="row" style="flex:1; justify-content:flex-end;">
              <label for="speedRange">Speed:</label>
              <input id="speedRange" type="range" min="0.5" max="3" step="0.1" value="1.4" aria-label="Animation speed">
              <span id="speedLabel" aria-live="polite">1.4×</span>
            </div>
          </div>

          <div class="legend" aria-label="Legend">
            <span class="swatch"><span class="dot compare" aria-hidden="true"></span> comparing pair</span>
            <span class="swatch"><span class="dot swap" aria-hidden="true"></span> swapping</span>
            <span class="swatch"><span class="dot locked" aria-hidden="true"></span> sorted suffix (locked)</span>
          </div>
        </div>

        <div class="board-wrap">
          <div class="board-labels">
            <span>Drag bars up/down to change values. Tab to a bar and use ArrowUp/ArrowDown for fine adjustments.</span>
            <span id="passInfo">Pass 0 of 0</span>
          </div>
          <div id="board" class="board" role="group" aria-label="Array visualization"></div>
        </div>

        <div class="status" aria-label="Status panel">
          <div class="stat" aria-live="polite">
            <div class="big"><span id="compareCount">0</span></div>
            <div class="label">Comparisons</div>
          </div>
          <div class="stat" aria-live="polite">
            <div class="big"><span id="swapCount">0</span></div>
            <div class="label">Swaps</div>
          </div>
          <div class="stat" aria-live="polite">
            <div class="big"><span id="indexInfo">i = 0</span></div>
            <div class="label">Current comparison index</div>
          </div>
          <div class="stat" aria-live="polite">
            <div class="big"><span id="invariantInfo">Largest of unsorted moves right each pass</span></div>
            <div class="label">Bubble sort invariant</div>
          </div>
        </div>

        <div class="aria-info">
          Tip: Screen readers can tab to each bar. Use arrow keys to adjust values. Use the Step and Play buttons to control the algorithm. Visual states are reinforced by text status.
        </div>
      </div>

      <!-- Design plan content -->
      <aside class="card plan" aria-label="Design plan">
        <h2>Design Plan</h2>

        <section>
          <h3>Concept Title</h3>
          <p>Bubble Sort: Adjacent Comparisons and Swaps</p>
        </section>

        <section>
          <h3>Learning Objective</h3>
          <ul>
            - Understand that bubble sort repeatedly compares adjacent elements, swapping out-of-order pairs.
            - See the invariant: after each pass, the largest remaining element is “bubbled” to the end and locked.
            - Experience the algorithm step-by-step and control speed, passes, and data values.
          </ul>
        </section>

        <section>
          <h3>Interaction Design</h3>
          <ul>
            - Input: Enter a comma-separated list or generate a random array.
            - Direct manipulation: Drag any bar vertically (or use arrow keys) to adjust its value; changes reflect immediately.
            - Controls:
              • Step: performs one adjacent comparison (and swap if needed).
              • Run Pass: completes the current pass, locking the next largest element at the end.
              • Play/Pause: auto-steps until the array is sorted.
              • Reset: restores the initial unsorted configuration.
            - Visual feedback:
              • Compared bars highlight.
              • Swaps animate with a bounce and smooth horizontal movement.
              • Sorted suffix bars turn green (“locked”).
            - Status: Live counters for comparisons and swaps, current index i, pass progress, and invariant description.
          </ul>
        </section>

        <section>
          <h3>Layout Description</h3>
          <ul>
            - Safe area margins: 24 px around the viewport, applied via page padding.
            - Structure: Two-column layout on wide screens (interactive module left, plan right); single-column on narrow screens.
            - Spacing: Minimum 16 px between interactive elements (buttons, inputs, board).
            - Clarity: Controls grouped (array input, sort control, speed). Visual board centered with labels and legend directly below.
            - Accessibility: Keyboard-operable bars, ARIA labels, polite live regions for status updates, high-contrast states, and responsive design across breakpoints.
          </ul>
        </section>
      </aside>
    </section>
  </main>

  <script>
    (function () {
      const board = document.getElementById('board');
      const arrayInput = document.getElementById('arrayInput');
      const loadBtn = document.getElementById('loadBtn');
      const randomBtn = document.getElementById('randomBtn');
      const lenInput = document.getElementById('lenInput');
      const stepBtn = document.getElementById('stepBtn');
      const passBtn = document.getElementById('passBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');

      const compareCountEl = document.getElementById('compareCount');
      const swapCountEl = document.getElementById('swapCount');
      const indexInfoEl = document.getElementById('indexInfo');
      const invariantInfoEl = document.getElementById('invariantInfo');
      const passInfoEl = document.getElementById('passInfo');

      const MIN_VAL = 1;
      const MAX_VAL = 99;

      let arr = [7, 3, 5, 2, 9, 1, 4];
      let bars = [];
      let initialArr = arr.slice();

      let i = 0;
      let pass = 0;
      let comparisons = 0;
      let swaps = 0;
      let running = false;
      let passRunning = false;
      let stepTimer = null;

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function randomInt(min, max) { return min + Math.floor(Math.random() * (max - min + 1)); }

      function applySpeed(scale) {
        document.documentElement.style.setProperty('--speed-scale', scale.toString());
        speedLabel.textContent = scale.toFixed(1) + '×';
      }

      function validateArrayFromInput(text) {
        const parts = text.split(',').map(s => s.trim()).filter(s => s.length);
        if (parts.length < 2 || parts.length > 30) {
          alert('Please provide between 2 and 30 numbers.');
          return null;
        }
        const nums = [];
        for (const p of parts) {
          const v = Number(p);
          if (!Number.isFinite(v)) { alert('Only numbers are allowed.'); return null; }
          nums.push(clamp(Math.round(v), MIN_VAL, MAX_VAL));
        }
        return nums;
      }

      function randomArray(length) {
        const len = clamp(Math.round(length), 3, 12);
        const out = [];
        for (let k = 0; k < len; k++) {
          out.push(randomInt(1, 99));
        }
        return out;
      }

      function clearBoard() {
        while (board.firstChild) board.removeChild(board.firstChild);
        bars = [];
      }

      function layoutBars() {
        const width = board.clientWidth || board.offsetWidth;
        const height = board.clientHeight || board.offsetHeight;
        const n = arr.length;
        const slot = Math.max(40, Math.floor(width / n) - 6);
        const gap = Math.max(6, Math.floor((width - n * slot) / Math.max(1, n - 1)));
        const maxH = height - 28;

        for (let k = 0; k < bars.length; k++) {
          const bar = bars[k];
          bar.el.style.width = slot + 'px';
          bar.el.style.left = (k * (slot + gap)) + 'px';
          const h = Math.floor((arr[k] / MAX_VAL) * maxH);
          bar.el.style.height = Math.max(24, h) + 'px';
          bar.el.setAttribute('aria-label', `Index ${k}, value ${arr[k]}`);
          bar.el.dataset.index = String(k);
          bar.valueEl.textContent = String(arr[k]);
        }
      }

      function renderBars() {
        clearBoard();
        const n = arr.length;
        for (let k = 0; k < n; k++) {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.tabIndex = 0;
          bar.setAttribute('role', 'slider');
          bar.setAttribute('aria-valuemin', String(MIN_VAL));
          bar.setAttribute('aria-valuemax', String(MAX_VAL));
          bar.setAttribute('aria-valuenow', String(arr[k]));
          bar.setAttribute('aria-label', `Index ${k}, value ${arr[k]}`);

          const label = document.createElement('div');
          label.className = 'value';
          label.textContent = String(arr[k]);
          bar.appendChild(label);

          attachBarEvents(bar, k);

          board.appendChild(bar);
          bars.push({ el: bar, valueEl: label });
        }
        layoutBars();
        updateStatus();
        updateLockedState();
      }

      function updateStatus() {
        compareCountEl.textContent = String(comparisons);
        swapCountEl.textContent = String(swaps);
        indexInfoEl.textContent = `i = ${i}`;
        passInfoEl.textContent = `Pass ${pass} of ${Math.max(0, arr.length - 1)}`;
        invariantInfoEl.textContent = (pass === 0)
          ? 'Largest of unsorted moves right each pass'
          : `Locked suffix size: ${pass}`;
      }

      function resetAlgorithmState() {
        i = 0; pass = 0;
        comparisons = 0; swaps = 0;
        running = false; passRunning = false;
        clearTimer();
        playBtn.textContent = 'Play';
        removeAllStates();
        updateStatus();
      }

      function removeAllStates() {
        bars.forEach(b => {
          b.el.classList.remove('compare', 'swap', 'locked');
        });
      }

      function updateLockedState() {
        // Lock last 'pass' bars
        const n = arr.length;
        for (let k = 0; k < n; k++) {
          if (k >= n - pass) {
            bars[k].el.classList.add('locked');
          } else {
            bars[k].el.classList.remove('locked');
          }
        }
      }

      function markCompare(idx) {
        removeComparisons();
        if (bars[idx]) bars[idx].el.classList.add('compare');
        if (bars[idx + 1]) bars[idx + 1].el.classList.add('compare');
      }
      function removeComparisons() {
        bars.forEach(b => b.el.classList.remove('compare', 'swap'));
      }

      function swapVisual(idxA, idxB) {
        // Swap array values and DOM bars positions
        const tmp = arr[idxA]; arr[idxA] = arr[idxB]; arr[idxB] = tmp;

        const tmpBar = bars[idxA];
        bars[idxA] = bars[idxB];
        bars[idxB] = tmpBar;

        // Indicate swap
        bars[idxA].el.classList.add('swap');
        bars[idxB].el.classList.add('swap');

        layoutBars();
        setTimeout(() => {
          bars[idxA].el.classList.remove('swap');
          bars[idxB].el.classList.remove('swap');
        }, 200);
      }

      function isSorted() {
        for (let k = 1; k < arr.length; k++) {
          if (arr[k - 1] > arr[k]) return false;
        }
        return true;
      }

      function clearTimer() {
        if (stepTimer) {
          clearTimeout(stepTimer);
          stepTimer = null;
        }
      }

      function stepOnce() {
        const n = arr.length;
        if (pass >= n - 1) {
          running = false;
          playBtn.textContent = 'Play';
          removeComparisons();
          updateLockedState();
          invariantInfoEl.textContent = 'Sorted complete';
          return;
        }

        if (i >= n - 1 - pass) {
          // End of pass: lock the bubbled element at position n-1-pass
          pass++;
          i = 0;
          updateLockedState();
          updateStatus();
          return;
        }

        markCompare(i);
        comparisons++;
        updateStatus();

        if (arr[i] > arr[i + 1]) {
          swaps++;
          swapVisual(i, i + 1);
        }
        i++;
        updateStatus();
      }

      function runPlayLoop() {
        if (!running) return;
        stepOnce();
        if (pass >= arr.length - 1) {
          running = false;
          playBtn.textContent = 'Play';
          return;
        }
        stepTimer = setTimeout(runPlayLoop, Math.max(90, 300 / Number(speedRange.value)));
      }

      function runPass() {
        if (passRunning || running) return;
        passRunning = true;
        const n = arr.length;
        function loop() {
          if (i >= n - 1 - pass) {
            pass++;
            i = 0;
            updateLockedState();
            passRunning = false;
            updateStatus();
            return;
          }
          stepOnce();
          if (passRunning) {
            stepTimer = setTimeout(loop, Math.max(90, 300 / Number(speedRange.value)));
          }
        }
        loop();
      }

      // Events
      loadBtn.addEventListener('click', () => {
        const parsed = validateArrayFromInput(arrayInput.value);
        if (!parsed) return;
        arr = parsed;
        initialArr = arr.slice();
        renderBars();
        resetAlgorithmState();
      });

      randomBtn.addEventListener('click', () => {
        const len = clamp(Number(lenInput.value) || 8, 3, 12);
        arr = randomArray(len);
        arrayInput.value = arr.join(', ');
        initialArr = arr.slice();
        renderBars();
        resetAlgorithmState();
      });

      stepBtn.addEventListener('click', () => {
        if (running) {
          running = false;
          playBtn.textContent = 'Play';
          clearTimer();
        }
        stepOnce();
      });

      passBtn.addEventListener('click', () => {
        runPass();
      });

      playBtn.addEventListener('click', () => {
        running = !running;
        playBtn.textContent = running ? 'Pause' : 'Play';
        if (running) {
          runPlayLoop();
        } else {
          clearTimer();
        }
      });

      resetBtn.addEventListener('click', () => {
        arr = initialArr.slice();
        renderBars();
        resetAlgorithmState();
      });

      speedRange.addEventListener('input', () => {
        applySpeed(Number(speedRange.value));
      });

      window.addEventListener('resize', () => {
        layoutBars();
      });

      // Drag and keyboard adjust for bars
      function attachBarEvents(bar, index) {
        let dragging = false;
        let startY = 0;
        let startVal = arr[index];

        function setValueFromPointer(clientY) {
          const rect = board.getBoundingClientRect();
          const relY = clamp(clientY - rect.top, 0, rect.height);
          const ratio = 1 - (relY / rect.height);
          const val = clamp(Math.round(ratio * MAX_VAL), MIN_VAL, MAX_VAL);
          return val;
        }

        function updateBarValue(idx, val) {
          arr[idx] = val;
          bars[idx].valueEl.textContent = String(val);
          bars[idx].el.setAttribute('aria-valuenow', String(val));
          layoutBars();
          // Changing data invalidates locks; restart algorithm state
          removeAllStates();
          i = 0; pass = 0; comparisons = 0; swaps = 0;
          updateStatus();
        }

        bar.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          dragging = true;
          startY = e.clientY;
          startVal = arr[Number(bar.dataset.index)];
          bar.setPointerCapture(e.pointerId);
          if (running) {
            running = false;
            playBtn.textContent = 'Play';
            clearTimer();
          }
        });

        bar.addEventListener('pointermove', (e) => {
          if (!dragging) return;
          const idx = Number(bar.dataset.index);
          const newVal = setValueFromPointer(e.clientY);
          updateBarValue(idx, newVal);
        });

        bar.addEventListener('pointerup', (e) => {
          dragging = false;
          try { bar.releasePointerCapture(e.pointerId); } catch (_) {}
        });

        bar.addEventListener('keydown', (e) => {
          const idx = Number(bar.dataset.index);
          let delta = 0;
          if (e.key === 'ArrowUp') delta = 1;
          else if (e.key === 'ArrowDown') delta = -1;
          else if (e.key === 'PageUp') delta = 5;
          else if (e.key === 'PageDown') delta = -5;
          if (delta !== 0) {
            e.preventDefault();
            const newVal = clamp(arr[idx] + delta, MIN_VAL, MAX_VAL);
            updateBarValue(idx, newVal);
          }
        });
      }

      // Initialize
      applySpeed(Number(speedRange.value));
      renderBars();

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target && ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
        if (e.key === ' ') {
          e.preventDefault();
          playBtn.click();
        } else if (e.key.toLowerCase() === 's') {
          stepBtn.click();
        } else if (e.key.toLowerCase() === 'p') {
          passBtn.click();
        } else if (e.key.toLowerCase() === 'r') {
          resetBtn.click();
        }
      });
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "Finite State Machine for the Bubble Sort interactive module, modeling algorithm execution (step/play/pass), data editing, visual compare/swap/lock feedback, and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateStatus",
      "on": {
        "LOAD_CLICK": "loading",
        "RANDOM_CLICK": "loading",
        "RESET_CLICK": "resetting",
        "STEP_CLICK": "step_comparing",
        "PASS_CLICK": "pass_running",
        "PLAY_TOGGLE": "playing",
        "SPEED_CHANGE": "idle",
        "WINDOW_RESIZE": "idle",
        "BAR_POINTER_DOWN": "editing_drag",
        "BAR_KEY_ADJUST_ARROW_UP": "editing_keyboard",
        "BAR_KEY_ADJUST_ARROW_DOWN": "editing_keyboard",
        "BAR_KEY_ADJUST_PAGE_UP": "editing_keyboard",
        "BAR_KEY_ADJUST_PAGE_DOWN": "editing_keyboard",
        "KEYBOARD_SPACE": "playing",
        "KEYBOARD_S": "step_comparing",
        "KEYBOARD_P": "pass_running",
        "KEYBOARD_R": "resetting"
      }
    },
    {
      "name": "playing",
      "onEnter": "runPlayLoop",
      "onExit": "clearTimer",
      "on": {
        "TIMER_TICK": "step_comparing",
        "PLAY_TOGGLE": "idle",
        "STEP_CLICK": "step_comparing",
        "BAR_POINTER_DOWN": "editing_drag",
        "ARRAY_SORTED": "done",
        "SPEED_CHANGE": "playing",
        "WINDOW_RESIZE": "playing",
        "KEYBOARD_SPACE": "idle",
        "KEYBOARD_S": "step_comparing",
        "KEYBOARD_R": "resetting"
      }
    },
    {
      "name": "pass_running",
      "onEnter": "runPass",
      "onExit": "clearTimer",
      "on": {
        "PASS_TIMER_TICK": "step_comparing",
        "END_OF_PASS": "idle",
        "BAR_POINTER_DOWN": "editing_drag",
        "ARRAY_SORTED": "done",
        "KEYBOARD_R": "resetting"
      }
    },
    {
      "name": "step_comparing",
      "onEnter": "markCompare",
      "onExit": "removeComparisons",
      "on": {
        "SWAP_REQUIRED": "step_swapping",
        "NO_SWAP": "idle",
        "END_OF_PASS": "end_of_pass_locking",
        "ARRAY_SORTED": "done",
        "CONTINUE_PLAY": "playing",
        "CONTINUE_IDLE": "idle"
      }
    },
    {
      "name": "step_swapping",
      "onEnter": "swapVisual",
      "on": {
        "SWAP_ANIMATION_DONE": "idle",
        "END_OF_PASS": "end_of_pass_locking",
        "CONTINUE_PLAY": "playing",
        "ARRAY_SORTED": "done"
      }
    },
    {
      "name": "end_of_pass_locking",
      "onEnter": "updateLockedState",
      "on": {
        "CONTINUE_PLAY": "playing",
        "PASS_LOOP_COMPLETED": "idle",
        "CONTINUE_IDLE": "idle",
        "ARRAY_SORTED": "done"
      }
    },
    {
      "name": "editing_drag",
      "onEnter": "clearTimer",
      "onExit": "releasePointerCapture",
      "on": {
        "BAR_POINTER_MOVE": "editing_drag",
        "BAR_POINTER_UP": "idle",
        "LOAD_CLICK": "loading",
        "RANDOM_CLICK": "loading",
        "RESET_CLICK": "resetting"
      }
    },
    {
      "name": "editing_keyboard",
      "onEnter": "updateBarValue",
      "on": {
        "KEY_ADJUST_APPLIED": "idle",
        "LOAD_CLICK": "loading",
        "RANDOM_CLICK": "loading",
        "RESET_CLICK": "resetting"
      }
    },
    {
      "name": "loading",
      "onEnter": "renderBars",
      "on": {
        "LOAD_SUCCESS": "idle",
        "RANDOM_SUCCESS": "idle",
        "INVALID_INPUT": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "resetAlgorithmState",
      "on": {
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "updateLockedState",
      "on": {
        "LOAD_CLICK": "loading",
        "RANDOM_CLICK": "loading",
        "RESET_CLICK": "resetting",
        "BAR_POINTER_DOWN": "editing_drag",
        "BAR_KEY_ADJUST_ARROW_UP": "editing_keyboard",
        "BAR_KEY_ADJUST_ARROW_DOWN": "editing_keyboard",
        "BAR_KEY_ADJUST_PAGE_UP": "editing_keyboard",
        "BAR_KEY_ADJUST_PAGE_DOWN": "editing_keyboard",
        "STEP_CLICK": "done",
        "PASS_CLICK": "done",
        "PLAY_TOGGLE": "done",
        "SPEED_CHANGE": "done",
        "WINDOW_RESIZE": "done",
        "KEYBOARD_SPACE": "done",
        "KEYBOARD_S": "done",
        "KEYBOARD_P": "done",
        "KEYBOARD_R": "resetting"
      }
    }
  ],
  "events": [
    "LOAD_CLICK",
    "RANDOM_CLICK",
    "RESET_CLICK",
    "STEP_CLICK",
    "PASS_CLICK",
    "PLAY_TOGGLE",
    "SPEED_CHANGE",
    "WINDOW_RESIZE",
    "BAR_POINTER_DOWN",
    "BAR_POINTER_MOVE",
    "BAR_POINTER_UP",
    "BAR_KEY_ADJUST_ARROW_UP",
    "BAR_KEY_ADJUST_ARROW_DOWN",
    "BAR_KEY_ADJUST_PAGE_UP",
    "BAR_KEY_ADJUST_PAGE_DOWN",
    "KEYBOARD_SPACE",
    "KEYBOARD_S",
    "KEYBOARD_P",
    "KEYBOARD_R",
    "TIMER_TICK",
    "PASS_TIMER_TICK",
    "SWAP_REQUIRED",
    "NO_SWAP",
    "SWAP_ANIMATION_DONE",
    "END_OF_PASS",
    "PASS_LOOP_COMPLETED",
    "ARRAY_SORTED",
    "LOAD_SUCCESS",
    "RANDOM_SUCCESS",
    "INVALID_INPUT",
    "RESET_DONE",
    "KEY_ADJUST_APPLIED",
    "CONTINUE_PLAY",
    "CONTINUE_IDLE"
  ],
  "notes": "Mapping to code: idle corresponds to the default state when not auto-playing or running a pass. playing is when the 'running' flag is true; onEnter runPlayLoop schedules TIMER_TICKs and sets the Play button to 'Pause' in code; onExit clearTimer sets 'running' false and returns Play label to 'Play'. pass_running corresponds to 'passRunning' true; onEnter runPass executes a timed loop until END_OF_PASS, then PASS_LOOP_COMPLETED leads back to idle. step_comparing uses markCompare() to add 'compare' CSS class to the two bars and increments comparisons; onExit removeComparisons() clears 'compare'/'swap' classes. step_swapping uses swapVisual() which swaps array contents and bar positions, adds 'swap' CSS class, animates, and schedules removal; SWAP_ANIMATION_DONE fires after ~200 ms. end_of_pass_locking uses updateLockedState() to add 'locked' CSS class to the bubbled element; updateStatus() also updates counters and pass info (invoked within stepOnce/runPass). editing_drag is entered on BAR_POINTER_DOWN; onEnter it interrupts playing (running=false, clearTimer()) and sets pointer capture; BAR_POINTER_MOVE repeatedly calls updateBarValue(), which resets algorithm state (i=0, pass=0, comparisons=0, swaps=0), removes all visual states via removeAllStates(), updates ARIA and layout; BAR_POINTER_UP releases capture and returns to idle. editing_keyboard is entered for arrow/page key adjustments on a focused bar; onEnter updateBarValue() performs the same algorithm reset behaviors, then KEY_ADJUST_APPLIED returns to idle. loading covers both Load and Random: validateArrayFromInput() or randomArray() produce new data; onEnter renderBars() rebuilds DOM bars and layout; resetAlgorithmState() is applied afterward; LOAD_SUCCESS/RANDOM_SUCCESS immediately return to idle, INVALID_INPUT keeps previous data. resetting sets arr = initialArr, then renderBars() and resetAlgorithmState() to clear counters/visual states. done occurs when pass >= n-1 (sorted complete); onEnter updateLockedState() ensures all bars are locked, removeComparisons() clears highlights, invariantInfoEl shows 'Sorted complete', and Play text is set to 'Play'; user actions that change data (drag/keyboard) or load/reset leave done. Shortcuts: SPACE triggers PLAY_TOGGLE, 's' triggers STEP_CLICK, 'p' triggers PASS_CLICK, 'r' triggers RESET_CLICK. Speed slider changes (SPEED_CHANGE) call applySpeed() and alter CSS variables; they do not change state but affect timer cadence and animation duration. WINDOW_RESIZE triggers layoutBars(); it is modeled as self-transitions in the current state. Conditional events emitted by the algorithm controller: SWAP_REQUIRED vs NO_SWAP are determined by arr[i] > arr[i+1]; END_OF_PASS occurs when i >= n-1-pass; ARRAY_SORTED occurs when pass >= n-1; CONTINUE_PLAY/CONTINUE_IDLE indicate whether auto-play or pass loop should continue versus staying idle after a step."
}
  </script>
</body>
</html>