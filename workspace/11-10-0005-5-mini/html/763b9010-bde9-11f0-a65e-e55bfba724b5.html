<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Binary Search Tree (BST) Explorer</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #6ee7b7;
      --muted: #94a3b8;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.02);
      --node-bg: #111827;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#0b1220 0%, #071120 100%);
      color: #e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding: var(--safe);
      box-sizing: border-box;
    }
    *{box-sizing:inherit}
    h1{margin:0;font-size:20px}
    p{margin:0}
    .app{
      display:flex;
      gap: var(--gap);
      height: calc(100vh - (var(--safe) * 2));
    }
    /* Left column: info and controls */
    .sidebar{
      width: 360px;
      min-width: 280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 4px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .overview{
      background: linear-gradient(90deg, rgba(110,231,183,0.06), transparent 40%);
      border-radius:10px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:120px;
    }
    .muted{color:var(--muted);font-size:13px}
    .controls{
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      margin-top: 6px;
    }
    .row{
      display:flex;
      gap: var(--gap);
      align-items:stretch;
    }
    .input{
      display:flex;
      gap:8px;
      align-items:center;
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    label{font-size:13px;color:var(--muted)}
    input[type="number"]{
      width:100%;
      padding:8px 10px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:6px;
      color:inherit;
      outline:none;
    }
    button{
      cursor:pointer;
      padding:10px 12px;
      border-radius:8px;
      border: none;
      color: #071122;
      background: var(--accent);
      font-weight:600;
      box-shadow: 0 6px 18px rgba(32, 133, 105, 0.12);
      min-width:0;
    }
    button.secondary{
      background: transparent;
      color: var(--accent);
      border: 1px solid rgba(110,231,183,0.12);
      font-weight:600;
      box-shadow:none;
    }
    button.ghost{
      background: transparent;
      color: var(--muted);
      border: 1px dashed rgba(255,255,255,0.03);
      font-weight:600;
    }
    .small{
      padding:8px 10px;
      font-size:13px;
    }
    .controls .group{
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    .log{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      overflow:auto;
      min-height:80px;
    }

    /* Right column: visualizer */
    .visual{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      align-items:stretch;
    }
    .canvas-wrap{
      flex:1;
      background: var(--glass);
      border-radius:10px;
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:200px;
      position:relative;
      overflow:auto;
    }
    svg{
      width:100%;
      height:100%;
    }
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .legend .item{display:flex;gap:8px;align-items:center}
    .dot{
      width:12px;height:12px;border-radius:6px;background:var(--node-bg);border:2px solid rgba(255,255,255,0.04);
    }

    /* Node styles (SVG) */
    .link{
      stroke: rgba(255,255,255,0.08);
      stroke-width:2;
      fill:none;
    }
    .node-group{
      cursor:default;
      transition: transform 300ms ease;
    }
    .node-circle{
      fill: var(--node-bg);
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      filter: drop-shadow(0 6px 14px rgba(2,6,23,0.6));
      transition: transform 240ms ease, fill 240ms ease, stroke 240ms ease;
    }
    .node-text{
      fill: #e6eef8;
      font-weight:700;
      font-size:13px;
      text-anchor:middle;
      dominant-baseline:central;
      pointer-events:none;
    }
    .node-label{
      font-size:11px;
      fill:var(--muted);
      text-anchor:middle;
      dominant-baseline:ideographic;
    }
    /* Visual feedback states */
    .highlight .node-circle{ fill: #065f46; stroke: #34d399; transform-origin:center; transform: scale(1.12); }
    .visited .node-circle{ fill: #0b1220; stroke: #6ee7b7; transform-origin:center; transform:scale(1.06); }
    .inserted .node-circle{ fill: #05203a; stroke: #60a5fa; transform-origin:center; transform: scale(1.18); }
    .deleted .node-circle{ fill: rgba(255,255,255,0.03); stroke: rgba(255,255,255,0.03); opacity: 0.25; transform: scale(0.8); transition: transform 320ms ease, opacity 320ms ease; }

    /* small responsive tweaks */
    @media (max-width:900px){
      .app{flex-direction:column}
      .sidebar{width:100%}
    }
    /* Accessibility focus */
    button:focus, input:focus { outline: 3px solid rgba(110,231,183,0.12); outline-offset:2px; border-radius:8px; }
    /* spacing enforcement for interactive elements */
    .controls > * { margin-bottom: 0 !important; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Binary Search Tree Explorer">
    <aside class="sidebar" aria-labelledby="title">
      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div>
          <h1 id="title">Binary Search Tree (BST) Explorer</h1>
          <div class="muted" style="margin-top:6px">One interactive module: insert, search, delete — watch traversal and structure updates.</div>
        </div>
      </div>

      <!-- Overview (Concept Title, Learning Objective, Interaction Design, Layout Description) -->
      <section class="overview" aria-labelledby="overview-title">
        <div id="overview-title" style="display:flex;justify-content:space-between;align-items:flex-start;">
          <div>
            <strong>Concept</strong>
            <div class="muted" style="margin-top:6px">Binary Search Tree — ordered node structure with left < right < right</div>
          </div>
          <div style="text-align:right;">
            <div style="font-size:12px;color:var(--muted)">Safe margins: 24px</div>
            <div style="font-size:12px;color:var(--muted)">Min spacing: 16px</div>
          </div>
        </div>

        <div style="margin-top:6px">
          <strong>Learning objective</strong>
          <div class="muted" style="margin-top:6px">
            After interacting you will understand how insertion, search, and deletion traverse and change a BST, and you'll see where rotations would be needed (not covered here).
          </div>
        </div>

        <div style="margin-top:6px">
          <strong>Interaction design</strong>
          <div class="muted" style="margin-top:6px">
            Type a number and click Insert / Search / Delete. Each operation animates node visits (highlight), shows the traversal log, and step-through controls let you advance or autoplay the sequence.
          </div>
        </div>
      </section>

      <!-- Controls -->
      <section class="controls" aria-label="Controls">
        <div class="input" role="group" aria-label="Value input">
          <label for="valueInput" class="muted" id="inputLabel" style="min-width:48px;">Value</label>
          <input id="valueInput" type="number" aria-labelledby="inputLabel" placeholder="e.g., 42" />
          <button id="insertBtn" class="small" title="Insert value" aria-label="Insert value">Insert</button>
          <button id="searchBtn" class="small secondary" title="Search value" aria-label="Search value">Search</button>
          <button id="deleteBtn" class="small ghost" title="Delete value" aria-label="Delete value">Delete</button>
        </div>

        <div class="group" role="group" aria-label="Playback controls" style="align-items:center">
          <button id="stepBtn" class="small">Step</button>
          <button id="playBtn" class="small secondary">Play</button>
          <button id="resetBtn" class="small ghost">Clear</button>
          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <label class="muted" for="speed" style="font-size:12px">Speed</label>
            <input id="speed" type="range" min="300" max="1500" step="100" value="800" aria-label="Playback speed" />
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center">
          <button id="randomBtn" class="small">Add Random</button>
          <button id="bulkBtn" class="small secondary">Add Batch</button>
          <div class="muted" style="font-size:12px;margin-left:auto">Nodes: <span id="nodeCount">0</span></div>
        </div>

        <div style="border-top:1px dashed rgba(255,255,255,0.03);padding-top:8px">
          <div class="muted" style="font-size:13px;margin-bottom:8px">Traversal Log</div>
          <pre id="log" class="log" aria-live="polite" role="log"></pre>
        </div>
      </section>
    </aside>

    <main class="visual" aria-label="BST visualizer">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="legend" aria-hidden="true">
          <div class="item"><div class="dot" style="background:#05203a;border:2px solid #60a5fa"></div><div class="muted">Inserted</div></div>
          <div class="item"><div class="dot" style="background:#065f46;border:2px solid #34d399"></div><div class="muted">Search path</div></div>
        </div>
        <div class="muted">Tip: values must be unique for this demo</div>
      </div>

      <div class="canvas-wrap" id="canvasWrap" tabindex="0" aria-label="BST canvas">
        <!-- SVG will be injected here -->
        <svg id="svgCanvas" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMid meet" role="img" aria-labelledby="svgTitle">
          <title id="svgTitle">Binary Search Tree visualization</title>
        </svg>
      </div>

      <div style="display:flex;gap:12px;align-items:center;justify-content:flex-end">
        <div class="muted">Zoom: <span id="zoomVal">100%</span></div>
        <input id="zoom" type="range" min="50" max="200" step="10" value="100" aria-label="Zoom canvas" />
      </div>
    </main>
  </div>

  <script>
    /***********************************************
     * Binary Search Tree Explorer (vanilla JS)
     * - Insert, Search, Delete with step-through animation
     * - Layout: simple in-order x-position and depth-based y
     * - No external libs or assets
     ***********************************************/

    // Utility helpers
    function el(name, attrs = {}) {
      const e = document.createElement(name);
      for (const k in attrs) {
        if (k === 'text') e.textContent = attrs[k];
        else e.setAttribute(k, attrs[k]);
      }
      return e;
    }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // BST data structure (simple)
    class BSTNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.parent = null;
        this.id = 'n' + Math.random().toString(36).slice(2,9);
      }
    }

    class BST {
      constructor() {
        this.root = null;
        this.size = 0;
      }
      insert(value){
        const newNode = new BSTNode(value);
        if (!this.root) {
          this.root = newNode;
          this.size = 1;
          return {node:newNode, path:[newNode], created:true};
        }
        let cur = this.root;
        const path = [];
        while (cur) {
          path.push(cur);
          if (value === cur.value) {
            return {node:cur, path, created:false, exists:true};
          }
          if (value < cur.value) {
            if (!cur.left) {
              cur.left = newNode;
              newNode.parent = cur;
              this.size++;
              path.push(newNode);
              return {node:newNode, path, created:true};
            } else cur = cur.left;
          } else {
            if (!cur.right) {
              cur.right = newNode;
              newNode.parent = cur;
              this.size++;
              path.push(newNode);
              return {node:newNode, path, created:true};
            } else cur = cur.right;
          }
        }
      }
      search(value){
        let cur = this.root;
        const path = [];
        while (cur) {
          path.push(cur);
          if (cur.value === value) return {found:true, node:cur, path};
          cur = (value < cur.value) ? cur.left : cur.right;
        }
        return {found:false, path};
      }
      delete(value){
        const s = this.search(value);
        if (!s.found) return {deleted:false, path:s.path};
        const node = s.node;
        const path = s.path;
        // cases
        if (!node.left && !node.right) {
          // leaf
          if (!node.parent) this.root = null;
          else {
            if (node.parent.left === node) node.parent.left = null;
            else node.parent.right = null;
          }
        } else if (node.left && !node.right) {
          // only left child
          if (!node.parent) {
            this.root = node.left;
            this.root.parent = null;
          } else {
            if (node.parent.left === node) node.parent.left = node.left;
            else node.parent.right = node.left;
            node.left.parent = node.parent;
          }
        } else if (!node.left && node.right) {
          // only right child
          if (!node.parent) {
            this.root = node.right;
            this.root.parent = null;
          } else {
            if (node.parent.left === node) node.parent.left = node.right;
            else node.parent.right = node.right;
            node.right.parent = node.parent;
          }
        } else {
          // two children: replace with in-order successor (min of right subtree)
          let succ = node.right;
          const succPath = [];
          while(succ.left) { succPath.push(succ); succ = succ.left; }
          succPath.push(succ);
          // swap values
          const oldVal = node.value;
          node.value = succ.value;
          succ.value = oldVal;
          // now delete succ (which has at most right child)
          // succ has no left child
          const parent = succ.parent;
          if (!succ.right) {
            if (parent.left === succ) parent.left = null;
            else parent.right = null;
          } else {
            if (parent.left === succ) parent.left = succ.right;
            else parent.right = succ.right;
            succ.right.parent = parent;
          }
          this.size--;
          return {deleted:true, path: path.concat(succPath), replacedWith:node}; // replaced value visible in node
        }
        this.size--;
        return {deleted:true, path};
      }
      // rebuild list of nodes for rendering
      nodesInOrder(){
        const res = [];
        function dfs(n){ if(!n) return; dfs(n.left); res.push(n); dfs(n.right); }
        dfs(this.root);
        return res;
      }
      maxDepth(){
        function depth(n){ if(!n) return 0; return 1 + Math.max(depth(n.left), depth(n.right)); }
        return depth(this.root);
      }
    }

    // Renderer for the BST into SVG with computed positions
    const svg = document.getElementById('svgCanvas');
    const canvasWrap = document.getElementById('canvasWrap');
    const logEl = document.getElementById('log');
    const nodeCountEl = document.getElementById('nodeCount');
    const zoom = document.getElementById('zoom');
    const zoomVal = document.getElementById('zoomVal');

    const tree = new BST();

    // state for playback steps
    let currentSteps = [];
    let stepIndex = 0;
    let playing = false;
    let playTimer = null;

    // heartbeat for rendering (debounced)
    let renderScheduled = false;
    function scheduleRender(){
      if (renderScheduled) return;
      renderScheduled = true;
      requestAnimationFrame(() => {
        renderTree();
        renderScheduled = false;
      });
    }

    // create an SVG element helper
    function svgEl(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      return el;
    }

    function clearSvg(){
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    // compute layout: assign x positions via in-order index, y by depth
    function computePositions(){
      const positions = new Map();
      let index = 0;
      function dfs(n, depth){
        if(!n) return;
        dfs(n.left, depth+1);
        index++;
        positions.set(n.id, {node:n, order:index, depth});
        dfs(n.right, depth+1);
      }
      if (tree.root) dfs(tree.root, 0);
      return positions;
    }

    function renderTree(highlightMap = {}) {
      clearSvg();
      const paddingX = 80;
      const paddingY = 60;
      const width = svg.viewBox.baseVal.width || 1200;
      const height = svg.viewBox.baseVal.height || 600;
      const positions = computePositions();
      if (positions.size === 0) { nodeCountEl.textContent = '0'; return; }
      nodeCountEl.textContent = String(tree.size);

      const maxOrder = Math.max(...Array.from(positions.values()).map(p=>p.order));
      const maxDepth = Math.max(...Array.from(positions.values()).map(p=>p.depth)) + 1;

      // map to coordinates
      const coords = new Map();
      positions.forEach((p, id) => {
        const x = paddingX + ( (p.order - 1) / Math.max(1, maxOrder - 1) ) * (width - paddingX * 2);
        const y = paddingY + (p.depth / Math.max(1, maxDepth - 1)) * (height - paddingY * 2);
        coords.set(id, {x,y,node:p.node,depth:p.depth,order:p.order});
      });

      // draw links first
      coords.forEach((c, id) => {
        const n = c.node;
        if (n.left) {
          const child = coords.get(n.left.id);
          if (child) {
            const path = svgEl('path', {
              d: generateCurve(c.x, c.y, child.x, child.y),
              class: 'link'
            });
            svg.appendChild(path);
          }
        }
        if (n.right) {
          const child = coords.get(n.right.id);
          if (child) {
            const path = svgEl('path', {
              d: generateCurve(c.x, c.y, child.x, child.y),
              class: 'link'
            });
            svg.appendChild(path);
          }
        }
      });

      // draw nodes
      coords.forEach((c, id) => {
        const g = svgEl('g', { class: 'node-group', 'data-id': id, 'data-val': c.node.value });
        const circle = svgEl('circle', { class: 'node-circle', cx: c.x, cy: c.y, r: 22 });
        const text = svgEl('text', { class: 'node-text', x: c.x, y: c.y });
        text.textContent = String(c.node.value);
        g.appendChild(circle);
        g.appendChild(text);

        // optional small label showing depth
        // const label = svgEl('text',{class:'node-label', x:c.x, y:c.y+34}); label.textContent = `d:${c.depth}`; g.appendChild(label);

        // apply highlight classes if present in highlightMap
        const state = highlightMap[c.node.id];
        if (state) {
          g.classList.add(state);
        }
        svg.appendChild(g);

        // attach pointer interactions
        g.addEventListener('mouseenter', ()=> {
          g.classList.add('highlight');
        });
        g.addEventListener('mouseleave', ()=> {
          if (!state) g.classList.remove('highlight');
        });
        g.addEventListener('click', ()=> {
          // clicking a node populates the input field for quick actions
          const input = document.getElementById('valueInput');
          input.value = c.node.value;
          input.focus();
        });
      });

      // minor accessibility: focus ring on canvas
      // done
    }

    function generateCurve(x1,y1,x2,y2){
      const dx = Math.abs(x2-x1);
      const midx = (x1+x2)/2;
      const controlY = (y1 + y2)/2;
      // cubic or quadratic curve: use simple quadratic for smoothness
      return `M ${x1} ${y1} Q ${midx} ${controlY - 40} ${x2} ${y2}`;
    }

    // Logging utility
    function log(msg){
      const time = new Date().toLocaleTimeString();
      const line = `[${time}] ${msg}\n`;
      logEl.textContent = line + logEl.textContent;
    }

    // Step management functions: create steps for insert/search/delete
    function stepsForSearch(value){
      const res = tree.search(value);
      const steps = [];
      for (let i=0;i<res.path.length;i++){
        const node = res.path[i];
        steps.push({
          label: `Visit ${node.value}`,
          action: (ctx) => {
            ctx.highlight = {[node.id]:'visited'};
            ctx.message = `Visited node ${node.value}`;
          }
        });
      }
      if (res.found) {
        steps.push({
          label: `Found ${value}`,
          action: (ctx) => { ctx.highlight = {[res.node.id]:'highlight'}; ctx.message = `Value ${value} found.`; }
        });
      } else {
        steps.push({
          label: `Not found`,
          action: (ctx) => { ctx.highlight = {}; ctx.message = `Value ${value} not found in tree.`; }
        });
      }
      return steps;
    }

    function stepsForInsert(value){
      // We'll step through visits until insertion point, then show insertion animation
      const result = tree.insert(value);
      // Note: we call insert immediately on tree; to animate properly we will reverse the structural change until the last step.
      // Simpler approach: revert structural change for the moment, compute path, then re-insert at final step.
      // For clarity, we'll revert the insertion if it created node.
      let createdNode = null;
      if (result.created) {
        createdNode = result.node;
        // detach it temporarily
        if (createdNode.parent) {
          if (createdNode.parent.left === createdNode) createdNode.parent.left = null;
          else createdNode.parent.right = null;
        } else {
          // was root
          tree.root = null;
        }
        tree.size--;
      }
      // Now compute the traversal path as if inserting
      const path = [];
      let cur = tree.root;
      if (!cur) { /* empty tree, will insert root */ }
      else {
        let p = tree.root;
        while (p) {
          path.push(p);
          if (value === p.value) break;
          if (value < p.value) {
            if (!p.left) { path.push({insertion:true, parent:p, side:'left'}); break; }
            p = p.left;
          } else {
            if (!p.right) { path.push({insertion:true, parent:p, side:'right'}); break; }
            p = p.right;
          }
        }
      }
      // Build steps
      const steps = [];
      // if tree empty, insertion is direct
      if (!tree.root && createdNode) {
        steps.push({
          label: 'Insert at root',
          action: (ctx) => {
            // attach node as root
            tree.root = createdNode;
            createdNode.parent = null;
            tree.size++;
            ctx.highlight = {[createdNode.id]:'inserted'};
            ctx.message = `Inserted ${value} as root`;
            scheduleRender();
          }
        });
        return steps;
      }

      // visit nodes
      path.forEach(item => {
        if (item.insertion) {
          steps.push({
            label: `Insert as ${item.side} child of ${item.parent.value}`,
            action: (ctx) => {
              // attach node
              if (!createdNode) {
                ctx.message = `Value ${value} already exists`;
                return;
              }
              if (item.side === 'left') item.parent.left = createdNode;
              else item.parent.right = createdNode;
              createdNode.parent = item.parent;
              tree.size++;
              ctx.highlight = {[createdNode.id]:'inserted', [item.parent.id]:'visited'};
              ctx.message = `Inserted ${value} under ${item.parent.value}`;
              scheduleRender();
            }
          });
        } else {
          steps.push({
            label: `Visit ${item.value}`,
            action: (ctx) => {
              ctx.highlight = {[item.id]:'visited'};
              ctx.message = `Visited ${item.value}`;
            }
          });
        }
      });

      // if the value already existed, the earlier insert returned exists
      if (result.exists) {
        // put node back with no structural change (nothing to revert)
        return steps;
      }
      return steps;
    }

    function stepsForDelete(value){
      const s = tree.search(value);
      if (!s.found) {
        const steps = s.path.map(node => ({
          label: `Visit ${node.value}`,
          action: (ctx) => { ctx.highlight = {[node.id]:'visited'}; ctx.message = `Visited ${node.value}`; }
        }));
        steps.push({label:'Not found', action:(ctx)=>{ ctx.highlight={}; ctx.message = `Value ${value} not found`; }});
        return steps;
      }
      // To animate delete we will perform deletion immediately but keep steps describing the path and highlight the node to be deleted.
      const steps = [];
      s.path.forEach(node => steps.push({label:`Visit ${node.value}`, action:(ctx)=>{ ctx.highlight={[node.id]:'visited'}; ctx.message=`Visited ${node.value}`; }}));
      steps.push({label:`Delete ${value}`, action:(ctx)=>{ ctx.highlight={[s.node.id]:'deleted'}; ctx.message=`Deleting ${value}`; }});
      // perform deletion after the highlight step by adding a step that actually mutates the tree
      steps.push({label:`Apply deletion`, action:(ctx)=>{ const res = tree.delete(value); ctx.highlight={}; ctx.message = `Deleted ${value}`; scheduleRender(); }});
      return steps;
    }

    // Step executor
    function runStep(){
      if (stepIndex >= currentSteps.length) {
        stopPlaying();
        return;
      }
      const step = currentSteps[stepIndex];
      const ctx = { highlight: {}, message: '' };
      // perform step action (may mutate tree and call render)
      try {
        step.action(ctx);
      } catch (err) {
        console.error(err);
      }
      // apply highlight temporarily and render
      renderTree(ctx.highlight);
      if (ctx.message) log(ctx.message);
      stepIndex++;
      if (stepIndex >= currentSteps.length) {
        stopPlaying();
      }
    }

    function play(){
      if (playing) return;
      playing = true;
      const speed = Number(document.getElementById('speed').value) || 800;
      playTimer = setInterval(()=> {
        if (stepIndex >= currentSteps.length) {
          stopPlaying();
          return;
        }
        runStep();
      }, speed);
      document.getElementById('playBtn').textContent = 'Pause';
    }

    function stopPlaying(){
      playing = false;
      if (playTimer) clearInterval(playTimer);
      playTimer = null;
      document.getElementById('playBtn').textContent = 'Play';
    }

    function resetSteps(){
      currentSteps = [];
      stepIndex = 0;
      stopPlaying();
    }

    // Wire controls
    document.getElementById('insertBtn').addEventListener('click', ()=> {
      const val = Number(document.getElementById('valueInput').value);
      if (!Number.isFinite(val) || Number.isNaN(val)) { log('Enter a valid number to insert.'); return; }
      resetSteps();
      currentSteps = stepsForInsert(val);
      stepIndex = 0;
      if (currentSteps.length === 0) { scheduleRender(); return; }
      runStep();
    });
    document.getElementById('searchBtn').addEventListener('click', ()=> {
      const val = Number(document.getElementById('valueInput').value);
      if (!Number.isFinite(val) || Number.isNaN(val)) { log('Enter a valid number to search.'); return; }
      resetSteps();
      currentSteps = stepsForSearch(val);
      stepIndex = 0;
      if (currentSteps.length === 0) return;
      runStep();
    });
    document.getElementById('deleteBtn').addEventListener('click', ()=> {
      const val = Number(document.getElementById('valueInput').value);
      if (!Number.isFinite(val) || Number.isNaN(val)) { log('Enter a valid number to delete.'); return; }
      resetSteps();
      currentSteps = stepsForDelete(val);
      stepIndex = 0;
      if (currentSteps.length === 0) return;
      runStep();
    });
    document.getElementById('stepBtn').addEventListener('click', ()=> {
      if (!currentSteps.length) { log('No active operation. Start Insert/Search/Delete first.'); return; }
      if (stepIndex >= currentSteps.length) { log('Operation completed.'); return; }
      runStep();
    });
    document.getElementById('playBtn').addEventListener('click', ()=> {
      if (!currentSteps.length) { log('No active operation. Start Insert/Search/Delete first.'); return; }
      if (playing) stopPlaying(); else play();
    });

    document.getElementById('resetBtn').addEventListener('click', ()=> {
      // clear entire tree
      tree.root = null;
      tree.size = 0;
      resetSteps();
      log('Cleared tree.');
      scheduleRender();
      logEl.scrollTop = 0;
    });

    document.getElementById('randomBtn').addEventListener('click', ()=> {
      const v = Math.floor(Math.random()*99)+1;
      document.getElementById('valueInput').value = v;
      document.getElementById('insertBtn').click();
    });

    document.getElementById('bulkBtn').addEventListener('click', ()=> {
      // add a small batch for quick demo
      const sample = [50, 30, 70, 20, 40, 60, 80];
      let i = 0;
      function addNext(){
        if (i >= sample.length) { scheduleRender(); return; }
        const v = sample[i++];
        document.getElementById('valueInput').value = v;
        const steps = stepsForInsert(v);
        // perform all steps immediately to quickly build tree (no step-through)
        steps.forEach(step => step.action({}));
        scheduleRender();
        setTimeout(addNext, 120);
      }
      addNext();
      log('Bulk inserted demo values.');
    });

    document.getElementById('speed').addEventListener('input', ()=> {
      if (playing){
        stopPlaying();
        play();
      }
    });

    zoom.addEventListener('input', ()=> {
      const z = Number(zoom.value);
      zoomVal.textContent = z + '%';
      svg.style.transform = `scale(${z/100})`;
      svg.style.transformOrigin = '0 0';
    });

    // Keyboard shortcuts for accessibility
    document.addEventListener('keydown', (e)=> {
      if (e.key === 'Enter') {
        // Enter in input triggers insert
        const active = document.activeElement;
        if (active && active.id === 'valueInput') {
          document.getElementById('insertBtn').click();
        }
      }
    });

    // initial render empty
    scheduleRender();

    // Add some initial demo nodes
    (function seedDemo(){
      const demo = [50, 30, 70, 20, 40, 60, 80];
      demo.forEach(v => {
        // directly insert into tree without animation
        const r = tree.insert(v);
        if (r.created) {} // noop
      });
      log('Loaded demo tree (balanced set). Use input controls to explore.');
      scheduleRender();
    })();

  </script>
</body>
</html>