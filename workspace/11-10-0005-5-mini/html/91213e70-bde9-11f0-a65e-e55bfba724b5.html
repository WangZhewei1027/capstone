<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K-Nearest Neighbors (KNN) Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent-a: #3b82f6; /* blue */
      --accent-b: #fb923c; /* orange */
      --accent-q: #a78bfa; /* purple for query when ambiguous */
      --glass: rgba(255,255,255,0.03);
      --success: #10b981;
      --danger: #ef4444;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#061226 0%, #071425 100%);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins */
    .app {
      box-sizing: border-box;
      padding: var(--safe-margin);
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    /* Container */
    .module {
      width: min(1200px, 100%);
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
    }

    /* Responsive stack on narrow screens */
    @media (max-width: 880px){
      .module {
        grid-template-columns: 1fr;
      }
    }

    /* Left panel (controls + concept text) */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height: 520px;
    }

    .header {
      display:flex;
      gap: 12px;
      align-items:flex-start;
    }

    .title {
      font-size: 18px;
      font-weight: 600;
      line-height: 1.1;
    }

    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin-top: 2px;
    }

    .section {
      background: rgba(255,255,255,0.01);
      border-radius: 10px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    label{
      font-size: 13px;
      color: #d6e3f3;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .row {
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .btn, button {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef6;
      padding: 8px 10px;
      border-radius: 8px;
      cursor:pointer;
      font-size: 13px;
      min-height: 40px;
    }

    .btn:focus, button:focus {
      outline: 2px solid rgba(99,102,241,0.22);
      outline-offset: 2px;
    }

    .btn.primary {
      background: linear-gradient(90deg,var(--accent-a), #7c3aed);
      border:none;
      box-shadow: 0 6px 18px rgba(59,130,246,0.12);
    }

    .btn.ghost {
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }

    .small {
      font-size: 13px;
      padding: 6px 8px;
      min-height: 36px;
    }

    /* Slider */
    .sliderRow {
      display:flex;
      gap: 12px;
      align-items:center;
    }

    input[type="range"]{
      width: 100%;
    }

    .legend {
      display:flex;
      gap: 12px;
      align-items:center;
      font-size: 13px;
      color: var(--muted);
    }

    .swatch {
      width:14px;
      height:14px;
      border-radius: 4px;
      display:inline-block;
      margin-right:6px;
      border: 1px solid rgba(0,0,0,0.2);
    }

    /* Right panel (canvas + info) */
    .canvasCard {
      background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 14px;
      border: 1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .canvasWrap {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 10px;
      position:relative;
      overflow:hidden;
      min-height: 520px;
    }

    canvas {
      display:block;
      width:100%;
      height:100%;
      background: linear-gradient(180deg,#052032 0%, #052236 100%);
    }

    .inspector {
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      padding-top:6px;
    }

    .infoBlock {
      font-size: 13px;
      color: var(--muted);
    }

    .neighborsList {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 8px;
      font-size: 13px;
      color: #e6eef6;
      max-height: 160px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.02);
    }

    .neighborItem {
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      padding:6px 8px;
      border-radius:6px;
    }

    .neighborItem:hover {
      background: rgba(255,255,255,0.01);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .kbd {
      display:inline-block;
      padding: 4px 6px;
      border-radius:6px;
      background: rgba(255,255,255,0.02);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:12px;
    }

    footer .muted {
      font-size:12px;
    }

    /* Accessibility helpers */
    .sr-only {
      position:absolute;
      left:-10000px;
      width:1px;
      height:1px;
      overflow:hidden;
    }

    /* Spacing helper to enforce min spacing between interactive elems */
    .controlGroup { display:flex; gap: var(--gap); flex-wrap:wrap; }

  </style>
</head>
<body>
  <main class="app" role="main">
    <section class="module" aria-labelledby="mod-title">

      <!-- Left: Controls & Concept Description -->
      <aside class="panel" aria-labelledby="mod-title">
        <div class="header" id="mod-title">
          <div style="flex:1">
            <div class="title">K-Nearest Neighbors (KNN) — Interactive Explorer</div>
            <div class="subtitle">Discover how K affects classification and how distance & weighting change predictions.</div>
          </div>
        </div>

        <!-- Concept Text (required sections) -->
        <div class="section" aria-labelledby="concept-heading">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;">
            <div>
              <div id="concept-heading" style="font-weight:600">Concept Overview</div>
              <div class="muted" style="margin-top:6px;font-size:13px;">
                The K-Nearest Neighbors algorithm classifies a query by looking at the K closest labeled examples.
              </div>
            </div>
          </div>

          <div style="font-size:13px;margin-top:10px;">
            <strong>Concept Title:</strong>
            <div class="muted" style="margin-top:6px;">K-Nearest Neighbors (KNN) classification — local voting based on distance</div>

            <div style="margin-top:12px"><strong>Learning Objective:</strong>
              <div class="muted" style="margin-top:6px;">
                After interacting you'll understand how K, distance metric, and weighting affect the chosen neighbors,
                the predicted label, and classifier confidence. You'll be able to see neighbor selection animated and experiment with noisy labels.
              </div>
            </div>

            <div style="margin-top:12px"><strong>Interaction Design:</strong>
              <div class="muted" style="margin-top:6px;">
                - Click on the canvas to add training points for Class A (blue) or Class B (orange).<br>
                - Switch to "Query" mode and click to place a query point (purple). Drag points to reposition them.<br>
                - Use the K slider to change the number of neighbors and the distance metric toggle to switch between Euclidean and Manhattan.<br>
                - Press "Find Neighbors" (or toggle animations) to see an expanding search circle that highlights the K nearest neighbors and shows the predicted label and confidence.<br>
                - Toggle weighting to see uniform voting vs. distance-weighted voting.
              </div>
            </div>

            <div style="margin-top:12px"><strong>Layout Description:</strong>
              <div class="muted" style="margin-top:6px;">
                Left column contains controls and explanatory content. Right column contains the interactive plot canvas and runtime inspector:
                neighbor list, predicted label, and controls. The safe area uses 24px margins; controls maintain at least 16px gaps.
                The design is responsive — columns stack vertically on narrow screens. All interactive elements are reachable by keyboard focus and have clear visual focus states.
              </div>
            </div>
          </div>
        </div>

        <!-- Controls -->
        <div class="section" aria-labelledby="controls-heading">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div id="controls-heading" style="font-weight:600">Controls</div>
            <div class="muted" style="font-size:12px;">Click canvas to add points • Drag to move</div>
          </div>

          <div class="controls">

            <div class="controlGroup" role="group" aria-label="Point class and modes">
              <div style="display:flex;flex-direction:column;min-width:140px;">
                <label for="classSelect">Active class</label>
                <select id="classSelect" style="padding:8px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);">
                  <option value="A">Class A (blue)</option>
                  <option value="B">Class B (orange)</option>
                </select>
              </div>

              <div style="display:flex;flex-direction:column;min-width:140px;">
                <label for="modeSelect">Mode</label>
                <select id="modeSelect" style="padding:8px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);">
                  <option value="add">Add training points</option>
                  <option value="query">Place/move query</option>
                  <option value="delete">Delete points</option>
                </select>
              </div>
            </div>

            <div>
              <label for="kRange">K neighbors: <span id="kValue">3</span></label>
              <div class="sliderRow" style="align-items:center;">
                <input id="kRange" type="range" min="1" max="15" value="3" step="1" aria-label="Number of neighbors K">
              </div>
            </div>

            <div class="row">
              <div style="display:flex;gap:10px;align-items:center">
                <label style="font-size:13px">Distance</label>
                <label><input type="radio" name="dist" value="euclid" checked> Euclidean</label>
                <label><input type="radio" name="dist" value="manhattan"> Manhattan</label>
              </div>
            </div>

            <div class="row">
              <label><input type="checkbox" id="weightToggle"> Distance-weighted voting</label>
              <label style="margin-left:8px;"><input type="checkbox" id="animToggle" checked> Animate search</label>
            </div>

            <div class="row" style="margin-top:6px;">
              <button id="findBtn" class="btn primary" aria-label="Find neighbors">Find Neighbors</button>
              <button id="clearBtn" class="btn ghost" aria-label="Clear all training points">Clear points</button>
              <button id="resetBtn" class="btn" aria-label="Reset everything">Reset</button>
            </div>

            <div class="muted" style="font-size:12px;">
              Tips: Use keyboard Tab to focus controls. On small screens the layout stacks.
            </div>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div class="muted">Built with plain HTML/CSS/JS • No libraries</div>
          <div style="font-size:12px;color:var(--muted)">Interaction: click, drag, slider</div>
        </div>
      </aside>

      <!-- Right: Canvas & Inspector -->
      <main class="canvasCard" aria-live="polite">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
          <div style="display:flex;gap:12px;align-items:center;">
            <div class="legend">
              <span class="swatch" style="background:var(--accent-a)"></span> Class A
              <span style="width:12px;"></span>
              <span class="swatch" style="background:var(--accent-b)"></span> Class B
              <span style="width:12px;"></span>
              <span class="swatch" style="background:var(--accent-q)"></span> Query
            </div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <div class="infoBlock">Prediction:
              <span id="predLabel" style="font-weight:700;margin-left:8px;">—</span>
            </div>
            <div class="infoBlock muted" id="confidence">Confidence: —</div>
          </div>
        </div>

        <div class="canvasWrap" id="canvasWrap" role="application" aria-label="KNN plot area">
          <canvas id="plotCanvas" width="800" height="600" tabindex="0"></canvas>
        </div>

        <div class="inspector">
          <div style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-weight:600">Nearest Neighbors</div>
              <div class="muted" id="neighborCount">0 points</div>
            </div>

            <div class="neighborsList" id="neighborsList" aria-live="polite" aria-atomic="true">
              <div class="muted">No query placed yet.</div>
            </div>
          </div>

          <div style="width:220px;display:flex;flex-direction:column;gap:8px;">
            <div style="font-size:13px;color:var(--muted);">Quick actions</div>
            <button id="randomBtn" class="btn small" aria-label="Add random training points">Add 6 random points</button>
            <button id="flipLabelBtn" class="btn small" aria-label="Flip labels of nearest neighbors">Flip labels of neighbors</button>
            <button id="explainBtn" class="btn small" aria-label="Explain prediction">Explain prediction</button>
          </div>
        </div>
      </main>

    </section>
  </main>

  <script>
    /*
      KNN Interactive Module
      - Click canvas to add training points (mode: add)
      - Mode: query to place/move query point
      - Slider to change K
      - Distance metric: Euclidean or Manhattan
      - Toggle distance-weighted voting
      - "Find Neighbors" animates expanding search circle
      - Drag training points or query
      - Delete mode to remove points
    */

    (function(){
      // DOM refs
      const canvas = document.getElementById('plotCanvas');
      const ctx = canvas.getContext('2d');
      const kRange = document.getElementById('kRange');
      const kValue = document.getElementById('kValue');
      const classSelect = document.getElementById('classSelect');
      const modeSelect = document.getElementById('modeSelect');
      const weightToggle = document.getElementById('weightToggle');
      const animToggle = document.getElementById('animToggle');
      const findBtn = document.getElementById('findBtn');
      const clearBtn = document.getElementById('clearBtn');
      const resetBtn = document.getElementById('resetBtn');
      const neighborsList = document.getElementById('neighborsList');
      const predLabel = document.getElementById('predLabel');
      const confidenceEl = document.getElementById('confidence');
      const neighborCount = document.getElementById('neighborCount');
      const randomBtn = document.getElementById('randomBtn');
      const flipLabelBtn = document.getElementById('flipLabelBtn');
      const explainBtn = document.getElementById('explainBtn');

      // Visual params
      const COLORS = { A: '#3b82f6', B: '#fb923c', Q: '#a78bfa' };
      const POINT_RADIUS = 8;
      const HIGHLIGHT_STROKE = 'rgba(250,250,250,0.9)';
      const SEARCH_STROKE = 'rgba(167,139,250,0.28)';

      // State
      let dpr = Math.max(1, window.devicePixelRatio || 1);
      let data = []; // training points: {id, x, y, cls}
      let query = null; // {x,y}
      let nextId = 1;
      let dragging = null; // {type:'point'|'query', id}
      let dragOffset = {x:0,y:0};
      let animState = null; // for expanding circle animation
      let currentNeighbors = []; // [{point, dist}...]
      let maxCanvasSize = {w:800,h:600};

      // Accessibility labels
      canvas.setAttribute('aria-describedby','controls-heading');

      // Resize & scaling
      function resizeCanvas(){
        const wrap = document.getElementById('canvasWrap');
        const rect = wrap.getBoundingClientRect();
        const cssW = Math.max(320, rect.width);
        const cssH = Math.max(360, rect.height);
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        draw();
      }
      window.addEventListener('resize', () => {
        dpr = Math.max(1, window.devicePixelRatio || 1);
        resizeCanvas();
      });

      // Utilities: map client coords to canvas coordinates
      function clientToCanvas(clientX, clientY){
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left);
        const y = (clientY - rect.top);
        return {x, y};
      }

      function distEuclid(a,b){
        const dx = a.x-b.x, dy = a.y-b.y;
        return Math.hypot(dx,dy);
      }

      function distManhattan(a,b){
        return Math.abs(a.x-b.x) + Math.abs(a.y-b.y);
      }

      function distance(a,b, metric){
        return metric === 'manhattan' ? distManhattan(a,b) : distEuclid(a,b);
      }

      // Drawing
      function clearCanvas(){
        ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
      }

      function drawGrid(){
        const w = canvas.width/dpr, h = canvas.height/dpr;
        const step = 40;
        ctx.save();
        ctx.globalAlpha = 0.06;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        for(let x=0;x<w;x+=step){
          ctx.beginPath();
          ctx.moveTo(x+0.5,0);
          ctx.lineTo(x+0.5,h);
          ctx.stroke();
        }
        for(let y=0;y<h;y+=step){
          ctx.beginPath();
          ctx.moveTo(0,y+0.5);
          ctx.lineTo(w,y+0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawPoints(highlightIds = new Set(), searchRadius = null){
        // training points
        for(const p of data){
          ctx.beginPath();
          ctx.fillStyle = (p.cls === 'A') ? COLORS.A : COLORS.B;
          ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI*2);
          ctx.fill();
          if(highlightIds.has(p.id)){
            ctx.lineWidth = 3;
            ctx.strokeStyle = HIGHLIGHT_STROKE;
            ctx.stroke();
          } else {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.stroke();
          }
        }

        // query point
        if(query){
          // predicted class color
          const label = getPredictionLabel();
          const color = label === 'A' ? COLORS.A : label === 'B' ? COLORS.B : COLORS.Q;
          ctx.save();
          ctx.translate(query.x, query.y);
          ctx.rotate(0.0);
          ctx.fillStyle = color;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1.5;
          // draw crosshair
          ctx.beginPath();
          ctx.moveTo(-10,0); ctx.lineTo(10,0);
          ctx.moveTo(0,-10); ctx.lineTo(0,10);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0,0,10,0,Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }

        // search circle
        if(searchRadius !== null && query){
          ctx.save();
          ctx.beginPath();
          ctx.strokeStyle = SEARCH_STROKE;
          ctx.lineWidth = 2;
          ctx.setLineDash([6,6]);
          ctx.arc(query.x, query.y, searchRadius, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawLegend(){
        // optional: draw small labels
      }

      function draw(){
        clearCanvas();
        drawGrid();
        // compute highlight ids
        const highlightIds = new Set(currentNeighbors.map(n => n.point.id));
        const radius = animState && animState.animating ? animState.currentRadius : null;
        drawPoints(highlightIds, radius);
      }

      // Data operations
      function addPoint(x,y,cls){
        const p = {id: nextId++, x: Math.round(x), y: Math.round(y), cls};
        data.push(p);
        draw();
        return p;
      }

      function clearPoints(){
        data = [];
        query = null;
        currentNeighbors = [];
        updateInspector();
        draw();
      }

      function resetAll(){
        data = [];
        query = null;
        currentNeighbors = [];
        animState = null;
        updateInspector();
        draw();
      }

      function findKNeighbors(k, metric){
        if(!query) return [];
        const arr = data.map(p => ({point: p, dist: distance(p, query, metric)}));
        arr.sort((a,b) => a.dist - b.dist);
        return arr.slice(0, k);
      }

      function getPredictionLabel(){
        if(!query) return null;
        const k = Number(kRange.value);
        if(data.length === 0) return null;
        const neighbors = currentNeighbors.length ? currentNeighbors : findKNeighbors(k, getMetric());
        if(neighbors.length === 0) return null;
        const weighted = weightToggle.checked;
        const eps = 1e-6;
        const tally = {A:0, B:0};
        for(const n of neighbors){
          const cls = n.point.cls;
          if(weighted){
            const w = 1 / (n.dist + eps);
            tally[cls] += w;
          } else {
            tally[cls] += 1;
          }
        }
        if(tally.A > tally.B) return 'A';
        if(tally.B > tally.A) return 'B';
        return null; // tie -> ambiguous
      }

      function getConfidence(){
        if(!query) return null;
        const neighbors = currentNeighbors.length ? currentNeighbors : findKNeighbors(Number(kRange.value), getMetric());
        if(neighbors.length === 0) return null;
        const weighted = weightToggle.checked;
        const eps = 1e-6;
        const tally = {A:0, B:0};
        for(const n of neighbors){
          const cls = n.point.cls;
          if(weighted){
            const w = 1 / (n.dist + eps);
            tally[cls] += w;
          } else {
            tally[cls] += 1;
          }
        }
        const total = tally.A + tally.B;
        if(total === 0) return 0;
        const major = Math.max(tally.A, tally.B);
        return major / total;
      }

      function updateInspector(){
        // neighbors list
        if(!query){
          neighborsList.innerHTML = '<div class="muted">No query placed yet.</div>';
          predLabel.textContent = '—';
          confidenceEl.textContent = 'Confidence: —';
          neighborCount.textContent = data.length + (data.length === 1 ? ' point' : ' points');
          return;
        }
        const k = Number(kRange.value);
        if(data.length === 0){
          neighborsList.innerHTML = '<div class="muted">No training points.</div>';
          predLabel.textContent = '—';
          confidenceEl.textContent = 'Confidence: —';
          neighborCount.textContent = '0 points';
          return;
        }
        const neighbors = currentNeighbors.length ? currentNeighbors : findKNeighbors(k, getMetric());
        neighborCount.textContent = neighbors.length + ' neighbors';
        // list
        neighborsList.innerHTML = '';
        for(const n of neighbors){
          const row = document.createElement('div');
          row.className = 'neighborItem';
          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.alignItems = 'center';
          left.style.gap = '8px';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = n.point.cls === 'A' ? COLORS.A : COLORS.B;
          left.appendChild(sw);
          const txt = document.createElement('div');
          txt.innerHTML = `<div style="font-weight:600">id:${n.point.id}</div><div class="muted" style="font-size:12px">(${Math.round(n.point.x)},${Math.round(n.point.y)})</div>`;
          left.appendChild(txt);
          row.appendChild(left);
          const right = document.createElement('div');
          right.style.textAlign = 'right';
          right.innerHTML = `<div style="font-weight:700">${n.dist.toFixed(2)}</div><div class="muted" style="font-size:12px">dist</div>`;
          row.appendChild(right);
          neighborsList.appendChild(row);
        }

        // prediction
        const label = getPredictionLabel();
        if(label === 'A' || label === 'B'){
          predLabel.textContent = label === 'A' ? 'Class A' : 'Class B';
          predLabel.style.color = label === 'A' ? COLORS.A : COLORS.B;
        } else {
          predLabel.textContent = 'Ambiguous';
          predLabel.style.color = COLORS.Q;
        }
        const conf = getConfidence();
        confidenceEl.textContent = 'Confidence: ' + (conf === null ? '—' : (conf*100).toFixed(1) + '%');
      }

      function getMetric(){
        const radios = document.getElementsByName('dist');
        for(const r of radios) if(r.checked) return r.value;
        return 'euclid';
      }

      // Animation: expand circle until includes k neighbors
      function animateSearch(){
        if(!query) return;
        const k = Number(kRange.value);
        if(data.length === 0) return;
        const metric = getMetric();
        const neighborsAll = data.map(p => ({point:p, dist:distance(p, query, metric)}));
        neighborsAll.sort((a,b)=>a.dist-b.dist);
        const targetDist = neighborsAll[Math.min(k-1, neighborsAll.length-1)].dist;
        animState = {
          animating: animToggle.checked,
          startTime: null,
          duration: Math.min(900, Math.max(300, targetDist*3)), // scale
          currentRadius: 0,
          target: targetDist
        };

        if(!animState.animating){
          // no animation: set neighbors directly
          currentNeighbors = neighborsAll.slice(0, k);
          updateInspector();
          draw();
          return;
        }

        // perform frame animation
        function step(ts){
          if(!animState.startTime) animState.startTime = ts;
          const elapsed = ts - animState.startTime;
          const t = Math.min(1, elapsed / animState.duration);
          animState.currentRadius = animState.target * easeOutCubic(t);
          // update current neighbors by radius threshold
          const within = neighborsAll.filter(n => n.dist <= animState.currentRadius + 1e-6);
          // ensure we pick up to k nearest if radius surpasses next neighbor
          let selected;
          if(within.length >= k) {
            selected = neighborsAll.slice(0,k);
          } else {
            selected = within;
          }
          currentNeighbors = selected;
          updateInspector();
          draw();
          if(t < 1){
            requestAnimationFrame(step);
          } else {
            // finished: ensure final selection of k neighbors
            currentNeighbors = neighborsAll.slice(0, k);
            animState.animating = false;
            updateInspector();
            draw();
          }
        }
        requestAnimationFrame(step);
      }

      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }

      // Event handlers for interactions
      canvas.addEventListener('mousedown', (ev) => {
        const pos = clientToCanvas(ev.clientX, ev.clientY);
        const mode = modeSelect.value;
        if(mode === 'add'){
          addPoint(pos.x, pos.y, classSelect.value);
          updateInspector();
          return;
        }
        if(mode === 'delete'){
          // find nearest point within hit radius
          const hit = findPointNear(pos.x,pos.y, POINT_RADIUS+6);
          if(hit){
            data = data.filter(p => p.id !== hit.id);
            if(query && query.id === hit.id) query = null;
            updateInspector();
            draw();
          }
          return;
        }
        if(mode === 'query'){
          // check if clicked on existing training point: start dragging that
          const pointHit = findPointNear(pos.x,pos.y, POINT_RADIUS+4);
          if(pointHit){
            // start dragging training point
            dragging = {type:'point', id: pointHit.id};
            dragOffset.x = pointHit.x - pos.x;
            dragOffset.y = pointHit.y - pos.y;
            return;
          }
          // else if clicking near existing query, start dragging query
          if(query){
            const qdist = Math.hypot(query.x - pos.x, query.y - pos.y);
            if(qdist <= POINT_RADIUS+8){
              dragging = {type:'query'};
              dragOffset.x = query.x - pos.x;
              dragOffset.y = query.y - pos.y;
              return;
            }
          }
          // place new query
          query = {x: pos.x, y: pos.y};
          // compute neighbors
          animateSearch();
          return;
        }
      });

      canvas.addEventListener('mousemove', (ev) => {
        if(!dragging) return;
        const pos = clientToCanvas(ev.clientX, ev.clientY);
        if(dragging.type === 'point'){
          const p = data.find(pp => pp.id === dragging.id);
          if(p){
            p.x = Math.max(8, Math.min(canvas.width/dpr - 8, pos.x + dragOffset.x));
            p.y = Math.max(8, Math.min(canvas.height/dpr - 8, pos.y + dragOffset.y));
            draw();
            updateInspector();
          }
        } else if(dragging.type === 'query'){
          query.x = Math.max(8, Math.min(canvas.width/dpr - 8, pos.x + dragOffset.x));
          query.y = Math.max(8, Math.min(canvas.height/dpr - 8, pos.y + dragOffset.y));
          // update neighbors live (no animation)
          currentNeighbors = findKNeighbors(Number(kRange.value), getMetric());
          updateInspector();
          draw();
        }
      });

      window.addEventListener('mouseup', () => {
        if(dragging){
          // finalize
          dragging = null;
          // if query moved, maybe animate search?
          if(query){
            animateSearch();
          }
        }
      });

      // keyboard: place query with spacebar when canvas focused
      canvas.addEventListener('keydown', (ev) => {
        if(ev.key === ' '){
          ev.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const center = {x: rect.width/2, y: rect.height/2};
          query = {x: center.x, y: center.y};
          animateSearch();
        }
      });

      function findPointNear(x,y, radius){
        let best = null;
        let bestDist = Infinity;
        for(const p of data){
          const d = Math.hypot(p.x - x, p.y - y);
          if(d < bestDist && d <= radius){
            best = p;
            bestDist = d;
          }
        }
        return best;
      }

      // Control events
      kRange.addEventListener('input', () => {
        kValue.textContent = kRange.value;
        // recompute neighbors
        if(query){
          animateSearch();
        }
      });

      findBtn.addEventListener('click', () => {
        if(!query){
          // place default query at center
          const rect = canvas.getBoundingClientRect();
          query = {x: rect.width/2, y: rect.height/2};
        }
        animateSearch();
      });

      clearBtn.addEventListener('click', () => {
        data = [];
        currentNeighbors = [];
        updateInspector();
        draw();
      });

      resetBtn.addEventListener('click', () => {
        resetAll();
        // also reset controls to defaults
        kRange.value = 3;
        kValue.textContent = '3';
        classSelect.value = 'A';
        modeSelect.value = 'add';
        weightToggle.checked = false;
        animToggle.checked = true;
      });

      randomBtn.addEventListener('click', () => {
        // add 6 random points near clusters
        const w = canvas.width/dpr, h = canvas.height/dpr;
        for(let i=0;i<3;i++){
          const x = Math.random()*w*0.5 + 40;
          const y = Math.random()*h*0.5 + 40;
          addPoint(x,y,'A');
        }
        for(let i=0;i<3;i++){
          const x = Math.random()*w*0.5 + w*0.45;
          const y = Math.random()*h*0.5 + h*0.45;
          addPoint(x,y,'B');
        }
        updateInspector();
      });

      flipLabelBtn.addEventListener('click', () => {
        // flip labels of current neighbors
        if(!query) return;
        const toFlip = currentNeighbors.map(n => n.point.id);
        for(const p of data){
          if(toFlip.includes(p.id)){
            p.cls = p.cls === 'A' ? 'B' : 'A';
          }
        }
        updateInspector();
        draw();
      });

      explainBtn.addEventListener('click', () => {
        // simple explanation: show which neighbors vote and weight
        if(!query) return;
        const neighbors = currentNeighbors.length ? currentNeighbors : findKNeighbors(Number(kRange.value), getMetric());
        if(neighbors.length === 0){
          alert('No neighbors to explain.');
          return;
        }
        let msg = 'Explanation of prediction:\\n';
        msg += `K = ${Number(kRange.value)}\\nDistance metric = ${getMetric()}\\nWeighted = ${weightToggle.checked ? 'yes' : 'no'}\\n\\nNeighbors (closest first):\\n`;
        const eps = 1e-6;
        for(const n of neighbors){
          const w = weightToggle.checked ? (1/(n.dist+eps)).toFixed(3) : '1';
          msg += `id:${n.point.id} cls:${n.point.cls} dist:${n.dist.toFixed(2)} weight:${w}\\n`;
        }
        const label = getPredictionLabel();
        msg += `\\nPredicted: ${label ? (label === 'A' ? 'Class A' : 'Class B') : 'Ambiguous'}\\nConfidence: ${getConfidence()===null ? '—' : (getConfidence()*100).toFixed(1) + '%'}`;
        // Use a more accessible dialog
        alert(msg);
      });

      // initial setup
      function init(){
        resizeCanvas();
        // default random seed points
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        addPoint(w*0.2, h*0.35, 'A');
        addPoint(w*0.25, h*0.45, 'A');
        addPoint(w*0.18, h*0.6, 'A');
        addPoint(w*0.7, h*0.4, 'B');
        addPoint(w*0.78, h*0.55, 'B');
        addPoint(w*0.63, h*0.62, 'B');
        updateInspector();
      }
      init();

      // redraw loop for safety (debounced)
      let redrawT = null;
      function drawDebounced(){
        if(redrawT) cancelAnimationFrame(redrawT);
        redrawT = requestAnimationFrame(draw);
      }

      // keyboard accessibility for buttons: Enter triggers
      [findBtn, clearBtn, resetBtn, randomBtn, flipLabelBtn, explainBtn].forEach(b => {
        b.addEventListener('keyup', (e) => {
          if(e.key === 'Enter') b.click();
        });
      });

      // observe control changes to recompute if necessary
      [document.getElementsByName('dist'), weightToggle].forEach(n => {
        if(n instanceof NodeList || Array.isArray(n)) {
          n.forEach(r => r.addEventListener('change', () => { if(query) animateSearch(); }));
        } else {
          n.addEventListener('change', () => { if(query) animateSearch(); });
        }
      });

      // initial draw
      draw();

      // expose some helpers for debugging (optional)
      window.__knnState = {
        data,
        get query(){ return query; },
        addPoint: (x,y,cls) => addPoint(x,y,cls),
        findKNeighbors: (k, metric) => { return findKNeighbors(k, metric); }
      };
    })();
  </script>
</body>
</html>