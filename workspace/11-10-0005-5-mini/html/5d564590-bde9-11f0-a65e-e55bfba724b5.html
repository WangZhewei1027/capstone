<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bubble Sort — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #0b1320;
      --muted: #94a3b8;
      --accent: #06b6d4;
      --success: #10b981;
      --danger: #ef4444;
      --compare: #f59e0b;
      --glass: rgba(255,255,255,0.04);
      --radius: 10px;
    }

    /* Safe area margins */
    html,body{height:100%; background:linear-gradient(180deg,#071021 0%, #071428 100%); margin:0; padding:var(--safe-margin); font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; color:#e6eef6; box-sizing:border-box; -webkit-font-smoothing:antialiased;}
    *{box-sizing:inherit}

    /* Layout */
    .container{
      max-width:1200px;
      margin:0 auto;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    /* Responsive stacking */
    @media (max-width:900px){
      .container{flex-direction:column;}
    }

    /* Left: Visualization panel */
    .viz-panel{
      flex:1 1 60%;
      min-height:340px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:var(--radius);
      padding:20px;
      position:relative;
    }

    .title{
      margin:0 0 8px 0;
      font-size:20px;
      font-weight:700;
      letter-spacing:0.2px;
    }
    .subtitle{margin:0 0 16px 0; color:var(--muted); font-size:13px}

    /* Bars area */
    .bars-wrap{
      position:relative;
      height:260px;
      margin-top:12px;
      margin-bottom:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      overflow:visible;
    }
    .slots{
      position:absolute;
      inset:12px;
      display:block;
      overflow:visible;
      background:transparent;
    }
    .bar{
      position:absolute;
      bottom:12px;
      width:40px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      transition:transform 360ms cubic-bezier(.2,.9,.2,1), background-color 200ms, height 360ms;
      transform-origin:center bottom;
      border-radius:6px;
      padding:6px 4px 6px 4px;
      gap:6px;
      cursor:default;
      user-select:none;
    }
    .bar .val{
      font-size:13px;
      color:#021122;
      font-weight:700;
      line-height:1;
      text-shadow:0 1px 0 rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.92);
      padding:6px 8px;
      border-radius:6px;
    }
    .bar .label{
      color:var(--muted);
      font-size:12px;
      margin-top:6px;
    }

    .bar.default{ background:linear-gradient(180deg, rgba(6,182,212,0.92), rgba(6,182,212,0.82)); }
    .bar.comparing{ background:linear-gradient(180deg, rgba(245,158,11,0.95), rgba(245,158,11,0.85)); }
    .bar.swapping{ background:linear-gradient(180deg, rgba(239,68,68,0.95), rgba(239,68,68,0.8)); }
    .bar.sorted{ background:linear-gradient(180deg, rgba(16,185,129,0.94), rgba(16,185,129,0.84)); color:#021122; }

    /* Right: Controls and pseudocode */
    .side-panel{
      width:360px;
      max-width:42%;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    @media (max-width:900px){
      .side-panel{width:auto; max-width:none;}
    }

    .controls{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center; }
    .btn{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent);
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      min-width:48px;
      text-align:center;
      font-weight:600;
      transition:transform 120ms;
    }
    .btn:active{ transform:scale(.98); }
    .btn.primary{ background:linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06)); color:var(--accent); border-color:rgba(6,182,212,0.16); }
    .btn.warn{ color:var(--compare); }
    .btn.danger{ color:var(--danger); }

    .control-group{ display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap; }

    label{ font-size:13px; color:var(--muted); }
    .small{ font-size:13px; color:var(--muted); }

    input[type="number"], input[type="text"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent);
      padding:8px 10px;
      border-radius:8px;
      width:140px;
    }
    input[type="range"]{ width:140px; }

    .stats{ display:flex; gap:12px; flex-wrap:wrap; }
    .stat{
      background:var(--glass);
      padding:8px 10px;
      border-radius:8px;
      min-width:92px;
      text-align:center;
    }
    .stat .num{ font-weight:700; color:var(--accent); font-size:16px; }
    .pseudocode{
      background:rgba(0,0,0,0.08);
      padding:12px;
      border-radius:8px;
      font-family:monospace;
      font-size:13px;
      color:var(--muted);
      max-height:240px;
      overflow:auto;
    }
    .line{ padding:6px; border-radius:6px; }
    .line.active{ background:rgba(6,182,212,0.12); color:var(--accent); font-weight:700; }
    .line.note{ color:var(--muted); font-style:italic; font-size:13px;}

    .info{ font-size:13px; color:var(--muted); line-height:1.35; }
    .footer{ font-size:12px; color:var(--muted); }

    /* Accessibility focus */
    .btn:focus, input:focus{
      outline:3px solid rgba(6,182,212,0.14);
      outline-offset:2px;
    }

    /* Spacing rules: ensure min spacing between interactive elements */
    .controls > * { margin:0; }
    .controls > * + * { margin-left:0; }

    /* aria-live status */
    .sr-only{ position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
  </style>
</head>
<body>
  <div class="container" role="main">
    <!-- Left: Explanation + Visualization -->
    <section class="viz-panel" aria-labelledby="concept-title">
      <h1 id="concept-title" class="title">Bubble Sort — Visual Explorer</h1>
      <p class="subtitle">Watch comparisons and swaps as Bubble Sort orders an array step by step.</p>

      <!-- Design description required by the prompt -->
      <div class="info" style="margin-bottom:12px;">
        <strong>Learning Objective:</strong>
        <div style="margin-top:6px;">
          Interactively learn how Bubble Sort repeatedly compares adjacent items, swaps them when out of order, and gradually places the largest (or smallest) elements into their final positions. After using this module you will recognize the compare-swap pattern, observe worst/best-case behavior, and relate the animation to the algorithm's pseudocode.
        </div>
      </div>

      <div class="bars-wrap" id="barsWrap" aria-hidden="false">
        <div class="slots" id="slots"></div>
      </div>

      <div style="display:flex; gap:16px; align-items:center; justify-content:space-between; margin-top:12px;">
        <div class="small">Pass: <span id="passNum">0</span> • Comparisons: <span id="cmpCount">0</span> • Swaps: <span id="swapCount">0</span></div>
        <div class="small" id="statusText" aria-live="polite">Ready</div>
      </div>
    </section>

    <!-- Right: Controls, pseudocode, inputs -->
    <aside class="side-panel" aria-labelledby="controls-title">
      <h2 id="controls-title" class="title" style="font-size:16px; margin:0;">Controls & Pseudocode</h2>
      <div class="subtitle" style="margin-top:4px;">Interact to step through Bubble Sort. Use Play to animate.</div>

      <div class="controls" role="group" aria-label="Simulation controls">
        <div class="control-group">
          <button id="shuffleBtn" class="btn" title="Shuffle array">Shuffle</button>
          <button id="resetBtn" class="btn" title="Reset to original">Reset</button>
        </div>

        <div class="control-group">
          <button id="stepBtn" class="btn primary" title="Perform one algorithm step">Step</button>
          <button id="playBtn" class="btn primary" title="Play / Pause">Play</button>
        </div>

        <div class="control-group" style="margin-left:auto;">
          <label for="speedRange" class="small" style="margin-right:8px;">Speed</label>
          <input id="speedRange" type="range" min="1" max="1000" value="400" aria-label="Animation speed">
        </div>
      </div>

      <div class="controls" style="margin-top:4px;">
        <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
          <label for="arrInput" class="small">Custom array (comma separated)</label>
          <input id="arrInput" type="text" value="5,3,8,1,7" aria-label="Custom array input">
          <button id="applyBtn" class="btn">Apply</button>
        </div>
      </div>

      <div class="controls">
        <div style="display:flex; gap:12px; align-items:center;">
          <label class="small"><input id="orderToggle" type="checkbox" aria-label="Sort ascending" checked> Ascending</label>
          <label class="small" style="margin-left:12px;"><input id="optToggle" type="checkbox" aria-label="Optimize bubble sort"> Optimized</label>
        </div>
      </div>

      <div class="controls" style="margin-top:0;">
        <div class="stat" title="Number of elements"><div class="small">Elements</div><div class="num" id="nCount">5</div></div>
        <div class="stat" title="Current pass number"><div class="small">Current Pass</div><div class="num" id="passCount">0</div></div>
        <div class="stat" title="Completed passes"><div class="small">Sorted Items</div><div class="num" id="sortedCount">0</div></div>
      </div>

      <div>
        <div class="small" style="margin-bottom:8px;">Pseudocode</div>
        <div class="pseudocode" id="pseudocode" role="region" aria-label="Bubble sort pseudocode">
          <div class="line" data-line="1">for i from 0 to n-2</div>
          <div class="line" data-line="2">  for j from 0 to n-2-i</div>
          <div class="line" data-line="3">    if A[j] > A[j+1]         // compare</div>
          <div class="line" data-line="4">      swap(A[j], A[j+1])    // swap</div>
          <div class="line" data-line="5">  end for</div>
          <div class="line" data-line="6">end for</div>
          <div class="line note" style="margin-top:8px;">(If 'Optimized' is on, stop early when no swaps occur in a pass.)</div>
        </div>
      </div>

      <div style="margin-top:8px;">
        <div class="small" style="margin-bottom:6px;">Explanation</div>
        <div class="info">Each animation step highlights the compared pair in orange. If they are out of order (relative to the selected direction), they turn red while swapping. Elements that reach their final position are marked green. Observe how the largest unsorted elements "bubble" to the end on each pass.</div>
      </div>

      <div class="footer" style="margin-top:8px;">Keyboard: Tab into controls, use Enter/Space on buttons. This module uses only standard web APIs.</div>
    </aside>
  </div>

  <div class="sr-only" aria-live="polite" id="ariaStatus">Ready</div>

  <script>
    /*****************************************************************************
     * Bubble Sort Interactive Module
     * - Single-file vanilla JS, CSS, and HTML
     * - Visualizes comparisons, swaps, and sorted region
     * - Supports step, play/pause, shuffle, reset, custom input, speed control
     * - Highlights pseudocode lines to map animation to algorithm
     *****************************************************************************/

    (function(){
      // UI references
      const slots = document.getElementById('slots');
      const barsWrap = document.getElementById('barsWrap');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const resetBtn = document.getElementById('resetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const speedRange = document.getElementById('speedRange');
      const arrInput = document.getElementById('arrInput');
      const applyBtn = document.getElementById('applyBtn');
      const orderToggle = document.getElementById('orderToggle');
      const optToggle = document.getElementById('optToggle');
      const nCount = document.getElementById('nCount');
      const passCount = document.getElementById('passCount');
      const sortedCount = document.getElementById('sortedCount');
      const passNum = document.getElementById('passNum');
      const cmpCount = document.getElementById('cmpCount');
      const swapCount = document.getElementById('swapCount');
      const statusText = document.getElementById('statusText');
      const ariaStatus = document.getElementById('ariaStatus');
      const pseudocode = document.getElementById('pseudocode');

      // State
      let arr = [5,3,8,1,7];
      let originalArr = arr.slice();
      let items = []; // DOM elements for bars
      let playing = false;
      let generator = null;
      let currentAction = null;
      let counts = { comparisons:0, swaps:0, passes:0 };
      let sortedBoundary = arr.length; // index from which items are sorted (exclusive)
      let speed = Number(speedRange.value); // ms between steps
      let ascending = true;
      let optimized = false;
      let scheduled = null;

      // Layout variables for positioning bars
      let containerWidth = 0;
      function computeLayout(){
        const rect = slots.getBoundingClientRect();
        containerWidth = rect.width;
      }

      // Utility: sleep but allows immediate cancellation by checking 'playing' if needed
      function wait(ms){
        return new Promise(resolve => {
          scheduled = setTimeout(()=>{ scheduled = null; resolve(); }, ms);
        });
      }

      // Render items into DOM (create or update)
      function renderItems(){
        // compute layout
        computeLayout();
        const n = arr.length;
        const slotWidth = Math.max(48, Math.floor((containerWidth - 12) / Math.max(1,n)));
        // create elements if needed
        while(items.length < n){
          const el = document.createElement('div');
          el.className = 'bar default';
          el.setAttribute('role','listitem');
          el.innerHTML = '<div class="val">0</div>';
          slots.appendChild(el);
          items.push(el);
        }
        while(items.length > n){
          const rem = items.pop();
          slots.removeChild(rem);
        }

        nCount.textContent = n;
        // update positions and heights
        const maxVal = Math.max(...arr.map(v=>Math.abs(v)), 1);
        const maxBarHeight = Math.max(32, slots.clientHeight - 36);
        arr.forEach((v, idx) => {
          const el = items[idx];
          el.style.width = (slotWidth - 8) + 'px';
          const height = Math.max(24, Math.round((Math.abs(v) / maxVal) * maxBarHeight));
          el.style.height = (height + 12) + 'px';
          el.style.transform = `translateX(${idx * slotWidth}px)`;
          el.dataset.index = idx;
          el.querySelector('.val').textContent = String(v);
          // Reset classes
          el.className = 'bar default';
          if (idx >= sortedBoundary) el.classList.add('sorted');
        });

        // update sortedCount
        sortedCount.textContent = Math.max(0, arr.length - sortedBoundary);
      }

      // Pseudocode highlighting
      function highlightLine(lineNum){
        Array.from(pseudocode.querySelectorAll('.line')).forEach(el=>{
          if (Number(el.dataset.line) === lineNum) el.classList.add('active');
          else el.classList.remove('active');
        });
      }

      // Generator: yields step actions for bubble sort
      function* bubbleSortGenerator(a, asc=true, opt=false){
        const n = a.length;
        // Outer loop: passes
        for (let i = 0; i < n - 1; i++){
          let swapped = false;
          yield { type:'passStart', pass:i, n:n };
          // Inner loop
          for (let j = 0; j < n - 1 - i; j++){
            yield { type:'compare', i:j, j:j+1 };
            if ((asc && a[j] > a[j+1]) || (!asc && a[j] < a[j+1])){
              yield { type:'swap', i:j, j:j+1 };
              // perform actual swap in the array copy used by the generator consumer
              const tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;
              swapped = true;
            }
          }
          yield { type:'passEnd', pass:i, swapped:swapped };
          if (opt && !swapped){
            // Early termination
            break;
          }
        }
        yield { type:'finished' };
      }

      // Apply a single action to UI and state
      async function applyAction(action){
        currentAction = action;
        if (!action) return;
        switch(action.type){
          case 'passStart':
            counts.passes = action.pass + 1;
            passNum.textContent = counts.passes;
            passCount.textContent = counts.passes;
            statusText.textContent = `Starting pass ${action.pass}`;
            ariaStatus.textContent = statusText.textContent;
            // highlight pseudocode lines 1-2
            highlightLine(1);
            break;

          case 'compare':
            counts.comparisons++;
            cmpCount.textContent = counts.comparisons;
            statusText.textContent = `Comparing indices ${action.i} and ${action.j}`;
            ariaStatus.textContent = statusText.textContent;
            // visual highlight compare
            clearBarStates();
            setBarState(action.i, 'comparing');
            setBarState(action.j, 'comparing');
            // pseudocode line 3
            highlightLine(3);
            break;

          case 'swap':
            counts.swaps++;
            swapCount.textContent = counts.swaps;
            statusText.textContent = `Swapping indices ${action.i} and ${action.j}`;
            ariaStatus.textContent = statusText.textContent;
            // set swapping state; swap values in our visible array and animate by re-rendering transforms
            // We need to swap values in arr to reflect the generator's expectation. The generator itself also updated its internal a,
            // but our arr must match that. To keep them in sync, the code that created the generator passed a copy; here we must perform swap.
            setBarState(action.i, 'swapping');
            setBarState(action.j, 'swapping');
            await performSwap(action.i, action.j);
            // pseudocode line 4
            highlightLine(4);
            break;

          case 'passEnd':
            statusText.textContent = `Pass ${action.pass} ended${action.swapped ? '' : ' (no swaps)'} `;
            ariaStatus.textContent = statusText.textContent;
            // mark last element of the pass as sorted
            const sortedIndex = arr.length - 1 - action.pass;
            markSortedFrom(sortedIndex);
            passCount.textContent = counts.passes;
            // pseudocode line 5
            highlightLine(5);
            break;

          case 'finished':
            statusText.textContent = 'Finished sorting!';
            ariaStatus.textContent = statusText.textContent;
            markSortedFrom(0);
            highlightLine(6);
            playing = false;
            updatePlayButton();
            break;
        }
      }

      // Set visual state for a bar at index
      function setBarState(idx, stateClass){
        if (idx < 0 || idx >= items.length) return;
        items[idx].classList.remove('default','comparing','swapping','sorted');
        items[idx].classList.add(stateClass);
      }

      // Clear temporary classes (comparing/swapping) but keep sorted
      function clearBarStates(){
        items.forEach((el, idx)=>{
          if (!el.classList.contains('sorted')){
            el.classList.remove('comparing','swapping');
            el.classList.add('default');
          }
        });
      }

      // Swap two positions in arr and animate by updating transforms
      async function performSwap(i,j){
        // swap values in arr
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        // trigger re-render (positions update with CSS transitions)
        renderItems();
        // Wait for animation time based on speed; ensure minimum so users see it
        await wait(Math.max(120, 800 - speed));
      }

      // Mark elements from index onward as sorted
      function markSortedFrom(index){
        sortedBoundary = index;
        renderItems();
      }

      // Step controller: fetch next action from generator and apply
      async function stepOnce(){
        if (!generator){
          // create a new generator based on current arr
          generator = bubbleSortGenerator(arr.slice(), ascending, optimized);
        }
        const res = generator.next();
        if (res.done){
          // nothing
          return;
        }
        await applyAction(res.value);
      }

      // Play loop: repeatedly step with delay
      async function playLoop(){
        if (playing === false) return;
        // ensure generator exists
        if (!generator) generator = bubbleSortGenerator(arr.slice(), ascending, optimized);
        let res = generator.next();
        if (res.done){
          // finished, ensure finish action applied
          await applyAction({type:'finished'});
          playing = false;
          updatePlayButton();
          return;
        }
        await applyAction(res.value);
        // If we reached finished inside applyAction, stop
        if (!playing) return;
        // schedule next step
        const delay = Math.max(40, 1100 - speed); // speedRange 1..1000 mapped
        await wait(delay);
        if (playing) playLoop();
      }

      // UI helpers
      function updatePlayButton(){
        playBtn.textContent = playing ? 'Pause' : 'Play';
        playBtn.classList.toggle('primary', playing);
      }

      function shuffleArray(){
        // Fisher-Yates shuffle
        for (let i = arr.length-1; i>0; i--){
          const j = Math.floor(Math.random() * (i+1));
          const tmp = arr[i]; arr[i]=arr[j]; arr[j]=tmp;
        }
        originalArr = arr.slice();
        resetCounts();
        renderItems();
      }

      function resetToOriginal(){
        arr = originalArr.slice();
        resetCounts();
        sortedBoundary = arr.length;
        renderItems();
      }

      function resetCounts(){
        counts = { comparisons:0, swaps:0, passes:0 };
        cmpCount.textContent = '0';
        swapCount.textContent = '0';
        passNum.textContent = '0';
        passCount.textContent = '0';
        sortedCount.textContent = '0';
      }

      // Start/stop playing
      function togglePlay(){
        playing = !playing;
        updatePlayButton();
        statusText.textContent = playing ? 'Playing...' : 'Paused';
        ariaStatus.textContent = statusText.textContent;
        if (playing){
          // If generator is null or done, re-create to continue from current arr
          if (!generator) generator = bubbleSortGenerator(arr.slice(), ascending, optimized);
          playLoop();
        } else {
          // cancel scheduled timeout if any
          if (scheduled) { clearTimeout(scheduled); scheduled = null; }
        }
      }

      // Apply custom input array
      function applyCustomArray(){
        const raw = arrInput.value.trim();
        if (!raw) return;
        // parse numbers separated by commas or spaces
        const vals = raw.split(/[\s,]+/).map(s => Number(s)).filter(n => !Number.isNaN(n));
        if (vals.length === 0) return;
        arr = vals.slice(0, 20); // limit to 20 elements to keep UI sane
        originalArr = arr.slice();
        resetCounts();
        sortedBoundary = arr.length;
        generator = null;
        renderItems();
      }

      // Mark elements at or after index as sorted
      function markSorted(index){
        for (let k = index; k < items.length; k++){
          items[k].classList.remove('default','comparing','swapping');
          items[k].classList.add('sorted');
        }
      }
      function markSortedFrom(index){
        // mark indices index..end as sorted
        sortedBoundary = index;
        items.forEach((el, idx)=>{
          if (idx >= index){
            el.classList.remove('default','comparing','swapping');
            el.classList.add('sorted');
          } else {
            if (el.classList.contains('sorted')) el.classList.remove('sorted');
            el.classList.add('default');
          }
        });
        sortedCount.textContent = Math.max(0, arr.length - sortedBoundary);
      }

      // Clear any running generator and stop animation
      function resetGenerator(){
        generator = null;
        playing = false;
        updatePlayButton();
        if (scheduled){ clearTimeout(scheduled); scheduled = null; }
      }

      // Event bindings
      shuffleBtn.addEventListener('click', ()=>{ shuffleArray(); resetGenerator(); statusText.textContent='Shuffled'; ariaStatus.textContent='Array shuffled'; });
      resetBtn.addEventListener('click', ()=>{ resetToOriginal(); resetGenerator(); statusText.textContent='Reset'; ariaStatus.textContent='Reset to original'; });
      stepBtn.addEventListener('click', async ()=>{
        // If playing, pause
        if (playing){
          togglePlay();
        }
        await stepOnce();
      });
      playBtn.addEventListener('click', ()=>{ togglePlay(); });

      speedRange.addEventListener('input', ()=>{
        speed = Number(speedRange.value);
      });

      applyBtn.addEventListener('click', ()=>{
        applyCustomArray();
      });

      arrInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){ applyCustomArray(); }
      });

      orderToggle.addEventListener('change', (e)=>{
        ascending = e.target.checked;
        resetGenerator();
        statusText.textContent = ascending ? 'Ascending' : 'Descending';
      });

      optToggle.addEventListener('change', (e)=>{
        optimized = e.target.checked;
        resetGenerator();
        statusText.textContent = optimized ? 'Optimization ON' : 'Optimization OFF';
      });

      // Handle resizing for layout recalculation
      window.addEventListener('resize', ()=>{
        computeLayout();
        renderItems();
      });

      // Initial render
      function init(){
        // Respect safe spacing: ensure controls have at least var(--gap) between them - handled by CSS gap.
        originalArr = arr.slice();
        renderItems();
        highlightLine(0);
        statusText.textContent = 'Ready';
        ariaStatus.textContent = 'Ready';
      }

      // Initialize module
      init();

      // Expose some debug for console (optional)
      window.__bubbleSortModule = {
        getArray: ()=>arr.slice(),
        reset: resetToOriginal,
        shuffle: shuffleArray
      };
    })();
  </script>
</body>
</html>