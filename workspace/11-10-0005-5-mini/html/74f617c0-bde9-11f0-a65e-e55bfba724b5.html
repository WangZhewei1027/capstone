<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Linked List Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #2dd4bf;
      --muted: #93c5fd;
      --node-bg: #111827;
      --node-border: #334155;
      --node-highlight: #0ea5a1;
      --text: #e6eef8;
      --glass: rgba(255,255,255,0.02);
      --success: #10b981;
      --danger: #ef4444;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071029 0%, #071a2b 60%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }

    .title{
      display:flex;
      gap:12px;
      align-items:baseline;
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }

    .subtitle{
      color:var(--muted);
      font-size:13px;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      flex:1;
      min-height:360px;
    }

    /* Left column: description + controls */
    .left{
      width:360px;
      min-width:280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border:1px solid rgba(255,255,255,0.03);
    }

    .section{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .label{
      font-weight:600;
      font-size:13px;
      color:var(--muted);
    }

    .text{
      font-size:13px;
      line-height:1.35;
      color: #cfe8ff;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .input-row{
      display:flex;
      gap:8px;
      align-items:center;
    }

    input[type="text"], input[type="number"], select{
      padding:10px 12px;
      font-size:14px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.02);
      color:var(--text);
      outline:none;
      min-width:0;
    }

    button{
      padding:10px 12px;
      border-radius:8px;
      border:none;
      background:var(--accent);
      color:#042029;
      font-weight:700;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
    }

    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--text);
      font-weight:600;
    }

    button.danger{
      background:var(--danger);
      color:#fff;
    }

    button:active{ transform:scale(.99); }
    button:focus{ outline:3px solid rgba(45,212,191,0.12); }

    .row{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .small{
      padding:8px 10px;
      font-size:13px;
    }

    .muted{
      color: #9fb7cf;
      font-size:13px;
    }

    /* Right column: visual canvas */
    .right{
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .canvas{
      flex:1;
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:8px;
      padding:12px;
      min-height:240px;
      overflow:auto;
    }

    .nodes{
      position:relative;
      display:flex;
      gap:20px;
      align-items:center;
      padding:12px;
      min-height:140px;
      flex-wrap:wrap;
      transition:height .2s ease;
    }

    /* Node visuals */
    .node{
      --w:110px;
      display:flex;
      gap:0;
      align-items:center;
      transform-origin:center;
      transition:transform .28s cubic-bezier(.2,.8,.2,1), opacity .18s ease;
      opacity:1;
    }

    .card{
      width:var(--w);
      min-width:var(--w);
      height:56px;
      background:var(--node-bg);
      border:1px solid var(--node-border);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px;
      box-sizing:border-box;
      color:var(--text);
      position:relative;
      box-shadow: 0 6px 18px rgba(2,6,23,0.4);
    }

    .val{
      font-weight:700;
      font-size:16px;
      color:var(--muted);
      padding-left:6px;
    }

    .ptr{
      width:38px;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }

    /* Arrow using SVG inside .arrow */
    .arrow {
      width:26px;
      height:26px;
      display:block;
      opacity:0.9;
    }

    /* small index badge */
    .idx{
      position:absolute;
      left:8px;
      top:-10px;
      background:var(--glass);
      border-radius:6px;
      padding:4px 6px;
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    .node.current .card{
      border-color:var(--node-highlight);
      box-shadow:0 8px 24px rgba(14,165,161,0.12), inset 0 0 18px rgba(14,165,161,0.02);
      transform:translateY(-6px) scale(1.02);
    }

    .node.removing{
      opacity:0;
      transform:translateY(12px) scale(.96);
      pointer-events:none;
    }

    .node.hidden{
      opacity:0.16;
      transform:scale(.98);
    }

    /* Head pointer */
    .head-pointer{
      position:absolute;
      top:6px;
      left:12px;
      display:flex;
      align-items:center;
      gap:8px;
      transition:transform .36s cubic-bezier(.2,.8,.2,1);
      pointer-events:none;
    }

    .head-label{
      background:linear-gradient(90deg, rgba(45,212,191,0.12), rgba(14,165,161,0.06));
      color:var(--accent);
      padding:6px 8px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      border:1px solid rgba(45,212,191,0.06);
      box-shadow: 0 6px 18px rgba(14,165,161,0.04);
    }

    .head-rod{
      width:2px;
      height:48px;
      background:linear-gradient(180deg, rgba(45,212,191,0.95), rgba(14,165,161,0.85));
      transform-origin:top;
      border-radius:2px;
    }

    /* Current pointer (for traversal) */
    .curr-pointer{
      position:absolute;
      top:56px;
      left:12px;
      display:flex;
      align-items:center;
      gap:8px;
      pointer-events:none;
      transition:transform .36s cubic-bezier(.2,.8,.2,1);
    }

    .curr-label{
      background:linear-gradient(90deg, rgba(59,130,246,0.08), rgba(59,130,246,0.04));
      color:#93c5fd;
      padding:6px 8px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      border:1px solid rgba(59,130,246,0.04);
    }

    /* footer controls inside right */
    .play-controls{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }

    .mini{
      padding:8px 10px;
      font-size:13px;
    }

    .status{
      font-size:13px;
      color:var(--muted);
    }

    /* responsive */
    @media (max-width:880px){
      main{ flex-direction:column; }
      .left{ width:100%; min-width:0; }
    }

    /* accessibility focus outlines for interactive node actions */
    .node .card:focus{
      outline:3px solid rgba(99,102,241,0.12);
    }

    /* small helper text style */
    .hint{
      font-size:12px;
      color:#9fb7cf;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Linked List Interactive Module">
    <header>
      <div class="title">
        <h1>Linked List — Singly Linked List Interactive</h1>
        <div class="subtitle">visualize insert • append • delete • traverse</div>
      </div>
      <div class="subtitle">Safe margins: 24px • Spacing: 16px • Vanilla JS</div>
    </header>

    <main>
      <!-- Left column: explanations + controls -->
      <aside class="left" aria-label="Module controls and explanation">
        <div class="section">
          <div class="label">Concept Title</div>
          <div class="text">Singly Linked List — nodes with value and pointer to next node.</div>
        </div>

        <div class="section">
          <div class="label">Learning Objective</div>
          <div class="text">
            After interacting with this module you should be able to:
            1) visualize the head pointer and node links, 2) perform and observe insert-at-head, append, and delete operations, and 3) step through traversal to understand pointer movement and node visiting order.
          </div>
        </div>

        <div class="section controls" aria-hidden="false">
          <div class="label">Interaction Design (how to use)</div>
          <div class="text">
            - Enter a value and use "Insert Head" or "Append" to add nodes.<br>
            - Delete a node by index (0-based).<br>
            - Use "Traverse" controls to step through nodes: "Play" animates pointer visiting each node.<br>
            - Visual feedback: nodes animate into place, arrows reconnect, and the current node is highlighted during traversal.
          </div>
        </div>

        <div class="section">
          <div class="label">Controls</div>
          <div class="controls" role="form" aria-labelledby="controls-heading">
            <div class="input-row" style="gap:12px;">
              <input id="valInput" type="text" placeholder="node value (e.g. 42)" aria-label="Node value" />
              <button id="insertHeadBtn" class="small">Insert Head</button>
              <button id="appendBtn" class="small secondary">Append</button>
            </div>

            <div class="input-row" style="gap:8px;">
              <input id="delIndex" type="number" min="0" placeholder="index to delete" aria-label="Index to delete" />
              <button id="deleteBtn" class="small danger">Delete Index</button>
            </div>

            <div class="row" style="margin-top:6px;">
              <button id="resetBtn" class="small">Reset</button>
              <button id="randomBtn" class="small secondary">Randomize (3 nodes)</button>
              <div style="flex:1"></div>
              <div class="hint">Spacing rules enforced for accessibility</div>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="label">Traversal Controls</div>
          <div class="row" style="align-items:center;">
            <button id="traversePrev" class="small secondary">Prev</button>
            <button id="traversePlay" class="small">Play</button>
            <button id="traverseNext" class="small secondary">Next</button>
            <div style="flex:1"></div>
            <div class="status" id="traverseStatus">Position: -</div>
          </div>
          <div class="text" style="margin-top:6px;">
            Use these to move the "current" pointer one node at a time. Play will auto-advance and highlight nodes — observe how links remain unchanged.
          </div>
        </div>

        <div class="section">
          <div class="label">Layout Description</div>
          <div class="text">
            The page is split: left column contains controls and explanation, right column is the visual canvas showing the linked list. Safe margins are 24px and at least 16px separates controls. Canvas supports horizontal wrapping and scroll for many nodes. Keyboard accessible and responsive.
          </div>
        </div>

      </aside>

      <!-- Right column: visual interactive area -->
      <section class="right" aria-label="Linked list canvas and visualization">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="label">Visualization</div>
          <div class="muted">Nodes are shown left→right. Head points to first node.</div>
        </div>

        <div class="canvas" id="canvas" tabindex="0" aria-live="polite">
          <div class="head-pointer" id="headPointer" aria-hidden="true">
            <div class="head-label">HEAD</div>
            <div class="head-rod" id="headRod"></div>
          </div>

          <div class="curr-pointer" id="currPointer" aria-hidden="true">
            <div class="curr-label">CUR</div>
          </div>

          <div class="nodes" id="nodes" role="list" aria-label="Linked list nodes">
            <!-- nodes injected here -->
          </div>
        </div>

        <div class="play-controls">
          <div class="row">
            <div class="status" id="nodeCount">Nodes: 0</div>
            <div style="width:12px"></div>
            <div class="status" id="headIndex">Head: -</div>
          </div>
          <div style="display:flex;gap:12px;align-items:center;">
            <div class="muted">Animation hints: insertion slides, deletion fades, pointer smoothly moves.</div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /* Linked List Interactive Module (vanilla JS)
       - Maintains a logical singly linked list and a visual representation.
       - Supports: insert head, append, delete by index, traverse step/play.
       - Animations: CSS transitions; pointer elements reposition with transforms.
    */

    (function(){
      // Utility
      const $ = sel => document.querySelector(sel);
      const $$ = sel => Array.from(document.querySelectorAll(sel));
      const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

      // DOM
      const nodesEl = $('#nodes');
      const headPointer = $('#headPointer');
      const currPointer = $('#currPointer');
      const valInput = $('#valInput');
      const insertHeadBtn = $('#insertHeadBtn');
      const appendBtn = $('#appendBtn');
      const deleteBtn = $('#deleteBtn');
      const delIndex = $('#delIndex');
      const resetBtn = $('#resetBtn');
      const randomBtn = $('#randomBtn');
      const traversePrev = $('#traversePrev');
      const traversePlay = $('#traversePlay');
      const traverseNext = $('#traverseNext');
      const traverseStatus = $('#traverseStatus');
      const nodeCount = $('#nodeCount');
      const headIndex = $('#headIndex');
      const canvas = $('#canvas');

      // Data structure: array representing nodes in order, each node = {id, value}
      // The "linked" aspect is implied by order; we explicitly draw an arrow to next node.
      let list = [];
      let idCounter = 1;

      // Traversal state
      let currentPos = -1; // index of current pointer
      let playing = false;
      let playTimer = null;

      // Accessibility & focus: ensure spacing and keyboard usage
      valInput.addEventListener('keydown', (e)=> {
        if(e.key === 'Enter') { appendNode(); }
      });

      // Event handlers
      insertHeadBtn.addEventListener('click', insertHead);
      appendBtn.addEventListener('click', appendNode);
      deleteBtn.addEventListener('click', deleteByIndex);
      resetBtn.addEventListener('click', resetList);
      randomBtn.addEventListener('click', randomize);
      traversePrev.addEventListener('click', ()=> stepTraverse(-1));
      traverseNext.addEventListener('click', ()=> stepTraverse(1));
      traversePlay.addEventListener('click', togglePlay);

      // Initialize with a small sample
      function init(){
        resetList();
        // add two nodes to begin
        list = [
          {id: nextId(), value: 'A'},
          {id: nextId(), value: 'B'},
          {id: nextId(), value: 'C'}
        ];
        render();
        setCurrent(-1);
      }

      function nextId(){ return idCounter++; }

      // Core operations
      function insertHead(){
        const v = (valInput.value || '').trim();
        if(v === '') { alert('Enter a value to insert.'); valInput.focus(); return; }
        const node = { id: nextId(), value: v };
        // visually insert with animation preference: add DOM first hidden, then place at front
        list.unshift(node);
        render(true, {focusId: node.id, effect: 'insert'});
        valInput.value = '';
      }

      function appendNode(){
        const v = (valInput.value || '').trim();
        if(v === '') { alert('Enter a value to append.'); valInput.focus(); return; }
        const node = { id: nextId(), value: v };
        list.push(node);
        render(true, {focusId: node.id, effect: 'insert'});
        valInput.value = '';
      }

      function deleteByIndex(){
        const idx = parseInt(delIndex.value,10);
        if(Number.isNaN(idx)){ alert('Enter a numeric index (0-based).'); delIndex.focus(); return; }
        if(idx < 0 || idx >= list.length){ alert('Index out of range.'); delIndex.focus(); return; }
        // Remove logically and animate removal
        const removed = list.splice(idx,1)[0];
        render(true, {removeId: removed.id});
        delIndex.value = '';
        // If current pointer was pointing beyond new length, adjust
        if(currentPos >= list.length) setCurrent(list.length-1);
      }

      function resetList(){
        list = [];
        idCounter = 1;
        playing = false;
        stopPlay();
        render();
        setCurrent(-1);
      }

      function randomize(){
        resetList();
        const count = 3;
        for(let i=0;i<count;i++){
          list.push({id: nextId(), value: String.fromCharCode(65 + randInt(0,25))});
        }
        render(true, {effect: 'insert'});
      }

      // Rendering logic
      // options: {focusId, effect, removeId}
      function render(animate=false, options={}){
        // Update metadata
        nodeCount.textContent = `Nodes: ${list.length}`;
        headIndex.textContent = `Head: ${list.length ? 0 : '-'}`;

        // Save scroll position
        const prevScroll = canvas.scrollLeft;

        // Rebuild nodes DOM with keys
        // We'll diff simply by id and reuse nodes where possible for smoother transitions.
        const existing = new Map();
        Array.from(nodesEl.children).forEach(child => {
          const id = child.dataset.id;
          if(id) existing.set(id, child);
        });

        const newOrder = [];
        list.forEach((node, idx) => {
          let el = existing.get(String(node.id));
          if(!el){
            el = createNodeElement(node, idx);
            el.style.opacity = '0';
            el.style.transform = 'translateY(8px) scale(.98)';
          } else {
            // update value in case changed
            const valEl = el.querySelector('.val');
            if(valEl) valEl.textContent = node.value;
            el.dataset.idx = idx;
            el.querySelector('.idx').textContent = `i:${idx}`;
            existing.delete(String(node.id));
          }
          newOrder.push(el);
        });

        // Remaining nodes in existing map are removed; mark them removing
        existing.forEach((el, id) => {
          el.classList.add('removing');
          el.style.pointerEvents = 'none';
          setTimeout(()=> el.remove(), 420);
        });

        // Replace nodes container
        nodesEl.innerHTML = '';
        newOrder.forEach(el => nodesEl.appendChild(el));

        // After adding, update arrows (draw SVG) for links
        requestAnimationFrame(()=> {
          // Update arrow SVG inside each .arrow element to point to next; we draw a simple rightwards arrow.
          Array.from(nodesEl.children).forEach((nodeEl, i) => {
            const arrow = nodeEl.querySelector('svg.arrow');
            if(i < nodesEl.children.length - 1){
              arrow.style.opacity = '0.95';
            } else {
              // last node has a small "null" marker (empty)
              arrow.style.opacity = '0.24';
            }
          });

          // Insert animation for new nodes: fade in
          if(animate){
            const focusId = options.focusId;
            Array.from(nodesEl.children).forEach(child => {
              if(focusId && child.dataset.id == focusId){
                // emphasize inserted node momentarily
                child.style.transition = 'transform .36s cubic-bezier(.2,.8,.2,1), opacity .28s ease';
                child.style.opacity = '1';
                child.style.transform = 'translateY(0) scale(1)';
                child.classList.add('current'); // temporary glow
                setTimeout(()=> child.classList.remove('current'), 700);
              } else {
                child.style.transition = 'transform .28s cubic-bezier(.2,.8,.2,1), opacity .18s ease';
                child.style.opacity = '1';
                child.style.transform = 'translateY(0) scale(1)';
              }
            });
          } else {
            Array.from(nodesEl.children).forEach(child => {
              child.style.opacity = '1';
              child.style.transform = 'translateY(0) scale(1)';
              child.style.transition = '';
            });
          }

          // Reposition head and current pointer
          updateHeadPointer();
          updateCurrPointer();
          // restore scroll
          canvas.scrollLeft = prevScroll;
        });
      }

      // Create node DOM
      function createNodeElement(node, idx){
        const wrapper = document.createElement('div');
        wrapper.className = 'node';
        wrapper.dataset.id = node.id;
        wrapper.dataset.idx = idx;
        wrapper.setAttribute('role','listitem');
        wrapper.setAttribute('tabindex','-1');

        const idxBadge = document.createElement('div');
        idxBadge.className = 'idx';
        idxBadge.textContent = `i:${idx}`;

        const card = document.createElement('div');
        card.className = 'card';
        card.tabIndex = 0;
        const val = document.createElement('div');
        val.className = 'val';
        val.textContent = node.value;
        const ptr = document.createElement('div');
        ptr.className = 'ptr';

        // inline SVG arrow
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox','0 0 24 24');
        svg.setAttribute('class','arrow');
        svg.innerHTML = '<path d="M3 12h14" stroke="rgba(255,255,255,0.6)" stroke-width="1.8" stroke-linecap="round"/>' +
                        '<path d="M15 8l4 4-4 4" stroke="rgba(255,255,255,0.6)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>';
        ptr.appendChild(svg);

        card.appendChild(val);
        card.appendChild(ptr);
        wrapper.appendChild(idxBadge);
        wrapper.appendChild(card);

        // Click to focus/traverse to this node
        card.addEventListener('click', () => {
          const idx = parseInt(wrapper.dataset.idx,10);
          setCurrent(idx);
          // focus for keyboard users
          card.focus();
        });

        return wrapper;
      }

      // Head pointer positioning: move the head element above the first node
      function updateHeadPointer(){
        const first = nodesEl.children[0];
        if(!first){
          headPointer.style.opacity = '0.12';
          headPointer.style.transform = `translate3d(0px, 0px, 0)`; // put to top-left a bit
          return;
        }
        headPointer.style.opacity = '1';
        const rectCanvas = canvas.getBoundingClientRect();
        const rectNode = first.getBoundingClientRect();
        const offsetX = rectNode.left - rectCanvas.left + (rectNode.width/2) - 24;
        const offsetY = rectNode.top - rectCanvas.top - 48;
        headPointer.style.transform = `translate3d(${offsetX}px, ${offsetY}px, 0)`;
      }

      // Current pointer positioning: position above the current node
      function updateCurrPointer(){
        if(currentPos < 0 || currentPos >= nodesEl.children.length){
          currPointer.style.opacity = '0.08';
          traverseStatus.textContent = `Position: -`;
          return;
        }
        const nodeEl = nodesEl.children[currentPos];
        currPointer.style.opacity = '1';
        const rectCanvas = canvas.getBoundingClientRect();
        const rectNode = nodeEl.getBoundingClientRect();
        const offsetX = rectNode.left - rectCanvas.left + (rectNode.width/2) - 28;
        const offsetY = rectNode.top - rectCanvas.top + 10;
        currPointer.style.transform = `translate3d(${offsetX}px, ${offsetY}px, 0)`;
        traverseStatus.textContent = `Position: ${currentPos} (val: ${list[currentPos]?.value ?? '-'})`;

        // highlight node
        Array.from(nodesEl.children).forEach((n,i)=> {
          if(i === currentPos) n.classList.add('current');
          else n.classList.remove('current');
        });

        // ensure visible (scroll into view smoothly)
        const nodeRect = nodeEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        if(nodeRect.left < canvasRect.left + 8){
          canvas.scrollBy({left: nodeRect.left - canvasRect.left - 16, behavior:'smooth'});
        } else if(nodeRect.right > canvasRect.right - 8){
          canvas.scrollBy({left: nodeRect.right - canvasRect.right + 16, behavior:'smooth'});
        }
      }

      // Traversal controls
      function setCurrent(idx){
        if(idx < 0){
          currentPos = -1;
        } else {
          currentPos = Math.max(0, Math.min(list.length-1, idx));
        }
        updateCurrPointer();
      }

      function stepTraverse(dir = 1){
        if(list.length === 0){
          setCurrent(-1);
          return;
        }
        if(currentPos === -1){
          // start at head
          setCurrent(0);
        } else {
          const next = currentPos + dir;
          if(next < 0) setCurrent(0);
          else if(next >= list.length) setCurrent(list.length-1);
          else setCurrent(next);
        }
      }

      function togglePlay(){
        if(playing) stopPlay();
        else startPlay();
      }

      function startPlay(){
        if(list.length === 0) return;
        playing = true;
        traversePlay.textContent = 'Pause';
        if(currentPos === -1) setCurrent(0);
        playTimer = setInterval(()=> {
          if(currentPos >= list.length-1){
            stopPlay();
          } else {
            stepTraverse(1);
          }
        }, 900);
      }

      function stopPlay(){
        playing = false;
        traversePlay.textContent = 'Play';
        if(playTimer) clearInterval(playTimer);
        playTimer = null;
      }

      // Initialize and expose for debugging
      init();

      // Ensure resizing updates pointers smoothly
      window.addEventListener('resize', () => {
        updateHeadPointer();
        updateCurrPointer();
      });

      // Allow keyboard traversal: left/right arrows when canvas focused
      canvas.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowRight') { stepTraverse(1); e.preventDefault(); }
        if(e.key === 'ArrowLeft') { stepTraverse(-1); e.preventDefault(); }
        if(e.key === ' '){ togglePlay(); e.preventDefault(); }
      });

      // Public small helper for accessibility: clicking empty canvas sets current to -1
      canvas.addEventListener('click', (e) => {
        if(e.target === canvas || e.target === nodesEl) {
          setCurrent(-1);
        }
      });

      // Expose some functions for console (optional)
      window.__linkedListModule = {
        list,
        render,
        insertHead,
        appendNode,
        deleteByIndex,
        resetList,
        randomize,
        setCurrent
      };
    })();
  </script>
</body>
</html>