<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>冒泡排序可视化</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --good:#10b981;
      --bad:#ef4444;
      --compare:#f59e0b;
      --bar-bg:#e6eef8;
    }
    *{box-sizing:border-box;font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{
      margin:0;
      padding:20px;
      background:linear-gradient(180deg,var(--bg),#071028 140%);
      color:#e6eef8;
      min-height:100vh;
    }

    .app{
      max-width:1100px;
      margin:0 auto;
    }

    header{
      display:flex;
      align-items:center;
      gap:16px;
      margin-bottom:12px;
    }
    header h1{
      margin:0;
      font-size:20px;
    }
    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls > * {display:flex; align-items:center; gap:8px;}
    button{
      background:var(--accent);
      color:white;
      border:0;
      padding:8px 12px;
      border-radius:6px;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(59,130,246,0.12);
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 10px;
    }
    button.danger{
      background:var(--bad);
    }
    input[type="range"]{
      cursor:pointer;
    }
    .panel{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:12px;
      align-items:start;
    }
    .visual{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:320px;
    }
    .bars{
      display:flex;
      align-items:flex-end;
      gap:4px;
      height:320px;
      width:100%;
      padding:8px;
      background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent);
      border-radius:6px;
    }
    .bar{
      flex:1;
      background:var(--bar-bg);
      border-radius:4px 4px 2px 2px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#0b1220;
      font-weight:700;
      transition: height 180ms ease, background 180ms ease, transform 180ms ease;
      position:relative;
      user-select:none;
      cursor:pointer;
    }
    .bar span{
      transform:translateY(-6px);
      font-size:12px;
      color:rgba(11,18,32,0.9);
    }
    .legend{
      display:flex;
      gap:8px;
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }
    .legend > div{display:flex; gap:6px; align-items:center;}
    .chip{width:16px;height:12px;border-radius:3px;}
    .stats{
      display:flex;
      gap:12px;
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }

    aside{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      color:var(--muted);
    }
    .section{
      margin-bottom:12px;
    }
    label{font-size:13px;color:var(--muted);}
    .row{display:flex;gap:8px;align-items:center;margin-top:6px;}
    .pseudocode{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding:8px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.02);
      font-family: monospace;
      font-size:13px;
      color:var(--muted);
    }
    .line{
      padding:6px 8px;
      border-radius:4px;
    }
    .line.active{
      background:rgba(59,130,246,0.12);
      color:var(--accent);
      border-left:3px solid var(--accent);
      padding-left:6px;
    }
    .small{
      font-size:13px;
      color:var(--muted);
    }
    .footer{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }
    .flex-space{flex:1}
    .saved-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    @media (max-width:900px){
      .panel{grid-template-columns:1fr;}
      .bars{height:240px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>冒泡排序可视化</h1>
      <div class="small">演示冒泡排序算法，支持开始/暂停/单步/速度/数组大小控制</div>
    </header>

    <div class="controls">
      <div>
        <button id="btn-generate">生成随机数组</button>
        <button id="btn-start">开始</button>
        <button id="btn-pause" class="secondary">暂停</button>
        <button id="btn-step" class="secondary">单步</button>
        <button id="btn-reset" class="secondary">重置</button>
      </div>

      <div>
        <label>大小</label>
        <input id="size" type="range" min="5" max="80" value="30"/>
        <span id="size-val">30</span>
      </div>

      <div>
        <label>速度</label>
        <input id="speed" type="range" min="1" max="1000" value="200"/>
        <span id="speed-val">200 ms</span>
      </div>

      <div>
        <label>方向</label>
        <select id="order">
          <option value="asc">升序</option>
          <option value="desc">降序</option>
        </select>
      </div>

      <div class="flex-space"></div>

      <div class="saved-controls">
        <div class="small">比较: <strong id="comp">0</strong></div>
        <div class="small">交换: <strong id="swaps">0</strong></div>
        <div class="small">步数: <strong id="steps">0</strong></div>
      </div>
    </div>

    <div class="panel">
      <div class="visual">
        <div class="bars" id="bars" title="点击条形可以修改数值"></div>

        <div class="legend">
          <div><div class="chip" style="background:var(--compare)"></div><div>比较中</div></div>
          <div><div class="chip" style="background:var(--bad)"></div><div>正在交换</div></div>
          <div><div class="chip" style="background:var(--good)"></div><div>已排序</div></div>
        </div>

        <div class="stats">
          <div>数组长度: <strong id="nsize">0</strong></div>
          <div>当前 i: <strong id="cur-i">-</strong></div>
          <div>当前 j: <strong id="cur-j">-</strong></div>
          <div>已完成轮数: <strong id="passes">0</strong></div>
        </div>
      </div>

      <aside>
        <div class="section">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div><strong>伪代码</strong></div>
            <div class="small">当前高亮显示执行行</div>
          </div>
          <div class="pseudocode" id="pseudocode" style="margin-top:8px;">
            <div class="line" data-line="1">1. procedure bubbleSort(A)</div>
            <div class="line" data-line="2">2.   n = length(A)</div>
            <div class="line" data-line="3">3.   for i from 0 to n-2</div>
            <div class="line" data-line="4">4.     for j from 0 to n-i-2</div>
            <div class="line" data-line="5">5.       if A[j] &gt; A[j+1]</div>
            <div class="line" data-line="6">6.         swap A[j], A[j+1]</div>
            <div class="line" data-line="7">7.   end</div>
          </div>
        </div>

        <div class="section">
          <strong>说明</strong>
          <div class="small" style="margin-top:6px;">
            点击“生成随机数组”创建一个新的数组。点击条形可以修改该元素为随机值。可用“开始”开始自动可视化，使用“暂停”停止，“单步”逐步执行。
          </div>
        </div>

        <div class="section">
          <strong>快速提示</strong>
          <div class="small" style="margin-top:6px;">
            - 减小速度值会让可视化更快（ms延迟）。<br>
            - 改变大小会生成新的数组。<br>
            - 排序方向可切换升序/降序。
          </div>
        </div>
      </aside>
    </div>

    <div class="footer">
      演示仅用于学习目的 — 冒泡排序时间复杂度 O(n^2)。
    </div>
  </div>

  <script>
    (function(){
      // DOM elements
      const barsEl = document.getElementById('bars');
      const btnGenerate = document.getElementById('btn-generate');
      const btnStart = document.getElementById('btn-start');
      const btnPause = document.getElementById('btn-pause');
      const btnStep = document.getElementById('btn-step');
      const btnReset = document.getElementById('btn-reset');
      const sizeInput = document.getElementById('size');
      const sizeVal = document.getElementById('size-val');
      const speedInput = document.getElementById('speed');
      const speedVal = document.getElementById('speed-val');
      const orderSelect = document.getElementById('order');

      const compEl = document.getElementById('comp');
      const swapsEl = document.getElementById('swaps');
      const stepsEl = document.getElementById('steps');
      const nsizeEl = document.getElementById('nsize');
      const curIEl = document.getElementById('cur-i');
      const curJEl = document.getElementById('cur-j');
      const passesEl = document.getElementById('passes');

      const pseudoLines = Array.from(document.querySelectorAll('.pseudocode .line'));

      // state
      let arr = [];
      let bars = []; // DOM nodes
      let n = parseInt(sizeInput.value,10) || 30;
      let running = false;
      let sorting = false;
      let aborted = false;
      let stepRequested = false;
      let waitingResolve = null;
      let compareCount = 0;
      let swapCount = 0;
      let stepCount = 0;
      let passCount = 0;
      let currentI = null;
      let currentJ = null;

      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

      function createArray(len){
        const a = [];
        for(let i=0;i<len;i++) a.push(randInt(5,100));
        return a;
      }

      function renderArray(){
        barsEl.innerHTML='';
        bars = [];
        const maxVal = Math.max(...arr);
        arr.forEach((v,i)=>{
          const bar = document.createElement('div');
          bar.className='bar';
          bar.style.height = (v / maxVal * 100) + '%';
          bar.style.flex = (1).toString();
          bar.dataset.index = i;
          bar.innerHTML = '<span>' + v + '</span>';
          bar.title = '值: ' + v;
          bar.addEventListener('click', ()=> {
            if(sorting){ // if sorting, clicking won't change while running but allowed to change when paused
              if(running) return;
            }
            const newVal = randInt(5,100);
            arr[i] = newVal;
            updateBars();
          });
          barsEl.appendChild(bar);
          bars.push(bar);
        });
        nsizeEl.textContent = arr.length;
      }

      function updateBars(highlight = {}) {
        // highlight: {compare:[i,j], swap:[i,j], sorted: uptoIndex}
        const maxVal = Math.max(...arr);
        bars.forEach((bar, i) => {
          bar.style.height = (arr[i] / maxVal * 100) + '%';
          bar.querySelector('span').textContent = arr[i];
          bar.style.background = '';
          bar.style.transform = '';
          bar.style.zIndex = '0';
        });

        if(highlight.compare){
          highlight.compare.forEach(idx=>{
            if(bars[idx]) bars[idx].style.background = 'var(--compare)';
          });
        }
        if(highlight.swap){
          highlight.swap.forEach(idx=>{
            if(bars[idx]) {
              bars[idx].style.background = 'var(--bad)';
              bars[idx].style.transform = 'scale(1.03)';
              bars[idx].style.zIndex = '2';
            }
          });
        }
        if(typeof highlight.sorted === 'number'){
          for(let k=highlight.sorted;k<arr.length;k++){
            if(bars[k]) bars[k].style.background = 'var(--good)';
          }
        }
      }

      function setPseudoline(lineNum){
        pseudoLines.forEach(l=>{
          l.classList.toggle('active', parseInt(l.dataset.line,10)===lineNum);
        });
      }

      function resetStats(){
        compareCount=0; swapCount=0; stepCount=0; passCount=0;
        compEl.textContent = compareCount;
        swapsEl.textContent = swapCount;
        stepsEl.textContent = stepCount;
        passesEl.textContent = passCount;
        curIEl.textContent = '-';
        curJEl.textContent = '-';
      }

      function setControlsDuringRun(isRunning){
        btnStart.disabled = isRunning;
        btnGenerate.disabled = isRunning;
        sizeInput.disabled = isRunning;
        orderSelect.disabled = isRunning;
      }

      // wait mechanism: waits until user resumes or step requested
      function waitForStepOrResume(){
        // If running is true, proceed immediately but still delay to reflect speed
        const delay = Math.max(1, parseInt(speedInput.value,10));
        return new Promise(resolve => {
          // If running is false, store resolver and return when resumed/stepped
          if(!running){
            waitingResolve = () => {
              waitingResolve = null;
              // small animation delay then resolve
              setTimeout(resolve, delay);
            };
          } else {
            // if stepRequested true, we allow one step and then pause
            if(stepRequested){
              stepRequested = false;
              running = false; // pause after taking this step
              setTimeout(resolve, delay);
            } else {
              setTimeout(resolve, delay);
            }
          }
        });
      }

      // Controls
      btnGenerate.addEventListener('click', ()=>{
        aborted = true;
        running = false;
        sorting = false;
        arr = createArray(parseInt(sizeInput.value,10));
        renderArray();
        resetStats();
        setPseudoline(0);
      });

      btnReset.addEventListener('click', ()=>{
        aborted = true;
        running = false;
        sorting = false;
        arr = createArray(parseInt(sizeInput.value,10));
        renderArray();
        resetStats();
        setPseudoline(0);
      });

      sizeInput.addEventListener('input', ()=>{
        sizeVal.textContent = sizeInput.value;
      });

      sizeInput.addEventListener('change', ()=>{
        aborted = true;
        running = false;
        sorting = false;
        n = parseInt(sizeInput.value,10);
        arr = createArray(n);
        renderArray();
        resetStats();
        setPseudoline(0);
      });

      speedInput.addEventListener('input', ()=>{
        speedVal.textContent = speedInput.value + ' ms';
      });

      btnStart.addEventListener('click', async ()=>{
        if(sorting){
          running = true;
          // resume if paused
          if(waitingResolve) { waitingResolve(); }
          setControlsDuringRun(true);
          return;
        }
        // start new sort
        aborted = false;
        sorting = true;
        running = true;
        setControlsDuringRun(true);
        resetStats();
        await bubbleSortVisual(arr, orderSelect.value);
        sorting = false;
        running = false;
        setControlsDuringRun(false);
      });

      btnPause.addEventListener('click', ()=>{
        running = false;
        // do not resolve waiting; simply pause
        setControlsDuringRun(false);
      });

      btnStep.addEventListener('click', ()=>{
        // If not sorting yet, start sorting but immediately pause after first step.
        if(!sorting){
          // Start but set stepRequested so it runs one step then pauses
          sorting = true;
          running = true;
          stepRequested = true;
          setControlsDuringRun(true);
          // start the algorithm
          bubbleSortVisual(arr, orderSelect.value).then(()=>{
            sorting = false;
            running = false;
            setControlsDuringRun(false);
          });
          return;
        }
        // If waitingResolve exists, cause it to resolve once (single step)
        if(waitingResolve){
          waitingResolve();
        } else {
          // if currently running but we want exactly one step from paused state
          stepRequested = true;
          running = true;
        }
      });

      // initial array
      arr = createArray(n);
      renderArray();
      resetStats();

      // bubble sort visualization algorithm
      async function bubbleSortVisual(A, order='asc'){
        const cmp = (x,y) => (order==='asc' ? x>y : x<y);
        const len = A.length;
        nsizeEl.textContent = len;
        setPseudoline(1);
        await waitForStepOrResume(); if(aborted) return;

        setPseudoline(2);
        await waitForStepOrResume(); if(aborted) return;

        for(let i=0;i<len-1;i++){
          currentI = i;
          currentJ = null;
          passCount = i;
          passesEl.textContent = passCount;
          curIEl.textContent = i;
          setPseudoline(3);
          await waitForStepOrResume(); if(aborted) return;

          let swapped = false;
          for(let j=0;j<len-i-1;j++){
            currentJ = j;
            curJEl.textContent = j;
            // highlight compare
            setPseudoline(4);
            updateBars({compare:[j, j+1], sorted: len - i});
            await waitForStepOrResume(); if(aborted) return;

            setPseudoline(5);
            compareCount++;
            compEl.textContent = compareCount;
            stepCount++;
            stepsEl.textContent = stepCount;

            if(cmp(A[j], A[j+1])){
              // swap
              setPseudoline(6);
              swapCount++;
              swapsEl.textContent = swapCount;
              swapped = true;
              // highlight swap
              updateBars({swap:[j,j+1], sorted: len - i});
              await waitForStepOrResume(); if(aborted) return;

              // do actual swap (with animation via height change)
              const tmp = A[j];
              A[j] = A[j+1];
              A[j+1] = tmp;
              updateBars({swap:[j,j+1], sorted: len - i});
              await waitForStepOrResume(); if(aborted) return;
            } else {
              // not swapped, still show compare highlight briefly
              updateBars({compare:[j,j+1], sorted: len - i});
              await waitForStepOrResume(); if(aborted) return;
            }
            // after each inner iteration, clear highlights
            updateBars({sorted: len - i});
            await waitForStepOrResume(); if(aborted) return;
          }
          // after inner loop, mark last element as sorted (len-i-1)
          updateBars({sorted: len - i - 1});
          setPseudoline(7);
          await waitForStepOrResume(); if(aborted) return;

          if(!swapped){
            // array is sorted; mark all sorted
            updateBars({sorted:0});
            break;
          }
        }
        // finished
        updateBars({sorted:0});
        curIEl.textContent = '-';
        curJEl.textContent = '-';
        setPseudoline(0);
      }

      // If user clicks resume while waiting
      document.addEventListener('visibilitychange', ()=>{
        // no-op
      });

      // Allow keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.code==='Space'){
          e.preventDefault();
          if(running){ btnPause.click(); } else { btnStart.click(); }
        } else if(e.key==='ArrowRight'){
          btnStep.click();
        }
      });

      // If waitingResolve is present and user clicks resume or start
      // We already call waitingResolve in btnStart/btnStep handlers when appropriate.

      // Safety: when clicking generate or reset during waiting, ensure waiting resolves to stop pending promises
      const ensureResolveWaiting = () => {
        if(waitingResolve){ waitingResolve(); waitingResolve = null; }
      };

      btnGenerate.addEventListener('click', ensureResolveWaiting);
      btnReset.addEventListener('click', ensureResolveWaiting);
      btnPause.addEventListener('click', ensureResolveWaiting);

    })();
  </script>
</body>
</html>