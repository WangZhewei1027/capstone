{
  "id": "90f6f506-d5a1-11f0-80b9-e1f86cea383f",
  "timestamp": "2025-12-10T08:24:49.243Z",
  "type": "html-to-test",
  "htmlModel": "meta-llama/Llama-3.2-1B-Instruct",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Depth-First Search (DFS)</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            text-align: center;\n        }\n        #graph {\n            width: 800px;\n            height: 600px;\n            border: 1px solid black;\n        }\n    </style>\n</head>\n<body>\n    <h1>Depth-First Search (DFS)</h1>\n    <canvas id=\"graph\"></canvas>\n    <script>\n        let graph = new Array(5).fill(0).map(() => new Array(5).fill(0));\n        let visited = new Array(5).fill(false);\n        let stack = new Array(5).fill(false);\n        let currentPath = new Array(5).fill(false);\n        let colors = new Array(5).fill(0);\n\n        function drawGraph() {\n            let ctx = document.getElementById('graph').getContext('2d');\n            let g = new Graph(ctx, graph, visited, stack, currentPath, colors);\n            g.init();\n        }\n\n        function dfs(node) {\n            visited[node] = true;\n            currentPath[node] = true;\n            colors[node] = g.getColors();\n            stack[node] = true;\n\n            for (let neighbor of graph[node]) {\n                if (!visited[neighbor]) {\n                    dfs(neighbor);\n                } else if (currentPath[neighbor]) {\n                    // Node is in the current path, so we backtrack\n                    g.backtrack();\n                }\n            }\n\n            stack[node] = false;\n            currentPath[node] = false;\n            g.updateColors();\n        }\n\n        function backtrack() {\n            for (let i = 0; i < graph.length; i++) {\n                if (stack[i]) {\n                    let color = colors[i];\n                    let node = i;\n                    let colorIndex = colors.indexOf(color);\n                    let neighbors = graph[node];\n                    let visited = graph[node].filter(neighbor => !stack[neighbor]);\n\n                    // Update the color of the node\n                    graph[node][colorIndex] = color;\n\n                    // Update the color of the neighbors\n                    for (let neighbor of visited) {\n                        graph[neighbor][colorIndex] = color;\n                    }\n\n                    // Update the colors of the neighbors\n                    for (let neighbor of neighbors) {\n                        graph[neighbor][colorIndex] = color;\n                    }\n\n                    // Update the color of the node\n                    colors[node] = color;\n\n                    // Update the colors of the neighbors\n                    for (let neighbor of neighbors) {\n                        graph[neighbor][colorIndex] = color;\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        let graphData = {\n            'A': ['B', 'C'],\n            'B': ['D'],\n            'C': ['A', 'F'],\n            'D': ['E'],\n            'E': ['F'],\n            'F': ['A', 'C', 'D']\n        };\n\n        drawGraph();\n        dfs('A');\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}