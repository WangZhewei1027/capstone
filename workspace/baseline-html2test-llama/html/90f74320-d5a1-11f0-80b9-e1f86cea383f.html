<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Warshall Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Floyd-Warshall Algorithm</h1>
    <p>Find the shortest path between all pairs of nodes in a weighted graph using the Floyd-Warshall algorithm.</p>
    <form id="graph-form">
        <label for="nodes">Enter nodes:</label>
        <input type="text" id="nodes" name="nodes"><br><br>
        <label for="edges">Enter edges (e.g., A -> B, B -> C, C -> D):</label>
        <textarea id="edges" name="edges"></textarea><br><br>
        <button id="submit-btn">Submit</button>
    </form>
    <div id="graph-container"></div>

    <script>
        const form = document.getElementById('graph-form');
        const graphContainer = document.getElementById('graph-container');

        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const nodes = document.getElementById('nodes').value.split(',').map(Number);
            const edges = document.getElementById('edges').value.split('\n').map((edge) => edge.trim().split(' -> ').map(Number));

            const graph = {};
            for (const node of nodes) {
                graph[node] = {};
            }

            for (const edge of edges) {
                const [from, to] = edge.split(' -> ');
                graph[from][to] = Number(edge.split(' -> ').pop());
                graph[to][from] = Number(edge.split(' -> ').pop());
            }

            const shortestDistances = {};
            for (const node of nodes) {
                shortestDistances[node] = Infinity;
            }
            shortestDistances[nodes[0]] = 0;

            for (let k = 0; k < nodes.length; k++) {
                for (const node of nodes) {
                    for (const neighbor in graph[node]) {
                        const distance = shortestDistances[node] + graph[node][neighbor];
                        if (distance < shortestDistances[neighbor]) {
                            shortestDistances[neighbor] = distance;
                        }
                    }
                }
            }

            const shortestPaths = {};
            for (const node of nodes) {
                for (const neighbor in graph[node]) {
                    const path = [];
                    let currentNode = node;
                    while (currentNode !== neighbor) {
                        path.push(currentNode);
                        currentNode = shortestDistances[currentNode] === Infinity ? neighbor : graph[currentNode][neighbor];
                    }
                    path.push(neighbor);
                    shortestPaths[`${node},${neighbor}`] = path.reverse();
                }
            }

            const graphHTML = [];
            for (const node in graph) {
                graphHTML.push(`<p>${node}: ${JSON.stringify(graph[node])}</p>`);
            }

            graphContainer.innerHTML = graphHTML.join('\n');

            const shortestPathButton = document.createElement('button');
            shortestPathButton.textContent = 'Show Shortest Path';
            shortestPathButton.onclick = () => {
                const path = shortestPaths[Object.keys(shortestPaths)[0]];
                const pathHTML = path.map((node, index) => `${node}, ${index + 1}`).join('<br>');
                const shortestPathButtonHTML = `<button>View Shortest Path</button>`;
                graphContainer.innerHTML += pathHTML + shortestPathButtonHTML;
            };

            graphContainer.appendChild(shortestPathButton);
        });
    </script>
</body>
</html>