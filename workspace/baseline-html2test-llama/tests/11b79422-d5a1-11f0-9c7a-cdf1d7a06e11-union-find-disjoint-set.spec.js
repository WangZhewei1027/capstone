import { test, expect } from '@playwright/test';

const APP_URL = 'http://127.0.0.1:5500/workspace/baseline-html2test-llama/html/11b79422-d5a1-11f0-9c7a-cdf1d7a06e11.html';

// Page Object for the Union-Find page
class UnionFindPage {
  /**
   * @param {import('@playwright/test').Page} page
   */
  constructor(page) {
    this.page = page;
    this.numInput = '#num-vertices';
    this.addButton = '#add-vertex';
    this.unionButton = '#union-vertices';
    this.findButton = '#find-vertex';
    this.printButton = '#print-vertices';
    this.canvas = '#graph';
  }

  async goto() {
    await this.page.goto(APP_URL);
    // Wait for the main heading to confirm page loaded
    await this.page.waitForSelector('h1');
  }

  async setNumVertices(n) {
    await this.page.fill(this.numInput, String(n));
  }

  async clickAddVertex() {
    await this.page.click(this.addButton);
  }

  async clickUnionVertices() {
    await this.page.click(this.unionButton);
  }

  async clickFindVertex() {
    await this.page.click(this.findButton);
  }

  async clickPrintVertices() {
    await this.page.click(this.printButton);
  }

  async getGlobalVariable(varName) {
    return this.page.evaluate((name) => {
      // Return the variable from window scope if present
      // If not present, return null to prevent reference errors in the test harness
      try {
        // eslint-disable-next-line no-undef
        const val = window[name];
        return val === undefined ? null : val;
      } catch (e) {
        return { __error__: String(e) };
      }
    }, varName);
  }
}

test.describe('Union-Find (Disjoint Set) - Interactive Tests', () => {
  // Basic smoke test for initial page structure and accessibility of controls
  test('Initial load: page renders expected elements', async ({ page }) => {
    const uf = new UnionFindPage(page);
    await uf.goto();

    // Check title/heading
    const title = await page.textContent('h1');
    expect(title).toContain('Union-Find (Disjoint Set)');

    // Ensure expected interactive elements exist and are visible
    await expect(page.locator('#num-vertices')).toBeVisible();
    await expect(page.locator('#add-vertex')).toBeVisible();
    await expect(page.locator('#union-vertices')).toBeVisible();
    await expect(page.locator('#find-vertex')).toBeVisible();
    await expect(page.locator('#print-vertices')).toBeVisible();
    await expect(page.locator('#graph')).toBeVisible();

    // Buttons should be enabled
    await expect(page.locator('#add-vertex')).toBeEnabled();
    await expect(page.locator('#union-vertices')).toBeEnabled();
    await expect(page.locator('#find-vertex')).toBeEnabled();
    await expect(page.locator('#print-vertices')).toBeEnabled();
  });

  test('Add vertices: populates vertices and edges arrays and draws canvas', async ({ page }) => {
    // This test verifies that clicking "Add Vertex" with a valid number sets up internal arrays.
    const uf1 = new UnionFindPage(page);
    await uf.goto();

    // Listen for console messages and page errors during the operation
    const consoleMessages = [];
    page.on('console', msg => {
      consoleMessages.push({ type: msg.type(), text: msg.text() });
    });
    const pageErrors = [];
    page.on('pageerror', err => {
      pageErrors.push(String(err));
    });

    // Provide a small graph size
    await uf.setNumVertices(3);
    await uf.clickAddVertex();

    // Give the page a moment to run drawGraph and any asynchronous tasks
    await page.waitForTimeout(100);

    // The script stores arrays on the global/window scope - inspect them directly
    const vertices = await uf.getGlobalVariable('vertices');
    const edges = await uf.getGlobalVariable('edges');
    const parent = await uf.getGlobalVariable('parent');
    const rank = await uf.getGlobalVariable('rank');

    // Confirm arrays were created and lengths are as expected
    expect(Array.isArray(vertices)).toBe(true);
    expect(vertices.length).toBe(3);
    expect(Array.isArray(edges)).toBe(true);
    // For 3 vertices the number of edges generated by the implementation is 3 (pairs (0,1),(0,2),(1,2))
    expect(edges.length).toBe(3);
    expect(Array.isArray(parent)).toBe(true);
    expect(parent.length).toBe(3);
    expect(Array.isArray(rank)).toBe(true);
    expect(rank.length).toBe(3);

    // The drawGraph uses the canvas 2D context. Validate that getContext returns an object.
    const has2DContext = await page.$eval('#graph', (canvas) => {
      try {
        return !!canvas.getContext && !!canvas.getContext('2d');
      } catch (e) {
        return false;
      }
    });
    expect(has2DContext).toBe(true);

    // The add action should not produce runtime page errors in this particular flow (find/union not triggered)
    expect(pageErrors.length).toBe(0);

    // Print vertices may have been called automatically by other interactions; at minimum, ensure no fatal console errors happened
    const fatalConsoleErrors = consoleMessages.filter(m => m.type === 'error' || m.type === 'warning');
    expect(fatalConsoleErrors.length).toBeLessThan(2); // allow none or minimal non-fatal logs
  });

  test('Print vertices: clicking Print produces a console.log of the vertices array', async ({ page }) => {
    // This test asserts that the Print Vertices button invokes console.log with the vertices array
    const uf2 = new UnionFindPage(page);
    await uf.goto();

    const logs = [];
    page.on('console', msg => {
      logs.push({ type: msg.type(), text: msg.text() });
    });

    // Prepare vertices first
    await uf.setNumVertices(4);
    await uf.clickAddVertex();
    await page.waitForTimeout(50);

    // Click print and ensure console.log was invoked
    await uf.clickPrintVertices();
    // Allow console event to be captured
    await page.waitForTimeout(50);

    // Find any log entries - specifically look for the array output or a log message
    const logMessages = logs.filter(l => l.type === 'log').map(l => l.text);
    expect(logMessages.length).toBeGreaterThanOrEqual(1);

    // At least one of the log messages should include the string '0' (element indices), as a sanity check that the vertices were logged
    const foundVerticesLog = logMessages.some(t => t.includes('0'));
    expect(foundVerticesLog).toBe(true);
  });

  test('Union button without input fields triggers a runtime error (missing input elements)', async ({ page }) => {
    // The implementation references non-existent inputs (#vertex1, #vertex2).
    // Clicking the Union Vertices button should therefore raise a TypeError when the handler runs.
    const uf3 = new UnionFindPage(page);
    await uf.goto();

    // Capture page errors
    const pageErrors1 = [];
    page.on('pageerror', err => {
      pageErrors.push(String(err));
    });

    // Click union which is expected to try to access .value of null and throw
    await uf.clickUnionVertices();

    // Wait briefly to ensure the error surfaces
    await page.waitForTimeout(50);

    expect(pageErrors.length).toBeGreaterThanOrEqual(1);
    // Error messages can vary across engines; assert that it's a property access error related to null/undefined
    const joined = pageErrors.join(' | ');
    expect(joined).toMatch(/cannot read|reading 'value'|Cannot read properties of null|Cannot read property 'value'/i);
  });

  test('Find button without vertex input triggers a runtime error (missing input element)', async ({ page }) => {
    // The implementation references a non-existent input (#vertex).
    // Clicking the Find Vertex button should therefore raise a TypeError when the handler runs.
    const uf4 = new UnionFindPage(page);
    await uf.goto();

    // Capture page errors
    const pageErrors2 = [];
    page.on('pageerror', err => {
      pageErrors.push(String(err));
    });

    // Click find which is expected to throw due to missing element
    await uf.clickFindVertex();

    // Wait briefly to ensure the error surfaces
    await page.waitForTimeout(50);

    expect(pageErrors.length).toBeGreaterThanOrEqual(1);
    const joined1 = pageErrors.join(' | ');
    expect(joined).toMatch(/cannot read|reading 'value'|Cannot read properties of null|Cannot read property 'value'/i);
  });

  test('Direct call to find after add-vertex: observe potential recursive error or exception', async ({ page }) => {
    // The find() function relies on parent[] being initialized to parent[i] = i.
    // The add-vertex handler creates parent = new Array(numVertices) but does not set elements.
    // A direct call to find(0) after add-vertex is therefore likely to cause recursion or a TypeError/RangeError.
    const uf5 = new UnionFindPage(page);
    await uf.goto();

    // Prepare a small graph
    await uf.setNumVertices(3);
    await uf.clickAddVertex();
    await page.waitForTimeout(50);

    // Invoke find in the page context and capture any thrown error string
    const result = await page.evaluate(() => {
      try {
        // Attempt to call the page's find function directly
        return { value: find(0) };
      } catch (e) {
        // Return the error string so the test can assert on it
        return { error: String(e) };
      }
    });

    // We expect either a returned value (unlikely given parent isn't initialized), or an error
    if (result.error) {
      // The error could be a RangeError/Maximum call stack size exceeded due to recursion,
      // or a TypeError depending on how indexing behaves. Check for these possibilities.
      expect(result.error).toMatch(/RangeError|Maximum call stack|call stack|TypeError|undefined/i);
    } else {
      // If no error, the function returned something; assert it is a number (root index)
      expect(typeof result.value).toBe('number');
      expect(result.value).toBeGreaterThanOrEqual(0);
    }
  });
});