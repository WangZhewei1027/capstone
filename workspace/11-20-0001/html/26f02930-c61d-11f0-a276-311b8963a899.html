<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>冒泡排序可视化</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --bar:#60a5fa;
      --compare:#f59e0b;
      --swap:#ef4444;
      --sorted:#10b981;
      --text:#e6eef8;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{
      margin:0;
      background:linear-gradient(180deg,var(--bg),#071022);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:24px;
      gap:20px;
    }

    .container{
      width:100%;
      max-width:1100px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:18px;
      box-shadow:0 10px 30px rgba(2,6,23,0.6);
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:14px;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .control{
      background:var(--panel);
      padding:8px;
      border-radius:8px;
      display:flex;
      gap:8px;
      align-items:center;
      border:1px solid rgba(255,255,255,0.02);
    }
    label{font-size:12px;color:var(--muted);margin-right:6px;}
    input[type="range"]{width:150px;}
    button{
      background:linear-gradient(180deg,var(--accent),#0891b2);
      color:#032026;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.05);
      color:var(--text);
      font-weight:500;
      padding:6px 10px;
    }
    button:disabled{opacity:0.5;cursor:not-allowed;}
    main{
      display:flex;
      gap:16px;
      align-items:flex-start;
    }

    /* Visualization area */
    .viz{
      flex:1 1 580px;
      min-height:320px;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .canvas{
      flex:1;
      display:flex;
      align-items:flex-end;
      gap:6px;
      padding:10px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.005), rgba(255,255,255,0.002));
      overflow:hidden;
      min-height:260px;
    }
    .bar{
      background:var(--bar);
      height:60%;
      border-radius:6px 6px 4px 4px;
      flex:1 0 20px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:rgba(0,0,0,0.5);
      font-weight:700;
      transition:height 250ms ease, transform 250ms ease, background 180ms;
      position:relative;
    }
    .bar span{
      transform:translateY(6px);
      font-size:11px;
      color:rgba(255,255,255,0.9);
      text-shadow:0 1px 0 rgba(0,0,0,0.4);
      padding-bottom:6px;
    }
    .bar.compare{background:var(--compare); transform:scale(1.05);}
    .bar.swap{background:var(--swap); transform:scale(1.05);}
    .bar.sorted{background:var(--sorted);}
    .stats{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
    }
    .stat{
      background:rgba(255,255,255,0.02);
      padding:6px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      min-width:88px;
      text-align:center;
    }

    /* side panel - code + info */
    .side{
      width:360px;
      max-width:38%;
      min-width:260px;
      display:flex;
      gap:12px;
      flex-direction:column;
    }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .panel h3{margin:0 0 8px 0;font-size:14px;}
    .pseudocode{
      background:#031021;
      padding:10px;
      border-radius:8px;
      color:var(--muted);
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      line-height:1.6;
    }
    .code-line{display:block;padding:2px 6px;border-radius:6px;}
    .code-line.active{background:linear-gradient(90deg, rgba(6,182,212,0.09), rgba(16,185,129,0.03)); color:var(--text);}

    footer{
      display:flex;
      justify-content:space-between;
      margin-top:12px;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .small{font-size:12px;color:var(--muted);}
    .branding{font-size:12px;color:var(--muted);}
    @media (max-width:900px){
      main{flex-direction:column;}
      .side{width:100%}
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="冒泡排序可视化">
    <header>
      <h1>冒泡排序（Bubble Sort）可视化</h1>
      <div class="controls" aria-hidden="false">
        <div class="control">
          <label for="size">数组大小</label>
          <input id="size" type="range" min="5" max="70" value="24" />
        </div>
        <div class="control">
          <label for="speed">速度</label>
          <input id="speed" type="range" min="10" max="1000" value="180" />
        </div>
        <div class="control">
          <button id="shuffle" class="ghost" title="随机生成数组">随机数组</button>
          <button id="start">开始</button>
          <button id="pause" disabled>暂停</button>
          <button id="step" class="ghost">单步</button>
          <button id="reset" class="ghost">重置</button>
        </div>
      </div>
    </header>

    <main>
      <section class="viz" aria-label="可视化区域">
        <div class="canvas" id="canvas" role="list" aria-live="polite"></div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
          <div class="stats">
            <div class="stat"><div style="font-size:11px;color:var(--muted)">比较次数</div><div id="comp">0</div></div>
            <div class="stat"><div style="font-size:11px;color:var(--muted)">交换次数</div><div id="swaps">0</div></div>
            <div class="stat"><div style="font-size:11px;color:var(--muted)">当前外循环 i</div><div id="iidx">-</div></div>
            <div class="stat"><div style="font-size:11px;color:var(--muted)">当前内循环 j</div><div id="jidx">-</div></div>
          </div>

          <div style="display:flex;gap:8px;align-items:center">
            <div class="small">条高度表示数值（随窗口自适应）</div>
          </div>
        </div>
      </section>

      <aside class="side">
        <div class="panel">
          <h3>伪代码</h3>
          <div class="pseudocode" id="pseudocode" aria-hidden="false">
            <span class="code-line" data-line="1">1. for i = 0 to n-2</span>
            <span class="code-line" data-line="2">2.   for j = 0 to n-2-i</span>
            <span class="code-line" data-line="3">3.     if a[j] &gt; a[j+1]</span>
            <span class="code-line" data-line="4">4.       swap(a[j], a[j+1])</span>
            <span class="code-line" data-line="5">5. （标记最后一个元素为已排序）</span>
          </div>
        </div>

        <div class="panel">
          <h3>说明</h3>
          <p class="small" style="margin:0">
            控件：
          </p>
          <ul class="small" style="margin:8px 0 0 18px;padding:0 6px 0 0">
            <li>数组大小：改变元素数量并生成新数组</li>
            <li>速度：控制步骤间隔（数值越小越快）</li>
            <li>随机数组：生成新的随机数组</li>
            <li>开始/暂停/单步/重置：控制排序过程</li>
          </ul>
        </div>

        <div class="panel">
          <h3>提示</h3>
          <p class="small" style="margin:0">
            典型的冒泡排序时间复杂度为 O(n^2)。可观察到每次外循环后最终元素会是当前未排序区间的最大值（标记为绿色）。
          </p>
        </div>
      </aside>
    </main>

    <footer>
      <div class="branding">可视化演示 • 冒泡排序</div>
      <div class="small">为了教学而优化的交互演示 — 支持暂停和单步</div>
    </footer>
  </div>

<script>
(function(){
  // 元素
  const canvas = document.getElementById('canvas');
  const sizeInput = document.getElementById('size');
  const speedInput = document.getElementById('speed');
  const shuffleBtn = document.getElementById('shuffle');
  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const stepBtn = document.getElementById('step');
  const resetBtn = document.getElementById('reset');
  const compEl = document.getElementById('comp');
  const swapEl = document.getElementById('swaps');
  const iEl = document.getElementById('iidx');
  const jEl = document.getElementById('jidx');
  const pseudocode = document.getElementById('pseudocode');

  // 状态
  let array = [];
  let bars = [];
  let sortedFlags = [];
  let comparatorCount = 0;
  let swapCount = 0;
  let animating = false;
  let paused = false;
  let sorter = null; // generator
  let speed = parseInt(speedInput.value,10); // delay in ms
  let lastSize = parseInt(sizeInput.value,10);

  // 初始化
  function randArray(n){
    const arr=[];
    for(let i=0;i<n;i++){
      // 随机整数 5..100
      arr.push(Math.floor(Math.random()*96)+5);
    }
    return arr;
  }

  function renderArray(){
    canvas.innerHTML='';
    bars = [];
    const n = array.length;
    // compute max for scaling
    const max = Math.max(...array, 1);
    for(let i=0;i<n;i++){
      const v = array[i];
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.flex = `0 0 ${Math.max(6, Math.floor(1000/n))}px`;
      // height relative: min 6% to 92%
      const percent = 6 + Math.round((v / max) * 86);
      bar.style.height = `${percent}%`;
      const label = document.createElement('span');
      label.textContent = v;
      bar.appendChild(label);
      bar.setAttribute('role','listitem');
      bar.setAttribute('aria-label',`值 ${v}`);
      canvas.appendChild(bar);
      bars.push(bar);
    }
  }

  function resetStats(){
    comparatorCount = 0;
    swapCount = 0;
    compEl.textContent = '0';
    swapEl.textContent = '0';
    iEl.textContent = '-';
    jEl.textContent = '-';
  }

  // Pseudocode highlighting
  function highlightLine(line){
    const lines = pseudocode.querySelectorAll('.code-line');
    lines.forEach(el => el.classList.toggle('active', parseInt(el.dataset.line,10) === line));
  }

  // Generator that yields steps for bubble sort
  function* bubbleSortGen(arr){
    const n = arr.length;
    // outer loop
    for(let i=0;i<n-1;i++){
      yield {type:'outer', i};
      for(let j=0;j<n-1-i;j++){
        yield {type:'compare', i, j};
        if(arr[j] > arr[j+1]){
          yield {type:'swap', i, j};
          // do the swap in the array so subsequent comparisons reflect change
          const tmp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = tmp;
        }
      }
      // after inner loop, the element at n-1-i is sorted
      yield {type:'markSorted', index: n-1-i};
    }
    yield {type:'done'};
  }

  // Helpers: set bar status classes
  function clearBarStates(){
    bars.forEach(b => {
      b.classList.remove('compare','swap');
    });
  }
  function markSorted(index){
    if(bars[index]) bars[index].classList.add('sorted');
  }

  // Advance one step (for step mode or internal use)
  async function stepOnce(){
    if(!sorter) return false;
    const next = sorter.next();
    if(next.done) return false;
    const step = next.value;
    // Handle step
    switch(step.type){
      case 'outer':
        highlightLine(1);
        iEl.textContent = step.i;
        jEl.textContent = '-';
        clearBarStates();
        break;
      case 'compare':
        highlightLine(3);
        comparatorCount++;
        compEl.textContent = comparatorCount;
        jEl.textContent = step.j;
        clearBarStates();
        if(bars[step.j]) bars[step.j].classList.add('compare');
        if(bars[step.j+1]) bars[step.j+1].classList.add('compare');
        break;
      case 'swap':
        highlightLine(4);
        swapCount++;
        swapEl.textContent = swapCount;
        // perform visual swap: animate heights and text content by swapping style & content
        clearBarStates();
        const a = step.j, b = step.j+1;
        if(!bars[a] || !bars[b]) break;
        bars[a].classList.add('swap');
        bars[b].classList.add('swap');
        // swap heights and labels
        await animateSwapBars(a,b);
        // swap DOM references in bars array to keep indices consistent
        const tmp = bars[a];
        bars[a] = bars[b];
        bars[b] = tmp;
        break;
      case 'markSorted':
        highlightLine(5);
        markSorted(step.index);
        clearBarStates();
        break;
      case 'done':
        highlightLine(null);
        // mark all as sorted
        bars.forEach(b => b.classList.add('sorted'));
        clearBarStates();
        iEl.textContent = '-';
        jEl.textContent = '-';
        return false;
      default:
        break;
    }
    return true;
  }

  // animate swap by exchanging heights + label smoothly
  function animateSwapBars(i,j){
    return new Promise(resolve=>{
      const bi = bars[i];
      const bj = bars[j];
      if(!bi || !bj){ resolve(); return; }
      // capture heights and labels
      const hi = bi.style.height;
      const hj = bj.style.height;
      const li = bi.querySelector('span').textContent;
      const lj = bj.querySelector('span').textContent;

      // apply swap visually by temporarily setting both heights to the other
      // Using transition in CSS to animate
      // Slight delay to let class 'swap' apply scale
      requestAnimationFrame(()=>{
        bi.style.height = hj;
        bj.style.height = hi;
        bi.querySelector('span').textContent = lj;
        bj.querySelector('span').textContent = li;
      });

      // wait for transition end
      const onEnd = (e)=>{
        // ensure triggered for both or fallback timeout
      };
      // fallback timeout: choose max transition 350ms
      const t = Math.max(250, Math.min(800, parseInt(speedInput.value,10)+120));
      setTimeout(()=>resolve(), t);
    });
  }

  // Main loop to continuously run generator steps respecting speed & pause
  async function runSort(){
    if(!sorter) return;
    animating = true;
    startBtn.disabled = true;
    shuffleBtn.disabled = true;
    sizeInput.disabled = true;
    stepBtn.disabled = true;
    resetBtn.disabled = true;
    pauseBtn.disabled = false;

    let active = true;
    while(active){
      if(paused){
        // wait until unpaused
        await new Promise(r=> {
          const resume = ()=>{
            document.removeEventListener('resumeSort', resume);
            r();
          };
          document.addEventListener('resumeSort', resume);
        });
      }
      const cont = await stepOnce();
      if(!cont) { active = false; break; }
      // dynamic delay based on speed slider: smaller value => faster
      const delay = Math.max(5, parseInt(speedInput.value,10));
      await new Promise(r => setTimeout(r, delay));
    }

    // finished or stopped
    animating = false;
    startBtn.disabled = false;
    shuffleBtn.disabled = false;
    sizeInput.disabled = false;
    stepBtn.disabled = false;
    resetBtn.disabled = false;
    pauseBtn.disabled = true;
  }

  // Control handlers
  function generateAndRender(n){
    array = randArray(n);
    sortedFlags = new Array(n).fill(false);
    resetStats();
    renderArray();
    highlightLine(null);
    sorter = null;
    paused = false;
    animating = false;
    pauseBtn.disabled = true;
  }

  // initialize default
  generateAndRender(lastSize);

  // Events
  sizeInput.addEventListener('input', ()=>{
    const n = parseInt(sizeInput.value,10);
    lastSize = n;
    generateAndRender(n);
  });

  shuffleBtn.addEventListener('click', ()=>{
    generateAndRender(lastSize);
  });

  startBtn.addEventListener('click', ()=>{
    if(animating) return;
    // if sorter is null, create a fresh clone of array for generator
    if(!sorter){
      sorter = bubbleSortGen(array.slice()); // generator works on a copy to drive steps, but we mutate DOM separately
    }
    paused = false;
    document.dispatchEvent(new Event('resumeSort'));
    runSort();
  });

  pauseBtn.addEventListener('click', ()=>{
    paused = true;
    pauseBtn.disabled = true;
    startBtn.disabled = false;
    // allow resume via start
  });

  stepBtn.addEventListener('click', async ()=>{
    if(!sorter){
      sorter = bubbleSortGen(array.slice());
    }
    // if currently animating, ignore step
    if(animating) return;
    // run one step
    paused = true;
    // perform single step (no auto play)
    await stepOnce();
  });

  resetBtn.addEventListener('click', ()=>{
    // reset to unsorted original generate new random
    generateAndRender(lastSize);
  });

  speedInput.addEventListener('input', ()=>{
    speed = parseInt(speedInput.value,10);
  });

  // Accessibility: keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){
      e.preventDefault();
      if(animating && !paused){
        pauseBtn.click();
      } else {
        startBtn.click();
      }
    }
    if(e.key === 'ArrowRight'){
      stepBtn.click();
    }
    if(e.key === 'r'){
      shuffleBtn.click();
    }
  });

  // Resize handling: re-render heights based on stored numbers (in bars' labels)
  window.addEventListener('resize', ()=>{
    // nothing heavy; heights are percentage so they adapt automatically
  });

  // Initialize some helpful hints in console
  console.log('冒泡排序可视化已加载。按空格开始/暂停，右箭头单步，r 随机数组。');

})();
</script>
</body>
</html>