<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2d3748;
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 24px;
            min-height: calc(100vh - 48px);
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 16px;
            color: #1a202c;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #2d3748;
        }

        p {
            line-height: 1.6;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .button {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 16px;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .button:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            background-color: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .button.secondary {
            background-color: #718096;
        }

        .button.secondary:hover {
            background-color: #4a5568;
        }

        #graphCanvas {
            width: 100%;
            height: 500px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            background: #fafbfc;
        }

        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #4299e1;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            z-index: 10;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .edge {
            position: absolute;
            background-color: #cbd5e0;
            height: 3px;
            transform-origin: left center;
            transition: all 0.3s ease;
            z-index: 1;
        }

        .edge.considering {
            background-color: #f6e05e;
            height: 5px;
            z-index: 5;
        }

        .edge.accepted {
            background-color: #48bb78;
            height: 4px;
            z-index: 3;
        }

        .edge.rejected {
            background-color: #f56565;
            opacity: 0.5;
        }

        .edge-weight {
            position: absolute;
            background-color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 15;
        }

        .cost-display {
            background-color: #edf2f7;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }

        .cost-value {
            font-size: 32px;
            font-weight: bold;
            color: #2d3748;
        }

        .edge-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 24px;
        }

        .edge-item {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            background-color: #f7fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .edge-item.current {
            background-color: #f6e05e;
            transform: scale(1.05);
        }

        .edge-item.done {
            opacity: 0.6;
        }

        .edge-item.accepted {
            background-color: #c6f6d5;
        }

        .edge-item.rejected {
            background-color: #fed7d7;
            text-decoration: line-through;
        }

        .union-find {
            background-color: #f7fafc;
            padding: 16px;
            border-radius: 8px;
            min-height: 200px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
        }

        .step-info {
            background-color: #e6fffa;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border-left: 4px solid #38b2ac;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>Kruskal's Algorithm</h1>
            <p>
                Kruskal's algorithm finds the minimum spanning tree of a graph by:
            </p>
            <ol style="margin-left: 20px; margin-bottom: 16px;">
                <li>Sorting all edges by weight</li>
                <li>Adding edges that don't create cycles</li>
                <li>Stopping when we have n-1 edges</li>
            </ol>
            
            <div class="step-info" id="stepInfo">
                Click "Generate Graph" to start!
            </div>
            
            <div class="cost-display">
                <div>Total Cost</div>
                <div class="cost-value" id="totalCost">0</div>
            </div>
            
            <button class="button" id="generateBtn">Generate Graph</button>
            <button class="button" id="stepBtn" disabled>Step Forward</button>
            <button class="button" id="autoRunBtn" disabled>Auto Run</button>
            <button class="button secondary" id="resetBtn" disabled>Reset</button>
        </div>

        <div class="panel">
            <h2>Graph Visualization</h2>
            <div id="graphCanvas"></div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #cbd5e0;"></div>
                    <span>Unprocessed</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f6e05e;"></div>
                    <span>Considering</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #48bb78;"></div>
                    <span>Accepted</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f56565;"></div>
                    <span>Rejected</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Sorted Edges</h2>
            <div class="edge-list" id="edgeList"></div>
            
            <h2>Union-Find Structure</h2>
            <div class="union-find" id="unionFind">
                <p style="color: #718096; text-align: center;">
                    Generate a graph to see the union-find structure
                </p>
            </div>
        </div>
    </div>

    <script>
        class UnionFind {
            constructor(n) {
                this.parent = Array(n).fill(0).map((_, i) => i);
                this.rank = Array(n).fill(0);
            }

            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                
                if (rootX === rootY) return false;
                
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
                
                return true;
            }

            getSets() {
                const sets = {};
                for (let i = 0; i < this.parent.length; i++) {
                    const root = this.find(i);
                    if (!sets[root]) sets[root] = [];
                    sets[root].push(i);
                }
                return Object.values(sets);
            }
        }

        class KruskalVisualization {
            constructor() {
                this.canvas = document.getElementById('graphCanvas');
                this.nodes = [];
                this.edges = [];
                this.sortedEdges = [];
                this.currentStep = -1;
                this.totalCost = 0;
                this.unionFind = null;
                this.autoRunning = false;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('generateBtn').addEventListener('click', () => this.generateGraph());
                document.getElementById('stepBtn').addEventListener('click', () => this.step());
                document.getElementById('autoRunBtn').addEventListener('click', () => this.toggleAutoRun());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            generateGraph() {
                this.clear();
                const nodeCount = 6 + Math.floor(Math.random() * 3);
                
                // Generate nodes
                const canvasRect = this.canvas.getBoundingClientRect();
                const padding = 40;
                
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * 2 * Math.PI;
                    const radius = Math.min(canvasRect.width, canvasRect.height) / 3;
                    const x = canvasRect.width / 2 + radius * Math.cos(angle);
                    const y = canvasRect.height / 2 + radius * Math.sin(angle);
                    
                    this.nodes.push({ id: i, x, y });
                }

                // Generate edges (ensure connected graph)
                const edgeSet = new Set();
                
                // First, create a connected graph
                for (let i = 0; i < nodeCount - 1; i++) {
                    const j = i + 1;
                    const weight = Math.floor(Math.random() * 20) + 1;
                    edgeSet.add(`${i}-${j}-${weight}`);
                }
                
                // Add some random edges
                const extraEdges = Math.floor(nodeCount * 1.5);
                for (let e = 0; e < extraEdges; e++) {
                    const i = Math.floor(Math.random() * nodeCount);
                    let j = Math.floor(Math.random() * nodeCount);
                    if (i !== j) {
                        if (i > j) [i, j] = [j, i];
                        const weight = Math.floor(Math.random() * 20) + 1;
                        edgeSet.add(`${i}-${j}-${weight}`);
                    }
                }

                // Convert edge set to array
                edgeSet.forEach(edgeStr => {
                    const [i, j, weight] = edgeStr.split('-').map(Number);
                    this.edges.push({ from: i, to: j, weight });
                });

                // Sort edges by weight
                this.sortedEdges = [...this.edges].sort((a, b) => a.weight - b.weight);
                
                // Initialize union-find
                this.unionFind = new UnionFind(nodeCount);
                
                // Render
                this.render();
                this.updateEdgeList();
                this.updateUnionFind();
                
                // Enable controls
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('autoRunBtn').disabled = false;
                document.getElementById('resetBtn').disabled = false;
                document.getElementById('stepInfo').textContent = 'Click "Step Forward" to begin the algorithm!';
            }

            clear() {
                this.canvas.innerHTML = '';
                this.nodes = [];
                this.edges = [];
                this.sortedEdges = [];
                this.currentStep = -1;
                this.totalCost = 0;
                this.unionFind = null;
                this.autoRunning = false;
                document.getElementById('totalCost').textContent = '0';
                document.getElementById('edgeList').innerHTML = '';
                document.getElementById('unionFind').innerHTML = '<p style="color: #718096; text-align: center;">Generate a graph to see the union-find structure</p>';
            }

            render() {
                this.canvas.innerHTML = '';
                
                // Draw edges
                this.edges.forEach((edge, index) => {
                    const fromNode = this.nodes[edge.from];
                    const toNode = this.nodes[edge.to];
                    
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    const edgeEl = document.createElement('div');
                    edgeEl.className = 'edge';
                    edgeEl.classList.add(edge.status || '');
                    edgeEl.style.left = fromNode.x + 'px';
                    edgeEl.style.top = fromNode.y + 'px';
                    edgeEl.style.width = length + 'px';
                    edgeEl.style.transform = `rotate(${angle}deg)`;
                    
                    // Add weight label
                    const weightEl = document.createElement('div');
                    weightEl.className = 'edge-weight';
                    weightEl.textContent = edge.weight;
                    weightEl.style.left = (fromNode.x + toNode.x) / 2 - 15 + 'px';
                    weightEl.style.top = (fromNode.y + toNode.y) / 2 - 15 + 'px';
                    
                    this.canvas.appendChild(edgeEl);
                    this.canvas.appendChild(weightEl);
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'node';
                    nodeEl.textContent = String.fromCharCode(65 + node.id);
                    nodeEl.style.left = (node.x - 20) + 'px';
                    nodeEl.style.top = (node.y - 20) + 'px';
                    this.canvas.appendChild(nodeEl);
                });
            }

            updateEdgeList() {
                const listEl = document.getElementById('edgeList');
                listEl.innerHTML = '';
                
                this.sortedEdges.forEach((edge, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'edge-item';
                    
                    if (index === this.currentStep) {
                        itemEl.classList.add('current');
                    } else if (index < this.currentStep) {
                        itemEl.classList.add('done');
                        if (edge.status === 'accepted') {
                            itemEl.classList.add('accepted');
                        } else if (edge.status === 'rejected') {
                            itemEl.classList.add('rejected');
                        }
                    }
                    
                    itemEl.innerHTML = `
                        <span>${String.fromCharCode(65 + edge.from)}-${String.fromCharCode(65 + edge.to)}</span>
                        <span style="font-weight: bold;">${edge.weight}</span>
                    `;
                    
                    listEl.appendChild(itemEl);
                });
            }

            updateUnionFind() {
                const ufEl = document.getElementById('unionFind');
                const sets = this.unionFind.getSets();
                
                ufEl.innerHTML = '<div style="display: flex; flex-wrap: wrap; gap: 16px;">';
                sets.forEach(set => {
                    const setDiv = document.createElement('div');
                    setDiv.style.cssText = 'background: #e2e8f0; padding: 8px 12px; border-radius: 6px;';
                    setDiv.textContent = '{' + set.map(i => String.fromCharCode(65 + i)).join(', ') + '}';
                    ufEl.appendChild(setDiv);
                });
                ufEl.innerHTML += '</div>';
            }

            step() {
                if (this.currentStep >= this.sortedEdges.length - 1) return;
                
                this.currentStep++;
                const edge = this.sortedEdges[this.currentStep];
                
                // Update original edge status
                const originalEdge = this.edges.find(e => 
                    e.from === edge.from && e.to === edge.to && e.weight === edge.weight
                );
                
                // Check if adding this edge creates a cycle
                if (this.unionFind.find(edge.from) === this.unionFind.find(edge.to)) {
                    originalEdge.status = 'rejected';
                    edge.status = 'rejected';
                    document.getElementById('stepInfo').innerHTML = 
                        `<strong>Rejected edge ${String.fromCharCode(65 + edge.from)}-${String.fromCharCode(65 + edge.to)} (${edge.weight})</strong><br>
                        Would create a cycle!`;
                } else {
                    this.unionFind.union(edge.from, edge.to);
                    originalEdge.status = 'accepted';
                    edge.status = 'accepted';
                    this.totalCost += edge.weight;
                    document.getElementById('totalCost').textContent = this.totalCost;
                    document.getElementById('stepInfo').innerHTML = 
                        `<strong>Accepted edge ${String.fromCharCode(65 + edge.from)}-${String.fromCharCode(65 + edge.to)} (${edge.weight})</strong><br>
                        Nodes are in different sets.`;
                }
                
                // Mark as considering first
                originalEdge.status = 'considering';
                this.render();
                
                setTimeout(() => {
                    originalEdge.status = edge.status;
                    this.render();
                    this.updateEdgeList();
                    this.updateUnionFind();
                    
                    // Check if done
                    const acceptedCount = this.edges.filter(e => e.status === 'accepted').length;
                    if (acceptedCount === this.nodes.length - 1) {
                        document.getElementById('stepInfo').innerHTML = 
                            '<strong>Algorithm Complete!</strong><br>Minimum spanning tree found.';
                        document.getElementById('stepBtn').disabled = true;
                        document.getElementById('autoRunBtn').disabled = true;
                        this.autoRunning = false;
                        document.getElementById('autoRunBtn').textContent = 'Auto Run';
                    }
                }, 300);
            }

            toggleAutoRun() {
                this.autoRunning = !this.autoRunning;
                const btn = document.getElementById('autoRunBtn');
                btn.textContent = this.autoRunning ? 'Stop' : 'Auto Run';
                
                if (this.autoRunning) {
                    this.autoStep();
                }
            }

            autoStep() {
                if (!this.autoRunning) return;
                if (document.getElementById('stepBtn').disabled) return;
                
                this.step();
                setTimeout(() => this.autoStep(), 1500);
            }

            reset() {
                // Reset to initial state
                this.currentStep = -1;
                this.totalCost = 0;
                this.unionFind = new UnionFind(this.nodes.length);
                
                // Clear edge statuses
                this.edges.forEach(edge => {
                    delete edge.status;
                });
                this.sortedEdges.forEach(edge => {
                    delete edge.status;
                });
                
                // Update UI
                document.getElementById('totalCost').textContent = '0';
                document.getElementById('stepInfo').textContent = 'Click "Step Forward" to begin the algorithm!';
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('autoRunBtn').disabled = false;
                this.autoRunning = false;
                document.getElementById('autoRunBtn').textContent = 'Auto Run';
                
                // Re-render
                this.render();
                this.updateEdgeList();
                this.updateUnionFind();
            }
        }

        // Initialize the visualization
        const viz = new KruskalVisualization();
    </script>
</body>
</html>