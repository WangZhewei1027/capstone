<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        header {
            text-align: center;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 16px;
            color: #1a73e8;
        }

        .subtitle {
            font-size: 1.1em;
            color: #5f6368;
            max-width: 600px;
            margin: 0 auto 24px;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #1a73e8;
            color: white;
        }

        button:hover {
            background: #1557b0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #e8f0fe;
            color: #1a73e8;
        }

        button.secondary:hover {
            background: #d2e3fc;
        }

        .toggle-button {
            background: #34a853;
        }

        .toggle-button.off {
            background: #ea4335;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }

        .visualization {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 24px;
            min-height: 500px;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 500px;
            border: 2px solid #e8eaed;
            border-radius: 8px;
            cursor: crosshair;
            position: relative;
            overflow: hidden;
            background: #fafbfc;
        }

        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            user-select: none;
            z-index: 10;
        }

        .node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .node.selected {
            animation: pulse 0.5s ease-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .edge {
            position: absolute;
            background: #dadce0;
            height: 3px;
            transform-origin: left center;
            z-index: 1;
            transition: all 0.3s;
        }

        .edge.animated {
            animation: drawLine 0.5s ease-out;
        }

        @keyframes drawLine {
            from {
                transform: scaleX(0);
            }
            to {
                transform: scaleX(1);
            }
        }

        .rank-indicator {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .info-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 24px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #5f6368;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: #1a73e8;
        }

        .operations-log {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e8eaed;
            border-radius: 8px;
            padding: 16px;
        }

        .operation-item {
            padding: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .operation-type {
            font-weight: 500;
        }

        .operation-time {
            color: #5f6368;
            font-size: 12px;
        }

        .legend {
            position: absolute;
            top: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.95);
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .instructions {
            background: #e3f2fd;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 24px;
            font-size: 14px;
            line-height: 1.6;
        }

        .dragging-line {
            position: absolute;
            background: #1a73e8;
            height: 3px;
            transform-origin: left center;
            z-index: 20;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            h1 {
                font-size: 2em;
            }

            .controls {
                gap: 8px;
            }

            button {
                padding: 8px 16px;
                font-size: 13px;
            }

            #canvas {
                height: 400px;
            }

            .legend {
                top: 16px;
                right: 16px;
                padding: 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Union-Find Data Structure</h1>
            <p class="subtitle">
                Explore how Union-Find efficiently manages disjoint sets through 
                interactive visualization. See path compression and union by rank in action!
            </p>
        </header>

        <div class="controls">
            <button onclick="resetCanvas()">Reset Canvas</button>
            <button class="secondary" onclick="loadExample('simple')">Simple Example</button>
            <button class="secondary" onclick="loadExample('complex')">Complex Example</button>
            <button id="pathCompressionToggle" class="toggle-button" onclick="togglePathCompression()">
                Path Compression: ON
            </button>
            <button id="unionByRankToggle" class="toggle-button" onclick="toggleUnionByRank()">
                Union by Rank: ON
            </button>
        </div>

        <div class="instructions">
            <strong>How to use:</strong> Click on empty space to create nodes. 
            Drag from one node to another to union their sets. Click a node to find its root and see its component.
            Watch how path compression optimizes the tree structure!
        </div>

        <div class="main-content">
            <div class="visualization">
                <div id="canvas"></div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #1a73e8"></div>
                        <span>Click to create node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #34a853"></div>
                        <span>Drag to union sets</span>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-grid">
                    <div class="stat-card">
                        <div class="stat-label">Total Nodes</div>
                        <div class="stat-value" id="nodeCount">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Disjoint Sets</div>
                        <div class="stat-value" id="setCount">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Operations</div>
                        <div class="stat-value" id="operationCount">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Max Tree Height</div>
                        <div class="stat-value" id="maxHeight">0</div>
                    </div>
                </div>

                <h3 style="margin-bottom: 16px;">Operation History</h3>
                <div class="operations-log" id="operationsLog"></div>
            </div>
        </div>
    </div>

    <script>
        class UnionFind {
            constructor() {
                this.parent = new Map();
                this.rank = new Map();
                this.usePathCompression = true;
                this.useUnionByRank = true;
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x, visualize = false) {
                if (!this.parent.has(x)) {
                    return null;
                }

                const path = [];
                let current = x;

                // Find root and collect path
                while (this.parent.get(current) !== current) {
                    path.push(current);
                    current = this.parent.get(current);
                }

                // Path compression
                if (this.usePathCompression && path.length > 0) {
                    for (const node of path) {
                        if (visualize) {
                            animatePathCompression(node, current);
                        }
                        this.parent.set(node, current);
                    }
                }

                return current;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);

                if (rootX === null || rootY === null || rootX === rootY) {
                    return false;
                }

                if (this.useUnionByRank) {
                    const rankX = this.rank.get(rootX);
                    const rankY = this.rank.get(rootY);

                    if (rankX < rankY) {
                        this.parent.set(rootX, rootY);
                    } else if (rankX > rankY) {
                        this.parent.set(rootY, rootX);
                    } else {
                        this.parent.set(rootY, rootX);
                        this.rank.set(rootX, rankX + 1);
                    }
                } else {
                    this.parent.set(rootY, rootX);
                }

                return true;
            }

            getSetCount() {
                const roots = new Set();
                for (const node of this.parent.keys()) {
                    roots.add(this.find(node));
                }
                return roots.size;
            }

            getMaxHeight() {
                let maxHeight = 0;
                for (const node of this.parent.keys()) {
                    let height = 0;
                    let current = node;
                    while (this.parent.get(current) !== current) {
                        height++;
                        current = this.parent.get(current);
                    }
                    maxHeight = Math.max(maxHeight, height);
                }
                return maxHeight;
            }
        }

        // Global variables
        const uf = new UnionFind();
        const nodes = new Map();
        const edges = new Map();
        const colors = ['#1a73e8', '#ea4335', '#fbbc04', '#34a853', '#673ab7', '#ff6d00', '#00acc1', '#e91e63'];
        let nodeIdCounter = 0;
        let operationCounter = 0;
        let isDragging = false;
        let dragSource = null;
        let dragLine = null;

        // Canvas element
        const canvas = document.getElementById('canvas');

        // Event listeners
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseLeave);

        function handleCanvasClick(e) {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on existing node
            const clickedNode = getNodeAtPosition(x, y);
            if (clickedNode) {
                performFind(clickedNode);
            } else {
                createNode(x, y);
            }
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const node = getNodeAtPosition(x, y);
            if (node) {
                isDragging = true;
                dragSource = node;
                createDragLine(x, y);
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (!isDragging || !dragLine) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            updateDragLine(x, y);
        }

        function handleMouseUp(e) {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const targetNode = getNodeAtPosition(x, y);
            if (targetNode && targetNode !== dragSource) {
                performUnion(dragSource, targetNode);
            }

            cleanupDrag();
        }

        function handleMouseLeave() {
            cleanupDrag();
        }

        function cleanupDrag() {
            isDragging = false;
            dragSource = null;
            if (dragLine) {
                dragLine.remove();
                dragLine = null;
            }
        }

        function createDragLine(x, y) {
            dragLine = document.createElement('div');
            dragLine.className = 'dragging-line';
            dragLine.style.left = x + 'px';
            dragLine.style.top = y + 'px';
            canvas.appendChild(dragLine);
        }

        function updateDragLine(x2, y2) {
            if (!dragLine || !dragSource) return;

            const sourceNode = nodes.get(dragSource);
            const x1 = sourceNode.x;
            const y1 = sourceNode.y;

            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            dragLine.style.width = length + 'px';
            dragLine.style.transform = `rotate(${angle}deg)`;
            dragLine.style.left = x1 + 'px';
            dragLine.style.top = y1 + 'px';
        }

        function getNodeAtPosition(x, y) {
            for (const [id, node] of nodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (Math.sqrt(dx * dx + dy * dy) <= 25) {
                    return id;
                }
            }
            return null;
        }

        function createNode(x, y) {
            // Ensure minimum spacing
            for (const node of nodes.values()) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (Math.sqrt(dx * dx + dy * dy) < 80) {
                    return;
                }
            }

            const id = nodeIdCounter++;
            uf.makeSet(id);

            const nodeElement = document.createElement('div');
            nodeElement.className = 'node';
            nodeElement.textContent = id;
            nodeElement.style.left = (x - 25) + 'px';
            nodeElement.style.top = (y - 25) + 'px';
            nodeElement.style.background = colors[id % colors.length];
            nodeElement.dataset.id = id;

            canvas.appendChild(nodeElement);

            nodes.set(id, {
                element: nodeElement,
                x: x,
                y: y,
                color: colors[id % colors.length]
            });

            updateStats();
            logOperation('Create', `Node ${id} created`);
        }

        function performFind(nodeId) {
            const root = uf.find(nodeId, true);
            highlightComponent(root);
            logOperation('Find', `Find(${nodeId}) â†’ Root: ${root}`);
            updateStats();
        }

        function performUnion(nodeId1, nodeId2) {
            const success = uf.union(nodeId1, nodeId2);
            if (success) {
                createEdge(nodeId1, nodeId2);
                updateNodeColors();
                logOperation('Union', `Union(${nodeId1}, ${nodeId2})`);
                updateStats();
            }
        }

        function createEdge(id1, id2) {
            const edgeKey = `${Math.min(id1, id2)}-${Math.max(id1, id2)}`;
            if (edges.has(edgeKey)) return;

            const node1 = nodes.get(id1);
            const node2 = nodes.get(id2);

            const edge = document.createElement('div');
            edge.className = 'edge animated';

            const x1 = node1.x;
            const y1 = node1.y;
            const x2 = node2.x;
            const y2 = node2.y;

            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            edge.style.width = length + 'px';
            edge.style.left = x1 + 'px';
            edge.style.top = y1 + 'px';
            edge.style.transform = `rotate(${angle}deg)`;

            canvas.appendChild(edge);
            edges.set(edgeKey, edge);
        }

        function updateNodeColors() {
            const rootColors = new Map();
            let colorIndex = 0;

            for (const [id, node] of nodes) {
                const root = uf.find(id);
                if (!rootColors.has(root)) {
                    rootColors.set(root, colors[colorIndex++ % colors.length]);
                }
                node.element.style.background = rootColors.get(root);
            }
        }

        function highlightComponent(root) {
            for (const [id, node] of nodes) {
                if (uf.find(id) === root) {
                    node.element.classList.add('selected');
                    setTimeout(() => {
                        node.element.classList.remove('selected');
                    }, 500);
                }
            }
        }

        function animatePathCompression(nodeId, rootId) {
            const node = nodes.get(nodeId);
            const root = nodes.get(rootId);
            if (!node || !root || nodeId === rootId) return;

            // Animate the node moving closer to root
            const originalLeft = node.element.style.left;
            const originalTop = node.element.style.top;

            node.element.style.transition = 'all 0.5s ease-out';
            node.element.style.left = (root.x - 25) + 'px';
            node.element.style.top = (root.y - 50) + 'px';

            setTimeout(() => {
                node.element.style.left = originalLeft;
                node.element.style.top = originalTop;
                setTimeout(() => {
                    node.element.style.transition = 'all 0.3s';
                }, 500);
            }, 500);
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.size;
            document.getElementById('setCount').textContent = uf.getSetCount();
            document.getElementById('operationCount').textContent = operationCounter;
            document.getElementById('maxHeight').textContent = uf.getMaxHeight();
        }

        function logOperation(type, details) {
            operationCounter++;
            const log = document.getElementById('operationsLog');
            const item = document.createElement('div');
            item.className = 'operation-item';
            item.innerHTML = `
                <span class="operation-type">${type}: ${details}</span>
                <span class="operation-time">#${operationCounter}</span>
            `;
            log.insertBefore(item, log.firstChild);

            // Keep only last 10 operations
            while (log.children.length > 10) {
                log.removeChild(log.lastChild);
            }
        }

        function togglePathCompression() {
            uf.usePathCompression = !uf.usePathCompression;
            const btn = document.getElementById('pathCompressionToggle');
            btn.textContent = `Path Compression: ${uf.usePathCompression ? 'ON' : 'OFF'}`;
            btn.classList.toggle('off', !uf.usePathCompression);
        }

        function toggleUnionByRank() {
            uf.useUnionByRank = !uf.useUnionByRank;
            const btn = document.getElementById('unionByRankToggle');
            btn.textContent = `Union by Rank: ${uf.useUnionByRank ? 'ON' : 'OFF'}`;
            btn.classList.toggle('off', !uf.useUnionByRank);
        }

        function resetCanvas() {
            canvas.innerHTML = '';
            nodes.clear();
            edges.clear();
            nodeIdCounter = 0;
            operationCounter = 0;
            uf.parent.clear();
            uf.rank.clear();
            document.getElementById('operationsLog').innerHTML = '';
            updateStats();
        }

        function loadExample(type) {
            resetCanvas();

            if (type === 'simple') {
                // Create a simple example with 3 separate sets
                const positions = [
                    [150, 150], [250, 150],
                    [150, 300], [250, 300], [350, 300],
                    [500, 225], [600, 225]
                ];
                positions.forEach(([x, y]) => createNode(x, y));
                
                // Create some unions
                setTimeout(() => {
                    performUnion(0, 1);
                    setTimeout(() => {
                        performUnion(2, 3);
                        setTimeout(() => {
                            performUnion(3, 4);
                            setTimeout(() => {
                                performUnion(5, 6);
                            }, 500);
                        }, 500);
                    }, 500);
                }, 500);
            } else if (type === 'complex') {
                // Create a complex example showing path compression benefits
                const positions = [
                    [200, 100], [300, 100], [400, 100], [500, 100],
                    [200, 200], [300, 200], [400, 200], [500, 200],
                    [200, 300], [300, 300], [400, 300], [500, 300],
                    [200, 400], [300, 400], [400, 400], [500, 400]
                ];
                positions.forEach(([x, y]) => createNode(x, y));

                // Create a long chain to demonstrate path compression
                setTimeout(() => {
                    const unions = [
                        [0, 1], [1, 2], [2, 3],
                        [4, 5], [5, 6], [6, 7],
                        [8, 9], [9, 10], [10, 11],
                        [12, 13], [13, 14], [14, 15],
                        [0, 4], [4, 8], [8, 12]
                    ];
                    
                    let delay = 0;
                    unions.forEach(([a, b]) => {
                        setTimeout(() => performUnion(a, b), delay);
                        delay += 300;
                    });
                }, 500);
            }
        }

        // Initialize
        updateStats();
    </script>
</body>
</html>