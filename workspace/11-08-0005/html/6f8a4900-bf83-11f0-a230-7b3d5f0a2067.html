<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors Interactive Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 24px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 800px;
            width: 100%;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 24px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            font-size: 16px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        label {
            font-weight: 500;
            color: #555;
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        .k-value {
            font-weight: bold;
            color: #3498db;
            min-width: 20px;
            text-align: center;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #ccc;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-toggle {
            background: #e0e0e0;
            color: #666;
        }

        .btn-toggle.active {
            background: #3498db;
            color: white;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 32px;
            margin-top: 24px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-symbol {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .class-a {
            background: #3498db;
            border-radius: 50%;
        }

        .class-b {
            background: #e74c3c;
        }

        .instructions {
            text-align: center;
            margin-top: 24px;
            padding: 16px;
            background: #e3f2fd;
            border-radius: 8px;
            color: #1976d2;
            font-size: 14px;
        }

        .distance-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                gap: 16px;
            }

            .control-group {
                width: 100%;
                justify-content: space-between;
            }

            h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>K-Nearest Neighbors: Classification by Proximity</h1>
            <p class="subtitle">Explore how KNN classifies points based on their nearest neighbors</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>K Value:</label>
                <input type="range" id="kSlider" min="1" max="15" value="3">
                <span class="k-value" id="kValue">3</span>
            </div>

            <div class="control-group">
                <label>Distance:</label>
                <div class="btn-group">
                    <button class="btn-toggle active" id="euclideanBtn">Euclidean</button>
                    <button class="btn-toggle" id="manhattanBtn">Manhattan</button>
                </div>
            </div>

            <div class="control-group">
                <button class="btn-secondary" id="clearBtn">Clear Points</button>
                <button class="btn-primary" id="animateBtn">Animate: ON</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="600" height="400"></canvas>
            <div class="distance-info" id="distanceInfo"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-symbol class-a"></div>
                <span>Class A (<span id="classACount">0</span>)</span>
            </div>
            <div class="legend-item">
                <div class="legend-symbol class-b"></div>
                <span>Class B (<span id="classACount">0</span>)</span>
            </div>
            <div class="legend-item">
                <div class="legend-symbol" style="background: #95a5a6; border: 2px dashed #333;"></div>
                <span>Unclassified</span>
            </div>
        </div>

        <div class="instructions">
            Click anywhere on the canvas to add a new point and see how KNN classifies it based on its neighbors.
            Adjust K to change the number of neighbors considered.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const kSlider = document.getElementById('kSlider');
        const kValue = document.getElementById('kValue');
        const clearBtn = document.getElementById('clearBtn');
        const animateBtn = document.getElementById('animateBtn');
        const euclideanBtn = document.getElementById('euclideanBtn');
        const manhattanBtn = document.getElementById('manhattanBtn');
        const distanceInfo = document.getElementById('distanceInfo');

        let k = 3;
        let animateOn = true;
        let distanceMetric = 'euclidean';
        let userPoints = [];
        let animations = [];
        let mousePos = { x: -1, y: -1 };

        // Training data
        const trainingData = [
            // Class A (blue circles)
            { x: 100, y: 100, class: 'A' },
            { x: 150, y: 120, class: 'A' },
            { x: 120, y: 180, class: 'A' },
            { x: 180, y: 150, class: 'A' },
            { x: 80, y: 160, class: 'A' },
            { x: 140, y: 80, class: 'A' },
            { x: 200, y: 100, class: 'A' },
            { x: 160, y: 200, class: 'A' },
            
            // Class B (red squares)
            { x: 400, y: 250, class: 'B' },
            { x: 450, y: 280, class: 'B' },
            { x: 420, y: 320, class: 'B' },
            { x: 480, y: 300, class: 'B' },
            { x: 380, y: 300, class: 'B' },
            { x: 440, y: 220, class: 'B' },
            { x: 500, y: 250, class: 'B' },
            { x: 460, y: 350, class: 'B' },
            
            // Mixed region
            { x: 280, y: 200, class: 'A' },
            { x: 320, y: 220, class: 'B' },
            { x: 300, y: 180, class: 'A' },
            { x: 340, y: 240, class: 'B' }
        ];

        // Event listeners
        kSlider.addEventListener('input', (e) => {
            k = parseInt(e.target.value);
            kValue.textContent = k;
            reclassifyPoints();
        });

        clearBtn.addEventListener('click', () => {
            userPoints = [];
            animations = [];
            draw();
        });

        animateBtn.addEventListener('click', () => {
            animateOn = !animateOn;
            animateBtn.textContent = `Animate: ${animateOn ? 'ON' : 'OFF'}`;
            animateBtn.classList.toggle('btn-primary');
            animateBtn.classList.toggle('btn-secondary');
        });

        euclideanBtn.addEventListener('click', () => {
            distanceMetric = 'euclidean';
            euclideanBtn.classList.add('active');
            manhattanBtn.classList.remove('active');
            reclassifyPoints();
        });

        manhattanBtn.addEventListener('click', () => {
            distanceMetric = 'manhattan';
            manhattanBtn.classList.add('active');
            euclideanBtn.classList.remove('active');
            reclassifyPoints();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            addUserPoint(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            mousePos = { x: -1, y: -1 };
            distanceInfo.style.display = 'none';
            draw();
        });

        function calculateDistance(p1, p2) {
            if (distanceMetric === 'euclidean') {
                return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            } else {
                return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
            }
        }

        function findKNearest(point) {
            const distances = trainingData.map(p => ({
                point: p,
                distance: calculateDistance(point, p)
            }));
            
            distances.sort((a, b) => a.distance - b.distance);
            return distances.slice(0, k);
        }

        function classifyPoint(point) {
            const nearest = findKNearest(point);
            const votes = { A: 0, B: 0 };
            
            nearest.forEach(n => {
                votes[n.point.class]++;
            });
            
            return {
                class: votes.A > votes.B ? 'A' : 'B',
                confidence: Math.max(votes.A, votes.B) / k,
                nearest: nearest,
                votes: votes
            };
        }

        function addUserPoint(x, y) {
            const point = { x, y, class: null, opacity: 0 };
            const classification = classifyPoint(point);
            point.class = classification.class;
            point.classification = classification;
            
            userPoints.push(point);
            
            if (animateOn) {
                animations.push({
                    point: point,
                    radius: 0,
                    maxRadius: classification.nearest[k - 1].distance,
                    opacity: 0,
                    phase: 'expanding'
                });
            } else {
                point.opacity = 1;
            }
            
            draw();
        }

        function reclassifyPoints() {
            userPoints.forEach(point => {
                const classification = classifyPoint(point);
                point.class = classification.class;
                point.classification = classification;
            });
            draw();
        }

        function drawPoint(point, isTraining = true) {
            ctx.save();
            
            if (!isTraining && point.opacity < 1) {
                ctx.globalAlpha = point.opacity;
            }
            
            if (point.class === 'A') {
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                ctx.fill();
            } else if (point.class === 'B') {
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(point.x - 8, point.y - 8, 16, 16);
            } else {
                ctx.fillStyle = '#95a5a6';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawConnection(p1, p2, opacity = 0.3) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        }

        function drawAnimation(animation) {
            const { point, radius, maxRadius } = animation;
            
            // Draw expanding circle
            ctx.save();
            ctx.globalAlpha = 0.3 * (1 - radius / maxRadius);
            ctx.strokeStyle = point.class === 'A' ? '#3498db' : '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            
            // Highlight nearest neighbors
            if (animation.phase === 'highlighting') {
                point.classification.nearest.forEach((n, i) => {
                    if (radius > n.distance) {
                        drawConnection(point, n.point, 0.5);
                        
                        // Draw larger highlight for neighbor
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = n.point.class === 'A' ? '#3498db' : '#e74c3c';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(n.point.x, n.point.y, 12, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }
        }

        function updateAnimations() {
            animations = animations.filter(anim => {
                if (anim.phase === 'expanding') {
                    anim.radius += 5;
                    if (anim.radius >= anim.maxRadius) {
                        anim.phase = 'highlighting';
                        anim.holdFrames = 30;
                    }
                } else if (anim.phase === 'highlighting') {
                    anim.holdFrames--;
                    if (anim.holdFrames <= 0) {
                        anim.phase = 'fading';
                    }
                } else if (anim.phase === 'fading') {
                    anim.point.opacity = Math.min(1, anim.point.opacity + 0.05);
                    anim.opacity = Math.max(0, anim.opacity - 0.05);
                    if (anim.opacity <= 0) {
                        return false;
                    }
                }
                return true;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw training data
            trainingData.forEach(point => drawPoint(point, true));
            
            // Draw animations
            animations.forEach(anim => drawAnimation(anim));
            
            // Draw user points
            userPoints.forEach(point => drawPoint(point, false));
            
            // Show distances on hover
            if (mousePos.x >= 0 && mousePos.y >= 0) {
                const hoverPoint = { x: mousePos.x, y: mousePos.y };
                const nearest = findKNearest(hoverPoint);
                
                ctx.save();
                ctx.globalAlpha = 0.2;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, nearest[k - 1].distance, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                
                // Highlight k nearest
                nearest.forEach(n => {
                    drawConnection(hoverPoint, n.point, 0.2);
                });
            }
            
            // Update counts
            const classACounts = trainingData.filter(p => p.class === 'A').length +
                               userPoints.filter(p => p.class === 'A').length;
            const classBCounts = trainingData.filter(p => p.class === 'B').length +
                               userPoints.filter(p => p.class === 'B').length;
            
            document.querySelectorAll('#classACount')[0].textContent = classACounts;
            document.querySelectorAll('#classACount')[1].textContent = classBCounts;
        }

        function animate() {
            updateAnimations();
            draw();
            requestAnimationFrame(animate);
        }

        // Initialize
        draw();
        animate();
    </script>
</body>
</html>