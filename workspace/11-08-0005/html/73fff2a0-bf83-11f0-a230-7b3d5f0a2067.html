<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Heap Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #f0f4f8, #e2e8f0);
            min-height: 100vh;
            padding: 24px;
            color: #334155;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 2.5rem;
            color: #1e293b;
            margin-bottom: 16px;
            font-weight: 700;
        }

        .heap-type-selector {
            display: flex;
            gap: 24px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .heap-type-selector label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.125rem;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .heap-type-selector input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .heap-type-selector label:hover {
            background: #f1f5f9;
        }

        .heap-type-selector input[type="radio"]:checked + span {
            color: #3b82f6;
            font-weight: 600;
        }

        .control-panel {
            display: flex;
            gap: 16px;
            margin-bottom: 32px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        input[type="number"] {
            padding: 10px 16px;
            font-size: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            width: 120px;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: #3b82f6;
            color: white;
        }

        button:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        button.secondary {
            background: #64748b;
        }

        button.secondary:hover:not(:disabled) {
            background: #475569;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover:not(:disabled) {
            background: #dc2626;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .speed-control label {
            font-weight: 500;
        }

        input[type="range"] {
            width: 120px;
        }

        .visualization-area {
            display: grid;
            grid-template-rows: 3fr 1fr;
            gap: 32px;
            min-height: 500px;
        }

        .tree-container {
            position: relative;
            background: #f8fafc;
            border-radius: 12px;
            padding: 24px;
            overflow: hidden;
        }

        .tree-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node circle {
            fill: white;
            stroke: #3b82f6;
            stroke-width: 3;
            transition: all 0.3s;
        }

        .node:hover circle {
            fill: #eff6ff;
            stroke-width: 4;
        }

        .node text {
            font-size: 1.125rem;
            font-weight: 600;
            fill: #1e293b;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .node.highlighting circle {
            fill: #fef3c7;
            stroke: #f59e0b;
            stroke-width: 4;
        }

        .node.inserting circle {
            fill: #d1fae5;
            stroke: #10b981;
            stroke-width: 4;
            animation: pulse 0.6s ease-in-out;
        }

        .node.extracting circle {
            fill: #fee2e2;
            stroke: #ef4444;
            stroke-width: 4;
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .edge {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 2;
            transition: all 0.3s;
        }

        .edge.highlighting {
            stroke: #f59e0b;
            stroke-width: 3;
            stroke-dasharray: 5;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        .array-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 24px;
            overflow-x: auto;
        }

        .array-view {
            display: flex;
            gap: 8px;
            align-items: center;
            min-height: 80px;
        }

        .array-cell {
            min-width: 60px;
            height: 60px;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
        }

        .array-cell .value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1e293b;
        }

        .array-cell .index {
            position: absolute;
            top: -20px;
            font-size: 0.875rem;
            color: #64748b;
        }

        .array-cell.highlighting {
            background: #fef3c7;
            border-color: #f59e0b;
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .info-panel {
            position: fixed;
            right: 24px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            min-width: 200px;
        }

        .info-item {
            margin-bottom: 16px;
        }

        .info-label {
            font-size: 0.875rem;
            color: #64748b;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
        }

        .heap-valid {
            color: #10b981;
        }

        .heap-invalid {
            color: #ef4444;
        }

        .tooltip {
            position: absolute;
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .tooltip.show {
            opacity: 1;
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            h1 {
                font-size: 1.875rem;
            }

            .control-panel {
                flex-direction: column;
                gap: 12px;
            }

            .info-panel {
                position: static;
                transform: none;
                margin-top: 24px;
                right: auto;
            }

            .array-cell {
                min-width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Heap Visualizer</h1>
            <div class="heap-type-selector">
                <label>
                    <input type="radio" name="heapType" value="min" checked>
                    <span>Min Heap</span>
                </label>
                <label>
                    <input type="radio" name="heapType" value="max">
                    <span>Max Heap</span>
                </label>
            </div>
        </div>

        <div class="control-panel">
            <div class="input-group">
                <input type="number" id="valueInput" placeholder="Enter value" min="-999" max="999">
                <button id="insertBtn" onclick="insertValue()">Insert</button>
            </div>
            <button id="extractBtn" onclick="extractRoot()" class="secondary">Extract <span id="extractType">Min</span></button>
            <button onclick="clearHeap()" class="danger">Clear Heap</button>
            <div class="speed-control">
                <label for="speedSlider">Animation Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5">
            </div>
        </div>

        <div class="visualization-area">
            <div class="tree-container">
                <svg class="tree-svg" id="treeSvg"></svg>
            </div>
            <div class="array-container">
                <div class="array-view" id="arrayView"></div>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-item">
            <div class="info-label">Heap Size</div>
            <div class="info-value" id="heapSize">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Last Operation</div>
            <div class="info-value" id="lastOperation">None</div>
        </div>
        <div class="info-item">
            <div class="info-label">Time Complexity</div>
            <div class="info-value">O(log n)</div>
        </div>
        <div class="info-item">
            <div class="info-label">Heap Property</div>
            <div class="info-value heap-valid" id="heapStatus">✓ Valid</div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        class Heap {
            constructor(isMinHeap = true) {
                this.data = [];
                this.isMinHeap = isMinHeap;
            }

            size() {
                return this.data.length;
            }

            isEmpty() {
                return this.data.length === 0;
            }

            parent(i) {
                return Math.floor((i - 1) / 2);
            }

            leftChild(i) {
                return 2 * i + 1;
            }

            rightChild(i) {
                return 2 * i + 2;
            }

            swap(i, j) {
                [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
            }

            compare(i, j) {
                if (this.isMinHeap) {
                    return this.data[i] < this.data[j];
                } else {
                    return this.data[i] > this.data[j];
                }
            }

            async insert(value, animate = true) {
                this.data.push(value);
                if (animate) {
                    await this.bubbleUp(this.data.length - 1, true);
                } else {
                    await this.bubbleUp(this.data.length - 1, false);
                }
            }

            async bubbleUp(index, animate = true) {
                while (index > 0) {
                    const parentIndex = this.parent(index);
                    
                    if (animate) {
                        await highlightNodes([index, parentIndex]);
                    }

                    if (this.compare(index, parentIndex)) {
                        this.swap(index, parentIndex);
                        if (animate) {
                            await animateSwap(index, parentIndex);
                        }
                        index = parentIndex;
                    } else {
                        break;
                    }
                }
            }

            async extractRoot(animate = true) {
                if (this.isEmpty()) return null;

                const root = this.data[0];
                
                if (this.data.length === 1) {
                    this.data.pop();
                    return root;
                }

                this.data[0] = this.data.pop();
                
                if (animate) {
                    await this.bubbleDown(0, true);
                } else {
                    await this.bubbleDown(0, false);
                }
                
                return root;
            }

            async bubbleDown(index, animate = true) {
                while (true) {
                    let targetIndex = index;
                    const left = this.leftChild(index);
                    const right = this.rightChild(index);

                    if (left < this.data.length && this.compare(left, targetIndex)) {
                        targetIndex = left;
                    }

                    if (right < this.data.length && this.compare(right, targetIndex)) {
                        targetIndex = right;
                    }

                    if (targetIndex === index) break;

                    if (animate) {
                        await highlightNodes([index, targetIndex]);
                    }

                    this.swap(index, targetIndex);
                    
                    if (animate) {
                        await animateSwap(index, targetIndex);
                    }
                    
                    index = targetIndex;
                }
            }

            clear() {
                this.data = [];
            }

            isValid() {
                for (let i = 0; i < Math.floor(this.data.length / 2); i++) {
                    const left = this.leftChild(i);
                    const right = this.rightChild(i);

                    if (left < this.data.length && !this.compare(i, left)) {
                        return false;
                    }

                    if (right < this.data.length && !this.compare(i, right)) {
                        return false;
                    }
                }
                return true;
            }
        }

        let heap = new Heap(true);
        let animationSpeed = 5;

        function getAnimationDuration() {
            return (11 - animationSpeed) * 100;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function highlightNodes(indices) {
            indices.forEach(index => {
                const node = document.querySelector(`#node-${index}`);
                const cell = document.querySelector(`#cell-${index}`);
                if (node) node.classList.add('highlighting');
                if (cell) cell.classList.add('highlighting');
            });

            await sleep(getAnimationDuration());

            indices.forEach(index => {
                const node = document.querySelector(`#node-${index}`);
                const cell = document.querySelector(`#cell-${index}`);
                if (node) node.classList.remove('highlighting');
                if (cell) cell.classList.remove('highlighting');
            });
        }

        async function animateSwap(i, j) {
            const duration = getAnimationDuration();
            
            // Visual swap in tree
            const node1 = document.querySelector(`#node-${i}`);
            const node2 = document.querySelector(`#node-${j}`);
            
            if (node1 && node2) {
                const text1 = node1.querySelector('text');
                const text2 = node2.querySelector('text');
                
                const temp = text1.textContent;
                text1.textContent = text2.textContent;
                text2.textContent = temp;
            }

            // Visual swap in array
            const cell1 = document.querySelector(`#cell-${i} .value`);
            const cell2 = document.querySelector(`#cell-${j} .value`);
            
            if (cell1 && cell2) {
                const temp = cell1.textContent;
                cell1.textContent = cell2.textContent;
                cell2.textContent = temp;
            }

            await sleep(duration);
        }

        function renderTree() {
            const svg = document.getElementById('treeSvg');
            svg.innerHTML = '';
            
            if (heap.isEmpty()) return;

            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const nodeRadius = 25;
            const verticalSpacing = 80;
            const levels = Math.ceil(Math.log2(heap.size() + 1));

            // Calculate positions
            const positions = [];
            for (let level = 0; level < levels; level++) {
                const levelWidth = width / (Math.pow(2, level) + 1);
                const y = (level + 1) * verticalSpacing;
                
                for (let i = Math.pow(2, level) - 1; i < Math.min(Math.pow(2, level + 1) - 1, heap.size()); i++) {
                    const posInLevel = i - (Math.pow(2, level) - 1);
                    const x = levelWidth * (posInLevel + 1);
                    positions[i] = { x, y };
                }
            }

            // Draw edges
            const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for (let i = 0; i < heap.size(); i++) {
                const leftChild = heap.leftChild(i);
                const rightChild = heap.rightChild(i);

                if (leftChild < heap.size()) {
                    const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    edge.setAttribute('class', 'edge');
                    edge.setAttribute('x1', positions[i].x);
                    edge.setAttribute('y1', positions[i].y);
                    edge.setAttribute('x2', positions[leftChild].x);
                    edge.setAttribute('y2', positions[leftChild].y);
                    edgeGroup.appendChild(edge);
                }

                if (rightChild < heap.size()) {
                    const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    edge.setAttribute('class', 'edge');
                    edge.setAttribute('x1', positions[i].x);
                    edge.setAttribute('y1', positions[i].y);
                    edge.setAttribute('x2', positions[rightChild].x);
                    edge.setAttribute('y2', positions[rightChild].y);
                    edgeGroup.appendChild(edge);
                }
            }
            svg.appendChild(edgeGroup);

            // Draw nodes
            for (let i = 0; i < heap.size(); i++) {
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                nodeGroup.setAttribute('class', 'node');
                nodeGroup.setAttribute('id', `node-${i}`);
                nodeGroup.setAttribute('transform', `translate(${positions[i].x}, ${positions[i].y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', nodeRadius);
                nodeGroup.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.textContent = heap.data[i];
                nodeGroup.appendChild(text);

                // Add hover tooltip
                nodeGroup.addEventListener('mouseenter', (e) => {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.textContent = `Index: ${i}, Value: ${heap.data[i]}`;
                    tooltip.classList.add('show');
                });

                nodeGroup.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.left = e.pageX + 10 + 'px';
                    tooltip.style.top = e.pageY - 30 + 'px';
                });

                nodeGroup.addEventListener('mouseleave', () => {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.classList.remove('show');
                });

                svg.appendChild(nodeGroup);
            }
        }

        function renderArray() {
            const arrayView = document.getElementById('arrayView');
            arrayView.innerHTML = '';

            for (let i = 0; i < heap.size(); i++) {
                const cell = document.createElement('div');
                cell.className = 'array-cell';
                cell.id = `cell-${i}`;
                
                const index = document.createElement('div');
                index.className = 'index';
                index.textContent = i;
                
                const value = document.createElement('div');
                value.className = 'value';
                value.textContent = heap.data[i];
                
                cell.appendChild(index);
                cell.appendChild(value);
                arrayView.appendChild(cell);
            }
        }

        function updateInfo() {
            document.getElementById('heapSize').textContent = heap.size();
            const status = document.getElementById('heapStatus');
            if (heap.isValid()) {
                status.textContent = '✓ Valid';
                status.className = 'info-value heap-valid';
            } else {
                status.textContent = '✗ Invalid';
                status.className = 'info-value heap-invalid';
            }
        }

        function render() {
            renderTree();
            renderArray();
            updateInfo();
        }

        async function insertValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                input.classList.add('error');
                setTimeout(() => input.classList.remove('error'), 300);
                return;
            }

            document.getElementById('insertBtn').disabled = true;
            document.getElementById('extractBtn').disabled = true;
            
            await heap.insert(value);
            
            document.getElementById('lastOperation').textContent = `Inserted ${value}`;
            input.value = '';
            
            render();
            
            document.getElementById('insertBtn').disabled = false;
            document.getElementById('extractBtn').disabled = false;
        }

        async function extractRoot() {
            if (heap.isEmpty()) return;

            document.getElementById('insertBtn').disabled = true;
            document.getElementById('extractBtn').disabled = true;
            
            const value = await heap.extractRoot();
            
            document.getElementById('lastOperation').textContent = `Extracted ${value}`;
            
            render();
            
            document.getElementById('insertBtn').disabled = false;
            document.getElementById('extractBtn').disabled = false;
        }

        function clearHeap() {
            heap.clear();
            document.getElementById('lastOperation').textContent = 'Heap cleared';
            render();
        }

        // Event listeners
        document.getElementById('valueInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') insertValue();
        });

        document.querySelectorAll('input[name="heapType"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                heap.isMinHeap = e.target.value === 'min';
                document.getElementById('extractType').textContent = heap.isMinHeap ? 'Min' : 'Max';
                document.getElementById('lastOperation').textContent = `Switched to ${e.target.value} heap`;
                render();
            });
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
        });

        // Initialize with some sample values
        async function initialize() {
            const sampleValues = [10, 5, 20, 3, 8, 15, 25];
            for (const value of sampleValues) {
                await heap.insert(value, false);
            }
            render();
            document.getElementById('lastOperation').textContent = 'Initialized with sample values';
        }

        initialize();
    </script>
</body>
</html>