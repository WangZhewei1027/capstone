<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 24px;
            color: #2c3e50;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }

        header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        .tree-container {
            position: relative;
            height: 60vh;
            min-height: 400px;
            background: #fafafa;
            overflow: hidden;
        }

        #tree-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            fill: #667eea;
            stroke: #fff;
            stroke-width: 3;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        .node:hover circle {
            transform: scale(1.1);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }

        .node.selected circle {
            fill: #f59e0b;
            stroke: #f97316;
        }

        .node.visiting circle {
            fill: #10b981;
            animation: pulse 0.6s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .node text {
            fill: white;
            font-weight: bold;
            font-size: 16px;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .edge {
            stroke: #cbd5e1;
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .edge.highlighting {
            stroke: #10b981;
            stroke-width: 4;
            animation: dash 1s linear;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: 0;
            }
        }

        .controls-info {
            display: grid;
            grid-template-columns: 40% 60%;
            gap: 16px;
            padding: 24px;
            background: white;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #64748b;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .input-group {
            display: flex;
            gap: 8px;
        }

        input[type="number"] {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
        }

        button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .traversal-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .traversal-buttons button {
            flex: 1;
            min-width: 80px;
            background: #8b5cf6;
        }

        .traversal-buttons button:hover {
            background: #7c3aed;
        }

        .danger-button {
            background: #ef4444;
        }

        .danger-button:hover {
            background: #dc2626;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .info-card {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .info-card h3 {
            font-size: 1rem;
            color: #64748b;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-card p {
            color: #334155;
            line-height: 1.6;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #64748b;
        }

        .traversal-output {
            font-family: 'Courier New', monospace;
            background: #1e293b;
            color: #10b981;
            padding: 12px;
            border-radius: 4px;
            min-height: 60px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        @media (max-width: 768px) {
            .controls-info {
                grid-template-columns: 1fr;
            }
            
            header h1 {
                font-size: 1.5rem;
            }
            
            .tree-container {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Binary Tree Explorer</h1>
            <p>Interactive visualization of binary tree structure and traversal algorithms</p>
        </header>

        <div class="tree-container">
            <svg id="tree-svg">
                <g id="edges"></g>
                <g id="nodes"></g>
            </svg>
        </div>

        <div class="controls-info">
            <div class="controls">
                <div class="control-group">
                    <label>Add Node</label>
                    <div class="input-group">
                        <input type="number" id="node-value" placeholder="Enter value" min="0" max="999">
                        <button id="add-node">Add</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Traversal Methods</label>
                    <div class="traversal-buttons">
                        <button id="preorder">Pre-order</button>
                        <button id="inorder">In-order</button>
                        <button id="postorder">Post-order</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Animation Speed</label>
                    <div class="speed-control">
                        <span>Slow</span>
                        <input type="range" id="speed-slider" min="100" max="1000" value="500">
                        <span>Fast</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Actions</label>
                    <div class="input-group">
                        <button id="delete-node" disabled>Delete Selected</button>
                        <button id="clear-tree" class="danger-button">Clear Tree</button>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-card">
                    <h3>Tree Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="node-count">0</div>
                            <div class="stat-label">Nodes</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="tree-height">0</div>
                            <div class="stat-label">Height</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="tree-balance">0</div>
                            <div class="stat-label">Balance</div>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h3>Selected Node</h3>
                    <p id="selected-info">Click a node to see its details</p>
                </div>

                <div class="info-card">
                    <h3>Traversal Output</h3>
                    <div class="traversal-output" id="traversal-output">
                        Results will appear here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
            }
        }

        class BinaryTree {
            constructor(svgId) {
                this.root = null;
                this.svg = document.getElementById(svgId);
                this.nodesGroup = document.getElementById('nodes');
                this.edgesGroup = document.getElementById('edges');
                this.selectedNode = null;
                this.nodeElements = new Map();
                this.animationSpeed = 500;
                this.isAnimating = false;
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                } else {
                    this.insertNode(this.root, newNode);
                }
                this.calculatePositions();
                this.render();
                this.updateStats();
            }

            insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (!node.left) {
                        node.left = newNode;
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else {
                    if (!node.right) {
                        node.right = newNode;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }

            calculatePositions() {
                if (!this.root) return;
                
                const svgRect = this.svg.getBoundingClientRect();
                const width = svgRect.width;
                const height = svgRect.height;
                const nodeRadius = 24;
                const levelHeight = 80;
                
                const calculateSubtreeWidth = (node) => {
                    if (!node) return 0;
                    if (!node.left && !node.right) return 1;
                    return calculateSubtreeWidth(node.left) + calculateSubtreeWidth(node.right);
                };
                
                const positionNodes = (node, x, y, spread) => {
                    if (!node) return;
                    
                    node.x = x;
                    node.y = y;
                    
                    const leftWidth = calculateSubtreeWidth(node.left);
                    const rightWidth = calculateSubtreeWidth(node.right);
                    const totalWidth = leftWidth + rightWidth;
                    
                    if (node.left) {
                        const leftX = x - spread * (rightWidth / totalWidth);
                        positionNodes(node.left, leftX, y + levelHeight, spread * 0.7);
                    }
                    
                    if (node.right) {
                        const rightX = x + spread * (leftWidth / totalWidth);
                        positionNodes(node.right, rightX, y + levelHeight, spread * 0.7);
                    }
                };
                
                positionNodes(this.root, width / 2, 50, width / 4);
            }

            render() {
                this.edgesGroup.innerHTML = '';
                this.nodesGroup.innerHTML = '';
                this.nodeElements.clear();
                
                if (this.root) {
                    this.renderNode(this.root);
                }
            }

            renderNode(node) {
                if (!node) return;
                
                // Draw edges first
                if (node.left) {
                    this.drawEdge(node, node.left);
                    this.renderNode(node.left);
                }
                
                if (node.right) {
                    this.drawEdge(node, node.right);
                    this.renderNode(node.right);
                }
                
                // Draw node
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('node');
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', '24');
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('dy', '0.35em');
                text.textContent = node.value;
                
                g.appendChild(circle);
                g.appendChild(text);
                
                g.addEventListener('click', () => this.selectNode(node, g));
                
                this.nodesGroup.appendChild(g);
                this.nodeElements.set(node, g);
            }

            drawEdge(parent, child) {
                const edge = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                edge.classList.add('edge');
                
                const dx = child.x - parent.x;
                const dy = child.y - parent.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const startX = parent.x + (24 * dx / distance);
                const startY = parent.y + (24 * dy / distance);
                const endX = child.x - (24 * dx / distance);
                const endY = child.y - (24 * dy / distance);
                
                const path = `M ${startX} ${startY} Q ${(startX + endX) / 2} ${(startY + endY) / 2 + 20} ${endX} ${endY}`;
                edge.setAttribute('d', path);
                
                this.edgesGroup.appendChild(edge);
            }

            selectNode(node, element) {
                if (this.selectedNode) {
                    const prevElement = this.nodeElements.get(this.selectedNode);
                    if (prevElement) prevElement.classList.remove('selected');
                }
                
                this.selectedNode = node;
                element.classList.add('selected');
                
                document.getElementById('delete-node').disabled = false;
                this.updateSelectedInfo(node);
            }

            updateSelectedInfo(node) {
                let info = `Value: ${node.value}<br>`;
                info += `Left child: ${node.left ? node.left.value : 'None'}<br>`;
                info += `Right child: ${node.right ? node.right.value : 'None'}`;
                document.getElementById('selected-info').innerHTML = info;
            }

            async preorderTraversal() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                const result = [];
                await this.preorderHelper(this.root, result);
                this.displayTraversalResult(result);
                this.isAnimating = false;
            }

            async preorderHelper(node, result) {
                if (!node) return;
                
                const element = this.nodeElements.get(node);
                element.classList.add('visiting');
                result.push(node.value);
                
                await this.delay(this.animationSpeed);
                element.classList.remove('visiting');
                
                await this.preorderHelper(node.left, result);
                await this.preorderHelper(node.right, result);
            }

            async inorderTraversal() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                const result = [];
                await this.inorderHelper(this.root, result);
                this.displayTraversalResult(result);
                this.isAnimating = false;
            }

            async inorderHelper(node, result) {
                if (!node) return;
                
                await this.inorderHelper(node.left, result);
                
                const element = this.nodeElements.get(node);
                element.classList.add('visiting');
                result.push(node.value);
                
                await this.delay(this.animationSpeed);
                element.classList.remove('visiting');
                
                await this.inorderHelper(node.right, result);
            }

            async postorderTraversal() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                const result = [];
                await this.postorderHelper(this.root, result);
                this.displayTraversalResult(result);
                this.isAnimating = false;
            }

            async postorderHelper(node, result) {
                if (!node) return;
                
                await this.postorderHelper(node.left, result);
                await this.postorderHelper(node.right, result);
                
                const element = this.nodeElements.get(node);
                element.classList.add('visiting');
                result.push(node.value);
                
                await this.delay(this.animationSpeed);
                element.classList.remove('visiting');
            }

            deleteNode(value) {
                this.root = this.deleteNodeHelper(this.root, value);
                this.selectedNode = null;
                document.getElementById('delete-node').disabled = true;
                document.getElementById('selected-info').textContent = 'Click a node to see its details';
                this.calculatePositions();
                this.render();
                this.updateStats();
            }

            deleteNodeHelper(node, value) {
                if (!node) return null;
                
                if (value < node.value) {
                    node.left = this.deleteNodeHelper(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNodeHelper(node.right, value);
                } else {
                    if (!node.left && !node.right) {
                        return null;
                    } else if (!node.left) {
                        return node.right;
                    } else if (!node.right) {
                        return node.left;
                    } else {
                        const minRight = this.findMin(node.right);
                        node.value = minRight.value;
                        node.right = this.deleteNodeHelper(node.right, minRight.value);
                    }
                }
                return node;
            }

            findMin(node) {
                while (node.left) {
                    node = node.left;
                }
                return node;
            }

            clear() {
                this.root = null;
                this.selectedNode = null;
                document.getElementById('delete-node').disabled = true;
                document.getElementById('selected-info').textContent = 'Click a node to see its details';
                this.render();
                this.updateStats();
            }

            getHeight(node = this.root) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            getNodeCount(node = this.root) {
                if (!node) return 0;
                return 1 + this.getNodeCount(node.left) + this.getNodeCount(node.right);
            }

            getBalance(node = this.root) {
                if (!node) return 0;
                return this.getHeight(node.left) - this.getHeight(node.right);
            }

            updateStats() {
                document.getElementById('node-count').textContent = this.getNodeCount();
                document.getElementById('tree-height').textContent = this.getHeight();
                document.getElementById('tree-balance').textContent = this.getBalance();
            }

            displayTraversalResult(result) {
                const output = document.getElementById('traversal-output');
                output.textContent = `[${result.join(', ')}]`;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            setAnimationSpeed(speed) {
                this.animationSpeed = 1100 - speed;
            }
        }

        // Initialize tree
        const tree = new BinaryTree('tree-svg');

        // Event listeners
        document.getElementById('add-node').addEventListener('click', () => {
            const input = document.getElementById('node-value');
            const value = parseInt(input.value);
            
            if (!isNaN(value) && value >= 0 && value <= 999) {
                tree.insert(value);
                input.value = '';
            }
        });

        document.getElementById('node-value').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('add-node').click();
            }
        });

        document.getElementById('preorder').addEventListener('click', () => {
            if (!tree.isAnimating) {
                tree.preorderTraversal();
            }
        });

        document.getElementById('inorder').addEventListener('click', () => {
            if (!tree.isAnimating) {
                tree.inorderTraversal();
            }
        });

        document.getElementById('postorder').addEventListener('click', () => {
            if (!tree.isAnimating) {
                tree.postorderTraversal();
            }
        });

        document.getElementById('delete-node').addEventListener('click', () => {
            if (tree.selectedNode) {
                tree.deleteNode(tree.selectedNode.value);
            }
        });

        document.getElementById('clear-tree').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the entire tree?')) {
                tree.clear();
                document.getElementById('traversal-output').textContent = 'Results will appear here...';
            }
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            tree.setAnimationSpeed(parseInt(e.target.value));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (tree.root) {
                tree.calculatePositions();
                tree.render();
            }
        });

        // Add some initial nodes for demonstration
        [50, 30, 70, 20, 40, 60, 80].forEach(value => tree.insert(value));
    </script>
</body>
</html>