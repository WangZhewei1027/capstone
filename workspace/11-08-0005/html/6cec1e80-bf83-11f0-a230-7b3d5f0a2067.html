<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            line-height: 1.6;
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 12px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #7f8c8d;
        }

        .main-content {
            display: flex;
            gap: 24px;
            margin-bottom: 32px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 280px;
            height: fit-content;
        }

        .canvas-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
            position: relative;
        }

        canvas {
            border: 1px solid #e0e0e0;
            cursor: crosshair;
            display: block;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #34495e;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ecf0f1;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .k-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #3498db;
            min-width: 20px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        button.secondary {
            background: #95a5a6;
        }

        button.secondary:hover {
            background: #7f8c8d;
        }

        .status {
            background: #ecf0f1;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .status-running {
            background: #f39c12;
            color: white;
        }

        .status-complete {
            background: #27ae60;
            color: white;
        }

        .legend {
            display: flex;
            gap: 16px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .instructions {
            background: #ecf0f1;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .instructions h3 {
            margin-bottom: 12px;
            color: #34495e;
        }

        .instructions ul {
            margin-left: 24px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>K-Means Clustering</h1>
            <p class="subtitle">Interactive Algorithm Visualization</p>
        </header>

        <div class="instructions">
            <h3>How to use:</h3>
            <ul>
                <li>Click on the canvas to add data points</li>
                <li>Adjust the K value (number of clusters) using the slider</li>
                <li>Click "Run Algorithm" to see the clustering process</li>
                <li>Use "Step" to watch the algorithm progress one iteration at a time</li>
                <li>Try different data patterns using the preset buttons</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Number of Clusters (K)</label>
                    <div class="slider-container">
                        <input type="range" id="kSlider" min="2" max="6" value="3">
                        <span class="k-value" id="kValue">3</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Controls</label>
                    <button id="runBtn">Run Algorithm</button>
                    <button id="stepBtn">Step</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>

                <div class="control-group">
                    <label>Sample Data</label>
                    <button id="clusteredDataBtn" class="secondary">Clustered</button>
                    <button id="randomDataBtn" class="secondary">Random</button>
                    <button id="circularDataBtn" class="secondary">Circular</button>
                </div>

                <div class="control-group">
                    <label>Status</label>
                    <div class="status" id="status">
                        Ready to start. Click canvas to add points.
                    </div>
                </div>

                <div class="control-group">
                    <label>Iteration</label>
                    <div class="status" id="iteration">0</div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas" width="600" height="400"></canvas>
                <div class="legend" id="legend"></div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();

        // Algorithm state
        let points = [];
        let centroids = [];
        let assignments = [];
        let k = 3;
        let iteration = 0;
        let isRunning = false;
        let hasConverged = false;

        // Colors for clusters
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];

        // UI elements
        const kSlider = document.getElementById('kSlider');
        const kValue = document.getElementById('kValue');
        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statusDiv = document.getElementById('status');
        const iterationDiv = document.getElementById('iteration');
        const legendDiv = document.getElementById('legend');

        // Event listeners
        kSlider.addEventListener('input', (e) => {
            k = parseInt(e.target.value);
            kValue.textContent = k;
            resetAlgorithm();
        });

        canvas.addEventListener('click', (e) => {
            if (!isRunning) {
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                addPoint(x, y);
            }
        });

        runBtn.addEventListener('click', runAlgorithm);
        stepBtn.addEventListener('click', stepAlgorithm);
        resetBtn.addEventListener('click', reset);

        document.getElementById('clusteredDataBtn').addEventListener('click', () => generateClusteredData());
        document.getElementById('randomDataBtn').addEventListener('click', () => generateRandomData());
        document.getElementById('circularDataBtn').addEventListener('click', () => generateCircularData());

        // Functions
        function addPoint(x, y) {
            points.push({ x, y, cluster: -1 });
            draw();
        }

        function reset() {
            points = [];
            centroids = [];
            assignments = [];
            iteration = 0;
            isRunning = false;
            hasConverged = false;
            statusDiv.textContent = 'Ready to start. Click canvas to add points.';
            statusDiv.className = 'status';
            iterationDiv.textContent = '0';
            updateLegend();
            draw();
        }

        function resetAlgorithm() {
            centroids = [];
            assignments = [];
            iteration = 0;
            isRunning = false;
            hasConverged = false;
            points.forEach(p => p.cluster = -1);
            statusDiv.textContent = 'K value changed. Ready to run algorithm.';
            statusDiv.className = 'status';
            iterationDiv.textContent = '0';
            updateLegend();
            draw();
        }

        function initializeCentroids() {
            centroids = [];
            // K-means++ initialization
            if (points.length > 0) {
                // First centroid is random
                centroids.push({
                    x: points[0].x,
                    y: points[0].y,
                    cluster: 0
                });

                // Rest are chosen with probability proportional to distance
                for (let i = 1; i < k && i < points.length; i++) {
                    let maxDist = 0;
                    let bestPoint = points[0];
                    
                    points.forEach(p => {
                        let minDist = Infinity;
                        centroids.forEach(c => {
                            const dist = distance(p, c);
                            minDist = Math.min(minDist, dist);
                        });
                        if (minDist > maxDist) {
                            maxDist = minDist;
                            bestPoint = p;
                        }
                    });

                    centroids.push({
                        x: bestPoint.x,
                        y: bestPoint.y,
                        cluster: i
                    });
                }
            }
            updateLegend();
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function assignPointsToClusters() {
            let changed = false;
            points.forEach(point => {
                let minDist = Infinity;
                let closestCluster = 0;

                centroids.forEach((centroid, i) => {
                    const dist = distance(point, centroid);
                    if (dist < minDist) {
                        minDist = dist;
                        closestCluster = i;
                    }
                });

                if (point.cluster !== closestCluster) {
                    changed = true;
                    point.cluster = closestCluster;
                }
            });
            return changed;
        }

        function updateCentroids() {
            const newCentroids = [];

            for (let i = 0; i < k; i++) {
                const clusterPoints = points.filter(p => p.cluster === i);
                
                if (clusterPoints.length > 0) {
                    const sumX = clusterPoints.reduce((sum, p) => sum + p.x, 0);
                    const sumY = clusterPoints.reduce((sum, p) => sum + p.y, 0);
                    
                    newCentroids.push({
                        x: sumX / clusterPoints.length,
                        y: sumY / clusterPoints.length,
                        cluster: i
                    });
                } else {
                    // Keep old centroid if no points assigned
                    newCentroids.push(centroids[i]);
                }
            }

            // Animate centroid movement
            animateCentroids(centroids, newCentroids);
            centroids = newCentroids;
        }

        function animateCentroids(oldCentroids, newCentroids) {
            const steps = 20;
            let step = 0;

            function animate() {
                if (step <= steps) {
                    const t = step / steps;
                    const tempCentroids = oldCentroids.map((oldC, i) => ({
                        x: oldC.x + (newCentroids[i].x - oldC.x) * t,
                        y: oldC.y + (newCentroids[i].y - oldC.y) * t,
                        cluster: i
                    }));

                    centroids = tempCentroids;
                    draw();
                    step++;
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        async function runAlgorithm() {
            if (points.length === 0) {
                statusDiv.textContent = 'Please add some points first!';
                return;
            }

            isRunning = true;
            hasConverged = false;
            iteration = 0;
            
            if (centroids.length === 0) {
                initializeCentroids();
            }

            statusDiv.textContent = 'Running K-Means algorithm...';
            statusDiv.className = 'status status-running';

            while (!hasConverged && iteration < 100) {
                await new Promise(resolve => setTimeout(resolve, 500));
                stepAlgorithm();
            }

            isRunning = false;
        }

        function stepAlgorithm() {
            if (points.length === 0) {
                statusDiv.textContent = 'Please add some points first!';
                return;
            }

            if (centroids.length === 0) {
                initializeCentroids();
                draw();
                return;
            }

            if (!hasConverged) {
                iteration++;
                iterationDiv.textContent = iteration;

                const changed = assignPointsToClusters();
                draw();
                
                setTimeout(() => {
                    updateCentroids();
                    
                    if (!changed) {
                        hasConverged = true;
                        statusDiv.textContent = `Converged after ${iteration} iterations!`;
                        statusDiv.className = 'status status-complete';
                    } else {
                        statusDiv.textContent = `Iteration ${iteration} - Updating clusters...`;
                        statusDiv.className = 'status status-running';
                    }
                }, 250);
            }
        }

        function updateLegend() {
            legendDiv.innerHTML = '';
            for (let i = 0; i < k; i++) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${colors[i]}"></div>
                    <span>Cluster ${i + 1}</span>
                `;
                legendDiv.appendChild(item);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw connections to centroids
            if (centroids.length > 0) {
                ctx.lineWidth = 1;
                points.forEach(point => {
                    if (point.cluster >= 0 && point.cluster < centroids.length) {
                        ctx.strokeStyle = colors[point.cluster] + '30';
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(centroids[point.cluster].x, centroids[point.cluster].y);
                        ctx.stroke();
                    }
                });
            }

            // Draw points
            points.forEach(point => {
                ctx.fillStyle = point.cluster >= 0 ? colors[point.cluster] : '#95a5a6';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw centroids
            centroids.forEach((centroid, i) => {
                ctx.fillStyle = colors[i];
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                
                // Draw cross
                ctx.beginPath();
                ctx.moveTo(centroid.x - 10, centroid.y);
                ctx.lineTo(centroid.x + 10, centroid.y);
                ctx.moveTo(centroid.x, centroid.y - 10);
                ctx.lineTo(centroid.x, centroid.y + 10);
                ctx.stroke();

                // Draw circle
                ctx.beginPath();
                ctx.arc(centroid.x, centroid.y, 8, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        // Data generation functions
        function generateClusteredData() {
            reset();
            const clusters = k;
            const pointsPerCluster = 15;
            
            for (let i = 0; i < clusters; i++) {
                const centerX = 100 + (i * (canvas.width - 200) / (clusters - 1));
                const centerY = 100 + (i % 2) * 200;
                
                for (let j = 0; j < pointsPerCluster; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 50;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    addPoint(x, y);
                }
            }
        }

        function generateRandomData() {
            reset();
            for (let i = 0; i < 50; i++) {
                const x = 50 + Math.random() * (canvas.width - 100);
                const y = 50 + Math.random() * (canvas.height - 100);
                addPoint(x, y);
            }
        }

        function generateCircularData() {
            reset();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const numRings = 3;
            
            for (let ring = 0; ring < numRings; ring++) {
                const radius = 50 + ring * 60;
                const pointsInRing = 20 + ring * 10;
                
                for (let i = 0; i < pointsInRing; i++) {
                    const angle = (i / pointsInRing) * Math.PI * 2;
                    const r = radius + (Math.random() - 0.5) * 20;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    addPoint(x, y);
                }
            }
        }

        // Initialize
        updateLegend();
        draw();
    </script>
</body>
</html>