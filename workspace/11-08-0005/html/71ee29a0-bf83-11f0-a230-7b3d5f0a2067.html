<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weighted Graph Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 1.1rem;
            color: #7f8c8d;
        }

        .main-container {
            display: flex;
            flex: 1;
            gap: 16px;
            position: relative;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 260px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .mode-section {
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 16px;
        }

        .mode-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: 2px solid #3498db;
            background: white;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-button:hover {
            background: #e8f4fd;
        }

        .mode-button.active {
            background: #3498db;
            color: white;
        }

        .info-section {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
        }

        .info-label {
            font-weight: 600;
            color: #7f8c8d;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .info-value {
            font-size: 1.5rem;
            color: #2c3e50;
            font-weight: bold;
        }

        .clear-button {
            padding: 12px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
            margin-top: auto;
        }

        .clear-button:hover {
            background: #c0392b;
        }

        .canvas-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            background-image: 
                linear-gradient(rgba(236, 240, 241, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(236, 240, 241, 0.5) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .instructions {
            background: white;
            border-radius: 12px;
            padding: 16px 24px;
            margin-top: 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            font-size: 1rem;
            color: #7f8c8d;
        }

        .weight-input {
            position: absolute;
            padding: 8px 12px;
            font-size: 1rem;
            border: 2px solid #3498db;
            border-radius: 6px;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        .node-label {
            position: absolute;
            font-size: 0.8rem;
            color: #7f8c8d;
            font-weight: 600;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-container {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 16px;
            }

            .mode-section {
                flex: 1;
                border-bottom: none;
                border-right: 1px solid #ecf0f1;
                padding-right: 16px;
                padding-bottom: 0;
            }

            .info-section {
                flex: 1;
            }

            .clear-button {
                margin-top: 0;
                flex-basis: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Weighted Graph Explorer</h1>
        <p>Interactive visualization of graphs with weighted edges</p>
    </div>

    <div class="main-container">
        <div class="control-panel">
            <div class="mode-section">
                <button class="mode-button active" data-mode="create">Create Mode</button>
                <button class="mode-button" data-mode="pathfind">Path Finding Mode</button>
            </div>
            
            <div class="info-section">
                <div class="info-label">Selected Path Weight</div>
                <div class="info-value" id="pathWeight">-</div>
            </div>

            <button class="clear-button" onclick="clearGraph()">Clear Graph</button>
        </div>

        <div class="canvas-container">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>

    <div class="instructions" id="instructions">
        Click to create nodes. Drag between nodes to create weighted edges.
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const instructions = document.getElementById('instructions');
        const pathWeightDisplay = document.getElementById('pathWeight');

        let nodes = [];
        let edges = [];
        let mode = 'create';
        let selectedNode = null;
        let dragStart = null;
        let pathfindStart = null;
        let pathfindEnd = null;
        let shortestPath = [];
        let nodeCounter = 0;

        // Resize canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Mode switching
        document.querySelectorAll('.mode-button').forEach(button => {
            button.addEventListener('click', () => {
                mode = button.dataset.mode;
                document.querySelectorAll('.mode-button').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                
                // Reset pathfinding selections
                pathfindStart = null;
                pathfindEnd = null;
                shortestPath = [];
                pathWeightDisplay.textContent = '-';
                
                // Update instructions
                if (mode === 'create') {
                    instructions.textContent = 'Click to create nodes. Drag between nodes to create weighted edges.';
                    canvas.style.cursor = 'crosshair';
                } else {
                    instructions.textContent = 'Click on two nodes to find the shortest path between them.';
                    canvas.style.cursor = 'pointer';
                }
                
                draw();
            });
        });

        // Node class
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.id = nodeCounter++;
                this.label = String.fromCharCode(65 + (this.id % 26));
            }

            draw(isSelected = false, isPath = false) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                
                if (isPath) {
                    ctx.fillStyle = '#27ae60';
                    ctx.strokeStyle = '#27ae60';
                } else if (isSelected) {
                    ctx.fillStyle = '#3498db';
                    ctx.strokeStyle = '#3498db';
                } else {
                    ctx.fillStyle = '#ecf0f1';
                    ctx.strokeStyle = '#34495e';
                }
                
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw label
                ctx.fillStyle = isPath || isSelected ? 'white' : '#2c3e50';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);
            }
        }

        // Edge class
        class Edge {
            constructor(start, end, weight = 1) {
                this.start = start;
                this.end = end;
                this.weight = weight;
            }

            draw(isPath = false) {
                const dx = this.end.x - this.start.x;
                const dy = this.end.y - this.start.y;
                const angle = Math.atan2(dy, dx);
                
                // Calculate edge endpoints (not overlapping with nodes)
                const startX = this.start.x + Math.cos(angle) * 20;
                const startY = this.start.y + Math.sin(angle) * 20;
                const endX = this.end.x - Math.cos(angle) * 20;
                const endY = this.end.y - Math.sin(angle) * 20;
                
                // Draw edge
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                
                if (isPath) {
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 4;
                } else {
                    // Weight-based styling
                    const intensity = Math.min(this.weight / 10, 1);
                    ctx.strokeStyle = `rgba(52, 73, 94, ${0.3 + intensity * 0.7})`;
                    ctx.lineWidth = 1 + Math.min(this.weight / 5, 3);
                }
                
                ctx.stroke();
                
                // Draw weight label
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(midX - 15, midY - 10, 30, 20);
                
                ctx.fillStyle = isPath ? '#27ae60' : '#34495e';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.weight, midX, midY);
            }
        }

        // Find node at position
        function getNodeAt(x, y) {
            return nodes.find(node => {
                const dx = node.x - x;
                const dy = node.y - y;
                return Math.sqrt(dx * dx + dy * dy) < 20;
            });
        }

        // Find edge at position
        function getEdgeAt(x, y) {
            return edges.find(edge => {
                const midX = (edge.start.x + edge.end.x) / 2;
                const midY = (edge.start.y + edge.end.y) / 2;
                const dx = midX - x;
                const dy = midY - y;
                return Math.sqrt(dx * dx + dy * dy) < 20;
            });
        }

        // Dijkstra's algorithm
        function dijkstra(start, end) {
            const distances = {};
            const previous = {};
            const unvisited = new Set();
            
            nodes.forEach(node => {
                distances[node.id] = node === start ? 0 : Infinity;
                unvisited.add(node.id);
            });
            
            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;
                
                unvisited.forEach(nodeId => {
                    if (distances[nodeId] < minDist) {
                        minDist = distances[nodeId];
                        current = nodes.find(n => n.id === nodeId);
                    }
                });
                
                if (!current || current === end) break;
                
                unvisited.delete(current.id);
                
                // Check neighbors
                edges.forEach(edge => {
                    let neighbor = null;
                    if (edge.start === current) neighbor = edge.end;
                    else if (edge.end === current) neighbor = edge.start;
                    
                    if (neighbor && unvisited.has(neighbor.id)) {
                        const alt = distances[current.id] + edge.weight;
                        if (alt < distances[neighbor.id]) {
                            distances[neighbor.id] = alt;
                            previous[neighbor.id] = current;
                        }
                    }
                });
            }
            
            // Reconstruct path
            const path = [];
            let current = end;
            while (current && previous[current.id]) {
                path.unshift(current);
                current = previous[current.id];
            }
            if (current === start) {
                path.unshift(start);
                return { path, weight: distances[end.id] };
            }
            
            return { path: [], weight: Infinity };
        }

        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            edges.forEach(edge => {
                const isInPath = shortestPath.some((node, i) => {
                    if (i === 0) return false;
                    const prevNode = shortestPath[i - 1];
                    return (edge.start === prevNode && edge.end === node) ||
                           (edge.start === node && edge.end === prevNode);
                });
                edge.draw(isInPath);
            });
            
            // Draw dragging line
            if (dragStart && selectedNode) {
                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                ctx.lineTo(selectedNode.x, selectedNode.y);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw nodes
            nodes.forEach(node => {
                const isSelected = node === pathfindStart || node === pathfindEnd;
                const isInPath = shortestPath.includes(node);
                node.draw(isSelected, isInPath);
            });
        }

        // Handle mouse events
        canvas.addEventListener('mousedown', (e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (mode === 'create') {
                const clickedNode = getNodeAt(x, y);
                
                if (clickedNode) {
                    dragStart = clickedNode;
                    selectedNode = { x, y };
                } else {
                    // Check if clicked on edge to modify weight
                    const clickedEdge = getEdgeAt(x, y);
                    if (clickedEdge) {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'weight-input';
                        input.value = clickedEdge.weight;
                        input.style.left = e.clientX + 'px';
                        input.style.top = e.clientY + 'px';
                        
                        document.body.appendChild(input);
                        input.focus();
                        input.select();
                        
                        input.addEventListener('blur', () => {
                            const newWeight = parseInt(input.value) || 1;
                            clickedEdge.weight = Math.max(1, Math.min(newWeight, 99));
                            document.body.removeChild(input);
                            draw();
                        });
                        
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                input.blur();
                            }
                        });
                    } else {
                        // Create new node
                        nodes.push(new Node(x, y));
                        draw();
                    }
                }
            } else if (mode === 'pathfind') {
                const clickedNode = getNodeAt(x, y);
                
                if (clickedNode) {
                    if (!pathfindStart) {
                        pathfindStart = clickedNode;
                        instructions.textContent = 'Now click on the destination node.';
                    } else if (!pathfindEnd && clickedNode !== pathfindStart) {
                        pathfindEnd = clickedNode;
                        
                        // Find shortest path
                        const result = dijkstra(pathfindStart, pathfindEnd);
                        shortestPath = result.path;
                        
                        if (result.weight === Infinity) {
                            pathWeightDisplay.textContent = 'No path';
                            instructions.textContent = 'No path exists between these nodes. Click to select new nodes.';
                        } else {
                            pathWeightDisplay.textContent = result.weight;
                            instructions.textContent = `Shortest path found with total weight: ${result.weight}. Click to select new nodes.`;
                        }
                    } else {
                        // Reset selection
                        pathfindStart = clickedNode;
                        pathfindEnd = null;
                        shortestPath = [];
                        pathWeightDisplay.textContent = '-';
                        instructions.textContent = 'Now click on the destination node.';
                    }
                    
                    draw();
                }
            }
        }));

        canvas.addEventListener('mousemove', (e) => {
            if (mode === 'create' && dragStart) {
                const rect = canvas.getBoundingClientRect();
                selectedNode = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (mode === 'create' && dragStart) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const endNode = getNodeAt(x, y);
                
                if (endNode && endNode !== dragStart) {
                    // Check if edge already exists
                    const existingEdge = edges.find(edge => 
                        (edge.start === dragStart && edge.end === endNode) ||
                        (edge.start === endNode && edge.end === dragStart)
                    );
                    
                    if (!existingEdge) {
                        // Create weight input
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'weight-input';
                        input.placeholder = 'Weight';
                        input.style.left = e.clientX + 'px';
                        input.style.top = e.clientY + 'px';
                        
                        document.body.appendChild(input);
                        input.focus();
                        
                        input.addEventListener('blur', () => {
                            const weight = parseInt(input.value) || 1;
                            edges.push(new Edge(dragStart, endNode, Math.max(1, Math.min(weight, 99))));
                            document.body.removeChild(input);
                            draw();
                        });
                        
                        input.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                input.blur();
                            }
                        });
                    }
                }
                
                dragStart = null;
                selectedNode = null;
                draw();
            }
        });

        // Clear graph
        function clearGraph() {
            nodes = [];
            edges = [];
            pathfindStart = null;
            pathfindEnd = null;
            shortestPath = [];
            nodeCounter = 0;
            pathWeightDisplay.textContent = '-';
            draw();
        }

        // Initial draw
        draw();
    </script>
</body>
</html>