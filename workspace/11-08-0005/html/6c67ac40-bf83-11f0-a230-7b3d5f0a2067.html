<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjacency List Interactive Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            padding: 24px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: #3498db;
            color: white;
            padding: 24px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        
        .header p {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .main-content {
            display: flex;
            min-height: 500px;
        }
        
        .graph-panel {
            flex: 1.5;
            border-right: 1px solid #e0e0e0;
            position: relative;
            background: #fafbfc;
        }
        
        .canvas-container {
            position: relative;
            height: 500px;
            cursor: crosshair;
            overflow: hidden;
        }
        
        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .list-panel {
            flex: 1;
            padding: 24px;
            background: white;
            overflow-y: auto;
            max-height: 500px;
        }
        
        .list-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #2c3e50;
        }
        
        .adjacency-list {
            font-family: 'Courier New', monospace;
        }
        
        .vertex-entry {
            margin-bottom: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .vertex-entry:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(4px);
        }
        
        .vertex-entry.highlighted {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        .vertex-label {
            font-weight: 700;
            color: #3498db;
            display: inline-block;
            min-width: 40px;
        }
        
        .neighbors {
            display: inline-block;
            margin-left: 8px;
        }
        
        .neighbor {
            display: inline-block;
            padding: 2px 8px;
            margin: 0 4px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 14px;
            color: #1976d2;
        }
        
        .controls {
            padding: 16px 24px;
            background: #f5f7fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #95a5a6;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .instructions {
            padding: 16px 24px;
            background: #e8f4f8;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .vertex {
            transition: all 0.3s ease;
        }
        
        .vertex.highlighted {
            filter: drop-shadow(0 0 10px #ffc107);
        }
        
        .edge-line {
            transition: all 0.3s ease;
        }
        
        .edge-line.highlighted {
            filter: drop-shadow(0 0 5px #ffc107);
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .graph-panel {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }
            
            .canvas-container {
                height: 400px;
            }
        }
        
        .empty-state {
            color: #95a5a6;
            font-style: italic;
            padding: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Adjacency List: Graph Representation</h1>
            <p>Explore how graphs are efficiently stored as lists of connected neighbors</p>
        </div>
        
        <div class="instructions">
            <strong>How to use:</strong> Click empty space to add vertices • Drag between vertices to create edges • Right-click to delete • Hover to highlight connections
        </div>
        
        <div class="main-content">
            <div class="graph-panel">
                <div class="canvas-container">
                    <canvas id="graphCanvas"></canvas>
                </div>
            </div>
            
            <div class="list-panel">
                <h3 class="list-title">Adjacency List Representation</h3>
                <div id="adjacencyList" class="adjacency-list">
                    <div class="empty-state">Add vertices to see the adjacency list</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="generateExample()">Generate Example Graph</button>
            <button class="btn btn-secondary" onclick="clearGraph()">Clear All</button>
            <button class="btn btn-secondary" onclick="toggleDirected()">
                <span id="directedToggle">Switch to Directed</span>
            </button>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const adjacencyListEl = document.getElementById('adjacencyList');
        
        // Graph state
        let vertices = new Map();
        let edges = [];
        let isDirected = false;
        let vertexCounter = 0;
        let selectedVertex = null;
        let hoveredVertex = null;
        let isDragging = false;
        
        // Canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            render();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Vertex class
        class Vertex {
            constructor(x, y, label) {
                this.x = x;
                this.y = y;
                this.label = label;
                this.radius = 25;
                this.neighbors = new Set();
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
            
            draw(highlighted = false) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = highlighted ? '#ffc107' : '#3498db';
                ctx.fill();
                ctx.strokeStyle = highlighted ? '#ff9800' : '#2980b9';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);
            }
        }
        
        // Edge drawing
        function drawEdge(v1, v2, highlighted = false) {
            const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);
            const startX = v1.x + Math.cos(angle) * v1.radius;
            const startY = v1.y + Math.sin(angle) * v1.radius;
            const endX = v2.x - Math.cos(angle) * v2.radius;
            const endY = v2.y - Math.sin(angle) * v2.radius;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = highlighted ? '#ffc107' : '#7f8c8d';
            ctx.lineWidth = highlighted ? 3 : 2;
            ctx.stroke();
            
            if (isDirected) {
                // Draw arrowhead
                const arrowLength = 15;
                const arrowAngle = Math.PI / 6;
                
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - arrowAngle),
                    endY - arrowLength * Math.sin(angle - arrowAngle)
                );
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + arrowAngle),
                    endY - arrowLength * Math.sin(angle + arrowAngle)
                );
                ctx.stroke();
            }
        }
        
        // Mouse event handlers
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getVertexAt(x, y) {
            for (let vertex of vertices.values()) {
                if (vertex.contains(x, y)) {
                    return vertex;
                }
            }
            return null;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) return; // Right click
            
            const pos = getMousePos(e);
            const vertex = getVertexAt(pos.x, pos.y);
            
            if (vertex) {
                selectedVertex = vertex;
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            } else {
                // Create new vertex
                const label = String.fromCharCode(65 + (vertexCounter % 26));
                const newVertex = new Vertex(pos.x, pos.y, label);
                vertices.set(label, newVertex);
                vertexCounter++;
                updateAdjacencyList();
                render();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            const vertex = getVertexAt(pos.x, pos.y);
            
            if (isDragging && selectedVertex) {
                canvas.style.cursor = 'grabbing';
                render();
                
                // Draw line from selected vertex to mouse
                ctx.beginPath();
                ctx.moveTo(selectedVertex.x, selectedVertex.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                canvas.style.cursor = vertex ? 'pointer' : 'crosshair';
                
                if (vertex !== hoveredVertex) {
                    hoveredVertex = vertex;
                    updateHighlights();
                }
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (isDragging && selectedVertex) {
                const pos = getMousePos(e);
                const targetVertex = getVertexAt(pos.x, pos.y);
                
                if (targetVertex && targetVertex !== selectedVertex) {
                    // Add edge
                    if (!selectedVertex.neighbors.has(targetVertex.label)) {
                        selectedVertex.neighbors.add(targetVertex.label);
                        edges.push([selectedVertex, targetVertex]);
                        
                        if (!isDirected) {
                            targetVertex.neighbors.add(selectedVertex.label);
                        }
                        
                        updateAdjacencyList();
                    }
                }
            }
            
            selectedVertex = null;
            isDragging = false;
            canvas.style.cursor = 'crosshair';
            render();
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const pos = getMousePos(e);
            const vertex = getVertexAt(pos.x, pos.y);
            
            if (vertex) {
                // Remove vertex and its edges
                vertices.delete(vertex.label);
                
                // Remove edges connected to this vertex
                edges = edges.filter(edge => 
                    edge[0] !== vertex && edge[1] !== vertex
                );
                
                // Remove from neighbors
                for (let v of vertices.values()) {
                    v.neighbors.delete(vertex.label);
                }
                
                updateAdjacencyList();
                render();
            }
        });
        
        // Adjacency list interaction
        function updateHighlights() {
            const entries = document.querySelectorAll('.vertex-entry');
            entries.forEach(entry => {
                const label = entry.dataset.vertex;
                if (hoveredVertex && 
                    (hoveredVertex.label === label || hoveredVertex.neighbors.has(label))) {
                    entry.classList.add('highlighted');
                } else {
                    entry.classList.remove('highlighted');
                }
            });
            render();
        }
        
        function updateAdjacencyList() {
            if (vertices.size === 0) {
                adjacencyListEl.innerHTML = '<div class="empty-state">Add vertices to see the adjacency list</div>';
                return;
            }
            
            const sortedVertices = Array.from(vertices.values())
                .sort((a, b) => a.label.localeCompare(b.label));
            
            adjacencyListEl.innerHTML = sortedVertices.map(vertex => {
                const neighbors = Array.from(vertex.neighbors).sort();
                const neighborsHtml = neighbors.length > 0 
                    ? neighbors.map(n => `<span class="neighbor">${n}</span>`).join('')
                    : '<span style="color: #95a5a6">[ ]</span>';
                
                return `
                    <div class="vertex-entry" data-vertex="${vertex.label}"
                         onmouseover="highlightVertex('${vertex.label}')"
                         onmouseout="clearHighlight()">
                        <span class="vertex-label">${vertex.label}:</span>
                        <span class="neighbors">[${neighborsHtml}]</span>
                    </div>
                `;
            }).join('');
        }
        
        function highlightVertex(label) {
            hoveredVertex = vertices.get(label);
            updateHighlights();
        }
        
        function clearHighlight() {
            hoveredVertex = null;
            updateHighlights();
        }
        
        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw edges
            edges.forEach(([v1, v2]) => {
                const highlighted = hoveredVertex && 
                    (hoveredVertex === v1 || hoveredVertex === v2);
                drawEdge(v1, v2, highlighted);
            });
            
            // Draw vertices
            for (let vertex of vertices.values()) {
                const highlighted = hoveredVertex && 
                    (hoveredVertex === vertex || 
                     hoveredVertex.neighbors.has(vertex.label) ||
                     vertex.neighbors.has(hoveredVertex.label));
                vertex.draw(highlighted);
            }
        }
        
        // Control functions
        function generateExample() {
            clearGraph();
            
            // Create a sample graph
            const positions = [
                {x: 150, y: 150, label: 'A'},
                {x: 350, y: 100, label: 'B'},
                {x: 350, y: 250, label: 'C'},
                {x: 550, y: 175, label: 'D'},
                {x: 250, y: 350, label: 'E'}
            ];
            
            positions.forEach(pos => {
                const vertex = new Vertex(pos.x, pos.y, pos.label);
                vertices.set(pos.label, vertex);
            });
            
            // Add edges
            const connections = [
                ['A', 'B'], ['A', 'C'], ['B', 'C'], 
                ['B', 'D'], ['C', 'D'], ['C', 'E']
            ];
            
            connections.forEach(([from, to]) => {
                const v1 = vertices.get(from);
                const v2 = vertices.get(to);
                v1.neighbors.add(to);
                edges.push([v1, v2]);
                if (!isDirected) {
                    v2.neighbors.add(from);
                }
            });
            
            vertexCounter = 5;
            updateAdjacencyList();
            render();
        }
        
        function clearGraph() {
            vertices.clear();
            edges = [];
            vertexCounter = 0;
            hoveredVertex = null;
            selectedVertex = null;
            updateAdjacencyList();
            render();
        }
        
        function toggleDirected() {
            isDirected = !isDirected;
            document.getElementById('directedToggle').textContent = 
                isDirected ? 'Switch to Undirected' : 'Switch to Directed';
            
            if (isDirected) {
                // Convert to directed: keep only forward edges
                for (let vertex of vertices.values()) {
                    for (let neighbor of vertex.neighbors) {
                        const neighborVertex = vertices.get(neighbor);
                        if (neighborVertex && neighborVertex.neighbors.has(vertex.label)) {
                            neighborVertex.neighbors.delete(vertex.label);
                        }
                    }
                }
            } else {
                // Convert to undirected: add reverse edges
                for (let vertex of vertices.values()) {
                    for (let neighbor of vertex.neighbors) {
                        const neighborVertex = vertices.get(neighbor);
                        if (neighborVertex) {
                            neighborVertex.neighbors.add(vertex.label);
                        }
                    }
                }
            }
            
            updateAdjacencyList();
            render();
        }
        
        // Initial render
        render();
    </script>
</body>
</html>