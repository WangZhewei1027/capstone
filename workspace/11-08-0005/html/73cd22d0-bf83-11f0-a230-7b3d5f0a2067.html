<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            line-height: 1.6;
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .visualization-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            padding: 24px;
            position: relative;
        }

        #graph-canvas {
            width: 100%;
            height: 500px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            padding: 24px;
        }

        .control-section {
            margin-bottom: 24px;
        }

        .control-section h3 {
            font-size: 1.1rem;
            color: #2c3e50;
            margin-bottom: 12px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #95a5a6;
        }

        button.secondary:hover {
            background: #7f8c8d;
        }

        button.danger {
            background: #e74c3c;
        }

        button.danger:hover {
            background: #c0392b;
        }

        .slider-container {
            margin-top: 16px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e6ed;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        .info-display {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .info-label {
            color: #7f8c8d;
        }

        .info-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .log-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            padding: 24px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            font-size: 0.9rem;
            border-left: 4px solid transparent;
        }

        .log-entry.relaxation {
            background: #e8f4fd;
            border-left-color: #3498db;
        }

        .log-entry.update {
            background: #e8f8f5;
            border-left-color: #27ae60;
        }

        .log-entry.cycle {
            background: #fdedec;
            border-left-color: #e74c3c;
        }

        .legend {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #e0e6ed;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: #e0e6ed;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #3498db;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .pulsing {
            animation: pulse 0.6s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bellman-Ford Algorithm</h1>
            <p class="subtitle">Finding Shortest Paths with Negative Edges</p>
        </header>

        <div class="main-content">
            <div class="visualization-panel">
                <canvas id="graph-canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #95a5a6;"></div>
                        <span>Unvisited</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Processing</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Completed</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Negative Cycle</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-section">
                    <h3>Algorithm Information</h3>
                    <div class="info-display">
                        <div class="info-item">
                            <span class="info-label">Source Node:</span>
                            <span class="info-value" id="source-node">A</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Current Iteration:</span>
                            <span class="info-value" id="current-iteration">0 / 0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Current Edge:</span>
                            <span class="info-value" id="current-edge">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Status:</span>
                            <span class="info-value" id="algorithm-status">Ready</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Controls</h3>
                    <div class="button-group">
                        <button id="start-btn" onclick="startAlgorithm()">Start Algorithm</button>
                        <button id="step-btn" onclick="nextStep()" disabled>Next Step</button>
                    </div>
                    <div class="button-group" style="margin-top: 16px;">
                        <button class="secondary" onclick="resetGraph()">Reset</button>
                        <button class="danger" onclick="addNegativeCycle()">Add Negative Cycle</button>
                    </div>
                    
                    <div class="toggle-container">
                        <span>Auto Run:</span>
                        <div class="toggle-switch" id="auto-toggle" onclick="toggleAutoRun()">
                            <div class="toggle-slider"></div>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="speed-slider">Animation Speed:</label>
                        <input type="range" id="speed-slider" min="100" max="2000" value="1000" step="100">
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 16px;">Algorithm Log</h3>
            <div id="log-container"></div>
        </div>
    </div>

    <script>
        // Graph data structure
        class Graph {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.distances = {};
                this.predecessor = {};
                this.sourceNode = 'A';
            }

            addNode(id, x, y) {
                this.nodes.push({ id, x, y, color: '#95a5a6' });
                this.distances[id] = Infinity;
                this.predecessor[id] = null;
            }

            addEdge(from, to, weight) {
                this.edges.push({ from, to, weight, highlighted: false });
            }

            setSource(nodeId) {
                this.sourceNode = nodeId;
                this.resetDistances();
                this.distances[nodeId] = 0;
            }

            resetDistances() {
                for (let node of this.nodes) {
                    this.distances[node.id] = Infinity;
                    this.predecessor[node.id] = null;
                    node.color = '#95a5a6';
                }
            }
        }

        // Global variables
        let canvas, ctx;
        let graph;
        let currentIteration = 0;
        let currentEdgeIndex = 0;
        let algorithmRunning = false;
        let autoRun = false;
        let animationSpeed = 1000;
        let hasNegativeCycle = false;

        // Initialize canvas and graph
        function init() {
            canvas = document.getElementById('graph-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Initialize graph
            setupInitialGraph();
            
            // Add event listeners
            canvas.addEventListener('click', handleCanvasClick);
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                animationSpeed = 2100 - parseInt(e.target.value);
            });
            
            // Initial draw
            drawGraph();
        }

        function setupInitialGraph() {
            graph = new Graph();
            
            // Add nodes in a nice layout
            graph.addNode('A', 100, 150);
            graph.addNode('B', 300, 100);
            graph.addNode('C', 300, 250);
            graph.addNode('D', 500, 100);
            graph.addNode('E', 500, 250);
            graph.addNode('F', 700, 175);
            
            // Add edges with various weights including negative
            graph.addEdge('A', 'B', 4);
            graph.addEdge('A', 'C', 2);
            graph.addEdge('B', 'C', -3);
            graph.addEdge('B', 'D', 2);
            graph.addEdge('B', 'E', 3);
            graph.addEdge('C', 'E', 5);
            graph.addEdge('D', 'E', -1);
            graph.addEdge('D', 'F', 2);
            graph.addEdge('E', 'F', 1);
            
            graph.setSource('A');
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            for (let edge of graph.edges) {
                drawEdge(edge);
            }
            
            // Draw nodes
            for (let node of graph.nodes) {
                drawNode(node);
            }
        }

        function drawNode(node) {
            const radius = 30;
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = node.color;
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw node label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id, node.x, node.y);
            
            // Draw distance
            const distance = graph.distances[node.id];
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.fillText(distance === Infinity ? '∞' : distance, node.x, node.y + radius + 20);
        }

        function drawEdge(edge) {
            const fromNode = graph.nodes.find(n => n.id === edge.from);
            const toNode = graph.nodes.find(n => n.id === edge.to);
            
            const radius = 30;
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            
            // Calculate start and end points
            const startX = fromNode.x + radius * Math.cos(angle);
            const startY = fromNode.y + radius * Math.sin(angle);
            const endX = toNode.x - radius * Math.cos(angle);
            const endY = toNode.y - radius * Math.sin(angle);
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = edge.highlighted ? '#e74c3c' : '#7f8c8d';
            ctx.lineWidth = edge.highlighted ? 3 : 2;
            ctx.stroke();
            
            // Draw arrow
            const arrowLength = 15;
            const arrowAngle = Math.PI / 6;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle - arrowAngle),
                endY - arrowLength * Math.sin(angle - arrowAngle)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle + arrowAngle),
                endY - arrowLength * Math.sin(angle + arrowAngle)
            );
            ctx.stroke();
            
            // Draw weight
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(midX - 15, midY - 10, 30, 20);
            
            ctx.fillStyle = edge.weight < 0 ? '#e74c3c' : '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(edge.weight, midX, midY);
        }

        function handleCanvasClick(event) {
            if (algorithmRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if clicked on a node
            for (let node of graph.nodes) {
                const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                if (distance <= 30) {
                    graph.setSource(node.id);
                    document.getElementById('source-node').textContent = node.id;
                    drawGraph();
                    addLog(`Source node set to ${node.id}`, 'update');
                    break;
                }
            }
        }

        function startAlgorithm() {
            algorithmRunning = true;
            currentIteration = 0;
            currentEdgeIndex = 0;
            hasNegativeCycle = false;
            
            document.getElementById('start-btn').disabled = true;
            document.getElementById('step-btn').disabled = false;
            document.getElementById('algorithm-status').textContent = 'Running';
            
            // Reset edge highlights
            graph.edges.forEach(edge => edge.highlighted = false);
            
            clearLog();
            addLog(`Starting Bellman-Ford algorithm from node ${graph.sourceNode}`, 'update');
            
            if (autoRun) {
                runAutomatic();
            }
        }

        function nextStep() {
            if (!algorithmRunning) return;
            
            const numNodes = graph.nodes.length;
            
            // Check if we've completed all iterations
            if (currentIteration >= numNodes - 1) {
                // Check for negative cycles
                checkNegativeCycles();
                return;
            }
            
            // Perform one edge relaxation
            if (currentEdgeIndex < graph.edges.length) {
                const edge = graph.edges[currentEdgeIndex];
                relaxEdge(edge);
                currentEdgeIndex++;
                
                // Update UI
                document.getElementById('current-iteration').textContent = 
                    `${currentIteration + 1} / ${numNodes - 1}`;
                document.getElementById('current-edge').textContent = 
                    `${edge.from} → ${edge.to}`;
            }
            
            // Move to next iteration if all edges processed
            if (currentEdgeIndex >= graph.edges.length) {
                currentIteration++;
                currentEdgeIndex = 0;
                
                if (currentIteration < numNodes - 1) {
                    addLog(`Starting iteration ${currentIteration + 1}`, 'update');
                }
            }
        }

        function relaxEdge(edge) {
            const fromDist = graph.distances[edge.from];
            const toDist = graph.distances[edge.to];
            
            // Highlight current edge
            graph.edges.forEach(e => e.highlighted = false);
            edge.highlighted = true;
            
            // Highlight nodes involved
            graph.nodes.forEach(n => {
                if (n.id === edge.from || n.id === edge.to) {
                    n.color = '#f39c12';
                }
            });
            
            drawGraph();
            
            // Check if we can relax this edge
            if (fromDist !== Infinity && fromDist + edge.weight < toDist) {
                const oldDist = toDist === Infinity ? '∞' : toDist;
                graph.distances[edge.to] = fromDist + edge.weight;
                graph.predecessor[edge.to] = edge.from;
                
                // Animate the update
                const toNode = graph.nodes.find(n => n.id === edge.to);
                toNode.color = '#27ae60';
                
                addLog(`Relaxed edge ${edge.from}→${edge.to}: ${oldDist} → ${fromDist + edge.weight}`, 'relaxation');
                
                // Add pulse animation
                setTimeout(() => {
                    drawGraph();
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(toNode.x, toNode.y, 40, 0, 2 * Math.PI);
                    ctx.fillStyle = '#27ae60';
                    ctx.fill();
                    ctx.restore();
                }, 100);
            } else {
                addLog(`Edge ${edge.from}→${edge.to}: No improvement (${fromDist} + ${edge.weight} ≥ ${toDist})`, 'relaxation');
            }
            
            // Reset colors after a delay
            setTimeout(() => {
                edge.highlighted = false;
                graph.nodes.forEach(n => {
                    if (n.id !== graph.sourceNode && !hasNegativeCycle) {
                        n.color = '#95a5a6';
                    }
                });
                drawGraph();
            }, animationSpeed * 0.8);
        }

        function checkNegativeCycles() {
            addLog('Checking for negative cycles...', 'update');
            
            let cycleFound = false;
            
            // One more iteration to detect negative cycles
            for (let edge of graph.edges) {
                const fromDist = graph.distances[edge.from];
                const toDist = graph.distances[edge.to];
                
                if (fromDist !== Infinity && fromDist + edge.weight < toDist) {
                    cycleFound = true;
                    hasNegativeCycle = true;
                    edge.highlighted = true;
                    
                    // Mark nodes in negative cycle
                    const fromNode = graph.nodes.find(n => n.id === edge.from);
                    const toNode = graph.nodes.find(n => n.id === edge.to);
                    fromNode.color = '#e74c3c';
                    toNode.color = '#e74c3c';
                    
                    addLog(`Negative cycle detected on edge ${edge.from}→${edge.to}!`, 'cycle');
                }
            }
            
            if (!cycleFound) {
                addLog('No negative cycles found. Algorithm completed successfully!', 'update');
                document.getElementById('algorithm-status').textContent = 'Completed';
                
                // Color source node
                const sourceNode = graph.nodes.find(n => n.id === graph.sourceNode);
                sourceNode.color = '#3498db';
            } else {
                document.getElementById('algorithm-status').textContent = 'Negative Cycle Detected';
            }
            
            algorithmRunning = false;
            document.getElementById('step-btn').disabled = true;
            drawGraph();
        }

        function runAutomatic() {
            if (!algorithmRunning || !autoRun) return;
            
            nextStep();
            
            if (algorithmRunning) {
                setTimeout(runAutomatic, animationSpeed);
            }
        }

        function toggleAutoRun() {
            autoRun = !autoRun;
            const toggle = document.getElementById('auto-toggle');
            toggle.classList.toggle('active', autoRun);
            
            if (autoRun && algorithmRunning) {
                runAutomatic();
            }
        }

        function resetGraph() {
            algorithmRunning = false;
            autoRun = false;
            currentIteration = 0;
            currentEdgeIndex = 0;
            hasNegativeCycle = false;
            
            document.getElementById('auto-toggle').classList.remove('active');
            document.getElementById('start-btn').disabled = false;
            document.getElementById('step-btn').disabled = true;
            document.getElementById('algorithm-status').textContent = 'Ready';
            document.getElementById('current-iteration').textContent = '0 / 0';
            document.getElementById('current-edge').textContent = '-';
            
            setupInitialGraph();
            drawGraph();
            clearLog();
            addLog('Graph reset to initial state', 'update');
        }

        function addNegativeCycle() {
            if (algorithmRunning) return;
            
            // Add edges that create a negative cycle
            graph.addEdge('E', 'B', -10);
            graph.addEdge('C', 'A', -5);
            
            drawGraph();
            addLog('Added negative cycle edges to the graph', 'cycle');
        }

        function addLog(message, type = 'relaxation') {
            const logContainer = document.getElementById('log-container');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log-container').innerHTML = '';
        }

        // Initialize when page loads
        window.onload = init;
        window.onresize = () => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawGraph();
        };
    </script>
</body>
</html>