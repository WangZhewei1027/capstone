<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Interactive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            padding: 24px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            margin-bottom: 16px;
        }

        .header h1 {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 24px;
            min-height: 0;
        }

        .canvas-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .control-panel {
            width: 300px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .button-primary {
            background: #3498db;
            color: white;
        }

        .button-primary:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .button-secondary {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .button-secondary:hover {
            background: #bdc3c7;
        }

        .button-danger {
            background: #e74c3c;
            color: white;
        }

        .button-danger:hover {
            background: #c0392b;
        }

        .speed-control {
            margin-top: 8px;
        }

        .speed-control label {
            display: block;
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
        }

        .speed-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #ecf0f1;
            border-radius: 2px;
            outline: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }

        .algorithm-state {
            background: #ecf0f1;
            padding: 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .algorithm-state h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #2c3e50;
        }

        .queue-item {
            display: inline-block;
            padding: 4px 12px;
            background: #3498db;
            color: white;
            border-radius: 4px;
            margin: 2px;
            font-size: 12px;
        }

        .result-container {
            height: 80px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 16px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .result-label {
            font-weight: 600;
            color: #2c3e50;
            white-space: nowrap;
        }

        .result-order {
            flex: 1;
            display: flex;
            gap: 8px;
            align-items: center;
            overflow-x: auto;
            padding: 8px 0;
        }

        .result-node {
            padding: 8px 16px;
            background: #27ae60;
            color: white;
            border-radius: 6px;
            font-weight: 600;
            white-space: nowrap;
            animation: fadeIn 0.3s ease-out;
        }

        .result-arrow {
            color: #95a5a6;
            font-size: 20px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .legend {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .node {
            cursor: move;
        }

        .node:hover {
            filter: brightness(1.1);
        }

        .edge {
            cursor: pointer;
        }

        .edge:hover {
            stroke-width: 3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Topological Sort: Order Dependencies</h1>
            <p>Create a directed graph and discover valid task execution orders</p>
        </div>
        
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Unvisited</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Processing</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Completed</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Cycle Detected</span>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <button class="button button-primary" onclick="addNode()">Add Node</button>
                <button class="button button-primary" onclick="runTopologicalSort()">Run Topological Sort</button>
                <button class="button button-secondary" onclick="pauseResume()">Pause/Resume</button>
                <button class="button button-danger" onclick="clearGraph()">Clear Graph</button>
                
                <div class="speed-control">
                    <label for="speed">Animation Speed</label>
                    <input type="range" id="speed" class="speed-slider" min="1" max="10" value="5">
                </div>
                
                <div class="algorithm-state">
                    <h3>Algorithm State</h3>
                    <p><strong>Status:</strong> <span id="status">Ready</span></p>
                    <p><strong>Queue:</strong></p>
                    <div id="queue"></div>
                </div>
                
                <div class="error-message" id="error"></div>
            </div>
        </div>
        
        <div class="result-container">
            <div class="result-label">Topological Order:</div>
            <div class="result-order" id="result"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const nodes = [];
        const edges = [];
        let nodeIdCounter = 0;
        let selectedNode = null;
        let isCreatingEdge = false;
        let draggedNode = null;
        let animationPaused = false;
        let animationRunning = false;

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Node {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.label = `Task ${String.fromCharCode(65 + id)}`;
                this.radius = 30;
                this.color = '#3498db';
                this.inDegree = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);

                // Draw in-degree
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px sans-serif';
                ctx.fillText(`in: ${this.inDegree}`, this.x, this.y + this.radius + 15);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        class Edge {
            constructor(from, to) {
                this.from = from;
                this.to = to;
                this.color = '#34495e';
            }

            draw() {
                const angle = Math.atan2(this.to.y - this.from.y, this.to.x - this.from.x);
                const startX = this.from.x + this.from.radius * Math.cos(angle);
                const startY = this.from.y + this.from.radius * Math.sin(angle);
                const endX = this.to.x - this.to.radius * Math.cos(angle);
                const endY = this.to.y - this.to.radius * Math.sin(angle);

                // Draw line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw arrow
                const arrowSize = 10;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw edges
            edges.forEach(edge => edge.draw());

            // Draw nodes
            nodes.forEach(node => node.draw());

            // Draw creating edge
            if (isCreatingEdge && selectedNode) {
                ctx.beginPath();
                ctx.moveTo(selectedNode.x, selectedNode.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function addNode() {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = Math.random() * (canvas.height - 100) + 50;
            nodes.push(new Node(x, y, nodeIdCounter++));
            calculateInDegrees();
            draw();
        }

        function clearGraph() {
            nodes.length = 0;
            edges.length = 0;
            nodeIdCounter = 0;
            document.getElementById('result').innerHTML = '';
            document.getElementById('status').textContent = 'Ready';
            document.getElementById('queue').innerHTML = '';
            document.getElementById('error').style.display = 'none';
            animationRunning = false;
            draw();
        }

        function calculateInDegrees() {
            nodes.forEach(node => node.inDegree = 0);
            edges.forEach(edge => edge.to.inDegree++);
        }

        let mouseX = 0, mouseY = 0;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (draggedNode) {
                draggedNode.x = mouseX;
                draggedNode.y = mouseY;
                draw();
            }

            if (isCreatingEdge) {
                draw();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNode = nodes.find(node => node.contains(x, y));

            if (clickedNode) {
                if (e.shiftKey) {
                    // Start creating edge
                    selectedNode = clickedNode;
                    isCreatingEdge = true;
                } else {
                    // Start dragging
                    draggedNode = clickedNode;
                }
            } else {
                // Create new node
                nodes.push(new Node(x, y, nodeIdCounter++));
                calculateInDegrees();
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isCreatingEdge && selectedNode) {
                const targetNode = nodes.find(node => node.contains(x, y) && node !== selectedNode);
                if (targetNode) {
                    // Check if edge already exists
                    const edgeExists = edges.some(edge => 
                        edge.from === selectedNode && edge.to === targetNode
                    );
                    if (!edgeExists) {
                        edges.push(new Edge(selectedNode, targetNode));
                        calculateInDegrees();
                    }
                }
                isCreatingEdge = false;
                selectedNode = null;
            }

            draggedNode = null;
            draw();
        });

        async function sleep(ms) {
            const speed = document.getElementById('speed').value;
            const adjustedMs = ms / speed;
            return new Promise(resolve => setTimeout(resolve, adjustedMs));
        }

        async function runTopologicalSort() {
            if (animationRunning) return;
            animationRunning = true;
            animationPaused = false;

            // Reset colors
            nodes.forEach(node => node.color = '#3498db');
            edges.forEach(edge => edge.color = '#34495e');
            document.getElementById('result').innerHTML = '';
            document.getElementById('error').style.display = 'none';
            
            // Calculate in-degrees
            calculateInDegrees();
            
            // Find nodes with in-degree 0
            const queue = [];
            const result = [];
            const inDegrees = {};
            
            nodes.forEach(node => {
                inDegrees[node.id] = node.inDegree;
                if (node.inDegree === 0) {
                    queue.push(node);
                }
            });

            document.getElementById('status').textContent = 'Running...';
            
            while (queue.length > 0 && !animationPaused) {
                updateQueue(queue);
                
                const current = queue.shift();
                current.color = '#f39c12'; // Processing
                draw();
                await sleep(1000);
                
                if (animationPaused) {
                    queue.unshift(current);
                    break;
                }
                
                result.push(current);
                current.color = '#27ae60'; // Completed
                
                // Update result display
                updateResult(result);
                
                // Process edges from current node
                edges.forEach(edge => {
                    if (edge.from === current) {
                        edge.color = '#27ae60';
                        inDegrees[edge.to.id]--;
                        edge.to.inDegree = inDegrees[edge.to.id];
                        
                        if (inDegrees[edge.to.id] === 0) {
                            queue.push(edge.to);
                        }
                    }
                });
                
                draw();
                await sleep(500);
            }
            
            if (!animationPaused) {
                // Check for cycles
                if (result.length !== nodes.length) {
                    document.getElementById('error').textContent = 'Cycle detected! Topological sort is not possible.';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('status').textContent = 'Error: Cycle detected';
                    
                    // Highlight remaining nodes in red
                    nodes.forEach(node => {
                        if (!result.includes(node)) {
                            node.color = '#e74c3c';
                        }
                    });
                    draw();
                } else {
                    document.getElementById('status').textContent = 'Complete!';
                }
                animationRunning = false;
            }
        }

        function pauseResume() {
            if (!animationRunning) return;
            animationPaused = !animationPaused;
            if (!animationPaused) {
                runTopologicalSort();
            }
        }

        function updateQueue(queue) {
            const queueDiv = document.getElementById('queue');
            queueDiv.innerHTML = queue.map(node => 
                `<span class="queue-item">${node.label}</span>`
            ).join('');
        }

        function updateResult(result) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = result.map((node, index) => 
                `<div class="result-node">${node.label}</div>${
                    index < result.length - 1 ? '<span class="result-arrow">â†’</span>' : ''
                }`
            ).join('');
        }

        // Add initial nodes for demonstration
        setTimeout(() => {
            nodes.push(new Node(150, 150, nodeIdCounter++));
            nodes.push(new Node(350, 100, nodeIdCounter++));
            nodes.push(new Node(350, 250, nodeIdCounter++));
            nodes.push(new Node(550, 175, nodeIdCounter++));
            
            edges.push(new Edge(nodes[0], nodes[1]));
            edges.push(new Edge(nodes[0], nodes[2]));
            edges.push(new Edge(nodes[1], nodes[3]));
            edges.push(new Edge(nodes[2], nodes[3]));
            
            calculateInDegrees();
            draw();
        }, 100);
    </script>
</body>
</html>