<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            padding: 24px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 24px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 24px;
            font-size: 2rem;
        }

        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        input[type="number"], input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            width: 100px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #4CAF50;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            min-width: 44px;
            min-height: 44px;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #1976d2;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        #treeCanvas {
            background: #ffffff;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            width: 100%;
            height: 500px;
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        .tree-node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .tree-node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .tree-node.highlighting {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .tree-line {
            position: absolute;
            background: #999;
            height: 2px;
            transform-origin: left center;
            transition: all 0.3s ease;
            z-index: 1;
        }

        .tree-line.highlighting {
            background: #4CAF50;
            height: 3px;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .info-section {
            background: white;
            padding: 16px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .info-section h3 {
            color: #333;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #333;
        }

        #traversalResult {
            font-family: monospace;
            font-size: 1.1rem;
            color: #2196F3;
            word-spacing: 0.5em;
        }

        #operationLog {
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .search-highlight {
            background: #FFF59D !important;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
        }

        .error-highlight {
            background: #FFCDD2 !important;
        }

        .success-highlight {
            background: #C8E6C9 !important;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                flex-direction: column;
                width: 100%;
            }

            input[type="number"], input[type="text"] {
                width: 100%;
            }

            button {
                width: 100%;
            }
        }

        .balance-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .balanced {
            background: #C8E6C9;
            color: #2E7D32;
        }

        .slightly-unbalanced {
            background: #FFF9C4;
            color: #F57C00;
        }

        .unbalanced {
            background: #FFCDD2;
            color: #C62828;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Binary Search Tree Explorer</h1>
        
        <div class="controls">
            <div class="control-group">
                <input type="number" id="insertValue" placeholder="Value" min="0" max="999" 
                       aria-label="Value to insert">
                <button class="btn-primary" onclick="insertNode()" 
                        aria-label="Insert value into tree">Insert</button>
            </div>
            
            <div class="control-group">
                <input type="text" id="searchValue" placeholder="Search..." 
                       oninput="searchNode()" aria-label="Search for value">
            </div>
            
            <div class="control-group">
                <button class="btn-secondary" onclick="traverseTree('inorder')">Inorder</button>
                <button class="btn-secondary" onclick="traverseTree('preorder')">Preorder</button>
                <button class="btn-secondary" onclick="traverseTree('postorder')">Postorder</button>
            </div>
            
            <div class="control-group">
                <button class="btn-secondary" onclick="generateRandomTree()">Random Tree</button>
                <button class="btn-danger" onclick="clearTree()">Clear Tree</button>
            </div>
        </div>

        <div id="treeCanvas">
            <div class="balance-indicator balanced" id="balanceIndicator">Balanced</div>
        </div>

        <div class="info-panel">
            <div class="info-section">
                <h3>Tree Statistics</h3>
                <div class="stat">
                    <span>Node Count:</span>
                    <span class="stat-value" id="nodeCount">0</span>
                </div>
                <div class="stat">
                    <span>Tree Height:</span>
                    <span class="stat-value" id="treeHeight">0</span>
                </div>
                <div class="stat">
                    <span>Balance Factor:</span>
                    <span class="stat-value" id="balanceFactor">0</span>
                </div>
            </div>
            
            <div class="info-section">
                <h3>Traversal Result</h3>
                <div id="traversalResult">Click a traversal button to see results</div>
            </div>
            
            <div class="info-section">
                <h3>Operation Log</h3>
                <div id="operationLog"></div>
            </div>
        </div>
    </div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
                this.element = null;
                this.leftLine = null;
                this.rightLine = null;
            }
        }

        class BinarySearchTree {
            constructor() {
                this.root = null;
                this.nodeCount = 0;
                this.canvas = document.getElementById('treeCanvas');
                this.canvasRect = this.canvas.getBoundingClientRect();
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                    this.nodeCount++;
                    this.updateDisplay();
                    this.logOperation(`Inserted ${value} as root`);
                    return true;
                }

                let current = this.root;
                let parent = null;
                const path = [];

                while (current) {
                    path.push(current);
                    parent = current;
                    
                    if (value < current.value) {
                        current = current.left;
                    } else if (value > current.value) {
                        current = current.right;
                    } else {
                        this.logOperation(`Value ${value} already exists`);
                        this.highlightPath(path, 'error-highlight');
                        return false;
                    }
                }

                if (value < parent.value) {
                    parent.left = newNode;
                } else {
                    parent.right = newNode;
                }

                this.nodeCount++;
                this.highlightPath(path, 'success-highlight');
                this.updateDisplay();
                this.logOperation(`Inserted ${value}`);
                return true;
            }

            delete(value) {
                this.root = this.deleteNode(this.root, value);
                this.updateDisplay();
            }

            deleteNode(node, value) {
                if (!node) {
                    this.logOperation(`Value ${value} not found`);
                    return null;
                }

                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                } else {
                    // Node found
                    if (!node.left && !node.right) {
                        // Leaf node
                        this.logOperation(`Deleted leaf node ${value}`);
                        this.nodeCount--;
                        return null;
                    } else if (!node.left) {
                        // Only right child
                        this.logOperation(`Deleted node ${value} with right child`);
                        this.nodeCount--;
                        return node.right;
                    } else if (!node.right) {
                        // Only left child
                        this.logOperation(`Deleted node ${value} with left child`);
                        this.nodeCount--;
                        return node.left;
                    } else {
                        // Two children - find inorder successor
                        let successor = node.right;
                        while (successor.left) {
                            successor = successor.left;
                        }
                        node.value = successor.value;
                        node.right = this.deleteNode(node.right, successor.value);
                        this.logOperation(`Deleted node ${value} with two children, replaced with ${successor.value}`);
                    }
                }
                return node;
            }

            search(value) {
                let current = this.root;
                const path = [];

                while (current) {
                    path.push(current);
                    if (value === current.value) {
                        this.highlightPath(path, 'search-highlight');
                        return current;
                    }
                    current = value < current.value ? current.left : current.right;
                }

                this.highlightPath(path, 'error-highlight');
                return null;
            }

            highlightPath(path, className) {
                path.forEach((node, index) => {
                    setTimeout(() => {
                        if (node.element) {
                            node.element.classList.add(className);
                            setTimeout(() => {
                                node.element.classList.remove(className);
                            }, 1000);
                        }
                    }, index * 200);
                });
            }

            traverseInorder(node, result = []) {
                if (node) {
                    this.traverseInorder(node.left, result);
                    result.push(node.value);
                    this.highlightNode(node, result.length * 300);
                    this.traverseInorder(node.right, result);
                }
                return result;
            }

            traversePreorder(node, result = []) {
                if (node) {
                    result.push(node.value);
                    this.highlightNode(node, result.length * 300);
                    this.traversePreorder(node.left, result);
                    this.traversePreorder(node.right, result);
                }
                return result;
            }

            traversePostorder(node, result = []) {
                if (node) {
                    this.traversePostorder(node.left, result);
                    this.traversePostorder(node.right, result);
                    result.push(node.value);
                    this.highlightNode(node, result.length * 300);
                }
                return result;
            }

            highlightNode(node, delay) {
                setTimeout(() => {
                    if (node.element) {
                        node.element.classList.add('highlighting');
                        setTimeout(() => {
                            node.element.classList.remove('highlighting');
                        }, 500);
                    }
                }, delay);
            }

            getHeight(node) {
                if (!node) return -1;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            getBalanceFactor(node) {
                if (!node) return 0;
                return this.getHeight(node.left) - this.getHeight(node.right);
            }

            updateDisplay() {
                this.clearDisplay();
                if (this.root) {
                    this.calculatePositions(this.root, this.canvas.offsetWidth / 2, 50, this.canvas.offsetWidth / 4);
                    this.drawTree(this.root);
                }
                this.updateStats();
            }

            calculatePositions(node, x, y, offset) {
                if (!node) return;

                node.x = x;
                node.y = y;

                if (node.left) {
                    this.calculatePositions(node.left, x - offset, y + 80, offset / 2);
                }
                if (node.right) {
                    this.calculatePositions(node.right, x + offset, y + 80, offset / 2);
                }
            }

            drawTree(node) {
                if (!node) return;

                // Draw lines first (behind nodes)
                if (node.left) {
                    this.drawLine(node, node.left, 'left');
                    this.drawTree(node.left);
                }
                if (node.right) {
                    this.drawLine(node, node.right, 'right');
                    this.drawTree(node.right);
                }

                // Draw node
                const nodeElement = document.createElement('div');
                nodeElement.className = 'tree-node';
                nodeElement.textContent = node.value;
                nodeElement.style.left = (node.x - 20) + 'px';
                nodeElement.style.top = (node.y - 20) + 'px';
                nodeElement.onclick = () => {
                    if (confirm(`Delete node ${node.value}?`)) {
                        this.delete(node.value);
                    }
                };
                nodeElement.setAttribute('aria-label', `Tree node with value ${node.value}`);
                this.canvas.appendChild(nodeElement);
                node.element = nodeElement;
            }

            drawLine(parent, child, side) {
                const line = document.createElement('div');
                line.className = 'tree-line';
                
                const dx = child.x - parent.x;
                const dy = child.y - parent.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.width = length + 'px';
                line.style.left = parent.x + 'px';
                line.style.top = parent.y + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                this.canvas.appendChild(line);
                
                if (side === 'left') {
                    parent.leftLine = line;
                } else {
                    parent.rightLine = line;
                }
            }

            clearDisplay() {
                this.canvas.innerHTML = '<div class="balance-indicator balanced" id="balanceIndicator">Balanced</div>';
            }

            updateStats() {
                document.getElementById('nodeCount').textContent = this.nodeCount;
                document.getElementById('treeHeight').textContent = this.getHeight(this.root) + 1;
                
                const balanceFactor = Math.abs(this.getBalanceFactor(this.root));
                document.getElementById('balanceFactor').textContent = balanceFactor;
                
                const indicator = document.getElementById('balanceIndicator');
                if (balanceFactor <= 1) {
                    indicator.className = 'balance-indicator balanced';
                    indicator.textContent = 'Balanced';
                } else if (balanceFactor === 2) {
                    indicator.className = 'balance-indicator slightly-unbalanced';
                    indicator.textContent = 'Slightly Unbalanced';
                } else {
                    indicator.className = 'balance-indicator unbalanced';
                    indicator.textContent = 'Unbalanced';
                }
            }

            logOperation(message) {
                const log = document.getElementById('operationLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                log.insertBefore(entry, log.firstChild);
                
                // Keep only last 5 entries
                while (log.children.length > 5) {
                    log.removeChild(log.lastChild);
                }
            }
        }

        // Initialize BST
        const bst = new BinarySearchTree();

        // Functions for UI interaction
        function insertNode() {
            const input = document.getElementById('insertValue');
            const value = parseInt(input.value);
            
            if (isNaN(value) || value < 0 || value > 999) {
                alert('Please enter a valid number between 0 and 999');
                return;
            }
            
            bst.insert(value);
            input.value = '';
            input.focus();
        }

        function searchNode() {
            const value = parseInt(document.getElementById('searchValue').value);
            if (!isNaN(value)) {
                bst.search(value);
            }
        }

        function traverseTree(order) {
            let result = [];
            switch(order) {
                case 'inorder':
                    result = bst.traverseInorder(bst.root);
                    break;
                case 'preorder':
                    result = bst.traversePreorder(bst.root);
                    break;
                case 'postorder':
                    result = bst.traversePostorder(bst.root);
                    break;
            }
            
            document.getElementById('traversalResult').textContent = 
                result.length > 0 ? result.join(' â†’ ') : 'Tree is empty';
        }

        function generateRandomTree() {
            clearTree();
            const count = Math.floor(Math.random() * 8) + 5;
            const values = new Set();
            
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100));
            }
            
            values.forEach(value => bst.insert(value));
        }

        function clearTree() {
            bst.root = null;
            bst.nodeCount = 0;
            bst.updateDisplay();
            document.getElementById('traversalResult').textContent = 'Click a traversal button to see results';
            bst.logOperation('Tree cleared');
        }

        // Keyboard shortcuts
        document.getElementById('insertValue').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                insertNode();
            }
        });

        // Initialize with sample tree
        window.addEventListener('load', () => {
            [50, 30, 70, 20, 40, 60, 80].forEach(value => bst.insert(value));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            bst.canvasRect = bst.canvas.getBoundingClientRect();
            bst.updateDisplay();
        });
    </script>
</body>
</html>