<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Linear Regression</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            padding: 24px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 32px;
        }
        
        h1 {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 32px;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            gap: 32px;
            margin-bottom: 24px;
        }
        
        .control-panel {
            flex: 0 0 300px;
            background: #f8f9fa;
            padding: 24px;
            border-radius: 8px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: #fff;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
        }
        
        .control-group {
            margin-bottom: 24px;
        }
        
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #495057;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .button {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .button-primary {
            background: #3498db;
            color: white;
        }
        
        .button-primary:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        
        .button-secondary {
            background: #ecf0f1;
            color: #2c3e50;
        }
        
        .button-secondary:hover {
            background: #d5dbdb;
        }
        
        .stats {
            background: white;
            padding: 16px;
            border-radius: 6px;
            margin-top: 24px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .stat-label {
            color: #7f8c8d;
        }
        
        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .instructions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 16px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .control-panel {
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Understanding Linear Regression</h1>
        <p class="subtitle">Finding the Best-Fit Line Through Data Points</p>
        
        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Slope (m)</label>
                    <div class="slider-container">
                        <input type="range" id="slopeSlider" min="-2" max="2" step="0.01" value="0.5">
                        <span class="value-display" id="slopeValue">0.50</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Intercept (b)</label>
                    <div class="slider-container">
                        <input type="range" id="interceptSlider" min="-100" max="100" step="1" value="50">
                        <span class="value-display" id="interceptValue">50</span>
                    </div>
                </div>
                
                <button class="button button-primary" id="fitButton">
                    Auto-Fit Best Line
                </button>
                
                <button class="button button-secondary" id="clearButton">
                    Clear All Points
                </button>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="showErrors" checked>
                    <label for="showErrors">Show Error Lines</label>
                </div>
                
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">Data Points:</span>
                        <span class="stat-value" id="pointCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">RÂ² Value:</span>
                        <span class="stat-value" id="r2Value">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mean Squared Error:</span>
                        <span class="stat-value" id="mseValue">-</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
        </div>
        
        <div class="instructions">
            <strong>How to use:</strong> Click anywhere on the graph to add data points. 
            Adjust the slope and intercept sliders to manually fit a line, or click "Auto-Fit" 
            to find the best-fit line automatically using least squares regression. 
            The red lines show the errors (residuals) between your line and the data points.
            The goal of linear regression is to minimize these errors.
        </div>
    </div>
    
    <script>
        class LinearRegressionDemo {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.points = [];
                this.slope = 0.5;
                this.intercept = 50;
                this.showErrors = true;
                this.padding = 40;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.animate();
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = 500;
            }
            
            setupEventListeners() {
                // Canvas click to add points
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const dataX = this.screenToDataX(x);
                    const dataY = this.screenToDataY(y);
                    
                    this.points.push({ x: dataX, y: dataY });
                    this.updateStats();
                });
                
                // Slider controls
                const slopeSlider = document.getElementById('slopeSlider');
                const interceptSlider = document.getElementById('interceptSlider');
                
                slopeSlider.addEventListener('input', (e) => {
                    this.slope = parseFloat(e.target.value);
                    document.getElementById('slopeValue').textContent = this.slope.toFixed(2);
                    this.updateStats();
                });
                
                interceptSlider.addEventListener('input', (e) => {
                    this.intercept = parseFloat(e.target.value);
                    document.getElementById('interceptValue').textContent = this.intercept;
                    this.updateStats();
                });
                
                // Buttons
                document.getElementById('fitButton').addEventListener('click', () => {
                    this.fitLine();
                });
                
                document.getElementById('clearButton').addEventListener('click', () => {
                    this.points = [];
                    this.updateStats();
                });
                
                // Checkbox
                document.getElementById('showErrors').addEventListener('change', (e) => {
                    this.showErrors = e.target.checked;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }
            
            screenToDataX(screenX) {
                const dataWidth = this.canvas.width - 2 * this.padding;
                return ((screenX - this.padding) / dataWidth) * 100;
            }
            
            screenToDataY(screenY) {
                const dataHeight = this.canvas.height - 2 * this.padding;
                return 100 - ((screenY - this.padding) / dataHeight) * 100;
            }
            
            dataToScreenX(dataX) {
                const dataWidth = this.canvas.width - 2 * this.padding;
                return this.padding + (dataX / 100) * dataWidth;
            }
            
            dataToScreenY(dataY) {
                const dataHeight = this.canvas.height - 2 * this.padding;
                return this.padding + (1 - dataY / 100) * dataHeight;
            }
            
            fitLine() {
                if (this.points.length < 2) return;
                
                // Calculate means
                const n = this.points.length;
                const meanX = this.points.reduce((sum, p) => sum + p.x, 0) / n;
                const meanY = this.points.reduce((sum, p) => sum + p.y, 0) / n;
                
                // Calculate slope
                let numerator = 0;
                let denominator = 0;
                
                for (const point of this.points) {
                    numerator += (point.x - meanX) * (point.y - meanY);
                    denominator += (point.x - meanX) * (point.x - meanX);
                }
                
                const newSlope = denominator !== 0 ? numerator / denominator : 0;
                const newIntercept = meanY - newSlope * meanX;
                
                // Animate to new values
                this.animateToValues(newSlope, newIntercept);
            }
            
            animateToValues(targetSlope, targetIntercept) {
                const startSlope = this.slope;
                const startIntercept = this.intercept;
                const duration = 500;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = this.easeInOutCubic(progress);
                    
                    this.slope = startSlope + (targetSlope - startSlope) * eased;
                    this.intercept = startIntercept + (targetIntercept - startIntercept) * eased;
                    
                    document.getElementById('slopeSlider').value = this.slope;
                    document.getElementById('interceptSlider').value = this.intercept;
                    document.getElementById('slopeValue').textContent = this.slope.toFixed(2);
                    document.getElementById('interceptValue').textContent = Math.round(this.intercept);
                    
                    this.updateStats();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            calculateR2() {
                if (this.points.length < 2) return 0;
                
                const n = this.points.length;
                const meanY = this.points.reduce((sum, p) => sum + p.y, 0) / n;
                
                let ssTotal = 0;
                let ssResidual = 0;
                
                for (const point of this.points) {
                    const predicted = this.slope * point.x + this.intercept;
                    ssTotal += Math.pow(point.y - meanY, 2);
                    ssResidual += Math.pow(point.y - predicted, 2);
                }
                
                return ssTotal === 0 ? 0 : 1 - (ssResidual / ssTotal);
            }
            
            calculateMSE() {
                if (this.points.length === 0) return 0;
                
                let sumSquaredErrors = 0;
                for (const point of this.points) {
                    const predicted = this.slope * point.x + this.intercept;
                    sumSquaredErrors += Math.pow(point.y - predicted, 2);
                }
                
                return sumSquaredErrors / this.points.length;
            }
            
            updateStats() {
                document.getElementById('pointCount').textContent = this.points.length;
                
                if (this.points.length > 0) {
                    const r2 = this.calculateR2();
                    const mse = this.calculateMSE();
                    document.getElementById('r2Value').textContent = r2.toFixed(3);
                    document.getElementById('mseValue').textContent = mse.toFixed(1);
                } else {
                    document.getElementById('r2Value').textContent = '-';
                    document.getElementById('mseValue').textContent = '-';
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.drawGrid();
                
                // Draw axes
                this.drawAxes();
                
                // Draw regression line
                this.drawRegressionLine();
                
                // Draw error lines
                if (this.showErrors && this.points.length > 0) {
                    this.drawErrorLines();
                }
                
                // Draw points
                this.drawPoints();
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#f0f0f0';
                this.ctx.lineWidth = 1;
                
                // Vertical lines
                for (let i = 0; i <= 10; i++) {
                    const x = this.dataToScreenX(i * 10);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.padding);
                    this.ctx.lineTo(x, this.canvas.height - this.padding);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let i = 0; i <= 10; i++) {
                    const y = this.dataToScreenY(i * 10);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, y);
                    this.ctx.lineTo(this.canvas.width - this.padding, y);
                    this.ctx.stroke();
                }
            }
            
            drawAxes() {
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 2;
                
                // X-axis
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding, this.canvas.height - this.padding);
                this.ctx.lineTo(this.canvas.width - this.padding, this.canvas.height - this.padding);
                this.ctx.stroke();
                
                // Y-axis
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding, this.padding);
                this.ctx.lineTo(this.padding, this.canvas.height - this.padding);
                this.ctx.stroke();
                
                // Labels
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                
                // X-axis labels
                for (let i = 0; i <= 10; i++) {
                    const x = this.dataToScreenX(i * 10);
                    this.ctx.fillText(i * 10, x, this.canvas.height - this.padding + 20);
                }
                
                // Y-axis labels
                this.ctx.textAlign = 'right';
                for (let i = 0; i <= 10; i++) {
                    const y = this.dataToScreenY(i * 10);
                    this.ctx.fillText(i * 10, this.padding - 10, y + 4);
                }
            }
            
            drawRegressionLine() {
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 3;
                
                const y1 = this.slope * 0 + this.intercept;
                const y2 = this.slope * 100 + this.intercept;
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.dataToScreenX(0), this.dataToScreenY(y1));
                this.ctx.lineTo(this.dataToScreenX(100), this.dataToScreenY(y2));
                this.ctx.stroke();
            }
            
            drawErrorLines() {
                this.ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                for (const point of this.points) {
                    const predictedY = this.slope * point.x + this.intercept;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.dataToScreenX(point.x), this.dataToScreenY(point.y));
                    this.ctx.lineTo(this.dataToScreenX(point.x), this.dataToScreenY(predictedY));
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            drawPoints() {
                for (const point of this.points) {
                    const x = this.dataToScreenX(point.x);
                    const y = this.dataToScreenY(point.y);
                    
                    // Outer circle
                    this.ctx.fillStyle = '#2c3e50';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Inner circle
                    this.ctx.fillStyle = '#ecf0f1';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the demo
        const demo = new LinearRegressionDemo();
    </script>
</body>
</html>