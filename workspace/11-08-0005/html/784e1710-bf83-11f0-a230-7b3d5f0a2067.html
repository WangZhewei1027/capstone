<!DOCTYPE html>
## Interactive Design Plan: Depth-First Search (DFS)

### Concept Title
**"Depth-First Search: Exploring Graphs One Path at a Time"**

### Learning Objective
Users should understand how DFS systematically explores a graph by going as deep as possible along each branch before backtracking. They will learn to recognize the stack-based nature of DFS, understand visited node tracking, and see how DFS differs from breadth-first traversal through interactive visualization.

### Interaction Design

**User Interactions:**
1. **Node Creation**: Click on empty canvas space to add nodes to the graph
2. **Edge Creation**: Click and drag from one node to another to create directed edges
3. **Start Selection**: Click any node and press "Set as Start" button to choose the starting point
4. **Algorithm Control**: 
   - "Start DFS" button initiates the visualization
   - "Step" button allows manual progression through the algorithm
   - "Auto-Run" toggle for automatic stepping with adjustable speed
   - "Reset" button clears the traversal state while keeping the graph
   - "Clear Graph" button removes all nodes and edges

**Visual Feedback & Animations:**
1. **Node States**: 
   - Unvisited (light gray)
   - Currently visiting (pulsing yellow)
   - In stack (orange)
   - Fully explored (dark green)
2. **Edge Animations**: 
   - Edge highlighting when being traversed (animated stroke)
   - Different colors for tree edges vs back edges
3. **Stack Visualization**: 
   - Live stack display showing current path
   - Push/pop animations when nodes are added/removed
4. **Traversal Order**: 
   - Numbered badges appear on nodes showing visit order
   - Path trace animation showing the complete DFS path

### Layout Description

**Main Container (100vw × 100vh)**
- 24px safe margins on all sides

**Left Panel (30% width)**
- **Controls Section** (top)
  - Title and brief description
  - Button group for graph manipulation
  - Algorithm control buttons with 16px spacing
  - Speed slider for auto-run mode
  
- **Information Display** (middle)
  - Current step explanation
  - Pseudocode with highlighted current line
  - Statistics (nodes visited, edges traversed)

- **Stack Visualization** (bottom)
  - Vertical stack representation
  - Smooth push/pop animations
  - Node labels with state indicators

**Center Canvas (50% width)**
- Interactive graph drawing area
- Grid background for spatial reference
- Node drag capability for repositioning
- Zoom and pan controls in corner
- Legend showing node/edge color meanings

**Right Panel (20% width)**
- **Traversal History**
  - Step-by-step log of DFS actions
  - Scrollable list with timestamps
  - Clear visual separation between steps

**Responsive Breakpoints:**
- Desktop (>1024px): Three-column layout
- Tablet (768-1024px): Stack right panel below main canvas
- Mobile (<768px): Single column with collapsible sections

**Visual Hierarchy:**
- Primary focus on canvas area
- High contrast for active elements
- Subtle shadows for depth perception
- Consistent 16px minimum spacing between all interactive elements
- Clear visual grouping of related controls

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth-First Search Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f7fa;
            color: #2d3748;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 24px;
            gap: 24px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .left-panel {
            width: 300px;
            gap: 24px;
        }

        .center-panel {
            flex: 1;
            position: relative;
            padding: 0;
        }

        .right-panel {
            width: 280px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #1a202c;
        }

        .description {
            font-size: 14px;
            color: #718096;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #4299e1;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #718096;
        }

        button.secondary:hover {
            background: #4a5568;
        }

        button.danger {
            background: #f56565;
        }

        button.danger:hover {
            background: #e53e3e;
        }

        .canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background: #fafafa;
            border-radius: 12px;
            overflow: hidden;
            cursor: crosshair;
        }

        .canvas svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node.unvisited {
            fill: #e2e8f0;
            stroke: #cbd5e0;
        }

        .node.visiting {
            fill: #ffd93d;
            stroke: #f6c23e;
            animation: pulse 1s infinite;
        }

        .node.in-stack {
            fill: #fed7aa;
            stroke: #fb923c;
        }

        .node.visited {
            fill: #48bb78;
            stroke: #38a169;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .edge {
            fill: none;
            stroke: #cbd5e0;
            stroke-width: 2;
            marker-end: url(#arrowhead);
            transition: all 0.3s;
        }

        .edge.traversing {
            stroke: #4299e1;
            stroke-width: 3;
            stroke-dasharray: 5;
            animation: dash 0.5s linear infinite;
        }

        .edge.tree-edge {
            stroke: #48bb78;
            stroke-width: 3;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        .node-label {
            font-size: 16px;
            font-weight: bold;
            fill: #2d3748;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }

        .visit-order {
            font-size: 12px;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .stack-container {
            flex: 1;
            background: #f7fafc;
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
        }

        .stack-item {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s;
        }

        .stack-item.active {
            border-color: #4299e1;
            background: #ebf8ff;
        }

        .info-section {
            background: #f7fafc;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .info-section h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #2d3748;
        }

        .pseudocode {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .pseudocode .active-line {
            background: #bee3f8;
            margin: 0 -12px;
            padding: 0 12px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        .stat-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4299e1;
        }

        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 4px;
        }

        .history-container {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }

        .history-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f7fafc;
            border-radius: 6px;
            font-size: 14px;
            border-left: 3px solid #4299e1;
        }

        .history-item.backtrack {
            border-left-color: #f56565;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #e2e8f0;
            border-radius: 2px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .legend {
            position: absolute;
            bottom: 24px;
            right: 24px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid;
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel left-panel">
            <div>
                <h1>Depth-First Search</h1>
                <p class="description">
                    Explore how DFS traverses a graph by going as deep as possible along each branch before backtracking.
                </p>
            </div>

            <div>
                <h3>Graph Controls</h3>
                <div class="button-group">
                    <button id="addNodeBtn">Add Node</button>
                    <button id="addEdgeBtn" class="secondary">Add Edge</button>
                    <button id="clearGraphBtn" class="danger">Clear Graph</button>
                </div>
            </div>

            <div>
                <h3>Algorithm Controls</h3>
                <div class="button-group">
                    <button id="startDfsBtn">Start DFS</button>
                    <button id="stepBtn" disabled>Step</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>
                
                <div class="controls-row">
                    <div class="toggle">
                        <input type="checkbox" id="autoRun">
                        <label for="autoRun">Auto-Run</label>
                    </div>
                    <div class="slider-container">
                        <span>Speed:</span>
                        <input type="range" class="slider" id="speedSlider" min="100" max="2000" value="1000">
                    </div>
                </div>
            </div>

            <div class="info-section">
                <h3>Current Step</h3>
                <p id="currentStep">Click on the canvas to add nodes, then connect them with edges.</p>
            </div>

            <div class="info-section">
                <h3>Pseudocode</h3>
                <div class="pseudocode" id="pseudocode">
                    <div>DFS(start):</div>
                    <div>  stack = [start]</div>
                    <div>  visited = set()</div>
                    <div>  while stack is not empty:</div>
                    <div>    node = stack.pop()</div>
                    <div>    if node not in visited:</div>
                    <div>      visited.add(node)</div>
                    <div>      for neighbor in node.neighbors:</div>
                    <div>        if neighbor not in visited:</div>
                    <div>          stack.push(neighbor)</div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="nodesVisited">0</div>
                    <div class="stat-label">Nodes Visited</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="edgesTraversed">0</div>
                    <div class="stat-label">Edges Traversed</div>
                </div>
            </div>

            <div style="flex: 1; display: flex; flex-direction: column;">
                <h3>Stack</h3>
                <div class="stack-container" id="stackContainer"></div>
            </div>
        </div>

        <div class="panel center-panel">
            <div class="canvas" id="canvas">
                <svg id="graphSvg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#cbd5e0" />
                        </marker>
                    </defs>
                    <g id="edges"></g>
                    <g id="nodes"></g>
                </svg>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #e2e8f0; border-color: #cbd5e0;"></div>
                    <span>Unvisited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d; border-color: #f6c23e;"></div>
                    <span>Currently Visiting</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fed7aa; border-color: #fb923c;"></div>
                    <span>In Stack</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #48bb78; border-color: #38a169;"></div>
                    <span>Fully Explored</span>
                </div>
            </div>
        </div>

        <div class="panel right-panel">
            <h3>Traversal History</h3>
            <div class="history-container" id="historyContainer"></div>
        </div>
    </div>

    <script>
        class DFSVisualizer {
            constructor() {
                this.nodes = new Map();
                this.edges = [];
                this.selectedNode = null;
                this.startNode = null;
                this.mode = 'add-node';
                this.isRunning = false;
                this.isPaused = false;
                this.nodeCounter = 0;
                
                this.stack = [];
                this.visited = new Set();
                this.visitOrder = new Map();
                this.currentNode = null;
                this.pseudocodeLine = 0;
                
                this.initializeElements();
                this.attachEventListeners();
                this.createSampleGraph();
            }

            initializeElements() {
                this.canvas = document.getElementById('canvas');
                this.svg = document.getElementById('graphSvg');
                this.nodesGroup = document.getElementById('nodes');
                this.edgesGroup = document.getElementById('edges');
                this.stackContainer = document.getElementById('stackContainer');
                this.historyContainer = document.getElementById('historyContainer');
                this.currentStepEl = document.getElementById('currentStep');
                this.nodesVisitedEl = document.getElementById('nodesVisited');
                this.edgesTraversedEl = document.getElementById('edgesTraversed');
                this.pseudocodeEl = document.getElementById('pseudocode');
                
                this.addNodeBtn = document.getElementById('addNodeBtn');
                this.addEdgeBtn = document.getElementById('addEdgeBtn');
                this.clearGraphBtn = document.getElementById('clearGraphBtn');
                this.startDfsBtn = document.getElementById('startDfsBtn');
                this.stepBtn = document.getElementById('stepBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.autoRunCheckbox = document.getElementById('autoRun');
                this.speedSlider = document.getElementById('speedSlider');
            }

            attachEventListeners() {
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                this.addNodeBtn.addEventListener('click', () => this.setMode('add-node'));
                this.addEdgeBtn.addEventListener('click', () => this.setMode('add-edge'));
                this.clearGraphBtn.addEventListener('click', () => this.clearGraph());
                this.startDfsBtn.addEventListener('click', () => this.startDFS());
                this.stepBtn.addEventListener('click', () => this.stepDFS());
                this.resetBtn.addEventListener('click', () => this.resetTraversal());
                this.autoRunCheckbox.addEventListener('change', () => this.toggleAutoRun());
            }

            setMode(mode) {
                this.mode = mode;
                this.selectedNode = null;
                this.updateModeButtons();
                this.updateCurrentStep();
            }

            updateModeButtons() {
                this.addNodeBtn.classList.toggle('secondary', this.mode !== 'add-node');
                this.addEdgeBtn.classList.toggle('secondary', this.mode !== 'add-edge');
            }

            updateCurrentStep() {
                if (this.isRunning) return;
                
                if (this.mode === 'add-node') {
                    this.currentStepEl.textContent = 'Click on the canvas to add nodes.';
                } else if (this.mode === 'add-edge') {
                    this.currentStepEl.textContent = 'Click a node, then click another to create an edge.';
                }
            }

            handleCanvasClick(event) {
                if (this.isRunning) return;
                
                const rect = this.svg.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                if (this.mode === 'add-node') {
                    const clickedNode = this.getNodeAt(x, y);
                    if (!clickedNode) {
                        this.addNode(x, y);
                    }
                } else if (this.mode === 'add-edge') {
                    const clickedNode = this.getNodeAt(x, y);
                    if (clickedNode) {
                        if (!this.selectedNode) {
                            this.selectedNode = clickedNode;
                            this.highlightNode(clickedNode);
                        } else {
                            if (this.selectedNode !== clickedNode) {
                                this.addEdge(this.selectedNode, clickedNode);
                            }
                            this.unhighlightNode(this.selectedNode);
                            this.selectedNode = null;
                        }
                    }
                }
            }

            getNodeAt(x, y) {
                for (const [id, node] of this.nodes) {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    if (Math.sqrt(dx * dx + dy * dy) <= 25) {
                        return id;
                    }
                }
                return null;
            }

            addNode(x, y) {
                const id = `node${this.nodeCounter++}`;
                const label = String.fromCharCode(65 + (this.nodeCounter - 1) % 26);
                
                this.nodes.set(id, {
                    id,
                    label,
                    x,
                    y,
                    neighbors: []
                });
                
                this.renderNode(id);
                this.addHistory(`Added node ${label}`);
                
                if (!this.startNode) {
                    this.startNode = id;
                }
            }

            addEdge(fromId, toId) {
                const fromNode = this.nodes.get(fromId);
                const toNode = this.nodes.get(toId);
                
                if (!fromNode.neighbors.includes(toId)) {
                    fromNode.neighbors.push(toId);
                    this.edges.push({ from: fromId, to: toId });
                    this.renderEdge(fromId, toId);
                    this.addHistory(`Added edge ${fromNode.label} → ${toNode.label}`);
                }
            }

            renderNode(id) {
                const node = this.nodes.get(id);
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('id', `node-${id}`);
                g.setAttribute('class', 'node-group');
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 25);
                circle.setAttribute('class', 'node unvisited');
                circle.setAttribute('id', `circle-${id}`);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y);
                text.setAttribute('class', 'node-label');
                text.textContent = node.label;
                
                const orderBadge = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                orderBadge.setAttribute('id', `order-${id}`);
                orderBadge.style.display = 'none';
                
                const badgeCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                badgeCircle.setAttribute('cx', node.x + 18);
                badgeCircle.setAttribute('cy', node.y - 18);
                badgeCircle.setAttribute('r', 10);
                badgeCircle.setAttribute('fill', '#4299e1');
                
                const badgeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badgeText.setAttribute('x', node.x + 18);
                badgeText.setAttribute('y', node.y - 18);
                badgeText.setAttribute('class', 'visit-order');
                
                orderBadge.appendChild(badgeCircle);
                orderBadge.appendChild(badgeText);
                
                g.appendChild(circle);
                g.appendChild(text);
                g.appendChild(orderBadge);
                
                circle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.handleNodeClick(id);
                });
                
                this.nodesGroup.appendChild(g);
            }

            handleNodeClick(id) {
                if (this.isRunning) return;
                
                if (this.mode === 'add-edge') {
                    const clickEvent = new MouseEvent('click', {
                        clientX: this.nodes.get(id).x + this.svg.getBoundingClientRect().left,
                        clientY: this.nodes.get(id).y + this.svg.getBoundingClientRect().top
                    });
                    this.handleCanvasClick(clickEvent);
                } else {
                    this.startNode = id;
                    this.updateStartNode();
                }
            }

            updateStartNode() {
                document.querySelectorAll('.node').forEach(node => {
                    node.style.strokeWidth = '2';
                });
                
                const startCircle = document.getElementById(`circle-${this.startNode}`);
                if (startCircle) {
                    startCircle.style.strokeWidth = '4';
                }
                
                this.addHistory(`Set ${this.nodes.get(this.startNode).label} as start node`);
            }

            renderEdge(fromId, toId) {
                const fromNode = this.nodes.get(fromId);
                const toNode = this.nodes.get(toId);
                
                const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                const startX = fromNode.x + 25 * Math.cos(angle);
                const startY = fromNode.y + 25 * Math.sin(angle);
                const endX = toNode.x - 25 * Math.cos(angle);
                const endY = toNode.y - 25 * Math.sin(angle);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${startX} ${startY} L ${endX} ${endY}`);
                path.setAttribute('class', 'edge');
                path.setAttribute('id', `edge-${fromId}-${toId}`);
                
                this.edgesGroup.appendChild(path);
            }

            highlightNode(id) {
                const circle = document.getElementById(`circle-${id}`);
                if (circle) {
                    circle.style.stroke = '#4299e1';
                    circle.style.strokeWidth = '3';
                }
            }

            unhighlightNode(id) {
                const circle = document.getElementById(`circle-${id}`);
                if (circle) {
                    circle.style.stroke = '';
                    circle.style.strokeWidth = '2';
                }
            }

            clearGraph() {
                this.nodes.clear();
                this.edges = [];
                this.nodeCounter = 0;
                this.startNode = null;
                this.selectedNode = null;
                this.nodesGroup.innerHTML = '';
                this.edgesGroup.innerHTML = '';
                this.resetTraversal();
                this.addHistory('Cleared graph');
            }

            createSampleGraph() {
                // Create a sample graph to start with
                const positions = [
                    { x: 200, y: 100 },
                    { x: 100, y: 200 },
                    { x: 300, y: 200 },
                    { x: 150, y: 300 },
                    { x: 250, y: 300 },
                    { x: 200, y: 400 }
                ];
                
                positions.forEach(pos => this.addNode(pos.x, pos.y));
                
                const edges = [
                    ['node0', 'node1'],
                    ['node0', 'node2'],
                    ['node1', 'node3'],
                    ['node2', 'node4'],
                    ['node3', 'node5'],
                    ['node4', 'node5']
                ];
                
                edges.forEach(([from, to]) => this.addEdge(from, to));
            }

            startDFS() {
                if (!this.startNode || this.nodes.size === 0) {
                    alert('Please create a graph and select a start node first!');
                    return;
                }
                
                this.isRunning = true;
                this.resetTraversal();
                
                this.stack = [this.startNode];
                this.updateStack();
                this.addHistory(`Starting DFS from node ${this.nodes.get(this.startNode).label}`);
                
                this.startDfsBtn.disabled = true;
                this.stepBtn.disabled = false;
                this.addNodeBtn.disabled = true;
                this.addEdgeBtn.disabled = true;
                this.clearGraphBtn.disabled = true;
                
                this.highlightPseudocode(1);
                
                if (this.autoRunCheckbox.checked) {
                    this.runAutoStep();
                }
            }

            stepDFS() {
                if (!this.isRunning || this.stack.length === 0) {
                    this.finishDFS();
                    return;
                }
                
                const nodeId = this.stack.pop();
                this.