<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
        }

        header {
            text-align: center;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 2em;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 24px;
            margin-bottom: 24px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .graph-container {
            position: relative;
            background: #fafafa;
            border-radius: 8px;
            min-height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            filter: brightness(1.1);
        }

        .node.current {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .node-circle {
            fill: #3498db;
            stroke: #2c3e50;
            stroke-width: 2;
            transition: fill 0.3s ease;
        }

        .node.visited .node-circle {
            fill: #27ae60;
        }

        .node.current .node-circle {
            fill: #e74c3c;
        }

        .node-label {
            fill: white;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
        }

        .edge {
            stroke: #7f8c8d;
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .edge.highlighted {
            stroke: #f39c12;
            stroke-width: 4;
        }

        .edge.shortest-path {
            stroke: #f1c40f;
            stroke-width: 5;
            filter: drop-shadow(0 0 3px rgba(241, 196, 15, 0.5));
        }

        .edge-weight {
            fill: #2c3e50;
            font-size: 14px;
            font-weight: bold;
            background: white;
        }

        .distance-label {
            fill: #2c3e50;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
        }

        .info-panel h3 {
            color: #2c3e50;
            margin-bottom: 16px;
            font-size: 1.2em;
        }

        .distance-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 24px;
        }

        .distance-table th,
        .distance-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .distance-table th {
            background: #ecf0f1;
            font-weight: 600;
        }

        .distance-table tr.current-node {
            background: #ffe5e5;
        }

        .controls {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-primary:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e74c3c;
            color: white;
        }

        .btn-secondary:hover {
            background: #c0392b;
        }

        .status-text {
            color: #666;
            font-size: 14px;
            margin-top: 16px;
            padding: 12px;
            background: #ecf0f1;
            border-radius: 6px;
            text-align: center;
        }

        .instructions {
            background: #e3f2fd;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Finding the Shortest Path with Dijkstra's Algorithm</h1>
            <p class="subtitle">Click any node to start exploring shortest paths</p>
        </header>

        <div class="instructions">
            <strong>How to use:</strong> Click on any node to set it as the starting point. Then click "Next Step" to see how Dijkstra's algorithm finds the shortest paths to all other nodes. The algorithm always visits the unvisited node with the smallest tentative distance.
        </div>

        <div class="main-content">
            <div class="graph-container">
                <svg id="graph" width="600" height="450" viewBox="0 0 600 450">
                    <!-- Edges will be drawn here -->
                    <g id="edges"></g>
                    <!-- Nodes will be drawn here -->
                    <g id="nodes"></g>
                </svg>
            </div>

            <div class="info-panel">
                <h3>Distance Table</h3>
                <table class="distance-table">
                    <thead>
                        <tr>
                            <th>Node</th>
                            <th>Distance</th>
                            <th>Previous</th>
                        </tr>
                    </thead>
                    <tbody id="distanceTableBody">
                        <!-- Distance rows will be inserted here -->
                    </tbody>
                </table>
                
                <h3>Current Step</h3>
                <div id="stepInfo" class="status-text">
                    Click a node to select the starting point
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="nextStep" class="btn-primary" disabled>Next Step</button>
            <button id="reset" class="btn-secondary">Reset</button>
            <button id="autoRun" class="btn-primary" disabled>Auto Run</button>
        </div>
    </div>

    <script>
        // Graph data structure
        const graphData = {
            nodes: [
                { id: 'A', x: 100, y: 100 },
                { id: 'B', x: 300, y: 50 },
                { id: 'C', x: 500, y: 100 },
                { id: 'D', x: 200, y: 250 },
                { id: 'E', x: 400, y: 250 },
                { id: 'F', x: 300, y: 380 }
            ],
            edges: [
                { source: 'A', target: 'B', weight: 4 },
                { source: 'A', target: 'D', weight: 2 },
                { source: 'B', target: 'C', weight: 5 },
                { source: 'B', target: 'D', weight: 1 },
                { source: 'B', target: 'E', weight: 8 },
                { source: 'C', target: 'E', weight: 1 },
                { source: 'D', target: 'E', weight: 3 },
                { source: 'D', target: 'F', weight: 6 },
                { source: 'E', target: 'F', weight: 2 }
            ]
        };

        // Algorithm state
        let distances = {};
        let previous = {};
        let unvisited = new Set();
        let currentNode = null;
        let startNode = null;
        let isRunning = false;
        let autoRunInterval = null;

        // Initialize the graph visualization
        function initializeGraph() {
            const svg = document.getElementById('graph');
            const edgesGroup = document.getElementById('edges');
            const nodesGroup = document.getElementById('nodes');

            // Clear existing elements
            edgesGroup.innerHTML = '';
            nodesGroup.innerHTML = '';

            // Create edges
            graphData.edges.forEach(edge => {
                const sourceNode = graphData.nodes.find(n => n.id === edge.source);
                const targetNode = graphData.nodes.find(n => n.id === edge.target);

                // Edge line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('class', 'edge');
                line.setAttribute('id', `edge-${edge.source}-${edge.target}`);
                line.setAttribute('x1', sourceNode.x);
                line.setAttribute('y1', sourceNode.y);
                line.setAttribute('x2', targetNode.x);
                line.setAttribute('y2', targetNode.y);
                edgesGroup.appendChild(line);

                // Edge weight label
                const midX = (sourceNode.x + targetNode.x) / 2;
                const midY = (sourceNode.y + targetNode.y) / 2;
                
                const weightBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                weightBg.setAttribute('cx', midX);
                weightBg.setAttribute('cy', midY);
                weightBg.setAttribute('r', 15);
                weightBg.setAttribute('fill', 'white');
                weightBg.setAttribute('stroke', '#7f8c8d');
                edgesGroup.appendChild(weightBg);

                const weightText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                weightText.setAttribute('class', 'edge-weight');
                weightText.setAttribute('x', midX);
                weightText.setAttribute('y', midY + 5);
                weightText.setAttribute('text-anchor', 'middle');
                weightText.textContent = edge.weight;
                edgesGroup.appendChild(weightText);
            });

            // Create nodes
            graphData.nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'node');
                g.setAttribute('id', `node-${node.id}`);
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                g.addEventListener('click', () => selectStartNode(node.id));

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'node-circle');
                circle.setAttribute('r', 25);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('class', 'node-label');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('y', 5);
                label.textContent = node.id;

                const distanceLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                distanceLabel.setAttribute('class', 'distance-label');
                distanceLabel.setAttribute('id', `distance-${node.id}`);
                distanceLabel.setAttribute('text-anchor', 'middle');
                distanceLabel.setAttribute('y', -35);
                distanceLabel.textContent = '∞';

                g.appendChild(circle);
                g.appendChild(label);
                g.appendChild(distanceLabel);
                nodesGroup.appendChild(g);
            });
        }

        // Select starting node
        function selectStartNode(nodeId) {
            if (isRunning) return;

            startNode = nodeId;
            resetAlgorithm();
            
            // Initialize distances
            graphData.nodes.forEach(node => {
                distances[node.id] = node.id === startNode ? 0 : Infinity;
                previous[node.id] = null;
                unvisited.add(node.id);
            });

            // Update visualization
            updateDistanceLabels();
            updateDistanceTable();
            
            document.getElementById('nextStep').disabled = false;
            document.getElementById('autoRun').disabled = false;
            document.getElementById('stepInfo').textContent = `Starting from node ${startNode}. Click "Next Step" to begin.`;
        }

        // Reset algorithm state
        function resetAlgorithm() {
            isRunning = false;
            currentNode = null;
            distances = {};
            previous = {};
            unvisited.clear();
            
            if (autoRunInterval) {
                clearInterval(autoRunInterval);
                autoRunInterval = null;
            }

            // Reset visual states
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('visited', 'current');
            });
            
            document.querySelectorAll('.edge').forEach(edge => {
                edge.classList.remove('highlighted', 'shortest-path');
            });

            document.getElementById('nextStep').disabled = true;
            document.getElementById('autoRun').disabled = true;
            document.getElementById('autoRun').textContent = 'Auto Run';
            document.getElementById('stepInfo').textContent = 'Click a node to select the starting point';
            
            updateDistanceLabels();
            updateDistanceTable();
        }

        // Update distance labels on nodes
        function updateDistanceLabels() {
            graphData.nodes.forEach(node => {
                const label = document.getElementById(`distance-${node.id}`);
                const distance = distances[node.id];
                label.textContent = distance === Infinity ? '∞' : distance;
            });
        }

        // Update distance table
        function updateDistanceTable() {
            const tbody = document.getElementById('distanceTableBody');
            tbody.innerHTML = '';
            
            graphData.nodes.forEach(node => {
                const row = document.createElement('tr');
                if (node.id === currentNode) {
                    row.classList.add('current-node');
                }
                
                const distance = distances[node.id] !== undefined ? 
                    (distances[node.id] === Infinity ? '∞' : distances[node.id]) : '-';
                const prev = previous[node.id] || '-';
                
                row.innerHTML = `
                    <td><strong>${node.id}</strong></td>
                    <td>${distance}</td>
                    <td>${prev}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // Get neighbors of a node
        function getNeighbors(nodeId) {
            const neighbors = [];
            graphData.edges.forEach(edge => {
                if (edge.source === nodeId) {
                    neighbors.push({ node: edge.target, weight: edge.weight });
                } else if (edge.target === nodeId) {
                    neighbors.push({ node: edge.source, weight: edge.weight });
                }
            });
            return neighbors;
        }

        // Execute one step of Dijkstra's algorithm
        function nextStep() {
            if (unvisited.size === 0) {
                isRunning = false;
                document.getElementById('stepInfo').textContent = 'Algorithm complete! Shortest paths have been found.';
                document.getElementById('nextStep').disabled = true;
                document.getElementById('autoRun').disabled = true;
                highlightShortestPaths();
                return;
            }

            isRunning = true;

            // Find unvisited node with minimum distance
            let minDistance = Infinity;
            let minNode = null;
            
            unvisited.forEach(nodeId => {
                if (distances[nodeId] < minDistance) {
                    minDistance = distances[nodeId];
                    minNode = nodeId;
                }
            });

            if (minNode === null || minDistance === Infinity) {
                isRunning = false;
                document.getElementById('stepInfo').textContent = 'No more reachable nodes.';
                document.getElementById('nextStep').disabled = true;
                document.getElementById('autoRun').disabled = true;
                return;
            }

            // Update current node
            if (currentNode) {
                document.getElementById(`node-${currentNode}`).classList.remove('current');
            }
            currentNode = minNode;
            document.getElementById(`node-${currentNode}`).classList.add('current');

            // Update step info
            document.getElementById('stepInfo').textContent = 
                `Visiting node ${currentNode} with distance ${minDistance}. Updating neighbors...`;

            // Update neighbors
            const neighbors = getNeighbors(currentNode);
            neighbors.forEach(({ node, weight }) => {
                if (unvisited.has(node)) {
                    const altDistance = distances[currentNode] + weight;
                    if (altDistance < distances[node]) {
                        distances[node] = altDistance;
                        previous[node] = currentNode;
                        
                        // Highlight edge
                        highlightEdge(currentNode, node);
                    }
                }
            });

            // Mark node as visited
            unvisited.delete(currentNode);
            document.getElementById(`node-${currentNode}`).classList.add('visited');
            document.getElementById(`node-${currentNode}`).classList.remove('current');

            // Update visualization
            updateDistanceLabels();
            updateDistanceTable();
        }

        // Highlight edge between two nodes
        function highlightEdge(node1, node2) {
            const edge1 = document.getElementById(`edge-${node1}-${node2}`);
            const edge2 = document.getElementById(`edge-${node2}-${node1}`);
            
            if (edge1) edge1.classList.add('highlighted');
            if (edge2) edge2.classList.add('highlighted');
            
            setTimeout(() => {
                if (edge1) edge1.classList.remove('highlighted');
                if (edge2) edge2.classList.remove('highlighted');
            }, 1000);
        }

        // Highlight shortest paths from start node
        function highlightShortestPaths() {
            graphData.nodes.forEach(node => {
                if (node.id !== startNode && previous[node.id]) {
                    let current = node.id;
                    while (previous[current]) {
                        const prev = previous[current];
                        const edge1 = document.getElementById(`edge-${prev}-${current}`);
                        const edge2 = document.getElementById(`edge-${current}-${prev}`);
                        
                        if (edge1) edge1.classList.add('shortest-path');
                        if (edge2) edge2.classList.add('shortest-path');
                        
                        current = prev;
                    }
                }
            });
        }

        // Auto run functionality
        function toggleAutoRun() {
            const autoRunBtn = document.getElementById('autoRun');
            
            if (autoRunInterval) {
                clearInterval(autoRunInterval);
                autoRunInterval = null;
                autoRunBtn.textContent = 'Auto Run';
            } else {
                autoRunBtn.textContent = 'Stop';
                autoRunInterval = setInterval(() => {
                    nextStep();
                    if (unvisited.size === 0) {
                        clearInterval(autoRunInterval);
                        autoRunInterval = null;
                        autoRunBtn.textContent = 'Auto Run';
                    }
                }, 1500);
            }
        }

        // Event listeners
        document.getElementById('nextStep').addEventListener('click', nextStep);
        document.getElementById('reset').addEventListener('click', resetAlgorithm);
        document.getElementById('autoRun').addEventListener('click', toggleAutoRun);

        // Initialize on load
        initializeGraph();
    </script>
</body>
</html>