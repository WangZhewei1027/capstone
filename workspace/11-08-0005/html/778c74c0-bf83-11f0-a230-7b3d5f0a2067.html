<!DOCTYPE html>
# Interactive HTML Page Design: Heap (Min/Max)

## Concept Title
**Interactive Heap Visualizer: Understanding Min and Max Heaps**

## Learning Objective
After interacting with this module, users will understand:
- The fundamental structure and properties of binary heaps (both min and max)
- How elements are inserted into a heap while maintaining the heap property
- How the root element is extracted and the heap is restructured
- The visual representation of heaps as complete binary trees
- The relationship between array indices and tree positions in heap implementation

## Interaction Design

### User Interactions:
1. **Heap Type Toggle**: Users can switch between Min Heap and Max Heap modes using a toggle button
2. **Insert Operation**: 
   - Users can type a number in an input field and click "Insert" or press Enter
   - The insertion animates through the heap, showing the bubble-up process
   - Each comparison during bubble-up is highlighted with color changes
3. **Extract Root Operation**:
   - Users click "Extract Min/Max" button to remove the root element
   - Animation shows the root removal, last element moving to root, and bubble-down process
4. **Clear Heap**: Reset the entire heap to start fresh
5. **Speed Control**: Slider to adjust animation speed for better observation
6. **Array View Toggle**: Show/hide the array representation alongside the tree view

### Visual Feedback:
- **Color Coding**: 
  - Active nodes during operations glow with a pulse animation
  - Comparisons show in contrasting colors (e.g., comparing parent and child)
  - Satisfied heap property shows in green, violations in red
- **Smooth Animations**: 
  - Nodes slide into position during swaps
  - New nodes fade in during insertion
  - Extracted nodes fade out
- **Real-time Array Updates**: Array representation updates synchronously with tree changes
- **Operation Log**: A sidebar shows step-by-step explanations of the current operation

## Layout Description

### Spatial Organization:
```
+------------------------------------------+
|            HEADER (80px)                 |
|    Title + Heap Type Toggle              |
+------------------------------------------+
|                                          |
|     MAIN VISUALIZATION AREA (60vh)       |
|                                          |
|         [Binary Tree Display]            |
|                                          |
|     [Array Representation (Optional)]    |
|                                          |
+------------------------------------------+
|         CONTROL PANEL (120px)            |
|   Input Field | Insert | Extract | Clear |
|        Animation Speed Slider            |
+------------------------------------------+
|      OPERATION LOG SIDEBAR (25%)         |
|         (Slides in from right)           |
+------------------------------------------+
```

### Detailed Layout Specifications:
- **Safe Area**: 24px margins on all viewport sides
- **Header**: Fixed height with centered title and toggle on the right
- **Visualization Area**: 
  - Tree nodes: 40px diameter circles with 60px horizontal and 80px vertical spacing
  - Connecting lines between parent and child nodes
  - Array cells: 50px width, 40px height with 8px gaps
- **Control Panel**: 
  - Horizontally centered controls with 16px spacing between elements
  - Input field: 120px width
  - Buttons: 100px width, 40px height
- **Operation Log**: 
  - Collapsible sidebar, 300px width when open
  - Semi-transparent background overlay when active
- **Responsive Design**: 
  - On smaller screens (<768px), controls stack vertically
  - Tree visualization scales down while maintaining proportions
  - Operation log becomes a bottom sheet instead of sidebar

Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Heap Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            padding: 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Header Styles */
        .header {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .title {
            font-size: 28px;
            font-weight: 600;
            color: #2c3e50;
        }

        .heap-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            background: white;
            padding: 8px 16px;
            border-radius: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .toggle-label {
            font-weight: 500;
            color: #666;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #3498db;
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.max-heap {
            background: #e74c3c;
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.max-heap .toggle-slider {
            transform: translateX(30px);
        }

        /* Visualization Area */
        .visualization-area {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            padding: 24px;
            position: relative;
            overflow: hidden;
            min-height: 400px;
        }

        .tree-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tree-svg {
            width: 100%;
            height: 70%;
            min-height: 300px;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node.max-heap circle {
            fill: #e74c3c;
            stroke: #c0392b;
        }

        .node.active circle {
            fill: #f39c12;
            stroke: #e67e22;
            filter: drop-shadow(0 0 10px rgba(243, 156, 18, 0.5));
        }

        .node.comparing circle {
            fill: #9b59b6;
            stroke: #8e44ad;
            animation: pulse 0.5s ease-in-out infinite;
        }

        .node.satisfied circle {
            fill: #27ae60;
            stroke: #229954;
        }

        .node.violating circle {
            fill: #e74c3c;
            stroke: #c0392b;
            animation: shake 0.5s ease-in-out;
        }

        .node text {
            fill: white;
            font-weight: 600;
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: central;
            user-select: none;
        }

        .edge {
            stroke: #bdc3c7;
            stroke-width: 2px;
            fill: none;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
        }

        /* Array View */
        .array-view {
            margin-top: 24px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .array-view.visible {
            display: block;
        }

        .array-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .array-cells {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .array-cell {
            width: 50px;
            height: 40px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            position: relative;
            transition: all 0.3s ease;
        }

        .array-cell.max-heap {
            border-color: #e74c3c;
        }

        .array-cell.active {
            background: #f39c12;
            border-color: #e67e22;
            color: white;
        }

        .array-cell .index {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #999;
            background: #f5f5f5;
            padding: 0 4px;
        }

        /* Control Panel */
        .controls {
            margin-top: 24px;
            padding: 24px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            justify-content: center;
        }

        .input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .number-input {
            width: 120px;
            height: 40px;
            padding: 0 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .number-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn {
            height: 40px;
            padding: 0 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(149, 165, 166, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .speed-label {
            font-size: 14px;
            color: #666;
        }

        .speed-slider {
            width: 150px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Operation Log */
        .operation-log {
            position: fixed;
            right: -300px;
            top: 0;
            width: 300px;
            height: 100%;
            background: white;
            box-shadow: -2px 0 12px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .operation-log.visible {
            right: 0;
        }

        .log-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .close-log {
            background: none;
            border: none;
            font-size: 24px;
            color: #999;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-log:hover {
            color: #666;
        }

        .log-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .log-entry {
            margin-bottom: 16px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #3498db;
            animation: slideIn 0.3s ease;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
            background: #fee;
        }

        .log-entry.success {
            border-left-color: #27ae60;
            background: #efe;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .log-time {
            font-size: 12px;
            color: #999;
            margin-bottom: 4px;
        }

        .log-message {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        /* Info Panel */
        .info-panel {
            margin-top: 24px;
            padding: 20px;
            background: #e8f4fd;
            border-radius: 8px;
            border: 1px solid #bee5eb;
        }

        .info-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .info-text {
            font-size: 14px;
            color: #555;
            line-height: 1.6;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            .header {
                flex-direction: column;
                height: auto;
                gap: 16px;
                align-items: stretch;
            }

            .title {
                font-size: 24px;
                text-align: center;
            }

            .heap-toggle {
                justify-content: center;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .input-group {
                width: 100%;
            }

            .number-input {
                flex: 1;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }

            .speed-control {
                width: 100%;
                justify-content: space-between;
            }

            .operation-log {
                width: 100%;
                right: -100%;
            }

            .array-cells {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">Interactive Heap Visualizer</h1>
            <div class="heap-toggle">
                <span class="toggle-label">Min Heap</span>
                <div class="toggle-switch" id="heapToggle">
                    <div class="toggle-slider"></div>
                </div>
                <span class="toggle-label">Max Heap</span>
            </div>
        </header>

        <div class="visualization-area">
            <div class="tree-container">
                <svg class="tree-svg" id="treeSvg"></svg>
                <div class="array-view" id="arrayView">
                    <div class="array-title">Array Representation</div>
                    <div class="array-cells" id="arrayCells"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="input-group">
                <input type="number" class="number-input" id="numberInput" placeholder="Enter number" min="-999" max="999">
                <button class="btn btn-primary" id="insertBtn">
                    <span>Insert</span>
                </button>
            </div>
            <button class="btn btn-danger" id="extractBtn">
                <span id="extractBtnText">Extract Min</span>
            </button>
            <button class="btn btn-secondary" id="clearBtn">
                <span>Clear Heap</span>
            </button>
            <div class="speed-control">
                <span class="speed-label">Animation Speed:</span>
                <input type="range" class="speed-slider" id="speedSlider" min="100" max="2000" value="800">
            </div>
            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="arrayToggle">
                <label for="arrayToggle">Show Array</label>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-title">Heap Properties</div>
            <div class="info-text" id="heapInfo">
                A <strong>Min Heap</strong> is a complete binary tree where each parent node is smaller than or equal to its children. The smallest element is always at the root.
            </div>
        </div>
    </div>

    <div class="operation-log" id="operationLog">
        <div class="log-header">
            <span class="log-title">Operation Log</span>
            <button class="close-log" id="closeLog">&times;</button>
        </div>
        <div class="log-content" id="logContent"></div>
    </div>

    <script>
        class HeapVisualizer {
            constructor() {
                this.heap = [];
                this.isMaxHeap = false;
                this.animationSpeed = 800;
                this.isAnimating = false;
                this.svg = document.getElementById('treeSvg');
                this.logContent = document.getElementById('logContent');
                
                this.initializeEventListeners();
                this.updateVisualization();
            }

            initializeEventListeners() {
                // Heap type toggle
                document.getElementById('heapToggle').addEventListener('click', () => {
                    this.toggleHeapType();
                });

                // Insert button
                document.getElementById('insertBtn').addEventListener('click', () => {
                    this.handleInsert();
                });

                // Enter key in input
                document.getElementById('numberInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.handleInsert();
                    }
                });

                // Extract button
                document.getElementById('extractBtn').addEventListener('click', () => {
                    this.handleExtract();
                });

                // Clear button
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearHeap();
                });

                // Speed slider
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });

                // Array view toggle
                document.getElementById('arrayToggle').addEventListener('change', (e) => {
                    const arrayView = document.getElementById('arrayView');
                    if (e.target.checked) {
                        arrayView.classList.add('visible');
                    } else {
                        arrayView.classList.remove('visible');
                    }
                });

                // Close log
                document.getElementById('closeLog').addEventListener('click', () => {
                    document.getElementById('operationLog').classList.remove('visible');
                });
            }

            toggleHeapType() {
                this.isMaxHeap = !this.isMaxHeap;
                const toggle = document.getElementById('heapToggle');
                const extractBtn = document.getElementById('extractBtnText');
                const heapInfo = document.getElementById('heapInfo');
                
                if (this.isMaxHeap) {
                    toggle.classList.add('max-heap');
                    extractBtn.textContent = 'Extract Max';
                    heapInfo.innerHTML = 'A <strong>Max Heap</strong> is a complete binary tree where each parent node is greater than or equal to its children. The largest element is always at the root.';
                } else {
                    toggle.classList.remove('max-heap');
                    extractBtn.textContent = 'Extract Min';
                    heapInfo.innerHTML = 'A <strong>Min Heap</strong> is a complete binary tree where each parent node is smaller than or equal to its children. The smallest element is always at the root.';
                }
                
                this.updateVisualization();
                this.log(`Switched to ${this.isMaxHeap ? 'Max' : 'Min'} Heap mode`, 'info');
            }

            async handleInsert() {
                const input = document.getElementById('numberInput');
                const value = parseInt(input.value);
                
                if (isNaN(value)) {
                    this.log('Please enter a valid number', 'error');
                    return;
                }
                
                if (this.isAnimating) {
                    this.log('Please wait for the current animation to complete', 'error');
                    return;
                }
                
                input.value = '';
                this.showOperationLog();
                await this.insert(value);
            }

            async handleExtract() {
                if (this.heap.length === 0) {
                    this.log('Heap is empty', 'error');
                    return;
                }
                
                if (this.isAnimating) {
                    this.log('Please wait for the current animation to complete', 'error');
                    return;
                }
                
                this.showOperationLog();
                await this.extractRoot();
            }

            clearHeap() {
                this.heap = [];
                this.updateVisualization();
                this.log('Heap cleared', 'success');
            }

            async insert(value) {
                this.isAnimating = true;
                this.setControlsEnabled(false);
                
                this.log(`Inserting ${value} into the heap`, 'info');
                this.heap.push(value);
                this.updateVisualization();
                
                // Highlight the new node
                const newIndex = this.heap.length - 1;
                this.highlightNode(newIndex, 'active');
                await this.delay();
                
                // Bubble up
                await this.bubbleUp(newIndex);
                
                this.clearHighlights();
                this.updateVisualization();
                this.log(`Successfully inserted ${value}`, 'success');
                
                this.isAnimating = false;
                this.setControlsEnabled(true);
            }

            async bubbleUp(index) {
                let currentIndex = index;
                
                while (currentIndex > 0) {
                    const parentIndex = Math.floor((currentIndex - 1) / 2);
                    const shouldSwap = this.isMaxHeap ? 
                        this.heap[currentIndex] > this.heap[parentIndex] :
                        this.heap[currentIndex] < this.heap[parentIndex];
                    
                    this.highlightNode(currentIndex, 'comparing');
                    this.highlightNode(parentIndex, 'comparing');
                    
                    this.log(`Comparing ${this.heap[currentIndex]} with parent ${this.heap[parentIndex]}`);
                    await this.delay();
                    
                    if (shouldSwap) {
                        this.log(`Swapping ${this.heap[currentIndex]} with ${this.heap[parentIndex]}`);
                        
                        // Swap animation
                        await this.animateSwap(currentIndex, parentIndex);
                        
                        // Actual swap
                        [this.heap[currentIndex], this.heap[parentIndex]] = 
                        [this.heap[parentIndex], this.heap[currentIndex]];
                        
                        this.updateVisualization();
                        this.highlightNode(parentIndex, 'active');
                        this.highlightNode(currentIndex, 'satisfied');
                        
                        currentIndex = parentIndex;
                    } else {
                        this.highlightNode(currentIndex, 'satisfied');
                        this.highlightNode(parentIndex, 'satisfied');
                        this.log('Heap property satisfied');
                        await this.delay();
                        break;
                    }
                }
            }

            async extractRoot() {
                this.isAnimating = true;
                this.setControlsEnabled(false);
                
                const root = this.heap[0];
                this.log(`Extracting ${this.isMaxHeap ? 'maximum' : 'minimum'} element: ${root}`, 'info');
                
                // Highlight root for removal
                this.highlightNode(0, 'violating');
                await this.delay();
                
                if (this.heap.length === 1) {
                    this.heap.pop();
                    this.updateVisualization();
                } else {
                    // Move last element to root
                    const lastElement = this.heap[this.heap.length - 1];
                    this.log(`Moving last element ${lastElement} to root`);
                    
                    this.heap[0] = lastElement;
                    this.heap.pop();
                    this.updateVisualization();
                    
                    // Bubble down
                    await this.bubbleDown(0);
                }
                
                this.clearHighlights();
                this.updateVisualization();
                this.log(`Successfully extracted ${root}`, 'success');
                
                this.isAnimating = false;
                this.setControlsEnabled(true);
            }

            async bubbleDown(index) {
                let currentIndex = index;
                
                while (true) {
                    const leftChildIndex = 2 * currentIndex + 1;
                    const rightChildIndex = 2 * currentIndex + 2;
                    let targetIndex = currentIndex;
                    
                    this.highlightNode(currentIndex, 'active');
                    
                    // Check left child
                    if (leftChildIndex < this.heap.length) {
                        this.highlightNode(leftChildIndex, 'comparing');
                        await this.delay(this.animationSpeed / 2);
                        
                        const shouldSwapLeft = this.isMaxHeap ?
                            this.heap[leftChildIndex] > this.heap[targetIndex] :
                            this.heap[leftChildIndex] < this.heap[targetIndex];
                            
                        if (shouldSwapLeft) {
                            targetIndex = leftChildIndex;
                        }
                    }
                    
                    // Check right child
                    if (rightChildIndex < this.heap.length) {
                        this.highlightNode(rightChildIndex, 'comparing');
                        await this.delay(this.animationSpeed / 2);
                        
                        const shouldSwapRight = this.isMaxHeap ?
                            this.heap[rightChildIndex] > this.heap[targetIndex] :
                            this.heap[rightChildIndex] < this.heap[targetIndex];
                            
                        if (shouldSwapRight) {
                            targetIndex = rightChildIndex;
                        }
                    }
                    
                    if (targetIndex !== currentIndex) {
                        this.log(`Swapping ${this.heap[currentIndex]} with ${this.heap[targetIndex]}`);
                        
                        // Swap animation
                        await this.animateSwap(currentIndex, targetIndex);
                        
                        // Actual swap
                        [this.heap[currentIndex], this.heap[targetIndex]] = 
                        [this.heap[targetIndex], this.heap[currentIndex]];
                        
                        this.updateVisualization();
                        this.highlightNode(targetIndex, 'active');
                        this.highlightNode(currentIndex, 'satisfied');
                        
                        currentIndex = targetIndex;
                    } else {
                        this.highlightNode(currentIndex, 'satisfied');
                        if (leftChildIndex < this.heap.length) {
                            this.highlightNode(leftChildIndex, 'satisfied');
                        }
                        if (rightChildIndex < this.heap.length) {
                            this.highlightNode(rightChildIndex, 'satisfied');
                        }
                        this.log('Heap property satisfied');
                        await this.delay();
                        break;
                    }
                }
            }

            updateVisualization() {
                this.drawTree();
                this.updateArray();
            }

            draw