<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Sort Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 24px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 32px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #3498db;
            color: white;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .toggle-button {
            background: #95a5a6;
        }

        .toggle-button.active {
            background: #27ae60;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="range"] {
            width: 120px;
        }

        .step-indicator {
            font-weight: bold;
            color: #2c3e50;
        }

        .visualization {
            background: white;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            min-height: 400px;
            overflow-x: auto;
        }

        .tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .tree-level {
            display: flex;
            justify-content: center;
            gap: 32px;
            position: relative;
        }

        .array-node {
            display: flex;
            gap: 4px;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.5s ease;
            position: relative;
        }

        .array-element {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e3f2fd;
            border: 2px solid #64b5f6;
            border-radius: 6px;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-element:hover {
            transform: scale(1.05);
        }

        .array-element.tracked {
            background: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 12px rgba(255, 193, 7, 0.5);
        }

        .array-element.comparing {
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .array-node.dividing {
            animation: dividing 0.8s ease-in-out;
            background: rgba(255, 235, 59, 0.3);
        }

        @keyframes dividing {
            0%, 100% { background: rgba(255, 235, 59, 0); }
            50% { background: rgba(255, 235, 59, 0.3); }
        }

        .array-node.merging {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4caf50;
        }

        .array-node.sorted {
            background: #e8f5e9;
        }

        .connector {
            position: absolute;
            width: 2px;
            background: #bdc3c7;
            transform-origin: top;
            transition: all 0.5s ease;
        }

        .detail-panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 16px;
        }

        .operation-text {
            font-size: 1.2em;
            margin-bottom: 12px;
            color: #2c3e50;
        }

        .complexity-info {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 0.9em;
            color: #7f8c8d;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #3498db;
        }

        .code-panel {
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 12px;
            padding: 24px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
        }

        .code-line {
            padding: 2px 0;
            transition: all 0.3s ease;
        }

        .code-line.active {
            background: rgba(52, 152, 219, 0.3);
            padding-left: 12px;
        }

        .toggle-code {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 6px 12px;
            font-size: 12px;
            background: #34495e;
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            h1 {
                font-size: 2em;
            }

            .controls {
                padding: 16px;
            }

            .tree-level {
                gap: 16px;
            }

            .array-element {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }

        .merge-arrow {
            position: absolute;
            font-size: 24px;
            color: #e74c3c;
            animation: bounce 1s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .comparing-left {
            background: #ffebee !important;
            border-color: #e74c3c !important;
        }

        .comparing-right {
            background: #e8f5e9 !important;
            border-color: #4caf50 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Merge Sort Visualizer</h1>
            <p class="subtitle">See how merge sort divides, sorts, and conquers</p>
        </header>

        <div class="controls">
            <button id="generateBtn">Generate New Array</button>
            <button id="prevBtn" disabled>Previous</button>
            <button id="nextBtn">Next</button>
            <button id="autoPlayBtn" class="toggle-button">Auto Play</button>
            <div class="speed-control">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" min="100" max="2000" value="1000">
            </div>
            <div class="step-indicator">
                Step: <span id="currentStep">0</span> / <span id="totalSteps">0</span>
            </div>
        </div>

        <div class="visualization">
            <div id="treeContainer" class="tree-container"></div>
        </div>

        <div class="detail-panel">
            <div id="operationText" class="operation-text">Click "Generate New Array" to begin</div>
            <div class="complexity-info">
                <div class="stat-item">
                    <span class="stat-label">Comparisons</span>
                    <span id="comparisons" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Current Depth</span>
                    <span id="depth" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Operations</span>
                    <span id="operations" class="stat-value">0</span>
                </div>
            </div>
        </div>

        <div class="code-panel" id="codePanel">
            <button class="toggle-code" onclick="toggleCode()">Hide Code</button>
            <pre id="codeContent">
<span class="code-line" data-line="1">function mergeSort(array) {</span>
<span class="code-line" data-line="2">    if (array.length <= 1) return array;</span>
<span class="code-line" data-line="3">    </span>
<span class="code-line" data-line="4">    const mid = Math.floor(array.length / 2);</span>
<span class="code-line" data-line="5">    const left = array.slice(0, mid);</span>
<span class="code-line" data-line="6">    const right = array.slice(mid);</span>
<span class="code-line" data-line="7">    </span>
<span class="code-line" data-line="8">    return merge(mergeSort(left), mergeSort(right));</span>
<span class="code-line" data-line="9">}</span>
<span class="code-line" data-line="10"></span>
<span class="code-line" data-line="11">function merge(left, right) {</span>
<span class="code-line" data-line="12">    let result = [];</span>
<span class="code-line" data-line="13">    let leftIndex = 0, rightIndex = 0;</span>
<span class="code-line" data-line="14">    </span>
<span class="code-line" data-line="15">    while (leftIndex < left.length && rightIndex < right.length) {</span>
<span class="code-line" data-line="16">        if (left[leftIndex] <= right[rightIndex]) {</span>
<span class="code-line" data-line="17">            result.push(left[leftIndex++]);</span>
<span class="code-line" data-line="18">        } else {</span>
<span class="code-line" data-line="19">            result.push(right[rightIndex++]);</span>
<span class="code-line" data-line="20">        }</span>
<span class="code-line" data-line="21">    }</span>
<span class="code-line" data-line="22">    </span>
<span class="code-line" data-line="23">    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));</span>
<span class="code-line" data-line="24">}</span>
            </pre>
        </div>
    </div>

    <script>
        // Global state
        let currentArray = [];
        let steps = [];
        let currentStepIndex = 0;
        let isAutoPlaying = false;
        let autoPlayInterval = null;
        let trackedValue = null;
        let comparisons = 0;
        let operations = 0;

        // DOM elements
        const generateBtn = document.getElementById('generateBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const autoPlayBtn = document.getElementById('autoPlayBtn');
        const speedSlider = document.getElementById('speedSlider');
        const currentStepSpan = document.getElementById('currentStep');
        const totalStepsSpan = document.getElementById('totalSteps');
        const treeContainer = document.getElementById('treeContainer');
        const operationText = document.getElementById('operationText');
        const comparisonsSpan = document.getElementById('comparisons');
        const depthSpan = document.getElementById('depth');
        const operationsSpan = document.getElementById('operations');

        // Event listeners
        generateBtn.addEventListener('click', generateNewArray);
        prevBtn.addEventListener('click', previousStep);
        nextBtn.addEventListener('click', nextStep);
        autoPlayBtn.addEventListener('click', toggleAutoPlay);

        // Generate a new random array
        function generateNewArray() {
            currentArray = Array.from({length: 8}, () => Math.floor(Math.random() * 99) + 1);
            trackedValue = null;
            comparisons = 0;
            operations = 0;
            steps = [];
            currentStepIndex = 0;
            
            // Record initial state
            steps.push({
                type: 'initial',
                arrays: [[...currentArray]],
                depth: 0,
                description: 'Initial unsorted array'
            });
            
            // Generate all steps
            const sortSteps = [];
            mergeSortWithSteps([...currentArray], 0, sortSteps);
            steps = steps.concat(sortSteps);
            
            totalStepsSpan.textContent = steps.length - 1;
            updateVisualization();
            updateControls();
        }

        // Merge sort with step recording
        function mergeSortWithSteps(array, depth, stepsArray, parentId = 'root') {
            if (array.length <= 1) {
                return array;
            }
            
            operations++;
            
            const mid = Math.floor(array.length / 2);
            const left = array.slice(0, mid);
            const right = array.slice(mid);
            
            // Record split step
            stepsArray.push({
                type: 'split',
                array: [...array],
                left: [...left],
                right: [...right],
                depth: depth,
                parentId: parentId,
                description: `Splitting array [${array.join(', ')}] into [${left.join(', ')}] and [${right.join(', ')}]`,
                codeLine: 4
            });
            
            const leftId = parentId + '-L';
            const rightId = parentId + '-R';
            
            const sortedLeft = mergeSortWithSteps(left, depth + 1, stepsArray, leftId);
            const sortedRight = mergeSortWithSteps(right, depth + 1, stepsArray, rightId);
            
            const merged = mergeWithSteps(sortedLeft, sortedRight, depth, stepsArray, parentId);
            
            return merged;
        }

        // Merge with step recording
        function mergeWithSteps(left, right, depth, stepsArray, parentId) {
            const result = [];
            let leftIndex = 0;
            let rightIndex = 0;
            
            operations++;
            
            // Record merge start
            stepsArray.push({
                type: 'merge-start',
                left: [...left],
                right: [...right],
                depth: depth,
                parentId: parentId,
                description: `Starting merge of [${left.join(', ')}] and [${right.join(', ')}]`,
                codeLine: 11
            });
            
            while (leftIndex < left.length && rightIndex < right.length) {
                comparisons++;
                
                // Record comparison
                stepsArray.push({
                    type: 'compare',
                    left: [...left],
                    right: [...right],
                    leftIndex: leftIndex,
                    rightIndex: rightIndex,
                    result: [...result],
                    depth: depth,
                    parentId: parentId,
                    description: `Comparing ${left[leftIndex]} and ${right[rightIndex]}`,
                    codeLine: 16
                });
                
                if (left[leftIndex] <= right[rightIndex]) {
                    result.push(left[leftIndex]);
                    leftIndex++;
                } else {
                    result.push(right[rightIndex]);
                    rightIndex++;
                }
            }
            
            // Add remaining elements
            while (leftIndex < left.length) {
                result.push(left[leftIndex++]);
            }
            while (rightIndex < right.length) {
                result.push(right[rightIndex++]);
            }
            
            // Record merge complete
            stepsArray.push({
                type: 'merge-complete',
                result: [...result],
                depth: depth,
                parentId: parentId,
                description: `Merge complete: [${result.join(', ')}]`,
                codeLine: 23
            });
            
            return result;
        }

        // Update visualization
        function updateVisualization() {
            if (currentStepIndex >= steps.length) return;
            
            const step = steps[currentStepIndex];
            currentStepSpan.textContent = currentStepIndex;
            operationText.textContent = step.description;
            depthSpan.textContent = step.depth || 0;
            comparisonsSpan.textContent = comparisons;
            operationsSpan.textContent = operations;
            
            // Update code highlighting
            const codeLines = document.querySelectorAll('.code-line');
            codeLines.forEach(line => line.classList.remove('active'));
            if (step.codeLine) {
                const activeLine = document.querySelector(`[data-line="${step.codeLine}"]`);
                if (activeLine) activeLine.classList.add('active');
            }
            
            // Render tree visualization
            renderTree();
        }

        // Render tree visualization
        function renderTree() {
            treeContainer.innerHTML = '';
            
            const step = steps[currentStepIndex];
            
            if (step.type === 'initial') {
                const level = document.createElement('div');
                level.className = 'tree-level';
                level.appendChild(createArrayNode(step.arrays[0], 'root', false));
                treeContainer.appendChild(level);
            } else {
                // Build tree structure from steps
                const tree = buildTreeStructure();
                renderTreeNode(tree, treeContainer);
            }
        }

        // Build tree structure from current steps
        function buildTreeStructure() {
            const nodes = new Map();
            
            // Add initial array
            nodes.set('root', {
                array: [...currentArray],
                children: [],
                depth: 0,
                state: 'normal'
            });
            
            // Process steps up to current
            for (let i = 1; i <= currentStepIndex; i++) {
                const step = steps[i];
                
                if (step.type === 'split') {
                    const node = nodes.get(step.parentId) || {
                        array: step.array,
                        children: [],
                        depth: step.depth,
                        state: 'normal'
                    };
                    
                    node.state = 'splitting';
                    node.children = [
                        {
                            id: step.parentId + '-L',
                            array: step.left,
                            children: [],
                            depth: step.depth + 1,
                            state: 'normal'
                        },
                        {
                            id: step.parentId + '-R',
                            array: step.right,
                            children: [],
                            depth: step.depth + 1,
                            state: 'normal'
                        }
                    ];
                    
                    nodes.set(step.parentId, node);
                    nodes.set(step.parentId + '-L', node.children[0]);
                    nodes.set(step.parentId + '-R', node.children[1]);
                } else if (step.type === 'merge-start' || step.type === 'compare') {
                    const node = nodes.get(step.parentId);
                    if (node) {
                        node.state = 'merging';
                        if (step.leftIndex !== undefined) {
                            node.compareLeft = step.leftIndex;
                            node.compareRight = step.rightIndex;
                        }
                    }
                } else if (step.type === 'merge-complete') {
                    const node = nodes.get(step.parentId);
                    if (node) {
                        node.array = step.result;
                        node.state = 'sorted';
                        node.children = [];
                    }
                }
            }
            
            return nodes.get('root');
        }

        // Render tree node recursively
        function renderTreeNode(node, container, level = 0) {
            if (!node) return;
            
            let levelDiv = container.querySelector(`[data-level="${level}"]`);
            if (!levelDiv) {
                levelDiv = document.createElement('div');
                levelDiv.className = 'tree-level';
                levelDiv.setAttribute('data-level', level);
                container.appendChild(levelDiv);
            }
            
            const arrayNode = createArrayNode(node.array, node.id, 
                node.state === 'sorted', node.state, node.compareLeft, node.compareRight);
            levelDiv.appendChild(arrayNode);
            
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    renderTreeNode(child, container, level + 1);
                });
            }
        }

        // Create array node element
        function createArrayNode(array, id, isSorted, state, compareLeft, compareRight) {
            const node = document.createElement('div');
            node.className = 'array-node';
            if (isSorted) node.classList.add('sorted');
            if (state === 'splitting') node.classList.add('dividing');
            if (state === 'merging') node.classList.add('merging');
            
            array.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                
                if (value === trackedValue) {
                    element.classList.add('tracked');
                }
                
                if (state === 'merging' && compareLeft !== undefined) {
                    if (index === compareLeft) {
                        element.classList.add('comparing-left');
                    } else if (index === compareRight) {
                        element.classList.add('comparing-right');
                    }
                }
                
                element.addEventListener('click', () => {
                    trackedValue = trackedValue === value ? null : value;
                    updateVisualization();
                });
                
                node.appendChild(element);
            });
            
            return node;
        }

        // Navigation functions
        function previousStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                updateVisualization();
                updateControls();
            }
        }

        function nextStep() {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                updateVisualization();
                updateControls();
            }
        }

        function toggleAutoPlay() {
            isAutoPlaying = !isAutoPlaying;
            autoPlayBtn.classList.toggle('active');
            
            if (isAutoPlaying) {
                autoPlayBtn.textContent = 'Pause';
                startAutoPlay();
            } else {
                autoPlayBtn.textContent = 'Auto Play';
                stopAutoPlay();
            }
        }

        function startAutoPlay() {
            const speed = parseInt(speedSlider.value);
            autoPlayInterval = setInterval(() => {
                if (currentStepIndex < steps.length - 1) {
                    nextStep();
                } else {
                    stopAutoPlay();
                }
            }, speed);
        }

        function stopAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            isAutoPlaying = false;
            autoPlayBtn.classList.remove('active');
            autoPlayBtn.textContent = 'Auto Play';
        }

        function updateControls() {
            prevBtn.disabled = currentStepIndex === 0;
            nextBtn.disabled = currentStepIndex === steps.length - 1;
            
            if (currentStepIndex === steps.length - 1) {
                stopAutoPlay();
            }
        }

        function toggleCode() {
            const codeContent = document.getElementById('codeContent');
            const toggleBtn = event.target;
            
            if (codeContent.style.display === 'none') {
                codeContent.style.display = 'block';
                toggleBtn.textContent = 'Hide Code';
            } else {
                codeContent.style.display = 'none';
                toggleBtn.textContent = 'Show Code';
            }
        }

        // Initialize with a random array
        generateNewArray();
    </script>
</body>
</html>