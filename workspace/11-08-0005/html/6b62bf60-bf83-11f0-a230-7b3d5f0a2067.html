<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Min/Max Heap Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            color: #1a1a1a;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-areas: 
                "header header"
                "controls viz"
                "info info";
            grid-template-columns: 300px 1fr;
            grid-template-rows: 80px 1fr 120px;
            gap: 24px;
            height: calc(100vh - 48px);
        }

        .header {
            grid-area: header;
            background: white;
            border-radius: 12px;
            padding: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 28px;
            font-weight: 600;
            color: #2c3e50;
        }

        .heap-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            padding: 4px;
        }

        .heap-toggle button {
            padding: 8px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .heap-toggle button.active {
            background: white;
            color: #3498db;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            grid-area: controls;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 24px;
        }

        .control-section h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #34495e;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        input[type="number"], input[type="text"] {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            padding: 10px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .array-display {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .visualization {
            grid-area: viz;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .tree-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s ease;
            z-index: 10;
        }

        .node.highlighting {
            background: #e74c3c;
            transform: scale(1.1);
        }

        .node.comparing {
            background: #f39c12;
        }

        .node-index {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #7f8c8d;
        }

        .edge {
            position: absolute;
            background: #bdc3c7;
            height: 2px;
            transform-origin: left center;
            z-index: 1;
        }

        .info-panel {
            grid-area: info;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .operation-info {
            flex: 1;
        }

        .operation-info h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #34495e;
        }

        .operation-info p {
            color: #7f8c8d;
            font-size: 14px;
        }

        .complexity-info {
            display: flex;
            gap: 24px;
        }

        .complexity-item {
            text-align: center;
        }

        .complexity-item span {
            display: block;
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 4px;
        }

        .complexity-item strong {
            font-size: 16px;
            color: #2c3e50;
        }

        .animation-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
        }

        .speed-slider {
            flex: 1;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-areas: 
                    "header"
                    "controls"
                    "viz"
                    "info";
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Heap Visualization</h1>
            <div class="heap-toggle">
                <button id="minHeapBtn" class="active">Min Heap</button>
                <button id="maxHeapBtn">Max Heap</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-section">
                <h3>Insert Element</h3>
                <div class="input-group">
                    <input type="number" id="insertValue" placeholder="Value" min="-999" max="999">
                    <button id="insertBtn">Insert</button>
                </div>
            </div>

            <div class="control-section">
                <h3>Extract Root</h3>
                <button id="extractBtn" style="width: 100%;">Extract Root</button>
            </div>

            <div class="control-section">
                <h3>Build from Array</h3>
                <input type="text" id="arrayInput" placeholder="e.g., 5,3,8,1,9,2" style="width: 100%; margin-bottom: 8px;">
                <button id="buildBtn" style="width: 100%;">Build Heap</button>
            </div>

            <div class="control-section">
                <h3>Array Representation</h3>
                <div class="array-display" id="arrayDisplay">[ ]</div>
            </div>

            <div class="control-section">
                <h3>Animation Speed</h3>
                <div class="animation-controls">
                    <input type="range" class="speed-slider" id="speedSlider" min="100" max="2000" value="1000">
                    <button id="stepBtn" style="width: 80px;">Step</button>
                </div>
            </div>
        </div>

        <div class="visualization">
            <div class="tree-container" id="treeContainer"></div>
        </div>

        <div class="info-panel">
            <div class="operation-info">
                <h4 id="operationTitle">Ready</h4>
                <p id="operationDescription">Insert elements to build a heap or use the array builder.</p>
            </div>
            <div class="complexity-info">
                <div class="complexity-item">
                    <span>Insert</span>
                    <strong>O(log n)</strong>
                </div>
                <div class="complexity-item">
                    <span>Extract</span>
                    <strong>O(log n)</strong>
                </div>
                <div class="complexity-item">
                    <span>Build</span>
                    <strong>O(n)</strong>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Heap {
            constructor(isMinHeap = true) {
                this.data = [];
                this.isMinHeap = isMinHeap;
            }

            parent(i) { return Math.floor((i - 1) / 2); }
            leftChild(i) { return 2 * i + 1; }
            rightChild(i) { return 2 * i + 2; }

            compare(a, b) {
                return this.isMinHeap ? a < b : a > b;
            }

            swap(i, j) {
                [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
            }

            insert(value) {
                this.data.push(value);
                return this.bubbleUp(this.data.length - 1);
            }

            bubbleUp(index) {
                const path = [];
                let current = index;
                
                while (current > 0) {
                    const parentIdx = this.parent(current);
                    path.push({ from: current, to: parentIdx, swap: false });
                    
                    if (this.compare(this.data[current], this.data[parentIdx])) {
                        this.swap(current, parentIdx);
                        path[path.length - 1].swap = true;
                        current = parentIdx;
                    } else {
                        break;
                    }
                }
                
                return path;
            }

            extractRoot() {
                if (this.data.length === 0) return null;
                if (this.data.length === 1) return { value: this.data.pop(), path: [] };
                
                const root = this.data[0];
                this.data[0] = this.data.pop();
                const path = this.bubbleDown(0);
                
                return { value: root, path };
            }

            bubbleDown(index) {
                const path = [];
                let current = index;
                
                while (true) {
                    const left = this.leftChild(current);
                    const right = this.rightChild(current);
                    let extreme = current;
                    
                    if (left < this.data.length) {
                        path.push({ from: current, to: left, comparing: true });
                        if (this.compare(this.data[left], this.data[extreme])) {
                            extreme = left;
                        }
                    }
                    
                    if (right < this.data.length) {
                        path.push({ from: current, to: right, comparing: true });
                        if (this.compare(this.data[right], this.data[extreme])) {
                            extreme = right;
                        }
                    }
                    
                    if (extreme !== current) {
                        this.swap(current, extreme);
                        path.push({ from: current, to: extreme, swap: true });
                        current = extreme;
                    } else {
                        break;
                    }
                }
                
                return path;
            }

            buildFromArray(arr) {
                this.data = [...arr];
                const animations = [];
                
                for (let i = Math.floor(this.data.length / 2) - 1; i >= 0; i--) {
                    const path = this.bubbleDown(i);
                    animations.push({ index: i, path });
                }
                
                return animations;
            }
        }

        class HeapVisualizer {
            constructor() {
                this.heap = new Heap(true);
                this.container = document.getElementById('treeContainer');
                this.animationSpeed = 1000;
                this.isAnimating = false;
                this.nodes = new Map();
                this.edges = new Map();
                
                this.setupEventListeners();
                this.render();
            }

            setupEventListeners() {
                document.getElementById('minHeapBtn').addEventListener('click', () => this.setHeapType(true));
                document.getElementById('maxHeapBtn').addEventListener('click', () => this.setHeapType(false));
                document.getElementById('insertBtn').addEventListener('click', () => this.handleInsert());
                document.getElementById('extractBtn').addEventListener('click', () => this.handleExtract());
                document.getElementById('buildBtn').addEventListener('click', () => this.handleBuild());
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });
                
                document.getElementById('insertValue').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleInsert();
                });
            }

            setHeapType(isMinHeap) {
                document.getElementById('minHeapBtn').classList.toggle('active', isMinHeap);
                document.getElementById('maxHeapBtn').classList.toggle('active', !isMinHeap);
                
                const currentData = [...this.heap.data];
                this.heap = new Heap(isMinHeap);
                
                if (currentData.length > 0) {
                    this.heap.buildFromArray(currentData);
                    this.render();
                }
            }

            calculateNodePosition(index) {
                const level = Math.floor(Math.log2(index + 1));
                const levelStart = Math.pow(2, level) - 1;
                const positionInLevel = index - levelStart;
                const nodesInLevel = Math.pow(2, level);
                
                const containerWidth = this.container.offsetWidth;
                const containerHeight = this.container.offsetHeight;
                const verticalSpacing = containerHeight / (Math.floor(Math.log2(this.heap.data.length + 1)) + 2);
                
                const x = (containerWidth / (nodesInLevel + 1)) * (positionInLevel + 1);
                const y = verticalSpacing * (level + 1);
                
                return { x, y };
            }

            createNode(value, index) {
                const node = document.createElement('div');
                node.className = 'node';
                node.textContent = value;
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'node-index';
                indexLabel.textContent = index;
                node.appendChild(indexLabel);
                
                const pos = this.calculateNodePosition(index);
                node.style.left = `${pos.x - 25}px`;
                node.style.top = `${pos.y - 25}px`;
                
                return node;
            }

            createEdge(parentIndex, childIndex) {
                const edge = document.createElement('div');
                edge.className = 'edge';
                
                const parent = this.calculateNodePosition(parentIndex);
                const child = this.calculateNodePosition(childIndex);
                
                const dx = child.x - parent.x;
                const dy = child.y - parent.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                edge.style.width = `${length - 50}px`;
                edge.style.left = `${parent.x}px`;
                edge.style.top = `${parent.y}px`;
                edge.style.transform = `rotate(${angle}rad)`;
                
                return edge;
            }

            render() {
                this.container.innerHTML = '';
                this.nodes.clear();
                this.edges.clear();
                
                // Create edges first (so they appear behind nodes)
                for (let i = 1; i < this.heap.data.length; i++) {
                    const parentIdx = this.heap.parent(i);
                    const edge = this.createEdge(parentIdx, i);
                    this.edges.set(`${parentIdx}-${i}`, edge);
                    this.container.appendChild(edge);
                }
                
                // Create nodes
                this.heap.data.forEach((value, index) => {
                    const node = this.createNode(value, index);
                    this.nodes.set(index, node);
                    this.container.appendChild(node);
                });
                
                this.updateArrayDisplay();
            }

            updateArrayDisplay() {
                document.getElementById('arrayDisplay').textContent = 
                    `[${this.heap.data.join(', ')}]`;
            }

            updateInfo(title, description) {
                document.getElementById('operationTitle').textContent = title;
                document.getElementById('operationDescription').textContent = description;
            }

            async animateInsertion(path) {
                this.isAnimating = true;
                this.updateInfo('Inserting Element', 'Bubble up: comparing with parent and swapping if necessary');
                
                for (const step of path) {
                    const fromNode = this.nodes.get(step.from);
                    const toNode = this.nodes.get(step.to);
                    
                    fromNode.classList.add('highlighting');
                    toNode.classList.add('comparing');
                    
                    await this.delay(this.animationSpeed / 2);
                    
                    if (step.swap) {
                        // Animate swap
                        const fromPos = this.calculateNodePosition(step.from);
                        const toPos = this.calculateNodePosition(step.to);
                        
                        fromNode.style.left = `${toPos.x - 25}px`;
                        fromNode.style.top = `${toPos.y - 25}px`;
                        toNode.style.left = `${fromPos.x - 25}px`;
                        toNode.style.top = `${fromPos.y - 25}px`;
                        
                        await this.delay(this.animationSpeed);
                    }
                    
                    fromNode.classList.remove('highlighting');
                    toNode.classList.remove('comparing');
                }
                
                this.render();
                this.isAnimating = false;
                this.updateInfo('Insertion Complete', `Element inserted and heap property maintained`);
            }

            async animateExtraction(path) {
                this.isAnimating = true;
                this.updateInfo('Extracting Root', 'Bubble down: moving last element to root and reheapifying');
                
                // Animate the last element moving to root
                const lastNode = this.nodes.get(this.heap.data.length);
                const rootNode = this.nodes.get(0);
                
                if (lastNode && rootNode) {
                    lastNode.classList.add('highlighting');
                    const rootPos = this.calculateNodePosition(0);
                    lastNode.style.left = `${rootPos.x - 25}px`;
                    lastNode.style.top = `${rootPos.y - 25}px`;
                    await this.delay(this.animationSpeed);
                }
                
                for (const step of path) {
                    if (step.comparing) {
                        const node = this.nodes.get(step.to);
                        if (node) node.classList.add('comparing');
                        await this.delay(this.animationSpeed / 3);
                        if (node) node.classList.remove('comparing');
                    } else if (step.swap) {
                        const fromNode = this.nodes.get(step.from);
                        const toNode = this.nodes.get(step.to);
                        
                        if (fromNode && toNode) {
                            fromNode.classList.add('highlighting');
                            toNode.classList.add('highlighting');
                            
                            const fromPos = this.calculateNodePosition(step.from);
                            const toPos = this.calculateNodePosition(step.to);
                            
                            fromNode.style.left = `${toPos.x - 25}px`;
                            fromNode.style.top = `${toPos.y - 25}px`;
                            toNode.style.left = `${fromPos.x - 25}px`;
                            toNode.style.top = `${fromPos.y - 25}px`;
                            
                            await this.delay(this.animationSpeed);
                            
                            fromNode.classList.remove('highlighting');
                            toNode.classList.remove('highlighting');
                        }
                    }
                }
                
                this.render();
                this.isAnimating = false;
                this.updateInfo('Extraction Complete', 'Root element removed and heap property restored');
            }

            async handleInsert() {
                if (this.isAnimating) return;
                
                const input = document.getElementById('insertValue');
                const value = parseInt(input.value);
                
                if (isNaN(value)) {
                    this.updateInfo('Invalid Input', 'Please enter a valid number');
                    return;
                }
                
                const path = this.heap.insert(value);
                this.render();
                await this.animateInsertion(path);
                
                input.value = '';
                input.focus();
            }

            async handleExtract() {
                if (this.isAnimating || this.heap.data.length === 0) return;
                
                const result = this.heap.extractRoot();
                if (result) {
                    await this.animateExtraction(result.path);
                    this.updateInfo('Extracted Value', `Removed ${result.value} from the heap`);
                }
            }

            async handleBuild() {
                if (this.isAnimating) return;
                
                const input = document.getElementById('arrayInput').value;
                const values = input.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));
                
                if (values.length === 0) {
                    this.updateInfo('Invalid Input', 'Please enter comma-separated numbers');
                    return;
                }
                
                this.heap.data = [];
                this.heap.buildFromArray(values);
                this.render();
                this.updateInfo('Heap Built', `Created ${this.heap.isMinHeap ? 'min' : 'max'} heap from array`);
                
                document.getElementById('arrayInput').value = '';
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize visualizer when page loads
        const visualizer = new HeapVisualizer();
    </script>
</body>
</html>