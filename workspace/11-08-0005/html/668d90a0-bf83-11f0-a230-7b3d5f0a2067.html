<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Interactive Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            padding: 24px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            color: #1a1a1a;
            text-align: center;
            margin-bottom: 16px;
        }

        .description {
            text-align: center;
            color: #555;
            margin-bottom: 32px;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 32px;
            flex-wrap: wrap;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background-color: #e74c3c;
        }

        button.secondary:hover {
            background-color: #c0392b;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .graph-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 24px;
            margin-bottom: 32px;
        }

        svg {
            width: 100%;
            height: 400px;
            display: block;
        }

        .node {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 3;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            fill: #2980b9;
        }

        .edge {
            stroke: #95a5a6;
            stroke-width: 3;
            fill: none;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .edge:hover {
            stroke-width: 5;
            stroke: #7f8c8d;
        }

        .edge.selected {
            stroke: #27ae60;
            stroke-width: 4;
        }

        .edge.considering {
            stroke: #f39c12;
            stroke-width: 5;
            animation: pulse 0.6s ease-in-out;
        }

        .edge.rejected {
            stroke: #e74c3c;
            stroke-width: 5;
            animation: reject 0.5s ease;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes reject {
            0%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
            50% { opacity: 1; stroke: #e74c3c; }
        }

        .edge-weight {
            fill: #2c3e50;
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .node-label {
            fill: white;
            font-size: 16px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .status-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .status-section h3 {
            font-size: 1.2rem;
            margin-bottom: 16px;
            color: #2c3e50;
        }

        .edge-list {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.8;
        }

        .edge-item {
            padding: 4px 8px;
            margin: 4px 0;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .edge-item.selected {
            background-color: #d5f4e6;
            color: #27ae60;
            font-weight: bold;
        }

        .edge-item.considering {
            background-color: #ffeaa7;
            color: #f39c12;
            font-weight: bold;
            animation: pulse 0.6s ease-in-out;
        }

        .edge-item.rejected {
            background-color: #ffcccc;
            color: #e74c3c;
            text-decoration: line-through;
        }

        .algorithm-step {
            background-color: #ecf0f1;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 16px;
        }

        .algorithm-step strong {
            color: #2980b9;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .status-panel {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kruskal's Algorithm: Building the Minimum Spanning Tree</h1>
        <p class="description">
            Watch how Kruskal's algorithm builds a minimum spanning tree by selecting edges in order of weight while avoiding cycles.
        </p>

        <div class="controls">
            <button id="nextStep" onclick="nextStep()">Next Step</button>
            <button id="runAll" onclick="runAll()">Run Complete</button>
            <button class="secondary" onclick="reset()">Reset</button>
            <button onclick="generateNewGraph()">New Graph</button>
        </div>

        <div class="graph-container">
            <svg id="graph" viewBox="0 0 600 400"></svg>
        </div>

        <div class="status-panel">
            <div class="status-section">
                <h3>Algorithm Status</h3>
                <div id="algorithmStep" class="algorithm-step">
                    Click "Next Step" to begin the algorithm
                </div>
                <div id="progress"></div>
            </div>
            <div class="status-section">
                <h3>Sorted Edges (by weight)</h3>
                <div id="edgeList" class="edge-list"></div>
            </div>
        </div>
    </div>

    <script>
        let nodes = [];
        let edges = [];
        let sortedEdges = [];
        let currentStep = 0;
        let selectedEdges = new Set();
        let parent = [];
        let rank = [];
        let isRunning = false;

        // Union-Find data structure
        function find(x) {
            if (parent[x] !== x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        function union(x, y) {
            let rootX = find(x);
            let rootY = find(y);
            
            if (rootX === rootY) return false;
            
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            return true;
        }

        function generateGraph() {
            nodes = [];
            edges = [];
            selectedEdges = new Set();
            currentStep = 0;
            
            // Generate 6 nodes
            const nodeCount = 6;
            const positions = [
                { x: 150, y: 100 },
                { x: 450, y: 100 },
                { x: 100, y: 250 },
                { x: 300, y: 200 },
                { x: 500, y: 250 },
                { x: 300, y: 350 }
            ];
            
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    id: i,
                    label: String.fromCharCode(65 + i),
                    x: positions[i].x,
                    y: positions[i].y
                });
            }
            
            // Generate edges with random weights
            const edgeData = [
                { from: 0, to: 1, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 0, to: 2, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 0, to: 3, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 1, to: 3, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 1, to: 4, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 2, to: 3, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 2, to: 5, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 3, to: 4, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 3, to: 5, weight: Math.floor(Math.random() * 15) + 1 },
                { from: 4, to: 5, weight: Math.floor(Math.random() * 15) + 1 }
            ];
            
            edges = edgeData.map((e, index) => ({
                ...e,
                id: index
            }));
            
            sortedEdges = [...edges].sort((a, b) => a.weight - b.weight);
            
            // Initialize Union-Find
            parent = Array(nodeCount).fill(0).map((_, i) => i);
            rank = Array(nodeCount).fill(0);
            
            renderGraph();
            updateEdgeList();
            updateStatus("Click 'Next Step' to begin the algorithm");
        }

        function renderGraph() {
            const svg = document.getElementById('graph');
            svg.innerHTML = '';
            
            // Draw edges
            edges.forEach(edge => {
                const from = nodes[edge.from];
                const to = nodes[edge.to];
                
                // Edge line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', from.x);
                line.setAttribute('y1', from.y);
                line.setAttribute('x2', to.x);
                line.setAttribute('y2', to.y);
                line.setAttribute('class', 'edge');
                line.setAttribute('data-edge-id', edge.id);
                
                if (selectedEdges.has(edge.id)) {
                    line.classList.add('selected');
                }
                
                svg.appendChild(line);
                
                // Edge weight
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                
                const weightBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                weightBg.setAttribute('x', midX - 15);
                weightBg.setAttribute('y', midY - 10);
                weightBg.setAttribute('width', 30);
                weightBg.setAttribute('height', 20);
                weightBg.setAttribute('fill', 'white');
                weightBg.setAttribute('stroke', '#95a5a6');
                weightBg.setAttribute('stroke-width', '1');
                weightBg.setAttribute('rx', '4');
                svg.appendChild(weightBg);
                
                const weight = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                weight.setAttribute('x', midX);
                weight.setAttribute('y', midY + 5);
                weight.setAttribute('class', 'edge-weight');
                weight.textContent = edge.weight;
                svg.appendChild(weight);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 25);
                circle.setAttribute('class', 'node');
                svg.appendChild(circle);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', node.x);
                label.setAttribute('y', node.y + 5);
                label.setAttribute('class', 'node-label');
                label.textContent = node.label;
                svg.appendChild(label);
            });
        }

        function updateEdgeList() {
            const edgeList = document.getElementById('edgeList');
            edgeList.innerHTML = '';
            
            sortedEdges.forEach((edge, index) => {
                const div = document.createElement('div');
                div.className = 'edge-item';
                div.textContent = `${nodes[edge.from].label}-${nodes[edge.to].label}: ${edge.weight}`;
                div.setAttribute('data-edge-id', edge.id);
                
                if (selectedEdges.has(edge.id)) {
                    div.classList.add('selected');
                } else if (index < currentStep && !selectedEdges.has(edge.id)) {
                    div.classList.add('rejected');
                }
                
                edgeList.appendChild(div);
            });
        }

        function updateStatus(message) {
            document.getElementById('algorithmStep').innerHTML = message;
            document.getElementById('progress').innerHTML = `
                <strong>Progress:</strong> ${selectedEdges.size} edges selected, 
                ${currentStep} of ${sortedEdges.length} edges examined
            `;
        }

        async function nextStep() {
            if (currentStep >= sortedEdges.length) {
                updateStatus("Algorithm complete! The minimum spanning tree has been found.");
                document.getElementById('nextStep').disabled = true;
                return;
            }
            
            const edge = sortedEdges[currentStep];
            const fromLabel = nodes[edge.from].label;
            const toLabel = nodes[edge.to].label;
            
            // Highlight the edge being considered
            const edgeElement = document.querySelector(`[data-edge-id="${edge.id}"]`);
            const edgeListItem = document.querySelector(`.edge-list [data-edge-id="${edge.id}"]`);
            
            edgeElement.classList.add('considering');
            edgeListItem.classList.add('considering');
            
            updateStatus(`<strong>Considering edge ${fromLabel}-${toLabel} (weight: ${edge.weight})</strong><br>
                         Checking if it creates a cycle...`);
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            edgeElement.classList.remove('considering');
            edgeListItem.classList.remove('considering');
            
            // Check if adding this edge creates a cycle
            if (union(edge.from, edge.to)) {
                selectedEdges.add(edge.id);
                edgeElement.classList.add('selected');
                edgeListItem.classList.add('selected');
                updateStatus(`<strong>Edge ${fromLabel}-${toLabel} added!</strong><br>
                             No cycle created. Components merged.`);
            } else {
                edgeElement.classList.add('rejected');
                edgeListItem.classList.add('rejected');
                updateStatus(`<strong>Edge ${fromLabel}-${toLabel} rejected!</strong><br>
                             Would create a cycle. Nodes already connected.`);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                edgeElement.classList.remove('rejected');
            }
            
            currentStep++;
            updateEdgeList();
            
            if (selectedEdges.size === nodes.length - 1) {
                updateStatus("Algorithm complete! The minimum spanning tree has been found.");
                document.getElementById('nextStep').disabled = true;
            }
        }

        async function runAll() {
            if (isRunning) return;
            isRunning = true;
            document.getElementById('runAll').disabled = true;
            
            while (currentStep < sortedEdges.length && selectedEdges.size < nodes.length - 1) {
                await nextStep();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            isRunning = false;
            document.getElementById('runAll').disabled = false;
        }

        function reset() {
            currentStep = 0;
            selectedEdges = new Set();
            parent = Array(nodes.length).fill(0).map((_, i) => i);
            rank = Array(nodes.length).fill(0);
            document.getElementById('nextStep').disabled = false;
            
            renderGraph();
            updateEdgeList();
            updateStatus("Click 'Next Step' to begin the algorithm");
        }

        function generateNewGraph() {
            generateGraph();
            document.getElementById('nextStep').disabled = false;
        }

        // Initialize on load
        generateGraph();
    </script>
</body>
</html>