<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 32px;
            color: #1d1d1f;
        }

        .section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .input-section {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
        }

        .input-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        input[type="number"] {
            width: 60px;
            padding: 8px;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }

        button {
            padding: 10px 20px;
            background-color: #007aff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 44px;
            min-height: 44px;
        }

        button:hover {
            background-color: #0051d5;
        }

        button:disabled {
            background-color: #c7c7cc;
            cursor: not-allowed;
        }

        .controls {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="range"] {
            width: 150px;
        }

        .tree-container {
            position: relative;
            height: 400px;
            overflow: hidden;
        }

        .tree-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            transition: all 0.3s ease;
        }

        .node-circle {
            fill: white;
            stroke: #007aff;
            stroke-width: 2;
        }

        .node-circle.comparing {
            fill: #3498db;
            animation: pulse 0.5s infinite alternate;
        }

        .node-circle.violating {
            fill: #e74c3c;
        }

        .node-circle.correct {
            fill: #2ecc71;
        }

        .node-circle.extracting {
            fill: #f39c12;
        }

        .node-circle.sorted {
            fill: #95a5a6;
            stroke: #7f8c8d;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .node-text {
            fill: #1d1d1f;
            text-anchor: middle;
            dominant-baseline: middle;
            font-weight: 600;
            pointer-events: none;
        }

        .edge {
            stroke: #86868b;
            stroke-width: 2;
            fill: none;
        }

        .array-view {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 16px;
        }

        .array-element {
            width: 50px;
            height: 50px;
            border: 2px solid #007aff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            background-color: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-element.comparing {
            background-color: #3498db;
            color: white;
            transform: translateY(-5px);
        }

        .array-element.violating {
            background-color: #e74c3c;
            color: white;
        }

        .array-element.correct {
            background-color: #2ecc71;
            color: white;
        }

        .array-element.extracting {
            background-color: #f39c12;
            color: white;
        }

        .array-element.sorted {
            background-color: #95a5a6;
            color: white;
            border-color: #7f8c8d;
        }

        .index-label {
            position: absolute;
            bottom: -20px;
            font-size: 12px;
            color: #86868b;
        }

        .status {
            text-align: center;
            font-size: 18px;
            color: #1d1d1f;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sorted-array {
            display: flex;
            gap: 8px;
            justify-content: center;
            min-height: 50px;
            align-items: center;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tree-container {
                height: 300px;
            }

            .array-element {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            button {
                padding: 8px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Heap Sort Visualizer</h1>
        
        <div class="section input-section">
            <div class="input-group">
                <input type="number" id="input0" placeholder="0" min="0" max="99">
                <input type="number" id="input1" placeholder="0" min="0" max="99">
                <input type="number" id="input2" placeholder="0" min="0" max="99">
                <input type="number" id="input3" placeholder="0" min="0" max="99">
                <input type="number" id="input4" placeholder="0" min="0" max="99">
            </div>
            <button onclick="generateRandom()">Generate Random</button>
            <button onclick="startHeapSort()" id="startBtn">Start Heap Sort</button>
            <button onclick="reset()">Reset</button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5">
            </div>
        </div>

        <div class="section">
            <div class="controls">
                <button onclick="stepBackward()" id="prevBtn">◀◀</button>
                <button onclick="previousStep()" id="stepBackBtn">◀</button>
                <button onclick="togglePlay()" id="playBtn">▶</button>
                <button onclick="nextStep()" id="stepForwardBtn">▶</button>
                <button onclick="stepForward()" id="nextBtn">▶▶</button>
            </div>
        </div>

        <div class="section">
            <div class="tree-container">
                <svg class="tree-svg" id="treeSvg"></svg>
            </div>
        </div>

        <div class="section">
            <div class="array-view" id="arrayView"></div>
            <div class="status" id="status">Enter values and click "Start Heap Sort" to begin</div>
        </div>

        <div class="section">
            <div style="text-align: center; margin-bottom: 8px; font-weight: 600;">Sorted Array:</div>
            <div class="sorted-array" id="sortedArray"></div>
        </div>
    </div>

    <script>
        let array = [];
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let playInterval = null;

        function generateRandom() {
            for (let i = 0; i < 5; i++) {
                const value = Math.floor(Math.random() * 50) + 1;
                document.getElementById(`input${i}`).value = value;
            }
        }

        function getInputValues() {
            const values = [];
            for (let i = 0; i < 5; i++) {
                const input = document.getElementById(`input${i}`);
                const value = parseInt(input.value);
                if (!isNaN(value)) {
                    values.push(value);
                }
            }
            return values;
        }

        function reset() {
            array = [];
            steps = [];
            currentStep = 0;
            isPlaying = false;
            clearInterval(playInterval);
            document.getElementById('playBtn').textContent = '▶';
            updateButtons();
            renderArray();
            renderTree();
            document.getElementById('status').textContent = 'Enter values and click "Start Heap Sort" to begin';
            document.getElementById('sortedArray').innerHTML = '';
        }

        function startHeapSort() {
            array = getInputValues();
            if (array.length === 0) {
                alert('Please enter at least one value');
                return;
            }
            
            steps = [];
            currentStep = 0;
            generateHeapSortSteps();
            updateButtons();
            renderStep();
        }

        function generateHeapSortSteps() {
            const arr = [...array];
            const n = arr.length;
            
            // Record initial state
            steps.push({
                array: [...arr],
                sorted: [],
                status: 'Initial array',
                highlights: {}
            });

            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                heapify(arr, n, i, true);
            }

            // Extract elements from heap
            for (let i = n - 1; i > 0; i--) {
                // Record extraction
                steps.push({
                    array: [...arr],
                    sorted: [...arr.slice(n - (n - i - 1))],
                    status: `Extracting maximum element ${arr[0]} to position ${i}`,
                    highlights: { 0: 'extracting', [i]: 'extracting' }
                });

                // Swap
                [arr[0], arr[i]] = [arr[i], arr[0]];
                
                steps.push({
                    array: [...arr],
                    sorted: [...arr.slice(i)],
                    status: `Moved ${arr[i]} to sorted portion`,
                    highlights: { [i]: 'sorted' }
                });

                // Heapify root
                heapify(arr, i, 0, false);
            }

            // Final sorted state
            steps.push({
                array: [...arr],
                sorted: [...arr],
                status: 'Heap Sort completed! Array is now sorted.',
                highlights: Object.fromEntries(arr.map((_, i) => [i, 'sorted']))
            });
        }

        function heapify(arr, n, i, building) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            // Record comparison
            const highlights = { [i]: 'comparing' };
            if (left < n) highlights[left] = 'comparing';
            if (right < n) highlights[right] = 'comparing';

            steps.push({
                array: [...arr],
                sorted: building ? [] : [...arr.slice(n)],
                status: `${building ? 'Building heap: ' : ''}Comparing parent ${arr[i]} with children`,
                highlights
            });

            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }

            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }

            if (largest !== i) {
                steps.push({
                    array: [...arr],
                    sorted: building ? [] : [...arr.slice(n)],
                    status: `Swapping ${arr[i]} with ${arr[largest]} to maintain heap property`,
                    highlights: { [i]: 'violating', [largest]: 'violating' }
                });

                [arr[i], arr[largest]] = [arr[i], arr[largest]];

                steps.push({
                    array: [...arr],
                    sorted: building ? [] : [...arr.slice(n)],
                    status: `Swapped successfully`,
                    highlights: { [i]: 'correct', [largest]: 'correct' }
                });

                heapify(arr, n, largest, building);
            } else {
                steps.push({
                    array: [...arr],
                    sorted: building ? [] : [...arr.slice(n)],
                    status: `Heap property satisfied at position ${i}`,
                    highlights: { [i]: 'correct' }
                });
            }
        }

        function renderArray() {
            const container = document.getElementById('arrayView');
            container.innerHTML = '';
            
            array.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                element.id = `array-${index}`;
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'index-label';
                indexLabel.textContent = index;
                element.appendChild(indexLabel);
                
                container.appendChild(element);
            });
        }

        function renderTree() {
            const svg = document.getElementById('treeSvg');
            svg.innerHTML = '';
            
            if (array.length === 0) return;

            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const nodeRadius = 25;
            const levelHeight = 80;

            // Calculate positions
            const positions = [];
            const levels = Math.ceil(Math.log2(array.length + 1));
            
            for (let i = 0; i < array.length; i++) {
                const level = Math.floor(Math.log2(i + 1));
                const levelNodes = Math.pow(2, level);
                const indexInLevel = i - (levelNodes - 1);
                const xSpacing = width / (levelNodes + 1);
                
                positions.push({
                    x: xSpacing * (indexInLevel + 1),
                    y: 50 + level * levelHeight
                });
            }

            // Draw edges
            for (let i = 0; i < array.length; i++) {
                const leftChild = 2 * i + 1;
                const rightChild = 2 * i + 2;
                
                if (leftChild < array.length) {
                    const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    edge.setAttribute('class', 'edge');
                    edge.setAttribute('x1', positions[i].x);
                    edge.setAttribute('y1', positions[i].y);
                    edge.setAttribute('x2', positions[leftChild].x);
                    edge.setAttribute('y2', positions[leftChild].y);
                    svg.appendChild(edge);
                }
                
                if (rightChild < array.length) {
                    const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    edge.setAttribute('class', 'edge');
                    edge.setAttribute('x1', positions[i].x);
                    edge.setAttribute('y1', positions[i].y);
                    edge.setAttribute('x2', positions[rightChild].x);
                    edge.setAttribute('y2', positions[rightChild].y);
                    svg.appendChild(edge);
                }
            }

            // Draw nodes
            for (let i = 0; i < array.length; i++) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'node');
                g.setAttribute('id', `node-${i}`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'node-circle');
                circle.setAttribute('cx', positions[i].x);
                circle.setAttribute('cy', positions[i].y);
                circle.setAttribute('r', nodeRadius);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'node-text');
                text.setAttribute('x', positions[i].x);
                text.setAttribute('y', positions[i].y);
                text.textContent = array[i];

                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
            }
        }

        function renderStep() {
            if (steps.length === 0) return;
            
            const step = steps[currentStep];
            array = [...step.array];
            
            renderArray();
            renderTree();
            
            // Apply highlights
            for (const [index, type] of Object.entries(step.highlights)) {
                const arrayElement = document.getElementById(`array-${index}`);
                const nodeElement = document.querySelector(`#node-${index} .node-circle`);
                
                if (arrayElement) arrayElement.classList.add(type);
                if (nodeElement) nodeElement.classList.add(type);
            }
            
            // Update status
            document.getElementById('status').textContent = step.status;
            
            // Update sorted array
            const sortedContainer = document.getElementById('sortedArray');
            sortedContainer.innerHTML = '';
            step.sorted.forEach(value => {
                const element = document.createElement('div');
                element.className = 'array-element sorted';
                element.textContent = value;
                sortedContainer.appendChild(element);
            });
        }

        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                renderStep();
                updateButtons();
            }
        }

        function previousStep() {
            if (currentStep > 0) {
                currentStep--;
                renderStep();
                updateButtons();
            }
        }

        function stepForward() {
            currentStep = steps.length - 1;
            renderStep();
            updateButtons();
        }

        function stepBackward() {
            currentStep = 0;
            renderStep();
            updateButtons();
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            
            if (isPlaying) {
                playBtn.textContent = '⏸';
                const speed = 11 - parseInt(document.getElementById('speedSlider').value);
                playInterval = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        nextStep();
                    } else {
                        togglePlay();
                    }
                }, speed * 200);
            } else {
                playBtn.textContent = '▶';
                clearInterval(playInterval);
            }
            updateButtons();
        }

        function updateButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const stepBackBtn = document.getElementById('stepBackBtn');
            const stepForwardBtn = document.getElementById('stepForwardBtn');
            const nextBtn = document.getElementById('nextBtn');
            const startBtn = document.getElementById('startBtn');
            
            prevBtn.disabled = currentStep === 0 || isPlaying;
            stepBackBtn.disabled = currentStep === 0 || isPlaying;
            stepForwardBtn.disabled = currentStep === steps.length - 1 || isPlaying;
            nextBtn.disabled = currentStep === steps.length - 1 || isPlaying;
            startBtn.disabled = isPlaying;
        }

        // Initialize with random values
        generateRandom();
    </script>
</body>
</html>