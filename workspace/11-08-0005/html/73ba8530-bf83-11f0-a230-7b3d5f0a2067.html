<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            color: #333;
            padding: 24px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        h1 {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 16px;
        }
        
        .main-content {
            display: flex;
            gap: 24px;
            margin-bottom: 24px;
        }
        
        .control-panel {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 300px;
            flex-shrink: 0;
        }
        
        .tree-canvas {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex-grow: 1;
            min-height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        .rules-panel {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .input-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e8;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #ecf0f1;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #bdc3c7;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .checkbox-group {
            margin-bottom: 24px;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .stats {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .stat-item:last-child {
            margin-bottom: 0;
        }
        
        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .tree-svg {
            width: 100%;
            height: 100%;
            min-height: 450px;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .node-circle {
            transition: all 0.3s;
        }
        
        .node-red {
            fill: #e74c3c;
        }
        
        .node-black {
            fill: #2c3e50;
        }
        
        .node-nil {
            fill: #95a5a6;
        }
        
        .node-text {
            fill: white;
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        .edge {
            stroke: #bdc3c7;
            stroke-width: 2;
            fill: none;
        }
        
        .rule-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all 0.3s;
        }
        
        .rule-status {
            margin-right: 12px;
            font-size: 18px;
        }
        
        .rule-text {
            flex: 1;
        }
        
        .rule-satisfied {
            background: #d4edda;
        }
        
        .rule-violated {
            background: #f8d7da;
        }
        
        .step-info {
            position: absolute;
            top: 24px;
            right: 24px;
            background: #3498db;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s;
            max-width: 300px;
        }
        
        .step-info.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .node-hover {
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .node:hover .node-hover {
            opacity: 1;
        }
        
        @keyframes nodeInsert {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .new-node {
            animation: nodeInsert 0.5s ease-out;
        }
        
        @keyframes glow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(52, 152, 219, 0.5));
            }
            50% {
                filter: drop-shadow(0 0 15px rgba(52, 152, 219, 0.8));
            }
        }
        
        .highlighting {
            animation: glow 1s ease-in-out infinite;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Red-Black Tree Visualizer</h1>
            <p class="subtitle">Interactive demonstration of self-balancing binary search trees</p>
        </header>
        
        <div class="main-content">
            <div class="control-panel">
                <div class="input-group">
                    <label for="nodeValue">Insert Value:</label>
                    <input type="number" id="nodeValue" placeholder="Enter a number" min="0" max="999">
                </div>
                
                <div class="button-group">
                    <button class="btn-primary" onclick="insertNode()">Insert</button>
                    <button class="btn-secondary" onclick="insertRandom()">Random</button>
                </div>
                
                <button class="btn-danger" onclick="clearTree()" style="width: 100%; margin-bottom: 16px;">Clear Tree</button>
                
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="stepMode">
                        Step-by-step mode
                    </label>
                </div>
                
                <div class="stats">
                    <h3 style="margin-bottom: 12px; color: #2c3e50;">Tree Properties</h3>
                    <div class="stat-item">
                        <span>Total Nodes:</span>
                        <span class="stat-value" id="nodeCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Tree Height:</span>
                        <span class="stat-value" id="treeHeight">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Black Height:</span>
                        <span class="stat-value" id="blackHeight">0</span>
                    </div>
                </div>
            </div>
            
            <div class="tree-canvas">
                <svg class="tree-svg" id="treeSvg"></svg>
                <div class="step-info" id="stepInfo"></div>
            </div>
        </div>
        
        <div class="rules-panel">
            <h3 style="margin-bottom: 16px; color: #2c3e50;">Red-Black Tree Properties</h3>
            <div class="rule-item" id="rule1">
                <span class="rule-status">✓</span>
                <span class="rule-text"><strong>Property 1:</strong> Every node is either red or black</span>
            </div>
            <div class="rule-item" id="rule2">
                <span class="rule-status">✓</span>
                <span class="rule-text"><strong>Property 2:</strong> The root is black</span>
            </div>
            <div class="rule-item" id="rule3">
                <span class="rule-status">✓</span>
                <span class="rule-text"><strong>Property 3:</strong> All leaves (NIL) are black</span>
            </div>
            <div class="rule-item" id="rule4">
                <span class="rule-status">✓</span>
                <span class="rule-text"><strong>Property 4:</strong> If a node is red, both its children are black</span>
            </div>
            <div class="rule-item" id="rule5">
                <span class="rule-status">✓</span>
                <span class="rule-text"><strong>Property 5:</strong> All paths from a node to descendant leaves contain the same number of black nodes</span>
            </div>
        </div>
    </div>
    
    <script>
        class Node {
            constructor(value, color = 'red') {
                this.value = value;
                this.color = color;
                this.left = null;
                this.right = null;
                this.parent = null;
                this.x = 0;
                this.y = 0;
            }
        }
        
        class RedBlackTree {
            constructor() {
                this.root = null;
                this.nil = new Node(null, 'black');
                this.nodeCount = 0;
            }
            
            insert(value) {
                const newNode = new Node(value, 'red');
                this.nodeCount++;
                
                if (!this.root) {
                    this.root = newNode;
                    this.root.color = 'black';
                    return;
                }
                
                let current = this.root;
                let parent = null;
                
                while (current) {
                    parent = current;
                    if (value < current.value) {
                        if (!current.left) {
                            current.left = newNode;
                            break;
                        }
                        current = current.left;
                    } else {
                        if (!current.right) {
                            current.right = newNode;
                            break;
                        }
                        current = current.right;
                    }
                }
                
                newNode.parent = parent;
                this.fixInsertion(newNode);
            }
            
            fixInsertion(node) {
                while (node !== this.root && node.parent && node.parent.color === 'red') {
                    const parent = node.parent;
                    const grandparent = parent.parent;
                    
                    if (!grandparent) break;
                    
                    if (parent === grandparent.left) {
                        const uncle = grandparent.right;
                        
                        if (uncle && uncle.color === 'red') {
                            // Case 1: Uncle is red
                            parent.color = 'black';
                            uncle.color = 'black';
                            grandparent.color = 'red';
                            node = grandparent;
                        } else {
                            // Case 2: Uncle is black, node is right child
                            if (node === parent.right) {
                                node = parent;
                                this.rotateLeft(node);
                            }
                            // Case 3: Uncle is black, node is left child
                            node.parent.color = 'black';
                            node.parent.parent.color = 'red';
                            this.rotateRight(node.parent.parent);
                        }
                    } else {
                        const uncle = grandparent.left;
                        
                        if (uncle && uncle.color === 'red') {
                            // Case 1: Uncle is red
                            parent.color = 'black';
                            uncle.color = 'black';
                            grandparent.color = 'red';
                            node = grandparent;
                        } else {
                            // Case 2: Uncle is black, node is left child
                            if (node === parent.left) {
                                node = parent;
                                this.rotateRight(node);
                            }
                            // Case 3: Uncle is black, node is right child
                            node.parent.color = 'black';
                            node.parent.parent.color = 'red';
                            this.rotateLeft(node.parent.parent);
                        }
                    }
                }
                
                this.root.color = 'black';
            }
            
            rotateLeft(node) {
                const rightChild = node.right;
                node.right = rightChild.left;
                
                if (rightChild.left) {
                    rightChild.left.parent = node;
                }
                
                rightChild.parent = node.parent;
                
                if (!node.parent) {
                    this.root = rightChild;
                } else if (node === node.parent.left) {
                    node.parent.left = rightChild;
                } else {
                    node.parent.right = rightChild;
                }
                
                rightChild.left = node;
                node.parent = rightChild;
            }
            
            rotateRight(node) {
                const leftChild = node.left;
                node.left = leftChild.right;
                
                if (leftChild.right) {
                    leftChild.right.parent = node;
                }
                
                leftChild.parent = node.parent;
                
                if (!node.parent) {
                    this.root = leftChild;
                } else if (node === node.parent.right) {
                    node.parent.right = leftChild;
                } else {
                    node.parent.left = leftChild;
                }
                
                leftChild.right = node;
                node.parent = leftChild;
            }
            
            getHeight(node = this.root) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }
            
            getBlackHeight(node = this.root) {
                if (!node) return 1;
                const leftHeight = this.getBlackHeight(node.left);
                const rightHeight = this.getBlackHeight(node.right);
                return (node.color === 'black' ? 1 : 0) + Math.max(leftHeight, rightHeight);
            }
            
            checkProperties() {
                const results = {
                    rule1: true, // Every node is red or black (always true by design)
                    rule2: !this.root || this.root.color === 'black',
                    rule3: true, // NIL nodes are black (always true by design)
                    rule4: this.checkRedProperty(this.root),
                    rule5: this.checkBlackHeightProperty(this.root) !== -1
                };
                return results;
            }
            
            checkRedProperty(node) {
                if (!node) return true;
                
                if (node.color === 'red') {
                    if ((node.left && node.left.color === 'red') || 
                        (node.right && node.right.color === 'red')) {
                        return false;
                    }
                }
                
                return this.checkRedProperty(node.left) && this.checkRedProperty(node.right);
            }
            
            checkBlackHeightProperty(node) {
                if (!node) return 1;
                
                const leftHeight = this.checkBlackHeightProperty(node.left);
                const rightHeight = this.checkBlackHeightProperty(node.right);
                
                if (leftHeight === -1 || rightHeight === -1 || leftHeight !== rightHeight) {
                    return -1;
                }
                
                return (node.color === 'black' ? 1 : 0) + leftHeight;
            }
            
            clear() {
                this.root = null;
                this.nodeCount = 0;
            }
        }
        
        const tree = new RedBlackTree();
        
        function calculateNodePositions(node, x, y, level, minX, maxX) {
            if (!node) return;
            
            node.x = x;
            node.y = y;
            
            const horizontalSpacing = (maxX - minX) / Math.pow(2, level + 1);
            
            if (node.left) {
                calculateNodePositions(node.left, x - horizontalSpacing, y + 80, level + 1, minX, x);
            }
            
            if (node.right) {
                calculateNodePositions(node.right, x + horizontalSpacing, y + 80, level + 1, x, maxX);
            }
        }
        
        function drawTree() {
            const svg = document.getElementById('treeSvg');
            const svgRect = svg.getBoundingClientRect();
            svg.innerHTML = '';
            
            if (!tree.root) {
                updateStats();
                updateRules();
                return;
            }
            
            calculateNodePositions(tree.root, svgRect.width / 2, 50, 0, 0, svgRect.width);
            
            const edges = [];
            const nodes = [];
            
            function collectElements(node) {
                if (!node) return;
                
                if (node.left) {
                    edges.push({
                        x1: node.x,
                        y1: node.y,
                        x2: node.left.x,
                        y2: node.left.y
                    });
                    collectElements(node.left);
                }
                
                if (node.right) {
                    edges.push({
                        x1: node.x,
                        y1: node.y,
                        x2: node.right.x,
                        y2: node.right.y
                    });
                    collectElements(node.right);
                }
                
                nodes.push(node);
            }
            
            collectElements(tree.root);
            
            // Draw edges
            edges.forEach(edge => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'edge');
                path.setAttribute('d', `M ${edge.x1} ${edge.y1} L ${edge.x2} ${edge.y2}`);
                svg.appendChild(path);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'node');
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', `node-circle node-${node.color}`);
                circle.setAttribute('r', '20');
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'node-text');
                text.textContent = node.value;
                
                // Hover info
                const hoverG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                hoverG.setAttribute('class', 'node-hover');
                
                const hoverRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                hoverRect.setAttribute('x', '-40');
                hoverRect.setAttribute('y', '-50');
                hoverRect.setAttribute('width', '80');
                hoverRect.setAttribute('height', '25');
                hoverRect.setAttribute('rx', '4');
                hoverRect.setAttribute('fill', 'rgba(0,0,0,0.8)');
                
                const hoverText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hoverText.setAttribute('y', '-35');
                hoverText.setAttribute('text-anchor', 'middle');
                hoverText.setAttribute('fill', 'white');
                hoverText.setAttribute('font-size', '12');
                hoverText.textContent = `${node.color.toUpperCase()}`;
                
                hoverG.appendChild(hoverRect);
                hoverG.appendChild(hoverText);
                
                g.appendChild(circle);
                g.appendChild(text);
                g.appendChild(hoverG);
                
                svg.appendChild(g);
            });
            
            updateStats();
            updateRules();
        }
        
        function updateStats() {
            document.getElementById('nodeCount').textContent = tree.nodeCount;
            document.getElementById('treeHeight').textContent = tree.getHeight();
            document.getElementById('blackHeight').textContent = tree.getBlackHeight();
        }
        
        function updateRules() {
            const rules = tree.checkProperties();
            
            for (let i = 1; i <= 5; i++) {
                const ruleElement = document.getElementById(`rule${i}`);
                const satisfied = rules[`rule${i}`];
                
                ruleElement.className = satisfied ? 'rule-item rule-satisfied' : 'rule-item rule-violated';
                ruleElement.querySelector('.rule-status').textContent = satisfied ? '✓' : '✗';
            }
        }
        
        function showStepInfo(message) {
            const stepInfo = document.getElementById('stepInfo');
            stepInfo.textContent = message;
            stepInfo.classList.add('show');
            
            setTimeout(() => {
                stepInfo.classList.remove('show');
            }, 3000);
        }
        
        function insertNode() {
            const input = document.getElementById('nodeValue');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                input.style.borderColor = '#e74c3c';
                setTimeout(() => {
                    input.style.borderColor = '#e1e5e8';
                }, 1000);
                return;
            }
            
            tree.insert(value);
            input.value = '';
            
            drawTree();
            
            if (document.getElementById('stepMode').checked) {
                showStepInfo(`Inserted ${value}. Tree rebalanced if needed.`);
            }
            
            // Add animation to newly inserted node
            setTimeout(() => {
                const nodes = document.querySelectorAll('.node');
                if (nodes.length > 0) {
                    nodes[nodes.length - 1].classList.add('new-node');
                }
            }, 50);
        }
        
        function insertRandom() {
            const value = Math.floor(Math.random() * 100);
            document.getElementById('nodeValue').value = value;
            insertNode();
        }
        
        function clearTree() {
            tree.clear();
            drawTree();
            showStepInfo('Tree cleared');
        }
        
        // Event listeners
        document.getElementById('nodeValue').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                insertNode();
            }
        });
        
        window.addEventListener('resize', drawTree);
        
        // Initial draw
        drawTree();
    </script>
</body>
</html>