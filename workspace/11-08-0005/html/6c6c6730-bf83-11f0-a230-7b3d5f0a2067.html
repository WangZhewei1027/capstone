<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            flex: 1;
            padding: 24px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 24px;
            min-height: 600px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .control-panel, .info-panel {
                max-width: 600px;
                margin: 0 auto;
            }
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .control-panel h2, .info-panel h2 {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .tree-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        #treeCanvas {
            width: 100%;
            height: 600px;
            position: relative;
        }

        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }

        .node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.4);
        }

        .node.highlighting {
            animation: highlight 0.6s ease;
        }

        .node.inserting {
            animation: insertNode 0.5s ease;
            background: #27ae60;
        }

        .node.deleting {
            animation: deleteNode 0.5s ease forwards;
            background: #e74c3c;
        }

        @keyframes highlight {
            0%, 100% { background: #3498db; transform: scale(1); }
            50% { background: #f39c12; transform: scale(1.2); }
        }

        @keyframes insertNode {
            0% { opacity: 0; transform: scale(0); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes deleteNode {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        .edge {
            position: absolute;
            background: #bdc3c7;
            height: 2px;
            transform-origin: left center;
            z-index: 1;
        }

        .traversal-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 2px solid #ecf0f1;
        }

        .traversal-section h3 {
            font-size: 1.1em;
            margin-bottom: 16px;
            color: #2c3e50;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .info-label {
            font-weight: 500;
            color: #7f8c8d;
        }

        .info-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.95em;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .message.show {
            opacity: 1;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .traversal-result {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            min-height: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Binary Search Tree</h1>
            <p class="subtitle">Interactive Visualization & Operations</p>
        </header>

        <div class="main-content">
            <div class="control-panel panel">
                <h2>Controls</h2>
                
                <div class="input-group">
                    <label for="nodeValue">Node Value</label>
                    <input type="number" id="nodeValue" placeholder="Enter a number">
                </div>

                <button class="btn btn-primary" onclick="insertNode()">Insert Node</button>
                <button class="btn btn-secondary" onclick="searchNode()">Search Node</button>
                <button class="btn btn-success" onclick="generateRandom()">Random Tree</button>
                <button class="btn btn-danger" onclick="clearTree()">Clear Tree</button>

                <div class="traversal-section">
                    <h3>Tree Traversals</h3>
                    <button class="btn btn-secondary" onclick="traverseTree('inorder')">In-order</button>
                    <button class="btn btn-secondary" onclick="traverseTree('preorder')">Pre-order</button>
                    <button class="btn btn-secondary" onclick="traverseTree('postorder')">Post-order</button>
                </div>
            </div>

            <div class="tree-container">
                <div id="treeCanvas"></div>
            </div>

            <div class="info-panel panel">
                <h2>Tree Information</h2>
                
                <div id="messageArea"></div>

                <div class="info-item">
                    <span class="info-label">Total Nodes:</span>
                    <span class="info-value" id="nodeCount">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Tree Height:</span>
                    <span class="info-value" id="treeHeight">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Min Value:</span>
                    <span class="info-value" id="minValue">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Max Value:</span>
                    <span class="info-value" id="maxValue">-</span>
                </div>

                <div class="traversal-section">
                    <h3>Traversal Result</h3>
                    <div class="traversal-result" id="traversalResult">
                        Perform a traversal to see results
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
                this.element = null;
            }
        }

        class BST {
            constructor() {
                this.root = null;
                this.nodeCount = 0;
            }

            insert(value) {
                const newNode = new TreeNode(value);
                if (!this.root) {
                    this.root = newNode;
                } else {
                    this.insertNode(this.root, newNode);
                }
                this.nodeCount++;
                return newNode;
            }

            insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (!node.left) {
                        node.left = newNode;
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else {
                    if (!node.right) {
                        node.right = newNode;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }

            search(value) {
                return this.searchNode(this.root, value);
            }

            searchNode(node, value) {
                if (!node) return null;
                if (value === node.value) return node;
                if (value < node.value) return this.searchNode(node.left, value);
                return this.searchNode(node.right, value);
            }

            delete(value) {
                this.root = this.deleteNode(this.root, value);
                if (this.root !== null) this.nodeCount--;
            }

            deleteNode(node, value) {
                if (!node) return null;

                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                } else {
                    // Node to delete found
                    if (!node.left && !node.right) {
                        return null;
                    }
                    if (!node.left) {
                        return node.right;
                    }
                    if (!node.right) {
                        return node.left;
                    }

                    // Node with two children
                    const minRight = this.findMin(node.right);
                    node.value = minRight.value;
                    node.right = this.deleteNode(node.right, minRight.value);
                }
                return node;
            }

            findMin(node) {
                while (node.left) {
                    node = node.left;
                }
                return node;
            }

            findMax(node) {
                while (node.right) {
                    node = node.right;
                }
                return node;
            }

            getHeight(node = this.root) {
                if (!node) return 0;
                return 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
            }

            inorder(node = this.root, result = []) {
                if (node) {
                    this.inorder(node.left, result);
                    result.push(node.value);
                    this.inorder(node.right, result);
                }
                return result;
            }

            preorder(node = this.root, result = []) {
                if (node) {
                    result.push(node.value);
                    this.preorder(node.left, result);
                    this.preorder(node.right, result);
                }
                return result;
            }

            postorder(node = this.root, result = []) {
                if (node) {
                    this.postorder(node.left, result);
                    this.postorder(node.right, result);
                    result.push(node.value);
                }
                return result;
            }
        }

        // Global variables
        let bst = new BST();
        const canvas = document.getElementById('treeCanvas');
        let animationInProgress = false;

        // Initialize
        document.getElementById('nodeValue').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') insertNode();
        });

        function showMessage(message, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            const msgElement = document.createElement('div');
            msgElement.className = `message ${type}`;
            msgElement.textContent = message;
            messageArea.innerHTML = '';
            messageArea.appendChild(msgElement);
            
            setTimeout(() => msgElement.classList.add('show'), 10);
            setTimeout(() => {
                msgElement.classList.remove('show');
                setTimeout(() => msgElement.remove(), 300);
            }, 3000);
        }

        function updateInfo() {
            document.getElementById('nodeCount').textContent = bst.nodeCount;
            document.getElementById('treeHeight').textContent = bst.getHeight();
            
            if (bst.root) {
                const minNode = bst.findMin(bst.root);
                const maxNode = bst.findMax(bst.root);
                document.getElementById('minValue').textContent = minNode.value;
                document.getElementById('maxValue').textContent = maxNode.value;
            } else {
                document.getElementById('minValue').textContent = '-';
                document.getElementById('maxValue').textContent = '-';
            }
        }

        function insertNode() {
            if (animationInProgress) return;
            
            const input = document.getElementById('nodeValue');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                showMessage('Please enter a valid number', 'error');
                return;
            }

            if (bst.search(value)) {
                showMessage(`Value ${value} already exists in the tree`, 'error');
                return;
            }

            animationInProgress = true;
            const newNode = bst.insert(value);
            renderTree();
            
            // Animate the new node
            setTimeout(() => {
                if (newNode.element) {
                    newNode.element.classList.add('inserting');
                    setTimeout(() => {
                        newNode.element.classList.remove('inserting');
                        animationInProgress = false;
                    }, 500);
                }
            }, 100);

            showMessage(`Inserted ${value} into the tree`, 'success');
            input.value = '';
            updateInfo();
        }

        function searchNode() {
            if (animationInProgress) return;
            
            const input = document.getElementById('nodeValue');
            const value = parseInt(input.value);
            
            if (isNaN(value)) {
                showMessage('Please enter a valid number', 'error');
                return;
            }

            animationInProgress = true;
            const path = [];
            let current = bst.root;
            
            while (current) {
                path.push(current);
                if (value === current.value) break;
                current = value < current.value ? current.left : current.right;
            }

            // Animate the search path
            path.forEach((node, index) => {
                setTimeout(() => {
                    if (node.element) {
                        node.element.classList.add('highlighting');
                        setTimeout(() => {
                            node.element.classList.remove('highlighting');
                        }, 600);
                    }
                }, index * 300);
            });

            setTimeout(() => {
                if (current && current.value === value) {
                    showMessage(`Found ${value} in the tree!`, 'success');
                } else {
                    showMessage(`Value ${value} not found in the tree`, 'error');
                }
                animationInProgress = false;
            }, path.length * 300);
        }

        function deleteNodeByClick(value) {
            if (animationInProgress) return;
            
            animationInProgress = true;
            const node = bst.search(value);
            
            if (node && node.element) {
                node.element.classList.add('deleting');
                setTimeout(() => {
                    bst.delete(value);
                    renderTree();
                    updateInfo();
                    showMessage(`Deleted ${value} from the tree`, 'success');
                    animationInProgress = false;
                }, 500);
            }
        }

        function clearTree() {
            if (animationInProgress) return;
            
            bst = new BST();
            renderTree();
            updateInfo();
            showMessage('Tree cleared', 'info');
            document.getElementById('traversalResult').textContent = 'Perform a traversal to see results';
        }

        function generateRandom() {
            if (animationInProgress) return;
            
            clearTree();
            const count = Math.floor(Math.random() * 7) + 5; // 5-11 nodes
            const values = new Set();
            
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100) + 1);
            }
            
            values.forEach(value => bst.insert(value));
            renderTree();
            updateInfo();
            showMessage(`Generated random tree with ${count} nodes`, 'success');
        }

        function traverseTree(type) {
            if (animationInProgress || !bst.root) return;
            
            animationInProgress = true;
            let result = [];
            let sequence = [];

            // Collect nodes in traversal order
            switch(type) {
                case 'inorder':
                    collectInorder(bst.root, sequence);
                    result = bst.inorder();
                    break;
                case 'preorder':
                    collectPreorder(bst.root, sequence);
                    result = bst.preorder();
                    break;
                case 'postorder':
                    collectPostorder(bst.root, sequence);
                    result = bst.postorder();
                    break;
            }

            // Animate nodes in sequence
            sequence.forEach((node, index) => {
                setTimeout(() => {
                    if (node.element) {
                        node.element.classList.add('highlighting');
                        setTimeout(() => {
                            node.element.classList.remove('highlighting');
                        }, 600);
                    }
                }, index * 400);
            });

            setTimeout(() => {
                document.getElementById('traversalResult').textContent = result.join(' â†’ ');
                animationInProgress = false;
            }, sequence.length * 400);
        }

        function collectInorder(node, sequence) {
            if (node) {
                collectInorder(node.left, sequence);
                sequence.push(node);
                collectInorder(node.right, sequence);
            }
        }

        function collectPreorder(node, sequence) {
            if (node) {
                sequence.push(node);
                collectPreorder(node.left, sequence);
                collectPreorder(node.right, sequence);
            }
        }

        function collectPostorder(node, sequence) {
            if (node) {
                collectPostorder(node.left, sequence);
                collectPostorder(node.right, sequence);
                sequence.push(node);
            }
        }

        function calculateNodePositions(node, x, y, horizontalSpacing) {
            if (!node) return;
            
            node.x = x;
            node.y = y;
            
            const spacing = horizontalSpacing / 2;
            
            if (node.left) {
                calculateNodePositions(node.left, x - spacing, y + 80, spacing);
            }
            
            if (node.right) {
                calculateNodePositions(node.right, x + spacing, y + 80, spacing);
            }
        }

        function renderTree() {
            canvas.innerHTML = '';
            
            if (!bst.root) return;
            
            const canvasWidth = canvas.offsetWidth;
            const initialSpacing = canvasWidth / 4;
            
            calculateNodePositions(bst.root, canvasWidth / 2, 60, initialSpacing);
            
            // Draw edges first
            drawEdges(bst.root);
            
            // Draw nodes
            drawNodes(bst.root);
        }

        function drawEdges(node) {
            if (!node) return;
            
            if (node.left) {
                drawEdge(node.x, node.y, node.left.x, node.left.y);
                drawEdges(node.left);
            }
            
            if (node.right) {
                drawEdge(node.x, node.y, node.right.x, node.right.y);
                drawEdges(node.right);
            }
        }

        function drawEdge(x1, y1, x2, y2) {
            const edge = document.createElement('div');
            edge.className = 'edge';
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
            
            edge.style.width = length + 'px';
            edge.style.left = x1 + 'px';
            edge.style.top = y1 + 'px';
            edge.style.transform = `rotate(${angle}deg)`;
            
            canvas.appendChild(edge);
        }

        function drawNodes(node) {
            if (!node) return;
            
            const element = document.createElement('div');
            element.className = 'node';
            element.textContent = node.value;
            element.style.left = (node.x - 25) + 'px';
            element.style.top = (node.y - 25) + 'px';
            element.onclick = () => deleteNodeByClick(node.value);
            
            node.element = element;
            canvas.appendChild(element);
            
            if (node.left) drawNodes(node.left);
            if (node.right) drawNodes(node.right);
        }

        // Initialize with a sample tree
        window.addEventListener('load', () => {
            [50, 30, 70, 20, 40, 60, 80].forEach(value => bst.insert(value));
            renderTree();
            updateInfo();
            showMessage('Click on any node to delete it!', 'info');
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (bst.root) renderTree();
        });
    </script>
</body>
</html>