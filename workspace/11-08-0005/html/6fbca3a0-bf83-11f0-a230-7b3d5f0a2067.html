<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find Interactive Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            color: #1a1a1a;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            padding: 24px;
            gap: 24px;
        }

        .header {
            grid-column: 1 / -1;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .header p {
            color: #5a6c7d;
            font-size: 1.1rem;
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 1.2rem;
            margin-bottom: 16px;
            color: #2c3e50;
        }

        .button {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #3498db;
            color: white;
        }

        .button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.secondary {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .button.secondary:hover {
            background: #d5dbdb;
        }

        .button.danger {
            background: #e74c3c;
        }

        .button.danger:hover {
            background: #c0392b;
        }

        .stats {
            margin-top: 24px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #5a6c7d;
        }

        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .canvas-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .info-panel {
            grid-column: 1 / -1;
            background: white;
            border-radius: 12px;
            padding: 16px 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            font-size: 1rem;
            color: #5a6c7d;
        }

        .mode-indicator {
            margin-bottom: 16px;
            padding: 8px 16px;
            background: #e3f2fd;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #1976d2;
        }

        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .node.selected {
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .edge {
            position: absolute;
            background: #7f8c8d;
            height: 3px;
            transform-origin: left center;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 5;
        }

        .edge.highlighted {
            background: #f39c12;
            height: 5px;
            z-index: 8;
        }

        .preset-section {
            margin-top: 24px;
        }

        .preset-button {
            margin-bottom: 8px;
            background: #9b59b6;
        }

        .preset-button:hover {
            background: #8e44ad;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto;
            }

            .sidebar {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Union-Find Data Structure</h1>
            <p>Click to create nodes • Select two nodes to union sets • Hover to find root</p>
        </div>

        <div class="sidebar">
            <h2>Controls</h2>
            <div class="mode-indicator" id="modeIndicator">
                Mode: Create Nodes
            </div>
            <button class="button" id="unionMode">Union Mode</button>
            <button class="button secondary" id="createMode">Create Mode</button>
            <button class="button danger" id="clearCanvas">Clear All</button>

            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Total Nodes:</span>
                    <span class="stat-value" id="nodeCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Disjoint Sets:</span>
                    <span class="stat-value" id="setCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Operations:</span>
                    <span class="stat-value" id="opCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max Tree Height:</span>
                    <span class="stat-value" id="maxHeight">0</span>
                </div>
            </div>

            <div class="preset-section">
                <h2>Presets</h2>
                <button class="button preset-button" id="preset1">Social Network</button>
                <button class="button preset-button" id="preset2">Connected Islands</button>
                <button class="button preset-button" id="preset3">Path Compression Demo</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="info-panel" id="infoPanel">
            Click on the canvas to create nodes, then switch to Union mode to connect them!
        </div>
    </div>

    <script>
        class UnionFind {
            constructor() {
                this.parent = new Map();
                this.rank = new Map();
                this.setColors = new Map();
                this.operations = 0;
            }

            makeSet(x) {
                this.parent.set(x, x);
                this.rank.set(x, 0);
                this.setColors.set(x, this.generateColor());
            }

            find(x, visualize = false) {
                this.operations++;
                if (this.parent.get(x) !== x) {
                    const path = [x];
                    let current = x;
                    
                    // Find root and collect path
                    while (this.parent.get(current) !== current) {
                        current = this.parent.get(current);
                        path.push(current);
                    }
                    
                    // Path compression
                    if (!visualize) {
                        for (let node of path.slice(0, -1)) {
                            this.parent.set(node, current);
                        }
                    }
                    
                    return current;
                }
                return x;
            }

            union(x, y) {
                this.operations++;
                const rootX = this.find(x);
                const rootY = this.find(y);

                if (rootX === rootY) return false;

                // Union by rank
                if (this.rank.get(rootX) < this.rank.get(rootY)) {
                    this.parent.set(rootX, rootY);
                    this.setColors.set(rootX, this.setColors.get(rootY));
                } else if (this.rank.get(rootX) > this.rank.get(rootY)) {
                    this.parent.set(rootY, rootX);
                    this.setColors.set(rootY, this.setColors.get(rootX));
                } else {
                    this.parent.set(rootY, rootX);
                    this.setColors.set(rootY, this.setColors.get(rootX));
                    this.rank.set(rootX, this.rank.get(rootX) + 1);
                }

                return true;
            }

            getSetMembers(x) {
                const root = this.find(x, true);
                const members = [];
                for (let [node, _] of this.parent) {
                    if (this.find(node, true) === root) {
                        members.push(node);
                    }
                }
                return members;
            }

            getHeight(x) {
                let height = 0;
                let current = x;
                while (this.parent.get(current) !== current) {
                    height++;
                    current = this.parent.get(current);
                }
                return height;
            }

            generateColor() {
                const hue = Math.random() * 360;
                return `hsl(${hue}, 70%, 60%)`;
            }
        }

        class Visualization {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = new Map();
                this.edges = [];
                this.uf = new UnionFind();
                this.mode = 'create';
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.animate();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;

                window.addEventListener('resize', () => {
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                });
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));

                document.getElementById('unionMode').addEventListener('click', () => {
                    this.mode = 'union';
                    this.updateModeIndicator();
                });

                document.getElementById('createMode').addEventListener('click', () => {
                    this.mode = 'create';
                    this.selectedNode = null;
                    this.updateModeIndicator();
                });

                document.getElementById('clearCanvas').addEventListener('click', () => {
                    this.clearAll();
                });

                document.getElementById('preset1').addEventListener('click', () => {
                    this.loadPreset('social');
                });

                document.getElementById('preset2').addEventListener('click', () => {
                    this.loadPreset('islands');
                });

                document.getElementById('preset3').addEventListener('click', () => {
                    this.loadPreset('compression');
                });
            }

            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.mode === 'create') {
                    this.createNode(x, y);
                } else if (this.mode === 'union') {
                    const clickedNode = this.getNodeAtPosition(x, y);
                    if (clickedNode) {
                        this.handleUnionClick(clickedNode);
                    }
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const hoveredNode = this.getNodeAtPosition(x, y);
                if (hoveredNode) {
                    this.canvas.style.cursor = 'pointer';
                    this.highlightSet(hoveredNode);
                } else {
                    this.canvas.style.cursor = this.mode === 'create' ? 'crosshair' : 'default';
                    this.clearHighlights();
                }
            }

            createNode(x, y) {
                // Check minimum spacing
                for (let [id, node] of this.nodes) {
                    const dist = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
                    if (dist < 66) return; // 50px node + 16px minimum spacing
                }

                const id = this.nodeIdCounter++;
                this.nodes.set(id, {
                    id,
                    x,
                    y,
                    vx: 0,
                    vy: 0,
                    highlighted: false
                });
                this.uf.makeSet(id);
                this.updateStats();
                this.updateInfo('Node created! Switch to Union mode to connect nodes.');
            }

            handleUnionClick(nodeId) {
                if (this.selectedNode === null) {
                    this.selectedNode = nodeId;
                    this.nodes.get(nodeId).selected = true;
                    this.updateInfo(`Selected node ${nodeId}. Click another node to union their sets.`);
                } else {
                    if (this.selectedNode !== nodeId) {
                        const success = this.uf.union(this.selectedNode, nodeId);
                        if (success) {
                            this.updateInfo(`Successfully united sets containing nodes ${this.selectedNode} and ${nodeId}!`);
                            this.animateUnion(this.selectedNode, nodeId);
                        } else {
                            this.updateInfo(`Nodes ${this.selectedNode} and ${nodeId} are already in the same set!`);
                        }
                    }
                    this.nodes.get(this.selectedNode).selected = false;
                    this.selectedNode = null;
                    this.updateStats();
                }
            }

            animateUnion(node1, node2) {
                // Visual feedback for union operation
                const n1 = this.nodes.get(node1);
                const n2 = this.nodes.get(node2);
                
                // Create temporary visual connection
                const dx = n2.x - n1.x;
                const dy = n2.y - n1.y;
                const steps = 30;
                let step = 0;
                
                const animate = () => {
                    step++;
                    if (step <= steps) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            highlightSet(nodeId) {
                const members = this.uf.getSetMembers(nodeId);
                for (let id of members) {
                    if (this.nodes.has(id)) {
                        this.nodes.get(id).highlighted = true;
                    }
                }
            }

            clearHighlights() {
                for (let [id, node] of this.nodes) {
                    node.highlighted = false;
                }
            }

            getNodeAtPosition(x, y) {
                for (let [id, node] of this.nodes) {
                    const dist = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
                    if (dist < 25) {
                        return id;
                    }
                }
                return null;
            }

            updateStats() {
                document.getElementById('nodeCount').textContent = this.nodes.size;
                document.getElementById('opCount').textContent = this.uf.operations;
                
                // Count disjoint sets
                const roots = new Set();
                for (let [id, _] of this.nodes) {
                    roots.add(this.uf.find(id, true));
                }
                document.getElementById('setCount').textContent = roots.size;
                
                // Calculate max height
                let maxHeight = 0;
                for (let [id, _] of this.nodes) {
                    maxHeight = Math.max(maxHeight, this.uf.getHeight(id));
                }
                document.getElementById('maxHeight').textContent = maxHeight;
            }

            updateModeIndicator() {
                const indicator = document.getElementById('modeIndicator');
                indicator.textContent = `Mode: ${this.mode === 'create' ? 'Create Nodes' : 'Union Sets'}`;
                indicator.style.background = this.mode === 'create' ? '#e3f2fd' : '#fff3cd';
                indicator.style.color = this.mode === 'create' ? '#1976d2' : '#856404';
            }

            updateInfo(message) {
                document.getElementById('infoPanel').textContent = message;
            }

            clearAll() {
                this.nodes.clear();
                this.edges = [];
                this.uf = new UnionFind();
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                this.updateStats();
                this.updateInfo('Canvas cleared. Click to create new nodes!');
            }

            loadPreset(type) {
                this.clearAll();
                
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                
                if (type === 'social') {
                    // Create social network groups
                    const groups = [
                        { x: cx - 200, y: cy - 100, count: 4 },
                        { x: cx + 200, y: cy - 100, count: 3 },
                        { x: cx, y: cy + 100, count: 5 }
                    ];
                    
                    groups.forEach((group, gi) => {
                        const nodes = [];
                        for (let i = 0; i < group.count; i++) {
                            const angle = (i / group.count) * Math.PI * 2;
                            const x = group.x + Math.cos(angle) * 60;
                            const y = group.y + Math.sin(angle) * 60;
                            this.createNode(x, y);
                            nodes.push(this.nodeIdCounter - 1);
                        }
                        
                        // Connect nodes within group
                        for (let i = 0; i < nodes.length - 1; i++) {
                            this.uf.union(nodes[i], nodes[i + 1]);
                        }
                    });
                    
                } else if (type === 'islands') {
                    // Create island-like clusters
                    for (let i = 0; i < 4; i++) {
                        const baseX = cx + (i - 1.5) * 150;
                        const baseY = cy + (i % 2 - 0.5) * 100;
                        const size = 3 + Math.floor(Math.random() * 3);
                        
                        const nodes = [];
                        for (let j = 0; j < size; j++) {
                            const x = baseX + (Math.random() - 0.5) * 80;
                            const y = baseY + (Math.random() - 0.5) * 80;
                            this.createNode(x, y);
                            nodes.push(this.nodeIdCounter - 1);
                        }
                        
                        // Randomly connect some nodes
                        for (let j = 0; j < size - 1; j++) {
                            if (Math.random() > 0.3) {
                                this.uf.union(nodes[j], nodes[j + 1]);
                            }
                        }
                    }
                    
                } else if (type === 'compression') {
                    // Create a long chain to demonstrate path compression
                    const count = 8;
                    const nodes = [];
                    
                    for (let i = 0; i < count; i++) {
                        const x = cx - 200 + i * 50;
                        const y = cy + Math.sin(i * 0.5) * 50;
                        this.createNode(x, y);
                        nodes.push(this.nodeIdCounter - 1);
                    }
                    
                    // Create a chain
                    for (let i = 0; i < nodes.length - 1; i++) {
                        this.uf.union(nodes[i], nodes[i + 1]);
                    }
                }
                
                this.updateStats();
                this.updateInfo('Preset loaded! Try different operations to explore the structure.');
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges (parent-child relationships)
                this.ctx.strokeStyle = '#7f8c8d';
                this.ctx.lineWidth = 3;
                
                for (let [id, node] of this.nodes) {
                    const parent = this.uf.parent.get(id);
                    if (parent !== id && this.nodes.has(parent)) {
                        const parentNode = this.nodes.get(parent);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(node.x, node.y);
                        this.ctx.lineTo(parentNode.x, parentNode.y);
                        
                        if (node.highlighted) {
                            this.ctx.strokeStyle = '#f39c12';
                            this.ctx.lineWidth = 5;
                        } else {
                            this.ctx.strokeStyle = '#7f8c8d';
                            this.ctx.lineWidth = 3;
                        }
                        
                        this.ctx.stroke();
                    }
                }
                
                // Draw nodes
                for (let [id, node] of this.nodes) {
                    const root = this.uf.find(id, true);
                    const color = this.uf.setColors.get(root) || '#3498db';
                    
                    // Node shadow
                    this.ctx.beginPath();
                    this.ctx.arc(node.x + 2, node.y + 2, 27, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fill();
                    
                    // Node circle
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                    
                    if (node.highlighted) {
                        this.ctx.strokeStyle = '#f39c12';
                        this.ctx.lineWidth = 4;
                        this.ctx.stroke();
                    }
                    
                    if (node.selected) {
                        this.ctx.strokeStyle = '#2c3e50';
                        this.ctx.lineWidth = 3;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                    
                    // Node label
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(id.toString(), node.x, node.y);
                }
            }

            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize visualization
        const viz = new Visualization();
    </script>
</body>
</html>