<!DOCTYPE html>
# Interactive Design Plan: Graph (Directed/Undirected)

## Concept Title
**"Understanding Directed vs Undirected Graphs Through Interactive Exploration"**

## Learning Objective
Users will understand the fundamental differences between directed and undirected graphs by:
- Visualizing how edges behave differently in each type
- Creating their own graph connections
- Observing how traversal patterns change between directed and undirected graphs
- Understanding real-world applications of each graph type

## Interaction Design

### User Interactions:
1. **Toggle Graph Type**: A prominent switch allows users to toggle between directed and undirected modes, instantly transforming the existing graph
2. **Add Nodes**: Click on empty canvas area to create new nodes with auto-generated labels (A, B, C...)
3. **Create Edges**: Click and drag from one node to another to create connections
4. **Delete Elements**: Right-click on nodes or edges to remove them
5. **Highlight Paths**: Hover over any node to highlight all reachable nodes from that starting point
6. **Interactive Examples**: Pre-built example buttons that demonstrate common graph patterns

### Visual Feedback:
- **Edge Animation**: In directed mode, edges display animated arrows showing direction flow
- **Bidirectional Indication**: In undirected mode, edges glow with a subtle pulse effect
- **Path Highlighting**: When hovering over a node, connected paths illuminate with a gradient effect
- **Mode Transition**: Smooth animation when switching between directed/undirected modes
- **Creation Feedback**: Nodes scale up slightly when created, edges draw progressively from start to end

## Layout Description

### Spatial Organization:

```
┌─────────────────────────────────────────────────────┐
│  24px margin                                        │
│  ┌───────────────────────────────────────────────┐ │
│  │  Header Section (80px height)                  │ │
│  │  - Title (left-aligned)                        │ │
│  │  - Mode Toggle Switch (right-aligned)          │ │
│  └───────────────────────────────────────────────┘ │
│                                                     │
│  ┌─────────────┬─────────────────────────────────┐ │
│  │ Control     │  Canvas Area                     │ │
│  │ Panel       │  (Interactive Graph)             │ │
│  │ (240px)     │                                  │ │
│  │             │  - Nodes as circles               │ │
│  │ - Examples  │  - Edges as lines/arrows         │ │
│  │ - Info      │  - Min 16px between elements     │ │
│  │ - Actions   │                                  │ │
│  └─────────────┴─────────────────────────────────┘ │
│                                                     │
│  24px margin                                        │
└─────────────────────────────────────────────────────┘
```

### Key Design Elements:
- **Safe Margins**: 24px padding on all viewport sides
- **Control Panel**: Fixed 240px width, contains examples and information
- **Canvas Area**: Flexible width, maintains 4:3 aspect ratio
- **Node Spacing**: Minimum 60px between node centers
- **Interactive Elements**: All buttons/controls have 16px minimum spacing
- **Responsive Design**: Canvas scales proportionally, controls stack vertically on mobile

Here's the complete interactive HTML implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Explorer: Directed vs Undirected</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            padding: 24px;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .header {
            height: 80px;
            padding: 0 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #e1e8ed;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 16px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 30px;
        }

        .mode-toggle label {
            font-size: 14px;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.directed {
            background: #48bb78;
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.directed .toggle-slider {
            transform: translateX(30px);
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .control-panel {
            width: 240px;
            padding: 24px;
            background: #f8fafc;
            border-right: 1px solid #e1e8ed;
        }

        .control-section {
            margin-bottom: 32px;
        }

        .control-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 16px;
        }

        .example-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            color: #4a5568;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .example-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .info-box {
            background: white;
            border-radius: 8px;
            padding: 16px;
            font-size: 13px;
            line-height: 1.6;
            color: #718096;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .instructions {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 16px 20px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            max-width: 300px;
        }

        .node-counter {
            position: absolute;
            top: 24px;
            right: 24px;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            .header {
                flex-direction: column;
                height: auto;
                padding: 20px;
                gap: 16px;
            }

            .main-content {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e1e8ed;
            }

            .instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Graph Explorer: Directed vs Undirected</h1>
            <div class="mode-toggle">
                <label>Undirected</label>
                <div class="toggle-switch" id="modeToggle">
                    <div class="toggle-slider"></div>
                </div>
                <label>Directed</label>
            </div>
        </div>
        
        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Examples</h3>
                    <button class="example-btn" onclick="loadExample('simple')">Simple Path</button>
                    <button class="example-btn" onclick="loadExample('cycle')">Cycle Graph</button>
                    <button class="example-btn" onclick="loadExample('tree')">Tree Structure</button>
                    <button class="example-btn" onclick="loadExample('complete')">Complete Graph</button>
                </div>
                
                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="example-btn" onclick="clearGraph()">Clear Graph</button>
                </div>
                
                <div class="control-section">
                    <h3>Current Mode</h3>
                    <div class="info-box">
                        <div id="modeInfo">
                            <strong>Undirected Graph:</strong><br>
                            Edges work both ways. If A connects to B, then B also connects to A.
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="canvas-area">
                <canvas id="graphCanvas"></canvas>
                <div class="node-counter" id="nodeCounter">Nodes: 0</div>
                <div class="instructions">
                    <strong>Instructions:</strong><br>
                    • Click to add nodes<br>
                    • Drag between nodes to connect<br>
                    • Right-click to delete<br>
                    • Hover to see paths
                </div>
            </div>
        </div>
    </div>

    <script>
        // Graph implementation
        class Graph {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.nodes = new Map();
                this.edges = [];
                this.isDirected = false;
                this.nodeIdCounter = 0;
                this.selectedNode = null;
                this.hoveredNode = null;
                this.dragStart = null;
                this.dragEnd = null;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.animate();
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    const rect = this.canvas.parentElement.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.draw();
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            setupEventListeners() {
                // Mode toggle
                const toggle = document.getElementById('modeToggle');
                toggle.addEventListener('click', () => {
                    this.isDirected = !this.isDirected;
                    toggle.classList.toggle('directed');
                    this.updateModeInfo();
                    this.draw();
                });

                // Mouse events
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredNode = null;
                    this.draw();
                });
            }

            updateModeInfo() {
                const infoBox = document.getElementById('modeInfo');
                if (this.isDirected) {
                    infoBox.innerHTML = `
                        <strong>Directed Graph:</strong><br>
                        Edges have direction. A→B doesn't mean B→A. Arrows show the direction of connections.
                    `;
                } else {
                    infoBox.innerHTML = `
                        <strong>Undirected Graph:</strong><br>
                        Edges work both ways. If A connects to B, then B also connects to A.
                    `;
                }
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedNode = this.getNodeAt(x, y);
                
                if (!clickedNode && !this.dragStart) {
                    this.addNode(x, y);
                }
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedNode = this.getNodeAt(x, y);
                if (clickedNode) {
                    this.dragStart = clickedNode;
                    e.preventDefault();
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const hoveredNode = this.getNodeAt(x, y);
                
                if (hoveredNode !== this.hoveredNode) {
                    this.hoveredNode = hoveredNode;
                    this.draw();
                }
                
                if (this.dragStart) {
                    this.dragEnd = { x, y };
                    this.canvas.style.cursor = 'pointer';
                    this.draw();
                } else if (hoveredNode) {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'crosshair';
                }
            }

            handleMouseUp(e) {
                if (this.dragStart) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const endNode = this.getNodeAt(x, y);
                    
                    if (endNode && endNode !== this.dragStart) {
                        this.addEdge(this.dragStart, endNode);
                    }
                    
                    this.dragStart = null;
                    this.dragEnd = null;
                    this.draw();
                }
            }

            handleRightClick(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedNode = this.getNodeAt(x, y);
                if (clickedNode) {
                    this.removeNode(clickedNode);
                } else {
                    const clickedEdge = this.getEdgeAt(x, y);
                    if (clickedEdge) {
                        this.removeEdge(clickedEdge);
                    }
                }
            }

            getNodeAt(x, y) {
                for (const [id, node] of this.nodes) {
                    const dist = Math.hypot(x - node.x, y - node.y);
                    if (dist <= 25) {
                        return id;
                    }
                }
                return null;
            }

            getEdgeAt(x, y) {
                for (let i = 0; i < this.edges.length; i++) {
                    const edge = this.edges[i];
                    const from = this.nodes.get(edge.from);
                    const to = this.nodes.get(edge.to);
                    
                    if (!from || !to) continue;
                    
                    const dist = this.pointToLineDistance(x, y, from.x, from.y, to.x, to.y);
                    if (dist < 10) {
                        return i;
                    }
                }
                return null;
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                
                return Math.sqrt(dx * dx + dy * dy);
            }

            addNode(x, y) {
                const label = String.fromCharCode(65 + this.nodeIdCounter % 26);
                const id = `node_${this.nodeIdCounter++}`;
                
                this.nodes.set(id, {
                    x,
                    y,
                    label,
                    scale: 0,
                    targetScale: 1
                });
                
                this.updateNodeCounter();
                this.draw();
            }

            removeNode(nodeId) {
                this.nodes.delete(nodeId);
                this.edges = this.edges.filter(edge => 
                    edge.from !== nodeId && edge.to !== nodeId
                );
                this.updateNodeCounter();
                this.draw();
            }

            addEdge(fromId, toId) {
                // Check if edge already exists
                const exists = this.edges.some(edge => 
                    (edge.from === fromId && edge.to === toId) ||
                    (!this.isDirected && edge.from === toId && edge.to === fromId)
                );
                
                if (!exists) {
                    this.edges.push({
                        from: fromId,
                        to: toId,
                        progress: 0,
                        targetProgress: 1
                    });
                }
                
                this.draw();
            }

            removeEdge(edgeIndex) {
                this.edges.splice(edgeIndex, 1);
                this.draw();
            }

            updateNodeCounter() {
                document.getElementById('nodeCounter').textContent = `Nodes: ${this.nodes.size}`;
            }

            getReachableNodes(startId) {
                const visited = new Set();
                const queue = [startId];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current)) continue;
                    
                    visited.add(current);
                    
                    this.edges.forEach(edge => {
                        if (edge.from === current && !visited.has(edge.to)) {
                            queue.push(edge.to);
                        }
                        if (!this.isDirected && edge.to === current && !visited.has(edge.from)) {
                            queue.push(edge.from);
                        }
                    });
                }
                
                return visited;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Get reachable nodes if hovering
                let reachableNodes = null;
                if (this.hoveredNode) {
                    reachableNodes = this.getReachableNodes(this.hoveredNode);
                }
                
                // Draw edges
                this.edges.forEach(edge => {
                    const from = this.nodes.get(edge.from);
                    const to = this.nodes.get(edge.to);
                    
                    if (!from || !to) return;
                    
                    const isHighlighted = reachableNodes && 
                        reachableNodes.has(edge.from) && 
                        reachableNodes.has(edge.to);
                    
                    this.drawEdge(from, to, edge, isHighlighted);
                });
                
                // Draw drag preview
                if (this.dragStart && this.dragEnd) {
                    const from = this.nodes.get(this.dragStart);
                    if (from) {
                        this.ctx.save();
                        this.ctx.strokeStyle = '#667eea';
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);
                        this.ctx.lineTo(this.dragEnd.x, this.dragEnd.y);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                
                // Draw nodes
                for (const [id, node] of this.nodes) {
                    const isHighlighted = reachableNodes && reachableNodes.has(id);
                    const isHovered = id === this.hoveredNode;
                    this.drawNode(node, isHighlighted, isHovered);
                }
            }

            drawNode(node, isHighlighted, isHovered) {
                const ctx = this.ctx;
                const radius = 25 * node.scale;
                
                // Shadow
                if (isHovered || isHighlighted) {
                    ctx.save();
                    ctx.shadowColor = isHovered ? 'rgba(102, 126, 234, 0.3)' : 'rgba(72, 187, 120, 0.3)';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = isHovered ? '#667eea' : '#48bb78';
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Node circle
                ctx.fillStyle = isHovered ? '#667eea' : (isHighlighted ? '#48bb78' : '#ffffff');
                ctx.strokeStyle = isHovered ? '#667eea' : (isHighlighted ? '#48bb78' : '#e2e8f0');
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Label
                ctx.fillStyle = isHovered || isHighlighted ? '#ffffff' : '#4a5568';
                ctx.font = `${16 * node.scale}px sans-serif`;
                ctx.fontWeight = '600';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);
            }

            drawEdge(from, to, edge, isHighlighted) {
                const ctx = this.ctx;
                
                // Calculate edge positions (account for node radius)
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const fromX = from.x + Math.cos(angle) * 25;
                const fromY = from.y + Math.sin(angle) * 25;
                const toX = to.x - Math.cos(angle) * 25;
                const toY = to.y - Math.sin(angle) * 25;
                
                // Edge style
                ctx.strokeStyle = isHighlighted ? '#48bb78' : '#cbd5e0';
                ctx.lineWidth = isHighlighted ? 3 : 2;
                
                if (this.isDirected) {
                    // Draw arrow
                    const headLength = 15;
                    const progress = edge.progress;
                    
                    // Animated line
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    const currentX = fromX + (toX - fromX) * progress;
                    const currentY = fromY + (toY - fromY) * progress;
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    
                    if (progress > 0.5) {
                        // Arrowhead
                        ctx.save();
                        ctx.translate(toX, toY);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(-headLength, -headLength / 2);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-headLength, headLength / 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                } else {
                    // Simple line for undirected
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();
                    
                    // Pulse effect for highlighted edges
                    if (isHighlighted) {
                        ctx.save();
                        ctx.globalAlpha = 0.3 + 0.3 * Math.sin(Date.now() * 0.003);
                        ctx.lineWidth = 6;
                        ctx.strokeStyle = '#48bb78';
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            animate() {
                // Animate node scales
                for (const [id, node] of this.nodes) {
                    if (node.scale < node.targetScale) {
                        node.scale = Math.min(node.scale + 0.1, node.targetScale);
                        this.draw();
                    }
                }
                
                // Animate edge progress
                this.edges.forEach(edge => {
                    if (edge.progress < edge.targetProgress) {
                        edge.progress = Math.min(edge.progress + 0.05, edge.targetProgress);
                        this.draw();
                    }
                });
                
                requestAnimationFrame(() => this.animate());
            }

            clearGraph() {
                this.nodes.clear();
                this.edges = [];
                this.nodeIdCounter = 0;
                this.updateNodeCounter();
                this.draw();
            }

            loadExample(type) {
                this.clearGraph();
                
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                
                switch (type) {
                    case 'simple':
                        // Simple path A -> B -> C -> D
                        this.addNode(cx - 150, cy);
                        this.addNode(cx - 50, cy);
                        this.addNode(cx + 50, cy);
                        this.addNode(cx + 150, cy);
                        
                        setTimeout(() => {
                            this.addEdge('node_0', 'node_1');
                            this.addEdge('node_1', 'node_2');
                            this.addEdge('node_2', 'node_3');
                        }, 300);
                        break;
                        
                    case 'cycle':
                        // Circular cycle
                        const radius = 100;
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                            this.addNode(
                                cx + Math.cos(angle) * radius,
                                cy + Math.sin(angle) * radius
                            );
                        }
                        
                        setTimeout(() => {
                            for (let i = 0; i < 5; i++) {
                                this.addEdge(`node_${i}`, `node_${(i + 1) % 5}`);
                            }
                        }, 300);
                        break;
                        
                    case 'tree':
                        // Binary tree
                        this.addNode(cx, cy - 100);      // Root
                        this.addNode(cx - 80, cy);       // Left child
                        this.addNode(cx + 80, cy);       // Right child
                        this.addNode(cx - 120, cy + 100); // Left-left
                        this.addNode(cx - 40, cy + 100);  // Left-right
                        this.addNode(cx + 40, cy + 100);  // Right-left
                        this.addNode(cx + 120, cy + 100); // Right-right
                        
                        setTimeout(() => {
                            this.addEdge('node_0', 'node_1');
                            this.addEdge('node_0', 'node_2');
                            this.addEdge('node_1', 'node_3');
                            this.addEdge('node_1', 'node_4');
                            this.addEdge('node_2', 'node_5');
                            this.addEdge('node_2', 'node_6');
                        }, 300);
                        break;
                        
                    case 'complete':
                        // Complete graph K4
                        const positions = [
                            [cx - 60, cy - 60],
                            [cx + 60, cy - 60],
                            [cx + 60, cy + 60],
                            [cx - 60, cy + 60]
                        ];
                        
                        positions.forEach(([x, y]) => this.addNode(x, y));
                        
                        setTimeout(() => {
                            for (let i = 0; i < 4; i++) {
                                for (let j = i + 1; j < 4; j++) {
                                    this.addEdge(`node_${i}`, `node_${j}`);
                                }
                            }
                        }, 300);
                        break;
                }
            }
        }

        // Initialize the graph
        const